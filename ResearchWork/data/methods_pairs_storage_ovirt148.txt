902
#method_before
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#method_after
private static void addHostNetworksAndUpdateInterfaces(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Integer> networkVlans = new HashMap<String, Integer>();
    // Networks collection (name point to list of nics or bonds)
    Map<String, Object> networks = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORKS);
    if (networks != null) {
        vds.getNetworks().clear();
        for (Entry<String, Object> entry : networks.entrySet()) {
            Map<String, Object> network = (Map<String, Object>) entry.getValue();
            if (network != null) {
                Network net = createNetworkData(entry.getKey(), network);
                List<VdsNetworkInterface> interfaces = findNetworkInterfaces(vds, xmlRpcStruct, network);
                for (VdsNetworkInterface iface : interfaces) {
                    updateNetworkDetailsInInterface(iface, network, vds, net);
                }
                vds.getNetworks().add(net);
                reportInvalidInterfacesForNetwork(interfaces, net, vds);
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostNicPopupPresenterWidget.class, HostNicPopupPresenterWidget.ViewDef.class, HostNicPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
}
#end_block

#method_before
void saveConnectAutomatically(UserPortalLoginModel loginModel) {
    Boolean isAutoconnect = (Boolean) loginModel.getIsAutoConnect().getEntity();
    connectAutomaticallyProvider.storeConnectAutomatically(isAutoconnect);
}
#method_after
void saveConnectAutomatically(UserPortalLoginModel loginModel) {
    Boolean isAutoconnect = loginModel.getIsAutoConnect().getEntity();
    connectAutomaticallyProvider.storeConnectAutomatically(isAutoconnect);
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    final T loginModel = getView().flush();
    // Set up model command invoker
    this.modelCommandInvoker = new DeferredModelCommandInvoker(loginModel) {

        @Override
        protected void executeCommand(UICommand command) {
            if (command == loginModel.getLoginCommand()) {
                beforeLoginCommandExecuted(loginModel);
            }
            super.executeCommand(command);
        }
    };
    loginModel.getLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            onLoggedInEvent(loginModel);
        }
    });
    loginModel.getLoginFailedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            lockInteractionManager.hideLoadingIndicator();
            formatAndSetErrorMessage(loginModel.getMessage());
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warning("Login failed for user [" + loginModel.getUserName().getEntity() + "]");
        }
    });
    getView().getLoginButton().setCommand(loginModel.getLoginCommand());
    registerHandler(getView().getLoginButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            modelCommandInvoker.invokeDefaultCommand();
        }
    }));
    registerHandler(getView().getLoginForm().addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                modelCommandInvoker.invokeDefaultCommand();
            }
        }
    }));
    // Update selected domain after domain items have been set
    loginModel.getDomain().getPropertyChangedEvent().addListener(new IEventListener() {

        @SuppressWarnings("unchecked")
        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!"Items".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                return;
            }
            String previouslySelectedItem = clientStorage.getLocalItem(getSelectedDomainKey());
            if (previouslySelectedItem == null || "".equals(previouslySelectedItem)) {
                // $NON-NLS-1$
                return;
            }
            for (String item : (Iterable<String>) loginModel.getDomain().getItems()) {
                if (previouslySelectedItem.equals(item)) {
                    loginModel.getDomain().setSelectedItem(item);
                    break;
                }
            }
        }
    });
}
#method_after
@Override
protected void onBind() {
    super.onBind();
    final T loginModel = getView().flush();
    // Set up model command invoker
    this.modelCommandInvoker = new DeferredModelCommandInvoker(loginModel) {

        @Override
        protected void executeCommand(UICommand command) {
            if (command == loginModel.getLoginCommand()) {
                beforeLoginCommandExecuted(loginModel);
            }
            super.executeCommand(command);
        }
    };
    loginModel.getLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            onLoggedInEvent(loginModel);
        }
    });
    loginModel.getLoginFailedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            lockInteractionManager.hideLoadingIndicator();
            formatAndSetErrorMessage(loginModel.getMessage());
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warning("Login failed for user [" + loginModel.getUserName().getEntity() + "]");
        }
    });
    getView().getLoginButton().setCommand(loginModel.getLoginCommand());
    registerHandler(getView().getLoginButton().addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            modelCommandInvoker.invokeDefaultCommand();
        }
    }));
    registerHandler(getView().getLoginForm().addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                modelCommandInvoker.invokeDefaultCommand();
            }
        }
    }));
    // Update selected domain after domain items have been set
    loginModel.getDomain().getPropertyChangedEvent().addListener(new IEventListener() {

        @SuppressWarnings("unchecked")
        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!"Items".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                return;
            }
            String previouslySelectedItem = clientStorage.getLocalItem(getSelectedDomainKey());
            if (previouslySelectedItem == null || "".equals(previouslySelectedItem)) {
                // $NON-NLS-1$
                return;
            }
            for (String item : loginModel.getDomain().getItems()) {
                if (previouslySelectedItem.equals(item)) {
                    loginModel.getDomain().setSelectedItem(item);
                    break;
                }
            }
        }
    });
}
#end_block

#method_before
void saveSelectedDomain(T loginModel) {
    String selectedItem = (String) loginModel.getDomain().getSelectedItem();
    if (selectedItem == null || "".equals(selectedItem)) {
        // $NON-NLS-1$
        return;
    }
    clientStorage.setLocalItem(getSelectedDomainKey(), selectedItem);
}
#method_after
void saveSelectedDomain(T loginModel) {
    String selectedItem = loginModel.getDomain().getSelectedItem();
    if (selectedItem == null || "".equals(selectedItem)) {
        // $NON-NLS-1$
        return;
    }
    clientStorage.setLocalItem(getSelectedDomainKey(), selectedItem);
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSessionsPresenter.class, SubTabExtendedVmSessionsPresenter.ViewDef.class, SubTabExtendedVmSessionsView.class, SubTabExtendedVmSessionsPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateNewPopupPresenterWidget.class, TemplateNewPopupPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginFormPresenterWidget.class, LoginFormPresenterWidget.ViewDef.class, LoginFormView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabBasicPresenter.class, MainTabBasicPresenter.ViewDef.class, MainTabBasicView.class, MainTabBasicPresenter.ProxyDef.class);
    bindPresenter(MainTabExtendedPresenter.class, MainTabExtendedPresenter.ViewDef.class, MainTabExtendedView.class, MainTabExtendedPresenter.ProxyDef.class);
    // Main section: side tabs
    bindPresenter(SideTabExtendedVirtualMachinePresenter.class, SideTabExtendedVirtualMachinePresenter.ViewDef.class, SideTabExtendedVirtualMachineView.class, SideTabExtendedVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedTemplatePresenter.class, SideTabExtendedTemplatePresenter.ViewDef.class, SideTabExtendedTemplateView.class, SideTabExtendedTemplatePresenter.ProxyDef.class);
    bindPresenter(SideTabExtendedResourcePresenter.class, SideTabExtendedResourcePresenter.ViewDef.class, SideTabExtendedResourceView.class, SideTabExtendedResourcePresenter.ProxyDef.class);
    // Main section: sub tabs
    // Virtual Machine
    bindPresenter(ExtendedVmSubTabPanelPresenter.class, ExtendedVmSubTabPanelPresenter.ViewDef.class, ExtendedVmSubTabPanelView.class, ExtendedVmSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmGeneralPresenter.class, SubTabExtendedVmGeneralPresenter.ViewDef.class, SubTabExtendedVmGeneralView.class, SubTabExtendedVmGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolGeneralPresenter.class, SubTabExtendedPoolGeneralPresenter.ViewDef.class, SubTabExtendedPoolGeneralView.class, SubTabExtendedPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmNetworkInterfacePresenter.class, SubTabExtendedVmNetworkInterfacePresenter.ViewDef.class, SubTabExtendedVmNetworkInterfaceView.class, SubTabExtendedVmNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolNetworkInterfacePresenter.class, SubTabExtendedPoolNetworkInterfacePresenter.ViewDef.class, SubTabExtendedPoolNetworkInterfaceView.class, SubTabExtendedPoolNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmVirtualDiskPresenter.class, SubTabExtendedVmVirtualDiskPresenter.ViewDef.class, SubTabExtendedVmVirtualDiskView.class, SubTabExtendedVmVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedPoolVirtualDiskPresenter.class, SubTabExtendedPoolVirtualDiskPresenter.ViewDef.class, SubTabExtendedPoolVirtualDiskView.class, SubTabExtendedPoolVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSnapshotPresenter.class, SubTabExtendedVmSnapshotPresenter.ViewDef.class, SubTabExtendedVmSnapshotView.class, SubTabExtendedVmSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmPermissionPresenter.class, SubTabExtendedVmPermissionPresenter.ViewDef.class, SubTabExtendedVmPermissionView.class, SubTabExtendedVmPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmEventPresenter.class, SubTabExtendedVmEventPresenter.ViewDef.class, SubTabExtendedVmEventView.class, SubTabExtendedVmEventPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmApplicationPresenter.class, SubTabExtendedVmApplicationPresenter.ViewDef.class, SubTabExtendedVmApplicationView.class, SubTabExtendedVmApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmMonitorPresenter.class, SubTabExtendedVmMonitorPresenter.ViewDef.class, SubTabExtendedVmMonitorView.class, SubTabExtendedVmMonitorPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedVmSessionsPresenter.class, SubTabExtendedVmSessionsPresenter.ViewDef.class, SubTabExtendedVmSessionsView.class, SubTabExtendedVmSessionsPresenter.ProxyDef.class);
    // Template
    bindPresenter(ExtendedTemplateSubTabPanelPresenter.class, ExtendedTemplateSubTabPanelPresenter.ViewDef.class, ExtendedTemplateSubTabPanelView.class, ExtendedTemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateGeneralPresenter.class, SubTabExtendedTemplateGeneralPresenter.ViewDef.class, SubTabExtendedTemplateGeneralView.class, SubTabExtendedTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateNetworkInterfacesPresenter.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ViewDef.class, SubTabExtendedTemplateNetworkInterfacesView.class, SubTabExtendedTemplateNetworkInterfacesPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateVirtualDisksPresenter.class, SubTabExtendedTemplateVirtualDisksPresenter.ViewDef.class, SubTabExtendedTemplateVirtualDisksView.class, SubTabExtendedTemplateVirtualDisksPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplateEventsPresenter.class, SubTabExtendedTemplateEventsPresenter.ViewDef.class, SubTabExtendedTemplateEventsView.class, SubTabExtendedTemplateEventsPresenter.ProxyDef.class);
    bindPresenter(SubTabExtendedTemplatePermissionsPresenter.class, SubTabExtendedTemplatePermissionsPresenter.ViewDef.class, SubTabExtendedTemplatePermissionsView.class, SubTabExtendedTemplatePermissionsPresenter.ProxyDef.class);
    // Main section: basic view
    bindSingletonPresenterWidget(MainTabBasicDetailsPresenterWidget.class, MainTabBasicDetailsPresenterWidget.ViewDef.class, MainTabBasicDetailsView.class);
    bindSingletonPresenterWidget(MainTabBasicListPresenterWidget.class, MainTabBasicListPresenterWidget.ViewDef.class, MainTabBasicListView.class);
    bindPresenterWidget(MainTabBasicListItemPresenterWidget.class, MainTabBasicListItemPresenterWidget.ViewDef.class, MainTabBasicListItemView.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // VM popups
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // Template popups
    bindPresenterWidget(TemplateNewPopupPresenterWidget.class, TemplateNewPopupPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
}
#end_block

#method_before
@Override
protected void setStyles() {
    super.setStyles();
    // $NON-NLS-1$
    connectAutomaticallyEditor.setContentWidgetContainerStyleName("connect-automatically-checkbox");
    // $NON-NLS-1$ //$NON-NLS-2$
    connectAutomaticallyEditor.getContentWidgetContainer().getElement().getStyle().setProperty("marginLeft", "6px");
    motdPanel.setVisible(false);
}
#method_after
@Override
protected void setStyles() {
    super.setStyles();
    // $NON-NLS-1$
    connectAutomaticallyEditor.setContentWidgetContainerStyleName("connect-automatically-checkbox");
    // $NON-NLS-1$
    connectAutomaticallyEditor.addContentWidgetContainerStyleName("connect-automatically-checkbox_pfly_fix");
    motdPanel.setVisible(false);
}
#end_block

#method_before
@Override
public void setFeedbackText(String feedbackText) {
    feedbackLink.setText(feedbackText);
}
#method_after
@Override
public void setFeedbackText(String feedbackText, String feedbackTitle) {
    feedbackLink.setText(feedbackText);
    if (feedbackTitle != null) {
        feedbackLink.setTitle(feedbackTitle);
    }
}
#end_block

#method_before
protected void setStyles() {
    userNameEditor.usePatternflyLoginStyles();
    passwordEditor.usePatternflyLoginStyles();
    domainEditor.usePatternflyLoginStyles();
    errorMessagePanel.setVisible(false);
    informationMessagePanel.setVisible(false);
    // $NON-NLS-1$
    passwordEditor.setAutoComplete("off");
}
#method_after
protected void setStyles() {
    errorMessagePanel.setVisible(false);
    informationMessagePanel.setVisible(false);
    // $NON-NLS-1$
    passwordEditor.setAutoComplete("off");
}
#end_block

#method_before
@Override
public List<VDSGroup> getAllWithQuery(String query) {
    List<VDSGroup> groups = jdbcTemplate.query(query, VdsGroupRowMapper.instance);
    try {
        // The UI requires the host and vm count
        return getHostsAndVmsForClusters(groups);
    } catch (Exception e) {
        log.error("Can't load host and vm count for vds group for query " + query, e);
    }
    return groups;
}
#method_after
@Override
public List<VDSGroup> getAllWithQuery(String query) {
    List<VDSGroup> groups = jdbcTemplate.query(query, VdsGroupRowMapper.instance);
    try {
        // The UI requires the host and vm count
        return getHostsAndVmsForClusters(groups);
    } catch (Exception e) {
        log.error("Can't load host and vm count for cluster. Query is " + query, e);
    }
    return groups;
}
#end_block

#method_before
protected List<VDSGroup> getHostsAndVmsForClusters(List<VDSGroup> vdsGroups) throws Exception {
    Map<Guid, VDSGroup> groupsById = new HashMap<>();
    for (VDSGroup vdsGroup : vdsGroups) {
        groupsById.put(vdsGroup.getId(), vdsGroup);
    }
    Array groups = jdbcTemplate.getDataSource().getConnection().createArrayOf("uuid", groupsById.keySet().toArray());
    List<VDSGroupHostsAndVMs> dataList = getCallsHandler().executeReadList("GetHostsAndVmsForClusters", VDSGroupHostsAndVMsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_ids", groups));
    for (VDSGroupHostsAndVMs groupDetail : dataList) {
        groupsById.get(groupDetail.getVdsGroupId()).setGroupHostsAndVms(groupDetail);
    }
    return new ArrayList<VDSGroup>(groupsById.values());
}
#method_after
protected List<VDSGroup> getHostsAndVmsForClusters(List<VDSGroup> vdsGroups) throws Exception {
    Map<Guid, VDSGroup> groupsById = new HashMap<>();
    for (VDSGroup vdsGroup : vdsGroups) {
        groupsById.put(vdsGroup.getId(), vdsGroup);
    }
    Connection c = jdbcTemplate.getDataSource().getConnection();
    Array groups = c.createArrayOf("uuid", groupsById.keySet().toArray());
    List<VDSGroupHostsAndVMs> dataList = getCallsHandler().executeReadList("GetHostsAndVmsForClusters", VDSGroupHostsAndVMsRowMapper.instance, getCustomMapSqlParameterSource().addValue("vds_group_ids", groups));
    c.close();
    for (VDSGroupHostsAndVMs groupDetail : dataList) {
        groupsById.get(groupDetail.getVdsGroupId()).setGroupHostsAndVms(groupDetail);
    }
    return new ArrayList<VDSGroup>(groupsById.values());
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VDSGroup> nameColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameCluster(), "150px");
    CommentColumn<VDSGroup> commentColumn = new CommentColumn<VDSGroup>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDSGroup> dataCenterColumn = new TextColumnWithTooltip<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getStoragePoolName();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dataCenterColumn, constants.dcCluster(), "150px");
    }
    TextColumnWithTooltip<VDSGroup> versionColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getcompatibility_version().getValue();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "150px");
    TextColumnWithTooltip<VDSGroup> descColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getdescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionCluster(), "300px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDSGroup> cpuTypeColumn = new TextColumnWithTooltip<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getcpu_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(cpuTypeColumn, constants.cpuTypeCluster(), "150px");
    }
    TextColumnWithTooltip<VDSGroup> hostCountColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null)
                return "";
            return object.getGroupHostsAndVms().getHosts() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostCountColumn, constants.hostCount(), "150px");
    TextColumnWithTooltip<VDSGroup> vmCountColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null)
                return "";
            return object.getGroupHostsAndVms().getVms() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(vmCountColumn, constants.vmCount(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.newCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.editCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.removeCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDSGroup>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Cluster", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDSGroup>(constants.showReportCluster(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VDSGroup>(constants.guideMeCluster(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<VDSGroup> nameColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameCluster(), "150px");
    CommentColumn<VDSGroup> commentColumn = new CommentColumn<VDSGroup>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDSGroup> dataCenterColumn = new TextColumnWithTooltip<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getStoragePoolName();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(dataCenterColumn, constants.dcCluster(), "150px");
    }
    TextColumnWithTooltip<VDSGroup> versionColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getcompatibility_version().getValue();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(versionColumn, constants.comptVersCluster(), "150px");
    TextColumnWithTooltip<VDSGroup> descColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            return object.getdescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descColumn, constants.descriptionCluster(), "300px");
    if (ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly) {
        TextColumnWithTooltip<VDSGroup> cpuTypeColumn = new TextColumnWithTooltip<VDSGroup>() {

            @Override
            public String getValue(VDSGroup object) {
                return object.getcpu_name();
            }
        };
        // $NON-NLS-1$
        getTable().addColumn(cpuTypeColumn, constants.cpuTypeCluster(), "150px");
    }
    TextColumnWithTooltip<VDSGroup> hostCountColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null) {
                return "";
            }
            return object.getGroupHostsAndVms().getHosts() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostCountColumn, constants.hostCount(), "150px");
    TextColumnWithTooltip<VDSGroup> vmCountColumn = new TextColumnWithTooltip<VDSGroup>() {

        @Override
        public String getValue(VDSGroup object) {
            if (object.getGroupHostsAndVms() == null) {
                return "";
            }
            return object.getGroupHostsAndVms().getVms() + "";
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(vmCountColumn, constants.vmCount(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.newCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.editCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VDSGroup>(constants.removeCluster()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VDSGroup>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("Cluster", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VDSGroup>(constants.showReportCluster(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VDSGroup>(constants.guideMeCluster(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
@Test
public void testGetVmHostCount() throws Exception {
    Guid guid = Guid.createGuidFromString("b399944a-81ab-4ec5-8266-e19ba7c3c9d1");
    List<VDSGroup> vdsGroups = new ArrayList<>();
    vdsGroups.add(dao.get(guid));
    List<VDSGroup> data = ((VdsGroupDAODbFacadeImpl) dao).getHostsAndVmsForClusters(vdsGroups);
    assertEquals("Incorrect number of VMs in cluster", data.get(0).getGroupHostsAndVms().getVms(), 11);
    assertEquals("Incorrect number of Hosts in cluster", data.get(0).getGroupHostsAndVms().getHosts(), 1);
}
#method_after
@Test
public void testGetVmHostCount() throws Exception {
    Guid guid = FixturesTool.VDS_GROUP_RHEL6_ISCSI;
    List<VDSGroup> vdsGroups = new ArrayList<>();
    vdsGroups.add(dao.get(guid));
    List<VDSGroup> data = ((VdsGroupDAODbFacadeImpl) dao).getHostsAndVmsForClusters(vdsGroups);
    assertEquals("Incorrect number of VMs in cluster", data.get(0).getGroupHostsAndVms().getVms(), 7);
    assertEquals("Incorrect number of Hosts in cluster", data.get(0).getGroupHostsAndVms().getHosts(), 1);
}
#end_block

#method_before
protected void updateAllInBatch(String procedureName, Collection<T> paramValues, MapSqlParameterMapper<T> mapper) {
    // To overcome possible deadlocks, we need to sort the collection
    List<T> sortedParamValues = new ArrayList<>(paramValues);
    Collections.sort(sortedParamValues, new Comparator<T>() {

        @Override
        public int compare(T o1, T o2) {
            if (o1 instanceof Comparable) {
                return ((Comparable) o1).compareTo(o2);
            } else if (o1.getId() instanceof Comparable) {
                return ((Comparable) o1.getId()).compareTo(o2.getId());
            }
            return ((Integer) o1.getId().hashCode()).compareTo(o2.getId().hashCode());
        }
    });
    getCallsHandler().executeStoredProcAsBatch(procedureName == null ? getProcedureNameForUpdate() : procedureName, paramValues, mapper);
}
#method_after
protected void updateAllInBatch(String procedureName, Collection<T> paramValues, MapSqlParameterMapper<T> mapper) {
    // To overcome possible deadlocks, we need to sort the collection
    List<T> sortedParamValues = new ArrayList<>(paramValues);
    Collections.sort(sortedParamValues, BusinessEntityComparator.<T, ID>newInstance());
    getCallsHandler().executeStoredProcAsBatch(procedureName == null ? getProcedureNameForUpdate() : procedureName, paramValues, mapper);
}
#end_block

#method_before
public VDSReturnValue fence(FenceAgentOrder order) {
    VDSReturnValue retValue = null;
    try {
        // skip following code in case of testing a new host status
        if (_vds.getId() != null && !_vds.getId().equals(Guid.Empty)) {
            // get the host spm status again from the database in order to test it's current state.
            _vds.setSpmStatus((DbFacade.getInstance().getVdsDao().get(_vds.getId()).getSpmStatus()));
            // try to stop SPM if action is Restart or Stop and the vds is SPM
            if ((_action == FenceActionType.Restart || _action == FenceActionType.Stop) && (_vds.getSpmStatus() != VdsSpmStatus.None)) {
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(_vds.getId(), _vds.getStoragePoolId()));
            }
        }
        retValue = runFenceAction(_action, order);
        // if fence failed, retry with another proxy
        if (!retValue.getSucceeded()) {
            log.warnFormat("Fencing operation failed with proxy host {0}, trying another proxy...", proxyHostId);
            if (!findProxyHost(proxyHostId)) {
                log.warnFormat("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                findProxyHost();
            }
            retValue = runFenceAction(_action, order);
        }
    } catch (VdcBLLException e) {
        retValue = new VDSReturnValue();
        retValue.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        retValue.setExceptionString(e.getMessage());
        retValue.setSucceeded(false);
    }
    return retValue;
}
#method_after
public VDSReturnValue fence(FenceAgentOrder order) {
    VDSReturnValue retValue = null;
    try {
        // skip following code in case of testing a new host status
        if (_vds.getId() != null && !_vds.getId().equals(Guid.Empty)) {
            // get the host spm status again from the database in order to test it's current state.
            _vds.setSpmStatus((DbFacade.getInstance().getVdsDao().get(_vds.getId()).getSpmStatus()));
            // try to stop SPM if action is Restart or Stop and the vds is SPM
            if ((_action == FenceActionType.Restart || _action == FenceActionType.Stop) && (_vds.getSpmStatus() != VdsSpmStatus.None)) {
                Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(_vds.getId(), _vds.getStoragePoolId()));
            }
        }
        retValue = runFenceAction(_action, order);
        // if fence failed, retry with another proxy
        if (!retValue.getSucceeded()) {
            log.warnFormat("Fencing operation failed with proxy host {0}, trying another proxy...", proxyHostId);
            if (!findProxyHostExcluding(proxyHostId)) {
                log.warnFormat("Failed to find other proxy to re-run failed fence operation, retrying with the same proxy...");
                findProxyHost();
            }
            retValue = runFenceAction(_action, order);
        }
    } catch (VdcBLLException e) {
        retValue = new VDSReturnValue();
        retValue.setReturnValue(new FenceStatusReturnValue("unknown", e.getMessage()));
        retValue.setExceptionString(e.getMessage());
        retValue.setSucceeded(false);
    }
    return retValue;
}
#end_block

#method_before
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    // If a skippedProxyHostId was given, try to use another proxy
    if (skippedProxyHostId != null) {
        for (int i = 0; i < hosts.size(); i++) {
            if (hosts.get(i).getId().equals(skippedProxyHostId)) {
                hosts.remove(i);
                break;
            }
        }
    }
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.OTHER_DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up;
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId());
                    } else {
                        return !isHostNetworkUnreacable(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#method_after
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    synchronized (this) {
        // If a skippedProxyHostId was given, try to use another proxy
        if (skippedProxyHostId != null) {
            Iterator<VDS> iter = hosts.iterator();
            while (iter.hasNext()) {
                if (iter.next().getId().equals(skippedProxyHostId)) {
                    iter.remove();
                    break;
                }
            }
        }
    }
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.OTHER_DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up;
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId());
                    } else {
                        return !isHostNetworkUnreacable(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#end_block

#method_before
@Override
public void edit(final EntityModel<String> model) {
    driver.edit(model);
    model.getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ValueChangeEvent.fire(DnsServerEditor.this, model);
        }
    });
}
#method_after
@Override
public void edit(final EntityModel<String> model) {
    driver.edit(model);
    stringEditor.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    ValueChangeEvent.fire(stringEditor.asValueBox(), stringEditor.asValueBox().getValue());
                }
            });
        }
    });
    stringEditor.asValueBox().addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            ValueChangeEvent.fire(DnsServerEditor.this, model);
        }
    });
}
#end_block

#method_before
@Override
protected boolean isGhost(EntityModel<String> value) {
    String text = value.getEntity();
    return text == null || text.isEmpty();
}
#method_after
@Override
protected boolean isGhost(EntityModel<String> value) {
    return StringUtils.isEmpty(value.getEntity());
}
#end_block

#method_before
public void flush() {
    subnet = new ExternalSubnet();
    subnet.setName(getName().getEntity());
    subnet.setExternalNetwork(getExternalNetwork());
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
    subnet.setGateway(getGateway().getEntity());
    List<String> dnsServers = new ArrayList<String>();
    for (EntityModel<String> dnsServer : getDnsServers().getItems()) {
        if (dnsServer.getEntity() != null && !dnsServer.getEntity().isEmpty()) {
            dnsServers.add(dnsServer.getEntity());
        }
    }
    subnet.setDnsServers(dnsServers);
}
#method_after
public void flush() {
    subnet = new ExternalSubnet();
    subnet.setName(getName().getEntity());
    subnet.setExternalNetwork(getExternalNetwork());
    subnet.setCidr(getCidr().getEntity());
    subnet.setIpVersion(getIpVersion().getSelectedItem());
    subnet.setGateway(getGateway().getEntity());
    List<String> dnsServers = new ArrayList<String>();
    for (EntityModel<String> dnsServer : getDnsServers().getItems()) {
        if (StringUtils.isNotEmpty(dnsServer.getEntity())) {
            dnsServers.add(dnsServer.getEntity());
        }
    }
    subnet.setDnsServers(dnsServers);
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    boolean ipv4 = getIpVersion().getSelectedItem() == IpVersion.IPV4;
    getCidr().validateEntity(new IValidation[] { ipv4 ? new CidrValidation() : new NotEmptyValidation() });
    getIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    if (getGateway().getEntity() != null && !getGateway().getEntity().isEmpty() && ipv4) {
        getGateway().validateEntity(new IValidation[] { new IpAddressValidation() });
    }
    boolean dnsServersValid = true;
    for (EntityModel<String> dnsServer : getDnsServers().getItems()) {
        if (dnsServer.getEntity() != null && !dnsServer.getEntity().isEmpty() && ipv4) {
            dnsServer.validateEntity(new IValidation[] { new IpAddressValidation() });
        }
        dnsServersValid &= dnsServer.getIsValid();
    }
    return getName().getIsValid() && getCidr().getIsValid() && getIpVersion().getIsValid() && getGateway().getIsValid() && dnsServersValid;
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    boolean ipv4 = getIpVersion().getSelectedItem() == IpVersion.IPV4;
    getCidr().validateEntity(new IValidation[] { ipv4 ? new CidrValidation() : new NotEmptyValidation() });
    getIpVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getGateway().setIsValid(true);
    if (StringUtils.isNotEmpty(getGateway().getEntity()) && ipv4) {
        getGateway().validateEntity(new IValidation[] { new IpAddressValidation() });
    }
    boolean dnsServersValid = true;
    for (EntityModel<String> dnsServer : getDnsServers().getItems()) {
        dnsServer.setIsValid(true);
        if (StringUtils.isNotEmpty(dnsServer.getEntity()) && ipv4) {
            dnsServer.validateEntity(new IValidation[] { new IpAddressValidation() });
        }
        dnsServersValid &= dnsServer.getIsValid();
    }
    return getName().getIsValid() && getCidr().getIsValid() && getIpVersion().getIsValid() && getGateway().getIsValid() && dnsServersValid;
}
#end_block

#method_before
@Override
protected void executeSave() {
    IFrontendActionAsyncCallback addNetworkCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
            }
            postSaveAction(succeeded ? (Guid) retVal.getActionReturnValue() : null, succeeded);
        }
    };
    final AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    // New network
    if ((Boolean) getExport().getEntity()) {
        Provider externalProvider = (Provider) getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        Frontend.getInstance().runAction(VdcActionType.AddNetworkOnProvider, parameters, addNetworkCallback, null);
    } else {
        Frontend.getInstance().runAction(VdcActionType.AddNetwork, parameters, addNetworkCallback, null);
    }
}
#method_after
@Override
protected void executeSave() {
    IFrontendActionAsyncCallback addNetworkCallback = new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result1) {
            VdcReturnValueBase retVal = result1.getReturnValue();
            boolean succeeded = false;
            if (retVal != null && retVal.getSucceeded()) {
                succeeded = true;
            }
            postSaveAction(succeeded ? (Guid) retVal.getActionReturnValue() : null, succeeded);
        }
    };
    final AddNetworkStoragePoolParameters parameters = new AddNetworkStoragePoolParameters(getSelectedDc().getId(), getNetwork());
    parameters.setVnicProfileRequired(false);
    // New network
    if ((Boolean) getExport().getEntity()) {
        Provider externalProvider = getExternalProviders().getSelectedItem();
        ProviderNetwork providerNetwork = new ProviderNetwork();
        providerNetwork.setProviderId(externalProvider.getId());
        getNetwork().setProvidedBy(providerNetwork);
        Frontend.getInstance().runAction(VdcActionType.AddNetworkOnProvider, parameters, addNetworkCallback, null);
    } else {
        Frontend.getInstance().runAction(VdcActionType.AddNetwork, parameters, addNetworkCallback, null);
    }
}
#end_block

#method_before
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (NetworkClusterModel networkClusterModel : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(networkClusterModel.isRequired());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(networkClusterModel.getEntity(), tempVar));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
    if ((Boolean) getExport().getEntity() && getSubnetModel().getName().getEntity() != null && !getSubnetModel().getName().getEntity().isEmpty()) {
        getSubnetModel().setExternalNetwork(getNetwork().getProvidedBy());
        getSubnetModel().flush();
        Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(getSubnetModel().getSubnet(), networkId));
    }
}
#method_after
@Override
protected void postSaveAction(Guid networkGuid, boolean succeeded) {
    super.postSaveAction(networkGuid, succeeded);
    if (!succeeded) {
        return;
    }
    Guid networkId = getNetwork().getId() == null ? networkGuid : getNetwork().getId();
    ArrayList<VdcActionParametersBase> actionParameters1 = new ArrayList<VdcActionParametersBase>();
    for (NetworkClusterModel networkClusterModel : getClustersToAttach()) {
        Network tempVar = new Network();
        tempVar.setId(networkId);
        tempVar.setName(getNetwork().getName());
        // Init default NetworkCluster values (required, display, status)
        NetworkCluster networkCluster = new NetworkCluster();
        networkCluster.setRequired(networkClusterModel.isRequired());
        tempVar.setCluster(networkCluster);
        actionParameters1.add(new AttachNetworkToVdsGroupParameter(networkClusterModel.getEntity(), tempVar));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.AttachNetworkToVdsGroup, actionParameters1);
    if ((Boolean) getExport().getEntity() && (Boolean) getCreateSubnet().getEntity()) {
        getSubnetModel().setExternalNetwork(getNetwork().getProvidedBy());
        getSubnetModel().flush();
        Frontend.getInstance().runAction(VdcActionType.AddSubnetToProvider, new AddExternalSubnetParameters(getSubnetModel().getSubnet(), networkId));
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = (HashMap<ArchitectureType, Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<String>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<VmDevice>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && ((List) source).size() > 0) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static Map<Version, List<String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StoragePool> pools = (ArrayList<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && pools.size() > 0) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#method_after
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StoragePool> pools = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && !pools.isEmpty()) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            if (siblingVlanInterfaces.size() > 0) {
                return true;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType() {
    return VmInterfaceType.pv;
}
#method_after
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            HashMap<Integer, String> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            String defaultValue = result.get(DEFAULT_OS_ID);
            osNames = new MapWithDefaults<Integer, String>(result, defaultValue);
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = (HashMap<Integer, ArchitectureType>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Integer, Map<Version, List<DisplayType>>> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            displayTypes = new MapWithDefaults<Integer, Map<Version, List<DisplayType>>>(result, result.get(DEFAULT_OS_ID));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.ISO);
    }
    return models;
}
#method_after
public static List<IStorageModel> getIsoStorageModels() {
    ArrayList<IStorageModel> models = new ArrayList<IStorageModel>();
    NfsStorageModel nfsIsoModel = new NfsStorageModel();
    models.add(nfsIsoModel);
    PosixStorageModel posixIsoModel = new PosixStorageModel();
    models.add(posixIsoModel);
    LocalStorageModel localIsoModel = new LocalStorageModel();
    models.add(localIsoModel);
    for (IStorageModel model : models) {
        model.setRole(StorageDomainType.ISO);
    }
    return models;
}
#end_block

#method_before
public EntityModel getName() {
    return privateName;
}
#method_after
public EntityModel<String> getName() {
    return privateName;
}
#end_block

#method_before
private void setName(EntityModel value) {
    privateName = value;
}
#method_after
private void setName(EntityModel<String> value) {
    privateName = value;
}
#end_block

#method_before
public EntityModel getDescription() {
    return privateDescription;
}
#method_after
public EntityModel<String> getDescription() {
    return privateDescription;
}
#end_block

#method_before
private void setDescription(EntityModel value) {
    privateDescription = value;
}
#method_after
private void setDescription(EntityModel<String> value) {
    privateDescription = value;
}
#end_block

#method_before
public EntityModel getExport() {
    return export;
}
#method_after
public EntityModel<Boolean> getExport() {
    return export;
}
#end_block

#method_before
private void setExport(EntityModel value) {
    export = value;
}
#method_after
private void setExport(EntityModel<Boolean> value) {
    export = value;
}
#end_block

#method_before
public ListModel getExternalProviders() {
    return externalProviders;
}
#method_after
public ListModel<Provider> getExternalProviders() {
    return externalProviders;
}
#end_block

#method_before
public void setExternalProviders(ListModel externalProviders) {
    this.externalProviders = externalProviders;
}
#method_after
public void setExternalProviders(ListModel<Provider> externalProviders) {
    this.externalProviders = externalProviders;
}
#end_block

#method_before
public EntityModel getComment() {
    return privateComment;
}
#method_after
public EntityModel<String> getComment() {
    return privateComment;
}
#end_block

#method_before
private void setComment(EntityModel value) {
    privateComment = value;
}
#method_after
private void setComment(EntityModel<String> value) {
    privateComment = value;
}
#end_block

#method_before
public EntityModel getVLanTag() {
    return privateVLanTag;
}
#method_after
public EntityModel<Integer> getVLanTag() {
    return privateVLanTag;
}
#end_block

#method_before
private void setVLanTag(EntityModel value) {
    privateVLanTag = value;
}
#method_after
private void setVLanTag(EntityModel<Integer> value) {
    privateVLanTag = value;
}
#end_block

#method_before
public EntityModel getIsStpEnabled() {
    return privateIsStpEnabled;
}
#method_after
public EntityModel<Boolean> getIsStpEnabled() {
    return privateIsStpEnabled;
}
#end_block

#method_before
private void setIsStpEnabled(EntityModel value) {
    privateIsStpEnabled = value;
}
#method_after
private void setIsStpEnabled(EntityModel<Boolean> value) {
    privateIsStpEnabled = value;
}
#end_block

#method_before
public EntityModel getHasVLanTag() {
    return privateHasVLanTag;
}
#method_after
public EntityModel<Boolean> getHasVLanTag() {
    return privateHasVLanTag;
}
#end_block

#method_before
private void setHasVLanTag(EntityModel value) {
    privateHasVLanTag = value;
}
#method_after
private void setHasVLanTag(EntityModel<Boolean> value) {
    privateHasVLanTag = value;
}
#end_block

#method_before
public EntityModel getHasMtu() {
    return privateHasMtu;
}
#method_after
public EntityModel<Boolean> getHasMtu() {
    return privateHasMtu;
}
#end_block

#method_before
private void setHasMtu(EntityModel value) {
    privateHasMtu = value;
}
#method_after
private void setHasMtu(EntityModel<Boolean> value) {
    privateHasMtu = value;
}
#end_block

#method_before
public EntityModel getMtu() {
    return privateMtu;
}
#method_after
public EntityModel<Integer> getMtu() {
    return privateMtu;
}
#end_block

#method_before
private void setMtu(EntityModel value) {
    privateMtu = value;
}
#method_after
private void setMtu(EntityModel<Integer> value) {
    privateMtu = value;
}
#end_block

#method_before
public EntityModel getIsVmNetwork() {
    return privateIsVmNetwork;
}
#method_after
public EntityModel<Boolean> getIsVmNetwork() {
    return privateIsVmNetwork;
}
#end_block

#method_before
public void setIsVmNetwork(EntityModel value) {
    privateIsVmNetwork = value;
}
#method_after
public void setIsVmNetwork(EntityModel<Boolean> value) {
    privateIsVmNetwork = value;
}
#end_block

#method_before
public ListModel getDataCenters() {
    return privateDataCenters;
}
#method_after
public ListModel<StoragePool> getDataCenters() {
    return privateDataCenters;
}
#end_block

#method_before
private void setDataCenters(ListModel value) {
    privateDataCenters = value;
}
#method_after
private void setDataCenters(ListModel<StoragePool> value) {
    privateDataCenters = value;
}
#end_block

#method_before
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if ((Boolean) getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if ((Boolean) getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if ((Boolean) getExport().getEntity() && getSubnetModel().getName().getEntity() != null && !getSubnetModel().getName().getEntity().isEmpty()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && profilesValid && getNetworkLabel().getIsValid();
}
#method_after
public boolean validate() {
    RegexValidation tempVar = new RegexValidation();
    // $NON-NLS-1$
    tempVar.setExpression("^[A-Za-z0-9_]{1,15}$");
    tempVar.setMessage(ConstantsManager.getInstance().getConstants().nameMustContainAlphanumericMaxLenMsg());
    RegexValidation tempVar2 = new RegexValidation();
    tempVar2.setIsNegate(true);
    // $NON-NLS-1$
    tempVar2.setExpression("^(bond)");
    tempVar2.setMessage(ConstantsManager.getInstance().getConstants().networkNameStartMsg());
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar, tempVar2 });
    LengthValidation tempVar3 = new LengthValidation();
    tempVar3.setMaxLength(40);
    getDescription().validateEntity(new IValidation[] { tempVar3 });
    getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    getVLanTag().setIsValid(true);
    if (getHasVLanTag().getEntity()) {
        IntegerValidation tempVar4 = new IntegerValidation();
        tempVar4.setMinimum(0);
        tempVar4.setMaximum(4094);
        getVLanTag().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar4 });
    }
    getMtu().setIsValid(true);
    if (getHasMtu().getEntity()) {
        IntegerValidation tempVar5 = new IntegerValidation();
        tempVar5.setMinimum(68);
        getMtu().validateEntity(new IValidation[] { new NotEmptyValidation(), tempVar5 });
    }
    getExternalProviders().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    boolean subnetValid = true;
    if ((Boolean) getExport().getEntity() && (Boolean) getCreateSubnet().getEntity()) {
        subnetValid = getSubnetModel().validate();
    }
    boolean profilesValid = true;
    Iterable<VnicProfileModel> profiles = getProfiles().getItems();
    for (VnicProfileModel profileModel : profiles) {
        if (!profileModel.validate()) {
            profilesValid = false;
        }
    }
    getNetworkLabel().validateSelectedItem(new IValidation[] { new AsciiNameValidation() });
    return getName().getIsValid() && getVLanTag().getIsValid() && getDescription().getIsValid() && getMtu().getIsValid() && getExternalProviders().getIsValid() && getComment().getIsValid() && subnetValid && profilesValid && getNetworkLabel().getIsValid();
}
#end_block

#method_before
public StoragePool getSelectedDc() {
    return (StoragePool) getDataCenters().getSelectedItem();
}
#method_after
public StoragePool getSelectedDc() {
    return getDataCenters().getSelectedItem();
}
#end_block

#method_before
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName((String) getName().getEntity());
    network.setStp((Boolean) getIsStpEnabled().getEntity());
    network.setDescription((String) getDescription().getEntity());
    network.setComment((String) getComment().getEntity());
    network.setVmNetwork((Boolean) getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if ((Boolean) getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if ((Boolean) getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#method_after
public void flush() {
    network.setDataCenterId(getSelectedDc().getId());
    network.setName(getName().getEntity());
    network.setStp(getIsStpEnabled().getEntity());
    network.setDescription(getDescription().getEntity());
    network.setComment(getComment().getEntity());
    network.setVmNetwork(getIsVmNetwork().getEntity());
    String label = getNetworkLabel().getSelectedItem();
    network.setLabel(label == null || !label.isEmpty() ? label : null);
    network.setMtu(0);
    if (getHasMtu().getEntity()) {
        network.setMtu(Integer.parseInt(getMtu().getEntity().toString()));
    }
    network.setVlanId(null);
    if (getHasVLanTag().getEntity()) {
        network.setVlanId(Integer.parseInt(getVLanTag().getEntity().toString()));
    }
    for (VnicProfileModel profileModel : getProfiles().getItems()) {
        profileModel.flush();
    }
    if (getQos().getIsChangable()) {
        NetworkQoS qos = getQos().getSelectedItem();
        network.setQosId(qos == NetworkQoSModel.EMPTY_QOS ? null : qos.getId());
    }
}
#end_block

#method_before
protected void toggleProfilesAvailability() {
    getProfiles().setIsAvailable((Boolean) getIsVmNetwork().getEntity());
}
#method_after
protected void toggleProfilesAvailability() {
    getProfiles().setIsAvailable(getIsVmNetwork().getEntity());
}
#end_block

#method_before
private void addQos() {
    NewNetworkQoSModel qosModel = new NewNetworkQoSModel(this, getSelectedDc()) {

        @Override
        protected void postSaveAction(boolean succeeded) {
            if (succeeded) {
                List<NetworkQoS> qosItems = new ArrayList<NetworkQoS>((Collection<NetworkQoS>) getQos().getItems());
                qosItems.add(1, networkQoS);
                getQos().setItems(qosItems);
                getQos().setSelectedItem(networkQoS);
            }
            super.postSaveAction(succeeded);
        }

        @Override
        protected void cancel() {
            sourceListModel.setConfirmWindow(null);
        }
    };
    qosModel.getDataCenters().setIsChangable(false);
    sourceListModel.setConfirmWindow(qosModel);
}
#method_after
private void addQos() {
    NewNetworkQoSModel qosModel = new NewNetworkQoSModel(this, getSelectedDc()) {

        @Override
        protected void postSaveAction(boolean succeeded) {
            if (succeeded) {
                List<NetworkQoS> qosItems = new ArrayList<NetworkQoS>(getQos().getItems());
                qosItems.add(1, networkQoS);
                getQos().setItems(qosItems);
                getQos().setSelectedItem(networkQoS);
            }
            super.postSaveAction(succeeded);
        }

        @Override
        protected void cancel() {
            sourceListModel.setConfirmWindow(null);
        }
    };
    qosModel.getDataCenters().setIsChangable(false);
    sourceListModel.setConfirmWindow(qosModel);
}
#end_block

#method_before
protected void onExportChanged() {
    boolean externalNetwork = (Boolean) getExport().getEntity();
    getQos().setIsChangable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    String label = getNetworkLabel().getSelectedItem();
    getNetworkLabel().setItems(externalNetwork ? new HashSet<String>() : dcLabels);
    getNetworkLabel().setSelectedItem(label);
}
#method_after
protected void onExportChanged() {
    boolean externalNetwork = getExport().getEntity();
    getQos().setIsChangable(!externalNetwork);
    getAddQosCommand().setIsExecutionAllowed(!externalNetwork);
    String label = getNetworkLabel().getSelectedItem();
    getNetworkLabel().setItems(externalNetwork ? new HashSet<String>() : dcLabels);
    getNetworkLabel().setSelectedItem(label);
}
#end_block

#method_before
private void updateVlanTagChangeability() {
    getVLanTag().setIsChangable((Boolean) getHasVLanTag().getEntity());
}
#method_after
private void updateVlanTagChangeability() {
    getVLanTag().setIsChangable(getHasVLanTag().getEntity());
}
#end_block

#method_before
private void updateMtuChangeability() {
    getMtu().setIsChangable((Boolean) getHasMtu().getEntity() && !((Boolean) getExport().getEntity()));
}
#method_after
private void updateMtuChangeability() {
    getMtu().setIsChangable(getHasMtu().getEntity() && !getExport().getEntity());
}
#end_block

#method_before
protected void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.generalTabNetworkPopup());
    clusterTab.setLabel(constants.clusterTabNetworkPopup());
    profilesTab.setLabel(constants.profilesTabNetworkPopup());
    subnetTab.setLabel(constants.subnetTabNetworkPopup());
    dataCenterEditor.setLabel(constants.networkPopupDataCenterLabel());
    assignLabel.setText(constants.networkPopupAssignLabel());
    nameEditor.setLabel(constants.nameLabel());
    descriptionEditor.setLabel(constants.descriptionLabel());
    exportLabel.setText(constants.exportLabel());
    exportEditor.setLabel(constants.exportCheckboxLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    networkLabel.setLabel(constants.networkLabel());
    commentEditor.setLabel(constants.commentLabel());
    isVmNetworkEditor.setLabel(constants.vmNetworkLabel());
    vlanTagging.setLabel(constants.enableVlanTagLabel());
    hasMtuEditor.setLabel(constants.overrideMtuLabel());
    qosEditor.setLabel(constants.hostNetworkQos());
    profilesLabel.setText(constants.profilesLabel());
}
#method_after
protected void localize(ApplicationConstants constants) {
    generalTab.setLabel(constants.generalTabNetworkPopup());
    clusterTab.setLabel(constants.clusterTabNetworkPopup());
    profilesTab.setLabel(constants.profilesTabNetworkPopup());
    subnetTab.setLabel(constants.subnetTabNetworkPopup());
    dataCenterEditor.setLabel(constants.networkPopupDataCenterLabel());
    assignLabel.setText(constants.networkPopupAssignLabel());
    nameEditor.setLabel(constants.nameLabel());
    descriptionEditor.setLabel(constants.descriptionLabel());
    exportLabel.setText(constants.exportLabel());
    exportEditor.setLabel(constants.exportCheckboxLabel());
    externalProviderEditor.setLabel(constants.externalProviderLabel());
    networkLabel.setLabel(constants.networkLabel());
    commentEditor.setLabel(constants.commentLabel());
    isVmNetworkEditor.setLabel(constants.vmNetworkLabel());
    vlanTagging.setLabel(constants.enableVlanTagLabel());
    hasMtuEditor.setLabel(constants.overrideMtuLabel());
    qosEditor.setLabel(constants.hostNetworkQos());
    createSubnetEditor.setLabel(constants.createSubnetLabel());
    profilesLabel.setText(constants.profilesLabel());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (!StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (!StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getcompatibility_version()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.hasCustomProperties()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    VdsDynamic vdsDynamic = getVdsDynamic();
    // in order to approve a host
    if (vdsDynamic != null && !VDSStatus.PendingApproval.equals(getVdsDynamic().getStatus())) {
        permissionList.add(new PermissionSubject(getParameters().getVdsId(), VdcObjectType.VDS, getActionType().getActionGroup()));
    }
    permissionList.add(new PermissionSubject(getParameters().getClusterId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    List<PermissionSubject> unmodifiableList = Collections.unmodifiableList(permissionList);
    return unmodifiableList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    VdsDynamic vdsDynamic = getVds().getDynamicData();
    // in order to approve a host
    if (vdsDynamic != null && !VDSStatus.PendingApproval.equals(vdsDynamic.getStatus())) {
        permissionList.add(new PermissionSubject(getParameters().getVdsId(), VdcObjectType.VDS, getActionType().getActionGroup()));
    }
    permissionList.add(new PermissionSubject(getParameters().getClusterId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    List<PermissionSubject> unmodifiableList = Collections.unmodifiableList(permissionList);
    return unmodifiableList;
}
#end_block

#method_before
@Override
public void edit(HostInterfaceModel object) {
    super.edit(object);
    info.setVisible(false);
    message.setVisible(false);
    checkConnectivity.setVisible(false);
    bondingModeEditor.setVisible(false);
    commitChanges.setVisible(false);
    isToSync.setVisible(true);
    if (object.getIsToSync().getIsChangable()) {
        isToSyncInfo.setVisible(true);
    }
    // resize
    layoutPanel.remove(infoPanel);
    layoutPanel.setWidgetSize(mainPanel, 510);
    asPopupPanel().setPixelSize(400, 590);
    enableDisableBySync(object);
    customPropertiesPanel.setVisible(object.getCustomPropertiesModel().getIsAvailable());
    customPropertiesWidget.edit(object.getCustomPropertiesModel());
    if (object.getNetwork().getSelectedItem().getCluster().isDisplay()) {
        displayNetworkChangeWarning.setText(constants.changeDisplayNetworkWarning());
        displayNetworkChangeWarning.setVisible(true);
    }
}
#method_after
@Override
public void edit(HostInterfaceModel object) {
    super.edit(object);
    info.setVisible(false);
    message.setVisible(false);
    checkConnectivity.setVisible(false);
    bondingModeEditor.setVisible(false);
    commitChanges.setVisible(false);
    isToSync.setVisible(true);
    if (object.getIsToSync().getIsChangable()) {
        isToSyncInfo.setVisible(true);
    }
    // resize
    layoutPanel.remove(infoPanel);
    layoutPanel.setWidgetSize(mainPanel, 510);
    asPopupPanel().setPixelSize(400, 590);
    enableDisableBySync(object);
    customPropertiesPanel.setVisible(object.getCustomPropertiesModel().getIsAvailable());
    customPropertiesWidget.edit(object.getCustomPropertiesModel());
    if (object.getNetwork().getSelectedItem().getCluster().isDisplay()) {
        displayNetworkChangeWarning.setVisible(true);
    }
}
#end_block

#method_before
private static String getTimeZone(VM vm) {
    String retVal;
    String timeZone = null;
    // Can be empty if the VM was imported.
    if (vm.getVmInit() != null && StringUtils.isNotEmpty(vm.getVmInit().getTimeZone())) {
        timeZone = vm.getVmInit().getTimeZone();
    } else {
        timeZone = Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone);
    }
    if (osRepository.isTimezoneValueInteger(vm.getStaticData().getOsId(), null)) {
        // send correct time zone as sysprep expect to get it (a wierd number)
        retVal = getTimezoneIndexByKey(timeZone);
    } else {
        retVal = timeZone;
    }
    return retVal;
}
#method_after
private static String getTimeZone(VM vm) {
    String timeZone = null;
    // Can be empty if the VM was imported.
    if (vm.getVmInit() != null && StringUtils.isNotEmpty(vm.getVmInit().getTimeZone())) {
        timeZone = vm.getVmInit().getTimeZone();
    } else {
        timeZone = Config.<String>getValue(ConfigValues.DefaultWindowsTimeZone);
    }
    if (osRepository.isTimezoneValueInteger(vm.getStaticData().getOsId(), null)) {
        // send correct time zone as sysprep expect to get it (a wierd number)
        return getTimezoneIndexByKey(timeZone);
    }
    return timeZone;
}
#end_block

#method_before
@Override
public void render(Context context, String value, SafeHtmlBuilder sb) {
    if (value != null) {
        SafeHtml escapedValue = getEscapedValue(value);
        SafeHtml renderedValue = getRenderedValue(escapedValue);
        if (style != null) {
            sb.append(styledTemplate.textContainer(style, ElementIdUtils.createTableCellElementId(elementIdPrefix, columnId, context), renderedValue));
        } else {
            sb.append(template.textContainer(ElementIdUtils.createTableCellElementId(elementIdPrefix, columnId, context), renderedValue));
        }
    }
}
#method_after
@Override
public void render(Context context, String value, SafeHtmlBuilder sb) {
    if (value != null) {
        SafeHtml escapedValue = getEscapedValue(value);
        SafeHtml renderedValue = getRenderedValue(escapedValue);
        sb.append(template.textContainer(styleClass, ElementIdUtils.createTableCellElementId(elementIdPrefix, columnId, context), renderedValue));
    }
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
    EventTarget eventTarget = event.getEventTarget();
    if (!Element.is(eventTarget)) {
        return;
    }
    if ("click".equals(event.getType())) {
        // $NON-NLS-1$
        onClick(value);
    }
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, T value, NativeEvent event, ValueUpdater<T> valueUpdater) {
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
    EventTarget eventTarget = event.getEventTarget();
    if (!Element.is(eventTarget)) {
        return;
    }
    if (BrowserEvents.CLICK.equals(event.getType())) {
        onClick(value);
    }
}
#end_block

#method_before
private static void logChangedDisplayNetwork(VDS vds, Collection<Network> engineHostNetworks, Collection<VdsNetworkInterface> engineInterfaces) {
    if (isVmRunningOnHost(vds.getId())) {
        final Network engineDisplayNetwork = findDisplayNetwork(engineHostNetworks);
        final IsNetworkOnInterfacePredicate isNetworkOnInterfacePredicate = new IsNetworkOnInterfacePredicate(engineDisplayNetwork.getName());
        final VdsNetworkInterface vdsmDisplayInterface = LinqUtils.firstOrNull(vds.getInterfaces(), isNetworkOnInterfacePredicate);
        final VdsNetworkInterface engineDisplayInterface = LinqUtils.firstOrNull(engineInterfaces, isNetworkOnInterfacePredicate);
        final DisplayInterfaceEqualityPredicate displayIneterfaceEqualityPredicate = new DisplayInterfaceEqualityPredicate(engineDisplayInterface);
        if (// the display interface is't on host anymore
        vdsmDisplayInterface == null || !displayIneterfaceEqualityPredicate.eval(vdsmDisplayInterface)) {
            final AuditLogableBase loggable = new AuditLogableBase();
            loggable.setVdsId(vds.getId());
            AuditLogDirector.log(loggable, AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_HOST_WITH_ACTIVE_VM);
        }
    }
}
#method_after
private static void logChangedDisplayNetwork(VDS vds, Collection<Network> engineHostNetworks, Collection<VdsNetworkInterface> engineInterfaces) {
    if (isVmRunningOnHost(vds.getId())) {
        final Network engineDisplayNetwork = findDisplayNetwork(engineHostNetworks);
        final IsNetworkOnInterfacePredicate isNetworkOnInterfacePredicate = new IsNetworkOnInterfacePredicate(engineDisplayNetwork.getName());
        final VdsNetworkInterface vdsmDisplayInterface = LinqUtils.firstOrNull(vds.getInterfaces(), isNetworkOnInterfacePredicate);
        final VdsNetworkInterface engineDisplayInterface = LinqUtils.firstOrNull(engineInterfaces, isNetworkOnInterfacePredicate);
        final DisplayInterfaceEqualityPredicate displayIneterfaceEqualityPredicate = new DisplayInterfaceEqualityPredicate(engineDisplayInterface);
        if (// the display interface is't on host anymore
        vdsmDisplayInterface == null || !displayIneterfaceEqualityPredicate.eval(vdsmDisplayInterface)) {
            final AuditLogableBase loggable = new AuditLogableBase(vds.getId());
            AuditLogDirector.log(loggable, AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_HOST_WITH_ACTIVE_VM);
        }
    }
}
#end_block

#method_before
private static boolean isVmRunningOnHost(Guid hostId) {
    return !DbFacade.getInstance().getVmDao().getAllRunningForVds(hostId).isEmpty();
}
#method_after
private static boolean isVmRunningOnHost(Guid hostId) {
    return !DbFacade.getInstance().getVmDynamicDao().getAllRunningForVds(hostId).isEmpty();
}
#end_block

#method_before
private static void persistTopology(VDS vds, Map<String, VdsNetworkInterface> nicsByName, List<VdsNetworkInterface> dbIfaces) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<String> updatedIfaces = new ArrayList<String>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    Map<String, VdsNetworkInterface> hostNicsByNames = Entities.entitiesByName(vds.getInterfaces());
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbIfaces) {
        if (hostNicsByNames.containsKey(dbIface.getName())) {
            VdsNetworkInterface vdsIface = hostNicsByNames.get(dbIface.getName());
            // we preserve only the ID and the labels from the Database
            // everything else is what we got from getVdsCapabilities
            vdsIface.setId(dbIface.getId());
            vdsIface.setLabels(dbIface.getLabels());
            vdsIface.setQosOverridden(dbIface.isQosOverridden());
            dbIfacesToBatch.add(vdsIface);
            updatedIfaces.add(vdsIface.getName());
        } else {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (nicsByName != null) {
        updateInterfacesWithUserConfiguration(dbIfacesToBatch, nicsByName);
        updateInterfacesWithUserConfiguration(vds.getInterfaces(), nicsByName);
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#method_after
private static void persistTopology(VDS vds, Map<String, VdsNetworkInterface> nicsByName, List<VdsNetworkInterface> dbIfaces) {
    InterfaceDao interfaceDAO = DbFacade.getInstance().getInterfaceDao();
    List<String> updatedIfaces = new ArrayList<String>();
    List<VdsNetworkInterface> dbIfacesToBatch = new ArrayList<>();
    Map<String, VdsNetworkInterface> hostNicsByNames = Entities.entitiesByName(vds.getInterfaces());
    // First we check what interfaces need to update/delete
    for (VdsNetworkInterface dbIface : dbIfaces) {
        if (hostNicsByNames.containsKey(dbIface.getName())) {
            VdsNetworkInterface vdsIface = hostNicsByNames.get(dbIface.getName());
            // we preserve only the ID and the labels from the Database
            // everything else is what we got from getVdsCapabilities
            vdsIface.setId(dbIface.getId());
            vdsIface.setLabels(dbIface.getLabels());
            vdsIface.setQosOverridden(dbIface.isQosOverridden());
            vdsIface.setCustomProperties(dbIface.getCustomProperties());
            dbIfacesToBatch.add(vdsIface);
            updatedIfaces.add(vdsIface.getName());
        } else {
            interfaceDAO.removeInterfaceFromVds(dbIface.getId());
            interfaceDAO.removeStatisticsForVds(dbIface.getId());
        }
    }
    if (nicsByName != null) {
        updateInterfacesWithUserConfiguration(dbIfacesToBatch, nicsByName);
        updateInterfacesWithUserConfiguration(vds.getInterfaces(), nicsByName);
    }
    if (!dbIfacesToBatch.isEmpty()) {
        interfaceDAO.massUpdateInterfacesForVds(dbIfacesToBatch);
    }
    // now all that left is add the interfaces that not exists in the Database
    for (VdsNetworkInterface vdsIface : vds.getInterfaces()) {
        if (!updatedIfaces.contains(vdsIface.getName())) {
            interfaceDAO.saveInterfaceForVds(vdsIface);
            interfaceDAO.saveStatisticsForVds(vdsIface.getStatistics());
        }
    }
}
#end_block

#method_before
private static void updateInterfacesWithUserConfiguration(List<VdsNetworkInterface> nicsForUpdate, Map<String, VdsNetworkInterface> nicsByName) {
    for (VdsNetworkInterface nicForUpdate : nicsForUpdate) {
        if (nicsByName.containsKey(nicForUpdate.getName())) {
            VdsNetworkInterface nic = nicsByName.get(nicForUpdate.getName());
            nicForUpdate.setLabels(nic.getLabels());
            nicForUpdate.setQosOverridden(nic.isQosOverridden());
        }
    }
}
#method_after
private static void updateInterfacesWithUserConfiguration(List<VdsNetworkInterface> nicsForUpdate, Map<String, VdsNetworkInterface> nicsByName) {
    for (VdsNetworkInterface nicForUpdate : nicsForUpdate) {
        if (nicsByName.containsKey(nicForUpdate.getName())) {
            VdsNetworkInterface nic = nicsByName.get(nicForUpdate.getName());
            nicForUpdate.setLabels(nic.getLabels());
            nicForUpdate.setQosOverridden(nic.isQosOverridden());
            nicForUpdate.setCustomProperties(nic.getCustomProperties());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            updateNetworkAttachment(getVdsGroupId(), getNetworkCluster(), getNetwork(), AttachNetworkToVdsGroupCommand.this);
            return null;
        }
    });
    if (!getPersistedNetwork().isExternal() && NetworkUtils.isLabeled(getPersistedNetwork()) && NetworkHelper.setupNetworkSupported(getVdsGroup().getcompatibility_version())) {
        addNetworkToHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            attachNetwork(getVdsGroupId(), getNetworkCluster(), getNetwork());
            return null;
        }
    });
    if (!getPersistedNetwork().isExternal() && NetworkUtils.isLabeled(getPersistedNetwork()) && NetworkHelper.setupNetworkSupported(getVdsGroup().getcompatibility_version())) {
        addNetworkToHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#method_after
@Override
protected boolean canDoAction() {
    return networkNotAttachedToCluster() && vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#end_block

#method_before
private static boolean networkExists(Guid clusterId, NetworkCluster networkCluster) {
    List<NetworkCluster> networks = getNetworkClusterDao().getAllForCluster(clusterId);
    for (NetworkCluster nc : networks) {
        if (nc.getNetworkId().equals(networkCluster.getNetworkId())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean networkExists() {
    return getNetworkClusterDAO().get(getNetworkCluster().getId()) != null;
}
#end_block

#method_before
public static AuditLog getInstance() {
    return instance;
}
#method_after
public static AuditLogger getInstance() {
    return instance;
}
#end_block

#method_before
@Before
public void setUp() {
    underTest = new DisplayNetworkClusterHelper(mockNetworkClusterDao, mockVmDao, mockNetworkCluster, TEST_NETWORK_NAME, mockCommandBase);
    Mockito.when(mockNetworkCluster.getId()).thenReturn(TEST_NETWORK_CLUSTER_ID);
    Mockito.when(mockNetworkClusterDao.get(TEST_NETWORK_CLUSTER_ID)).thenReturn(mockNetworkClusterBeforeUpdate);
}
#method_after
@Before
public void setUp() {
    underTest = new DisplayNetworkClusterHelper(mockNetworkClusterDao, mockVmDao, mockNetworkCluster, TEST_NETWORK_NAME, mockAuditLogger);
    Mockito.when(mockNetworkCluster.getId()).thenReturn(TEST_NETWORK_CLUSTER_ID);
    Mockito.when(mockNetworkClusterDao.get(TEST_NETWORK_CLUSTER_ID)).thenReturn(mockNetworkClusterBeforeUpdate);
}
#end_block

#method_before
@Test
public void testWarnOnActiveVmPositive() {
    testWarnOnActiveVmInner(true);
    Mockito.verify(mockCommandBase).auditLog(auditLogableBaseCaptor.capture(), Mockito.same(AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_CLUSTER_WITH_ACTIVE_VM));
    final AuditLogableBase actualLoggable = auditLogableBaseCaptor.getValue();
    Assert.assertEquals(TEST_CLUSTER_ID, actualLoggable.getVdsGroupId());
    Assert.assertEquals(TEST_NETWORK_NAME, actualLoggable.getCustomValue("networkname"));
}
#method_after
@Test
public void testWarnOnActiveVmPositive() {
    testWarnOnActiveVmInner(true);
    Mockito.verify(mockAuditLogger).log(auditLogableBaseCaptor.capture(), Mockito.same(AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_CLUSTER_WITH_ACTIVE_VM));
    final AuditLogableBase actualLoggable = auditLogableBaseCaptor.getValue();
    Assert.assertEquals(TEST_CLUSTER_ID, actualLoggable.getVdsGroupId());
    Assert.assertEquals(TEST_NETWORK_NAME, actualLoggable.getCustomValue("networkname"));
}
#end_block

#method_before
@Test
public void testWarnOnActiveVmNegative() {
    testWarnOnActiveVmInner(false);
    Mockito.verifyZeroInteractions(mockCommandBase);
}
#method_after
@Test
public void testWarnOnActiveVmNegative() {
    testWarnOnActiveVmInner(false);
    Mockito.verifyZeroInteractions(mockAuditLogger);
}
#end_block

#method_before
public void warnOnActiveVm() {
    if (activeVmAttachedToClusterPredicate.eval(networkCluster.getClusterId())) {
        AuditLogableBase loggable = createLoggable();
        commandBase.auditLog(loggable, AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_CLUSTER_WITH_ACTIVE_VM);
    }
}
#method_after
public void warnOnActiveVm() {
    if (activeVmAttachedToClusterPredicate.eval(networkCluster.getClusterId())) {
        AuditLogableBase loggable = createLoggable();
        auditLogger.log(loggable, AuditLogType.NETWORK_UPDATE_DISPLAY_FOR_CLUSTER_WITH_ACTIVE_VM);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDAO(), getVmDAO(), getNetworkCluster(), getNetworkName(), this);
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    getNetworkClusterDAO().update(getNetworkCluster());
    if (getNetworkCluster().isDisplay()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetwork().getId());
    }
    if (getNetworkCluster().isMigration()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsMigration(getVdsGroupId(), getNetwork().getId());
    }
    NetworkClusterHelper.setStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDAO(), getVmDAO(), getNetworkCluster(), getNetworkName(), AuditLogDirectorDelegator.getInstance());
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    getNetworkClusterDAO().update(getNetworkCluster());
    if (getNetworkCluster().isDisplay()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsDisplay(getVdsGroupId(), getNetwork().getId());
    }
    if (getNetworkCluster().isMigration()) {
        getNetworkClusterDAO().setNetworkExclusivelyAsMigration(getVdsGroupId(), getNetwork().getId());
    }
    NetworkClusterHelper.setStatus(getVdsGroupId(), getNetwork());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDAO(), getVmDAO(), getNetworkCluster(), getNetworkName(), this);
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            updateNetworkAttachment(getVdsGroupId(), getNetworkCluster(), getNetwork());
            return null;
        }
    });
    if (!getPersistedNetwork().isExternal() && NetworkUtils.isLabeled(getPersistedNetwork()) && NetworkHelper.setupNetworkSupported(getVdsGroup().getcompatibility_version())) {
        addNetworkToHosts();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final DisplayNetworkClusterHelper displayNetworkClusterHelper = new DisplayNetworkClusterHelper(getNetworkClusterDAO(), getVmDAO(), getNetworkCluster(), getNetworkName(), AuditLogDirectorDelegator.getInstance());
    if (displayNetworkClusterHelper.isDisplayToBeUpdated()) {
        displayNetworkClusterHelper.warnOnActiveVm();
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            attachNetwork(getVdsGroupId(), getNetworkCluster(), getNetwork());
            return null;
        }
    });
    if (!getPersistedNetwork().isExternal() && NetworkUtils.isLabeled(getPersistedNetwork()) && NetworkHelper.setupNetworkSupported(getVdsGroup().getcompatibility_version())) {
        addNetworkToHosts();
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#method_after
@Override
protected boolean canDoAction() {
    return networkNotAttachedToCluster() && vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#end_block

#method_before
private static boolean networkExists(Guid clusterId, NetworkCluster networkCluster) {
    List<NetworkCluster> networks = getNetworkClusterDao().getAllForCluster(clusterId);
    for (NetworkCluster nc : networks) {
        if (nc.getNetworkId().equals(networkCluster.getNetworkId())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean networkExists() {
    return getNetworkClusterDAO().get(getNetworkCluster().getId()) != null;
}
#end_block

#method_before
public final Object getData(String sessionId, String key, boolean refresh) {
    Map<String, Object> currentContext = null;
    if ((currentContext = newContext.get(sessionId)) != null) {
        return currentContext.get(key);
    }
    if (refresh) {
        if ((currentContext = oldContext.remove(sessionId)) != null) {
            newContext.put(sessionId, currentContext);
        }
    } else {
        currentContext = oldContext.get(sessionId);
    }
    if (currentContext != null) {
        return currentContext.get(key);
    }
    return null;
}
#method_after
public final Object getData(String key) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (sessionId == null) {
        return null;
    }
    return getData(sessionId, key, false);
}
#end_block

#method_before
public final Object getData(String key, boolean refresh) {
    String sessionId = ThreadLocalParamsContainer.getHttpSessionId();
    if (sessionId == null) {
        return null;
    }
    return getData(sessionId, key, refresh);
}
#method_after
public final Object getData(String key, boolean refresh) {
    return getData(ThreadLocalParamsContainer.getHttpSessionId(), key, refresh);
}
#end_block

#method_before
public final Object getData(String sessionId, String key, boolean refresh) {
    Map<String, Object> currentContext = null;
    if ((currentContext = newContext.get(sessionId)) != null) {
        return currentContext.get(key);
    }
    if (refresh) {
        if ((currentContext = oldContext.remove(sessionId)) != null) {
            newContext.put(sessionId, currentContext);
        }
    } else {
        currentContext = oldContext.get(sessionId);
    }
    if (currentContext != null) {
        return currentContext.get(key);
    }
    return null;
}
#method_after
public final Object getData(String sessionId, String key, boolean refresh) {
    if (sessionId == null) {
        return null;
    }
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    Object value = null;
    if (sessionInfo != null) {
        if (refresh) {
            refresh(sessionInfo);
        }
        value = sessionInfo.contentOfSession.get(key);
    }
    return value;
}
#end_block

#method_before
public final void setData(String sessionId, String key, Object value) {
    // Try to get value from new generation
    Map<String, Object> context = newContext.get(sessionId);
    if (context == null) {
        // Try to get value from old generation
        context = oldContext.get(sessionId);
        if (context == null) {
            context = new ConcurrentHashMap<String, Object>();
        }
        // Put a value to new generation , for case that other thread put
        // value before current thread , his value will be used
        Map<String, Object> oldSessionContext = newContext.putIfAbsent(sessionId, context);
        if (oldSessionContext != null) {
            context = oldSessionContext;
        }
    }
    context.put(key, value);
}
#method_after
public final void setData(String sessionId, String key, Object value) {
    SessionInfo sessionInfo = getSessionInfo(sessionId);
    if (sessionInfo == null) {
        sessionInfo = new SessionInfo();
        SessionInfo oldSessionInfo = sessionInfoMap.putIfAbsent(sessionId, sessionInfo);
        if (oldSessionInfo != null) {
            sessionInfo = oldSessionInfo;
        }
    }
    sessionInfo.contentOfSession.put(key, value);
}
#end_block

#method_before
public final void removeSession(String sessionId) {
    oldContext.remove(sessionId);
    newContext.remove(sessionId);
}
#method_after
public final void removeSession(String sessionId) {
    sessionInfoMap.remove(sessionId);
}
#end_block

#method_before
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    deleteOldGeneration();
}
#method_after
@OnTimerMethodAnnotation("cleanExpiredUsersSessions")
public final void cleanExpiredUsersSessions() {
    Date now = new Date();
    for (Entry<String, SessionInfo> entry : sessionInfoMap.entrySet()) {
        ConcurrentMap<String, Object> sessionMap = entry.getValue().contentOfSession;
        Date hardLimit = (Date) sessionMap.get(HARD_LIMIT_PARAMETER_NAME);
        Date softLimit = (Date) sessionMap.get(SOFT_LIMIT_PARAMETER_NAME);
        if ((hardLimit != null && hardLimit.before(now)) || (softLimit != null && softLimit.before(now))) {
            removeSessionImpl(entry.getKey());
        }
    }
}
#end_block

#method_before
public DbUser getUser(boolean refresh) {
    return (DbUser) getData(USER_PARAMETER_NAME, refresh);
}
#method_after
public DbUser getUser(boolean refresh) {
    return (DbUser) getData(ThreadLocalParamsContainer.getHttpSessionId(), USER_PARAMETER_NAME, refresh);
}
#end_block

#method_before
public String getPassword() {
    return (String) getData(PASSWORD_PARAMETER_NAME, false);
}
#method_after
public String getPassword() {
    return (String) getData(PASSWORD_PARAMETER_NAME);
}
#end_block

#method_before
protected boolean attachUserToSession() {
    Date validTo = null;
    if (!StringUtils.isEmpty(getParameters().getSessionId())) {
        validTo = SessionDataContainer.getInstance().getValidTo(getParameters().getSessionId());
        if (validTo.compareTo(new Date(System.currentTimeMillis())) < 0) {
            SessionDataContainer.getInstance().removeSession(getParameters().getSessionId());
            return failCanDoAction(VdcBllMessages.USER_CANNOT_LOGIN_SESSION_MISSING);
        }
        SessionDataContainer.getInstance().setUser(getParameters().getSessionId(), getCurrentUser());
    } else {
        if (!SessionDataContainer.getInstance().setUser(getCurrentUser())) {
            return failCanDoAction(VdcBllMessages.USER_CANNOT_LOGIN_SESSION_MISSING);
        }
        try {
            validTo = new SimpleDateFormat("yyyy-MM-dd HH:mm:ssZ").parse(authRecord.<String>get(AuthRecord.VALID_TO));
        } catch (ParseException e) {
            log.warn("Error parsing AuthRecord.VALID_TO . Default VALID_TO value will be set on session");
            validTo = DateUtils.addMinutes(new Date(System.currentTimeMillis()), Config.<Integer>getValue(ConfigValues.UserSessionTimeOutInterval));
        }
        SessionDataContainer.getInstance().setValidTo(validTo);
    }
    return true;
}
#method_after
protected boolean attachUserToSession() {
    if (!StringUtils.isEmpty(getParameters().getSessionId())) {
        SessionDataContainer.getInstance().setUser(getParameters().getSessionId(), getCurrentUser());
    } else {
        if (!SessionDataContainer.getInstance().setUser(getCurrentUser())) {
            return failCanDoAction(VdcBllMessages.USER_CANNOT_LOGIN_SESSION_MISSING);
        }
        SessionDataContainer.getInstance().refresh();
        int userSessionHardLimit = Config.<Integer>getValue(ConfigValues.UserSessionHardLimit);
        Date validTo = userSessionHardLimit != 0 ? DateUtils.addMinutes(new Date(), userSessionHardLimit) : null;
        if (authRecord.<String>get(AuthRecord.VALID_TO) != null) {
            try {
                Date fromExtension = new SimpleDateFormat("yyyy-MM-dd HH:mm:ssZ").parse(authRecord.<String>get(AuthRecord.VALID_TO));
                if (validTo != null) {
                    validTo = validTo.compareTo(fromExtension) < 0 ? validTo : fromExtension;
                } else {
                    validTo = fromExtension;
                }
            } catch (ParseException e) {
                log.warn("Error parsing AuthRecord.VALID_TO . Default VALID_TO value will be set on session");
                log.debug("Exception is ", e);
            }
        }
        SessionDataContainer.getInstance().setHardLimit(validTo);
    }
    return true;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    authnExtension = profile.getAuthn();
    if (!isPasswordAuth()) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    authRecord = authenticate(loginName, password);
    if (authRecord != null) {
        DirectoryUser directoryUser = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
        if (directoryUser == null) {
            log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // Check that the user exists in the database, if it doesn't exist then we need to add it now:
        dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), directoryUser.getId());
        if (dbUser == null) {
            dbUser = new DbUser(directoryUser);
            String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
            dbUser.setGroupIds(groupIds);
            dbUser.setId(Guid.newGuid());
            getDbUserDAO().save(dbUser);
        }
        // except the login command
        if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
        log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
        dbUser.setAdmin(isAdmin);
        setCurrentUser(dbUser);
        // Add the user password to the session, as it will be needed later
        // when trying to log on to virtual machines:
        SessionDataContainer.getInstance().setPassword(password);
        return true;
    }
    return false;
// Check that the user exists in the directory associated to the authentication profile:
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    authnExtension = profile.getAuthn();
    SessionDataContainer.getInstance().setAuthn(authnExtension);
    if (!isPasswordAuth()) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    authRecord = authenticate(loginName, password);
    if (authRecord != null) {
        DirectoryUser directoryUser = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
        if (directoryUser == null) {
            log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // Check that the user exists in the database, if it doesn't exist then we need to add it now:
        dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), directoryUser.getId());
        if (dbUser == null) {
            dbUser = new DbUser(directoryUser);
            String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
            dbUser.setGroupIds(groupIds);
            dbUser.setId(Guid.newGuid());
            getDbUserDAO().save(dbUser);
        }
        // except the login command
        if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
        log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
        dbUser.setAdmin(isAdmin);
        setCurrentUser(dbUser);
        // Add the user password to the session, as it will be needed later
        // when trying to log on to virtual machines:
        SessionDataContainer.getInstance().setPassword(password);
        return true;
    }
    return false;
// Check that the user exists in the directory associated to the authentication profile:
}
#end_block

#method_before
private ExtMap authenticate(String user, String password) {
    ExtMap result = null;
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessage(String.format("$URL %1$s", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL)));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessage(String.format("$MSG %1$s", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE)));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            addCanDoActionMessage(vdcBllMessagesMap.get(authResult));
        }
        result = null;
    } else {
        ExtensionProxy mapper = profile.getMapper();
        if (mapper != null) {
            outputMap.put(Authn.InvokeKeys.AUTH_RECORD, mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD))));
        }
        result = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
    }
    return result;
}
#method_after
private ExtMap authenticate(String user, String password) {
    ExtMap result = null;
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).<String>get(Mapping.InvokeKeys.USER, user);
    }
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    SessionDataContainer.getInstance().setPrincipal(outputMap.<String>get(Authn.InvokeKeys.PRINCIPAL));
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessage(String.format("$URL %1$s", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL)));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessage(String.format("$MSG %1$s", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE)));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            addCanDoActionMessage(vdcBllMessagesMap.get(authResult));
        }
        result = null;
    } else {
        result = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
        if (mapper != null) {
            result = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, result), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, result);
        }
    }
    return result;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    authnExtension = profile.getAuthn();
    if (!isPasswordAuth()) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    ExtMap authRecord = authenticate(loginName, password);
    if (authRecord != null) {
        DirectoryUser directoryUser = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
        if (directoryUser == null) {
            log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // Check that the user exists in the database, if it doesn't exist then we need to add it now:
        dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), directoryUser.getId());
        if (dbUser == null) {
            dbUser = new DbUser(directoryUser);
            String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
            dbUser.setGroupIds(groupIds);
            dbUser.setId(Guid.newGuid());
            getDbUserDAO().save(dbUser);
        }
        // except the login command
        if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
        log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
        dbUser.setAdmin(isAdmin);
        setCurrentUser(dbUser);
        // Add the user password to the session, as it will be needed later
        // when trying to log on to virtual machines:
        SessionDataContainer.getInstance().setPassword(password);
        return true;
    }
    return false;
// Check that the user exists in the directory associated to the authentication profile:
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    authnExtension = profile.getAuthn();
    SessionDataContainer.getInstance().setAuthn(authnExtension);
    if (!isPasswordAuth()) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    authRecord = authenticate(loginName, password);
    if (authRecord != null) {
        DirectoryUser directoryUser = AuthzUtils.fetchPrincipalRecord(profile.getAuthz(), authRecord);
        if (directoryUser == null) {
            log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // Check that the user exists in the database, if it doesn't exist then we need to add it now:
        dbUser = getDbUserDAO().getByExternalId(AuthzUtils.getName(profile.getAuthz()), directoryUser.getId());
        if (dbUser == null) {
            dbUser = new DbUser(directoryUser);
            String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
            dbUser.setGroupIds(groupIds);
            dbUser.setId(Guid.newGuid());
            getDbUserDAO().save(dbUser);
        }
        // except the login command
        if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
            addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
            return false;
        }
        // Retrieve the MLA admin status of the user.
        // This may be redundant in some use-cases, but looking forward to Single Sign On,
        // we will want this info
        boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
        log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
        dbUser.setAdmin(isAdmin);
        setCurrentUser(dbUser);
        // Add the user password to the session, as it will be needed later
        // when trying to log on to virtual machines:
        SessionDataContainer.getInstance().setPassword(password);
        return true;
    }
    return false;
// Check that the user exists in the directory associated to the authentication profile:
}
#end_block

#method_before
private ExtMap authenticate(String user, String password) {
    ExtMap result = null;
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessage(String.format("$URL %1$s", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL)));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessage(String.format("$MSG %1$s", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE)));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            addCanDoActionMessage(vdcBllMessagesMap.get(authResult));
        }
        result = null;
    } else {
        ExtensionProxy mapper = profile.getMapper();
        if (mapper != null) {
            outputMap.put(Authn.InvokeKeys.AUTH_RECORD, mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD))));
        }
        result = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
    }
    return result;
}
#method_after
private ExtMap authenticate(String user, String password) {
    ExtMap result = null;
    ExtensionProxy mapper = profile.getMapper();
    if (mapper != null) {
        user = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_USER).mput(Mapping.InvokeKeys.USER, user), true).<String>get(Mapping.InvokeKeys.USER, user);
    }
    ExtMap outputMap = authnExtension.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Authn.InvokeCommands.AUTHENTICATE_CREDENTIALS).mput(Authn.InvokeKeys.USER, user).mput(Authn.InvokeKeys.CREDENTIALS, password));
    SessionDataContainer.getInstance().setPrincipal(outputMap.<String>get(Authn.InvokeKeys.PRINCIPAL));
    int authResult = outputMap.<Integer>get(Authn.InvokeKeys.RESULT);
    if (authResult != Authn.AuthResult.SUCCESS) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", user, getParameters().getProfileName());
        AuditLogType auditLogType = auditLogMap.get(authResult);
        // anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            logEventForUser(user, auditLogType);
        }
        if (authResult == Authn.AuthResult.CREDENTIALS_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                addCanDoActionMessage(String.format("$URL %1$s", outputMap.<String>get(Authn.InvokeKeys.CREDENTIALS_CHANGE_URL)));
                addedUserPasswordExpiredCDA = true;
            }
            if (outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE) != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                addCanDoActionMessage(String.format("$MSG %1$s", outputMap.<String>get(Authn.InvokeKeys.USER_MESSAGE)));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            addCanDoActionMessage(vdcBllMessagesMap.get(authResult));
        }
        result = null;
    } else {
        result = outputMap.<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD);
        if (mapper != null) {
            result = mapper.invoke(new ExtMap().mput(Base.InvokeKeys.COMMAND, Mapping.InvokeCommands.MAP_AUTH_RECORD).mput(Authn.InvokeKeys.AUTH_RECORD, result), true).<ExtMap>get(Authn.InvokeKeys.AUTH_RECORD, result);
        }
    }
    return result;
}
#end_block

#method_before
private void createProfiles() throws ConfigurationException {
    ExtensionsManager.getInstance().dump();
    for (ExtensionProxy authnExtension : ExtensionsManager.getInstance().getProvidedExtensions(AUTHN_SERVICE)) {
        registerProfile(new AuthenticationProfile(authnExtension, ExtensionsManager.getInstance().getExtensionByName(authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_AUTHZ_PLUGIN)), ExtensionsManager.getInstance().getExtensionByName(authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_MAPPING_PLUGIN))));
    }
}
#method_after
private void createProfiles() throws ConfigurationException {
    for (ExtensionProxy authnExtension : ExtensionsManager.getInstance().getProvidedExtensions(AUTHN_SERVICE)) {
        registerProfile(new AuthenticationProfile(authnExtension, ExtensionsManager.getInstance().getExtensionByName(authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_AUTHZ_PLUGIN)), ExtensionsManager.getInstance().getExtensionByName(authnExtension.getContext().<Properties>get(Base.ContextKeys.CONFIGURATION).getProperty(AUTHN_MAPPING_PLUGIN))));
    }
}
#end_block

#method_before
@Override
public boolean getUserHasPermissions(String userName, String domain) throws SQLException {
    ResultSet resultSet = null;
    try (Connection connection = ds.getConnection();
        PreparedStatement prepareStatement = connection.prepareStatement(selectQuery)) {
        log.info("getPermissionsForUser  username: " + userName + " domain: " + domain);
        prepareStatement.setString(1, userName);
        prepareStatement.setString(2, domain);
        resultSet = prepareStatement.executeQuery();
        if (resultSet.next()) {
            return true;
        }
    } finally {
        if (resultSet != null) {
            resultSet.close();
        }
    }
    return false;
}
#method_after
@Override
public boolean getUserHasPermissions(String userName, String domain) throws SQLException {
    boolean result = false;
    try (Connection connection = ds.getConnection();
        PreparedStatement prepareStatement = connection.prepareStatement(selectQuery)) {
        log.info("getPermissionsForUser  username: " + userName + " domain: " + domain);
        prepareStatement.setString(1, userName);
        prepareStatement.setString(2, domain);
        try (ResultSet resultSet = prepareStatement.executeQuery()) {
            result = resultSet.next();
        }
    }
    return result;
}
#end_block

#method_before
private static DiskImage createDisk() {
    DiskImage disk = new DiskImage();
    disk.setId(Guid.newGuid());
    disk.setDiskAlias(RandomUtils.instance().nextString(10));
    disk.setActive(true);
    disk.setImageStatus(ImageStatus.OK);
    return disk;
}
#method_after
private static DiskImage createDisk() {
    DiskImage disk = new DiskImage();
    disk.setId(Guid.newGuid());
    disk.setDiskAlias(RandomUtils.instance().nextString(10));
    disk.setActive(true);
    disk.setImageStatus(ImageStatus.OK);
    ArrayList<Guid> storageDomainIds = new ArrayList<>();
    storageDomainIds.add(Guid.newGuid());
    disk.setStorageIds(storageDomainIds);
    return disk;
}
#end_block

#method_before
public ValidationResult diskImagesBelongToSameImageGroup() {
    Guid imageGroupId = null;
    for (DiskImage diskImage : diskImages) {
        if (imageGroupId == null || diskImage.getId().equals(imageGroupId)) {
            imageGroupId = diskImage.getId();
            continue;
        }
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_SNAPSHOTS_DONT_BELONG_TO_SAME_DISK, String.format("diskalias %s", diskImage.getDiskAlias()));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesBelongToSameImageGroup() {
    Guid imageGroupId = null;
    for (DiskImage diskImage : diskImages) {
        if (imageGroupId == null || diskImage.getId().equals(imageGroupId)) {
            imageGroupId = diskImage.getId();
            continue;
        }
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_SNAPSHOTS_DONT_BELONG_TO_SAME_DISK);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#method_after
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null && !removedBonds.containsKey(nic.getName())) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#end_block

#method_before
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || nic.isQosOverridden() != existingNic.isQosOverridden() || !Objects.equals(nic.getCustomProperties(), existingNic.getCustomProperties())) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#method_after
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || nic.isQosOverridden() != existingNic.isQosOverridden() || customPropertiesChanged(nic, existingNic)) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#end_block

#method_before
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<String, String>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        String networkName = iface.getNetworkName();
        if (iface.getCustomProperties() != null) {
            if (!networkCustomPropertiesSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
            } else if (!util.validateProperties(existingClusterNetworks.get(networkName).isVmNetwork() ? validProperties : validPropertiesNonVm, iface.getCustomProperties()).isEmpty()) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
            }
        }
    }
}
#method_after
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    Map<String, String> validPropertiesNonVm = new HashMap<String, String>(validProperties);
    validPropertiesNonVm.remove("bridge_opts");
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.hasCustomProperties()) {
            String networkName = iface.getNetworkName();
            if (StringUtils.isEmpty(networkName)) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NO_NETWORK, iface.getName());
            } else {
                if (!networkCustomPropertiesSupported) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
                }
                Network network = existingClusterNetworks.get(networkName);
                List<ValidationError> errors = util.validateProperties(network == null || network.isVmNetwork() ? validProperties : validPropertiesNonVm, iface.getCustomProperties());
                if (!errors.isEmpty()) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
                    List<String> messages = new ArrayList<>();
                    util.handleCustomPropertiesError(errors, messages);
                    log.error(StringUtils.join(translateErrorMessages(messages), ','));
                }
            }
        }
    }
}
#end_block

#method_before
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        VdsNetworkInterface existingIface = getExistingIfaces().get(newIface.getName());
        if (existingIface != null && !isBond(existingIface) && existingIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = existingIface.getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.contains(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#method_after
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        VdsNetworkInterface existingIface = getExistingIfaces().get(newIface.getName());
        if (existingIface != null && !isBond(existingIface) && existingIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = existingIface.getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.containsKey(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#end_block

#method_before
private boolean networkWasModified(VdsNetworkInterface iface) {
    VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
    if (existingIface == null) {
        return true;
    }
    return !ObjectUtils.equals(iface.getNetworkName(), existingIface.getNetworkName()) || iface.getBootProtocol() != existingIface.getBootProtocol() || staticBootProtoPropertiesChanged(iface, existingIface) || !ObjectUtils.equals(iface.getQos(), existingIface.getQos()) || !ObjectUtils.equals(iface.getCustomProperties(), existingIface.getCustomProperties());
}
#method_after
private boolean networkWasModified(VdsNetworkInterface iface) {
    VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
    if (existingIface == null) {
        return true;
    }
    return !ObjectUtils.equals(iface.getNetworkName(), existingIface.getNetworkName()) || iface.getBootProtocol() != existingIface.getBootProtocol() || staticBootProtoPropertiesChanged(iface, existingIface) || !ObjectUtils.equals(iface.getQos(), existingIface.getQos()) || customPropertiesChanged(iface, existingIface);
}
#end_block

#method_before
private void extractRemovedBonds() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String bondName = iface.getBondName();
        if (StringUtils.isNotBlank(bondName) && !bonds.containsKey(bondName)) {
            removedBonds.add(bondName);
        }
    }
}
#method_after
private void extractRemovedBonds() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String bondName = iface.getBondName();
        if (StringUtils.isNotBlank(bondName) && !bonds.containsKey(bondName)) {
            VdsNetworkInterface existingBond = getExistingIfaces().get(bondName);
            existingBond.setLabels(null);
            removedBonds.put(bondName, existingBond);
        }
    }
}
#end_block

#method_before
public Set<String> getRemovedBonds() {
    return removedBonds;
}
#method_after
public Map<String, VdsNetworkInterface> getRemovedBonds() {
    return removedBonds;
}
#end_block

#method_before
@Test
public void customPropertiesNotSupported() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, MANAGEMENT_NETWORK_NAME);
}
#method_after
@Test
public void customPropertiesNotSupported() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
}
#end_block

#method_before
private void assertBondRemoved(SetupNetworksHelper helper, String expectedBondName) {
    assertTrue(MessageFormat.format("Expected bond ''{0}'' to be removed but it wasn''t. Removed bonds: {1}", expectedBondName, helper.getRemovedBonds()), helper.getRemovedBonds().contains(expectedBondName));
}
#method_after
private void assertBondRemoved(SetupNetworksHelper helper, String expectedBondName) {
    assertTrue(MessageFormat.format("Expected bond ''{0}'' to be removed but it wasn''t. Removed bonds: {1}", expectedBondName, helper.getRemovedBonds()), helper.getRemovedBonds().containsKey(expectedBondName));
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds, Version compatibilityVersion) {
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(compatibilityVersion);
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, vds));
    when(helper.getVmInterfaceManager()).thenReturn(vmInterfaceManager);
    DbFacade dbFacade = mock(DbFacade.class);
    doReturn(dbFacade).when(helper).getDbFacade();
    doReturn(interfaceDAO).when(dbFacade).getInterfaceDao();
    doReturn(mock(VdsDAO.class)).when(dbFacade).getVdsDao();
    doReturn(networkDAO).when(dbFacade).getNetworkDao();
    doReturn(qosDao).when(dbFacade).getQosDao();
    return helper;
}
#method_after
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds, Version compatibilityVersion) {
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(compatibilityVersion);
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, vds));
    when(helper.getVmInterfaceManager()).thenReturn(vmInterfaceManager);
    doReturn(null).when(helper).translateErrorMessages(any(List.class));
    DbFacade dbFacade = mock(DbFacade.class);
    doReturn(dbFacade).when(helper).getDbFacade();
    doReturn(interfaceDAO).when(dbFacade).getInterfaceDao();
    doReturn(mock(VdsDAO.class)).when(dbFacade).getVdsDao();
    doReturn(networkDAO).when(dbFacade).getNetworkDao();
    doReturn(qosDao).when(dbFacade).getQosDao();
    return helper;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (!StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getcompatibility_version()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getCustomProperties() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (!StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (FeatureSupported.networkCustomProperties(getSourceCluster().getcompatibility_version()) && !FeatureSupported.networkCustomProperties(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.hasCustomProperties()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#method_after
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null && !removedBonds.containsKey(nic.getName())) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#end_block

#method_before
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || nic.isQosOverridden() != existingNic.isQosOverridden() || !Objects.equals(nic.getCustomProperties(), existingNic.getCustomProperties())) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#method_after
private void extractModifiedInterfaces() {
    for (VdsNetworkInterface nic : params.getInterfaces()) {
        VdsNetworkInterface existingNic = getExistingIfaces().get(nic.getName());
        if (existingNic != null) {
            Set<String> newLabels = NetworkUtils.isLabeled(nic) ? nic.getLabels() : Collections.<String>emptySet();
            Set<String> existingLabels = NetworkUtils.isLabeled(existingNic) ? existingNic.getLabels() : Collections.<String>emptySet();
            if (!CollectionUtils.isEqualCollection(newLabels, existingLabels) || nic.isQosOverridden() != existingNic.isQosOverridden() || customPropertiesChanged(nic, existingNic)) {
                existingNic.setLabels(newLabels);
                existingNic.setQosOverridden(nic.isQosOverridden());
                existingNic.setCustomProperties(nic.getCustomProperties());
                modifiedInterfaces.add(existingNic);
            }
        }
    }
}
#end_block

#method_before
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.getCustomProperties() != null) {
            if (!networkCustomPropertiesSupported) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, iface.getNetworkName());
            } else if (!util.validateProperties(validProperties, iface.getCustomProperties()).isEmpty()) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, iface.getNetworkName());
            }
        }
    }
}
#method_after
private void validateCustomProperties() {
    String version = vds.getVdsGroupCompatibilityVersion().getValue();
    SimpleCustomPropertiesUtil util = SimpleCustomPropertiesUtil.getInstance();
    Map<String, String> validProperties = util.convertProperties(Config.<String>getValue(ConfigValues.PreDefinedNetworkCustomProperties, version));
    validProperties.putAll(util.convertProperties(Config.<String>getValue(ConfigValues.UserDefinedNetworkCustomProperties, version)));
    for (VdsNetworkInterface iface : params.getInterfaces()) {
        if (iface.hasCustomProperties()) {
            String networkName = iface.getNetworkName();
            if (StringUtils.isEmpty(networkName)) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NO_NETWORK, iface.getName());
            } else {
                if (!networkCustomPropertiesSupported) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, networkName);
                }
                List<ValidationError> errors = util.validateProperties(validProperties, iface.getCustomProperties());
                if (!errors.isEmpty()) {
                    addViolation(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_BAD_INPUT, networkName);
                    List<String> messages = new ArrayList<>();
                    util.handleCustomPropertiesError(errors, messages);
                    log.error(StringUtils.join(translateErrorMessages(messages), ','));
                }
            }
        }
    }
}
#end_block

#method_before
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        VdsNetworkInterface existingIface = getExistingIfaces().get(newIface.getName());
        if (existingIface != null && !isBond(existingIface) && existingIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = existingIface.getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.contains(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#method_after
private void detectSlaveChanges() {
    for (VdsNetworkInterface newIface : params.getInterfaces()) {
        VdsNetworkInterface existingIface = getExistingIfaces().get(newIface.getName());
        if (existingIface != null && !isBond(existingIface) && existingIface.getVlanId() == null) {
            String bondNameInNewIface = newIface.getBondName();
            String bondNameInOldIface = existingIface.getBondName();
            if (!StringUtils.equals(bondNameInNewIface, bondNameInOldIface)) {
                if (bondNameInNewIface != null && !modifiedBonds.containsKey(bondNameInNewIface)) {
                    modifiedBonds.put(bondNameInNewIface, getExistingIfaces().get(bondNameInNewIface));
                }
                if (bondNameInOldIface != null && !modifiedBonds.containsKey(bondNameInNewIface) && !removedBonds.containsKey(bondNameInOldIface)) {
                    modifiedBonds.put(bondNameInOldIface, getExistingIfaces().get(bondNameInOldIface));
                }
            }
        }
    }
}
#end_block

#method_before
private boolean networkWasModified(VdsNetworkInterface iface) {
    VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
    if (existingIface == null) {
        return true;
    }
    return !ObjectUtils.equals(iface.getNetworkName(), existingIface.getNetworkName()) || iface.getBootProtocol() != existingIface.getBootProtocol() || staticBootProtoPropertiesChanged(iface, existingIface) || !ObjectUtils.equals(iface.getQos(), existingIface.getQos()) || !ObjectUtils.equals(iface.getCustomProperties(), existingIface.getCustomProperties());
}
#method_after
private boolean networkWasModified(VdsNetworkInterface iface) {
    VdsNetworkInterface existingIface = getExistingIfaces().get(iface.getName());
    if (existingIface == null) {
        return true;
    }
    return !ObjectUtils.equals(iface.getNetworkName(), existingIface.getNetworkName()) || iface.getBootProtocol() != existingIface.getBootProtocol() || staticBootProtoPropertiesChanged(iface, existingIface) || !ObjectUtils.equals(iface.getQos(), existingIface.getQos()) || customPropertiesChanged(iface, existingIface);
}
#end_block

#method_before
private void extractRemovedBonds() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String bondName = iface.getBondName();
        if (StringUtils.isNotBlank(bondName) && !bonds.containsKey(bondName)) {
            removedBonds.add(bondName);
        }
    }
}
#method_after
private void extractRemovedBonds() {
    for (VdsNetworkInterface iface : getExistingIfaces().values()) {
        String bondName = iface.getBondName();
        if (StringUtils.isNotBlank(bondName) && !bonds.containsKey(bondName)) {
            VdsNetworkInterface existingBond = getExistingIfaces().get(bondName);
            existingBond.setLabels(null);
            removedBonds.put(bondName, existingBond);
        }
    }
}
#end_block

#method_before
public Set<String> getRemovedBonds() {
    return removedBonds;
}
#method_after
public Map<String, VdsNetworkInterface> getRemovedBonds() {
    return removedBonds;
}
#end_block

#method_before
public void parsePropertiesRegex(String properties, Map<String, Pattern> keysToRegex) {
    if (StringUtils.isEmpty(properties)) {
        return;
    }
    String[] propertiesStrs = semicolonPattern.split(properties);
    // Property is in the form of key=regex
    for (String property : propertiesStrs) {
        Pattern pattern = null;
        String[] propertyParts = property.split(KEY_VALUE_DELIMETER, 2);
        if (propertyParts.length == 1) {
            // there is no value(regex) for the property - we assume in that case that any value is allowed except
            // for the properties delimiter
            pattern = valuePattern;
        } else {
            pattern = Pattern.compile(propertyParts[1]);
        }
        keysToRegex.put(propertyParts[0], pattern);
    }
}
#method_after
protected void parsePropertiesRegex(String properties, Map<String, Pattern> keysToRegex) {
    if (StringUtils.isEmpty(properties)) {
        return;
    }
    String[] propertiesStrs = semicolonPattern.split(properties);
    // Property is in the form of key=regex
    for (String property : propertiesStrs) {
        Pattern pattern = null;
        String[] propertyParts = property.split(KEY_VALUE_DELIMETER, 2);
        if (propertyParts.length == 1) {
            // there is no value(regex) for the property - we assume in that case that any value is allowed except
            // for the properties delimiter
            pattern = valuePattern;
        } else {
            pattern = Pattern.compile(propertyParts[1]);
        }
        keysToRegex.put(propertyParts[0], pattern);
    }
}
#end_block

#method_before
@Test
public void customPropertiesNotSupported() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, MANAGEMENT_NETWORK_NAME);
}
#method_after
@Test
public void customPropertiesNotSupported() {
    Network network = createNetwork(MANAGEMENT_NETWORK_NAME);
    mockExistingNetworks(network);
    VdsNetworkInterface iface = createNicSyncedWithNetwork("eth0", network);
    mockExistingIfaces(iface);
    iface.setCustomProperties(createCustomProperties());
    SetupNetworksHelper helper = createHelper(createParametersForNics(iface));
    validateAndExpectViolation(helper, VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_CUSTOM_PROPERTIES_NOT_SUPPORTED, network.getName());
}
#end_block

#method_before
private void assertBondRemoved(SetupNetworksHelper helper, String expectedBondName) {
    assertTrue(MessageFormat.format("Expected bond ''{0}'' to be removed but it wasn''t. Removed bonds: {1}", expectedBondName, helper.getRemovedBonds()), helper.getRemovedBonds().contains(expectedBondName));
}
#method_after
private void assertBondRemoved(SetupNetworksHelper helper, String expectedBondName) {
    assertTrue(MessageFormat.format("Expected bond ''{0}'' to be removed but it wasn''t. Removed bonds: {1}", expectedBondName, helper.getRemovedBonds()), helper.getRemovedBonds().containsKey(expectedBondName));
}
#end_block

#method_before
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds, Version compatibilityVersion) {
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(compatibilityVersion);
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, vds));
    when(helper.getVmInterfaceManager()).thenReturn(vmInterfaceManager);
    DbFacade dbFacade = mock(DbFacade.class);
    doReturn(dbFacade).when(helper).getDbFacade();
    doReturn(interfaceDAO).when(dbFacade).getInterfaceDao();
    doReturn(mock(VdsDAO.class)).when(dbFacade).getVdsDao();
    doReturn(networkDAO).when(dbFacade).getNetworkDao();
    doReturn(qosDao).when(dbFacade).getQosDao();
    return helper;
}
#method_after
private SetupNetworksHelper createHelper(SetupNetworksParameters params, VDS vds, Version compatibilityVersion) {
    when(vds.getVdsGroupCompatibilityVersion()).thenReturn(compatibilityVersion);
    SetupNetworksHelper helper = spy(new SetupNetworksHelper(params, vds));
    when(helper.getVmInterfaceManager()).thenReturn(vmInterfaceManager);
    doReturn(null).when(helper).translateErrorMessages(any(List.class));
    DbFacade dbFacade = mock(DbFacade.class);
    doReturn(dbFacade).when(helper).getDbFacade();
    doReturn(interfaceDAO).when(dbFacade).getInterfaceDao();
    doReturn(mock(VdsDAO.class)).when(dbFacade).getVdsDao();
    doReturn(networkDAO).when(dbFacade).getNetworkDao();
    doReturn(qosDao).when(dbFacade).getQosDao();
    return helper;
}
#end_block

#method_before
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        Version version = getDbFacade().getVdsDao().get(getParameters().getVdsId()).getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (FeatureSupported.defaultRoute(version) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.getCustomProperties() != null) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#method_after
private Map<String, Object> generateNetworks() {
    Map<String, Object> networks = new HashMap<String, Object>();
    NetworkQoSDao qosDao = getDbFacade().getQosDao();
    for (Network network : getParameters().getNetworks()) {
        Map<String, Object> opts = new HashMap<String, Object>();
        VdsNetworkInterface iface = findNetworkInterface(network.getName(), getParameters().getInterfaces(), getParameters().getBonds());
        String ifaceNameWithoutVlan = NetworkUtils.stripVlan(iface.getName());
        Boolean bonded = findInterfaceByName(ifaceNameWithoutVlan).getBonded();
        String type = (bonded != null && bonded) ? "bonding" : "nic";
        opts.put(type, ifaceNameWithoutVlan);
        if (NetworkUtils.isVlan(network)) {
            opts.put("vlan", network.getVlanId().toString());
        }
        if (iface.getBootProtocol() != null) {
            addBootProtocol(opts, iface);
        }
        if (network.getMtu() != 0) {
            opts.put("mtu", String.valueOf(network.getMtu()));
        }
        opts.put("bridged", Boolean.toString(network.isVmNetwork()));
        if (network.isVmNetwork()) {
            opts.put(VdsProperties.STP, network.getStp() ? "yes" : "no");
        }
        Version version = getDbFacade().getVdsDao().get(getParameters().getVdsId()).getVdsGroupCompatibilityVersion();
        if (qosConfiguredOnInterface(iface, network) && FeatureSupported.hostNetworkQos(version)) {
            NetworkQosMapper qosMapper = new NetworkQosMapper(opts, VdsProperties.HOST_QOS_INBOUND, VdsProperties.HOST_QOS_OUTBOUND);
            qosMapper.serialize(iface.isQosOverridden() ? iface.getQos() : qosDao.get(network.getQosId()));
        }
        if (FeatureSupported.defaultRoute(version) && NetworkUtils.isManagementNetwork(network) && (iface.getBootProtocol() == NetworkBootProtocol.DHCP || (iface.getBootProtocol() == NetworkBootProtocol.STATIC_IP && StringUtils.isNotEmpty(iface.getGateway())))) {
            opts.put(DEFAULT_ROUTE, Boolean.TRUE);
        }
        if (iface.hasCustomProperties()) {
            opts.put(VdsProperties.NETWORK_CUSTOM_PROPERTIES, iface.getCustomProperties());
        }
        networks.put(network.getName(), opts);
    }
    for (String net : getParameters().getRemovedNetworks()) {
        networks.put(net, REMOVE_OBJ);
    }
    return networks;
}
#end_block

#method_before
private MapSqlParameterSource createInterfaceParametersMapper(VdsNetworkInterface nic) {
    return getCustomMapSqlParameterSource().addValue("addr", nic.getAddress()).addValue("bond_name", nic.getBondName()).addValue("bond_type", nic.getBondType()).addValue("gateway", nic.getGateway()).addValue("id", nic.getId()).addValue("is_bond", nic.getBonded()).addValue("bond_opts", nic.getBondOptions()).addValue("mac_addr", nic.getMacAddress()).addValue("name", nic.getName()).addValue("network_name", nic.getNetworkName()).addValue("speed", nic.getSpeed()).addValue("subnet", nic.getSubnet()).addValue("boot_protocol", nic.getBootProtocol()).addValue("type", nic.getType()).addValue("vds_id", nic.getVdsId()).addValue("vlan_id", nic.getVlanId()).addValue("mtu", nic.getMtu()).addValue("bridged", nic.isBridged()).addValue("qos_overridden", nic.isQosOverridden()).addValue("labels", SerializationFactory.getSerializer().serialize(nic.getLabels())).addValue("custom_properties", SerializationFactory.getSerializer().serialize(nic.hasCustomProperties() ? nic.getCustomProperties() : null));
}
#method_after
private MapSqlParameterSource createInterfaceParametersMapper(VdsNetworkInterface nic) {
    return getCustomMapSqlParameterSource().addValue("addr", nic.getAddress()).addValue("bond_name", nic.getBondName()).addValue("bond_type", nic.getBondType()).addValue("gateway", nic.getGateway()).addValue("id", nic.getId()).addValue("is_bond", nic.getBonded()).addValue("bond_opts", nic.getBondOptions()).addValue("mac_addr", nic.getMacAddress()).addValue("name", nic.getName()).addValue("network_name", nic.getNetworkName()).addValue("speed", nic.getSpeed()).addValue("subnet", nic.getSubnet()).addValue("boot_protocol", nic.getBootProtocol()).addValue("type", nic.getType()).addValue("vds_id", nic.getVdsId()).addValue("vlan_id", nic.getVlanId()).addValue("mtu", nic.getMtu()).addValue("bridged", nic.isBridged()).addValue("qos_overridden", nic.isQosOverridden()).addValue("labels", SerializationFactory.getSerializer().serialize(nic.getLabels())).addValue("custom_properties", nic.hasCustomProperties() ? SerializationFactory.getSerializer().serialize(nic.getCustomProperties()) : null);
}
#end_block

#method_before
public void setAsDisplay() {
    final Network network = (Network) Cloner.clone(getSelectedItem());
    network.getCluster().setDisplay(true);
    final AttachNetworkToVdsGroupParameter attachNetworkToVdcGroupParameter = new AttachNetworkToVdsGroupParameter(getEntity(), network);
    Frontend.getInstance().runAction(VdcActionType.AttachNetworkToVdsGroup, attachNetworkToVdcGroupParameter);
}
#method_after
public void setAsDisplay() {
    final Network network = (Network) Cloner.clone(getSelectedItem());
    network.getCluster().setDisplay(true);
    final NetworkClusterParameters networkClusterParameters = new NetworkClusterParameters(network.getCluster());
    Frontend.getInstance().runAction(VdcActionType.UpdateNetworkOnCluster, networkClusterParameters);
}
#end_block

#method_before
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    duringFailureJobId = sched.scheduleAFixedDelayJob(this, "onVdsDuringFailureTimer", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
    sched.pauseJob(duringFailureJobId);
    // start with refresh statistics
    _refreshIteration = _numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], VDS_REFRESH_RATE, VDS_REFRESH_RATE, TimeUnit.MILLISECONDS);
}
#method_after
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    // start with refresh statistics
    _refreshIteration = _numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], VDS_REFRESH_RATE, VDS_REFRESH_RATE, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtilQuartzImpl.getInstance().resumeJob(duringFailureJobId);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh host capabilities");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getStatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitStatus(), vmInternalData.getVmDynamic().getExitMessage());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getStatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitStatus(), vmInternalData.getVmDynamic().getExitMessage(), vmInternalData.getVmDynamic().getExitReason());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void clearVm(VM vm, VmExitStatus exitStatus, String exitMessage) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to _vmDynamicToSave though because it might been removed from it in #updateRepository
        if (vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.Down) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down, exitStatus, exitMessage);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#method_after
private void clearVm(VM vm, VmExitStatus exitStatus, String exitMessage, VmExitReason exitReason) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to _vmDynamicToSave though because it might been removed from it in #updateRepository
        if (vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.Down) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down, exitStatus, exitMessage, exitReason);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getStatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitStatus(), vmInternalData.getVmDynamic().getExitMessage());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#method_after
private void proceedDownVms() {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic vm = vmInternalData.getVmDynamic();
        if (vm.getStatus() != VMStatus.Down) {
            continue;
        }
        VM vmTo = _vmDict.get(vm.getId());
        VMStatus status = VMStatus.Unassigned;
        if (vmTo != null) {
            status = vmTo.getStatus();
            proceedVmBeforeDeletion(vmTo, vm);
            // when going to suspend, delete vm from cache later
            if (status == VMStatus.SavingState) {
                ResourceManager.getInstance().InternalSetVmStatus(vmTo, VMStatus.Suspended);
            }
            clearVm(vmTo, vmInternalData.getVmDynamic().getExitStatus(), vmInternalData.getVmDynamic().getExitMessage(), vmInternalData.getVmDynamic().getExitReason());
        }
        VmStatistics vmStatistics = getDbFacade().getVmStatisticsDao().get(vm.getId());
        if (vmStatistics != null) {
            DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(_vds.getId(), vm.getId(), false, false, 0));
            vdsBrokerCommand.execute();
            if (vmTo != null && status == VMStatus.SavingState) {
                afterSuspendTreatment(vm);
            } else if (status != VMStatus.MigratingFrom) {
                handleVmOnDown(vmTo, vm, vmStatistics);
            }
        }
    }
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage(), vmDynamic.getExitReason());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void clearVm(VM vm, VmExitStatus exitStatus, String exitMessage) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to _vmDynamicToSave though because it might been removed from it in #updateRepository
        if (vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.Down) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down, exitStatus, exitMessage);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#method_after
private void clearVm(VM vm, VmExitStatus exitStatus, String exitMessage, VmExitReason exitReason) {
    if (vm.getStatus() != VMStatus.MigratingFrom) {
        // we will add it to _vmDynamicToSave though because it might been removed from it in #updateRepository
        if (vm.getStatus() != VMStatus.Suspended && vm.getStatus() != VMStatus.Down) {
            ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.Down, exitStatus, exitMessage, exitReason);
        }
        addVmDynamicToList(vm.getDynamicData());
        addVmStatisticsToList(vm.getStatisticsData());
        addVmInterfaceStatisticsToList(vm.getInterfaces());
        if (!ResourceManager.getInstance().IsVmInAsyncRunningList(vm.getId())) {
            _vmsMovedToDown.add(vm.getId());
        }
    }
}
#end_block

#method_before
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    duringFailureJobId = sched.scheduleAFixedDelayJob(this, "onVdsDuringFailureTimer", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
    sched.pauseJob(duringFailureJobId);
    // start with refresh statistics
    _refreshIteration = _numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], VDS_REFRESH_RATE, VDS_REFRESH_RATE, TimeUnit.MILLISECONDS);
}
#method_after
public void schedulJobs() {
    SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
    // start with refresh statistics
    _refreshIteration = _numberRefreshesBeforeSave - 1;
    onTimerJobId = sched.scheduleAFixedDelayJob(this, "onTimer", new Class[0], new Object[0], VDS_REFRESH_RATE, VDS_REFRESH_RATE, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtilQuartzImpl.getInstance().resumeJob(duringFailureJobId);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh host capabilities");
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds.getStaticData().getId());
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debugFormat("monitoring: refresh {0} capabilities", vds);
    VDS oldVDS = vds.clone();
    GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase> vdsBrokerCommand = new GetCapabilitiesVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(vds));
    vdsBrokerCommand.execute();
    if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getVdsGroupCompatibilityVersion();
        if (FeatureSupported.hardwareInfo(clusterCompatibility) && // host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = CollectVdsNetworkDataVDSCommand.persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debugFormat("monitoring: vds {0} networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
        // handleNetworkException
        if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException && handleNetworkException((VDSNetworkException) vdsBrokerCommand.getVDSReturnValue().getExceptionObject(), vds)) {
            updateDynamicData(vds.getDynamicData());
            updateStatisticsData(vds.getStatisticsData());
        }
        throw vdsBrokerCommand.getVDSReturnValue().getExceptionObject();
    } else {
        log.errorFormat("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
    }
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(reasonColumn, reasonColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    PercentColumn<VM> migrationProgressColumn = new OneColorPercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getMigrationProgressPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(migrationProgressColumn, constants.migrationProgress(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    TextColumnWithTooltip<VM> descriptionColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneVmCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(reasonColumn, reasonColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    PercentColumn<VM> migrationProgressColumn = new OneColorPercentColumn<VM>(ProgressBarColumn.ProgressBarColors.GREEN) {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getMigrationProgressPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(migrationProgressColumn, constants.migrationProgress(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    TextColumnWithTooltip<VM> descriptionColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cloneVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCloneVmCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
@Override
protected String getColorByProgress(int progress) {
    // $NON-NLS-1$
    return "#669966";
}
#method_after
@Override
protected String getColorByProgress(int progress) {
    return color.asCode();
}
#end_block

#method_before
protected String getColorByProgress(int progress) {
    // $NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    return progress < 70 ? "#669966" : progress < 95 ? "#FF9900" : "#FF0000";
}
#method_after
protected String getColorByProgress(int progress) {
    if (progress < 70) {
        return ProgressBarColors.GREEN.asCode();
    } else if (progress < 95) {
        return ProgressBarColors.ORANGE.asCode();
    } else {
        return ProgressBarColors.RED.asCode();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return noConflictingNetwork() && vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#method_after
@Override
protected boolean canDoAction() {
    return networkNotAttachedToCluster() && vdsGroupExists() && changesAreClusterCompatible() && logicalNetworkExists() && validateAttachment();
}
#end_block

#method_before
private boolean networkExists() {
    List<NetworkCluster> networks = getNetworkClusterDAO().getAllForCluster(getVdsGroupId());
    for (NetworkCluster networkCluster : networks) {
        if (networkCluster.getNetworkId().equals(getNetworkCluster().getNetworkId())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean networkExists() {
    return getNetworkClusterDAO().get(getNetworkCluster().getId()) != null;
}
#end_block

#method_before
public static void attachNetwork(Guid clusterId, NetworkCluster networkCluster, Network network) {
    getNetworkClusterDao().save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkCluster.isRequired(), networkCluster.isMigration()));
    NetworkClusterHelper.setStatus(clusterId, network);
}
#method_after
public static void attachNetwork(Guid clusterId, NetworkCluster networkCluster, Network network) {
    getNetworkClusterDao().save(new NetworkCluster(clusterId, network.getId(), NetworkStatus.OPERATIONAL, false, networkCluster.isRequired(), networkCluster.isMigration()));
    if (network.getCluster().isDisplay()) {
        getNetworkClusterDao().setNetworkExclusivelyAsDisplay(clusterId, network.getId());
    }
    if (network.getCluster().isMigration()) {
        getNetworkClusterDao().setNetworkExclusivelyAsMigration(clusterId, network.getId());
    }
    NetworkClusterHelper.setStatus(clusterId, network);
}
#end_block

#method_before
private void checkCanItemBeSelected(final IStorageModel item, StoragePool dataCenter, boolean isNoExportOrIsoStorageAttached) {
    boolean isExistingStorage = getModel().getStorage() != null && item.getType() == getModel().getStorage().getStorageType();
    // If we are in edit mode then the type of the entity edited should appear in the selection
    if (isExistingStorage) {
        updateItemSelectability(item, true);
        return;
    }
    // Local types should not be selectable for shared data centers and vice versa
    if (isLocalStorage(item) != dataCenter.isLocal()) {
        updateItemSelectability(item, false);
        return;
    }
    boolean isNoneDataCenter = dataCenter.getId().equals(StorageModel.UnassignedDataCenterId);
    boolean isDataDomain = item.getRole() == StorageDomainType.Data;
    // For 'None' data center we allow all data types and no ISO/Export, no reason for further checks
    if (isNoneDataCenter) {
        updateItemSelectability(item, isDataDomain);
        return;
    }
    boolean isExportDomain = item.getRole() == StorageDomainType.ImportExport;
    boolean canAttachExportDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    boolean isIsoDomain = item.getRole() == StorageDomainType.ISO;
    boolean canAttachIsoDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    if (isExportDomain && canAttachExportDomain || isIsoDomain && canAttachIsoDomain) {
        updateItemSelectability(item, true);
        return;
    }
    if (isDataDomain) {
        if (isLocalStorage(item)) {
            updateItemSelectability(item, true);
            return;
        }
        if (AsyncDataProvider.isMixedStorageDomainsSupported(dataCenter.getcompatibility_version())) {
            updateItemSelectability(item, true);
            return;
        } else {
            IdQueryParameters params = new IdQueryParameters(dataCenter.getId());
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageTypesInPoolByPoolId, params, new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    List<StorageType> storageTypes = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    for (StorageType storageType : storageTypes) {
                        if (storageType.isBlockDomain() != item.getType().isBlockDomain()) {
                            updateItemSelectability(item, false);
                            return;
                        }
                    }
                    updateItemSelectability(item, true);
                    return;
                }
            }));
            return;
        }
    }
    updateItemSelectability(item, false);
}
#method_after
private void checkCanItemBeSelected(final IStorageModel item, StoragePool dataCenter, boolean isNoExportOrIsoStorageAttached) {
    boolean isExistingStorage = getModel().getStorage() != null && item.getType() == getModel().getStorage().getStorageType();
    // If we are in edit mode then the type of the entity edited should appear in the selection
    if (isExistingStorage) {
        updateItemSelectability(item, true);
        return;
    }
    // Local types should not be selectable for shared data centers and vice versa
    if (isLocalStorage(item) != dataCenter.isLocal()) {
        updateItemSelectability(item, false);
        return;
    }
    boolean isNoneDataCenter = dataCenter.getId().equals(StorageModel.UnassignedDataCenterId);
    boolean isDataDomain = item.getRole() == StorageDomainType.Data;
    // For 'None' data center we allow all data types and no ISO/Export, no reason for further checks
    if (isNoneDataCenter) {
        updateItemSelectability(item, isDataDomain);
        return;
    }
    boolean isExportDomain = item.getRole() == StorageDomainType.ImportExport;
    boolean canAttachExportDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    boolean isIsoDomain = item.getRole() == StorageDomainType.ISO;
    boolean canAttachIsoDomain = isNoExportOrIsoStorageAttached && dataCenter.getStatus() != StoragePoolStatus.Uninitialized;
    if ((isExportDomain && canAttachExportDomain) || (isIsoDomain && canAttachIsoDomain)) {
        updateItemSelectability(item, true);
        return;
    }
    if (isDataDomain) {
        if (isLocalStorage(item)) {
            updateItemSelectability(item, true);
            return;
        }
        if (AsyncDataProvider.isMixedStorageDomainsSupported(dataCenter.getcompatibility_version())) {
            updateItemSelectability(item, true);
            return;
        } else {
            IdQueryParameters params = new IdQueryParameters(dataCenter.getId());
            Frontend.getInstance().runQuery(VdcQueryType.GetStorageTypesInPoolByPoolId, params, new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object ReturnValue) {
                    List<StorageType> storageTypes = ((VdcQueryReturnValue) ReturnValue).getReturnValue();
                    for (StorageType storageType : storageTypes) {
                        if (storageType.isBlockDomain() != item.getType().isBlockDomain()) {
                            updateItemSelectability(item, false);
                            return;
                        }
                    }
                    updateItemSelectability(item, true);
                    return;
                }
            }));
            return;
        }
    }
    updateItemSelectability(item, false);
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean canAddVm = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority());
    if (canAddVm) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            return false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getStorageDomainDAO().getAllForStoragePool(vmDisksSource.getStoragePoolId()), diskInfoDestinationMap, destStorages, false);
}
#method_after
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getPoolDomains(), diskInfoDestinationMap, destStorages, false);
}
#end_block

#method_before
@Test
public void validateSpaceAndThreshold() {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForClonedDisks(any(List.class));
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForClonedDisks(any(List.class));
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(any(List.class));
}
#method_after
@Test
public void validateSpaceAndThreshold() {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForClonedDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForClonedDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotEnough() throws Exception {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForClonedDisks(any(List.class));
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertFalse(command.validateSpaceRequirements());
    // The following is mocked to fail, should happen only once.
    verify(storageDomainValidator).hasSpaceForClonedDisks(any(List.class));
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(any(List.class));
}
#method_after
@Test
public void validateSpaceNotEnough() throws Exception {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForClonedDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertFalse(command.validateSpaceRequirements());
    // The following is mocked to fail, should happen only once.
    verify(storageDomainValidator).hasSpaceForClonedDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(anyList());
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean canAddVm = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority());
    if (canAddVm) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            return false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return isDedicatedVdsOnSameCluster(vmStaticFromParams);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getVdsGroup().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getVmStaticData().getOsId(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getStorageDomainDAO().getAllForStoragePool(vmDisksSource.getStoragePoolId()), diskInfoDestinationMap, destStorages, false);
}
#method_after
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getPoolDomains(), diskInfoDestinationMap, destStorages, false);
}
#end_block

#method_before
private CreateCloneOfTemplateParameters buildCreateCloneOfTemplateParameters(DiskImage disk) {
    DiskImageBase diskInfo = getParameters().getDiskInfoDestinationMap().get(disk.getId());
    CreateCloneOfTemplateParameters params = new CreateCloneOfTemplateParameters(disk.getImageId(), getParameters().getVmStaticData().getId(), diskInfo);
    params.setStorageDomainId(disk.getStorageIds().get(0));
    params.setDestStorageDomainId(diskInfoDestinationMap.get(disk.getId()).getStorageIds().get(0));
    params.setDiskAlias(diskInfoDestinationMap.get(disk.getId()).getDiskAlias());
    params.setVmSnapshotId(getVmSnapshotId());
    params.setParentCommand(VdcActionType.AddVmFromTemplate);
    params.setParentParameters(getParameters());
    params.setEntityInfo(getParameters().getEntityInfo());
    params.setQuotaId(diskInfoDestinationMap.get(disk.getId()).getQuotaId() != null ? diskInfoDestinationMap.get(disk.getId()).getQuotaId() : null);
    return params;
}
#method_after
private CreateCloneOfTemplateParameters buildCreateCloneOfTemplateParameters(DiskImage disk) {
    DiskImageBase diskInfo = getParameters().getDiskInfoDestinationMap().get(disk.getId());
    CreateCloneOfTemplateParameters params = new CreateCloneOfTemplateParameters(disk.getImageId(), getParameters().getVmStaticData().getId(), diskInfo);
    params.setStorageDomainId(diskInfoSourceMap.get(disk.getId()));
    params.setDestStorageDomainId(retrieveDestinationDomainForDisk(disk.getId()));
    params.setDiskAlias(diskInfoDestinationMap.get(disk.getId()).getDiskAlias());
    params.setVmSnapshotId(getVmSnapshotId());
    params.setParentCommand(VdcActionType.AddVmFromTemplate);
    params.setParentParameters(getParameters());
    params.setEntityInfo(getParameters().getEntityInfo());
    params.setQuotaId(diskInfoDestinationMap.get(disk.getId()).getQuotaId() != null ? diskInfoDestinationMap.get(disk.getId()).getQuotaId() : null);
    return params;
}
#end_block

#method_before
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(any(List.class));
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(any(List.class));
}
#method_after
@Test
public void validateSpaceAndThreshold() {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(any(List.class));
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(any(List.class));
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(any(List.class));
}
#method_after
@Test
public void validateSpaceNotEnough() throws Exception {
    AddVmCommand<VmManagementParametersBase> command = setupCanAddVmTests(0, 0);
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForNewDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    assertFalse(command.validateSpaceRequirements());
    verify(storageDomainValidator).hasSpaceForNewDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForClonedDisks(anyList());
}
#end_block

#method_before
static private List<DiskImage> generateDisksList(int size) {
    List<DiskImage> disksList = new ArrayList<>();
    for (int i = 0; i < size; ++i) {
        DiskImage diskImage = new DiskImage();
        diskImage.setImageId(Guid.newGuid());
        disksList.add(diskImage);
    }
    return disksList;
}
#method_after
private static List<DiskImage> generateDisksList(int size) {
    List<DiskImage> disksList = new ArrayList<>();
    for (int i = 0; i < size; ++i) {
        DiskImage diskImage = new DiskImage();
        diskImage.setImageId(Guid.newGuid());
        disksList.add(diskImage);
    }
    return disksList;
}
#end_block

#method_before
protected void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmFromTemplateParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#method_after
private void mockGetAllSnapshots(AddVmFromTemplateCommand<AddVmFromTemplateParameters> command) {
    doAnswer(new Answer<List<DiskImage>>() {

        @Override
        public List<DiskImage> answer(InvocationOnMock invocation) throws Throwable {
            Object[] args = invocation.getArguments();
            DiskImage arg = (DiskImage) args[0];
            List<DiskImage> list = createDiskSnapshot(arg.getId(), 3);
            return list;
        }
    }).when(command).getAllImageSnapshots(any(DiskImage.class));
}
#end_block

#method_before
@Test
public void validateSpaceAndThreshold() {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForClonedDisks(any(List.class));
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForClonedDisks(any(List.class));
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(any(List.class));
}
#method_after
@Test
public void validateSpaceAndThreshold() {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).hasSpaceForClonedDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertTrue(command.validateSpaceRequirements());
    verify(storageDomainValidator, times(TOTAL_NUM_DOMAINS)).hasSpaceForClonedDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(anyList());
}
#end_block

#method_before
@Test
public void validateSpaceNotEnough() throws Exception {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForClonedDisks(any(List.class));
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertFalse(command.validateSpaceRequirements());
    // The following is mocked to fail, should happen only once.
    verify(storageDomainValidator).hasSpaceForClonedDisks(any(List.class));
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(any(List.class));
}
#method_after
@Test
public void validateSpaceNotEnough() throws Exception {
    initCommand();
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainWithinThresholds();
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN)).when(storageDomainValidator).hasSpaceForClonedDisks(anyList());
    doReturn(storageDomainValidator).when(command).createStorageDomainValidator(any(StorageDomain.class));
    mockGetAllSnapshots();
    assertFalse(command.validateSpaceRequirements());
    // The following is mocked to fail, should happen only once.
    verify(storageDomainValidator).hasSpaceForClonedDisks(anyList());
    verify(storageDomainValidator, never()).hasSpaceForNewDisks(anyList());
}
#end_block

#method_before
public Pair<ValidationResult, Map<Guid, Set<Guid>>> diskImagesOnAnyApplicableDomains(Map<Guid, StorageDomain> storageDomains, Set<StorageDomainStatus> applicableStatuses, VdcBllMessages message) {
    List<String> disksInfo = new LinkedList<>();
    Map<Guid, Set<Guid>> legitDomainsForDisks = new HashMap<>();
    for (DiskImage diskImage : diskImages) {
        List<String> nonApplicableStorageInfo = new LinkedList<>();
        for (Guid storageDomainID : diskImage.getStorageIds()) {
            StorageDomain domain = storageDomains.get(storageDomainID);
            if (domain == null || domain.getStatus() == null) {
                throw new RuntimeException("Wrong data provided to validator");
            }
            if (applicableStatuses.contains(domain.getStatus())) {
                MultiValueMapUtils.addToMap(diskImage.getId(), domain.getId(), legitDomainsForDisks, new MultiValueMapUtils.SetCreator<Guid>());
            } else {
                nonApplicableStorageInfo.add(String.format("%s - %s", domain.getName(), domain.getStatus().toString()));
            }
        }
        if (diskImage.getStorageIds().size() == nonApplicableStorageInfo.size()) {
            disksInfo.add(String.format("%s (%s) %n", diskImage.getDiskAlias(), StringUtils.join(nonApplicableStorageInfo, " / ")));
        }
    }
    ValidationResult result = ValidationResult.VALID;
    if (!disksInfo.isEmpty()) {
        result = new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(disksInfo, "%n"))), String.format("$applicableStatus %s", StringUtils.join(applicableStatuses, ",")));
    }
    return new Pair<>(result, legitDomainsForDisks);
}
#method_after
public ValidationResult diskImagesOnAnyApplicableDomains(Map<Guid, Set<Guid>> validDomainsForDisk, Map<Guid, StorageDomain> storageDomains, VdcBllMessages message, Set<StorageDomainStatus> applicableStatuses) {
    List<String> disksInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        Set<Guid> applicableDomains = validDomainsForDisk.get(diskImage.getId());
        if (!applicableDomains.isEmpty()) {
            continue;
        }
        List<String> nonApplicableStorageInfo = new LinkedList<>();
        for (Guid id : diskImage.getStorageIds()) {
            StorageDomain domain = storageDomains.get(id);
            nonApplicableStorageInfo.add(String.format("%s - %s", domain.getName(), domain.getStatus().toString()));
        }
        disksInfo.add(String.format("%s (%s) %n", diskImage.getDiskAlias(), StringUtils.join(nonApplicableStorageInfo, " / ")));
    }
    ValidationResult result = ValidationResult.VALID;
    if (!disksInfo.isEmpty()) {
        result = new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(disksInfo, "%n"))), String.format("$applicableStatus %s", StringUtils.join(applicableStatuses, ",")));
    }
    return result;
}
#end_block

#method_before
public Guid getVmIdRef() {
    if (mVmId == null && getVm() != null) {
        mVmId = getVm().getId();
    }
    return mVmId;
}
#method_after
public Guid getVmIdRef() {
    if (Guid.isNullOrEmpty(mVmId) && getVm() != null) {
        mVmId = getVm().getId();
    }
    return mVmId;
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName(model.getName().getEntity());
    host.setComment(model.getComment().getEntity());
    host.setHostName(model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = model.getCluster().getSelectedItem().getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp(model.getManagementIp().getEntity());
    host.setPmUser(model.getPmUserName().getEntity());
    host.setPmPassword(model.getPmPassword().getEntity());
    host.setPmType(model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp(model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser(model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword(model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType(model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled(model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent(model.getPmSecondaryConcurrent().getEntity());
    host.setDisablePowerManagementPolicy(model.getDisableAutomaticPowerManagement().getEntity());
    host.setPmKdumpDetection(model.getPmKdumpDetection().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = model.getCluster().getSelectedItem().supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword(model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall(model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings(model.getInterfaceMappings().getEntity());
        }
        Frontend.getInstance().runAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.getInstance().runAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
private void updateConfigureLocalStorageCommandAvailability1() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    getConfigureLocalStorageCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStatus() == VDSStatus.Maintenance);
    if (!hasAdminSystemPermission && getConfigureLocalStorageCommand().getIsExecutionAllowed()) {
        getConfigureLocalStorageCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().configuringLocalStoragePermittedOnlyAdministratorsWithSystemLevelPermissionsReason());
        getConfigureLocalStorageCommand().setIsExecutionAllowed(false);
    }
}
#method_after
private void updateConfigureLocalStorageCommandAvailability1() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    getConfigureLocalStorageCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStatus() == VDSStatus.Maintenance);
    if (!Boolean.TRUE.equals(hasAdminSystemPermission) && getConfigureLocalStorageCommand().getIsExecutionAllowed()) {
        getConfigureLocalStorageCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().configuringLocalStoragePermittedOnlyAdministratorsWithSystemLevelPermissionsReason());
        getConfigureLocalStorageCommand().setIsExecutionAllowed(false);
    }
}
#end_block

#method_before
private TransactionMethod<Boolean> updateVdsNetworksInTx() {
    return new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            // save the new network topology to DB
            List<VdsNetworkInterface> ifaces = new ArrayList<VdsNetworkInterface>(getInterfaces());
            ifaces.addAll(getRemovedBonds().values());
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds(), ifaces));
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return Boolean.TRUE;
        }
    };
}
#method_after
private TransactionMethod<Boolean> updateVdsNetworksInTx() {
    return new TransactionMethod<Boolean>() {

        @Override
        public Boolean runInTransaction() {
            // save the new network topology to DB
            List<VdsNetworkInterface> ifaces = new ArrayList<>(getInterfaces());
            ifaces.addAll(getRemovedBonds().values());
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.CollectVdsNetworkData, new CollectHostNetworkDataVdsCommandParameters(getVds(), ifaces));
            // Update cluster networks (i.e. check if need to activate each new network)
            for (Network net : getNetworks()) {
                NetworkClusterHelper.setStatus(getVdsGroupId(), net);
            }
            return Boolean.TRUE;
        }
    };
}
#end_block

#method_before
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#method_after
private void validateNotRemovingLabeledNetworks() {
    Map<String, VdsNetworkInterface> nicsByName = Entities.entitiesByName(params.getInterfaces());
    Map<String, VdsNetworkInterface> hostInterfacesByNetworkName = Entities.hostInterfacesByNetworkName(getExistingIfaces().values());
    for (String network : removedNetworks) {
        VdsNetworkInterface nic = hostInterfacesByNetworkName.get(network);
        if (nic != null && !removedBonds.contains(nic.getName())) {
            if (NetworkUtils.isVlan(nic)) {
                nic = nicsByName.get(NetworkUtils.stripVlan(nic.getName()));
                if (nic == null) {
                    continue;
                }
            }
            Network removedNetwork = getExistingClusterNetworks().get(network);
            if (NetworkUtils.isLabeled(nic) && removedNetwork != null && nic.getLabels().contains(removedNetwork.getLabel())) {
                addViolation(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_REMOVE_LABELED_NETWORK_FROM_NIC, network);
            }
        }
    }
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
    initCustomPropertiesList();
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = (HashMap<ArchitectureType, Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static boolean canVmsBePaused(List<VM> items) {
    boolean result = true;
    for (VM vm : items) {
        result &= AsyncDataProvider.isSuspendSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    }
    return result;
}
#method_after
public static boolean canVmsBePaused(List<VM> items) {
    for (VM vm : items) {
        if (!AsyncDataProvider.isSuspendSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<String>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<VmDevice>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && ((List) source).size() > 0) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static Map<Version, List<String>> getCustomPropertiesList() {
    return customPropertiesList;
}
#end_block

#method_before
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StoragePool> pools = (ArrayList<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && pools.size() > 0) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#method_after
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StoragePool> pools = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && !pools.isEmpty()) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            if (siblingVlanInterfaces.size() > 0) {
                return true;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType() {
    return VmInterfaceType.pv;
}
#method_after
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            HashMap<Integer, String> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            String defaultValue = result.get(DEFAULT_OS_ID);
            osNames = new MapWithDefaults<Integer, String>(result, defaultValue);
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = (HashMap<Integer, ArchitectureType>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<Integer, Map<Version, List<DisplayType>>> result = ((VdcQueryReturnValue) returnValue).getReturnValue();
            displayTypes = new MapWithDefaults<Integer, Map<Version, List<DisplayType>>>(result, result.get(DEFAULT_OS_ID));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#method_after
private static void initDisplayTypes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            displayTypes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDisplayTypes), callback);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(AsyncDataProvider.getCustomPropertiesList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, getCustomPropertiesKeysList().get(((VM) result).getVdsGroupCompatibilityVersion()), VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#method_after
private void runOnce() {
    VM vm = (VM) getSelectedItem();
    // populating VMInit
    AsyncQuery getVmInitQuery = new AsyncQuery();
    getVmInitQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            RunOnceModel runOnceModel = new WebadminRunOnceModel((VM) result, VmListModel.this);
            setWindow(runOnceModel);
            runOnceModel.init();
        }
    };
    AsyncDataProvider.getVmById(getVmInitQuery, vm.getId());
}
#end_block

#method_before
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#method_after
private void onNewTemplate() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    if (model.getProgress() != null) {
        return;
    }
    if (!model.validate()) {
        model.setIsValid(false);
    } else if (model.getIsSubTemplate().getEntity()) {
        postNameUniqueCheck();
    } else {
        String name = model.getName().getEntity();
        // Check name unicitate.
        AsyncDataProvider.isTemplateNameUnique(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmListModel vmListModel = (VmListModel) target;
                boolean isNameUnique = (Boolean) returnValue;
                if (!isNameUnique) {
                    UnitVmModel VmModel = (UnitVmModel) vmListModel.getWindow();
                    VmModel.getInvalidityReasons().clear();
                    VmModel.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
                    VmModel.getName().setIsValid(false);
                    VmModel.setIsValid(false);
                } else {
                    vmListModel.postNameUniqueCheck();
                }
            }
        }), name);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onShutdown() {
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true);
        }
    });
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void onStop() {
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL);
        }
    });
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg(), false);
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                // do nothing
                }

                @Override
                public void queryFailed() {
                // do nothing
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    getWindow().stopProgress();
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        setWindow(null);
                        setGuideContext(returnValue.getActionReturnValue());
                        updateActionAvailability();
                        getGuideCommand().execute();
                    } else {
                        cancel();
                    }
                    super.executed(result);
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(items));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    VM entity = (VM) getItem().getEntity();
    getItem().getTakeVmCommand().setIsAvailable(false);
    ArrayList<VM> entities = new ArrayList<VM>();
    entities.add(entity);
    getItem().getRunCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.RunVm));
    getItem().getPauseCommand().setIsExecutionAllowed(entities.size() > 0 && VdcActionUtils.canExecute(entities, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(entities));
    getItem().getShutdownCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.ShutdownVm));
    getItem().getStopCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.StopVm));
    getItem().getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(entities));
    // Check whether a VM is from the manual pool.
    if (entity.getVmPoolId() != null) {
        AsyncDataProvider.getPoolById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmItemBehavior behavior = (VmItemBehavior) target;
                VmPool pool = (VmPool) returnValue;
                boolean isManualPool = pool.getVmPoolType() == VmPoolType.Manual;
                behavior.updateCommandsAccordingToPoolType(isManualPool);
            }
        }), entity.getVmPoolId());
    } else {
        updateCommandsAccordingToPoolType(true);
    }
}
#method_after
private void updateActionAvailability() {
    VM entity = (VM) getItem().getEntity();
    getItem().getTakeVmCommand().setIsAvailable(false);
    ArrayList<VM> entities = new ArrayList<VM>();
    entities.add(entity);
    getItem().getRunCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.RunVm));
    getItem().getPauseCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.HibernateVm) && AsyncDataProvider.canVmsBePaused(entities));
    getItem().getShutdownCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.ShutdownVm));
    getItem().getStopCommand().setIsExecutionAllowed(VdcActionUtils.canExecute(entities, VM.class, VdcActionType.StopVm));
    getItem().getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(entities));
    // Check whether a VM is from the manual pool.
    if (entity.getVmPoolId() != null) {
        AsyncDataProvider.getPoolById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VmItemBehavior behavior = (VmItemBehavior) target;
                VmPool pool = (VmPool) returnValue;
                boolean isManualPool = pool.getVmPoolType() == VmPoolType.Manual;
                behavior.updateCommandsAccordingToPoolType(isManualPool);
            }
        }), entity.getVmPoolId());
    } else {
        updateCommandsAccordingToPoolType(true);
    }
}
#end_block

#method_before
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    entity.setPmKdumpDetection(model.isKdumpDetection());
    return entity;
}
#method_after
@Mapping(from = PowerManagement.class, to = VdsStatic.class)
public static VdsStatic map(PowerManagement model, VdsStatic template) {
    VdsStatic entity = template != null ? template : new VdsStatic();
    entity.setManagementIp(getManagementIp(model, entity));
    entity.setPmType(getManagementType(model, entity));
    entity.setPmUser(getManagementUser(model, entity));
    entity.setPmPassword(getManagementPassword(model, entity));
    entity.setPmOptions(getManagementOptions(model, entity));
    if (model.isSetEnabled()) {
        entity.setPmEnabled(model.isEnabled());
    }
    if (model.isSetAutomaticPmEnabled()) {
        entity.setDisablePowerManagementPolicy(!model.isAutomaticPmEnabled());
    }
    if (model.isSetPmProxies()) {
        String delim = "";
        StringBuilder builder = new StringBuilder();
        for (PmProxy pmProxy : model.getPmProxies().getPmProxy()) {
            builder.append(delim);
            builder.append(pmProxy.getType());
            delim = ",";
        }
        entity.setPmProxyPreferences(builder.toString());
    }
    if (model.isSetAgents()) {
        // Currently only Primary/Secondary agents are supported
        int order = 1;
        for (Agent agent : model.getAgents().getAgents()) {
            if (agent.isSetOrder()) {
                order = agent.getOrder();
            }
            if (order == 1) {
                // Primary
                // in case that order is not defined, secondary will still be defined correctly.
                order++;
            } else if (order == 2) {
                // Secondary
                if (agent.isSetType()) {
                    entity.setPmSecondaryType(agent.getType());
                }
                if (agent.isSetAddress()) {
                    entity.setPmSecondaryIp(agent.getAddress());
                }
                if (agent.isSetUsername()) {
                    entity.setPmSecondaryUser(agent.getUsername());
                }
                if (agent.isSetPassword()) {
                    entity.setPmSecondaryPassword(agent.getPassword());
                }
                if (agent.isSetOptions()) {
                    entity.setPmSecondaryOptions(map(agent.getOptions(), null));
                }
                if (agent.isSetConcurrent()) {
                    entity.setPmSecondaryConcurrent(agent.isConcurrent());
                }
            }
        }
    }
    if (model.isSetKdumpDetection()) {
        entity.setPmKdumpDetection(model.isKdumpDetection());
    }
    return entity;
}
#end_block

#method_before
void onWindowFocusChange(boolean inFocus) {
    GridTimer modelTimer = getModelTimer();
    // Change refresh rate only when the model timer is currently active and not paused
    if (modelTimer.isActive() && !modelTimer.isPaused()) {
        if (inFocus) {
            modelTimer.stop();
            modelTimer.setRefreshRate(readRefreshRate());
        } else {
            modelTimer.stop();
            modelTimer.setRefreshRate(OUT_OF_FOCUS_REFRESH_RATE);
        }
        modelTimer.start();
    }
}
#method_after
void onWindowFocusChange(boolean inFocus) {
    GridTimer modelTimer = getModelTimer();
    // Change refresh rate only when the model timer is currently active and not paused
    if (modelTimer.isActive() && !modelTimer.isPaused()) {
        modelTimer.stop();
        if (inFocus) {
            modelTimer.setRefreshRate(readRefreshRate());
        } else {
            modelTimer.setRefreshRate(OUT_OF_FOCUS_REFRESH_RATE);
        }
        modelTimer.start();
    }
}
#end_block

#method_before
@Override
public void setItems(Collection<T> value) {
    if (items != value) {
        T lastSelectedItem = getSelectedItem();
        List<T> lastSelectedItems = new ArrayList<T>();
        if (getSelectedItems() != null) {
            for (T item : getSelectedItems()) {
                lastSelectedItems.add(item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && (((SortedSet) value).comparator() == comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            TreeSet<T> sortedValue = null;
            if (value != null) {
                sortedValue = new TreeSet<T>(comparator);
                for (T item : value) {
                    sortedValue.add(item);
                }
            }
            itemsChanging(sortedValue, items);
            items = sortedValue;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            T newSelectedItem = null;
            List<T> newItems = new ArrayList<T>();
            for (T item : items) {
                newItems.add(item);
            }
            if (newItems != null) {
                for (T newItem : newItems) {
                    // Search for selected item
                    if (((IVdcQueryable) newItem).getQueryableId().equals(((IVdcQueryable) lastSelectedItem).getQueryableId())) {
                        newSelectedItem = newItem;
                    } else {
                        // Search for selected items
                        for (T item : lastSelectedItems) {
                            if (((IVdcQueryable) newItem).getQueryableId().equals(((IVdcQueryable) item).getQueryableId())) {
                                selectedItems.add(newItem);
                            }
                        }
                    }
                }
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#method_after
@Override
public void setItems(Collection<T> value) {
    if (items != value) {
        T lastSelectedItem = getSelectedItem();
        List<T> lastSelectedItems = new ArrayList<T>();
        if (getSelectedItems() != null) {
            for (T item : getSelectedItems()) {
                lastSelectedItems.add(item);
            }
        }
        if (comparator == null || ((value instanceof SortedSet) && (((SortedSet) value).comparator() == comparator))) {
            itemsChanging(value, items);
            items = value;
        } else {
            TreeSet<T> sortedValue = null;
            if (value != null) {
                sortedValue = new TreeSet<T>(comparator);
                for (T item : value) {
                    sortedValue.add(item);
                }
            }
            itemsChanging(sortedValue, items);
            items = sortedValue;
        }
        updatePagingAvailability();
        getItemsChangedEvent().raise(this, EventArgs.EMPTY);
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("Items"));
        selectedItem = null;
        if (getSelectedItems() != null) {
            getSelectedItems().clear();
        }
        if (lastSelectedItem != null && items != null) {
            T newSelectedItem = null;
            List<T> newItems = new ArrayList<T>();
            for (T item : items) {
                newItems.add(item);
            }
            if (newItems != null) {
                newSelectedItem = determineSelectedItems(newItems, lastSelectedItem, lastSelectedItems);
            }
            if (newSelectedItem != null) {
                selectedItem = newSelectedItem;
                if (selectedItems != null) {
                    selectedItems.add(newSelectedItem);
                }
            }
        }
        onSelectedItemChanged();
    }
}
#end_block

#method_before
@Override
protected void registerHandlers() {
    // Register to listen for operation complete events.
    registerHandler(getEventBus().addHandler(RefreshActiveModelEvent.getType(), new RefreshActiveModelHandler() {

        @Override
        public void onRefreshActiveModel(RefreshActiveModelEvent event) {
            if (getTimer().isActive()) {
                // Only if we are active should we refresh.
                if (handleRefreshActiveModel(event)) {
                    syncSearch();
                }
                if (event.isDoFastForward()) {
                    // Start the fast refresh.
                    getTimer().fastForward();
                }
            }
        }
    }));
}
#method_after
@Override
protected void registerHandlers() {
    // Register to listen for operation complete events.
    registerHandler(getEventBus().addHandler(RefreshActiveModelEvent.getType(), new RefreshActiveModelHandler() {

        @Override
        public void onRefreshActiveModel(RefreshActiveModelEvent event) {
            if (getTimer().isActive() || refreshOnInactiveTimer()) {
                // Only if we are active should we refresh.
                if (handleRefreshActiveModel(event)) {
                    syncSearch();
                }
                if (event.isDoFastForward()) {
                    // Start the fast refresh.
                    getTimer().fastForward();
                }
            }
        }
    }));
}
#end_block

#method_before
public SystemTreeItemModel findNode(SystemTreeItemModel root, SystemTreeItemModel match) {
    SystemTreeItemModel result = null;
    if (root != null && match != null) {
        if (root.getEntity() != null && root.getEntity().equals(match.getEntity()) && root.getTitle().equals(match.getTitle())) {
            // match found.
            result = root;
        } else {
            if (root.getChildren().size() > 0) {
                for (int i = 0; i < root.getChildren().size(); i++) {
                    result = findNode(root.getChildren().get(i), match);
                    if (result != null) {
                        break;
                    }
                }
            }
        }
    }
    return result;
}
#method_after
public SystemTreeItemModel findNode(SystemTreeItemModel root, SystemTreeItemModel match) {
    SystemTreeItemModel result = null;
    if (root != null && match != null) {
        if (root.equals(match)) {
            // match found.
            result = root;
        } else {
            if (root.getChildren().size() > 0) {
                for (int i = 0; i < root.getChildren().size(); i++) {
                    result = findNode(root.getChildren().get(i), match);
                    if (result != null) {
                        break;
                    }
                }
            }
        }
    }
    return result;
}
#end_block

#method_before
public boolean equals(Object other, boolean deepCompare) {
    if (other == this) {
        return true;
    }
    if (other == null || other.getClass() != getClass()) {
        return false;
    }
    SystemTreeItemModel otherModel = (SystemTreeItemModel) other;
    if (getChildren().size() > 0 && deepCompare) {
        if (otherModel.getChildren().size() == getChildren().size()) {
            boolean result = true;
            for (int i = 0; i < getChildren().size(); i++) {
                result = getChildren().get(i).equals(otherModel.getChildren().get(i), deepCompare);
                if (!result) {
                    break;
                }
            }
            return result;
        } else {
            return false;
        }
    } else {
        if (otherModel.getEntity() != null && otherModel.getEntity().equals(getEntity()) && otherModel.getTitle().equals(getTitle())) {
            return true;
        }
        return false;
    }
}
#method_after
public boolean equals(Object other, boolean deepCompare) {
    if (other == this) {
        return true;
    }
    if (other == null || other.getClass() != getClass()) {
        return false;
    }
    boolean result = true;
    SystemTreeItemModel otherModel = (SystemTreeItemModel) other;
    if (getChildren().size() > 0 && deepCompare) {
        if (otherModel.getChildren().size() == getChildren().size()) {
            for (int i = 0; i < getChildren().size(); i++) {
                result = getChildren().get(i).equals(otherModel.getChildren().get(i), deepCompare);
                if (!result) {
                    break;
                }
            }
        } else {
            result = false;
        }
    }
    if (result) {
        if (!((otherModel.getEntity() == null && getEntity() == null) || (otherModel.getEntity() != null && otherModel.getEntity().equals(getEntity()) && ((otherModel.getTitle() == null && getTitle() == null) || (otherModel.getTitle() != null && otherModel.getTitle().equals(getTitle())))))) {
            result = false;
        }
    }
    return result;
}
#end_block

#method_before
@Override
public int hashCode() {
    return super.hashCode();
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((getEntity() == null) ? 0 : getEntity().hashCode());
    result = prime * result + ((getTitle() == null) ? 0 : getTitle().hashCode());
    return result;
}
#end_block

#method_before
public void calculateFreeVirtualMemory() {
    if (getMemCommited() != null && getPhysicalMemMb() != null && getReservedMem() != null) {
        maxSchedulingMemory = (getMaxVdsMemoryOverCommit() * getPhysicalMemMb() / 100.0f) - (getMemCommited() + getReservedMem() - getPendingVmemSize());
        // avoid negative values
        maxSchedulingMemory = maxSchedulingMemory > 0 ? maxSchedulingMemory : 0;
    }
}
#method_after
public void calculateFreeVirtualMemory() {
    if (getMemCommited() != null && getPhysicalMemMb() != null && getReservedMem() != null) {
        maxSchedulingMemory = (getMaxVdsMemoryOverCommit() * getPhysicalMemMb() / 100.0f) - getMemCommited() - getReservedMem() - getPendingVmemSize();
        // avoid negative values
        maxSchedulingMemory = maxSchedulingMemory > 0 ? maxSchedulingMemory : 0;
    }
}
#end_block

#method_before
@Test
public void versionDecreaseLowerVersionThanDC() {
    createCommandWithOlderVersion();
    StoragePoolDAO storagePoolDAO2 = Mockito.mock(StoragePoolDAO.class);
    when(storagePoolDAO2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFSOldVersion());
    doReturn(storagePoolDAO2).when(cmd).getStoragePoolDAO();
    cpuExists();
    cpuManufacturersMatch();
    canDoActionFailedWithReason(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
}
#method_after
@Test
public void versionDecreaseLowerVersionThanDC() {
    createCommandWithOlderVersion();
    StoragePoolDAO storagePoolDAO2 = Mockito.mock(StoragePoolDAO.class);
    when(storagePoolDAO2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFSOldVersion());
    doReturn(storagePoolDAO2).when(cmd).getStoragePoolDAO();
    cpuExists();
    cpuManufacturersMatch();
    canDoActionFailedWithReason(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if ((allForVdsGroup != null && allForVdsGroup.size() > 0) || (oldGroup.getStoragePoolId() != null && getVdsGroup().getcompatibility_version().compareTo(getStoragePoolDAO().get(oldGroup.getStoragePoolId()).getcompatibility_version()) < 0)) {
            result = false;
            getReturnValue().getCanDoActionMessages().add(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION.toString());
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = true;
    boolean hasVms = false;
    boolean hasVmOrHost = false;
    boolean sameCpuNames = false;
    boolean allVdssInMaintenance = false;
    List<VM> vmList = null;
    oldGroup = getVdsGroupDAO().get(getVdsGroup().getId());
    if (oldGroup == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        result = false;
    }
    // if the name was changed then make sure the new name is unique
    if (result && !StringUtils.equals(oldGroup.getName(), getVdsGroup().getName())) {
        if (!isVdsGroupUnique(getVdsGroup().getName())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DO_ACTION_NAME_IN_USE);
            result = false;
        }
    }
    if (result && !VersionSupport.checkVersionSupported(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VersionSupport.getUnsupportedVersionMessage());
        result = false;
    }
    if (result) {
        allForVdsGroup = getVdsDAO().getAllForVdsGroup(oldGroup.getId());
    }
    // decreasing of compatibility version is only allowed when no hosts exists, and not beneath the DC version
    if (result && getVdsGroup().getcompatibility_version().compareTo(oldGroup.getcompatibility_version()) < 0) {
        if (!allForVdsGroup.isEmpty()) {
            result = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION);
        }
        if (oldGroup.getStoragePoolId() != null) {
            StoragePool storagePool = getStoragePoolDAO().get(oldGroup.getStoragePoolId());
            if (storagePool != null && getVdsGroup().getcompatibility_version().compareTo(storagePool.getcompatibility_version()) < 0) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
            }
        }
    }
    if (result && oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_CHANGE_STORAGE_POOL);
        result = false;
    }
    // If both original Cpu and new Cpu are null, don't check Cpu validity
    if (result) {
        allVdssInMaintenance = areAllVdssInMaintenance(allForVdsGroup);
    }
    // Validate the cpu only if the cluster supports Virt
    if (result && getVdsGroup().supportsVirtService() && (oldGroup.getcpu_name() != null || getVdsGroup().getcpu_name() != null)) {
        // Check that cpu exist
        if (!checkIfCpusExist()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CPU_NOT_FOUND);
            addCanDoActionMessage(VdcBllMessages.VAR__TYPE__CLUSTER);
            result = false;
        } else {
            // vds in this cluster, cannot update
            if (!StringUtils.isEmpty(oldGroup.getcpu_name()) && !checkIfCpusSameManufacture(oldGroup) && !allVdssInMaintenance) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ILLEGAL);
                result = false;
            }
        }
    }
    if (result) {
        vmList = getVmDAO().getAllForVdsGroup(oldGroup.getId());
        hasVmOrHost = !vmList.isEmpty() || !allForVdsGroup.isEmpty();
    }
    // cannot change the the processor architecture while there are attached hosts or VMs to the cluster
    if (result && getVdsGroup().supportsVirtService() && !isArchitectureUpdatable() && hasVmOrHost) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_ARCHITECTURE_ILLEGAL);
        result = false;
    }
    if (result) {
        sameCpuNames = StringUtils.equals(oldGroup.getcpu_name(), getVdsGroup().getcpu_name());
    }
    if (result) {
        boolean isOldCPUEmpty = StringUtils.isEmpty(oldGroup.getcpu_name());
        if (!isOldCPUEmpty && !sameCpuNames && !isCpuUpdatable(oldGroup) && hasVmOrHost) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CPU_IS_NOT_UPDATABLE);
            result = false;
        }
    }
    if (result) {
        List<VDS> vdss = new ArrayList<VDS>();
        boolean isAddedToStoragePool = oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null;
        for (VDS vds : allForVdsGroup) {
            if (vds.getStatus() == VDSStatus.Up) {
                if (isAddedToStoragePool) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_VDS_UP);
                    return false;
                } else {
                    vdss.add(vds);
                }
            }
        }
        for (VDS vds : vdss) {
            if (!VersionSupport.checkClusterVersionSupported(getVdsGroup().getcompatibility_version(), vds)) {
                result = false;
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_COMPATIBILITY_VERSION_WITH_LOWER_HOSTS);
                break;
            } else if (getVdsGroup().supportsVirtService() && missingServerCpuFlags(vds) != null) {
                addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_LOWER_HOSTS);
                result = false;
                break;
            }
        }
        if (result) {
            boolean notDownVms = false;
            boolean suspendedVms = false;
            hasVms = vmList.size() > 0;
            if (!sameCpuNames) {
                for (VM vm : vmList) {
                    if (vm.getStatus() == VMStatus.Suspended) {
                        suspendedVms = true;
                        break;
                    } else if (vm.getStatus() != VMStatus.Down) {
                        notDownVms = true;
                        break;
                    }
                }
                if (suspendedVms) {
                    addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_UPDATE_CPU_WITH_SUSPENDED_VMS);
                    result = false;
                } else if (notDownVms) {
                    int compareResult = compareCpuLevels(oldGroup);
                    if (compareResult > 0) {
                        // Upgrade of CPU in same compability level is allowed if
                        // there
                        // are running VMs - but we should warn they
                        // cannot not be hibernated
                        AuditLogableBase logable = new AuditLogableBase();
                        logable.addCustomValue("VdsGroup", getParameters().getVdsGroup().getName());
                        AuditLogDirector.log(logable, AuditLogType.CANNOT_HIBERNATE_RUNNING_VMS_AFTER_CLUSTER_CPU_UPGRADE);
                    }
                }
            }
        }
    }
    if (result && getVdsGroup().getStoragePoolId() != null) {
        StoragePool storagePool = getStoragePoolDAO().get(getVdsGroup().getStoragePoolId());
        if (oldGroup.getStoragePoolId() == null && storagePool.isLocal()) {
            // we allow only one cluster in localfs data center
            if (!getVdsGroupDAO().getAllForStoragePool(getVdsGroup().getStoragePoolId()).isEmpty()) {
                getReturnValue().getCanDoActionMessages().add(VdcBllMessages.VDS_GROUP_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE.toString());
                result = false;
            } else if (Config.getValue(ConfigValues.AutoRegistrationDefaultVdsGroupID).equals(getVdsGroup().getId())) {
                addCanDoActionMessage(VdcBllMessages.DEFAULT_CLUSTER_CANNOT_BE_ON_LOCALFS);
                result = false;
            }
        }
    }
    if (getVdsGroup().getcompatibility_version() != null && Version.v3_3.compareTo(getVdsGroup().getcompatibility_version()) > 0 && getVdsGroup().isEnableBallooning()) {
        // Members of pre-3.3 clusters don't support ballooning; here we act like a 3.2 engine
        addCanDoActionMessage(VdcBllMessages.QOS_BALLOON_NOT_SUPPORTED);
        result = false;
    }
    if (getVdsGroup().supportsGlusterService() && !GlusterFeatureSupported.gluster(getVdsGroup().getcompatibility_version())) {
        addCanDoActionMessage(VdcBllMessages.GLUSTER_NOT_SUPPORTED);
        addCanDoActionMessage(String.format("$compatibilityVersion %1$s", getVdsGroup().getcompatibility_version().getValue()));
        result = false;
    }
    if (result) {
        if (!(getVdsGroup().supportsGlusterService() || getVdsGroup().supportsVirtService())) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_AT_LEAST_ONE_SERVICE_MUST_BE_ENABLED);
            result = false;
        } else if (getVdsGroup().supportsGlusterService() && getVdsGroup().supportsVirtService() && !isAllowClusterWithVirtGluster()) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_ENABLING_BOTH_VIRT_AND_GLUSTER_SERVICES_NOT_ALLOWED);
            result = false;
        }
    }
    if (result && hasVms && !getVdsGroup().supportsVirtService()) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_VIRT_WHEN_CLUSTER_CONTAINS_VMS);
        result = false;
    }
    if (result && !getVdsGroup().supportsGlusterService()) {
        List<GlusterVolumeEntity> volumes = getGlusterVolumeDao().getByClusterId(getVdsGroup().getId());
        if (volumes != null && volumes.size() > 0) {
            addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_DISABLE_GLUSTER_WHEN_CLUSTER_CONTAINS_VOLUMES);
            result = false;
        }
    }
    if (result && getVdsGroup().supportsTrustedService() && Config.<String>getValue(ConfigValues.AttestationServer).equals("")) {
        addCanDoActionMessage(VdcBllMessages.VDS_GROUP_CANNOT_SET_TRUSTED_ATTESTATION_SERVER_NOT_CONFIGURED);
        result = false;
    }
    if (result) {
        result = validateClusterPolicy();
    }
    return result;
}
#end_block

#method_before
@Override
public void setComment(String value) {
    if (value == null) {
        this.comment = "";
    } else {
        this.comment = value;
    }
}
#method_after
@Override
public void setComment(String value) {
    this.comment = (value == null) ? "" : value;
}
#end_block

#method_before
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    // $NON-NLS-1$
    networks.addColumn(new NetworkNameTextColumnWithTooltip(), constants.nameNetwork(), "85px");
    networks.addColumn(new AttachedIndicatorCheckboxColumn(new AttachedIndicatorFieldUpdater()), new AttachedIndicatorCheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())), // $NON-NLS-1$
    "90px");
    networks.addColumn(new RequiredIndicatorCheckboxColumn(new RequiredIndicatorFieldUpdater()), new RequiredAllCheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())), // $NON-NLS-1$
    "110px");
    networks.addColumn(new VmNetworkImageSafeHtmlWithSafeHtmlTooltipColumn(constants), constants.vmNetwork(), // $NON-NLS-1$
    "80px");
    final SafeHtml displayNetworkColumnHeader = templates.textWithTooltip(constants.displayNetwork(), constants.restartVMwarning());
    networks.addColumn(new DisplayNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new DisplayNetworkIndicatorFieldUpdater()), displayNetworkColumnHeader, // $NON-NLS-1$
    "100px");
    networks.addColumn(new MigrationNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new MigrationNetworkIndicatorFieldUpdater()), constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#method_after
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    // $NON-NLS-1$
    networks.addColumn(new NetworkNameTextColumnWithTooltip(), constants.nameNetwork(), "85px");
    networks.addColumn(new AttachedIndicatorCheckboxColumn(new AttachedIndicatorFieldUpdater()), new AttachedIndicatorCheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())), // $NON-NLS-1$
    "90px");
    networks.addColumn(new RequiredIndicatorCheckboxColumn(new RequiredIndicatorFieldUpdater()), new RequiredAllCheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())), // $NON-NLS-1$
    "110px");
    networks.addColumn(new VmNetworkImageSafeHtmlWithSafeHtmlTooltipColumn(constants), constants.vmNetwork(), // $NON-NLS-1$
    "80px");
    final SafeHtml displayNetworkColumnHeader = templates.textWithTooltip(constants.displayNetwork(), constants.changeDisplayNetworkWarning());
    networks.addColumn(new DisplayNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new DisplayNetworkIndicatorFieldUpdater()), displayNetworkColumnHeader, // $NON-NLS-1$
    "100px");
    networks.addColumn(new MigrationNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new MigrationNetworkIndicatorFieldUpdater()), constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#end_block

#method_before
@Override
protected void initSelectedType() {
    Integer selectedNicType = getNic().getType();
    ArrayList<VmInterfaceType> nicTypes = (ArrayList<VmInterfaceType>) getNicType().getItems();
    nicTypes = nicTypes == null ? new ArrayList<VmInterfaceType>() : nicTypes;
    if (selectedNicType == null || !nicTypes.contains(VmInterfaceType.forValue(selectedNicType))) {
        selectedNicType = AsyncDataProvider.getDefaultNicType(nicTypes).getValue();
    }
    getNicType().setSelectedItem(VmInterfaceType.forValue(selectedNicType));
}
#method_after
@Override
protected void initSelectedType() {
    VmInterfaceType selectedNicType = VmInterfaceType.forValue(getNic().getType());
    ArrayList<VmInterfaceType> nicTypes = (ArrayList<VmInterfaceType>) getNicType().getItems();
    nicTypes = nicTypes == null ? new ArrayList<VmInterfaceType>() : nicTypes;
    if (selectedNicType == null || !nicTypes.contains(selectedNicType)) {
        selectedNicType = AsyncDataProvider.getDefaultNicType(nicTypes);
    }
    getNicType().setSelectedItem(selectedNicType);
}
#end_block

#method_before
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    return items.contains(VmInterfaceType.pv) ? VmInterfaceType.pv : items.iterator().next();
}
#method_after
public static VmInterfaceType getDefaultNicType(Collection<VmInterfaceType> items) {
    if (items == null || items.isEmpty()) {
        return null;
    } else if (items.contains(VmInterfaceType.pv)) {
        return VmInterfaceType.pv;
    } else {
        return items.iterator().next();
    }
}
#end_block

#method_before
public void updateVnics(final Guid vmId, final Iterable<VnicInstanceType> vnicsWithProfiles, final UnitVmModel unitVmModel) {
    final AsyncQuery getVmNicsQuery = new AsyncQuery();
    getVmNicsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Iterable<VmNetworkInterface> existingVnics = (Iterable<VmNetworkInterface>) result;
            if (existingVnics == null) {
                existingVnics = new ArrayList<VmNetworkInterface>();
            }
            Map<String, VmNetworkInterface> existingVnicForName = new HashMap<String, VmNetworkInterface>();
            for (VmNetworkInterface vnic : existingVnics) {
                existingVnicForName.put(vnic.getName(), vnic);
            }
            final ArrayList<VdcActionParametersBase> createVnicParameters = new ArrayList<VdcActionParametersBase>();
            final ArrayList<VdcActionParametersBase> updateVnicParameters = new ArrayList<VdcActionParametersBase>();
            final ArrayList<VdcActionParametersBase> removeVnicParameters = new ArrayList<VdcActionParametersBase>();
            final Set<String> vnicsEncountered = new HashSet<String>();
            // iterate over edited VNICs, see if any need to be added or have been assigned a different profile
            for (VnicInstanceType vnicWithProfile : vnicsWithProfiles) {
                VmNetworkInterface editedVnic = vnicWithProfile.getNetworkInterface();
                String vnicName = editedVnic.getName();
                VmNetworkInterface existingVnic = existingVnicForName.get(vnicName);
                if (existingVnic == null) {
                    editedVnic.setType(defaultType.getValue());
                    createVnicParameters.add(new AddVmInterfaceParameters(vmId, editedVnic));
                } else {
                    vnicsEncountered.add(vnicName);
                    Guid existingProfileId = existingVnic.getVnicProfileId();
                    Guid editedProfileId = editedVnic.getVnicProfileId();
                    if ((editedProfileId == null && existingProfileId != null) || (editedProfileId != null && !editedProfileId.equals(existingProfileId))) {
                        existingVnic.setVnicProfileId(editedProfileId);
                        existingVnic.setNetworkName(editedVnic.getNetworkName());
                        updateVnicParameters.add(new AddVmInterfaceParameters(vmId, existingVnic));
                    }
                }
            }
            // iterate over existing VNICs, see if any have not been encountered and thus removed in editing
            for (VmNetworkInterface existingVnic : existingVnics) {
                if (!vnicsEncountered.contains(existingVnic.getName())) {
                    removeVnicParameters.add(new RemoveVmInterfaceParameters(vmId, existingVnic.getId()));
                }
            }
            Frontend.getInstance().runMultipleActions(VdcActionType.AddVmInterface, createVnicParameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Frontend.getInstance().runMultipleActions(VdcActionType.UpdateVmInterface, updateVnicParameters, new IFrontendActionAsyncCallback() {

                        @Override
                        public void executed(FrontendActionAsyncResult result) {
                            Frontend.getInstance().runMultipleActions(VdcActionType.RemoveVmInterface, removeVnicParameters, new IFrontendActionAsyncCallback() {

                                @Override
                                public void executed(FrontendActionAsyncResult result) {
                                    if (unitVmModel.getIsNew()) {
                                        VmOperationParameterBase reorderParams = new VmOperationParameterBase(vmId);
                                        Frontend.getInstance().runAction(VdcActionType.ReorderVmNics, reorderParams, new IFrontendActionAsyncCallback() {

                                            public void executed(FrontendActionAsyncResult result) {
                                                callback.vnicCreated(vmId);
                                            }
                                        });
                                    } else {
                                        callback.vnicCreated(vmId);
                                    }
                                }
                            }, this);
                        }
                    }, this);
                }
            }, this);
        }
    };
    AsyncQuery osInfoQuery = new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultType = AsyncDataProvider.getDefaultNicType((Collection<VmInterfaceType>) returnValue);
            AsyncDataProvider.getVmNicList(getVmNicsQuery, vmId);
        }
    });
    AsyncDataProvider.getNicTypeList(unitVmModel.getOSType().getSelectedItem(), unitVmModel.getDataCenterWithClustersList().getSelectedItem().getCluster().getcompatibility_version(), osInfoQuery);
}
#method_after
public void updateVnics(final Guid vmId, final Iterable<VnicInstanceType> vnicsWithProfiles, final UnitVmModel unitVmModel) {
    final AsyncQuery getVmNicsQuery = new AsyncQuery();
    getVmNicsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            Iterable<VmNetworkInterface> existingVnics = (Iterable<VmNetworkInterface>) result;
            if (existingVnics == null) {
                existingVnics = new ArrayList<VmNetworkInterface>();
            }
            Map<String, VmNetworkInterface> existingVnicForName = new HashMap<String, VmNetworkInterface>();
            for (VmNetworkInterface vnic : existingVnics) {
                existingVnicForName.put(vnic.getName(), vnic);
            }
            final ArrayList<VdcActionParametersBase> createVnicParameters = new ArrayList<VdcActionParametersBase>();
            final ArrayList<VdcActionParametersBase> updateVnicParameters = new ArrayList<VdcActionParametersBase>();
            final ArrayList<VdcActionParametersBase> removeVnicParameters = new ArrayList<VdcActionParametersBase>();
            final Set<String> vnicsEncountered = new HashSet<String>();
            // iterate over edited VNICs, see if any need to be added or have been assigned a different profile
            for (VnicInstanceType vnicWithProfile : vnicsWithProfiles) {
                VmNetworkInterface editedVnic = vnicWithProfile.getNetworkInterface();
                String vnicName = editedVnic.getName();
                VmNetworkInterface existingVnic = existingVnicForName.get(vnicName);
                if (existingVnic == null) {
                    editedVnic.setType(defaultType == null ? null : defaultType.getValue());
                    createVnicParameters.add(new AddVmInterfaceParameters(vmId, editedVnic));
                } else {
                    vnicsEncountered.add(vnicName);
                    Guid existingProfileId = existingVnic.getVnicProfileId();
                    Guid editedProfileId = editedVnic.getVnicProfileId();
                    if ((editedProfileId == null && existingProfileId != null) || (editedProfileId != null && !editedProfileId.equals(existingProfileId))) {
                        existingVnic.setVnicProfileId(editedProfileId);
                        existingVnic.setNetworkName(editedVnic.getNetworkName());
                        updateVnicParameters.add(new AddVmInterfaceParameters(vmId, existingVnic));
                    }
                }
            }
            // iterate over existing VNICs, see if any have not been encountered and thus removed in editing
            for (VmNetworkInterface existingVnic : existingVnics) {
                if (!vnicsEncountered.contains(existingVnic.getName())) {
                    removeVnicParameters.add(new RemoveVmInterfaceParameters(vmId, existingVnic.getId()));
                }
            }
            Frontend.getInstance().runMultipleActions(VdcActionType.AddVmInterface, createVnicParameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Frontend.getInstance().runMultipleActions(VdcActionType.UpdateVmInterface, updateVnicParameters, new IFrontendActionAsyncCallback() {

                        @Override
                        public void executed(FrontendActionAsyncResult result) {
                            Frontend.getInstance().runMultipleActions(VdcActionType.RemoveVmInterface, removeVnicParameters, new IFrontendActionAsyncCallback() {

                                @Override
                                public void executed(FrontendActionAsyncResult result) {
                                    if (unitVmModel.getIsNew()) {
                                        VmOperationParameterBase reorderParams = new VmOperationParameterBase(vmId);
                                        Frontend.getInstance().runAction(VdcActionType.ReorderVmNics, reorderParams, new IFrontendActionAsyncCallback() {

                                            public void executed(FrontendActionAsyncResult result) {
                                                callback.vnicCreated(vmId);
                                            }
                                        });
                                    } else {
                                        callback.vnicCreated(vmId);
                                    }
                                }
                            }, this);
                        }
                    }, this);
                }
            }, this);
        }
    };
    AsyncQuery osInfoQuery = new AsyncQuery(new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultType = AsyncDataProvider.getDefaultNicType((Collection<VmInterfaceType>) returnValue);
            AsyncDataProvider.getVmNicList(getVmNicsQuery, vmId);
        }
    });
    AsyncDataProvider.getNicTypeList(unitVmModel.getOSType().getSelectedItem(), unitVmModel.getDataCenterWithClustersList().getSelectedItem().getCluster().getcompatibility_version(), osInfoQuery);
}
#end_block

#method_before
Iterable<ClusterNetworkModel> getNetworksTableItems() {
    ListModel<ClusterNetworkModel> tableModel = networks.asEditor().flush();
    return tableModel != null ? tableModel.getItems() : new ArrayList<ClusterNetworkModel>();
}
#method_after
Iterable<ClusterNetworkModel> getNetworksTableItems() {
    ClusterNetworkManageModel tableModel = networks.asEditor().flush();
    return tableModel != null ? tableModel.getItems() : new ArrayList<ClusterNetworkModel>();
}
#end_block

#method_before
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    // $NON-NLS-1$
    networks.addColumn(new NetworkNameTextColumnWithTooltip(), constants.nameNetwork(), "85px");
    networks.addColumn(new AttachedIndicatorCheckboxColumn(new AttachedIndicatorFieldUpdater(), constants, templates), new AttachedIndicatorCheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())), // $NON-NLS-1$
    "90px");
    networks.addColumn(new RequiredIndicatorCheckboxColumn(new RequiredIndicatorFieldUpdater(), templates, constants), new RequiredAllCheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())), // $NON-NLS-1$
    "110px");
    networks.addColumn(new VmNetworkImageSafeHtmlWithSafeHtmlTooltipColumn(constants), constants.vmNetwork(), // $NON-NLS-1$
    "80px");
    networks.addColumn(new DisplayNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new DisplayNetworkIndicatorFieldUpdater()), constants.displayNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new MigrationNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new MigrationNetworkIndicatorFieldUpdater()), constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#method_after
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    // $NON-NLS-1$
    networks.addColumn(new NetworkNameTextColumnWithTooltip(), constants.nameNetwork(), "85px");
    networks.addColumn(new AttachedIndicatorCheckboxColumn(new AttachedIndicatorFieldUpdater()), new AttachedIndicatorCheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())), // $NON-NLS-1$
    "90px");
    networks.addColumn(new RequiredIndicatorCheckboxColumn(new RequiredIndicatorFieldUpdater()), new RequiredAllCheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())), // $NON-NLS-1$
    "110px");
    networks.addColumn(new VmNetworkImageSafeHtmlWithSafeHtmlTooltipColumn(constants), constants.vmNetwork(), // $NON-NLS-1$
    "80px");
    networks.addColumn(new DisplayNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new DisplayNetworkIndicatorFieldUpdater()), constants.displayNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new MigrationNetworkIndicatorCheckboxColumn(multipleSelectionAllowed, new MigrationNetworkIndicatorFieldUpdater()), constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#end_block

#method_before
private PushButton createButton(final Pair<T, V> item, boolean plusButton) {
    final T value = item.getFirst();
    final V widget = item.getSecond();
    final PushButton button = new PushButton(new Image(plusButton ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    button.setEnabled(!isGhost(value));
    button.addClickHandler(plusButton ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getEntry(widget).removeLastButton();
            Pair<T, V> item = addGhostEntry();
            onAdd(item.getFirst(), item.getSecond());
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ListIterator<Pair<T, V>> last = items.listIterator(items.size());
            if (item == last.previous() && last.hasPrevious()) {
                Pair<T, V> previousItem = last.previous();
                getEntry(previousItem.getSecond()).appendButton(createButton(previousItem, true));
            }
            removeEntry(item);
            onRemove(value, widget);
            if (items.isEmpty()) {
                Pair<T, V> item = addGhostEntry();
                onAdd(item.getFirst(), item.getSecond());
            }
        }
    });
    return button;
}
#method_after
private PushButton createButton(final Pair<T, V> item, boolean plusButton) {
    final T value = item.getFirst();
    final V widget = item.getSecond();
    final PushButton button = new PushButton(new Image(plusButton ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    button.setEnabled(!isGhost(value));
    button.addClickHandler(plusButton ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            getEntry(widget).removeLastButton();
            Pair<T, V> item = addGhostEntry();
            onAdd(item.getFirst(), item.getSecond());
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ListIterator<Pair<T, V>> last = items.listIterator(items.size());
            if (!last.hasPrevious()) {
                // just a precaution; if there's no item, there should be no button
                return;
            }
            if (item == last.previous() && last.hasPrevious()) {
                // add plus button to previous item
                Pair<T, V> previousItem = last.previous();
                getEntry(previousItem.getSecond()).appendButton(createButton(previousItem, true));
            }
            removeEntry(item);
            onRemove(value, widget);
            if (items.isEmpty()) {
                Pair<T, V> item = addGhostEntry();
                onAdd(item.getFirst(), item.getSecond());
            }
        }
    });
    return button;
}
#end_block

#method_before
public boolean findProxyHost() {
    PMProxyOptions proxyOption = null;
    final Guid NO_VDS = Guid.Empty;
    int count = 0;
    // make sure that loop is executed at least once , no matter what is the
    // value in config
    int retries = Math.max(Config.<Integer>getValue(ConfigValues.FindFenceProxyRetries), 1);
    int delayInMs = 1000 * Config.<Integer>getValue(ConfigValues.FindFenceProxyDelayBetweenRetriesInSec);
    proxyHostId = NO_VDS;
    VDS proxyHost = null;
    boolean proxyFound = false;
    // get PM Proxy preferences or use defaults if not defined
    String pmProxyPreferences = (StringUtils.isEmpty(_vds.getPmProxyPreferences())) ? Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences) : _vds.getPmProxyPreferences();
    String[] pmProxyOptions = pmProxyPreferences.split(",");
    for (String pmProxyOption : pmProxyOptions) {
        if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.CLUSTER.name())) {
            proxyOption = PMProxyOptions.CLUSTER;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.DC.name())) {
            proxyOption = PMProxyOptions.DC;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.OTHERDC.name())) {
            proxyOption = PMProxyOptions.OTHERDC;
        } else {
            log.errorFormat("Illegal value in PM Proxy Preferences string {0}, skipped.", pmProxyOption);
            continue;
        }
        // available on new host.
        if (_vds.getId().equals(NO_VDS)) {
            // try first to find a Host in UP status
            proxyHost = getFenceProxy(true, false, proxyOption);
            // trying other Hosts that are not in UP since they can be a proxy for fence operations
            if (proxyHost == null) {
                proxyHost = getFenceProxy(false, false, proxyOption);
            }
            if (proxyHost != null) {
                proxyHostId = proxyHost.getId();
                proxyHostName = proxyHost.getName();
                proxyFound = true;
            }
        } else {
            // as configured.
            while (count < retries) {
                proxyHost = getFenceProxy(true, true, proxyOption);
                if (proxyHost == null) {
                    proxyHost = getFenceProxy(false, true, proxyOption);
                }
                if (proxyHost != null) {
                    proxyHostId = proxyHost.getId();
                    proxyHostName = proxyHost.getName();
                    proxyFound = true;
                    break;
                }
                // do not retry getting proxy for Status operation.
                if (_action == FenceActionType.Status)
                    break;
                log.infoFormat("Attempt {0} to find fence proxy host failed...", ++count);
                try {
                    Thread.sleep(delayInMs);
                } catch (Exception e) {
                    log.error(e.getMessage());
                    break;
                }
            }
        }
        if (proxyFound) {
            break;
        }
    }
    if (NO_VDS.equals(proxyHostId)) {
        log.errorFormat("Failed to run Power Management command on Host {0}, no running proxy Host was found.", _vds.getName());
    } else {
        logProxySelection(proxyHost.getName(), proxyOption.createLogEntry(proxyHost), _action.name());
    }
    return !NO_VDS.equals(proxyHostId);
}
#method_after
public boolean findProxyHost() {
    PMProxyOptions proxyOption = null;
    final Guid NO_VDS = Guid.Empty;
    int count = 0;
    // make sure that loop is executed at least once , no matter what is the
    // value in config
    int retries = Math.max(Config.<Integer>getValue(ConfigValues.FindFenceProxyRetries), 1);
    int delayInMs = 1000 * Config.<Integer>getValue(ConfigValues.FindFenceProxyDelayBetweenRetriesInSec);
    proxyHostId = NO_VDS;
    VDS proxyHost = null;
    boolean proxyFound = false;
    // get PM Proxy preferences or use defaults if not defined
    String pmProxyPreferences = (StringUtils.isEmpty(_vds.getPmProxyPreferences())) ? Config.<String>getValue(ConfigValues.FenceProxyDefaultPreferences) : _vds.getPmProxyPreferences();
    String[] pmProxyOptions = pmProxyPreferences.split(",");
    for (String pmProxyOption : pmProxyOptions) {
        if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.CLUSTER.name())) {
            proxyOption = PMProxyOptions.CLUSTER;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.DC.name())) {
            proxyOption = PMProxyOptions.DC;
        } else if (pmProxyOption.equalsIgnoreCase(PMProxyOptions.OTHER_DC.name())) {
            proxyOption = PMProxyOptions.OTHER_DC;
        } else {
            log.errorFormat("Illegal value in PM Proxy Preferences string {0}, skipped.", pmProxyOption);
            continue;
        }
        // available on new host.
        if (_vds.getId().equals(NO_VDS)) {
            // try first to find a Host in UP status
            proxyHost = getFenceProxy(true, false, proxyOption);
            // trying other Hosts that are not in UP since they can be a proxy for fence operations
            if (proxyHost == null) {
                proxyHost = getFenceProxy(false, false, proxyOption);
            }
            if (proxyHost != null) {
                proxyHostId = proxyHost.getId();
                proxyHostName = proxyHost.getName();
                proxyFound = true;
            }
        } else {
            // as configured.
            while (count < retries) {
                proxyHost = getFenceProxy(true, true, proxyOption);
                if (proxyHost == null) {
                    proxyHost = getFenceProxy(false, true, proxyOption);
                }
                if (proxyHost != null) {
                    proxyHostId = proxyHost.getId();
                    proxyHostName = proxyHost.getName();
                    proxyFound = true;
                    break;
                }
                // do not retry getting proxy for Status operation.
                if (_action == FenceActionType.Status)
                    break;
                log.infoFormat("Attempt {0} to find fence proxy host failed...", ++count);
                try {
                    Thread.sleep(delayInMs);
                } catch (Exception e) {
                    log.error(e.getMessage());
                    break;
                }
            }
        }
        if (proxyFound) {
            break;
        }
    }
    if (NO_VDS.equals(proxyHostId)) {
        log.errorFormat("Failed to run Power Management command on Host {0}, no running proxy Host was found.", _vds.getName());
    } else {
        logProxySelection(proxyHost.getName(), proxyOption.createLogEntry(proxyHost), _action.name());
    }
    return !NO_VDS.equals(proxyHostId);
}
#end_block

#method_before
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.OTHERDC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up;
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId());
                    } else {
                        return !isHostNetworkUnreacable(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#method_after
private VDS getFenceProxy(final boolean onlyUpHost, final boolean filterSelf, final PMProxyOptions proxyOptions) {
    List<VDS> hosts = DbFacade.getInstance().getVdsDao().getAll();
    VDS proxyHost = LinqUtils.firstOrNull(hosts, new Predicate<VDS>() {

        @Override
        public boolean eval(VDS vds) {
            if (!isAgentSupported(vds)) {
                return false;
            }
            if (proxyOptions == PMProxyOptions.CLUSTER) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getVdsGroupId().equals(_vds.getVdsGroupId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId()) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    } else {
                        return !isHostNetworkUnreacable(vds) && vds.getStoragePoolId().equals(_vds.getStoragePoolId());
                    }
                }
            } else if (proxyOptions == PMProxyOptions.OTHER_DC) {
                if (onlyUpHost) {
                    if (filterSelf) {
                        return !vds.getId().equals(_vds.getId()) && vds.getStatus() == VDSStatus.Up;
                    } else {
                        return vds.getStatus() == VDSStatus.Up;
                    }
                } else {
                    if (filterSelf) {
                        return !isHostNetworkUnreacable(vds) && !vds.getId().equals(_vds.getId());
                    } else {
                        return !isHostNetworkUnreacable(vds);
                    }
                }
            }
            return false;
        }

        private boolean isAgentSupported(VDS vds) {
            boolean ret = false;
            // Checks if the requested _vds PM agent is supported by the candidate proxy (vds)
            VdsFenceOptions options = new VdsFenceOptions(vds.getVdsGroupCompatibilityVersion().getValue());
            if (StringUtils.isNotEmpty(_vds.getManagementIp())) {
                ret = options.isAgentSupported(_vds.getPmType());
            }
            // Secondary PM agent should attempt to fence the Host
            if (StringUtils.isNotEmpty(_vds.getPmSecondaryIp())) {
                ret = options.isAgentSupported(_vds.getPmSecondaryType());
            }
            return ret;
        }
    });
    return proxyHost;
}
#end_block

#method_before
public static void main(String... args) {
    EngineConfigCLIParser parser = null;
    try {
        parser = new EngineConfigCLIParser();
        parser.parse(args);
        EngineConfigMap argsMap = parser.getEngineConfigMap();
        Log4jUtils.setupLogging(argsMap.getLog4jConfig(), EngineConfigExecutor.class.getResource("/engine-config/log4j.xml"));
        Log4jUtils.setupFileAppender(argsMap.getLogFile(), argsMap.getLogLevel());
    } catch (Throwable t) {
        System.out.println(t.getMessage());
        System.exit(1);
    }
    try {
        EngineConfig.getInstance().setUpAndExecute(parser);
    } catch (Throwable t) {
        Logger.getLogger(EngineConfigExecutor.class).debug("Exiting with error: ", t);
        System.out.println(t.getMessage());
        System.exit(1);
    }
}
#method_after
public static void main(String... args) {
    EngineConfigCLIParser parser = null;
    try {
        parser = new EngineConfigCLIParser();
        parser.parse(args);
        EngineConfigMap argsMap = parser.getEngineConfigMap();
        setupLogging(argsMap.getLog4jConfig(), argsMap.getLogFile(), argsMap.getLogLevel());
    } catch (Throwable t) {
        System.out.println(t.getMessage());
        System.exit(1);
    }
    try {
        EngineConfig.getInstance().setUpAndExecute(parser);
    } catch (Throwable t) {
        Logger.getLogger(EngineConfigExecutor.class).debug("Exiting with error: ", t);
        System.out.println(t.getMessage());
        System.exit(1);
    }
}
#end_block

#method_before
public static void setupLogging(String log4jConfig, URL defaultUrl) {
    try {
        URL url = defaultUrl;
        if (!StringUtils.isBlank(log4jConfig)) {
            File f = new File(log4jConfig);
            if (f.exists()) {
                url = f.toURI().toURL();
            } else {
                url = new URL(log4jConfig);
            }
        }
        LogManager.resetConfiguration();
        DOMConfigurator.configure(url);
    } catch (IOException | FactoryConfigurationError ex) {
        throw new RuntimeException("Cannot configure logging: " + ex.getMessage(), ex);
    }
}
#method_after
public static void setupLogging(URL url) {
    try {
        LogManager.resetConfiguration();
        DOMConfigurator.configure(url);
    } catch (FactoryConfigurationError ex) {
        throw new RuntimeException("Cannot configure logging: " + ex.getMessage(), ex);
    }
}
#end_block

#method_before
public void reuseSession() {
    getSessionId(new StorageCallback() {

        @Override
        public void onSuccess(String result) {
            if (result != null) {
                restApiSessionId = result;
                RestApiSessionAcquiredEvent.fire(eventBus, result);
                scheduleKeepAliveHeartbeat();
            } else {
                // $NON-NLS-1$
                RestApiSessionManager.logger.severe("Engine REST API session ID is not available");
            }
        }

        @Override
        public void onFailure(Throwable caught) {
            // $NON-NLS-1$
            RestApiSessionManager.logger.severe("Engine REST API session ID is not available");
        }
    });
}
#method_after
public void reuseSession() {
    // can we can utilize the async call to retrieve it from the backend.
    if (getSessionId() != null) {
        processSessionId(getSessionId());
    } else {
        getSessionId(new StorageCallback() {

            @Override
            public void onSuccess(String result) {
                if (result != null) {
                    restApiSessionId = result;
                    processSessionId(result);
                } else {
                    processSessionIdException();
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                processSessionIdException();
            }

            private void processSessionIdException() {
                // $NON-NLS-1$
                RestApiSessionManager.logger.severe("Engine REST API session ID is not available");
            }
        });
    }
}
#end_block

#method_before
void getSessionId(final StorageCallback callback) {
    Frontend.getInstance().retrieveValue(SESSION_ID_KEY, callback);
}
#method_after
void getSessionId(final StorageCallback callback) {
    Frontend.getInstance().retrieveFromHttpSession(SESSION_ID_KEY, callback);
}
#end_block

#method_before
void setSessionId(String sessionId) {
    Frontend.getInstance().storeValue(SESSION_ID_KEY, sessionId);
    restApiSessionId = sessionId;
}
#method_after
void setSessionId(String sessionId) {
    Frontend.getInstance().storeInHttpSession(SESSION_ID_KEY, sessionId);
    restApiSessionId = sessionId;
}
#end_block

#method_before
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getSessionId());
    return getBackend().runQuery(search, searchParameters);
}
#method_after
@Override
public VdcQueryReturnValue RunQuery(VdcQueryType search, VdcQueryParametersBase searchParameters) {
    // $NON-NLS-1$
    log.debug("Server: RunQuery invoked!");
    debugQuery(search, searchParameters);
    searchParameters.setSessionId(getSession().getId());
    return getBackend().runQuery(search, searchParameters);
}
#end_block

#method_before
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllCanDoPass, boolean isWaitForResult) {
    // $NON-NLS-1$ //$NON-NLS-2$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: " + multipleParams.size() + "]");
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getSessionId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllCanDoPass, isWaitForResult);
    return returnValues;
}
#method_after
@Override
public ArrayList<VdcReturnValueBase> RunMultipleActions(VdcActionType actionType, ArrayList<VdcActionParametersBase> multipleParams, boolean isRunOnlyIfAllCanDoPass, boolean isWaitForResult) {
    // $NON-NLS-1$ //$NON-NLS-2$
    log.debug("Server: RunMultipleAction invoked! [amount of actions: " + multipleParams.size() + "]");
    for (VdcActionParametersBase params : multipleParams) {
        params.setSessionId(getSession().getId());
    }
    ArrayList<VdcReturnValueBase> returnValues = getBackend().runMultipleActions(actionType, multipleParams, isRunOnlyIfAllCanDoPass, isWaitForResult);
    return returnValues;
}
#end_block

#method_before
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getSessionId());
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().runAction(actionType, params);
}
#method_after
@Override
public VdcReturnValueBase RunAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getSession().getId());
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().runAction(actionType, params);
}
#end_block

#method_before
@Override
public DbUser getLoggedInUser() {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(getSessionId());
    queryParams.setHttpSessionId(getSessionId());
    VdcQueryReturnValue vqrv = RunQuery(VdcQueryType.GetUserBySessionId, queryParams);
    if (!vqrv.getSucceeded()) {
        return null;
    } else if (vqrv.getSucceeded()) {
        if (vqrv.getReturnValue() == null) {
            return null;
        }
        return (DbUser) vqrv.getReturnValue();
    } else {
        // For unknown reason the result was failed be returned.
        return null;
    }
}
#method_after
@Override
public DbUser getLoggedInUser() {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(getSession().getId());
    queryParams.setHttpSessionId(getSession().getId());
    VdcQueryReturnValue vqrv = RunQuery(VdcQueryType.GetUserBySessionId, queryParams);
    if (!vqrv.getSucceeded()) {
        return null;
    } else if (vqrv.getSucceeded()) {
        if (vqrv.getReturnValue() == null) {
            return null;
        }
        return (DbUser) vqrv.getReturnValue();
    } else {
        // For unknown reason the result was failed be returned.
        return null;
    }
}
#end_block

#method_before
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().logoff(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSession().getId());
    VdcReturnValueBase returnValue = getBackend().logoff(params);
    return returnValue;
}
#end_block

#method_before
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    params.setSessionId(getSessionId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase Login(String userName, String password, String profileName, VdcActionType loginType) {
    LoginUserParameters params = new LoginUserParameters(profileName, userName, password);
    HttpSession originalSession = getSession();
    // Prevent session fixation.
    getSession().invalidate();
    // Calling getSession again after invalidating it should create a new session.
    HttpSession newSession = getSession();
    // $NON-NLS-1$
    assert !newSession.equals(originalSession) : "new session the same as old session";
    params.setSessionId(getSession().getId());
    params.setActionType(loginType);
    VdcReturnValueBase returnValue = getBackend().login(params);
    return returnValue;
}
#end_block

#method_before
@Override
public void storeInHttpSession(String key, String value) {
    HttpServletRequest request = this.getThreadLocalRequest();
    HttpSession session = request.getSession();
    session.setAttribute(key, value);
}
#method_after
@Override
public void storeInHttpSession(String key, String value) {
    HttpServletRequest request = this.getThreadLocalRequest();
    HttpSession session = request.getSession();
    session.setAttribute(UI_PREFIX + key, value);
}
#end_block

#method_before
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__MANUAL_FENCE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__MANUAL_FENCE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__HOST);
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuid(rs, "vds_group_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setBaseTemplateId(getGuidDefaultEmpty(rs, "base_template_id"));
    entity.setTemplateVersionNumber(rs.getInt("template_version_number"));
    entity.setTemplateVersionName(rs.getString("template_version_name"));
    return entity;
}
#end_block

#method_before
@Test
public void testUpdateVmPolicy() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetEntityExpectations("Hosts: name=" + NAMES[1], SearchType.VDS, getHost());
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    VM model = getModel(0);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    verifyModel(resource.update(model), 0);
}
#method_after
@Test
public void testUpdateVmPolicy() throws Exception {
    setUpGetEntityExpectations(3);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetPayloadExpectations(0, 2);
    setUpGetBallooningExpectations();
    setUpGetBallooningExpectations();
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpEntityQueryExpectations(VdcQueryType.GetVdsStaticByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, getStaticHost());
    setUriInfo(setUpActionExpectations(VdcActionType.UpdateVm, VmManagementParametersBase.class, new String[] {}, new Object[] {}, true, true));
    VM model = getModel(0);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    verifyModel(resource.update(model), 0);
}
#end_block

#method_before
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpGetEntityExpectations("Storage: name=" + NAMES[2], SearchType.StorageDomain, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false, false);
}
#method_after
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false, false);
}
#end_block

#method_before
@Test
public void testMoveWithStorageDomainName() throws Exception {
    setUpGetEntityExpectations("Storage: name=" + NAMES[2], SearchType.StorageDomain, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestMove(storageDomain);
}
#method_after
@Test
public void testMoveWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestMove(storageDomain);
}
#end_block

#method_before
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_3)) {
        addFeatureVmApplications(features);
        addFeatureVirtioScsi(features);
        addFeatureComment(features);
        addFeatureRefreshHostCapabilities(features);
        addFeatureMemorySnapshot(features);
        addWatchdogFeature(features);
        addSshAuthenticationFeature(features);
        addForceSelectSpmFeature(features);
        addConsoleFeature(features);
        addFeatureStorageServerConnections(features);
        addFeatureStorageServerConnectionsForDomain(features);
        addFeatureAttachDetachStorageServerConnectionsForDomain(features);
        addSingleQxlPciFeature(features);
        addFeatureAddVmFromOvf(features);
        addVnicProfilesFeature(features);
        addStorageDomainImageFeature(features);
        addGlusterHooksFeature(features);
        addFeatureReportVmFQDN(features);
        addFeatureAttachDiskSnapshot(features);
        addFeatureCloudInit(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_4)) {
        addGlusterBricksFeature(features);
        addFeatureCopyMoveDiskInAdditionalContext(features);
        addNetworkLabelsFeature(features);
        addRebootFeature(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_5)) {
        addHostedEngineMaintenanceFeature(features);
    }
    return features;
}
#method_after
public Features getFeatures(Version version) {
    Features features = new Features();
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_0)) {
        addFeatureTransparentHugePages(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_1)) {
        addFeatureGluster(features);
        addFeaturePosixDevice(features);
        addFeaturePortMirroring(features);
        addFeatureServerTime(features);
        addFeatureHostMemory(features);
        addFeatureHostSockets(features, version);
        addFeatureIgnoreCase(features);
        addFeatureMaxResults(features);
        addFeatureJSONContentType(features);
        addFeatureCorrelationId(features);
        addFeatureDiskActivation(features);
        addFeatureNicActivation(features);
        addFeatureSnapshotsRefactoring(features);
        addFeatureRemoveTemplateFromSD(features);
        addFeatureFloatingDisks(features);
        addFeatureAsyncDelete(features);
        addFeatureSessionBasedAuthentication(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_3)) {
        addFeatureVmApplications(features);
        addFeatureVirtioScsi(features);
        addFeatureComment(features);
        addFeatureRefreshHostCapabilities(features);
        addFeatureMemorySnapshot(features);
        addWatchdogFeature(features);
        addSshAuthenticationFeature(features);
        addForceSelectSpmFeature(features);
        addConsoleFeature(features);
        addFeatureStorageServerConnections(features);
        addFeatureStorageServerConnectionsForDomain(features);
        addFeatureAttachDetachStorageServerConnectionsForDomain(features);
        addSingleQxlPciFeature(features);
        addFeatureAddVmFromOvf(features);
        addVnicProfilesFeature(features);
        addStorageDomainImageFeature(features);
        addGlusterHooksFeature(features);
        addFeatureReportVmFQDN(features);
        addFeatureAttachDiskSnapshot(features);
        addFeatureCloudInit(features);
    }
    if (VersionUtils.greaterOrEqual(version, BackendCapabilitiesResource.VERSION_3_4)) {
        addGlusterBricksFeature(features);
        addFeatureCopyMoveDiskInAdditionalContext(features);
        addNetworkLabelsFeature(features);
        addRebootFeature(features);
        addMaintenanceFeature(features);
    }
    return features;
}
#end_block

#method_before
private String getHostId(String hostName) {
    return getEntity(VDS.class, SearchType.VDS, "Hosts: name=" + hostName).getId().toString();
}
#method_after
private String getHostId(String hostName) {
    return getEntity(VdsStatic.class, VdcQueryType.GetVdsStaticByName, new NameQueryParameters(hostName), "Hosts: name=" + hostName).getId().toString();
}
#end_block

#method_before
protected Guid lookupClusterId(VM vm) {
    return vm.getCluster().isSetId() ? asGuid(vm.getCluster().getId()) : getEntity(VDSGroup.class, SearchType.Cluster, "Cluster: name=" + vm.getCluster().getName()).getId();
}
#method_after
protected Guid lookupClusterId(VM vm) {
    return vm.getCluster().isSetId() ? asGuid(vm.getCluster().getId()) : getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(vm.getCluster().getName()), "Cluster: name=" + vm.getCluster().getName()).getId();
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    HostedEngine hostedEngine = new HostedEngine();
    hostedEngine.setConfigured(entity.getHighlyAvailableIsConfigured());
    hostedEngine.setActive(entity.getHighlyAvailableIsActive());
    hostedEngine.setScore(entity.getHighlyAvailableScore());
    hostedEngine.setGlobalMaintenance(entity.getHighlyAvailableGlobalMaintenance());
    hostedEngine.setLocalMaintenance(entity.getHighlyAvailableLocalMaintenance());
    model.setHostedEngine(hostedEngine);
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(StatusUtils.create(status));
    if (status == HostStatus.NON_OPERATIONAL) {
        model.getStatus().setDetail(entity.getNonOperationalReason().name().toLowerCase());
    }
    StorageManager sm = new StorageManager();
    sm.setPriority(entity.getVdsSpmPriority());
    sm.setValue(entity.getSpmStatus() == VdsSpmStatus.SPM);
    model.setStorageManager(sm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(getHostOs(entity.getHostOs()));
    model.setKsm(new KSM());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), (SSH) null));
    CPU cpu = new CPU();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type != null ? type.value() : null);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    return model;
}
#end_block

#method_before
@Mapping(from = Host.class, to = VdsOperationActionParameters.class)
public static VdsOperationActionParameters map(Host host, VdsOperationActionParameters params) {
    params.setPassword(host.getRootPassword());
    if (host.isSetSsh()) {
        if (host.getSsh().isSetUser()) {
            if (host.getSsh().getUser().isSetPassword()) {
                // For backward compatibility giving priority to rootPassword field
                if (params.getPassword() == null) {
                    params.setPassword(host.getSsh().getUser().getPassword());
                }
            }
            if (host.getSsh().getUser().isSetUserName()) {
                params.getvds().setSshUsername(host.getSsh().getUser().getUserName());
            }
        }
        if (host.getSsh().isSetPort()) {
            params.getvds().setSshPort(host.getSsh().getPort());
        }
        if (host.getSsh().isSetFingerprint()) {
            params.getvds().setSshKeyFingerprint(host.getSsh().getFingerprint());
        }
        if (host.getSsh().isSetAuthenticationMethod()) {
            params.setAuthMethod(map(AuthenticationMethod.fromValue(host.getSsh().getAuthenticationMethod()), null));
        }
    }
    return params;
}
#method_after
@Mapping(from = VDS.class, to = HostedEngine.class)
public static HostedEngine map(VDS entity, HostedEngine template) {
    HostedEngine hostedEngine = template != null ? template : new HostedEngine();
    hostedEngine.setConfigured(entity.getHighlyAvailableIsConfigured());
    hostedEngine.setActive(entity.getHighlyAvailableIsActive());
    hostedEngine.setScore(entity.getHighlyAvailableScore());
    hostedEngine.setGlobalMaintenance(entity.getHighlyAvailableGlobalMaintenance());
    hostedEngine.setLocalMaintenance(entity.getHighlyAvailableLocalMaintenance());
    return hostedEngine;
}
#end_block

#method_before
private static void setHookId(Hook hook, String hookName, String eventName, String md5) {
    Guid guid = generateHookId(eventName, hookName, md5);
    hook.setId(guid.toString());
}
#method_after
private static void setHookId(Hook hook, String hookName, String eventName, String md5) {
    Guid guid = GuidUtils.generateGuidUsingMd5(eventName, hookName, md5);
    hook.setId(guid.toString());
}
#end_block

#method_before
@Test
public void testHostedEngineMapping() {
    VDS vds = new VDS();
    vds.setId(Guid.Empty);
    vds.setHighlyAvailableIsConfigured(true);
    vds.setHighlyAvailableIsActive(false);
    vds.setHighlyAvailableScore(123);
    vds.setHighlyAvailableGlobalMaintenance(true);
    vds.setHighlyAvailableLocalMaintenance(false);
    Host host = HostMapper.map(vds, (Host) null);
    assertNotNull(host.getHostedEngine());
    assertEquals(host.getHostedEngine().isConfigured(), Boolean.TRUE);
    assertEquals(host.getHostedEngine().isActive(), Boolean.FALSE);
    assertEquals(host.getHostedEngine().getScore(), Integer.valueOf(123));
    assertEquals(host.getHostedEngine().isGlobalMaintenance(), Boolean.TRUE);
    assertEquals(host.getHostedEngine().isLocalMaintenance(), Boolean.FALSE);
}
#method_after
@Test
public void testHostedEngineMapping() {
    VDS vds = new VDS();
    vds.setId(Guid.Empty);
    vds.setHighlyAvailableIsConfigured(true);
    vds.setHighlyAvailableIsActive(false);
    vds.setHighlyAvailableScore(123);
    vds.setHighlyAvailableGlobalMaintenance(true);
    vds.setHighlyAvailableLocalMaintenance(false);
    HostedEngine hostedEngine = HostMapper.map(vds, (HostedEngine) null);
    assertNotNull(hostedEngine);
    assertEquals(hostedEngine.isConfigured(), Boolean.TRUE);
    assertEquals(hostedEngine.isActive(), Boolean.FALSE);
    assertEquals(hostedEngine.getScore(), Integer.valueOf(123));
    assertEquals(hostedEngine.isGlobalMaintenance(), Boolean.TRUE);
    assertEquals(hostedEngine.isLocalMaintenance(), Boolean.FALSE);
}
#end_block

#method_before
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = (String) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#method_after
private static void getDefaultConfigurationVersion(Object target) {
    AsyncQuery callback = new AsyncQuery(target, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            if (returnValue != null) {
                _defaultConfigurationVersion = ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                _defaultConfigurationVersion = GENERAL;
            }
            LoginModel loginModel = (LoginModel) model;
            loginModel.getLoggedInEvent().raise(loginModel, EventArgs.EMPTY);
        }
    });
    callback.setHandleFailure(true);
    Frontend.getInstance().runQuery(VdcQueryType.GetDefaultConfigurationVersion, new VdcQueryParametersBase(), callback);
}
#end_block

#method_before
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = (HashMap<ArchitectureType, Integer>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#method_after
public static void initDefaultOSes() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            defaultOSes = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDefaultOSes), callback);
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StoragePool> pools = (List<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && !pools.isEmpty()) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#method_after
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StoragePool> pools = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && !pools.isEmpty()) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = returnValue.getReturnValue();
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#method_after
public static void getNicTypeList(final int osId, Version version, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<VmInterfaceType> interfaceTypes = new ArrayList<VmInterfaceType>();
            for (String nic : nics) {
                try {
                    interfaceTypes.add(VmInterfaceType.valueOf(nic));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNetworkDevices, osId, version), asyncQuery);
}
#end_block

#method_before
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#method_after
public static void initOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osNames = ((VdcQueryReturnValue) returnValue).getReturnValue();
            initOsIds();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsNames), callback);
}
#end_block

#method_before
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = (HashMap<Integer, ArchitectureType>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#method_after
public static void initOsArchitecture() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            osArchitectures = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetOsArchitectures), callback);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel<String>>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel<String>>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel<String>>> list = new ArrayList<Map.Entry<String, EntityModel<String>>>();
    EntityModel<String> entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel<String>>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel<String>();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel<String>>("custom", entityModel));
    return list;
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel<? extends DisplayType> displayProtocolSelectedItem = (EntityModel<? extends DisplayType>) getDisplayProtocol().getSelectedItem();
    params.setUseVnc(displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if (getDisplayConsole_Vnc_IsSelected().getEntity() || getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc(getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setBootMenuEnabled(getBootMenuEnabled().getEntity());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel<? extends DisplayType> displayProtocolSelectedItem = (EntityModel<? extends DisplayType>) getDisplayProtocol().getSelectedItem();
    params.setUseVnc(displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if (getDisplayConsole_Vnc_IsSelected().getEntity() || getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc(getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMemSize().setIsChangable(vm.isDown());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    getModel().getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMemSize().setIsChangable(vm.isDown());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    getModel().getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getBaseTemplate().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getSerialNumberPolicy().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        getSsoMethodNone().setIsChangable(false);
        getSsoMethodGuestAgent().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && ObjectUtils.objectsEqual(Frontend.getInstance().getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            getBehavior().oSType_SelectedItemChanged();
            getVmInitModel().osTypeChanged(getOSType().getSelectedItem());
            updateDisplayProtocol();
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        } else if (sender == getBaseTemplate()) {
            behavior.baseTemplateSelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getVmInitEnabled()) {
            vmInitEnabledChanged();
        } else if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if (getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if (getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        } else if (sender == getOverrideMigrationDowntime()) {
            overrideMigrationDowntimeChanged();
        } else if (sender == getIsSubTemplate()) {
            behavior.isSubTemplateEntityChanged();
        }
    }
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
}
#end_block

#method_before
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getcompatibility_version();
        getBootMenuEnabled().setIsAvailable(AsyncDataProvider.isBootMenuSupported(version.toString()));
    }
}
#method_after
private void updateBootMenu() {
    if (getSelectedCluster() != null) {
        Version version = getSelectedCluster().getcompatibility_version();
        final boolean supported = AsyncDataProvider.isBootMenuSupported(version.toString());
        if (!supported) {
            getBootMenuEnabled().setEntity(false);
            getBootMenuEnabled().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootMenuNotSupported(version.toString(2)));
        }
        getBootMenuEnabled().setIsChangable(supported);
    }
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
    updateWatchdogModels(osType);
    vmInitEnabledChanged();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void selectDataCenterWithCluster(UnitVmModel model, Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    if (selectedCluster == null) {
        getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters));
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster)));
    }
}
#method_after
protected void selectDataCenterWithCluster(Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    DataCenterWithCluster selectedDataCenterWithCluster = (selectedCluster == null) ? Linq.firstOrDefault(dataCentersWithClusters) : Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster));
    getDataCenterWithClustersList().setItems(dataCentersWithClusters, selectedDataCenterWithCluster);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    boolean vmInitIsValid = getVmInitModel().validate();
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && vmInitIsValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#end_block

#method_before
private void validateMemorySize(EntityModel model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = (Integer) model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#method_after
private void validateMemorySize(EntityModel<Integer> model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#end_block

#method_before
protected void initSpiceProxy() {
    EntityModelLabel label = new EntityModelLabel();
    label.setText(constants.defineSpiceProxyEnable());
    spiceProxyOverrideEnabledEditor = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo(label, spiceProxyOverrideEnabledEditor);
}
#method_after
protected void initSpiceProxy() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.defineSpiceProxyEnable());
    spiceProxyOverrideEnabledEditor = new EntityModelCheckBoxOnlyEditor();
    spiceProxyEnabledCheckboxWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, spiceProxyOverrideEnabledEditor);
}
#end_block

#method_before
private void initTotalVcpus() {
    EntityModelLabel label = new EntityModelLabel();
    label.setText(constants.numOfVCPUs());
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelWidgetWithInfo(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(applicationTemplates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#method_after
private void initTotalVcpus() {
    StringEntityModelLabel label = new StringEntityModelLabel();
    label.setText(constants.numOfVCPUs());
    totalvCPUsEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    totalvCPUsEditorWithInfoIcon = new EntityModelWidgetWithInfo<String>(label, totalvCPUsEditor);
    totalvCPUsEditorWithInfoIcon.setExplanation(applicationTemplates.italicText(messages.hotPlugUnplugCpuWarning()));
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                boolean sysprepEnabled = object.getSysprepEnabled().getEntity();
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
                domainEditor.setVisible(sysprepEnabled);
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
}
#end_block

#method_before
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsWindowsOS".equals(propName)) {
                // $NON-NLS-1$
                domainEditor.setEnabled(vm.getIsWindowsOS());
            } else if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#method_after
private void initTabAvailabilityListeners(final UnitVmModel vm) {
    // TODO should be handled by the core framework
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsSystemTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsSystemTabValid()) {
                    systemTab.markAsValid();
                } else {
                    systemTab.markAsInvalid(null);
                }
            } else if ("IsDisplayTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsDisplayTabValid()) {
                    consoleTab.markAsValid();
                } else {
                    consoleTab.markAsInvalid(null);
                }
            } else if ("IsAllocationTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsAllocationTabValid()) {
                    resourceAllocationTab.markAsValid();
                } else {
                    resourceAllocationTab.markAsInvalid(null);
                }
            } else if ("IsHighlyAvailable".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(highAvailabilityTab, vm.getIsHighlyAvailable().getEntity());
            } else if ("IsBootSequenceTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsHighlyAvailable().getEntity()) {
                    bootOptionsTab.markAsValid();
                } else {
                    bootOptionsTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (vm.getIsCustomPropertiesTabValid()) {
                    customPropertiesTab.markAsValid();
                } else {
                    customPropertiesTab.markAsInvalid(null);
                }
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                boolean isDisksAvailable = vm.getIsDisksAvailable();
                changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
                boolean isProvisioningAvailable = vm.getProvisioning().getIsAvailable();
                changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || vm.getIsVirtioScsiEnabled().getIsAvailable());
                if (isDisksAvailable) {
                    // Update warning message by disks status
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.ILLEGAL);
                    updateDisksWarningByImageStatus(vm.getDisks(), ImageStatus.LOCKED);
                } else {
                    // Clear warning message
                    // $NON-NLS-1$
                    generalWarningMessage.setText("");
                }
            }
        }
    });
    // TODO: Move to a more appropriate method
    vm.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsLinuxOS".equals(propName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(linuxBootOptionsPanel, vm.getIsLinuxOS());
            }
        }
    });
    defaultHostEditor.setEnabled(false);
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    // TODO: This is a hack and should be handled cleanly via model property availability
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    vm.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue())
                specificHost.setValue(true, true);
        }
    });
    ssoMethodGuestAgent.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodNone.asRadioButton(), false);
            }
        }
    });
    ssoMethodNone.asRadioButton().addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            if (Boolean.TRUE.equals(event.getValue())) {
                ValueChangeEvent.fire(ssoMethodGuestAgent.asRadioButton(), false);
            }
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    bootMenuEnabledEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
        getModel().getBootMenuEnabled().setEntity(template.isBootMenuEnabled());
    }
}
#method_after
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
        getModel().getBootMenuEnabled().setEntity(template.isBootMenuEnabled());
    }
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateQuotaByCluster(null, null);
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateVirtioScsiAvailability();
    updateOSValues();
    updateTemplate();
    updateNumOfSockets();
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(this.vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(this.vm.getVmOsId());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getDefaultBootSequence());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.vm.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(this.vm.getNumOfSockets());
    getModel().getIsStateless().setEntity(this.vm.isStateless());
    getModel().getIsRunAndPause().setEntity(this.vm.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(this.vm.isDeleteProtected());
    getModel().selectSsoMethod(this.vm.getSsoMethod());
    updateSelectedCdImage(this.vm.getStaticData());
    updateTimeZone(this.vm.getTimeZone());
    updateConsoleDevice(this.vm.getId());
    // Update domain list
    updateDomain();
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == this.vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getUsbPolicy().setSelectedItem(this.vm.getUsbPolicy());
    getModel().getIsSmartcardEnabled().setEntity(this.vm.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(this.vm.getDefaultVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(this.vm.getMigrationDowntime());
    initPriority(this.vm.getPriority());
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    getModel().getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getMemSize().setEntity(this.vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(this.vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(this.vm.getVmOsId());
    getModel().getNumOfMonitors().setSelectedItem(this.vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(this.vm.getAllowConsoleReconnect());
    getModel().setBootSequence(this.vm.getDefaultBootSequence());
    getModel().getTotalCPUCores().setEntity(Integer.toString(this.vm.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(this.vm.getNumOfSockets());
    getModel().getIsStateless().setEntity(this.vm.isStateless());
    getModel().getIsRunAndPause().setEntity(this.vm.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(this.vm.isDeleteProtected());
    getModel().selectSsoMethod(this.vm.getSsoMethod());
    updateSelectedCdImage(this.vm.getStaticData());
    updateTimeZone(this.vm.getTimeZone());
    updateConsoleDevice(this.vm.getId());
    getModel().getStorageDomain().setIsChangable(true);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == this.vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getUsbPolicy().setSelectedItem(this.vm.getUsbPolicy());
    getModel().getIsSmartcardEnabled().setEntity(this.vm.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(this.vm.getDefaultVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(this.vm.getMigrationDowntime());
    initPriority(this.vm.getPriority());
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    getModel().getBootMenuEnabled().setEntity(vm.isBootMenuEnabled());
}
#end_block

#method_before
@Override
protected void baseTemplateSelectedItemChanged() {
}
#method_after
@Override
protected void baseTemplateSelectedItemChanged() {
    if (getModel().getBaseTemplate().getSelectedItem() != null && getModel().getIsSubTemplate().getEntity()) {
        // template.name for version should be the same as the base template name
        getModel().getName().setEntity(getModel().getBaseTemplate().getSelectedItem().getName());
    }
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        BuilderExecutor.build(vmBase, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
        getModel().getBootMenuEnabled().setEntity(vmBase.isBootMenuEnabled());
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getVmType().setSelectedItem(vmBase.getVmType());
        setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        BuilderExecutor.build(vmBase, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
        getModel().getBootMenuEnabled().setEntity(vmBase.isBootMenuEnabled());
    }
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    getModel().getTemplateVersionName().setEntity(template.getTemplateVersionName());
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    getModel().getTemplateVersionName().setEntity(template.getTemplateVersionName());
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(String actionName, String title, String message, boolean reasonVisible) {
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(title);
    model.setReasonVisible(reasonVisible);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onShutdown() {
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true);
        }
    });
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void onStop() {
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL);
        }
    });
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg());
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg(), false);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (jobId != null) {
            log.infoFormat("Cancelling current running update for vms for base template id {0}", getParameters().getBaseTemplateId());
            try {
                SchedulerUtilQuartzImpl.getInstance().deleteJob(jobId);
            } catch (Exception e) {
                log.warnFormat("Failed deleting job {0} at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), VmDeviceUtils.isBalloonEnabled(getVmId()), false);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVm().isBalloonEnabled(), false);
            }
            setSucceeded(true);
            return null;
        }
    });
    VmHandler.warnMemorySizeLegal(getVmTemplate(), getVdsGroup().getcompatibility_version());
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getVmTemplateDAO().get(getParameters().getBaseTemplateId());
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        } else // template version name should be the same as the base template name
        {
            setVmTemplateName(userSelectedBaseTemplate.getName());
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    // A Template cannot be added in a cluster without a defined architecture
    if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (!isTemplateVersion() && isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    if (isTemplateVersion()) {
        VmTemplate userSelectedBaseTemplate = getBaseTemplate();
        if (userSelectedBaseTemplate == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (!userSelectedBaseTemplate.isBaseTemplate()) {
            // currently template version cannot be base template
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_VERSION_CANNOT_BE_BASE_TEMPLATE);
        }
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#end_block

#method_before
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior());
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(CustomPropertiesKeysList);
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newInternal() {
    UnitVmModel model = new UnitVmModel(new UserPortalNewVmModelBehavior());
    model.getVmType().setSelectedItem(VmType.Server);
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.setCustomPropertiesKeysList(CustomPropertiesKeysList);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm));
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(CustomPropertiesKeysList);
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new UserPortalExistingVmModelBehavior(vm));
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setCustomPropertiesKeysList(CustomPropertiesKeysList);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("up_vm_dialog");
    setWindow(model);
    model.initialize(null);
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public static ResourceManager getInstance() {
    return _Instance;
}
#method_after
public static ResourceManager getInstance() {
    return instance;
}
#end_block

#method_before
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), _vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    DbFacade.getInstance().getVdsDynamicDao().updateAllInBatch(updatedEntities);
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#method_after
public void init() {
    log.info("Start initializing " + getClass().getSimpleName());
    List<VDS> allVdsList = DbFacade.getInstance().getVdsDao().getAll();
    HashSet<Guid> nonResponsiveVdss = new HashSet<Guid>();
    for (VDS helper_vds : allVdsList) {
        if (helper_vds.getStatus() == VDSStatus.NonResponsive) {
            nonResponsiveVdss.add(helper_vds.getId());
        }
    }
    // Is there any VM that is not fully Up or fully Down?
    boolean runningVmsInTransition = false;
    // Cleanup all vms dynamic data. This is defensive code on power crash
    List<VM> vms = DbFacade.getInstance().getVmDao().getAll();
    for (VM vm : vms) {
        if (!vm.isNotRunning()) {
            if (vm.getRunOnVds() != null) {
                MultiValueMapUtils.addToMap(vm.getRunOnVds(), vm.getId(), vdsAndVmsList, new MultiValueMapUtils.HashSetCreator<Guid>());
            }
            if (vm.getRunOnVds() != null && nonResponsiveVdss.contains(vm.getRunOnVds())) {
                SetVmUnknown(vm);
            }
        }
        if (!runningVmsInTransition && vm.isRunning() && vm.getStatus() != VMStatus.Up) {
            runningVmsInTransition = true;
        }
    }
    // Clean pending memory and CPUs if there is no VM in transition on a given Host
    // (meaning we tried to start a VM and the engine crashed before telling VDSM about it)
    List<VdsDynamic> updatedEntities = new ArrayList<>();
    for (VDS _vds : allVdsList) {
        boolean _saveVdsDynamic = false;
        if (_vds.getPendingVcpusCount() != 0 && !runningVmsInTransition) {
            _vds.setPendingVcpusCount(0);
            _saveVdsDynamic = true;
        }
        if (_vds.getPendingVmemSize() != 0 && !runningVmsInTransition) {
            _vds.setPendingVmemSize(0);
            _saveVdsDynamic = true;
        }
        if (_saveVdsDynamic) {
            updatedEntities.add(_vds.getDynamicData());
        }
    }
    DbFacade.getInstance().getVdsDynamicDao().updateAllInBatch(updatedEntities);
    // Populate the VDS dictionary
    for (VDS curVds : allVdsList) {
        AddVds(curVds, true);
    }
    IrsBrokerCommand.init();
    log.info("Finished initializing " + getClass().getSimpleName());
}
#end_block

#method_before
public boolean AddAsyncRunningVm(Guid vmId) {
    boolean returnValue = false;
    if (_asyncRunningVms.putIfAbsent(vmId, Boolean.TRUE) == null) {
        returnValue = true;
    }
    return returnValue;
}
#method_after
public boolean AddAsyncRunningVm(Guid vmId) {
    return asyncRunningVms.add(vmId);
}
#end_block

#method_before
public void RemoveAsyncRunningVm(Guid vmId) {
    _asyncRunningVms.remove(vmId);
    getEventListener().removeAsyncRunningCommand(vmId);
}
#method_after
public void RemoveAsyncRunningVm(Guid vmId) {
    asyncRunningVms.remove(vmId);
    getEventListener().removeAsyncRunningCommand(vmId);
}
#end_block

#method_before
public void succededToRunVm(Guid vmId, Guid vdsId) {
    if (_asyncRunningVms.containsKey(vmId)) {
        getEventListener().runningSucceded(vmId);
    }
    RemoveAsyncRunningVm(vmId);
}
#method_after
public void succededToRunVm(Guid vmId, Guid vdsId) {
    if (asyncRunningVms.contains(vmId)) {
        getEventListener().runningSucceded(vmId);
    }
    RemoveAsyncRunningVm(vmId);
}
#end_block

#method_before
public void RerunFailedCommand(Guid vmId, Guid vdsId) {
    Boolean value = _asyncRunningVms.remove(vmId);
    // remove async record from broker only
    if (value != null) {
        getEventListener().rerun(vmId);
    }
}
#method_after
public void RerunFailedCommand(Guid vmId, Guid vdsId) {
    if (asyncRunningVms.remove(vmId)) {
        // remove async record from broker only
        getEventListener().rerun(vmId);
    }
}
#end_block

#method_before
public boolean IsVmInAsyncRunningList(Guid vmId) {
    return (_asyncRunningVms.containsKey(vmId));
}
#method_after
public boolean IsVmInAsyncRunningList(Guid vmId) {
    return asyncRunningVms.contains(vmId);
}
#end_block

#method_before
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        vms.remove(vmId);
    }
}
#method_after
public void RemoveVmFromDownVms(Guid vdsId, Guid vmId) {
    HashSet<Guid> vms = vdsAndVmsList.get(vdsId);
    if (vms != null) {
        vms.remove(vmId);
    }
}
#end_block

#method_before
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = null;
    if ((vms = _vdsAndVmsList.get(vdsId)) != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        _vdsAndVmsList.remove(vdsId);
    }
}
#method_after
public void HandleVdsFinishedInit(Guid vdsId) {
    HashSet<Guid> vms = vdsAndVmsList.get(vdsId);
    if (vms != null) {
        for (Guid vmId : vms) {
            getEventListener().processOnVmStop(vmId);
            log.info("Procceed on vm stop entered: " + vmId.toString());
        }
        vdsAndVmsList.remove(vdsId);
    }
}
#end_block

#method_before
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    _vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("VDS {0} was added to the Resource Manager", vds.getId());
}
#method_after
public void AddVds(VDS vds, boolean isInternal) {
    VdsManager vdsManager = VdsManager.buildVdsManager(vds);
    if (isInternal) {
        VDSStatus status = vds.getStatus();
        switch(vds.getStatus()) {
            case Error:
                status = VDSStatus.Up;
                break;
            case Reboot:
            case NonResponsive:
            case Connecting:
            case Installing:
                status = VDSStatus.Unassigned;
                break;
        }
        if (status != vds.getStatus()) {
            vdsManager.setStatus(status, vds);
            vdsManager.updateStatisticsData(vds.getStatisticsData());
        }
        // set pending to 0
        vds.setPendingVcpusCount(0);
        vdsManager.updateDynamicData(vds.getDynamicData());
    }
    vdsManager.schedulJobs();
    vdsManagersDict.put(vds.getId(), vdsManager);
    log.infoFormat("VDS {0} was added to the Resource Manager", vds.getId());
}
#end_block

#method_before
public void RemoveVds(Guid vdsId) {
    VdsManager vdsManager = GetVdsManager(vdsId);
    if (vdsManager != null) {
        vdsManager.dispose();
        _vdsManagersDict.remove(vdsId);
    }
}
#method_after
public void RemoveVds(Guid vdsId) {
    RemoveVds(vdsId, false);
}
#end_block

#method_before
public void RemoveVds(Guid vdsId) {
    VdsManager vdsManager = GetVdsManager(vdsId);
    if (vdsManager != null) {
        vdsManager.dispose();
        _vdsManagersDict.remove(vdsId);
    }
}
#method_after
public void RemoveVds(Guid vdsId, boolean newHost) {
    VdsManager vdsManager = GetVdsManager(vdsId, newHost);
    if (vdsManager != null) {
        vdsManager.dispose();
        vdsManagersDict.remove(vdsId);
    }
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId) {
    VdsManager vdsManger = _vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
    }
    return vdsManger;
}
#method_after
public VdsManager GetVdsManager(Guid vdsId) {
    return GetVdsManager(vdsId, false);
}
#end_block

#method_before
public VdsManager GetVdsManager(Guid vdsId) {
    VdsManager vdsManger = _vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
    }
    return vdsManger;
}
#method_after
public VdsManager GetVdsManager(Guid vdsId, boolean newHost) {
    VdsManager vdsManger = vdsManagersDict.get(vdsId);
    if (vdsManger == null) {
        if (!newHost) {
            log.errorFormat("Cannot get vdsManager for vdsid={0}", vdsId);
        }
    }
    return vdsManger;
}
#end_block

#method_before
public boolean IsVmDuringInitiating(Guid vm_guid) {
    return _asyncRunningVms.containsKey(vm_guid);
}
#method_after
public boolean IsVmDuringInitiating(Guid vm_guid) {
    return asyncRunningVms.contains(vm_guid);
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    log.infoFormat("vm {0} DOWN exit reason generic", vm.getId());
    InternalSetVmStatus(vm, status, VmExitStatus.Normal, StringUtils.EMPTY, VmExitReason.Unknown);
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status) {
    InternalSetVmStatus(vm, status, VmExitStatus.Normal, StringUtils.EMPTY, VmExitReason.Unknown);
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage, final VmExitReason exitReason) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    vm.setExitReason(exitReason);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
            vm.setLastStopTime(new Date());
            log.infoFormat("vm {0} DOWN exit reason : {1}", vm.getId(), vm.getExitReason());
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status, VmExitStatus exitStatus) {
    InternalSetVmStatus(vm, status, exitStatus, StringUtils.EMPTY, VmExitReason.Unknown);
}
#end_block

#method_before
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage, final VmExitReason exitReason) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    vm.setExitReason(exitReason);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
            vm.setLastStopTime(new Date());
            log.infoFormat("vm {0} DOWN exit reason : {1}", vm.getId(), vm.getExitReason());
        }
    }
}
#method_after
public void InternalSetVmStatus(VM vm, final VMStatus status, final VmExitStatus exitStaus, final String exitMessage, final VmExitReason exitReason) {
    vm.setStatus(status);
    vm.setExitStatus(exitStaus);
    vm.setExitMessage(exitMessage);
    vm.setExitReason(exitReason);
    boolean isVmNotRunning = status.isNotRunning();
    if (isVmNotRunning || status == VMStatus.Unknown) {
        resetVmAttributes(vm);
        if (isVmNotRunning) {
            vm.setRunOnVds(null);
            vm.setVmPauseStatus(VmPauseStatus.NONE);
            vm.setLastStopTime(new Date());
        }
    }
}
#end_block

#method_before
public static String migrationMethodtoString(MigrationMethod method) {
    if (method == MigrationMethod.OFFLINE) {
        return offline;
    } else if (method == MigrationMethod.ONLINE) {
        return online;
    } else {
        return "";
    }
}
#method_after
public static String migrationMethodtoString(MigrationMethod method) {
    switch(method) {
        case OFFLINE:
            return offline;
        case ONLINE:
            return online;
        default:
            return "";
    }
}
#end_block

#method_before
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId());
}
#method_after
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    setCurrentCd(vm.getCurrentCd());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + migreatingFromPort;
    result = prime * result + migreatingToPort;
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.setDisplay(instance.getDisplay());
    vm.setDisplayIp(instance.getDisplayIp());
    vm.setDisplaySecurePort(instance.getDisplaySecurePort());
    vm.setDisplayType(instance.getDisplayType());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestLastLoginTime(instance.getGuestLastLoginTime());
    vm.setGuestLastLogoutTime(instance.getGuestLastLogoutTime());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setVdsGroupCompatibilityVersion(instance.getVdsGroupCompatibilityVersion());
    vm.setVdsGroupId(instance.getVdsGroupId());
    vm.setVdsGroupName(instance.getVdsGroupName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setVmIp(instance.getVmIp());
    vm.setVmFQDN(instance.getVmFQDN());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmPid(instance.getVmPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    return vm;
}
#end_block

#method_before
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    return obj;
}
#method_after
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    obj.setArchitecture(instance.getArchitecture());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    return obj;
}
#end_block

#method_before
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    return obj;
}
#method_after
private static VmTemplate cloneVmTemplate(VmTemplate instance) {
    VmTemplate obj = new VmTemplate();
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setStoragePoolName(instance.getStoragePoolName());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setSizeGB(instance.getSizeGB());
    // TODO: see comments above on DiskImageMap
    obj.setDiskImageMap(instance.getDiskImageMap());
    obj.setInterfaces(instance.getInterfaces());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setChildCount(instance.getChildCount());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setComment(instance.getComment());
    obj.setFailBack(instance.isFailBack());
    obj.setStateless(instance.isStateless());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setName(instance.getName());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setStatus(instance.getStatus());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setVdsGroupName(instance.getVdsGroupName());
    obj.setVmType(instance.getVmType());
    obj.setId(instance.getId());
    obj.setDiskList(instance.getDiskList());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setClusterArch(instance.getClusterArch());
    obj.setTemplateVersionNumber(instance.getTemplateVersionNumber());
    obj.setBaseTemplateId(instance.getBaseTemplateId());
    obj.setTemplateVersionName(instance.getTemplateVersionName());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    return obj;
}
#end_block

#method_before
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    return obj;
}
#method_after
private static VmStatic cloneVmStatic(VmStatic instance) {
    VmStatic obj = new VmStatic();
    obj.setFailBack(instance.isFailBack());
    obj.setDefaultBootSequence(instance.getDefaultBootSequence());
    obj.setVmType(instance.getVmType());
    obj.setDefaultDisplayType(instance.getDefaultDisplayType());
    obj.setPriority(instance.getPriority());
    obj.setIsoPath(instance.getIsoPath());
    obj.setOrigin(instance.getOrigin());
    obj.setAutoStartup(instance.isAutoStartup());
    obj.setCpuPerSocket(instance.getCpuPerSocket());
    obj.setCreationDate(instance.getCreationDate());
    obj.setDedicatedVmForVds(instance.getDedicatedVmForVds());
    obj.setDescription(instance.getDescription());
    obj.setComment(instance.getComment());
    obj.setInitialized(instance.isInitialized());
    obj.setStateless(instance.isStateless());
    obj.setRunAndPause(instance.isRunAndPause());
    obj.setMemSizeMb(instance.getMemSizeMb());
    obj.setDiskSize(instance.getDiskSize());
    obj.setNiceLevel(instance.getNiceLevel());
    obj.setNumOfMonitors(instance.getNumOfMonitors());
    obj.setAllowConsoleReconnect(instance.isAllowConsoleReconnect());
    obj.setNumOfSockets(instance.getNumOfSockets());
    obj.setTimeZone(instance.getTimeZone());
    obj.setUsbPolicy(instance.getUsbPolicy());
    obj.setVdsGroupId(instance.getVdsGroupId());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setVmtGuid(instance.getVmtGuid());
    obj.setUseLatestVersion(instance.isUseLatestVersion());
    obj.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    obj.setCustomSerialNumber(instance.getCustomSerialNumber());
    return obj;
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", StringUtils.stripEnd(sNetworks.toString(), ", "));
                logable.addCustomValue("Interfaces", StringUtils.stripEnd(sNics.toString(), ", "));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()), VmExitReason.GenericError);
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        memCommited += vm.getVmMemSizeMb();
        memCommited += _vds.getGuestOverhead();
        vmsCoresCount += vm.getNumOfCpus();
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VmInternalData runningVm : _runningVms.values()) {
        VmDynamic vmDynamic = runningVm.getVmDynamic();
        // we shouldn't include them as committed.
        if (vmDynamic.getStatus() != VMStatus.WaitForLaunch && vmDynamic.getStatus() != VMStatus.Down) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                memCommited += vm.getVmMemSizeMb();
                memCommited += _vds.getGuestOverhead();
                vmsCoresCount += vm.getNumOfCpus();
            }
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    } else {
        vm.setCurrentCd(null);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    } else {
        vm.setExitReason(VmExitReason.Unknown);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + exitReason.hashCode();
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    result = prime * result + exitReason.hashCode();
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && exitReason == other.exitReason);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason) && exitReason == other.exitReason);
}
#end_block

#method_before
private String getHostId(String hostName) {
    return getEntity(VDS.class, SearchType.VDS, "Hosts: name=" + hostName).getId().toString();
}
#method_after
private String getHostId(String hostName) {
    return getEntity(VdsStatic.class, VdcQueryType.GetVdsStaticByName, new NameQueryParameters(hostName), "Hosts: name=" + hostName).getId().toString();
}
#end_block

#method_before
protected Guid lookupClusterId(VM vm) {
    return vm.getCluster().isSetId() ? asGuid(vm.getCluster().getId()) : getEntity(VDSGroup.class, SearchType.Cluster, "Cluster: name=" + vm.getCluster().getName()).getId();
}
#method_after
protected Guid lookupClusterId(VM vm) {
    return vm.getCluster().isSetId() ? asGuid(vm.getCluster().getId()) : getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(vm.getCluster().getName()), "Cluster: name=" + vm.getCluster().getName()).getId();
}
#end_block

#method_before
@Override
public Response cloneVm(Action action) {
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), "GetVmByVmId");
    // in case not set let the server to handle it in canDoAction
    String newName = "";
    if (action.isSetCloneConfiguration() && action.getCloneConfiguration().isSetName()) {
        newName = action.getCloneConfiguration().getName();
    }
    CloneVmParameters cloneVmParameters = new CloneVmParameters(vm, newName);
    cloneVmParameters.setMakeCreatorExplicitOwner(isFiltered());
    Response response = doAction(VdcActionType.CloneVm, cloneVmParameters, action);
    return response;
}
#method_after
@Override
public Response cloneVm(Action action) {
    validateParameters(action, "vm.name");
    org.ovirt.engine.core.common.businessentities.VM vm = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), "VM: id=" + guid);
    CloneVmParameters cloneVmParameters = new CloneVmParameters(vm, action.getVm().getName());
    cloneVmParameters.setMakeCreatorExplicitOwner(isFiltered());
    Response response = doAction(VdcActionType.CloneVm, cloneVmParameters, action);
    return response;
}
#end_block

#method_before
protected void lockEntities() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // Assumption - a snapshot can be locked only if in status OK, so if canDoAction passed
            // this is the status of the snapshot. In addition the newly added VM is in down status
            getCompensationContext().snapshotEntityStatus(getSnapshot());
            getSnapshotDao().updateStatus(sourceSnapshotId, SnapshotStatus.LOCKED);
            lockVmWithCompensationIfNeeded();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
}
#method_after
@Override
protected void lockEntities() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            // Assumption - a snapshot can be locked only if in status OK, so if canDoAction passed
            // this is the status of the snapshot. In addition the newly added VM is in down status
            getCompensationContext().snapshotEntityStatus(getSnapshot());
            getSnapshotDao().updateStatus(sourceSnapshotId, SnapshotStatus.LOCKED);
            lockVmWithCompensationIfNeeded();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
}
#end_block

#method_before
protected void unlockEntities() {
    // Assumption - this is last DB change of command, no need for compensation here
    getSnapshotDao().updateStatus(sourceSnapshotId, SnapshotStatus.OK);
    getVmDynamicDao().updateStatus(getVmId(), VMStatus.Down);
}
#method_after
@Override
protected void unlockEntities() {
    // Assumption - this is last DB change of command, no need for compensation here
    getSnapshotDao().updateStatus(sourceSnapshotId, SnapshotStatus.OK);
    getVmDynamicDao().updateStatus(getVmId(), VMStatus.Down);
}
#end_block

#method_before
@Override
protected void updateOriginalTemplate(VmStatic vmStatic) {
    vmStatic.setOriginalTemplateGuid(getParameters().getVmStaticData().getOriginalTemplateGuid());
    vmStatic.setOriginalTemplateName(getParameters().getVmStaticData().getOriginalTemplateName());
}
#method_after
protected void updateOriginalTemplate(VmStatic vmStatic) {
// do not update it - it is already correctly configured from the snapshot
}
#end_block

#method_before
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.VM.name().toLowerCase(), StringUtils.defaultString(getParameters().getNewName()));
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put(VdcObjectType.VM.name().toLowerCase(), StringUtils.defaultString(getParameters().getNewName()));
    }
    return jobProperties;
}
#end_block

#method_before
private void setupParameters() {
    setVmId(Guid.newGuid());
    VM vmToClone = getVm();
    getParameters().setNewVmGuid(getVmId());
    getParameters().setVmStaticData(vmToClone.getStaticData());
    List<VmDevice> devices = getVmDeviceDao().getVmDeviceByVmId(oldVmId);
    getParameters().setSoundDeviceEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.SOUND));
    getParameters().setConsoleEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.CONSOLE));
    getParameters().setVirtioScsiEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI));
    getParameters().setBalloonEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.BALLOON));
    VdcQueryReturnValue watchdogs = getBackend().runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(oldVmId));
    if (!((List<VmWatchdog>) watchdogs.getReturnValue()).isEmpty()) {
        VmWatchdog watchdog = ((List<VmWatchdog>) watchdogs.getReturnValue()).iterator().next();
        getParameters().setUpdateWatchdog(true);
        getParameters().setWatchdog(watchdog);
    }
    fillDisksToParameters();
}
#method_after
private void setupParameters() {
    setVmId(Guid.newGuid());
    VM vmToClone = getVm();
    getParameters().setNewVmGuid(getVmId());
    getParameters().setVm(vmToClone);
    List<VmDevice> devices = getVmDeviceDao().getVmDeviceByVmId(oldVmId);
    getParameters().setSoundDeviceEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.SOUND));
    getParameters().setConsoleEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.CONSOLE));
    getParameters().setVirtioScsiEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI));
    getParameters().setBalloonEnabled(containsDeviceWithType(devices, VmDeviceGeneralType.BALLOON));
    VdcQueryReturnValue watchdogs = getBackend().runInternalQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(oldVmId));
    if (!((List<VmWatchdog>) watchdogs.getReturnValue()).isEmpty()) {
        VmWatchdog watchdog = ((List<VmWatchdog>) watchdogs.getReturnValue()).iterator().next();
        getParameters().setUpdateWatchdog(true);
        getParameters().setWatchdog(watchdog);
    }
    fillDisksToParameters();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!getSourceVmFromDb().isDown()) {
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (!(getSourceVmFromDb().getStatus() == VMStatus.Suspended || getSourceVmFromDb().isDown())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
    }
    return super.canDoAction();
}
#end_block

#method_before
private String getDiskSharedLockMessage() {
    if (cachedDiskSharedLockMessage == null) {
        cachedDiskSharedLockMessage = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
    }
    return cachedDiskSharedLockMessage;
}
#method_after
protected String getDiskSharedLockMessage() {
    if (cachedDiskSharedLockMessage == null) {
        cachedDiskSharedLockMessage = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_USED_FOR_CREATE_VM.name()).append(String.format("$VmName %1$s", getVmName())).toString();
    }
    return cachedDiskSharedLockMessage;
}
#end_block

#method_before
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(CreateEntity.class);
    return super.getValidationGroups();
}
#method_after
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(CreateVm.class);
    return super.getValidationGroups();
}
#end_block

#method_before
public String getReason() {
    if (mReason == null && getVm() != null) {
        mReason = getVm().getReason();
    }
    return mReason;
}
#method_after
public String getReason() {
    if (mReason == null && getVm() != null) {
        mReason = getVm().getStopReason();
    }
    return mReason;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setReason(rs.getString("reason"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setSsoMethod(SsoMethod.fromString(rs.getString("sso_method")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setDefaultVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    entity.setClusterArch(ArchitectureType.forValue(rs.getInt("architecture")));
    entity.setOriginalTemplateName(rs.getString("original_template_name"));
    entity.setOriginalTemplateGuid(getGuid(rs, "original_template_id"));
    entity.setVmPoolSpiceProxy(rs.getString("vm_pool_spice_proxy"));
    entity.setVdsGroupSpiceProxy(rs.getString("vds_group_spice_proxy"));
    entity.setMigrationDowntime((Integer) rs.getObject("migration_downtime"));
    // if template_version_number is null it means use latest version
    entity.setUseLatestVersion(rs.getObject("template_version_number") == VmStaticDAODbFacadeImpl.USE_LATEST_VERSION_NUMBER_INDICATOR);
    entity.setCurrentCd(rs.getString("current_cd"));
    entity.setSerialNumberPolicy(SerialNumberPolicy.forValue((Integer) rs.getObject("serial_number_policy")));
    entity.setCustomSerialNumber(rs.getString("custom_serial_number"));
    entity.setStopReason(rs.getString("reason"));
    return entity;
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    setCurrentCd(vm.getCurrentCd());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    getDynamicData().setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + migreatingFromPort;
    result = prime * result + migreatingToPort;
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("display", vm.getDisplay()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("display_ip", vm.getDisplayIp()).addValue("display_type", vm.getDisplayType()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("display_secure_port", vm.getDisplaySecurePort()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("hibernation_vol_handle", vm.getHibernationVolHandle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getReason());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("vm_fqdn", vm.getVmFQDN()).addValue("last_start_time", vm.getLastStartTime()).addValue("last_stop_time", vm.getLastStopTime()).addValue("vm_pid", vm.getVmPid()).addValue("display", vm.getDisplay()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("display_ip", vm.getDisplayIp()).addValue("display_type", vm.getDisplayType()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("display_secure_port", vm.getDisplaySecurePort()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("hibernation_vol_handle", vm.getHibernationVolHandle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce()).addValue("cpu_name", vm.getCpuName()).addValue("current_cd", vm.getCurrentCd()).addValue("reason", vm.getStopReason());
}
#end_block

#method_before
@Override
protected RowMapper<VmDynamic> createEntityRowMapper() {
    return new RowMapper<VmDynamic>() {

        @Override
        public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmDynamic entity = new VmDynamic();
            entity.setAppList(rs.getString("app_list"));
            entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
            entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
            entity.setConsoleUserId(getGuid(rs, "console_user_id"));
            entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
            entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
            entity.setGuestOs(rs.getString("guest_os"));
            entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
            entity.setRunOnVds(getGuid(rs, "run_on_vds"));
            entity.setStatus(VMStatus.forValue(rs.getInt("status")));
            entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
            entity.setVmHost(rs.getString("vm_host"));
            entity.setVmIp(rs.getString("vm_ip"));
            entity.setVmFQDN(rs.getString("vm_fqdn"));
            entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
            entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
            entity.setVmPid((Integer) rs.getObject("vm_pid"));
            entity.setDisplay((Integer) rs.getObject("display"));
            entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
            entity.setSession(SessionState.forValue(rs.getInt("session")));
            entity.setDisplayIp(rs.getString("display_ip"));
            entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
            entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
            entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
            entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
            entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
            entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
            entity.setClientIp(rs.getString("client_ip"));
            entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
            entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
            VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
            VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
            entity.setExitMessage(rs.getString("exit_message"));
            entity.setExitStatus(exitStatus);
            entity.setPauseStatus(pauseStatus);
            entity.setHash(rs.getString("hash"));
            entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
            entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
            entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
            entity.setRunOnce(rs.getBoolean("is_run_once"));
            entity.setCpuName(rs.getString("cpu_name"));
            entity.setCurrentCd(rs.getString("current_cd"));
            entity.setReason(rs.getString("reason"));
            return entity;
        }
    };
}
#method_after
@Override
protected RowMapper<VmDynamic> createEntityRowMapper() {
    return new RowMapper<VmDynamic>() {

        @Override
        public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmDynamic entity = new VmDynamic();
            entity.setAppList(rs.getString("app_list"));
            entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
            entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
            entity.setConsoleUserId(getGuid(rs, "console_user_id"));
            entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
            entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
            entity.setGuestOs(rs.getString("guest_os"));
            entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
            entity.setRunOnVds(getGuid(rs, "run_on_vds"));
            entity.setStatus(VMStatus.forValue(rs.getInt("status")));
            entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
            entity.setVmHost(rs.getString("vm_host"));
            entity.setVmIp(rs.getString("vm_ip"));
            entity.setVmFQDN(rs.getString("vm_fqdn"));
            entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
            entity.setLastStopTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_stop_time")));
            entity.setVmPid((Integer) rs.getObject("vm_pid"));
            entity.setDisplay((Integer) rs.getObject("display"));
            entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
            entity.setSession(SessionState.forValue(rs.getInt("session")));
            entity.setDisplayIp(rs.getString("display_ip"));
            entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
            entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
            entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
            entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
            entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
            entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
            entity.setClientIp(rs.getString("client_ip"));
            entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
            entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
            VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
            VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
            entity.setExitMessage(rs.getString("exit_message"));
            entity.setExitStatus(exitStatus);
            entity.setPauseStatus(pauseStatus);
            entity.setHash(rs.getString("hash"));
            entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
            entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
            entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
            entity.setRunOnce(rs.getBoolean("is_run_once"));
            entity.setCpuName(rs.getString("cpu_name"));
            entity.setCurrentCd(rs.getString("current_cd"));
            entity.setStopReason(rs.getString("reason"));
            return entity;
        }
    };
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<VmDynamic> getBatchMapper() {
    return new MapSqlParameterMapper<VmDynamic>() {

        @Override
        public MapSqlParameterSource map(VmDynamic entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("guest_cur_user_name", entity.getGuestCurrentUserName()).addValue("console_cur_user_name", entity.getConsoleCurrentUserName()).addValue("guest_last_login_time", entity.getGuestLastLoginTime()).addValue("guest_last_logout_time", entity.getGuestLastLogoutTime()).addValue("console_user_id", entity.getConsoleUserId()).addValue("guest_os", entity.getGuestOs()).addValue("migrating_to_vds", entity.getMigratingToVds()).addValue("run_on_vds", entity.getRunOnVds()).addValue("status", entity.getStatus()).addValue("vm_guid", entity.getId()).addValue("vm_host", entity.getVmHost()).addValue("vm_ip", entity.getVmIp()).addValue("last_start_time", entity.getLastStartTime()).addValue("last_stop_time", entity.getLastStopTime()).addValue("vm_pid", entity.getVmPid()).addValue("vm_fqdn", entity.getVmFQDN()).addValue("app_list", entity.getAppList()).addValue("display", entity.getDisplay()).addValue("acpi_enable", entity.getAcpiEnable()).addValue("session", entity.getSession()).addValue("display_ip", entity.getDisplayIp()).addValue("display_type", entity.getDisplayType()).addValue("kvm_enable", entity.getKvmEnable()).addValue("boot_sequence", entity.getBootSequence()).addValue("display_secure_port", entity.getDisplaySecurePort()).addValue("utc_diff", entity.getUtcDiff()).addValue("last_vds_run_on", entity.getLastVdsRunOn()).addValue("client_ip", entity.getClientIp()).addValue("guest_requested_memory", entity.getGuestRequestedMemory()).addValue("hibernation_vol_handle", entity.getHibernationVolHandle()).addValue("exit_status", entity.getExitStatus()).addValue("pause_status", entity.getPauseStatus()).addValue("exit_message", entity.getExitMessage()).addValue("hash", entity.getHash()).addValue("guest_agent_nics_hash", entity.getGuestAgentNicsHash()).addValue("last_watchdog_event", entity.getLastWatchdogEvent()).addValue("last_watchdog_action", entity.getLastWatchdogAction()).addValue("is_run_once", entity.isRunOnce()).addValue("cpu_name", entity.getCpuName()).addValue("current_cd", entity.getCurrentCd()).addValue("reason", entity.getReason());
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<VmDynamic> getBatchMapper() {
    return new MapSqlParameterMapper<VmDynamic>() {

        @Override
        public MapSqlParameterSource map(VmDynamic entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("guest_cur_user_name", entity.getGuestCurrentUserName()).addValue("console_cur_user_name", entity.getConsoleCurrentUserName()).addValue("guest_last_login_time", entity.getGuestLastLoginTime()).addValue("guest_last_logout_time", entity.getGuestLastLogoutTime()).addValue("console_user_id", entity.getConsoleUserId()).addValue("guest_os", entity.getGuestOs()).addValue("migrating_to_vds", entity.getMigratingToVds()).addValue("run_on_vds", entity.getRunOnVds()).addValue("status", entity.getStatus()).addValue("vm_guid", entity.getId()).addValue("vm_host", entity.getVmHost()).addValue("vm_ip", entity.getVmIp()).addValue("last_start_time", entity.getLastStartTime()).addValue("last_stop_time", entity.getLastStopTime()).addValue("vm_pid", entity.getVmPid()).addValue("vm_fqdn", entity.getVmFQDN()).addValue("app_list", entity.getAppList()).addValue("display", entity.getDisplay()).addValue("acpi_enable", entity.getAcpiEnable()).addValue("session", entity.getSession()).addValue("display_ip", entity.getDisplayIp()).addValue("display_type", entity.getDisplayType()).addValue("kvm_enable", entity.getKvmEnable()).addValue("boot_sequence", entity.getBootSequence()).addValue("display_secure_port", entity.getDisplaySecurePort()).addValue("utc_diff", entity.getUtcDiff()).addValue("last_vds_run_on", entity.getLastVdsRunOn()).addValue("client_ip", entity.getClientIp()).addValue("guest_requested_memory", entity.getGuestRequestedMemory()).addValue("hibernation_vol_handle", entity.getHibernationVolHandle()).addValue("exit_status", entity.getExitStatus()).addValue("pause_status", entity.getPauseStatus()).addValue("exit_message", entity.getExitMessage()).addValue("hash", entity.getHash()).addValue("guest_agent_nics_hash", entity.getGuestAgentNicsHash()).addValue("last_watchdog_event", entity.getLastWatchdogEvent()).addValue("last_watchdog_action", entity.getLastWatchdogAction()).addValue("is_run_once", entity.isRunOnce()).addValue("cpu_name", entity.getCpuName()).addValue("current_cd", entity.getCurrentCd()).addValue("reason", entity.getStopReason());
            return paramValue;
        }
    };
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (reason == null ? 0 : reason.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((acpiEnabled == null) ? 0 : acpiEnabled.hashCode());
    result = prime * result + ((appList == null) ? 0 : appList.hashCode());
    result = prime * result + bootSequence.hashCode();
    result = prime * result + ((clientIp == null) ? 0 : clientIp.hashCode());
    result = prime * result + ((display == null) ? 0 : display.hashCode());
    result = prime * result + ((displayIp == null) ? 0 : displayIp.hashCode());
    result = prime * result + ((displaySecurePort == null) ? 0 : displaySecurePort.hashCode());
    result = prime * result + displayType.hashCode();
    result = prime * result + ((vncKeyboardLayout == null) ? 0 : vncKeyboardLayout.hashCode());
    result = prime * result + ((consoleCurrentUserName == null) ? 0 : consoleCurrentUserName.hashCode());
    result = prime * result + ((guestCurUserName == null) ? 0 : guestCurUserName.hashCode());
    result = prime * result + ((consoleUserId == null) ? 0 : consoleUserId.hashCode());
    result = prime * result + ((guestLastLoginTime == null) ? 0 : guestLastLoginTime.hashCode());
    result = prime * result + ((guestLastLogoutTime == null) ? 0 : guestLastLogoutTime.hashCode());
    result = prime * result + ((guestOs == null) ? 0 : guestOs.hashCode());
    result = prime * result + ((guestRequestedMemory == null) ? 0 : guestRequestedMemory.hashCode());
    result = prime * result + ((hibernationVolHandle == null) ? 0 : hibernationVolHandle.hashCode());
    result = prime * result + ((kvmEnable == null) ? 0 : kvmEnable.hashCode());
    result = prime * result + ((lastVdsRunOn == null) ? 0 : lastVdsRunOn.hashCode());
    result = prime * result + ((disks == null) ? 0 : disks.hashCode());
    result = prime * result + ((exitMessage == null) ? 0 : exitMessage.hashCode());
    result = prime * result + exitStatus.hashCode();
    result = prime * result + (win2kHackEnabled ? 1231 : 1237);
    result = prime * result + ((migratingToVds == null) ? 0 : migratingToVds.hashCode());
    result = prime * result + ((pauseStatus == null) ? 0 : pauseStatus.hashCode());
    result = prime * result + ((runOnVds == null) ? 0 : runOnVds.hashCode());
    result = prime * result + session.hashCode();
    result = prime * result + status.hashCode();
    result = prime * result + ((utcDiff == null) ? 0 : utcDiff.hashCode());
    result = prime * result + ((vmHost == null) ? 0 : vmHost.hashCode());
    result = prime * result + ((vmIp == null) ? 0 : vmIp.hashCode());
    result = prime * result + ((vmFQDN == null) ? 0 : vmFQDN.hashCode());
    result = prime * result + ((lastStartTime == null) ? 0 : lastStartTime.hashCode());
    result = prime * result + ((lastStopTime == null) ? 0 : lastStopTime.hashCode());
    result = prime * result + ((vmPid == null) ? 0 : vmPid.hashCode());
    result = prime * result + (lastWatchdogEvent == null ? 0 : lastWatchdogEvent.hashCode());
    result = prime * result + (lastWatchdogAction == null ? 0 : lastWatchdogAction.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + (cpuName == null ? 0 : cpuName.hashCode());
    result = prime * result + (currentCd == null ? 0 : currentCd.hashCode());
    result = prime * result + (stopReason == null ? 0 : stopReason.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(reason, other.reason));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(acpiEnabled, other.acpiEnabled) && ObjectUtils.objectsEqual(appList, other.appList) && bootSequence == other.bootSequence && ObjectUtils.objectsEqual(clientIp, other.clientIp) && ObjectUtils.objectsEqual(display, other.display) && ObjectUtils.objectsEqual(displayIp, other.displayIp) && ObjectUtils.objectsEqual(displaySecurePort, other.displaySecurePort) && displayType == other.displayType && ObjectUtils.objectsEqual(vncKeyboardLayout, other.vncKeyboardLayout) && ObjectUtils.objectsEqual(consoleCurrentUserName, other.consoleCurrentUserName) && ObjectUtils.objectsEqual(guestCurUserName, other.guestCurUserName) && ObjectUtils.objectsEqual(consoleUserId, other.consoleUserId) && ObjectUtils.objectsEqual(guestLastLoginTime, other.guestLastLoginTime) && ObjectUtils.objectsEqual(guestLastLogoutTime, other.guestLastLogoutTime) && ObjectUtils.objectsEqual(guestOs, other.guestOs) && ObjectUtils.objectsEqual(guestRequestedMemory, other.guestRequestedMemory) && ObjectUtils.objectsEqual(hibernationVolHandle, other.hibernationVolHandle) && ObjectUtils.objectsEqual(kvmEnable, other.kvmEnable) && ObjectUtils.objectsEqual(lastVdsRunOn, other.lastVdsRunOn) && ObjectUtils.objectsEqual(disks, other.disks) && ObjectUtils.objectsEqual(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && ObjectUtils.objectsEqual(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && ObjectUtils.objectsEqual(runOnVds, other.runOnVds) && session == other.session && status == other.status && ObjectUtils.objectsEqual(utcDiff, other.utcDiff) && ObjectUtils.objectsEqual(vmHost, other.vmHost) && ObjectUtils.objectsEqual(vmIp, other.vmIp) && ObjectUtils.objectsEqual(vmFQDN, other.vmFQDN) && ObjectUtils.objectsEqual(lastStartTime, other.lastStartTime) && ObjectUtils.objectsEqual(lastStopTime, other.lastStopTime) && ObjectUtils.objectsEqual(vmPid, other.vmPid) && ObjectUtils.objectsEqual(lastWatchdogEvent, other.lastWatchdogEvent) && ObjectUtils.objectsEqual(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && ObjectUtils.objectsEqual(cpuName, other.cpuName) && ObjectUtils.objectsEqual(currentCd, other.currentCd) && ObjectUtils.objectsEqual(stopReason, other.stopReason));
}
#end_block

#method_before
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void newVm() {
    if (getWindow() != null) {
        return;
    }
    UnitVmModel model = new UnitVmModel(new NewVmModelBehavior());
    model.setTitle(ConstantsManager.getInstance().getConstants().newVmTitle());
    model.setHelpTag(HelpTag.new_vm);
    // $NON-NLS-1$
    model.setHashName("new_vm");
    model.setIsNew(true);
    model.getVmType().setSelectedItem(VmType.Server);
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.initialize(getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    model.getProvisioning().setEntity(true);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void vmInitLoaded(VM vm) {
    UnitVmModel model = new UnitVmModel(new ExistingVmModelBehavior(vm));
    model.getVmType().setSelectedItem(vm.getVmType());
    model.setVmAttachedToPool(vm.getVmPoolId() != null);
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey("wa_vm_dialog");
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editVmTitle());
    model.setHelpTag(HelpTag.edit_vm);
    // $NON-NLS-1$
    model.setHashName("edit_vm");
    model.setCustomPropertiesKeysList(getCustomPropertiesKeysList());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void powerAction(String actionName, String title, String message, ConfirmationModel model) {
    setWindow(model);
    model.setTitle(title);
    if (actionName.equals(SHUTDOWN)) {
        model.setHelpTag(HelpTag.shutdown_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("shutdown_virtual_machine");
    } else if (actionName.equals(STOP)) {
        model.setHelpTag(HelpTag.stop_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("stop_virtual_machine");
    } else if (actionName.equals(REBOOT)) {
        model.setHelpTag(HelpTag.reboot_virtual_machine);
        // $NON-NLS-1$
        model.setHashName("reboot_virtual_machine");
    }
    model.setMessage(message);
    // model.Items = SelectedItems.Cast<VM>().Select(a => a.vm_name);
    ArrayList<String> items = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        items.add(a.getName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("On" + actionName, this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void powerAction(final String actionName, final String title, final String message) {
    Guid clusterId = getClusterIdOfSelectedVms();
    if (clusterId == null) {
        powerAction(actionName, title, message, false);
    } else {
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null) {
                    powerAction(actionName, title, message, cluster.isOptionalReasonRequired());
                }
            }
        }), clusterId);
    }
}
#end_block

#method_before
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg(), new ConfirmationWithReasonModel());
}
#method_after
private void shutdown() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(SHUTDOWN, constants.shutdownVirtualMachinesTitle(), constants.areYouSureYouWantToShutDownTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void onShutdown() {
    final ConfirmationWithReasonModel model = (ConfirmationWithReasonModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity());
        }
    });
}
#method_after
private void onShutdown() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.ShutdownVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new ShutdownVmParameters(vm.getId(), true, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg(), new ConfirmationWithReasonModel());
}
#method_after
private void stop() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(STOP, constants.stopVirtualMachinesTitle(), constants.areYouSureYouWantToStopTheFollowingVirtualMachinesMsg());
}
#end_block

#method_before
private void onStop() {
    final ConfirmationWithReasonModel model = (ConfirmationWithReasonModel) getWindow();
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity());
        }
    });
}
#method_after
private void onStop() {
    final ConfirmationModel model = (ConfirmationModel) getWindow();
    onPowerAction(VdcActionType.StopVm, new PowerActionParametersFactory<VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase createActionParameters(VM vm) {
            return new StopVmParameters(vm.getId(), StopVmTypeEnum.NORMAL, model.getReason().getEntity());
        }
    });
}
#end_block

#method_before
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg(), new ConfirmationModel());
}
#method_after
private void reboot() {
    UIConstants constants = ConstantsManager.getInstance().getConstants();
    powerAction(REBOOT, constants.rebootVirtualMachinesTitle(), constants.areYouSureYouWantToRebootTheFollowingVirtualMachinesMsg(), false);
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                // do nothing
                }

                @Override
                public void queryFailed() {
                // do nothing
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    getWindow().stopProgress();
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        setWindow(null);
                        setGuideContext(returnValue.getActionReturnValue());
                        updateActionAvailability();
                        getGuideCommand().execute();
                    } else {
                        cancel();
                    }
                    super.executed(result);
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
@Override
protected void perform() {
    log.infoFormat("Entered (VM {0}).", getVm().getName());
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (canShutdownVm()) {
        // shutting down desktop and waiting for it in a separate thread to
        // become 'down':
        log.infoFormat("Sending shutdown command for VM {0}.", getVmName());
        int secondsToWait = getParameters().getWaitBeforeShutdown() ? Config.<Integer>getValue(ConfigValues.VmGracefulShutdownTimeout) : 0;
        // sending a shutdown command to the VM:
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), getParameters().getReason(), false, true, secondsToWait)).getReturnValue());
    } else {
        // cannot shutdown -> send a StopVm command instead ('destroy'):
        // don't log -> log will appear for the StopVmCommand we are about to run:
        setCommandShouldBeLogged(false);
        log.infoFormat("Cannot shutdown VM {0}, status is not up. Stopping instead.", getVmName());
        StopVmParameters stopVmParams = new StopVmParameters(getVmId(), StopVmTypeEnum.CANNOT_SHUTDOWN);
        // stopVmParams.ParametersCurrentUser = CurrentUser;
        stopVmParams.setSessionId(getParameters().getSessionId());
        Backend.getInstance().runInternalAction(VdcActionType.StopVm, stopVmParams);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    log.infoFormat("Entered (VM {0}).", getVm().getName());
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (canShutdownVm()) {
        // shutting down desktop and waiting for it in a separate thread to
        // become 'down':
        log.infoFormat("Sending shutdown command for VM {0}.", getVmName());
        int secondsToWait = getParameters().getWaitBeforeShutdown() ? Config.<Integer>getValue(ConfigValues.VmGracefulShutdownTimeout) : 0;
        // sending a shutdown command to the VM:
        setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), getParameters().getStopReason(), false, true, secondsToWait)).getReturnValue());
    } else {
        // cannot shutdown -> send a StopVm command instead ('destroy'):
        // don't log -> log will appear for the StopVmCommand we are about to run:
        setCommandShouldBeLogged(false);
        log.infoFormat("Cannot shutdown VM {0}, status is not up. Stopping instead.", getVmName());
        StopVmParameters stopVmParams = new StopVmParameters(getVmId(), StopVmTypeEnum.CANNOT_SHUTDOWN);
        // stopVmParams.ParametersCurrentUser = CurrentUser;
        stopVmParams.setSessionId(getParameters().getSessionId());
        Backend.getInstance().runInternalAction(VdcActionType.StopVm, stopVmParams);
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager != null) {
        final DestroyVmVDSCommandParameters parameters = getParameters();
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        final VM curVm = DbFacade.getInstance().getVmDao().get(parameters.getVmId());
        curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(curVm.getId()));
        DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
        vdsBrokerCommand.execute();
        if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
            if (curVm.getStatus() == VMStatus.Down) {
                getVDSReturnValue().setReturnValue(VMStatus.Down);
            }
            changeStatus(parameters, curVm);
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    curVm.guestLogoutTimeTreatmentAfterDestroy();
                    curVm.setReason(getParameters().getReason());
                    // SaveVmDynamicToDBThreaded(curVm);
                    DbFacade.getInstance().getVmDynamicDao().update(curVm.getDynamicData());
                    DbFacade.getInstance().getVmStatisticsDao().update(curVm.getStatisticsData());
                    List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                    if (interfaces != null && interfaces.size() > 0) {
                        for (VmNetworkInterface ifc : interfaces) {
                            VmNetworkStatistics stats = ifc.getStatistics();
                            DbFacade.getInstance().getVmNetworkStatisticsDao().update(stats);
                        }
                    }
                    DbFacade.getInstance().getVdsDynamicDao().updatePartialVdsDynamicCalc(getVdsId(), 0, 0, 0, -curVm.getVmMemSizeMb(), -curVm.getNumOfCpus());
                    return null;
                }
            });
            // will not be called from UpdateRunTimeInfo
            if (!parameters.getGracefully()) {
                onVmStop(curVm);
            }
            getVDSReturnValue().setReturnValue(curVm.getStatus());
        } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
            log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} : {2}, error = {3}", parameters.getVmId(), getVds().getId(), getVds().getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
            getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
        }
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#method_after
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager != null) {
        final DestroyVmVDSCommandParameters parameters = getParameters();
        ResourceManager.getInstance().RemoveAsyncRunningVm(parameters.getVmId());
        final VM curVm = DbFacade.getInstance().getVmDao().get(parameters.getVmId());
        curVm.setInterfaces(DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(curVm.getId()));
        DestroyVDSCommand<DestroyVmVDSCommandParameters> vdsBrokerCommand = new DestroyVDSCommand<DestroyVmVDSCommandParameters>(parameters);
        vdsBrokerCommand.execute();
        if (vdsBrokerCommand.getVDSReturnValue().getSucceeded()) {
            if (curVm.getStatus() == VMStatus.Down) {
                getVDSReturnValue().setReturnValue(VMStatus.Down);
            }
            changeStatus(parameters, curVm);
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    curVm.guestLogoutTimeTreatmentAfterDestroy();
                    curVm.setStopReason(getParameters().getReason());
                    // SaveVmDynamicToDBThreaded(curVm);
                    DbFacade.getInstance().getVmDynamicDao().update(curVm.getDynamicData());
                    DbFacade.getInstance().getVmStatisticsDao().update(curVm.getStatisticsData());
                    List<VmNetworkInterface> interfaces = curVm.getInterfaces();
                    if (interfaces != null && interfaces.size() > 0) {
                        for (VmNetworkInterface ifc : interfaces) {
                            VmNetworkStatistics stats = ifc.getStatistics();
                            DbFacade.getInstance().getVmNetworkStatisticsDao().update(stats);
                        }
                    }
                    DbFacade.getInstance().getVdsDynamicDao().updatePartialVdsDynamicCalc(getVdsId(), 0, 0, 0, -curVm.getVmMemSizeMb(), -curVm.getNumOfCpus());
                    return null;
                }
            });
            // will not be called from UpdateRunTimeInfo
            if (!parameters.getGracefully()) {
                onVmStop(curVm);
            }
            getVDSReturnValue().setReturnValue(curVm.getStatus());
        } else if (vdsBrokerCommand.getVDSReturnValue().getExceptionObject() != null) {
            log.errorFormat("VDS::destroy Failed destroying vm '{0}' in vds = {1} : {2}, error = {3}", parameters.getVmId(), getVds().getId(), getVds().getName(), vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setSucceeded(false);
            getVDSReturnValue().setExceptionString(vdsBrokerCommand.getVDSReturnValue().getExceptionString());
            getVDSReturnValue().setExceptionObject(vdsBrokerCommand.getVDSReturnValue().getExceptionObject());
            getVDSReturnValue().setVdsError(vdsBrokerCommand.getVDSReturnValue().getVdsError());
        }
    } else {
        getVDSReturnValue().setSucceeded(false);
    }
}
#end_block

#method_before
@Override
public ImageResource getValue(T value) {
    setTitle(value.getReason());
    if (value.getReason() != null && !value.getReason().isEmpty()) {
        return getApplicationResources().commentImage();
    }
    return null;
}
#method_after
@Override
public ImageResource getValue(T value) {
    setTitle(value.getStopReason());
    if (value.getStopReason() != null && !value.getStopReason().trim().isEmpty()) {
        return getApplicationResources().commentImage();
    }
    return null;
}
#end_block

#method_before
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(reasonColumn, reasonColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#method_after
void initTable(ApplicationResources resources, ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VmStatusColumn<VM>(), constants.empty(), "30px");
    // $NON-NLS-1$
    getTable().addColumn(new VmTypeColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<VM> nameColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.nameVm(), "120px");
    CommentColumn<VM> commentColumn = new CommentColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(commentColumn, commentColumn.getHeaderHtml(), "30px");
    ReasonColumn<VM> reasonColumn = new ReasonColumn<VM>();
    // $NON-NLS-1$
    getTable().addColumnWithHtmlHeader(reasonColumn, reasonColumn.getHeaderHtml(), "30px");
    TextColumnWithTooltip<VM> hostColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getRunOnVdsName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(hostColumn, constants.hostVm(), "120px");
    TextColumnWithTooltip<VM> ipColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmIp();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(ipColumn, constants.ipVm(), "120px");
    TextColumnWithTooltip<VM> fqdnColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVmFQDN();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fqdnColumn, constants.fqdn(), "120px");
    TextColumnWithTooltip<VM> clusterColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVm(), "120px");
    TextColumnWithTooltip<VM> dcColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getStoragePoolName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(dcColumn, constants.dcVm(), "120px");
    PercentColumn<VM> memoryColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageMemPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(memoryColumn, constants.memoryVm(), "60px");
    PercentColumn<VM> cpuColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageCpuPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(cpuColumn, constants.cpuVm(), "60px");
    PercentColumn<VM> networkColumn = new PercentColumn<VM>() {

        @Override
        public Integer getProgressValue(VM object) {
            return object.getUsageNetworkPercent();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(networkColumn, constants.networkVm(), "60px");
    TextColumnWithTooltip<VM> displayColumn = new EnumColumn<VM, DisplayType>() {

        @Override
        protected DisplayType getRawValue(VM object) {
            return object.getDisplayType();
        }

        @Override
        public String getValue(VM object) {
            if ((object.getStatus() == VMStatus.Down) || (object.getStatus() == VMStatus.ImageLocked))
                // $NON-NLS-1$
                return "";
            else
                return renderer.render(getRawValue(object));
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(displayColumn, constants.displayVm(), "80px");
    TextColumnWithTooltip<VM> statusColumn = new EnumColumn<VM, VMStatus>() {

        @Override
        public VMStatus getRawValue(VM object) {
            switch(object.getStatus()) {
                case PreparingForHibernate:
                    return VMStatus.SavingState;
                default:
                    return object.getStatus();
            }
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVm(), "80px");
    TextColumnWithTooltip<VM> uptimeColumn = new UptimeColumn<VM>() {

        @Override
        public Double getRawValue(VM object) {
            return object.getRoundedElapsedTime();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(uptimeColumn, constants.uptimeVm(), "120px");
    TextColumnWithTooltip<VM> descriptionColumn = new TextColumnWithTooltip<VM>() {

        @Override
        public String getValue(VM object) {
            return object.getDescription();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(descriptionColumn, constants.description(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.newVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVmCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.editVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.removeVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.runOnceVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunOnceCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.runVm(), resources.runVmImage(), resources.runVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRunCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.suspendVm(), resources.suspendVmImage(), resources.suspendVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getPauseCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.shutDownVm(), resources.stopVmImage(), resources.stopVmDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getShutdownCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.powerOffVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.rebootVm(), resources.rebootImage(), resources.rebootDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebootCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.consoleVm(), resources.consoleImage(), resources.consoleDisabledImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getConsoleConnectCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(commonConstants.consoleOptions(), // $NON-NLS-1$
    CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEditConsoleCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.migrateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cancelMigrationVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCancelMigrateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.makeTemplateVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewTemplateCommand();
        }
    });
    // TODO: separator
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.exportVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getExportCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.createSnapshotVM()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateSnapshotCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.cheangeCdVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getChangeCdCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.assignTagsVm()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getAssignTagsCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.enableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getEnableGlobalHaMaintenanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<VM>(constants.disableGlobalHaMaintenanceVm(), CommandLocation.OnlyFromContext) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getDisableGlobalHaMaintenanceCommand();
        }
    });
    if (ReportInit.getInstance().isReportsEnabled()) {
        List<ActionButtonDefinition<VM>> resourceSubActions = // $NON-NLS-1$
        ReportActionsHelper.getInstance().getResourceSubActions("VM", getModelProvider());
        if (resourceSubActions != null && resourceSubActions.size() > 0) {
            getTable().addActionButton(new WebAdminMenuBarButtonDefinition<VM>(constants.showReportVm(), resourceSubActions));
        }
    }
    getTable().addActionButton(new WebAdminImageButtonDefinition<VM>(constants.guideMeVm(), resources.guideSmallImage(), resources.guideSmallDisabledImage(), true) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getGuideCommand();
        }
    });
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getReason() != null) {
        model.setReason(entity.getReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getStopReason() != null) {
        model.setStopReason(entity.getStopReason());
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHostName()) {
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        List<VmInitNetwork> networks = new ArrayList<VmInitNetwork>();
        for (GuestNicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    return entity;
}
#method_after
@Mapping(from = Initialization.class, to = VmInit.class)
public static VmInit map(Initialization model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHostName()) {
        entity.setHostname(model.getHostName());
    }
    if (model.isSetDomain()) {
        entity.setDomain(model.getDomain());
    }
    if (model.isSetTimezone()) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetAuthorizedSshKeys()) {
        entity.setAuthorizedKeys(model.getAuthorizedSshKeys());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetDnsServers()) {
        entity.setDnsServers(model.getDnsServers());
    }
    if (model.isSetDnsSearch()) {
        entity.setDnsSearch(model.getDnsSearch());
    }
    if (model.isSetWindowsLicenseKey()) {
        entity.setWinKey(model.getWindowsLicenseKey());
    }
    if (model.isSetRootPassword()) {
        entity.setRootPassword(model.getRootPassword());
    }
    if (model.isSetCustomScript()) {
        entity.setCustomScript(model.getCustomScript());
    }
    if (model.isSetNicConfigurations()) {
        List<VmInitNetwork> networks = new ArrayList<VmInitNetwork>();
        for (GuestNicConfiguration nic : model.getNicConfigurations().getNicConfigurations()) {
            networks.add(map(nic, null));
        }
        entity.setNetworks(networks);
    }
    if (model.isSetInputLocale()) {
        entity.setInputLocale(model.getInputLocale());
    }
    if (model.isSetUiLanguage()) {
        entity.setUiLanguage(model.getUiLanguage());
    }
    if (model.isSetSystemLocale()) {
        entity.setSystemLocale(model.getSystemLocale());
    }
    if (model.isSetUserLocale()) {
        entity.setUserLocale(model.getUserLocale());
    }
    if (model.isSetUserName()) {
        entity.setUserName(model.getUserName());
    }
    if (model.isSetActiveDirectoryOu()) {
        entity.setUserName(model.getActiveDirectoryOu());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = VmInit.class, to = Initialization.class)
public static Initialization map(VmInit entity, Initialization template) {
    Initialization model = template != null ? template : new Initialization();
    if (entity.getHostname() != null) {
        model.setHostName(entity.getHostname());
    }
    if (entity.getDomain() != null) {
        model.setDomain(entity.getDomain());
    }
    if (entity.getTimeZone() != null) {
        model.setTimezone(entity.getTimeZone());
    }
    if (entity.getAuthorizedKeys() != null) {
        model.setAuthorizedSshKeys(entity.getAuthorizedKeys());
    }
    if (entity.getRegenerateKeys() != null) {
        model.setRegenerateSshKeys(entity.getRegenerateKeys());
    }
    if (entity.getDnsServers() != null) {
        model.setDnsServers(entity.getDnsServers());
    }
    if (entity.getDnsSearch() != null) {
        model.setDnsSearch(entity.getDnsSearch());
    }
    if (entity.getWinKey() != null) {
        model.setWindowsLicenseKey(entity.getWinKey());
    }
    if (entity.getRootPassword() != null) {
        model.setRootPassword("******");
    }
    if (entity.getCustomScript() != null) {
        model.setCustomScript(entity.getCustomScript());
    }
    if (entity.getNetworks() != null) {
        model.setNicConfigurations(new GuestNicsConfiguration());
        for (VmInitNetwork network : entity.getNetworks()) {
            model.getNicConfigurations().getNicConfigurations().add(map(network, null));
        }
    }
    return model;
}
#method_after
@Mapping(from = VmInit.class, to = Initialization.class)
public static Initialization map(VmInit entity, Initialization template) {
    Initialization model = template != null ? template : new Initialization();
    if (entity.getHostname() != null) {
        model.setHostName(entity.getHostname());
    }
    if (entity.getDomain() != null) {
        model.setDomain(entity.getDomain());
    }
    if (entity.getTimeZone() != null) {
        model.setTimezone(entity.getTimeZone());
    }
    if (entity.getAuthorizedKeys() != null) {
        model.setAuthorizedSshKeys(entity.getAuthorizedKeys());
    }
    if (entity.getRegenerateKeys() != null) {
        model.setRegenerateSshKeys(entity.getRegenerateKeys());
    }
    if (entity.getDnsServers() != null) {
        model.setDnsServers(entity.getDnsServers());
    }
    if (entity.getDnsSearch() != null) {
        model.setDnsSearch(entity.getDnsSearch());
    }
    if (entity.getWinKey() != null) {
        model.setWindowsLicenseKey(entity.getWinKey());
    }
    if (entity.getRootPassword() != null) {
        model.setRootPassword("******");
    }
    if (entity.getCustomScript() != null) {
        model.setCustomScript(entity.getCustomScript());
    }
    if (entity.getNetworks() != null) {
        model.setNicConfigurations(new GuestNicsConfiguration());
        for (VmInitNetwork network : entity.getNetworks()) {
            model.getNicConfigurations().getNicConfigurations().add(map(network, null));
        }
    }
    if (entity.getInputLocale() != null) {
        model.setInputLocale(entity.getInputLocale());
    }
    if (entity.getUiLanguage() != null) {
        model.setUiLanguage(entity.getUiLanguage());
    }
    if (entity.getSystemLocale() != null) {
        model.setSystemLocale(entity.getSystemLocale());
    }
    if (entity.getUserLocale() != null) {
        model.setUserLocale(entity.getUserLocale());
    }
    if (entity.getUserName() != null) {
        model.setUserName(entity.getUserName());
    }
    if (entity.getActiveDirectoryOU() != null) {
        model.setActiveDirectoryOu(entity.getActiveDirectoryOU());
    }
    return model;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGuestSessions(vm, sessions);
    return sessions;
}
#end_block

#method_before
protected void destroyVm() {
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(getVm().getMigratingToVds().toString()), getVmId(), getParameters().getReason(), true, false, 0));
    }
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), getParameters().getReason(), false, false, 0)).getReturnValue());
}
#method_after
protected void destroyVm() {
    boolean wasPaused = (getVm().getStatus() == VMStatus.Paused && getVm().getVmPauseStatus() == VmPauseStatus.NOERR);
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(getVm().getMigratingToVds().toString()), getVmId(), getParameters().getStopReason(), true, false, 0));
    }
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), getParameters().getStopReason(), false, false, 0)).getReturnValue());
    if (wasPaused) {
        VmHandler.decreasePendingVms(getVm(), getVdsId());
    }
}
#end_block

#method_before
@Override
@Size(min = 1, max = BusinessEntitiesDefinitions.VM_NAME_SIZE, groups = { Default.class, ImportClonedEntity.class })
@ValidI18NName(message = "ACTION_TYPE_FAILED_NAME_MAY_NOT_CONTAIN_SPECIAL_CHARS", groups = { CreateVm.class, UpdateVm.class, CreateVmTemplate.class, UpdateVmTemplate.class, ImportClonedEntity.class })
public String getName() {
    return super.getName();
}
#method_after
@Override
@Size(min = 1, max = BusinessEntitiesDefinitions.VM_NAME_SIZE, groups = { Default.class, ImportClonedEntity.class })
@ValidI18NName(message = "ACTION_TYPE_FAILED_NAME_MAY_NOT_CONTAIN_SPECIAL_CHARS", groups = { CreateVm.class, UpdateVm.class, ImportClonedEntity.class })
public String getName() {
    return super.getName();
}
#end_block

#method_before
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<String, Object>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    Version clusterVersion = getParameters().getVm().getVdsGroupCompatibilityVersion();
    map.put(VdsProperties.Type, vmDevice.getType().getValue());
    map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
    map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
    if (FeatureSupported.networkLinking(clusterVersion)) {
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    }
    addAddress(map, vmDevice.getAddress());
    map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    VmInterfaceType ifaceType = VmInterfaceType.forValue(nic.getType());
    if (ifaceType == VmInterfaceType.rtl8139_pv) {
        if (getParameters().getVm().getHasAgent()) {
            map.put(VdsProperties.NIC_TYPE, VmInterfaceType.pv.name());
        } else {
            map.put(VdsProperties.NIC_TYPE, VmInterfaceType.rtl8139.name());
        }
    } else {
        map.put(VdsProperties.NIC_TYPE, ifaceType.getInternalName());
    }
    map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (vmDevice.getBootOrder() > 0) {
        map.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
    }
    VmInfoBuilder.addProfileDataToNic(map, getParameters().getVm(), vmDevice, nic);
    VmInfoBuilder.addNetworkFiltersToNic(map, clusterVersion);
    return map;
}
#method_after
private Map<String, Object> initNicStructure() {
    Map<String, Object> map = new HashMap<String, Object>();
    VmNic nic = getParameters().getNic();
    VmDevice vmDevice = getParameters().getVmDevice();
    Version clusterVersion = getParameters().getVm().getVdsGroupCompatibilityVersion();
    map.put(VdsProperties.Type, vmDevice.getType().getValue());
    map.put(VdsProperties.Device, VmDeviceType.BRIDGE.getName());
    map.put(VdsProperties.MAC_ADDR, nic.getMacAddress());
    if (FeatureSupported.networkLinking(clusterVersion)) {
        map.put(VdsProperties.LINK_ACTIVE, String.valueOf(nic.isLinked()));
    }
    addAddress(map, vmDevice.getAddress());
    map.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    map.put(VdsProperties.NIC_TYPE, VmInfoBuilder.evaluateInterfaceType(VmInterfaceType.forValue(nic.getType()), getParameters().getVm().getHasAgent()));
    map.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    if (vmDevice.getBootOrder() > 0) {
        map.put(VdsProperties.BootOrder, String.valueOf(vmDevice.getBootOrder()));
    }
    VmInfoBuilder.addProfileDataToNic(map, getParameters().getVm(), vmDevice, nic);
    VmInfoBuilder.addNetworkFiltersToNic(map, clusterVersion);
    return map;
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName() + "@" + entity.getDomain());
    model.setId(DirectoryEntryIdUtils.generateId(entity.getId().toString(), entity.getDomain(), entity.getExternalId()));
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName() + "@" + entity.getDomain());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    model.setDomainEntryId(DatatypeConverter.printHexBinary(entity.getExternalId().getBytes(Charset.forName("UTF-8"))));
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = DirectoryUser.class, to = User.class)
public static User map(DirectoryUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setUserName(entity.getName() + "@" + entity.getDirectoryName());
    model.setId(DirectoryEntryIdUtils.generateId("", entity.getDirectoryName(), entity.getId()));
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (DirectoryGroup directoryGroup : entity.getGroups()) {
            Group group = new Group();
            group.setName(directoryGroup.getName());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDirectoryName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectoryName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DirectoryUser.class, to = User.class)
public static User map(DirectoryUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setUserName(entity.getName() + "@" + entity.getDirectoryName());
    model.setId(DatatypeConverter.printHexBinary(entity.getId().getBytes(Charset.forName("UTF-8"))));
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (DirectoryGroup directoryGroup : entity.getGroups()) {
            Group group = new Group();
            group.setName(directoryGroup.getName());
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDirectoryName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectoryName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = User.class, to = DbUser.class)
public static DbUser map(User model, DbUser template) {
    DbUser entity = template != null ? template : new DbUser();
    if (model.isSetName()) {
        entity.setLoginName(model.getName());
    }
    if (model.isSetId()) {
        String id = model.getId();
        try {
            String internalId = DirectoryEntryIdUtils.getInternalId(id);
            String providerId = DirectoryEntryIdUtils.getProviderId(id);
            String externalId = DirectoryEntryIdUtils.getIdInDirectory(providerId);
            if (internalId.isEmpty()) {
                entity.setId(Guid.newGuid());
            } else {
                entity.setId(GuidUtils.asGuid(internalId));
            }
            entity.setExternalId(externalId);
        } catch (MalformedIdException exception) {
        // The identifier won't be a UUID if the user comes from /domains/{domain:id}/users.
        }
    }
    if (model.isSetDomain()) {
        Domain domain = model.getDomain();
        if (domain.isSetName()) {
            entity.setDomain(domain.getName());
        }
    }
    return entity;
}
#method_after
@Mapping(from = User.class, to = DbUser.class)
public static DbUser map(User model, DbUser template) {
    DbUser entity = template != null ? template : new DbUser();
    if (model.isSetName()) {
        entity.setLoginName(model.getName());
    }
    if (model.isSetId()) {
        String id = model.getId();
        entity.setId(GuidUtils.asGuid(id));
    }
    if (model.isSetDomain()) {
        Domain domain = model.getDomain();
        if (domain.isSetName()) {
            entity.setDomain(domain.getName());
        }
    }
    if (model.isSetDomainEntryId()) {
        entity.setExternalId(new String(DatatypeConverter.parseHexBinary(model.getDomainEntryId()), Charset.forName("UTF-8")));
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(DirectoryEntryIdUtils.generateId(entity.getId().toString(), entity.getDomain(), entity.getExternalId()));
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbGroup.class, to = Group.class)
public static Group map(DbGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(entity.getId().toString());
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    model.setDomainEntryId(DatatypeConverter.printHexBinary(entity.getExternalId().getBytes(Charset.forName("UTF-8"))));
    return model;
}
#end_block

#method_before
@Mapping(from = DirectoryGroup.class, to = Group.class)
public static Group map(DirectoryGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    model.setId(DirectoryEntryIdUtils.generateId("", entity.getDirectoryName(), entity.getId()));
    if (!StringUtils.isEmpty(entity.getDirectoryName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectoryName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DirectoryGroup.class, to = Group.class)
public static Group map(DirectoryGroup entity, Group template) {
    Group model = template != null ? template : new Group();
    model.setName(entity.getName());
    if (!StringUtils.isEmpty(entity.getDirectoryName())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDirectoryName().getBytes(), true).toString());
        model.setDomain(dom);
    }
    model.setId(DatatypeConverter.printHexBinary(entity.getId().getBytes(Charset.forName("UTF-8"))));
    return model;
}
#end_block

#method_before
@Mapping(from = Group.class, to = DbGroup.class)
public static DbGroup map(Group model, DbGroup template) {
    DbGroup entity = template != null ? template : new DbGroup();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        String id = model.getId();
        try {
            String internalId = DirectoryEntryIdUtils.getInternalId(id);
            String providerId = DirectoryEntryIdUtils.getProviderId(id);
            String externalId = DirectoryEntryIdUtils.getIdInDirectory(providerId);
            if (internalId.isEmpty()) {
                entity.setId(Guid.newGuid());
            } else {
                entity.setId(GuidUtils.asGuid(internalId));
            }
            entity.setExternalId(externalId);
        } catch (MalformedIdException exception) {
        // The identifier won't be a UUID if the group comes from /domains/{domain:id}/groups.
        }
    }
    if (model.isSetDomain()) {
        Domain domain = model.getDomain();
        if (domain.isSetName()) {
            entity.setDomain(domain.getName());
        }
    }
    return entity;
}
#method_after
@Mapping(from = Group.class, to = DbGroup.class)
public static DbGroup map(Group model, DbGroup template) {
    DbGroup entity = template != null ? template : new DbGroup();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        String id = model.getId();
        entity.setId(GuidUtils.asGuid(id));
    }
    if (model.isSetDomain()) {
        Domain domain = model.getDomain();
        if (domain.isSetName()) {
            entity.setDomain(domain.getName());
        }
    }
    if (model.isSetDomainEntryId()) {
        entity.setExternalId(new String(DatatypeConverter.parseHexBinary(model.getDomainEntryId()), Charset.forName("UTF-8")));
    }
    return entity;
}
#end_block

#method_before
protected boolean checkDomainCanBeAttached(StorageDomain storageDomain) {
    if (!validateAmountOfIsoAndExportDomainsInDC(storageDomain)) {
        return false;
    }
    if (!isStorageDomainFormatCorrectForDC(storageDomain, getStoragePool())) {
        return false;
    }
    if (!checkStorageDomainSharedStatusNotLocked(storageDomain)) {
        return false;
    }
    if (!(isStorageDomainOfTypeIsoOrExport(storageDomain) || isStorageDomainNotInPool(storageDomain))) {
        return false;
    }
    if (!isStorageDomainTypeCorrect(storageDomain)) {
        return false;
    }
    if (!isStorageDomainCompatibleWithDC(storageDomain)) {
        return false;
    }
    if (!isMixedTypesAllowedInDC() && isMixedTypeDC(storageDomain)) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkDomainCanBeAttached(StorageDomain storageDomain) {
    if (!validateAmountOfIsoAndExportDomainsInDC(storageDomain)) {
        return false;
    }
    if (!isStorageDomainFormatCorrectForDC(storageDomain, getStoragePool())) {
        return false;
    }
    if (!checkStorageDomainSharedStatusNotLocked(storageDomain)) {
        return false;
    }
    if (!(isStorageDomainOfTypeIsoOrExport(storageDomain) || isStorageDomainNotInPool(storageDomain))) {
        return false;
    }
    if (!isStorageDomainTypeCorrect(storageDomain)) {
        return false;
    }
    if (!isStorageDomainCompatibleWithDC(storageDomain)) {
        return false;
    }
    if (!isMixedTypesAllowedInDC(getStoragePool().getcompatibility_version()) && isMixedTypeDC(storageDomain)) {
        return false;
    }
    return true;
}
#end_block

#method_before
// TODO: Should be removed when 3.0 compatibility will not be supported, for now we are blocking the possibility
// to mix NFS domains with block domains on 3.0 pools since block domains on 3.0 pools can be in V2 format while NFS
protected boolean isMixedTypesAllowedInDC() {
    return getStoragePool().getcompatibility_version().compareTo(Version.v3_3) > 0;
}
#method_after
// TODO: Should be removed when 3.0 compatibility will not be supported, for now we are blocking the possibility
// to mix NFS domains with block domains on 3.0 pools since block domains on 3.0 pools can be in V2 format while NFS
protected boolean isMixedTypesAllowedInDC(Version version) {
    return FeatureSupported.mixedDomainTypesOnDataCenter(version);
}
#end_block

#method_before
@Override
public VM getVmDataFromPoolByPoolName(String vmPoolNam, Guid userID, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("pool_name", vmPoolNam).addValue("user_id", userID).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeRead("GetVmDataFromPoolByPoolName", VMRowMapper.instance, parameterSource);
}
#method_after
@Override
public VM getVmDataFromPoolByPoolName(String vmPoolName, Guid userId, boolean isFiltered) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("pool_name", vmPoolName).addValue("user_id", userId).addValue("is_filtered", isFiltered);
    return getCallsHandler().executeRead("GetVmDataFromPoolByPoolName", VMRowMapper.instance, parameterSource);
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            TaskListModel taskListModel = (TaskListModel) model;
            ArrayList<Job> taskList = (ArrayList<Job>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            if (taskList.size() == 0) {
                detailedTaskMap.clear();
            }
            ArrayList<Job> taskListWithCorrelationFilter = new ArrayList<Job>();
            Map<String, Map.Entry<Job, ArrayList<Job>>> correlationTaskMap = new HashMap<String, Map.Entry<Job, ArrayList<Job>>>();
            for (Job task : taskList) {
                if (task.getCorrelationId().startsWith(_WEBADMIN_)) {
                    if (!correlationTaskMap.containsKey(task.getCorrelationId())) {
                        Job rootTask = new Job();
                        rootTask.setCorrelationId(task.getCorrelationId());
                        Map.Entry<Job, ArrayList<Job>> entry = new TaskEntry(rootTask);
                        entry.setValue(new ArrayList<Job>());
                        correlationTaskMap.put(rootTask.getCorrelationId(), entry);
                        String[] taskDescreptionArray = // $NON-NLS-1$ //$NON-NLS-2$
                        rootTask.getCorrelationId().replace(_WEBADMIN_, "").split("_");
                        StringBuilder taskDesc = new StringBuilder();
                        for (int i = 1; i < taskDescreptionArray.length; i++) {
                            // $NON-NLS-1$
                            taskDesc.append(taskDescreptionArray[i]).append(" ");
                        }
                        rootTask.setId(task.getId());
                        rootTask.setDescription(taskDesc.toString());
                        taskListWithCorrelationFilter.add(rootTask);
                    }
                    Map.Entry<Job, ArrayList<Job>> entry = correlationTaskMap.get(task.getCorrelationId());
                    entry.getValue().add(task);
                } else {
                    taskListWithCorrelationFilter.add(task);
                }
            }
            for (Map.Entry<Job, ArrayList<Job>> entry : correlationTaskMap.values()) {
                entry.getKey().setStatus(JobExecutionStatus.UNKNOWN);
                boolean hasFailedStatus = false;
                boolean hasStartedStatus = false;
                boolean hasAbortedStatus = false;
                int finishedCount = 0;
                for (Job task : entry.getValue()) {
                    switch(task.getStatus()) {
                        case STARTED:
                            hasStartedStatus = true;
                            break;
                        case FINISHED:
                            finishedCount++;
                            break;
                        case FAILED:
                            hasFailedStatus = true;
                            break;
                        case ABORTED:
                            hasAbortedStatus = true;
                            break;
                        case UNKNOWN:
                            break;
                        default:
                            break;
                    }
                    if (entry.getKey().getLastUpdateTime() == null || (entry.getKey().getLastUpdateTime().before(task.getLastUpdateTime()) && !entry.getKey().getLastUpdateTime().equals(task.getLastUpdateTime()))) {
                        entry.getKey().setLastUpdateTime(task.getLastUpdateTime());
                    }
                    Date tempDate = task.getLastUpdateTime();
                    if (entry.getKey().getStartTime() == null || entry.getKey().getStartTime().after(task.getStartTime())) {
                        entry.getKey().setStartTime(task.getStartTime());
                    }
                    if (entry.getKey().getEndTime() == null || entry.getKey().getEndTime().before(task.getEndTime())) {
                        entry.getKey().setEndTime(task.getEndTime());
                    }
                    entry.getKey().setLastUpdateTime(tempDate);
                }
                if (hasFailedStatus) {
                    entry.getKey().setStatus(JobExecutionStatus.FAILED);
                } else if (finishedCount == entry.getValue().size()) {
                    entry.getKey().setStatus(JobExecutionStatus.FINISHED);
                } else if (hasStartedStatus) {
                    entry.getKey().setStatus(JobExecutionStatus.STARTED);
                } else if (hasAbortedStatus) {
                    entry.getKey().setStatus(JobExecutionStatus.ABORTED);
                } else {
                    entry.getKey().setStatus(JobExecutionStatus.UNKNOWN);
                }
            }
            ArrayList<Job> newTaskList = new ArrayList<Job>();
            for (Job task : taskListWithCorrelationFilter) {
                // $NON-NLS-1$
                String id = "";
                if (task.getCorrelationId().startsWith(_WEBADMIN_)) {
                    id = task.getCorrelationId();
                } else {
                    id = task.getId().toString();
                }
                boolean hadDetails = detailedTaskMap.containsKey(id);
                if (hadDetails && task.getLastUpdateTime().getTime() - detailedTaskMap.get(id).getLastUpdateTime().getTime() < 100) {
                    task.setSteps(detailedTaskMap.get(id).getSteps());
                } else if (hadDetails) {
                    detailedTaskMap.remove(id.toString());
                    updateSingleTask(id);
                }
                newTaskList.add(task);
            }
            taskListModel.setItems(newTaskList);
        }
    };
    GetJobsByOffsetQueryParameters tempVar = new GetJobsByOffsetQueryParameters();
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetJobsByOffset, tempVar, _asyncQuery);
    setIsQueryFirstTime(false);
}
#method_after
@Override
protected void syncSearch() {
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            TaskListModel taskListModel = (TaskListModel) model;
            ArrayList<Job> taskList = (ArrayList<Job>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            if (taskList.size() == 0) {
                detailedTaskMap.clear();
            }
            ArrayList<Job> taskListWithCorrelationFilter = new ArrayList<Job>();
            Map<String, Map.Entry<Job, ArrayList<Job>>> correlationTaskMap = new HashMap<String, Map.Entry<Job, ArrayList<Job>>>();
            for (Job task : taskList) {
                if (task.getCorrelationId().startsWith(_WEBADMIN_)) {
                    if (!correlationTaskMap.containsKey(task.getCorrelationId())) {
                        Job rootTask = new Job();
                        rootTask.setCorrelationId(task.getCorrelationId());
                        Map.Entry<Job, ArrayList<Job>> entry = new TaskEntry(rootTask);
                        entry.setValue(new ArrayList<Job>());
                        correlationTaskMap.put(rootTask.getCorrelationId(), entry);
                        String[] taskDescreptionArray = // $NON-NLS-1$ //$NON-NLS-2$
                        rootTask.getCorrelationId().replace(_WEBADMIN_, "").split("_");
                        StringBuilder taskDesc = new StringBuilder();
                        for (int i = 1; i < taskDescreptionArray.length; i++) {
                            // $NON-NLS-1$
                            taskDesc.append(taskDescreptionArray[i]).append(" ");
                        }
                        rootTask.setId(task.getId());
                        rootTask.setDescription(taskDesc.toString());
                        taskListWithCorrelationFilter.add(rootTask);
                    }
                    Map.Entry<Job, ArrayList<Job>> entry = correlationTaskMap.get(task.getCorrelationId());
                    entry.getValue().add(task);
                } else {
                    taskListWithCorrelationFilter.add(task);
                }
            }
            for (Map.Entry<Job, ArrayList<Job>> entry : correlationTaskMap.values()) {
                entry.getKey().setStatus(JobExecutionStatus.UNKNOWN);
                boolean hasFailedStatus = false;
                boolean hasStartedStatus = false;
                boolean hasAbortedStatus = false;
                int finishedCount = 0;
                for (Job task : entry.getValue()) {
                    switch(task.getStatus()) {
                        case STARTED:
                            hasStartedStatus = true;
                            break;
                        case FINISHED:
                            finishedCount++;
                            break;
                        case FAILED:
                            hasFailedStatus = true;
                            break;
                        case ABORTED:
                            hasAbortedStatus = true;
                            break;
                        case UNKNOWN:
                            break;
                        default:
                            break;
                    }
                    if (entry.getKey().getLastUpdateTime() == null || (entry.getKey().getLastUpdateTime().before(task.getLastUpdateTime()) && !entry.getKey().getLastUpdateTime().equals(task.getLastUpdateTime()))) {
                        entry.getKey().setLastUpdateTime(task.getLastUpdateTime());
                    }
                    Date tempDate = task.getLastUpdateTime();
                    if (entry.getKey().getStartTime() == null || entry.getKey().getStartTime().after(task.getStartTime())) {
                        entry.getKey().setStartTime(task.getStartTime());
                    }
                    if (entry.getKey().getEndTime() == null || entry.getKey().getEndTime().before(task.getEndTime())) {
                        entry.getKey().setEndTime(task.getEndTime());
                    }
                    entry.getKey().setLastUpdateTime(tempDate);
                }
                if (hasFailedStatus) {
                    entry.getKey().setStatus(JobExecutionStatus.FAILED);
                } else if (finishedCount == entry.getValue().size()) {
                    entry.getKey().setStatus(JobExecutionStatus.FINISHED);
                } else if (hasStartedStatus) {
                    entry.getKey().setStatus(JobExecutionStatus.STARTED);
                } else if (hasAbortedStatus) {
                    entry.getKey().setStatus(JobExecutionStatus.ABORTED);
                } else {
                    entry.getKey().setStatus(JobExecutionStatus.UNKNOWN);
                }
            }
            ArrayList<Job> newTaskList = new ArrayList<Job>();
            for (Job task : taskListWithCorrelationFilter) {
                // $NON-NLS-1$
                String id = "";
                if (task.getCorrelationId().startsWith(_WEBADMIN_)) {
                    id = task.getCorrelationId();
                } else {
                    id = task.getId().toString();
                }
                boolean hadDetails = detailedTaskMap.containsKey(id) && detailedTaskMap.get(id) != null;
                if (hadDetails && task.getLastUpdateTime().getTime() - detailedTaskMap.get(id).getLastUpdateTime().getTime() < 100) {
                    task.setSteps(detailedTaskMap.get(id).getSteps());
                } else if (hadDetails) {
                    detailedTaskMap.remove(id.toString());
                    updateSingleTask(id);
                }
                newTaskList.add(task);
            }
            taskListModel.setItems(newTaskList);
        }
    };
    GetJobsByOffsetQueryParameters tempVar = new GetJobsByOffsetQueryParameters();
    tempVar.setRefresh(getIsQueryFirstTime());
    Frontend.getInstance().runQuery(VdcQueryType.GetJobsByOffset, tempVar, _asyncQuery);
    setIsQueryFirstTime(false);
}
#end_block

#method_before
protected void updateSpiceVersion() {
    // If can't update spice version - leave the default value from the Configurator.
    if ((clientOsType().equalsIgnoreCase("Windows")) && (clientBrowserType().equalsIgnoreCase("Explorer"))) {
        // $NON-NLS-1$ //$NON-NLS-2$
        if (clientPlatformType().equalsIgnoreCase("win32")) {
            // $NON-NLS-1$
            updateSpice32Version();
        } else if (clientPlatformType().equalsIgnoreCase("win64")) {
            // $NON-NLS-1$
            updateSpice64Version();
        }
    }
}
#method_after
protected void updateSpiceVersion() {
    // If can't update spice version - leave the default value from the Configurator.
    if (clientPlatformType().equalsIgnoreCase("win32")) {
        // $NON-NLS-1$
        updateSpice32Version();
    } else if (clientPlatformType().equalsIgnoreCase("win64")) {
        // $NON-NLS-1$
        updateSpice64Version();
    }
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<String> excludeUsers = new HashSet<String>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getExternalId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                DirectoryGroup a = (DirectoryGroup) item;
                if (!excludeUsers.contains(a.getId())) {
                    // XXX: This should use DbGroup and not DbUser.
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getId());
                    tempVar3.setFirstName(a.getName());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getDirectoryName());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<String> excludeUsers = new HashSet<String>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getExternalId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (Collection<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                DirectoryGroup a = (DirectoryGroup) item;
                if (!excludeUsers.contains(a.getId())) {
                    // XXX: This should use DbGroup and not DbUser.
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setExternalId(a.getId());
                    tempVar3.setFirstName(a.getName());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getDirectoryName());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
public List<IdType> getIds() {
    return ids;
}
#method_after
public List<Guid> getIds() {
    return ids;
}
#end_block

#method_before
public void setIds(List<IdType> ids) {
    this.ids = ids;
}
#method_after
public void setIds(List<Guid> ids) {
    this.ids = ids;
}
#end_block

#method_before
private String getDirectoryName(Group group) {
    if (group.isSetDomain() && group.getDomain().isSetName()) {
        return group.getDomain().getName();
    } else if (group.isSetDomain() && group.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
        for (String domain : domains) {
            Guid domainId = new Guid(domain.getBytes(), true);
            if (domainId.toString().equals(group.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + group.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (group.isSetName() && group.getName().contains("/")) {
        return group.getName().substring(0, group.getName().indexOf("/"));
    }
    return null;
}
#method_after
private String getDirectoryName(Group group) {
    if (group.isSetDomain() && group.getDomain().isSetName()) {
        return group.getDomain().getName();
    } else if (group.isSetDomain() && group.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new GetDomainListParameters());
        for (String domain : domains) {
            Guid domainId = new Guid(domain.getBytes(), true);
            if (domainId.toString().equals(group.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + group.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (group.isSetName() && group.getName().contains("/")) {
        return group.getName().substring(0, group.getName().indexOf("/"));
    }
    return null;
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(entryuuid.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(idText);
        user.setUserId(new IdType(idObject).toString());
        // Getting other string properties
        Attribute att = attributes.get(uid.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(entryuuid.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(idText);
        user.setUserId(idObject.toString());
        // Getting other string properties
        Attribute att = attributes.get(uid.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#end_block

#method_before
@Override
public String encodedId(IdType id) {
    Guid guid = id.toGuid();
    return guid.toString();
}
#method_after
@Override
public String encodedId(Guid id) {
    return id.toString();
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(ipaUniqueId.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(ipaUniqueId.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(new IdType(Guid.createGuidFromStringDefaultEmpty(objectGuid)).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(ipaUniqueId.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(ipaUniqueId.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(Guid.createGuidFromStringDefaultEmpty(objectGuid).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#end_block

#method_before
private DbUser refreshUser(DbUser dbUser, DirectoryUser directoryUser) {
    // if it isn't marked already:
    if (directoryUser == null) {
        if (dbUser.isActive()) {
            log.warnFormat("User \"{0}\" will be marked as not active as it wasn't found in the directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
        }
        return dbUser;
    }
    // This flag indicates if there are any differences and thus if the database update should actually be
    // performed:
    boolean update = false;
    // If the user was marked as not active in the database then mark it as active:
    if (!dbUser.isActive()) {
        log.infoFormat("User \"{0}\" will be marked as active as it was found in directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
        dbUser.setActive(true);
        update = true;
    }
    // the flag that indicates that the database needs to be updated:
    if (!StringUtils.equals(dbUser.getFirstName(), directoryUser.getName())) {
        dbUser.setFirstName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLastName(), directoryUser.getLastName())) {
        dbUser.setLastName(directoryUser.getLastName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDomain(), directoryUser.getDirectoryName())) {
        dbUser.setDomain(directoryUser.getDirectoryName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLoginName(), directoryUser.getName())) {
        dbUser.setLoginName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDepartment(), directoryUser.getDepartment())) {
        dbUser.setDepartment(directoryUser.getDepartment());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getRole(), directoryUser.getTitle())) {
        dbUser.setRole(directoryUser.getTitle());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getEmail(), directoryUser.getEmail())) {
        dbUser.setEmail(directoryUser.getEmail());
        update = true;
    }
    // Compare the new list of group names and identifiers:
    StringBuilder groupNamesBuffer = new StringBuilder();
    StringBuilder groupIdsBuffer = new StringBuilder();
    boolean first = true;
    DbGroupDAO groupDao = DbFacade.getInstance().getDbGroupDao();
    for (DirectoryGroup directoryGroup : directoryUser.getGroups()) {
        if (!first) {
            groupNamesBuffer.append(',');
            groupIdsBuffer.append(',');
        }
        DbGroup dbGroup = groupsMap.get(directoryGroup.getId());
        if (dbGroup == null) {
            dbGroup = groupDao.getByExternalId(dbUser.getDomain(), directoryGroup.getId());
        }
        if (dbGroup == null) {
            // group is not in map or db
            groupIdsBuffer.append(Guid.Empty);
        } else {
            groupIdsBuffer.append(dbGroup.getId());
        }
        groupNamesBuffer.append(directoryGroup.getName());
        first = false;
    }
    String groupNames = groupNamesBuffer.toString();
    String groupIds = groupIdsBuffer.toString();
    if (!StringUtils.equals(dbUser.getGroupNames(), groupNames)) {
        dbUser.setGroupNames(groupNames);
        update = true;
    }
    if (!StringUtils.equals(dbUser.getGroupIds(), groupIds)) {
        dbUser.setGroupIds(groupIds);
        update = true;
    }
    return update ? dbUser : null;
}
#method_after
private DbUser refreshUser(DbUser dbUser, DirectoryUser directoryUser) {
    // if it isn't marked already:
    if (directoryUser == null) {
        if (dbUser.isActive()) {
            log.warnFormat("User \"{0}\" will be marked as not active as it wasn't found in the directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
        }
        return dbUser;
    }
    // This flag indicates if there are any differences and thus if the database update should actually be
    // performed:
    boolean update = false;
    // If the user was marked as not active in the database then mark it as active:
    if (!dbUser.isActive()) {
        log.infoFormat("User \"{0}\" will be marked as active as it was found in directory \"{1}\".", dbUser.getLoginName(), dbUser.getDomain());
        dbUser.setActive(true);
        update = true;
    }
    // the flag that indicates that the database needs to be updated:
    if (!StringUtils.equals(dbUser.getFirstName(), directoryUser.getFirstName())) {
        dbUser.setFirstName(directoryUser.getFirstName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLastName(), directoryUser.getLastName())) {
        dbUser.setLastName(directoryUser.getLastName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDomain(), directoryUser.getDirectoryName())) {
        dbUser.setDomain(directoryUser.getDirectoryName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getLoginName(), directoryUser.getName())) {
        dbUser.setLoginName(directoryUser.getName());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getDepartment(), directoryUser.getDepartment())) {
        dbUser.setDepartment(directoryUser.getDepartment());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getRole(), directoryUser.getTitle())) {
        dbUser.setRole(directoryUser.getTitle());
        update = true;
    }
    if (!StringUtils.equals(dbUser.getEmail(), directoryUser.getEmail())) {
        dbUser.setEmail(directoryUser.getEmail());
        update = true;
    }
    // Compare the new list of group names and identifiers:
    StringBuilder groupNamesBuffer = new StringBuilder();
    StringBuilder groupIdsBuffer = new StringBuilder();
    boolean first = true;
    DbGroupDAO groupDao = DbFacade.getInstance().getDbGroupDao();
    for (DirectoryGroup directoryGroup : directoryUser.getGroups()) {
        if (!first) {
            groupNamesBuffer.append(',');
            groupIdsBuffer.append(',');
        }
        DbGroup dbGroup = groupsMap.get(directoryGroup.getId());
        if (dbGroup == null) {
            dbGroup = groupDao.getByExternalId(dbUser.getDomain(), directoryGroup.getId());
        }
        if (dbGroup == null) {
            // group is not in map or db
            groupIdsBuffer.append(Guid.Empty);
        } else {
            groupIdsBuffer.append(dbGroup.getId());
        }
        groupNamesBuffer.append(directoryGroup.getName());
        first = false;
    }
    String groupNames = groupNamesBuffer.toString();
    String groupIds = groupIdsBuffer.toString();
    if (!StringUtils.equals(dbUser.getGroupNames(), groupNames)) {
        dbUser.setGroupNames(groupNames);
        update = true;
    }
    if (!StringUtils.equals(dbUser.getGroupIds(), groupIds)) {
        dbUser.setGroupIds(groupIds);
        update = true;
    }
    return update ? dbUser : null;
}
#end_block

#method_before
@Override
public String encodedId(IdType id) {
    Guid guid = id.toGuid();
    return getNsUniqueIdFromGuidString(guid.toString());
}
#method_after
@Override
public String encodedId(Guid id) {
    return getNsUniqueIdFromGuidString(id.toString());
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(nsUniqueId.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(nsUniqueId.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(new IdType(Guid.createGuidFromStringDefaultEmpty(LdapBrokerUtils.getGuidFromNsUniqueId(objectGuid))).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(nsUniqueId.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(nsUniqueId.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(Guid.createGuidFromStringDefaultEmpty(LdapBrokerUtils.getGuidFromNsUniqueId(objectGuid)).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#end_block

#method_before
@Override
public String encodedId(IdType id) {
    // AD guid is stored in reversed order than MS-SQL guid -
    // Since it is important for us to work with GUIDs which are MS-SQL
    // aligned,
    // for each GUID -before using with AD we will change its byte order to
    // support AD
    Guid adGuid = new Guid(id.toGuid().toByteArray(), false);
    byte[] bytes = adGuid.toByteArray();
    StringBuilder sb = new StringBuilder();
    for (int idx = 0; idx < bytes.length; idx++) {
        sb.append("\\" + String.format("%02X", bytes[idx]));
    }
    return sb.toString();
}
#method_after
@Override
public String encodedId(Guid id) {
    // AD guid is stored in reversed order than MS-SQL guid -
    // Since it is important for us to work with GUIDs which are MS-SQL
    // aligned,
    // for each GUID -before using with AD we will change its byte order to
    // support AD
    byte[] bytes = id.toByteArray();
    StringBuilder sb = new StringBuilder();
    for (int idx = 0; idx < bytes.length; idx++) {
        sb.append("\\" + String.format("%02X", bytes[idx]));
    }
    return sb.toString();
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(uniqueIdentifier.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(uniqueMember.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(uniqueIdentifier.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(new IdType(Guid.createGuidFromStringDefaultEmpty(LdapBrokerUtils.getGuidFromNsUniqueId(objectGuid))).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(uniqueIdentifier.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(uniqueMember.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(uniqueIdentifier.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(Guid.createGuidFromStringDefaultEmpty(LdapBrokerUtils.getGuidFromNsUniqueId(objectGuid)).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#end_block

#method_before
protected Object[] getEncodedParameters(Object[] parameters, LdapIdEncoder idEncoder) {
    if (parameters == null) {
        return null;
    }
    Object[] retVal = parameters.clone();
    int index = 0;
    for (Object parameter : parameters) {
        if (parameter instanceof IdType) {
            retVal[index] = idEncoder.encodedId((IdType) parameter);
        }
        index++;
    }
    return retVal;
}
#method_after
protected Object[] getEncodedParameters(Object[] parameters, LdapIdEncoder idEncoder) {
    if (parameters == null) {
        return null;
    }
    Object[] retVal = parameters.clone();
    int index = 0;
    for (Object parameter : parameters) {
        if (parameter instanceof Guid) {
            retVal[index] = idEncoder.encodedId((Guid) parameter);
        }
        index++;
    }
    return retVal;
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(ipaUniqueId.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(idText);
        user.setUserId(new IdType(idObject).toString());
        // Getting other string properties
        Attribute att = attributes.get(krbPrincipalname.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(ipaUniqueId.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(idText);
        user.setUserId(idObject.toString());
        // Getting other string properties
        Attribute att = attributes.get(krbPrincipalname.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(entryuuid.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(entryuuid.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(new IdType(Guid.createGuidFromStringDefaultEmpty(objectGuid)).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(entryuuid.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        String objectGuid = (String) attributes.get(entryuuid.name()).get(0);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(Guid.createGuidFromStringDefaultEmpty(objectGuid).toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#end_block

#method_before
@Override
public DirectoryUser findUserById(String id) {
    // Find the user with the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(getName(), new IdType(id)));
    LdapUser ldapUser = (LdapUser) ldapResult.getReturnValue();
    // Map the user:
    return mapUser(ldapUser);
}
#method_after
@Override
public DirectoryUser findUserById(String id) {
    // Find the user with the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(getName(), Guid.createGuidFromString(id)));
    LdapUser ldapUser = (LdapUser) ldapResult.getReturnValue();
    // Map the user:
    return mapUser(ldapUser);
}
#end_block

#method_before
@Override
public List<DirectoryUser> findUsers(List<String> ids) {
    // Find the users using the old mechanism:
    List<IdType> idTypes = new ArrayList<>();
    for (String id : ids) {
        idTypes.add(new IdType(id));
    }
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(getName(), idTypes));
    @SuppressWarnings("unchecked")
    List<LdapUser> ldapUsers = (List<LdapUser>) ldapResult.getReturnValue();
    // Map the users:
    return mapUsers(ldapUsers);
}
#method_after
@Override
public List<DirectoryUser> findUsers(List<String> ids) {
    // Find the users using the old mechanism:
    List<Guid> guids = new ArrayList<>();
    for (String id : ids) {
        guids.add(Guid.createGuidFromString(id));
    }
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdUserByUserIdList, new LdapSearchByUserIdListParameters(getName(), guids, true));
    @SuppressWarnings("unchecked")
    List<LdapUser> ldapUsers = (List<LdapUser>) ldapResult.getReturnValue();
    // Map the users:
    return mapUsers(ldapUsers);
}
#end_block

#method_before
@Override
public DirectoryGroup findGroupById(String id) {
    // Find the group using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(getName(), new IdType(id)));
    LdapGroup ldapGroup = (LdapGroup) ldapResult.getReturnValue();
    // Map the group:
    return mapGroup(ldapGroup);
}
#method_after
@Override
public DirectoryGroup findGroupById(String id) {
    // Find the group using the old mechanism:
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(getName(), Guid.createGuidFromString(id)));
    LdapGroup ldapGroup = (LdapGroup) ldapResult.getReturnValue();
    // Map the group:
    return mapGroup(ldapGroup);
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    try {
        Object adObjectGuid = attributes.get(objectguid.name()).get(0);
        byte[] guidBytes = (byte[]) adObjectGuid;
        Guid guid = new Guid(guidBytes, false);
        user.setUserId(new IdType(guid).toString());
        // Getting other string properties
        Attribute att = attributes.get(userprincipalname.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    try {
        Object adObjectGuid = attributes.get(objectguid.name()).get(0);
        byte[] guidBytes = (byte[]) adObjectGuid;
        Guid guid = new Guid(guidBytes, false);
        user.setUserId(guid.toString());
        // Getting other string properties
        Attribute att = attributes.get(userprincipalname.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(objectGuid.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        Object adObjectGuid = attributes.get(objectGuid.name()).get(0);
        byte[] guidBytes = (byte[]) adObjectGuid;
        Guid guid = new Guid(guidBytes, false);
        IdType id = new IdType(guid);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(id.toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    if (attributes.get(objectGuid.name()) == null) {
        return null;
    }
    try {
        List<String> memberOf = new ArrayList<String>();
        Attribute att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
        }
        Object adObjectGuid = attributes.get(objectGuid.name()).get(0);
        byte[] guidBytes = (byte[]) adObjectGuid;
        Guid guid = new Guid(guidBytes, false);
        String distinguishedName = searchResult.getNameInNamespace();
        distinguishedName = LdapBrokerUtils.hadleNameEscaping(distinguishedName);
        GroupSearchResult groupSearchResult = new GroupSearchResult(guid.toString(), memberOf, distinguishedName);
        return groupSearchResult;
    } catch (Exception ex) {
        log.error("Failed populating group", ex);
        return null;
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectoryName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.save(dbUser);
    } else {
        dbUser = new DbUser(directoryUser);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectoryName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(nsUniqueId.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(LdapBrokerUtils.getGuidFromNsUniqueId(idText));
        user.setUserId(new IdType(idObject).toString());
        // Getting other string properties
        Attribute att = attributes.get(uid.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(nsUniqueId.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(LdapBrokerUtils.getGuidFromNsUniqueId(idText));
        user.setUserId(idObject.toString());
        // Getting other string properties
        Attribute att = attributes.get(uid.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(memberof.name());
        if (att != null) {
            NamingEnumeration<?> groupsNames = att.getAll();
            List<String> memberOf = new ArrayList<String>();
            while (groupsNames.hasMoreElements()) {
                memberOf.add((String) groupsNames.nextElement());
            }
            user.setMemberof(memberOf);
        } else {
            // In case the attribute is null, an empty list is set
            // in the "memberOf" field in order to avoid a
            // NullPointerException
            // while traversing on the groups list in
            // LdapBrokerCommandBase.ProceedGroupsSearchResult
            user.setMemberof(new ArrayList<String>());
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#end_block

#method_before
@Override
public DbUser getByIdOrExternalId(Guid id, String domain, String externalId) {
    // Check if there is a user with the given internal identifier:
    if (id != null) {
        DbUser existing = get(id);
        if (existing != null) {
            return existing;
        }
    }
    // Check if there is an existing user for the given external identifier:
    if (domain != null && externalId != null) {
        DbUser existing = getByExternalId(domain, externalId);
        if (existing != null) {
            return existing;
        }
    }
    // if the internal id is really an external id:
    if (domain != null && id != null) {
        externalId = guidToExternalId(id);
        DbUser existing = getByExternalId(domain, externalId);
        if (existing != null) {
            return existing;
        }
    }
    // There is no such existing user:
    return null;
}
#method_after
@Override
public DbUser getByIdOrExternalId(Guid id, String domain, String externalId) {
    // Check if there is a user with the given internal identifier:
    if (id != null) {
        DbUser existing = get(id);
        if (existing != null) {
            return existing;
        }
    }
    // Check if there is an existing user for the given external identifier:
    if (domain != null && externalId != null) {
        DbUser existing = getByExternalId(domain, externalId);
        if (existing != null) {
            return existing;
        }
    }
    // if the internal id is really an external id:
    if (domain != null && id != null) {
        DbUser existing = getByExternalId(domain, id.toString());
        if (existing != null) {
            return existing;
        }
    }
    // There is no such existing user:
    return null;
}
#end_block

#method_before
public List<LdapQueryData> getLdapQueriesData(String domain) {
    int queryLimit = Config.<Integer>getValue(ConfigValues.MaxLDAPQueryPartsNumber);
    List<LdapQueryData> results = new ArrayList<LdapQueryData>();
    LdapQueryData subQueryData = new LdapQueryDataImpl();
    ArrayList<Object> filterParameters = new ArrayList<Object>();
    int counter = 0;
    for (IdType identifier : ldapIdentifiers) {
        filterParameters.add(identifier);
        // Checking if more than queryLimit query clauses were added to the query
        if (counter >= queryLimit) {
            // More than queryLimit query clauses were added to the query -
            // close the query, add it to the results, and start a new query
            subQueryData.setFilterParameters(filterParameters.toArray());
            subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
            subQueryData.setBaseDNParameters(null);
            subQueryData.setDomain(domain);
            results.add(subQueryData);
            subQueryData = new LdapQueryDataImpl();
            filterParameters = new ArrayList<Object>();
            counter = 0;
        }
        counter++;
    }
    if (!filterParameters.isEmpty()) {
        subQueryData.setFilterParameters(filterParameters.toArray());
        subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
        subQueryData.setBaseDNParameters(null);
        subQueryData.setDomain(domain);
        results.add(subQueryData);
    }
    return results;
}
#method_after
public List<LdapQueryData> getLdapQueriesData(String domain) {
    int queryLimit = Config.<Integer>getValue(ConfigValues.MaxLDAPQueryPartsNumber);
    List<LdapQueryData> results = new ArrayList<LdapQueryData>();
    LdapQueryData subQueryData = new LdapQueryDataImpl();
    ArrayList<Object> filterParameters = new ArrayList<Object>();
    int counter = 0;
    for (Guid identifier : ldapIdentifiers) {
        filterParameters.add(identifier);
        // Checking if more than queryLimit query clauses were added to the query
        if (counter >= queryLimit) {
            // More than queryLimit query clauses were added to the query -
            // close the query, add it to the results, and start a new query
            subQueryData.setFilterParameters(filterParameters.toArray());
            subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
            subQueryData.setBaseDNParameters(null);
            subQueryData.setDomain(domain);
            results.add(subQueryData);
            subQueryData = new LdapQueryDataImpl();
            filterParameters = new ArrayList<Object>();
            counter = 0;
        }
        counter++;
    }
    if (!filterParameters.isEmpty()) {
        subQueryData.setFilterParameters(filterParameters.toArray());
        subQueryData.setLdapQueryType(LdapQueryType.getUsersByUserGuids);
        subQueryData.setBaseDNParameters(null);
        subQueryData.setDomain(domain);
        results.add(subQueryData);
    }
    return results;
}
#end_block

#method_before
private IdType getUserId() {
    return ((LdapSearchByIdParameters) getParameters()).getId();
}
#method_after
private Guid getUserId() {
    return ((LdapSearchByIdParameters) getParameters()).getId();
}
#end_block

#method_before
public IdType getId() {
    return id;
}
#method_after
public Guid getId() {
    return id;
}
#end_block

#method_before
public void setId(IdType id) {
    this.id = id;
}
#method_after
public void setId(Guid id) {
    this.id = id;
}
#end_block

#method_before
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(uniqueIdentifier.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(idText);
        user.setUserId(new IdType(idObject).toString());
        // Getting other string properties
        Attribute att = attributes.get(uid.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(department.name());
        if (att != null) {
            user.setDepartment((String) att.get(0));
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#method_after
@Override
public Object mapFromContext(Object ctx) {
    if (ctx == null) {
        return null;
    }
    DirContextAdapter searchResult = (DirContextAdapter) ctx;
    Attributes attributes = searchResult.getAttributes();
    if (attributes == null) {
        return null;
    }
    LdapUser user;
    user = new LdapUser();
    // user's Guid
    try {
        String idText = (String) attributes.get(uniqueIdentifier.name()).get(0);
        Guid idObject = Guid.createGuidFromStringDefaultEmpty(idText);
        user.setUserId(idObject.toString());
        // Getting other string properties
        Attribute att = attributes.get(uid.name());
        if (att != null) {
            user.setUserName((String) att.get(0));
        } else {
            return null;
        }
        att = attributes.get(givenname.name());
        if (att != null) {
            user.setName((String) att.get(0));
        }
        att = attributes.get(sn.name());
        if (att != null) {
            user.setSurName((String) att.get(0));
        }
        att = attributes.get(title.name());
        if (att != null) {
            user.setTitle((String) att.get(0));
        }
        att = attributes.get(mail.name());
        if (att != null) {
            user.setEmail((String) att.get(0));
        }
        att = attributes.get(department.name());
        if (att != null) {
            user.setDepartment((String) att.get(0));
        }
    } catch (NamingException e) {
        log.error("Failed populating user", e);
        return null;
    }
    return user;
}
#end_block

#method_before
private List<IdType> getUserIds() {
    return ((LdapSearchByIdListParameters) getParameters()).getIds();
}
#method_after
private List<Guid> getUserIds() {
    return ((LdapSearchByIdListParameters) getParameters()).getIds();
}
#end_block

#method_before
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        ArrayList<LdapUser> tempUsers = (ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#method_after
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        ArrayList<LdapUser> tempUsers = (ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData, populateGroups)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#end_block

#method_before
private List<LdapQueryData> GenerateUsersQuery() {
    UsersObjectIdQueryGenerator generator = new UsersObjectIdQueryGenerator();
    for (IdType id : getUserIds()) {
        generator.add(id);
    }
    return generator.getLdapQueriesData(getDomain());
}
#method_after
private List<LdapQueryData> GenerateUsersQuery() {
    UsersObjectIdQueryGenerator generator = new UsersObjectIdQueryGenerator();
    for (Guid id : getUserIds()) {
        generator.add(id);
    }
    return generator.getLdapQueriesData(getDomain());
}
#end_block

#method_before
private IdType getGroupId() {
    return ((LdapSearchByIdParameters) getParameters()).getId();
}
#method_after
private Guid getGroupId() {
    return ((LdapSearchByIdParameters) getParameters()).getId();
}
#end_block

#method_before
@Override
public DbGroup getByIdOrExternalId(Guid id, String domain, String externalId) {
    // Check if there is a user with the given internal identifier:
    if (id != null) {
        DbGroup existing = get(id);
        if (existing != null) {
            return existing;
        }
    }
    // Check if there is an existing user for the given external identifier:
    if (domain != null && externalId != null) {
        DbGroup existing = getByExternalId(domain, externalId);
        if (existing != null) {
            return existing;
        }
    }
    // if the internal id is really an external id:
    if (domain != null && id != null) {
        externalId = guidToExternalId(id);
        DbGroup existing = getByExternalId(domain, externalId);
        if (existing != null) {
            return existing;
        }
    }
    // There is no such existing user:
    return null;
}
#method_after
@Override
public DbGroup getByIdOrExternalId(Guid id, String domain, String externalId) {
    // Check if there is a user with the given internal identifier:
    if (id != null) {
        DbGroup existing = get(id);
        if (existing != null) {
            return existing;
        }
    }
    // Check if there is an existing user for the given external identifier:
    if (domain != null && externalId != null) {
        DbGroup existing = getByExternalId(domain, externalId);
        if (existing != null) {
            return existing;
        }
    }
    // if the internal id is really an external id:
    if (domain != null && id != null) {
        DbGroup existing = getByExternalId(domain, id.toString());
        if (existing != null) {
            return existing;
        }
    }
    // There is no such existing user:
    return null;
}
#end_block

#method_before
@Override
public String encodedId(IdType id) {
    Guid guid = id.toGuid();
    return guid.toString();
}
#method_after
@Override
public String encodedId(Guid id) {
    return id.toString();
}
#end_block

#method_before
private static void AddEventNotificationEntry(EventNotificationEntity entity, AuditLogType auditLogType) {
    HashSet<AuditLogType> entry;
    if (!_eventNotificationTypeMap.containsKey(entity)) {
        _eventNotificationTypeMap.put(entity, new HashSet<AuditLogType>());
    }
    entry = _eventNotificationTypeMap.get(entity);
    entry.add(auditLogType);
}
#method_after
private static void AddEventNotificationEntry(EventNotificationEntity entity, AuditLogType auditLogType) {
    HashSet<AuditLogType> entry = _eventNotificationTypeMap.get(entity);
    if (entry == null) {
        entry = new HashSet<AuditLogType>();
        _eventNotificationTypeMap.put(entity, entry);
    }
    entry.add(auditLogType);
}
#end_block

#method_before
private void parseSecondArgWithoutDash(String arg, boolean passFileExists) {
    int delimiterIndex = arg.indexOf("=");
    if ((getConfigAction().equals(ConfigActionType.ACTION_SET) || getConfigAction().equals(ConfigActionType.ACTION_MERGE)) && delimiterIndex == -1 && !passFileExists) {
        throw new IllegalArgumentException("Argument for set/concat action must be in format of key=value.");
    }
    String key = getStringBeforeEqualChar(arg, delimiterIndex);
    String value = getStringAfterEqualChar(arg, delimiterIndex);
    if (!key.isEmpty()) {
        if (!value.isEmpty()) {
            parseSecondArgWithKeyValue(arg, key, value);
        } else if ((getConfigAction().equals(ConfigActionType.ACTION_SET) || getConfigAction().equals(ConfigActionType.ACTION_MERGE)) && getKey() == null) {
            engineConfigMap.setKey(key);
            engineConfigMap.setValue(value);
        } else if ((getConfigAction().equals(ConfigActionType.ACTION_GET) || getConfigAction().equals(ConfigActionType.ACTION_HELP)) && getKey() == null) {
            // sets the key in 'get' action with format: "-g key"
            engineConfigMap.setKey(arg);
        } else {
            log.debug("parsing error: illegal argument " + arg + ". Skipping argument.");
        }
    } else {
        log.debug("parsing error: illegal argument " + arg + ", starts with '='. Skipping argument.");
    }
}
#method_after
private void parseSecondArgWithoutDash(String arg, boolean passFileExists) {
    int delimiterIndex = arg.indexOf("=");
    if (isSetOrMergeAction() && delimiterIndex == -1 && !passFileExists) {
        throw new IllegalArgumentException("Argument for set/merge action must be in format of key=value.");
    }
    String key = getStringBeforeEqualChar(arg, delimiterIndex);
    String value = getStringAfterEqualChar(arg, delimiterIndex);
    if (!key.isEmpty()) {
        if (!value.isEmpty()) {
            parseSecondArgWithKeyValue(arg, key, value);
        } else if (isSetOrMergeAction() && getKey() == null) {
            engineConfigMap.setKey(key);
            engineConfigMap.setValue(value);
        } else if ((getConfigAction().equals(ConfigActionType.ACTION_GET) || getConfigAction().equals(ConfigActionType.ACTION_HELP)) && getKey() == null) {
            // sets the key in 'get' action with format: "-g key"
            engineConfigMap.setKey(arg);
        } else {
            log.debug("parsing error: illegal argument " + arg + ". Skipping argument.");
        }
    } else {
        log.debug("parsing error: illegal argument " + arg + ", starts with '='. Skipping argument.");
    }
}
#end_block

#method_before
private void parseSecondArgWithKeyValue(String arg, String key, String value) {
    if (getConfigAction().equals(ConfigActionType.ACTION_SET) || getConfigAction().equals(ConfigActionType.ACTION_MERGE)) {
        engineConfigMap.setKey(key);
        engineConfigMap.setValue(value);
    } else {
        log.debug("parseArguments error: second argument '" + arg + "' has an '=' char but action is not 'set'.");
        throw new IllegalArgumentException("Illegal second argument: " + arg + ".");
    }
}
#method_after
private void parseSecondArgWithKeyValue(String arg, String key, String value) {
    if (isSetOrMergeAction()) {
        engineConfigMap.setKey(key);
        engineConfigMap.setValue(value);
    } else {
        log.debug("parseArguments error: second argument '" + arg + "' has an '=' char but action is not 'set'.");
        throw new IllegalArgumentException("Illegal second argument: " + arg + ".");
    }
}
#end_block

#method_before
private void mergeValue() throws Exception {
    String key = parser.getKey();
    String value = parser.getValue();
    String version = parser.getVersion();
    if (version == null) {
        version = startVersionDialog(key);
    }
    ConfigKey configKey = fetchConfigKey(key, version);
    if (configKey != null && configKey.getKey() != null) {
        if (!configKey.isPasswordKey() && configKey.getDisplayValue().trim().length() > 0) {
            String val = configKey.getDisplayValue();
            if (!val.endsWith(";")) {
                val += ";";
            }
            val += value;
            value = val;
        }
    }
    boolean sucessUpdate = persist(key, value, version);
    if (!sucessUpdate) {
        log.debug("setValue: error concatenating " + key + "'s value. No such entry" + (version == null ? "" : " with version " + version) + ".");
        throw new IllegalArgumentException("Error setting " + key + "'s value. No such entry" + (version == null ? "" : " with version " + version) + ".");
    }
}
#method_after
private void mergeValue() throws Exception {
    String key = parser.getKey();
    String value = parser.getValue();
    if (!keysConfig.getBoolean(key + "/" + MERGABLE_TOKEN, false)) {
        console.writeFormat(MERGE_NOT_SUPPORTED_MSG, key);
        console.writeLine();
        return;
    }
    String version = parser.getVersion();
    if (version == null) {
        version = startVersionDialog(key);
    }
    ConfigKey configKey = fetchConfigKey(key, version);
    if (configKey != null && configKey.getKey() != null && configKey.getDisplayValue().trim().length() > 0) {
        String valueInDb = configKey.getDisplayValue().trim();
        String delimiter = keysConfig.getString(key + "/" + DELIMITER_TOKEN, ";");
        value = mergedValues(value, valueInDb, delimiter);
        if (valueInDb.equals(value)) {
            console.writeFormat(MERGE_SAME_VALUE_MSG);
            console.writeLine();
            return;
        }
    }
    if (!persist(key, value, version)) {
        String msg = MessageFormat.format(MERGE_PERSIST_ERR_MSG, key, (version == null ? "" : " with version " + version));
        log.debug(msg);
        throw new IllegalArgumentException(msg);
    }
}
#end_block

#method_before
private void printHelpForKey() throws Exception {
    final String keyName = parser.getKey();
    boolean foundKey = iterateAllKeys(this.configKeyFactory, keysConfig, new ConfigKeyHandler() {

        @Override
        public boolean handle(ConfigKey key) {
            if (key.getKey().equals(keyName)) {
                console.writeLine(key.getValueHelper().getHelpNote(key));
                return false;
            }
            return true;
        }
    });
    if (!foundKey) {
        console.writeFormat("Cannot display help for key %1$s. The key does not " + "exist at the configuration file of engine-config.", keyName);
    }
}
#method_after
private void printHelpForKey() throws Exception {
    final String keyName = parser.getKey();
    boolean foundKey = iterateAllKeys(this.configKeyFactory, keysConfig, new ConfigKeyHandler() {

        @Override
        public boolean handle(ConfigKey key) {
            if (key.getKey().equals(keyName)) {
                console.writeLine(key.getValueHelper().getHelpNote(key));
                return false;
            }
            return true;
        }
    });
    if (!foundKey) {
        console.writeFormat(KEY_NOT_FOUND_ERR_MSG, keyName);
    }
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, InterfaceStatus> monitoredInterfaces = new HashMap<String, InterfaceStatus>();
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String parentIfaceName = iface.getVlanId() == null ? iface.getName() : NetworkUtils.stripVlan(iface.getName());
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(parentIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || (iface.getLabels() != null && !iface.getLabels().isEmpty())) {
            VdsNetworkInterface parentIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                for (VdsNetworkInterface tmpIface : interfaces) {
                    if (parentIfaceName.equals(tmpIface.getName())) {
                        parentIface = tmpIface;
                    }
                }
            }
            monitoredInterfaces.put(parentIface.getName(), parentIface.getStatistics().getStatus());
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave.getStatistics().getStatus());
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        InterfaceStatus status = monitoredInterfaces.get(oldIface.getName());
        if (status != null && oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(oldIface.getName());
            logable.addCustomValue("InterfaceName", oldIface.getName());
            if (oldIface.getBonded() != null && oldIface.getBonded()) {
                auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_UP : AuditLogType.HOST_BOND_DOWN);
            } else {
                auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_IFACE_UP : AuditLogType.HOST_IFACE_DOWN);
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface.getName());
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are empty if we change oVrt node cluster during approve process
    if (vds.getCpuFlags() != null) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (!StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "setUpStatus", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "setUpStatus", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onVdsDuringFailureTimer")
public void onVdsDuringFailureTimer() {
    synchronized (getLockObj()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        /**
         * Move vds to Up status from error
         */
        if (vds.getStatus() == VDSStatus.Error) {
            mFailedToRunVmAttempts.set(0);
            setStatus(VDSStatus.Up, vds);
            DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
            log.infoFormat("onVdsDuringFailureTimer of Host {0} entered after {1} attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onVdsDuringFailureTimer")
public void onVdsDuringFailureTimer() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    /**
     * Move vds to Up status from error
     */
    if (vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.infoFormat("onVdsDuringFailureTimer of Host {0} entered after {1} attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#end_block

#method_before
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getCloneVmCommand()) {
        cloneVm();
    }
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    getEditCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool());
    getRemoveCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RemoveVm));
    getRunOnceCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RunVmOnce));
    getCloneVmCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.CloneVm));
    getChangeCdCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.ChangeDisk));
    getNewTemplateCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.AddVmTemplate));
}
#method_after
private void updateActionAvailability() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    getEditCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool());
    getRemoveCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RemoveVm));
    getRunOnceCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RunVmOnce));
    getChangeCdCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.ChangeDisk));
    getNewTemplateCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.AddVmTemplate));
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void selectDataCenterWithCluster(UnitVmModel model, Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    if (selectedCluster == null) {
        getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters));
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster)));
    }
}
#method_after
protected void selectDataCenterWithCluster(Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    DataCenterWithCluster selectedDataCenterWithCluster = (selectedCluster == null) ? Linq.firstOrDefault(dataCentersWithClusters) : Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster));
    getDataCenterWithClustersList().setItems(dataCentersWithClusters, selectedDataCenterWithCluster);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#end_block

#method_before
private void validateMemorySize(EntityModel model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = (Integer) model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#method_after
private void validateMemorySize(EntityModel<Integer> model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectoryName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(new Guid(directoryUser.getId().getBytes(), true));
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectoryName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#end_block

#method_before
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    if (vm.getVmInit() != null && !StringUtils.isEmpty(vm.getVmInit().getCustomScript())) {
        sysPrepContent = vm.getVmInit().getCustomScript();
    } else {
        sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    }
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String activeDirectorAU = "";
        if (vm.getVmInit() != null) {
            if (!StringUtils.isEmpty(vm.getVmInit().getInputLocale())) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUiLanguage())) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getSystemLocale())) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUserLocale())) {
                userLocale = vm.getVmInit().getUserLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getActiveDirectoryOU())) {
                activeDirectorAU = vm.getVmInit().getActiveDirectoryOU();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
        sysPrepContent = replace(sysPrepContent, "$MachineObjectOU$", activeDirectorAU);
    }
    return sysPrepContent;
}
#method_after
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    if (vm.getVmInit() != null && !StringUtils.isEmpty(vm.getVmInit().getCustomScript())) {
        sysPrepContent = vm.getVmInit().getCustomScript();
    } else {
        sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    }
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String activeDirectoryOU = "";
        if (vm.getVmInit() != null) {
            if (!StringUtils.isEmpty(vm.getVmInit().getInputLocale())) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUiLanguage())) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getSystemLocale())) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUserLocale())) {
                userLocale = vm.getVmInit().getUserLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getActiveDirectoryOU())) {
                activeDirectoryOU = vm.getVmInit().getActiveDirectoryOU();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
        sysPrepContent = replace(sysPrepContent, "$MachineObjectOU$", activeDirectoryOU);
    }
    return sysPrepContent;
}
#end_block

#method_before
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<Object>();
    networkNameEditor = new EntityModelTextBoxEditor();
    networkComboBox = new ComboBox(networkListEditor, networkNameEditor);
}
#method_after
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<String>();
    networkNameEditor = new StringEntityModelTextBoxEditor();
    networkComboBox = new ComboBox<String>(networkListEditor, networkNameEditor);
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !(Boolean) model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#end_block

#method_before
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled((Boolean) model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled((Boolean) model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = (Boolean) model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#method_after
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled(model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled(model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getUserName() {
    return privateUserName;
}
#method_after
public EntityModel<String> getUserName() {
    return privateUserName;
}
#end_block

#method_before
private void setUserName(EntityModel value) {
    privateUserName = value;
}
#method_after
private void setUserName(EntityModel<String> value) {
    privateUserName = value;
}
#end_block

#method_before
public EntityModel getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#method_after
public EntityModel<String> getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#end_block

#method_before
private void setActiveDirectoryOU(EntityModel value) {
    privateActiveDirectoryOU = value;
}
#method_after
private void setActiveDirectoryOU(EntityModel<String> value) {
    privateActiveDirectoryOU = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public EntityModel getSysprepScript() {
    return privateSysprepScript;
}
#method_after
public EntityModel<String> getSysprepScript() {
    return privateSysprepScript;
}
#end_block

#method_before
private void setSysprepScript(EntityModel value) {
    privateSysprepScript = value;
}
#method_after
private void setSysprepScript(EntityModel<String> value) {
    privateSysprepScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getUserName() {
    return privateUserName;
}
#method_after
public EntityModel<String> getUserName() {
    return privateUserName;
}
#end_block

#method_before
private void setUserName(EntityModel value) {
    privateUserName = value;
}
#method_after
private void setUserName(EntityModel<String> value) {
    privateUserName = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<Object>();
    networkNameEditor = new EntityModelTextBoxEditor();
    networkComboBox = new ComboBox(networkListEditor, networkNameEditor);
}
#method_after
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<String>();
    networkNameEditor = new StringEntityModelTextBoxEditor();
    networkComboBox = new ComboBox<String>(networkListEditor, networkNameEditor);
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !(Boolean) model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#end_block

#method_before
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled((Boolean) model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled((Boolean) model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = (Boolean) model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#method_after
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled(model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled(model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null) {
        if (!FeatureSupported.cloudInit(getVm().getVdsGroupCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLOUD_INIT_IS_NOT_SUPPORTED);
        }
        if (getParameters().getVmInit().isPasswordAlreadyStored()) {
            VmBase temp = new VmBase();
            temp.setId(getParameters().getVmId());
            VmHandler.updateVmInitFromDB(temp, false);
            getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null) {
        if (!OsRepositoryImpl.INSTANCE.isWindows(getVm().getOs()) && !FeatureSupported.cloudInit(getVm().getVdsGroupCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLOUD_INIT_IS_NOT_SUPPORTED);
        }
        if (getParameters().getVmInit().isPasswordAlreadyStored()) {
            VmBase temp = new VmBase();
            temp.setId(getParameters().getVmId());
            VmHandler.updateVmInitFromDB(temp, false);
            getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void refreshBootParameters(RunVmParams runVmParameters) {
    if (runVmParameters == null) {
        return;
    }
    getVm().setInitrdUrl(runVmParameters.getInitrdUrl());
    getVm().setKernelUrl(runVmParameters.getKernelUrl());
    getVm().setKernelParams(runVmParameters.getKernelParams());
    getVm().setCustomProperties(runVmParameters.getCustomProperties());
    getVm().setBootSequence((runVmParameters.getBootSequence() != null) ? runVmParameters.getBootSequence() : getVm().getDefaultBootSequence());
}
#method_after
@Override
protected void refreshBootParameters(RunVmParams runVmParameters) {
    getVm().setInitrdUrl(runVmParameters.getInitrdUrl());
    getVm().setKernelUrl(runVmParameters.getKernelUrl());
    getVm().setKernelParams(runVmParameters.getKernelParams());
    getVm().setCustomProperties(runVmParameters.getCustomProperties());
    getVm().setBootSequence((runVmParameters.getBootSequence() != null) ? runVmParameters.getBootSequence() : getVm().getDefaultBootSequence());
    getVm().setRunOnce(true);
}
#end_block

#method_before
@Override
protected void initVm() {
    super.initVm();
    if (getParameters().getVncKeyboardLayout() == null) {
        getVm().getDynamicData().setVncKeyboardLayout(getVm().getDefaultVncKeyboardLayout());
    } else {
        // if is not null it means runVM was launch from the run once command, thus
        // the VM can run with keyboard layout type which is different from its default display type
        getVm().getDynamicData().setVncKeyboardLayout(getParameters().getVncKeyboardLayout());
    }
}
#method_after
@Override
protected void initVm() {
    super.initVm();
    if (getParameters().getVncKeyboardLayout() == null) {
        getVm().getDynamicData().setVncKeyboardLayout(getVm().getDefaultVncKeyboardLayout());
    } else {
        // if is not null it means runVM was launch from the run once command, thus
        // the VM can run with keyboard layout type which is different from its default display type
        getVm().getDynamicData().setVncKeyboardLayout(getParameters().getVncKeyboardLayout());
    }
    if (getParameters().getVmInit() != null) {
        getVm().setVmInit(getParameters().getVmInit());
    }
}
#end_block

#method_before
private SnapshotDao getSnapshotDao() {
    return DbFacade.getInstance().getSnapshotDao();
}
#method_after
private SnapshotDao getSnapshotDao() {
    return getDbFacade().getSnapshotDao();
}
#end_block

#method_before
protected void refreshBootParameters(RunVmParams runVmParameters) {
    if (runVmParameters == null) {
        return;
    }
    getVm().setBootSequence(getVm().getDefaultBootSequence());
}
#method_after
protected void refreshBootParameters(RunVmParams runVmParameters) {
    getVm().setBootSequence(getVm().getDefaultBootSequence());
    getVm().setRunOnce(false);
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            VmHandler.updateVmGuestAgentVersion(getVm());
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        setCommandShouldBeLogged(false);
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to
    // configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    initVm();
    perform();
}
#method_after
@Override
protected void executeVmCommand() {
    setActionReturnValue(VMStatus.Down);
    initVm();
    perform();
}
#end_block

#method_before
private String chooseCd() {
    if (!StringUtils.isEmpty(getParameters().getDiskPath())) {
        return getParameters().getDiskPath();
    }
    if (getVm().getBootSequence() != null && getVm().getBootSequence().containsSubsequence(BootSequence.D)) {
        return getVm().getIsoPath();
    }
    String guestToolPath = guestToolsVersionTreatment();
    if (guestToolPath != null) {
        return guestToolPath;
    }
    return getVm().getIsoPath();
}
#method_after
private String chooseCd() {
    if (getParameters().getDiskPath() != null) {
        return getParameters().getDiskPath();
    }
    if (getVm().getBootSequence() != null && getVm().getBootSequence().containsSubsequence(BootSequence.D)) {
        return getVm().getIsoPath();
    }
    String guestToolPath = guestToolsVersionTreatment();
    if (guestToolPath != null) {
        return guestToolPath;
    }
    return getVm().getIsoPath();
}
#end_block

#method_before
protected VMStatus createVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    getVm().setLastStartTime(new Date());
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.infoFormat("Running VM with attached cd {0}", cdPath);
    }
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initCreateVmParams(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotIrrelevant = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.infoFormat("Running VM with attached cd {0}", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
protected void initVm() {
    if (!EnumSet.of(RunVmFlow.RUN, RunVmFlow.RESUME_HIBERNATE).contains(getFlow())) {
        return;
    }
    fetchVmDisksFromDb();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (!getVm().getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void runningFailed() {
    if (memoryFromSnapshotIrrelevant) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#method_after
@Override
protected void runningFailed() {
    if (memoryFromSnapshotUsed) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#end_block

#method_before
private void removeMemoryFromActiveSnapshot() {
    if (memoryVolumeFromSnapshot.isEmpty()) {
        return;
    }
    // If the active snapshot is the only one that points to the memory volume we can remove it
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolumeFromSnapshot) == 1) {
        removeMemoryVolumes(memoryVolumeFromSnapshot, getActionType(), true);
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
}
#method_after
private void removeMemoryFromActiveSnapshot() {
    if (StringUtils.isEmpty(cachedMemoryVolumeFromSnapshot)) {
        return;
    }
    // If the active snapshot is the only one that points to the memory volume we can remove it
    if (getSnapshotDao().getNumOfSnapshotsByMemory(cachedMemoryVolumeFromSnapshot) == 1) {
        removeMemoryVolumes(cachedMemoryVolumeFromSnapshot, getActionType(), true);
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
}
#end_block

#method_before
public EntityModel getAttachFloppy() {
    return privateAttachFloppy;
}
#method_after
public EntityModel<Boolean> getAttachFloppy() {
    return privateAttachFloppy;
}
#end_block

#method_before
private void setAttachFloppy(EntityModel value) {
    privateAttachFloppy = value;
}
#method_after
private void setAttachFloppy(EntityModel<Boolean> value) {
    privateAttachFloppy = value;
}
#end_block

#method_before
public ListModel getFloppyImage() {
    return privateFloppyImage;
}
#method_after
public ListModel<String> getFloppyImage() {
    return privateFloppyImage;
}
#end_block

#method_before
private void setFloppyImage(ListModel value) {
    privateFloppyImage = value;
}
#method_after
private void setFloppyImage(ListModel<String> value) {
    privateFloppyImage = value;
}
#end_block

#method_before
public EntityModel getAttachIso() {
    return privateAttachIso;
}
#method_after
public EntityModel<Boolean> getAttachIso() {
    return privateAttachIso;
}
#end_block

#method_before
private void setAttachIso(EntityModel value) {
    privateAttachIso = value;
}
#method_after
private void setAttachIso(EntityModel<Boolean> value) {
    privateAttachIso = value;
}
#end_block

#method_before
public ListModel getIsoImage() {
    return privateIsoImage;
}
#method_after
public ListModel<String> getIsoImage() {
    return privateIsoImage;
}
#end_block

#method_before
private void setIsoImage(ListModel value) {
    privateIsoImage = value;
}
#method_after
private void setIsoImage(ListModel<String> value) {
    privateIsoImage = value;
}
#end_block

#method_before
public ListModel getDisplayProtocol() {
    return privateDisplayProtocol;
}
#method_after
public ListModel<EntityModel<DisplayType>> getDisplayProtocol() {
    return privateDisplayProtocol;
}
#end_block

#method_before
private void setDisplayProtocol(ListModel value) {
    privateDisplayProtocol = value;
}
#method_after
private void setDisplayProtocol(ListModel<EntityModel<DisplayType>> value) {
    privateDisplayProtocol = value;
}
#end_block

#method_before
public EntityModel getInitrd_path() {
    return privateInitrd_path;
}
#method_after
public EntityModel<String> getInitrd_path() {
    return privateInitrd_path;
}
#end_block

#method_before
private void setInitrd_path(EntityModel value) {
    privateInitrd_path = value;
}
#method_after
private void setInitrd_path(EntityModel<String> value) {
    privateInitrd_path = value;
}
#end_block

#method_before
public EntityModel getKernel_path() {
    return privateKernel_path;
}
#method_after
public EntityModel<String> getKernel_path() {
    return privateKernel_path;
}
#end_block

#method_before
private void setKernel_path(EntityModel value) {
    privateKernel_path = value;
}
#method_after
private void setKernel_path(EntityModel<String> value) {
    privateKernel_path = value;
}
#end_block

#method_before
public EntityModel getKernel_parameters() {
    return privateKernel_parameters;
}
#method_after
public EntityModel<String> getKernel_parameters() {
    return privateKernel_parameters;
}
#end_block

#method_before
private void setKernel_parameters(EntityModel value) {
    privateKernel_parameters = value;
}
#method_after
private void setKernel_parameters(EntityModel<String> value) {
    privateKernel_parameters = value;
}
#end_block

#method_before
public ListModel getSysPrepDomainName() {
    return privateSysPrepDomainName;
}
#method_after
public ListModel<String> getSysPrepDomainName() {
    return privateSysPrepDomainName;
}
#end_block

#method_before
private void setSysPrepDomainName(ListModel value) {
    privateSysPrepDomainName = value;
}
#method_after
private void setSysPrepDomainName(ListModel<String> value) {
    privateSysPrepDomainName = value;
}
#end_block

#method_before
public EntityModel getSysPrepSelectedDomainName() {
    return privateSysPrepSelectedDomainName;
}
#method_after
public EntityModel<String> getSysPrepSelectedDomainName() {
    return privateSysPrepSelectedDomainName;
}
#end_block

#method_before
private void setSysPrepSelectedDomainName(EntityModel value) {
    privateSysPrepSelectedDomainName = value;
}
#method_after
private void setSysPrepSelectedDomainName(EntityModel<String> value) {
    privateSysPrepSelectedDomainName = value;
}
#end_block

#method_before
public EntityModel getSysPrepUserName() {
    return privateSysPrepUserName;
}
#method_after
public EntityModel<String> getSysPrepUserName() {
    return privateSysPrepUserName;
}
#end_block

#method_before
private void setSysPrepUserName(EntityModel value) {
    privateSysPrepUserName = value;
}
#method_after
private void setSysPrepUserName(EntityModel<String> value) {
    privateSysPrepUserName = value;
}
#end_block

#method_before
public EntityModel getSysPrepPassword() {
    return privateSysPrepPassword;
}
#method_after
public EntityModel<String> getSysPrepPassword() {
    return privateSysPrepPassword;
}
#end_block

#method_before
private void setSysPrepPassword(EntityModel value) {
    privateSysPrepPassword = value;
}
#method_after
private void setSysPrepPassword(EntityModel<String> value) {
    privateSysPrepPassword = value;
}
#end_block

#method_before
public EntityModel getUseAlternateCredentials() {
    return privateUseAlternateCredentials;
}
#method_after
public EntityModel<Boolean> getUseAlternateCredentials() {
    return privateUseAlternateCredentials;
}
#end_block

#method_before
private void setUseAlternateCredentials(EntityModel value) {
    privateUseAlternateCredentials = value;
}
#method_after
private void setUseAlternateCredentials(EntityModel<Boolean> value) {
    privateUseAlternateCredentials = value;
}
#end_block

#method_before
public EntityModel getIsSysprepEnabled() {
    return privateIsSysprepEnabled;
}
#method_after
public EntityModel<Boolean> getIsSysprepEnabled() {
    return privateIsSysprepEnabled;
}
#end_block

#method_before
private void setIsSysprepEnabled(EntityModel value) {
    privateIsSysprepEnabled = value;
}
#method_after
private void setIsSysprepEnabled(EntityModel<Boolean> value) {
    privateIsSysprepEnabled = value;
}
#end_block

#method_before
public EntityModel getIsSysprepPossible() {
    return privateIsSysprepPossible;
}
#method_after
public EntityModel<Boolean> getIsSysprepPossible() {
    return privateIsSysprepPossible;
}
#end_block

#method_before
private void setIsSysprepPossible(EntityModel value) {
    privateIsSysprepPossible = value;
}
#method_after
private void setIsSysprepPossible(EntityModel<Boolean> value) {
    privateIsSysprepPossible = value;
}
#end_block

#method_before
public EntityModel getIsVmFirstRun() {
    return privateIsVmFirstRun;
}
#method_after
public EntityModel<Boolean> getIsVmFirstRun() {
    return privateIsVmFirstRun;
}
#end_block

#method_before
private void setIsVmFirstRun(EntityModel value) {
    privateIsVmFirstRun = value;
}
#method_after
private void setIsVmFirstRun(EntityModel<Boolean> value) {
    privateIsVmFirstRun = value;
}
#end_block

#method_before
public EntityModel getIsLinuxOptionsAvailable() {
    return privateIsLinuxOptionsAvailable;
}
#method_after
public EntityModel<Boolean> getIsLinuxOptionsAvailable() {
    return privateIsLinuxOptionsAvailable;
}
#end_block

#method_before
private void setIsLinuxOptionsAvailable(EntityModel value) {
    privateIsLinuxOptionsAvailable = value;
}
#method_after
private void setIsLinuxOptionsAvailable(EntityModel<Boolean> value) {
    privateIsLinuxOptionsAvailable = value;
}
#end_block

#method_before
public EntityModel getIsCloudInitEnabled() {
    return privateIsCloudInitEnabled;
}
#method_after
public EntityModel<Boolean> getIsCloudInitEnabled() {
    return privateIsCloudInitEnabled;
}
#end_block

#method_before
private void setIsCloudInitEnabled(EntityModel value) {
    privateIsCloudInitEnabled = value;
}
#method_after
private void setIsCloudInitEnabled(EntityModel<Boolean> value) {
    privateIsCloudInitEnabled = value;
}
#end_block

#method_before
public EntityModel getIsCloudInitPossible() {
    return privateIsCloudInitPossible;
}
#method_after
public EntityModel<Boolean> getIsCloudInitPossible() {
    return privateIsCloudInitPossible;
}
#end_block

#method_before
private void setIsCloudInitPossible(EntityModel value) {
    privateIsCloudInitPossible = value;
}
#method_after
private void setIsCloudInitPossible(EntityModel<Boolean> value) {
    privateIsCloudInitPossible = value;
}
#end_block

#method_before
public EntityModel getRunAndPause() {
    return privateRunAndPause;
}
#method_after
public EntityModel<Boolean> getRunAndPause() {
    return privateRunAndPause;
}
#end_block

#method_before
public void setRunAndPause(EntityModel value) {
    privateRunAndPause = value;
}
#method_after
public void setRunAndPause(EntityModel<Boolean> value) {
    privateRunAndPause = value;
}
#end_block

#method_before
public EntityModel getRunAsStateless() {
    return privateRunAsStateless;
}
#method_after
public EntityModel<Boolean> getRunAsStateless() {
    return privateRunAsStateless;
}
#end_block

#method_before
public void setRunAsStateless(EntityModel value) {
    privateRunAsStateless = value;
}
#method_after
public void setRunAsStateless(EntityModel<Boolean> value) {
    privateRunAsStateless = value;
}
#end_block

#method_before
public EntityModel getDisplayConsole_Vnc_IsSelected() {
    return privateDisplayConsole_Vnc_IsSelected;
}
#method_after
public EntityModel<Boolean> getDisplayConsole_Vnc_IsSelected() {
    return privateDisplayConsole_Vnc_IsSelected;
}
#end_block

#method_before
public void setDisplayConsole_Vnc_IsSelected(EntityModel value) {
    privateDisplayConsole_Vnc_IsSelected = value;
}
#method_after
public void setDisplayConsole_Vnc_IsSelected(EntityModel<Boolean> value) {
    privateDisplayConsole_Vnc_IsSelected = value;
}
#end_block

#method_before
public EntityModel getDisplayConsole_Spice_IsSelected() {
    return privateDisplayConsole_Spice_IsSelected;
}
#method_after
public EntityModel<Boolean> getDisplayConsole_Spice_IsSelected() {
    return privateDisplayConsole_Spice_IsSelected;
}
#end_block

#method_before
public void setDisplayConsole_Spice_IsSelected(EntityModel value) {
    privateDisplayConsole_Spice_IsSelected = value;
}
#method_after
public void setDisplayConsole_Spice_IsSelected(EntityModel<Boolean> value) {
    privateDisplayConsole_Spice_IsSelected = value;
}
#end_block

#method_before
public ListModel getDefaultHost() {
    return defaultHost;
}
#method_after
public ListModel<VDS> getDefaultHost() {
    return defaultHost;
}
#end_block

#method_before
private void setDefaultHost(ListModel value) {
    this.defaultHost = value;
}
#method_after
private void setDefaultHost(ListModel<VDS> value) {
    this.defaultHost = value;
}
#end_block

#method_before
public EntityModel getIsAutoAssign() {
    return isAutoAssign;
}
#method_after
public EntityModel<Boolean> getIsAutoAssign() {
    return isAutoAssign;
}
#end_block

#method_before
public void setIsAutoAssign(EntityModel value) {
    this.isAutoAssign = value;
}
#method_after
public void setIsAutoAssign(EntityModel<Boolean> value) {
    this.isAutoAssign = value;
}
#end_block

#method_before
// The "sysprep" option was moved from a standalone check box to a
// pseudo floppy disk image. In order not to change the back-end
// interface, the Reinitialize variable was changed to a read-only
// property and its value is based on the selected floppy image.
// A similar comparison is done for cloud-init iso images, so the
public InitializationType getInitializationType() {
    if (getAttachFloppy().getEntity() != null && (Boolean) getAttachFloppy().getEntity() && "[sysprep]".equals(getFloppyImage().getSelectedItem())) {
        // $NON-NLS-1$
        return InitializationType.Sysprep;
    } else if (getIsCloudInitEnabled().getEntity() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        return InitializationType.CloudInit;
    } else {
        return InitializationType.None;
    }
}
#method_after
// The "sysprep" option was moved from a standalone check box to a
// pseudo floppy disk image. In order not to change the back-end
// interface, the Reinitialize variable was changed to a read-only
// property and its value is based on the selected floppy image.
// A similar comparison is done for cloud-init iso images, so the
public InitializationType getInitializationType() {
    if (getAttachFloppy().getEntity() != null && getAttachFloppy().getEntity() && "[sysprep]".equals(getFloppyImage().getSelectedItem())) {
        // $NON-NLS-1$
        return InitializationType.Sysprep;
    } else if (getIsCloudInitEnabled().getEntity() != null && getIsCloudInitEnabled().getEntity()) {
        return InitializationType.CloudInit;
    } else {
        return InitializationType.None;
    }
}
#end_block

#method_before
public String getFloppyImagePath() {
    if ((Boolean) getAttachFloppy().getEntity()) {
        return getInitializationType() == InitializationType.Sysprep ? "" : // $NON-NLS-1$
        (String) getFloppyImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#method_after
public String getFloppyImagePath() {
    if (getAttachFloppy().getEntity()) {
        return getInitializationType() == InitializationType.Sysprep ? "" : // $NON-NLS-1$
        getFloppyImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#end_block

#method_before
public String getIsoImagePath() {
    if ((Boolean) getAttachIso().getEntity()) {
        return (String) getIsoImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#method_after
public String getIsoImagePath() {
    if (getAttachIso().getEntity()) {
        return getIsoImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && (Boolean) getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc(displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if (getDisplayConsole_Vnc_IsSelected().getEntity() || getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc(getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#end_block

#method_before
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = (ArrayList<Disk>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#method_after
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#end_block

#method_before
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = (Collection<VmNetworkInterface>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !((List<VmNetworkInterface>) pluggedNics).isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#method_after
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !pluggedNics.isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#end_block

#method_before
public void updateIsoList(boolean forceRefresh) {
    AsyncDataProvider.getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            getIsoImage().setItems(images);
            if (getIsoImage().getIsChangable() && getIsoImage().getSelectedItem() == null) {
                getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    }), vm.getStoragePoolId(), forceRefresh);
}
#method_after
public void updateIsoList(boolean forceRefresh) {
    AsyncDataProvider.getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            final String lastSelectedIso = getIsoImage().getSelectedItem();
            getIsoImage().setItems(images);
            if (getIsoImage().getIsChangable()) {
                // try to preselect last image
                if (lastSelectedIso != null && images.contains(lastSelectedIso)) {
                    getIsoImage().setSelectedItem(lastSelectedIso);
                } else {
                    getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
                }
            }
        }
    }), vm.getStoragePoolId(), forceRefresh);
}
#end_block

#method_before
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> domains = (List<String>) returnValue;
            String oldDomain = (String) getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }), true);
}
#method_after
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> domains = (List<String>) returnValue;
            String oldDomain = getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }), true);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable((Boolean) getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable((Boolean) getAttachIso().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable(getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable(getAttachIso().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable((Boolean) getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable(getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = (Boolean) getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable((Boolean) getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable((Boolean) getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
}
#method_after
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable(getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable(getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
}
#end_block

#method_before
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#method_after
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if (getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#end_block

#method_before
public boolean validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && (Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid;
}
#method_after
public boolean validate() {
    getIsoImage().setIsValid(true);
    if (getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if (getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid;
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    final VM vm = getParameters().getVm();
    if (canExecute() && ResourceManager.getInstance().AddAsyncRunningVm(vm.getId())) {
        CreateVDSCommand<?> command = null;
        try {
            command = initCreateVDSCommand(vm);
            command.execute();
            if (command.getVDSReturnValue().getSucceeded()) {
                saveSetInitializedToDb(vm.getId());
                vm.setInitialized(true);
                vm.setRunOnVds(getVdsId());
                if (getParameters().isClearHibernationVolumes()) {
                    vm.setHibernationVolHandle(StringUtils.EMPTY);
                }
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
            } else {
                handleCommandResult(command);
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
        } catch (java.lang.Exception e) {
            log.error("Error in excuting CreateVmVDSCommand", e);
            if (command != null && !command.getVDSReturnValue().getSucceeded()) {
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
            throw new RuntimeException(e);
        }
    }
    getVDSReturnValue().setReturnValue(vm.getStatus());
}
#method_after
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    final VM vm = getParameters().getVm();
    vm.setLastStartTime(new Date());
    // if the VM is not suspended, it means that if there is 'hibernation volume'
    // set, it is actually memory from snapshot, thus it should be cleared right
    // after the VM started
    final boolean clearHibernationVolume = vm.getStatus() != VMStatus.Suspended;
    if (canExecute() && ResourceManager.getInstance().AddAsyncRunningVm(vm.getId())) {
        CreateVDSCommand<?> command = null;
        try {
            command = initCreateVDSCommand(vm);
            command.execute();
            if (command.getVDSReturnValue().getSucceeded()) {
                saveSetInitializedToDb(vm.getId());
                vm.setInitialized(true);
                vm.setRunOnVds(getVdsId());
                if (clearHibernationVolume) {
                    vm.setHibernationVolHandle(StringUtils.EMPTY);
                }
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
            } else {
                handleCommandResult(command);
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
        } catch (Exception e) {
            log.error("Error in excuting CreateVmVDSCommand", e);
            if (command != null && !command.getVDSReturnValue().getSucceeded()) {
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
            throw new RuntimeException(e);
        }
    }
    getVDSReturnValue().setReturnValue(vm.getStatus());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGuestSessions(vm, sessions);
    return sessions;
}
#end_block

#method_before
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        if (vm.getVmInit() != null) {
            sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", vm.getVmInit().getInputLocale() != null ? vm.getVmInit().getInputLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$InputLocale$", vm.getVmInit().getInputLocale() != null ? vm.getVmInit().getInputLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$UiLanguage$", vm.getVmInit().getUiLanguage() != null ? vm.getVmInit().getUiLanguage() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$SystemLocale$", vm.getVmInit().getSystemLocale() != null ? vm.getVmInit().getSystemLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$UserLocale$", vm.getVmInit().getUserLocale() != null ? vm.getVmInit().getUserLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
        }
    }
    return sysPrepContent;
}
#method_after
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        if (vm.getVmInit() != null) {
            if (vm.getVmInit().getInputLocale() != null) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (vm.getVmInit().getUiLanguage() != null) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (vm.getVmInit().getSystemLocale() != null) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (vm.getVmInit().getUserLocale() != null) {
                userLocale = vm.getVmInit().getUserLocale();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
    }
    return sysPrepContent;
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation() })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<Object>();
    networkNameEditor = new EntityModelTextBoxEditor();
    networkComboBox = new ComboBox(networkListEditor, networkNameEditor);
}
#method_after
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<String>();
    networkNameEditor = new StringEntityModelTextBoxEditor();
    networkComboBox = new ComboBox<String>(networkListEditor, networkNameEditor);
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !(Boolean) model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#end_block

#method_before
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled((Boolean) model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled((Boolean) model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = (Boolean) model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#method_after
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled(model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled(model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#end_block

#method_before
private void storeNetwork() throws UnsupportedEncodingException {
    StringBuilder output = new StringBuilder();
    if (vmInit.getNetworks() != null) {
        List<VmInitNetwork> networks = vmInit.getNetworks();
        for (VmInitNetwork iface : networks) {
            output.append("iface " + iface.getName() + " inet " + iface.getBootProtocol().getDisplayName() + "\n");
            if (!StringUtils.isEmpty(iface.getIp())) {
                output.append("  address " + iface.getIp() + "\n");
            }
            if (!StringUtils.isEmpty(iface.getNetmask())) {
                output.append("  netmask " + iface.getNetmask() + "\n");
            }
            if (!StringUtils.isEmpty(iface.getGateway())) {
                output.append("  gateway " + iface.getGateway() + "\n");
            }
            // As of cloud-init 0.7.1, you can't set DNS servers without also setting NICs
            if (vmInit.getDnsServers() != null) {
                output.append("  dns-nameservers").append(" ").append(vmInit.getDnsServers());
                output.append("\n");
            }
            if (vmInit.getDnsSearch() != null) {
                output.append("  dns-search").append(" ").append(vmInit.getDnsSearch());
                output.append("\n");
            }
        }
        output.append("auto");
        for (VmInitNetwork iface : networks) {
            output.append(" " + iface.getName());
        }
        output.append("\n");
    }
    interfaces = output.toString();
    if (!interfaces.isEmpty()) {
        // Workaround for cloud-init 0.6.3, which requires the "network-interfaces"
        // meta-data entry instead of the "network_config" file reference
        metaData.put("network-interfaces", interfaces);
        // Cloud-init will translate this as needed for ifcfg-based systems
        storeNextFile(CloudInitFileMode.NETWORK, "/etc/network/interfaces", interfaces.getBytes("US-ASCII"));
    }
}
#method_after
private void storeNetwork() throws UnsupportedEncodingException {
    StringBuilder output = new StringBuilder();
    if (vmInit.getNetworks() != null) {
        List<VmInitNetwork> networks = vmInit.getNetworks();
        for (VmInitNetwork iface : networks) {
            output.append("iface " + iface.getName() + " inet " + iface.getBootProtocol().getDisplayName() + "\n");
            if (StringUtils.isNotEmpty(iface.getIp())) {
                output.append("  address " + iface.getIp() + "\n");
            }
            if (StringUtils.isNotEmpty(iface.getNetmask())) {
                output.append("  netmask " + iface.getNetmask() + "\n");
            }
            if (StringUtils.isNotEmpty(iface.getGateway())) {
                output.append("  gateway " + iface.getGateway() + "\n");
            }
            // As of cloud-init 0.7.1, you can't set DNS servers without also setting NICs
            if (vmInit.getDnsServers() != null) {
                output.append("  dns-nameservers").append(" ").append(vmInit.getDnsServers());
                output.append("\n");
            }
            if (vmInit.getDnsSearch() != null) {
                output.append("  dns-search").append(" ").append(vmInit.getDnsSearch());
                output.append("\n");
            }
        }
        output.append("auto");
        for (VmInitNetwork iface : networks) {
            output.append(" " + iface.getName());
        }
        output.append("\n");
    }
    interfaces = output.toString();
    if (!interfaces.isEmpty()) {
        // Workaround for cloud-init 0.6.3, which requires the "network-interfaces"
        // meta-data entry instead of the "network_config" file reference
        metaData.put("network-interfaces", interfaces);
        // Cloud-init will translate this as needed for ifcfg-based systems
        storeNextFile(CloudInitFileMode.NETWORK, "/etc/network/interfaces", interfaces.getBytes("US-ASCII"));
    }
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getUserName() {
    return privateUserName;
}
#method_after
public EntityModel<String> getUserName() {
    return privateUserName;
}
#end_block

#method_before
private void setUserName(EntityModel value) {
    privateUserName = value;
}
#method_after
private void setUserName(EntityModel<String> value) {
    privateUserName = value;
}
#end_block

#method_before
public EntityModel getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#method_after
public EntityModel<String> getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#end_block

#method_before
private void setActiveDirectoryOU(EntityModel value) {
    privateActiveDirectoryOU = value;
}
#method_after
private void setActiveDirectoryOU(EntityModel<String> value) {
    privateActiveDirectoryOU = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public EntityModel getSysprepScript() {
    return privateSysprepScript;
}
#method_after
public EntityModel<String> getSysprepScript() {
    return privateSysprepScript;
}
#end_block

#method_before
private void setSysprepScript(EntityModel value) {
    privateSysprepScript = value;
}
#method_after
private void setSysprepScript(EntityModel<String> value) {
    privateSysprepScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.STATIC_IP);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.STATIC_IP);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#end_block

#method_before
@Override
public Integer parse(CharSequence text) throws ParseException {
    // $NON-NLS-1$
    MatchResult match = RegExp.compile("^(\\d*)\\s*(\\w*)$").exec(text.toString());
    String prefix = match.getGroup(1);
    String suffix = match.getGroup(2);
    Integer size = null;
    try {
        size = Integer.parseInt(prefix);
    } catch (NumberFormatException e) {
        return 0;
    }
    if (suffix.equalsIgnoreCase("TB") || suffix.equalsIgnoreCase("T")) {
        // $NON-NLS-1$ $NON-NLS-2$
        size *= 1024 * 1024;
        return size;
    }
    if (suffix.equalsIgnoreCase("GB") || suffix.equalsIgnoreCase("G")) {
        // $NON-NLS-1$ $NON-NLS-2$
        size *= 1024;
        return size;
    }
    if (suffix.equalsIgnoreCase("MB") || suffix.equalsIgnoreCase("M")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size;
    }
    return size;
}
#method_after
@Override
public Integer parse(CharSequence text) throws ParseException {
    // $NON-NLS-1$
    MatchResult match = RegExp.compile("^(\\d*)\\s*(\\w*)$").exec(text.toString());
    if (match == null) {
        return 0;
    }
    String prefix = match.getGroup(1);
    String suffix = match.getGroup(2);
    Integer size = null;
    try {
        size = Integer.parseInt(prefix);
    } catch (NumberFormatException e) {
        return 0;
    }
    if (suffix.equalsIgnoreCase("TB") || suffix.equalsIgnoreCase("T")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size * 1024 * 1024;
    } else if (suffix.equalsIgnoreCase("GB") || suffix.equalsIgnoreCase("G")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size * 1024;
    } else if (suffix.equalsIgnoreCase("MB") || suffix.equalsIgnoreCase("M")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size;
    } else if (StringHelper.isNullOrEmpty(suffix)) {
        return size;
    } else {
        // disallow garbled suffixes
        return 0;
    }
}
#end_block

#method_before
public void setBootTime(Date value) {
    if (bootTime != value) {
        bootTime = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("bootTime"));
    }
}
#method_after
public void setBootTime(Long value) {
    /* Factor by 1000 since Date works with millis since epoch and we store seconds (as provided by machines) */
    if (value == null) {
        if (bootTime == null) {
            return;
        }
        bootTime = null;
    } else {
        if (bootTime == null) {
            bootTime = new Date(value * 1000);
        } else if ((bootTime.getTime() / 1000) != value) {
            bootTime.setTime(value * 1000);
        } else {
            return;
        }
    }
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("bootTime"));
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime(rs.getTimestamp("boot_time"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    return entity;
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#end_block

#method_before
public Date getBootTime() {
    return this.mVdsDynamic.getboot_time();
}
#method_after
public Long getBootTime() {
    return this.mVdsStatistics.getboot_time();
}
#end_block

#method_before
public void setBootTime(Date value) {
    this.mVdsDynamic.setboot_time(value);
}
#method_after
public void setBootTime(Long value) {
    this.mVdsStatistics.setboot_time(value);
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    } else {
        vm.setCurrentCd(null);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignDatetimeValue(xmlRpcStruct, VdsProperties.bootTime));
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignDatetimeValue(xmlRpcStruct, VdsProperties.bootTime));
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePoolId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().get(getStorageDomainId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(storageDomainId, storagePoolId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().get(storageDomainId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Test
public void testGetUnregisteredDisks() {
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDAOMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDAOMock.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    // Execute query
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Disk> newDisks = (List<Disk>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(newDisks.size(), 1);
    assertEquals(newDisks.get(0).getId(), importDiskId);
}
#method_after
@Test
public void testGetUnregisteredDisks() {
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDAOMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDAOMock.get(storageDomainId)).thenReturn(storageDomain);
    // Execute query
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Disk> newDisks = (List<Disk>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(newDisks.size(), 1);
    assertEquals(newDisks.get(0).getId(), importDiskId);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    DbFacade dbFacade = getDbFacade();
    check(dbFacade.getVdsDao(), VdcActionType.ActivateVds, new DoWithClosure<VDS, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final VDS arg) {
            final VdsActionParameters params = new VdsActionParameters(arg.getId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> list) {
            List<VDS> filtered = new ArrayList<>(list.size());
            for (VDS vds : list) {
                Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId()), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
                if (problematicNics.getFirst().isEmpty()) {
                    filtered.add(vds);
                }
            }
            return filtered;
        }
    }, "hosts");
    check(dbFacade.getStorageDomainDao(), VdcActionType.ConnectDomainToStorage, new DoWithClosure<StorageDomain, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final StorageDomain arg) {
            final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(arg.getId(), arg.getStoragePoolId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<StorageDomain>() {

        @Override
        public List<StorageDomain> filter(List<StorageDomain> list) {
            return list;
        }
    }, "storage domains");
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    DbFacade dbFacade = getDbFacade();
    check(dbFacade.getVdsDao(), VdcActionType.ActivateVds, new DoWithClosure<VDS, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final VDS arg) {
            final VdsActionParameters params = new VdsActionParameters(arg.getId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> list) {
            List<VDS> filtered = new ArrayList<>(list.size());
            List<VdsNetworkInterface> nics;
            for (VDS vds : list) {
                if (vds.getNonOperationalReason() == NonOperationalReason.NETWORK_INTERFACE_IS_DOWN) {
                    getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
                    nics = vds.getInterfaces();
                } else {
                    nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId());
                }
                Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(nics, getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
                if (problematicNics.getFirst().isEmpty()) {
                    filtered.add(vds);
                }
            }
            return filtered;
        }
    }, "hosts");
    check(dbFacade.getStorageDomainDao(), VdcActionType.ConnectDomainToStorage, new DoWithClosure<StorageDomain, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final StorageDomain arg) {
            final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(arg.getId(), arg.getStoragePoolId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<StorageDomain>() {

        @Override
        public List<StorageDomain> filter(List<StorageDomain> list) {
            return list;
        }
    }, "storage domains");
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
private boolean isHostNetworkUnreacable(VDS vds) {
    VdsDynamic vdsDynamic = vds.getDynamicData();
    return ((vdsDynamic.getStatus() == VDSStatus.Down) || (vdsDynamic.getStatus() == VDSStatus.Reboot) || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE));
}
#method_after
private boolean isHostNetworkUnreacable(VDS vds) {
    VdsDynamic vdsDynamic = vds.getDynamicData();
    return (vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(storageDomainId, storagePoolId) == null) {
        getQueryReturnValue().setExceptionString("Storage Domain does not exist in the Data Center");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(storageDomainId, storagePoolId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePoolId()) == null) {
        getQueryReturnValue().setExceptionString("Storage Domain does not exist in the Data Center");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePoolId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean canDo = true;
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
            canDo = failCanDoAction(VdcBllMessages.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
        canDo = failCanDoAction(VdcBllMessages.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    }
    return canDo;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean canDo = true;
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (getParameters().getVm().getNumOfCpus() > SlaValidator.getEffectiveCpuCores(getVds())) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CPUS);
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
            canDo = failCanDoAction(VdcBllMessages.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
        canDo = failCanDoAction(VdcBllMessages.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    }
    return canDo;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_SET_CPUS);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    addCanDoActionMessage(String.format("clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion()));
    addCanDoActionMessage(String.format("$architecture %1$s", getVm().getClusterArch()));
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_SET_CPUS);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion()));
    addCanDoActionMessage(String.format("$architecture %1$s", getVm().getClusterArch()));
}
#end_block

#method_before
public boolean getLegal() {
    if (getUseTimout()) {
        String keyForCheck = getkeyForCheck();
        if (!CacheManager.getTimeoutBaseCache().containsKey(keyForCheck)) {
            CacheManager.getTimeoutBaseCache().put(keyForCheck, keyForCheck, getEndTime(), TimeUnit.MILLISECONDS);
            return true;
        }
        return false;
    }
    return true;
}
#method_after
public boolean getLegal() {
    if (getUseTimout()) {
        String keyForCheck = getkeyForCheck();
        synchronized (keyForCheck.intern()) {
            if (!CacheManager.getTimeoutBaseCache().containsKey(keyForCheck)) {
                CacheManager.getTimeoutBaseCache().put(keyForCheck, keyForCheck, getEndTime(), TimeUnit.MILLISECONDS);
                return true;
            }
        }
        return false;
    }
    return true;
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        checkNetwrokInterfaceThreshold(iface, iface.getStatistics().getReceiveRate(), AuditLogType.RECEIVE_RATE);
        checkNetwrokInterfaceThreshold(iface, iface.getStatistics().getTransmitRate(), AuditLogType.TRANSMIT_RATE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", StringUtils.stripEnd(sNetworks.toString(), ", "));
                logable.addCustomValue("Interfaces", StringUtils.stripEnd(sNics.toString(), ", "));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (vm.getStatus() != VMStatus.WaitForLaunch) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VmInternalData runningVm : _runningVms.values()) {
        VmDynamic vmDynamic = runningVm.getVmDynamic();
        // we shouldn't include them as committed.
        if (vmDynamic.getStatus() != VMStatus.WaitForLaunch && vmDynamic.getStatus() != VMStatus.Down) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                memCommited += vm.getVmMemSizeMb();
                memCommited += _vds.getGuestOverhead();
                vmsCoresCount += vm.getNumOfCpus();
            }
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

