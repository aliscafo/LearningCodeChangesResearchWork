613
#method_before
@Override
public void onCreate(final Bundle icicle) {
    super.onCreate(icicle);
    addPreferencesFromResource(R.xml.prefs_screen_correction);
    final Context context = getActivity();
    final PackageManager pm = context.getPackageManager();
    final Preference dictionaryLink = findPreference(Settings.PREF_CONFIGURE_DICTIONARIES_KEY);
    final Intent intent = dictionaryLink.getIntent();
    intent.setClassName(context.getPackageName(), DictionarySettingsActivity.class.getName());
    final int number = pm.queryIntentActivities(intent, 0).size();
    if (0 >= number) {
        removePreference(Settings.PREF_CONFIGURE_DICTIONARIES_KEY);
    }
    final Preference editPersonalDictionary = findPreference(Settings.PREF_EDIT_PERSONAL_DICTIONARY);
    final Intent editPersonalDictionaryIntent = editPersonalDictionary.getIntent();
    final ResolveInfo ri = USE_INTERNAL_PERSONAL_DICTIONARY_SETTINGS ? null : pm.resolveActivity(editPersonalDictionaryIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (ri == null) {
        overwriteUserDictionaryPreference(editPersonalDictionary);
    }
    mUseContactsPreference = (SwitchPreference) findPreference(Settings.PREF_KEY_USE_CONTACTS_DICT);
    turnOffUseContactsIfNoPermission();
    final SwitchPreference suggestionsEnabledPreference = (SwitchPreference) findPreference(Settings.PREF_SHOW_SUGGESTIONS);
    final SettingsValues currentSettings = Settings.getInstance().getCurrent();
    if (suggestionsEnabledPreference != null && currentSettings != null) {
        suggestionsEnabledPreference.setChecked(currentSettings.isSuggestionsEnabledPerUserSettings());
    }
}
#method_after
@Override
public void onCreate(final Bundle icicle) {
    super.onCreate(icicle);
    addPreferencesFromResource(R.xml.prefs_screen_correction);
    final Context context = getActivity();
    final PackageManager pm = context.getPackageManager();
    final Preference dictionaryLink = findPreference(Settings.PREF_CONFIGURE_DICTIONARIES_KEY);
    final Intent intent = dictionaryLink.getIntent();
    intent.setClassName(context.getPackageName(), DictionarySettingsActivity.class.getName());
    final int number = pm.queryIntentActivities(intent, 0).size();
    if (0 >= number) {
        removePreference(Settings.PREF_CONFIGURE_DICTIONARIES_KEY);
    }
    final Preference editPersonalDictionary = findPreference(Settings.PREF_EDIT_PERSONAL_DICTIONARY);
    final Intent editPersonalDictionaryIntent = editPersonalDictionary.getIntent();
    final ResolveInfo ri = USE_INTERNAL_PERSONAL_DICTIONARY_SETTINGS ? null : pm.resolveActivity(editPersonalDictionaryIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (ri == null) {
        overwriteUserDictionaryPreference(editPersonalDictionary);
    }
    mUseContactsPreference = (SwitchPreference) findPreference(Settings.PREF_KEY_USE_CONTACTS_DICT);
    turnOffUseContactsIfNoPermission();
}
#end_block

#method_before
@Override
public boolean onPreferenceChange(Preference preference, Object o) {
    switch(preference.getKey()) {
        case API_KEY_KEY:
            Editable editText = mApiKeyPreference.getEditText().getText();
            String text = editText.toString();
            if (!TextUtils.isEmpty(text)) {
                SharedPreferences.Editor editor = getSharedPreferences().edit();
                editor.putString(WundergroundModule.API_KEY, text);
                editor.commit();
                mWundergroundServiceManager.updateApiKey(text);
                Message verifyApiKeyMessage = mHandler.obtainMessage();
                verifyApiKeyMessage.sendToTarget();
            } else {
                failedVerification();
            }
            return true;
    }
    return false;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object o) {
    switch(preference.getKey()) {
        case API_KEY_KEY:
            Editable editText = mApiKeyPreference.getEditText().getText();
            String text = editText.toString();
            if (!TextUtils.isEmpty(text)) {
                SharedPreferences.Editor editor = getSharedPreferences().edit();
                editor.putString(WundergroundModule.API_KEY, text);
                editor.commit();
                mWundergroundServiceManager.updateApiKey(text);
                Message verifyApiKeyMessage = mHandler.obtainMessage();
                verifyApiKeyMessage.sendToTarget();
            } else {
                passedVerification(false);
            }
            return true;
    }
    return false;
}
#end_block

#method_before
private void verifyReceivedWeatherInfoByPostalCode() {
    WeatherLocation weatherLocation = new WeatherLocation.Builder("Seattle").setPostalCode("98121").setCountry("US").setState("WA").build();
    Call<WundergroundReponse> wundergroundCall = mWundergroundServiceManager.query(weatherLocation.getPostalCode(), Feature.conditions, Feature.forecast);
    Log.d(TAG, "Enqueue api request...");
    wundergroundCall.enqueue(new retrofit2.Callback<WundergroundReponse>() {

        @Override
        public void onResponse(Call<WundergroundReponse> call, Response<WundergroundReponse> response) {
            Log.d(TAG, "Response " + response.toString());
            if (response.isSuccessful()) {
                WundergroundReponse wundergroundReponse = response.body();
                if (wundergroundReponse == null) {
                    failedVerification();
                    return;
                }
                CurrentObservationResponse currentObservationResponse = wundergroundReponse.getCurrentObservation();
                if (currentObservationResponse == null) {
                    failedVerification();
                } else {
                    passedVerification();
                }
            } else {
                failedVerification();
            }
        }

        @Override
        public void onFailure(Call<WundergroundReponse> call, Throwable t) {
            Log.d(TAG, "Response " + t.toString());
            failedVerification();
        }
    });
}
#method_after
private void verifyReceivedWeatherInfoByPostalCode() {
    WeatherLocation weatherLocation = new WeatherLocation.Builder("Seattle").setPostalCode("98121").setCountry("US").setState("WA").build();
    Call<WundergroundReponse> wundergroundCall = mWundergroundServiceManager.query(weatherLocation.getPostalCode(), Feature.conditions, Feature.forecast);
    Log.d(TAG, "Enqueue api request...");
    wundergroundCall.enqueue(new retrofit2.Callback<WundergroundReponse>() {

        @Override
        public void onResponse(Call<WundergroundReponse> call, Response<WundergroundReponse> response) {
            Log.d(TAG, "Response " + response.toString());
            if (response.isSuccessful()) {
                WundergroundReponse wundergroundReponse = response.body();
                if (wundergroundReponse == null) {
                    passedVerification(false);
                    return;
                }
                CurrentObservationResponse currentObservationResponse = wundergroundReponse.getCurrentObservation();
                if (currentObservationResponse == null) {
                    passedVerification(false);
                } else {
                    passedVerification(true);
                }
            } else {
                passedVerification(false);
            }
        }

        @Override
        public void onFailure(Call<WundergroundReponse> call, Throwable t) {
            Log.d(TAG, "Response " + t.toString());
            passedVerification(false);
        }
    });
}
#end_block

#method_before
private void passedVerification() {
    Log.d(TAG, "Passed verification");
    final SharedPreferences.Editor editor = getSharedPreferences().edit();
    editor.putBoolean(WundergroundModule.API_KEY_VERIFIED, true);
    editor.apply();
    update();
}
#method_after
private void passedVerification(boolean passed) {
    Log.d(TAG, "Passed verification" + passed);
    final SharedPreferences.Editor editor = getSharedPreferences().edit();
    editor.putBoolean(WundergroundModule.API_KEY_VERIFIED, passed);
    editor.apply();
    update();
}
#end_block

#method_before
public static int convertWeatherConditionStringToWeatherConditionCode(String weatherCondition) {
    if (!TextUtils.isEmpty(weatherCondition) && mWeatherConditionStringToCode.get(weatherCondition) != null) {
        return mWeatherConditionStringToCode.get(weatherCondition);
    }
    return WeatherContract.WeatherColumns.WeatherCode.NOT_AVAILABLE;
}
#method_after
public static int convertWeatherConditionStringToWeatherConditionCode(String weatherCondition) {
    return sWeatherConditionStringToCode.containsKey(weatherCondition) ? sWeatherConditionStringToCode.get(weatherCondition) : WeatherContract.WeatherColumns.WeatherCode.NOT_AVAILABLE;
}
#end_block

#method_before
public boolean markRead(boolean read) {
    boolean changed = false;
    for (MessageInfo msg : messageInfos) {
        changed |= msg.markRead(read);
    }
    // message in this conversation. Otherwise firstSnippet = lastSnippet = firstUnreadSnippet
    if (messageCount > 0) {
        if (read) {
            firstSnippet = lastSnippet;
        } else {
            firstSnippet = firstUnreadSnippet;
        }
    }
    return changed;
}
#method_after
public boolean markRead(boolean read) {
    boolean changed = false;
    for (MessageInfo msg : messageInfos) {
        changed |= msg.markRead(read);
    }
    // Change the firstSnippet only if the conversion has messages.
    if (messageCount > 0) {
        if (read) {
            firstSnippet = lastSnippet;
        } else {
            firstSnippet = firstUnreadSnippet;
        }
    }
    return changed;
}
#end_block

#method_before
protected SavedWallpaperImages getSavedImages() {
    // for subclasses
    return null;
}
#method_after
protected SavedWallpaperImages getSavedImages() {
    // for subclasses
    throw new UnsupportedOperationException("Not implemented for WallpaperCropActivity");
}
#end_block

#method_before
protected CropView getCropView() {
    return null;
}
#method_after
protected CropView getCropView() {
    // for subclasses
    throw new UnsupportedOperationException("Not implemented for WallpaperCropActivity");
}
#end_block

#method_before
protected void onLiveWallpaperPickerLaunch() {
// for subclasses
}
#method_after
protected void onLiveWallpaperPickerLaunch() {
    // for subclasses
    throw new UnsupportedOperationException("Not implemented for WallpaperCropActivity");
}
#end_block

#method_before
private void updateProtectedAppsList() {
    String protectedComponents = Settings.Secure.getString(mLauncher.getContentResolver(), "protected_components");
    protectedComponents = protectedComponents == null ? "" : protectedComponents;
    String[] flattened = protectedComponents.split("\\|");
    mProtectedApps = new ArrayList<ComponentName>(flattened.length);
    mProtectedPackages = new ArrayList<String>(flattened.length);
    for (String flat : flattened) {
        ComponentName cmp = ComponentName.unflattenFromString(flat);
        if (cmp != null) {
            mProtectedApps.add(cmp);
            mProtectedPackages.add(cmp.getPackageName());
        }
    }
}
#method_after
private void updateProtectedAppsList(Context context) {
    String protectedComponents = Settings.Secure.getString(context.getContentResolver(), LauncherModel.SETTINGS_PROTECTED_COMPONENTS);
    protectedComponents = protectedComponents == null ? "" : protectedComponents;
    String[] flattened = protectedComponents.split("\\|");
    mProtectedApps = new ArrayList<ComponentName>(flattened.length);
    mProtectedPackages = new ArrayList<String>(flattened.length);
    for (String flat : flattened) {
        ComponentName cmp = ComponentName.unflattenFromString(flat);
        if (cmp != null) {
            mProtectedApps.add(cmp);
            mProtectedPackages.add(cmp.getPackageName());
        }
    }
}
#end_block

#method_before
public void filterAppsWithoutInvalidate() {
    updateProtectedAppsList();
    mFilteredApps = new ArrayList<AppInfo>(mApps);
    Iterator<AppInfo> iterator = mFilteredApps.iterator();
    while (iterator.hasNext()) {
        AppInfo appInfo = iterator.next();
        boolean system = (appInfo.flags & AppInfo.DOWNLOADED_FLAG) == 0;
        if (mProtectedApps.contains(appInfo.componentName) || (system && !getShowSystemApps()) || (!system && !getShowDownloadedApps())) {
            iterator.remove();
        }
    }
    Collections.sort(mFilteredApps, getComparatorForSortMode());
}
#method_after
public void filterAppsWithoutInvalidate() {
    updateProtectedAppsList(mLauncher);
    mFilteredApps = new ArrayList<AppInfo>(mApps);
    Iterator<AppInfo> iterator = mFilteredApps.iterator();
    while (iterator.hasNext()) {
        AppInfo appInfo = iterator.next();
        boolean system = (appInfo.flags & AppInfo.DOWNLOADED_FLAG) == 0;
        if (mProtectedApps.contains(appInfo.componentName) || (system && !getShowSystemApps()) || (!system && !getShowDownloadedApps())) {
            iterator.remove();
        }
    }
    Collections.sort(mFilteredApps, getComparatorForSortMode());
}
#end_block

#method_before
public void filterWidgetsWithoutInvalidate() {
    updateProtectedAppsList();
    mFilteredWidgets = new ArrayList<Object>(mWidgets);
    Iterator<Object> iterator = mFilteredWidgets.iterator();
    while (iterator.hasNext()) {
        Object o = iterator.next();
        String packageName;
        if (o instanceof AppWidgetProviderInfo) {
            AppWidgetProviderInfo widgetInfo = (AppWidgetProviderInfo) o;
            if (widgetInfo.provider == null) {
                continue;
            }
            packageName = widgetInfo.provider.getPackageName();
        } else if (o instanceof ResolveInfo) {
            ResolveInfo shortcut = (ResolveInfo) o;
            packageName = shortcut.activityInfo.applicationInfo.packageName;
        } else {
            Log.w(TAG, "Unknown class in widgets list: " + o.getClass());
            continue;
        }
        int flags;
        try {
            flags = AppInfo.initFlags(mPackageManager.getPackageInfo(packageName, 0));
        } catch (NameNotFoundException e) {
            flags = 0;
        }
        boolean system = (flags & AppInfo.DOWNLOADED_FLAG) == 0;
        if (mProtectedPackages.contains(packageName) || (system && !getShowSystemApps()) || (!system && !getShowDownloadedApps())) {
            iterator.remove();
        }
    }
}
#method_after
public void filterWidgetsWithoutInvalidate() {
    updateProtectedAppsList(mLauncher);
    mFilteredWidgets = new ArrayList<Object>(mWidgets);
    Iterator<Object> iterator = mFilteredWidgets.iterator();
    while (iterator.hasNext()) {
        Object o = iterator.next();
        String packageName;
        if (o instanceof AppWidgetProviderInfo) {
            AppWidgetProviderInfo widgetInfo = (AppWidgetProviderInfo) o;
            if (widgetInfo.provider == null) {
                continue;
            }
            packageName = widgetInfo.provider.getPackageName();
        } else if (o instanceof ResolveInfo) {
            ResolveInfo shortcut = (ResolveInfo) o;
            packageName = shortcut.activityInfo.applicationInfo.packageName;
        } else {
            Log.w(TAG, "Unknown class in widgets list: " + o.getClass());
            continue;
        }
        int flags;
        try {
            flags = AppInfo.initFlags(mPackageManager.getPackageInfo(packageName, 0));
        } catch (NameNotFoundException e) {
            flags = 0;
        }
        boolean system = (flags & AppInfo.DOWNLOADED_FLAG) == 0;
        if (mProtectedPackages.contains(packageName) || (system && !getShowSystemApps()) || (!system && !getShowDownloadedApps())) {
            iterator.remove();
        }
    }
}
#end_block

#method_before
private void removeHiddenAppsWorkspaceItems(final ArrayList<ItemInfo> workspaceItems, final ArrayList<LauncherAppWidgetInfo> appWidgets, final HashMap<Long, FolderInfo> folders) {
    // Get hidden apps
    ArrayList<ComponentName> mHiddenApps = new ArrayList<ComponentName>();
    ArrayList<String> mHiddenAppsPackages = new ArrayList<String>();
    Context context = mApp.getContext();
    // Since Trebuchet is compiled using the SDK we have to hardcode this string
    String protectedComponents = Settings.Secure.getString(context.getContentResolver(), "protected_components");
    protectedComponents = protectedComponents == null ? "" : protectedComponents;
    String[] flattened = protectedComponents.split("\\|");
    boolean hideShortcuts = SettingsProvider.getBoolean(context, SettingsProvider.SETTINGS_UI_DRAWER_REMOVE_HIDDEN_APPS_SHORTCUTS, R.bool.preferences_interface_drawer_remove_hidden_apps_shortcuts_default);
    boolean hideWidgets = SettingsProvider.getBoolean(context, SettingsProvider.SETTINGS_UI_DRAWER_REMOVE_HIDDEN_APPS_WIDGETS, R.bool.preferences_interface_drawer_remove_hidden_apps_widgets_default);
    for (String flat : flattened) {
        ComponentName cmp = ComponentName.unflattenFromString(flat);
        if (cmp != null) {
            mHiddenApps.add(cmp);
            mHiddenAppsPackages.add(cmp.getPackageName());
        }
    }
    // Shortcuts
    if (hideShortcuts) {
        int N = workspaceItems.size() - 1;
        for (int i = N; i >= 0; i--) {
            final ItemInfo item = workspaceItems.get(i);
            if (item instanceof ShortcutInfo) {
                ShortcutInfo shortcut = (ShortcutInfo) item;
                if (shortcut.intent != null && shortcut.intent.getComponent() != null) {
                    if (mHiddenApps.contains(shortcut.intent.getComponent())) {
                        LauncherModel.deleteItemFromDatabase(mContext, shortcut);
                        workspaceItems.remove(i);
                    }
                }
            } else {
                // Only remove items from folders that aren't hidden
                final FolderInfo folder = (FolderInfo) item;
                List<ShortcutInfo> shortcuts = folder.contents;
                int NN = shortcuts.size() - 1;
                for (int j = NN; j >= 0; j--) {
                    ShortcutInfo sci = shortcuts.get(j);
                    if (sci.intent != null && sci.intent.getComponent() != null) {
                        if (!folder.hidden) {
                            if (mHiddenApps.contains(sci.intent.getComponent())) {
                                LauncherModel.deleteItemFromDatabase(mContext, sci);
                                folder.remove(sci);
                            }
                        } else {
                            if (!mHiddenApps.contains(sci.intent.getComponent())) {
                                LauncherModel.deleteItemFromDatabase(mContext, sci);
                                folder.remove(sci);
                            }
                        }
                    }
                }
                if (folder.contents.size() == 1 && !folder.hidden) {
                    ShortcutInfo finalItem = folder.contents.get(0);
                    finalItem.container = folder.container;
                    LauncherModel.deleteItemFromDatabase(mContext, folder);
                    LauncherModel.addOrMoveItemInDatabase(mContext, finalItem, folder.container, folder.screenId, folder.cellX, folder.cellY);
                    workspaceItems.remove(i);
                    workspaceItems.add(finalItem);
                    folders.remove(Long.valueOf(item.id));
                } else if (folder.contents.size() == 0) /*&& !(folder instanceof LiveFolderInfo)*/
                {
                    LauncherModel.deleteFolderContentsFromDatabase(mContext, folder);
                    workspaceItems.remove(i);
                    folders.remove(Long.valueOf(item.id));
                }
            }
        }
    }
    // AppWidgets
    if (hideWidgets) {
        int N = appWidgets.size() - 1;
        for (int i = N; i >= 0; i--) {
            final LauncherAppWidgetInfo item = appWidgets.get(i);
            if (item.providerName != null) {
                if (mHiddenAppsPackages.contains(item.providerName.getPackageName())) {
                    LauncherModel.deleteItemFromDatabase(mContext, item);
                    appWidgets.remove(i);
                }
            }
        }
    }
}
#method_after
private void removeHiddenAppsWorkspaceItems(final ArrayList<ItemInfo> workspaceItems, final ArrayList<LauncherAppWidgetInfo> appWidgets, final HashMap<Long, FolderInfo> folders) {
    // Get hidden apps
    ArrayList<ComponentName> mHiddenApps = new ArrayList<ComponentName>();
    ArrayList<String> mHiddenAppsPackages = new ArrayList<String>();
    Context context = mApp.getContext();
    // Since Trebuchet is compiled using the SDK we have to hardcode this string
    String protectedComponents = Settings.Secure.getString(context.getContentResolver(), SETTINGS_PROTECTED_COMPONENTS);
    protectedComponents = protectedComponents == null ? "" : protectedComponents;
    String[] flattened = protectedComponents.split("\\|");
    boolean hideShortcuts = SettingsProvider.getBoolean(context, SettingsProvider.SETTINGS_UI_DRAWER_REMOVE_HIDDEN_APPS_SHORTCUTS, R.bool.preferences_interface_drawer_remove_hidden_apps_shortcuts_default);
    boolean hideWidgets = SettingsProvider.getBoolean(context, SettingsProvider.SETTINGS_UI_DRAWER_REMOVE_HIDDEN_APPS_WIDGETS, R.bool.preferences_interface_drawer_remove_hidden_apps_widgets_default);
    for (String flat : flattened) {
        ComponentName cmp = ComponentName.unflattenFromString(flat);
        if (cmp != null) {
            mHiddenApps.add(cmp);
            mHiddenAppsPackages.add(cmp.getPackageName());
        }
    }
    // Shortcuts
    if (hideShortcuts) {
        int N = workspaceItems.size() - 1;
        for (int i = N; i >= 0; i--) {
            final ItemInfo item = workspaceItems.get(i);
            if (item instanceof ShortcutInfo) {
                ShortcutInfo shortcut = (ShortcutInfo) item;
                if (shortcut.intent != null && shortcut.intent.getComponent() != null) {
                    if (mHiddenApps.contains(shortcut.intent.getComponent())) {
                        LauncherModel.deleteItemFromDatabase(mContext, shortcut);
                        workspaceItems.remove(i);
                    }
                }
            } else {
                // Only remove items from folders that aren't hidden
                final FolderInfo folder = (FolderInfo) item;
                List<ShortcutInfo> shortcuts = folder.contents;
                int NN = shortcuts.size() - 1;
                for (int j = NN; j >= 0; j--) {
                    ShortcutInfo sci = shortcuts.get(j);
                    if (sci.intent != null && sci.intent.getComponent() != null) {
                        if (!folder.hidden) {
                            if (mHiddenApps.contains(sci.intent.getComponent())) {
                                LauncherModel.deleteItemFromDatabase(mContext, sci);
                                folder.remove(sci);
                            }
                        } else {
                            if (!mHiddenApps.contains(sci.intent.getComponent())) {
                                LauncherModel.deleteItemFromDatabase(mContext, sci);
                                folder.remove(sci);
                            }
                        }
                    }
                }
                if (folder.contents.size() == 1 && !folder.hidden) {
                    ShortcutInfo finalItem = folder.contents.get(0);
                    finalItem.container = folder.container;
                    LauncherModel.deleteItemFromDatabase(mContext, folder);
                    LauncherModel.addOrMoveItemInDatabase(mContext, finalItem, folder.container, folder.screenId, folder.cellX, folder.cellY);
                    workspaceItems.remove(i);
                    workspaceItems.add(finalItem);
                    folders.remove(Long.valueOf(item.id));
                } else if (folder.contents.size() == 0) /*&& !(folder instanceof LiveFolderInfo)*/
                {
                    LauncherModel.deleteFolderContentsFromDatabase(mContext, folder);
                    workspaceItems.remove(i);
                    folders.remove(Long.valueOf(item.id));
                }
            }
        }
    }
    // AppWidgets
    if (hideWidgets) {
        int N = appWidgets.size() - 1;
        for (int i = N; i >= 0; i--) {
            final LauncherAppWidgetInfo item = appWidgets.get(i);
            if (item.providerName != null) {
                if (mHiddenAppsPackages.contains(item.providerName.getPackageName())) {
                    LauncherModel.deleteItemFromDatabase(mContext, item);
                    appWidgets.remove(i);
                }
            }
        }
    }
}
#end_block

#method_before
public void startHiddenFolderManager() {
    Bundle bundle = new Bundle();
    bundle.putBoolean(HiddenFolderFragment.HIDDEN_FOLDER_STATUS, mInfo.hidden);
    mLauncher.startHiddenFolderActivity(bundle, mFolderIcon);
}
#method_after
public void startHiddenFolderManager() {
    Bundle bundle = new Bundle();
    bundle.putBoolean(HiddenFolderFragment.HIDDEN_FOLDER_STATUS, mInfo.hidden);
    mLauncher.validateLockForHiddenFolders(bundle, mFolderIcon);
}
#end_block

#method_before
public String[] getComponents() {
    int size = mItemsInReadingOrder.size();
    String[] components = new String[size];
    for (int i = 0; i < size; i++) {
        View v = mItemsInReadingOrder.get(i);
        Object tag = v.getTag();
        if (tag instanceof ShortcutInfo) {
            components[i] = ((ShortcutInfo) tag).getIntent().getComponent().flattenToString();
        }
    }
    return components;
}
#method_after
public String[] getComponents() {
    String components = getComponentString();
    return components.split("\\|");
}
#end_block

#method_before
public Bitmap writeOnDrawable(int drawableId) {
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    int rows = mCustomGridRows == 0 ? (int) grid.numRows : mCustomGridRows;
    int columns = mCustomGridColumns == 0 ? (int) grid.numColumns : mCustomGridColumns;
    String text = rows + " \u00d7 " + columns;
    Bitmap bm = BitmapFactory.decodeResource(getResources(), drawableId).copy(Bitmap.Config.ARGB_8888, true);
    Paint paint = new Paint();
    paint.setStyle(Paint.Style.FILL);
    paint.setColor(Color.BLACK);
    int px = getResources().getDimensionPixelOffset(R.dimen.grid_custom_text);
    paint.setTextSize(px);
    Canvas canvas = new Canvas(bm);
    float canvasWidth = canvas.getWidth();
    float sentenceWidth = paint.measureText(text);
    float startPositionX = (canvasWidth - sentenceWidth) / 2;
    canvas.drawText(text, startPositionX, bm.getHeight() / 2, paint);
    return bm;
}
#method_after
public Bitmap writeOnDrawable(int drawableId) {
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    int rows = mCustomGridRows == 0 ? (int) grid.numRows : mCustomGridRows;
    int columns = mCustomGridColumns == 0 ? (int) grid.numColumns : mCustomGridColumns;
    String text = rows + " " + "\u00d7" + " " + columns;
    Bitmap bm = BitmapFactory.decodeResource(getResources(), drawableId).copy(Bitmap.Config.ARGB_8888, true);
    Paint paint = new Paint();
    paint.setStyle(Paint.Style.FILL);
    paint.setColor(Color.BLACK);
    int px = getResources().getDimensionPixelOffset(R.dimen.grid_custom_text);
    paint.setTextSize(px);
    Canvas canvas = new Canvas(bm);
    float canvasWidth = canvas.getWidth();
    float sentenceWidth = paint.measureText(text);
    float startPositionX = (canvasWidth - sentenceWidth) / 2;
    canvas.drawText(text, startPositionX, bm.getHeight() / 2, paint);
    return bm;
}
#end_block

#method_before
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    convertView = inflater.inflate(R.layout.settings_pane_list_item, parent, false);
    TextView textView = (TextView) convertView.findViewById(R.id.item_name);
    textView.setText(mTitles[position]);
    // Set Selected State
    if (position == mCurrentSize.getValue()) {
        mCurrentSelection = convertView;
        setSelected(mCurrentSelection);
    }
    if (position == DeviceProfile.GridSize.Custom.getValue()) {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        String state = mTitles[position];
        int rows = SettingsProvider.getIntCustomDefault(getActivity(), SettingsProvider.SETTINGS_UI_HOMESCREEN_ROWS, grid.numRowsBase);
        int columns = SettingsProvider.getIntCustomDefault(getActivity(), SettingsProvider.SETTINGS_UI_HOMESCREEN_COLUMNS, grid.numColumnsBase);
        state += "(" + rows + "\u00d7" + columns + ")";
        textView.setText(state);
    }
    convertView.setOnClickListener(mSettingsItemListener);
    convertView.setTag(position);
    return convertView;
}
#method_after
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    LayoutInflater inflater = (LayoutInflater) mContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    convertView = inflater.inflate(R.layout.settings_pane_list_item, parent, false);
    TextView textView = (TextView) convertView.findViewById(R.id.item_name);
    textView.setText(mTitles[position]);
    // Set Selected State
    if (position == mCurrentSize.getValue()) {
        mCurrentSelection = convertView;
        setSelected(mCurrentSelection);
    }
    if (position == DeviceProfile.GridSize.Custom.getValue()) {
        LauncherAppState app = LauncherAppState.getInstance();
        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
        String state = mTitles[position];
        int rows = SettingsProvider.getIntCustomDefault(getActivity(), SettingsProvider.SETTINGS_UI_HOMESCREEN_ROWS, grid.numRowsBase);
        int columns = SettingsProvider.getIntCustomDefault(getActivity(), SettingsProvider.SETTINGS_UI_HOMESCREEN_COLUMNS, grid.numColumnsBase);
        state += " " + "(" + rows + " " + "\u00d7" + " " + columns + ")";
        textView.setText(state);
    }
    convertView.setOnClickListener(mSettingsItemListener);
    convertView.setTag(position);
    return convertView;
}
#end_block

#method_before
public void updateDynamicGridSizeSettingsItem(View v) {
    DeviceProfile.GridSize gridSize = DeviceProfile.GridSize.getModeForValue(SettingsProvider.getIntCustomDefault(mLauncher, SettingsProvider.SETTINGS_UI_DYNAMIC_GRID_SIZE, 0));
    String state = "";
    switch(gridSize) {
        case Comfortable:
            state = mLauncher.getResources().getString(R.string.grid_size_comfortable);
            break;
        case Cozy:
            state = mLauncher.getResources().getString(R.string.grid_size_cozy);
            break;
        case Condensed:
            state = mLauncher.getResources().getString(R.string.grid_size_condensed);
            break;
        case Custom:
            state = mLauncher.getResources().getString(R.string.grid_size_custom);
            int rows = SettingsProvider.getIntCustomDefault(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_ROWS, 0);
            int columns = SettingsProvider.getIntCustomDefault(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_COLUMNS, 0);
            state += "(" + rows + "\u00d7" + columns + ")";
            break;
    }
    ((TextView) v.findViewById(R.id.item_state)).setText(state);
}
#method_after
public void updateDynamicGridSizeSettingsItem(View v) {
    DeviceProfile.GridSize gridSize = DeviceProfile.GridSize.getModeForValue(SettingsProvider.getIntCustomDefault(mLauncher, SettingsProvider.SETTINGS_UI_DYNAMIC_GRID_SIZE, 0));
    String state = "";
    switch(gridSize) {
        case Comfortable:
            state = mLauncher.getResources().getString(R.string.grid_size_comfortable);
            break;
        case Cozy:
            state = mLauncher.getResources().getString(R.string.grid_size_cozy);
            break;
        case Condensed:
            state = mLauncher.getResources().getString(R.string.grid_size_condensed);
            break;
        case Custom:
            int rows = SettingsProvider.getIntCustomDefault(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_ROWS, 0);
            int columns = SettingsProvider.getIntCustomDefault(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_COLUMNS, 0);
            state = rows + " " + "\u00d7" + " " + columns;
            break;
    }
    ((TextView) v.findViewById(R.id.item_state)).setText(state);
}
#end_block

#method_before
public void registerSwipeBackGestureListenerAndStartGel(final Activity launcherActivity, boolean isLayoutRtl) {
    EdgeGestureManager edgeGestureManager = EdgeGestureManager.getInstance();
    if (mEdgeGestureActivationListener == null) {
        mEdgeGestureActivationListener = new EdgeGestureManager.EdgeGestureActivationListener() {

            ActivityManager mAm = (ActivityManager) launcherActivity.getSystemService(Activity.ACTIVITY_SERVICE);

            @Override
            public void onEdgeGestureActivation(int touchX, int touchY, EdgeGesturePosition position, int flags) {
                // Retrieve the top level activity information
                List<ActivityManager.RunningTaskInfo> taskInfo = mAm.getRunningTasks(1);
                ComponentName topActivityComponentInfo = taskInfo.get(0).topActivity;
                String topActivityClassName = topActivityComponentInfo.getClassName();
                String topActivityPackageName = topActivityComponentInfo.getPackageName();
                // Otherwise, do nothing.
                if (GEL_ACTIVITY.equals(topActivityClassName) && GEL_PACKAGE_NAME.equals(topActivityPackageName)) {
                    Intent homeIntent = new Intent(Intent.ACTION_MAIN);
                    homeIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION);
                    homeIntent.addCategory(Intent.CATEGORY_HOME);
                    launcherActivity.startActivity(homeIntent);
                    launcherActivity.overridePendingTransition(0, 0);
                    dropEventsUntilLift();
                }
            }
        };
        edgeGestureManager.setEdgeGestureActivationListener(mEdgeGestureActivationListener);
    }
    mEdgeGestureActivationListener.restoreListenerState();
    int edge = isLayoutRtl ? EDGE_GESTURE_SERVICE_LEFT_EDGE : EDGE_GESTURE_SERVICE_RIGHT_EDGE;
    edgeGestureManager.updateEdgeGestureActivationListener(mEdgeGestureActivationListener, edge);
    // Start the Global Search Activity
    Intent i = new Intent();
    final SearchManager searchManager = (SearchManager) launcherActivity.getSystemService(Context.SEARCH_SERVICE);
    ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
    i.setComponent(globalSearchActivity);
    launcherActivity.startActivity(i);
    launcherActivity.overridePendingTransition(0, R.anim.exit_out_right);
}
#method_after
public void registerSwipeBackGestureListenerAndStartGel(final Activity launcherActivity, boolean isLayoutRtl) {
    EdgeGestureManager edgeGestureManager = EdgeGestureManager.getInstance();
    if (mEdgeGestureActivationListener == null) {
        mEdgeGestureActivationListener = new EdgeGestureManager.EdgeGestureActivationListener() {

            ActivityManager mAm = (ActivityManager) launcherActivity.getSystemService(Activity.ACTIVITY_SERVICE);

            @Override
            public void onEdgeGestureActivation(int touchX, int touchY, EdgeGesturePosition position, int flags) {
                // Retrieve the top level activity information
                List<ActivityManager.RunningTaskInfo> taskInfo = mAm.getRunningTasks(1);
                ComponentName topActivityComponentInfo = taskInfo.get(0).topActivity;
                String topActivityClassName = topActivityComponentInfo.getClassName();
                String topActivityPackageName = topActivityComponentInfo.getPackageName();
                // Otherwise, do nothing.
                if (GEL_ACTIVITY.equals(topActivityClassName) && GEL_PACKAGE_NAME.equals(topActivityPackageName)) {
                    Intent homeIntent = new Intent(Intent.ACTION_MAIN);
                    homeIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION);
                    homeIntent.addCategory(Intent.CATEGORY_HOME);
                    launcherActivity.startActivity(homeIntent);
                    launcherActivity.overridePendingTransition(0, 0);
                    dropEventsUntilLift();
                }
            }
        };
        edgeGestureManager.setEdgeGestureActivationListener(mEdgeGestureActivationListener);
    }
    mEdgeGestureActivationListener.restoreListenerState();
    int edge = isLayoutRtl ? EDGE_GESTURE_SERVICE_LEFT_EDGE : EDGE_GESTURE_SERVICE_RIGHT_EDGE;
    edgeGestureManager.updateEdgeGestureActivationListener(mEdgeGestureActivationListener, edge);
    // Attempt to use Intent.ACTION_ASSIST, if supported
    Intent intent = new Intent(Intent.ACTION_ASSIST);
    if (!isIntentSupported(launcherActivity, intent)) {
        // Start the Global Search Activity
        final SearchManager searchManager = (SearchManager) launcherActivity.getSystemService(Context.SEARCH_SERVICE);
        ComponentName globalSearchActivity = searchManager.getGlobalSearchActivity();
        intent = new Intent();
        intent.setComponent(globalSearchActivity);
    }
    launcherActivity.startActivity(intent);
    launcherActivity.overridePendingTransition(0, R.anim.exit_out_right);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    super.onCreate(savedInstanceState);
    LauncherAppState.setApplicationContext(getApplicationContext());
    LauncherAppState app = LauncherAppState.getInstance();
    // Load configuration-specific DeviceProfile
    mDeviceProfile = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE ? app.getInvariantDeviceProfile().landscapeProfile : app.getInvariantDeviceProfile().portraitProfile;
    mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mModel = app.setLauncher(this);
    mIconCache = app.getIconCache();
    mDragController = new DragController(this);
    mInflater = getLayoutInflater();
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this);
    mStats = new Stats(this);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    if (PROFILE_STARTUP) {
        android.os.Debug.startMethodTracing(Environment.getExternalStorageDirectory() + "/launcher");
    }
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this);
    lockAllApps();
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (PROFILE_STARTUP) {
        android.os.Debug.stopMethodTracing();
    }
    if (!mRestoring) {
        if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
            // If the user leaves launcher, then we should just load items asynchronously when
            // they return.
            mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        } else {
            // We only load the page synchronously if the user rotates (or triggers a
            // configuration change) while launcher is in the foreground
            mModel.startLoader(mWorkspace.getRestorePage());
        }
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    registerReceiver(mCloseSystemDialogsReceiver, filter);
    mRotationEnabled = Utilities.isRotationAllowedForDevice(getApplicationContext());
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext(), false);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
        if (mLauncherCallbacks.hasLauncherOverlay()) {
            ViewStub stub = (ViewStub) findViewById(R.id.launcher_overlay_stub);
            mLauncherOverlayContainer = (InsettableFrameLayout) stub.inflate();
            mLauncherOverlay = mLauncherCallbacks.setLauncherOverlayView(mLauncherOverlayContainer, mLauncherOverlayCallbacks);
            mWorkspace.setLauncherOverlay(mLauncherOverlay);
        }
    }
    if (shouldShowIntroScreen()) {
        showIntroScreen();
    } else {
        showFirstRunActivity();
        showFirstRunClings();
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    super.onCreate(savedInstanceState);
    LauncherAppState.setApplicationContext(getApplicationContext());
    LauncherAppState app = LauncherAppState.getInstance();
    initializeDeviceProfile(app);
    mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mDragController = new DragController(this);
    mInflater = getLayoutInflater();
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this);
    mStats = new Stats(this);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    if (PROFILE_STARTUP) {
        android.os.Debug.startMethodTracing(Environment.getExternalStorageDirectory() + "/launcher");
    }
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this);
    lockAllApps();
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (PROFILE_STARTUP) {
        android.os.Debug.stopMethodTracing();
    }
    if (!mRestoring) {
        if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
            // If the user leaves launcher, then we should just load items asynchronously when
            // they return.
            mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        } else {
            // We only load the page synchronously if the user rotates (or triggers a
            // configuration change) while launcher is in the foreground
            mModel.startLoader(mWorkspace.getRestorePage());
        }
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    registerReceiver(mCloseSystemDialogsReceiver, filter);
    mRotationEnabled = Utilities.isRotationAllowedForDevice(getApplicationContext());
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext(), false);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
        if (mLauncherCallbacks.hasLauncherOverlay()) {
            ViewStub stub = (ViewStub) findViewById(R.id.launcher_overlay_stub);
            mLauncherOverlayContainer = (InsettableFrameLayout) stub.inflate();
            mLauncherOverlay = mLauncherCallbacks.setLauncherOverlayView(mLauncherOverlayContainer, mLauncherOverlayCallbacks);
            mWorkspace.setLauncherOverlay(mLauncherOverlay);
        }
    }
    if (shouldShowIntroScreen()) {
        showIntroScreen();
    } else {
        showFirstRunActivity();
        showFirstRunClings();
    }
}
#end_block

#method_before
@Override
protected void onResume() {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
        Log.v(TAG, "Launcher.onResume()");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnResume();
    }
    super.onResume();
    // Restore the previous launcher state
    if (mOnResumeState == State.WORKSPACE) {
        showWorkspace(false);
    } else if (mOnResumeState == State.APPS) {
        boolean launchedFromApp = (mWaitingForResume != null);
        // Don't update the predicted apps if the user is returning to launcher in the apps
        // view after launching an app, as they may be depending on the UI to be static to
        // switch to another app, otherwise, if it was
        showAppsView(false, /* animated */
        false, /* resetListToTop */
        !launchedFromApp, /* updatePredictedApps */
        false);
    } else if (mOnResumeState == State.WIDGETS) {
        showWidgetsView(false, false);
    }
    mOnResumeState = State.NONE;
    // Background was set to gradient in onPause(), restore to transparent if in all apps.
    setWorkspaceBackground(mState == State.WORKSPACE ? WORKSPACE_BACKGROUND_GRADIENT : WORKSPACE_BACKGROUND_TRANSPARENT);
    mPaused = false;
    if (mRestoring || mOnResumeNeedsLoad) {
        setWorkspaceLoading(true);
        // If we're starting binding all over again, clear any bind calls we'd postponed in
        // the past (see waitUntilResume) -- we don't need them since we're starting binding
        // from scratch again
        mBindOnResumeCallbacks.clear();
        mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        mRestoring = false;
        mOnResumeNeedsLoad = false;
    }
    if (mBindOnResumeCallbacks.size() > 0) {
        // We might have postponed some bind calls until onResume (see waitUntilResume) --
        // execute them here
        long startTimeCallbacks = 0;
        if (DEBUG_RESUME_TIME) {
            startTimeCallbacks = System.currentTimeMillis();
        }
        for (int i = 0; i < mBindOnResumeCallbacks.size(); i++) {
            mBindOnResumeCallbacks.get(i).run();
        }
        mBindOnResumeCallbacks.clear();
        if (DEBUG_RESUME_TIME) {
            Log.d(TAG, "Time spent processing callbacks in onResume: " + (System.currentTimeMillis() - startTimeCallbacks));
        }
    }
    if (mOnResumeCallbacks.size() > 0) {
        for (int i = 0; i < mOnResumeCallbacks.size(); i++) {
            mOnResumeCallbacks.get(i).run();
        }
        mOnResumeCallbacks.clear();
    }
    // were launching
    if (mWaitingForResume != null) {
        // Resets the previous workspace icon press state
        mWaitingForResume.setStayPressed(false);
    }
    // It is possible that widgets can receive updates while launcher is not in the foreground.
    // Consequently, the widgets will be inflated in the orientation of the foreground activity
    // (framework issue). On resuming, we ensure that any widgets are inflated for the current
    // orientation.
    getWorkspace().reinflateWidgetsIfNecessary();
    reinflateQSBIfNecessary();
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onResume: " + (System.currentTimeMillis() - startTime));
    }
    if (mWorkspace.getCustomContentCallbacks() != null) {
        // if PagedView#setRestorePage was set to the custom content page in onCreate().
        if (mWorkspace.isOnOrMovingToCustomContent()) {
            mWorkspace.getCustomContentCallbacks().onShow(true);
        }
    }
    updateInteraction(Workspace.State.NORMAL, mWorkspace.getState());
    mWorkspace.onResume();
    if (!isWorkspaceLoading()) {
        // Process any items that were added while Launcher was away.
        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onResume();
    }
    // Close out Fragments
    Fragment f1 = getFragmentManager().findFragmentByTag(HiddenFolderFragment.HIDDEN_FOLDER_FRAGMENT);
    if (f1 != null && !mHiddenFolderAuth) {
        mHiddenFolderFragment.saveHiddenFolderStatus(-1);
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        fragmentTransaction.remove(mHiddenFolderFragment).commit();
    } else {
        mHiddenFolderAuth = false;
    }
}
#method_after
@Override
protected void onResume() {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
        Log.v(TAG, "Launcher.onResume()");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnResume();
    }
    super.onResume();
    // Restore the previous launcher state
    if (mOnResumeState == State.WORKSPACE) {
        showWorkspace(false);
    } else if (mOnResumeState == State.APPS) {
        boolean launchedFromApp = (mWaitingForResume != null);
        // Don't update the predicted apps if the user is returning to launcher in the apps
        // view after launching an app, as they may be depending on the UI to be static to
        // switch to another app, otherwise, if it was
        showAppsView(false, /* animated */
        false, /* resetListToTop */
        !launchedFromApp, /* updatePredictedApps */
        false);
    } else if (mOnResumeState == State.WIDGETS) {
        showWidgetsView(false, false);
    }
    mOnResumeState = State.NONE;
    // Background was set to gradient in onPause(), restore to transparent if in all apps.
    setWorkspaceBackground(mState == State.WORKSPACE ? WORKSPACE_BACKGROUND_GRADIENT : WORKSPACE_BACKGROUND_TRANSPARENT);
    mPaused = false;
    if (mRestoring || mOnResumeNeedsLoad) {
        setWorkspaceLoading(true);
        // If we're starting binding all over again, clear any bind calls we'd postponed in
        // the past (see waitUntilResume) -- we don't need them since we're starting binding
        // from scratch again
        mBindOnResumeCallbacks.clear();
        mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        mRestoring = false;
        mOnResumeNeedsLoad = false;
    }
    if (mBindOnResumeCallbacks.size() > 0) {
        // We might have postponed some bind calls until onResume (see waitUntilResume) --
        // execute them here
        long startTimeCallbacks = 0;
        if (DEBUG_RESUME_TIME) {
            startTimeCallbacks = System.currentTimeMillis();
        }
        for (int i = 0; i < mBindOnResumeCallbacks.size(); i++) {
            mBindOnResumeCallbacks.get(i).run();
        }
        mBindOnResumeCallbacks.clear();
        if (DEBUG_RESUME_TIME) {
            Log.d(TAG, "Time spent processing callbacks in onResume: " + (System.currentTimeMillis() - startTimeCallbacks));
        }
    }
    if (mOnResumeCallbacks.size() > 0) {
        for (int i = 0; i < mOnResumeCallbacks.size(); i++) {
            mOnResumeCallbacks.get(i).run();
        }
        mOnResumeCallbacks.clear();
    }
    // were launching
    if (mWaitingForResume != null) {
        // Resets the previous workspace icon press state
        mWaitingForResume.setStayPressed(false);
    }
    // It is possible that widgets can receive updates while launcher is not in the foreground.
    // Consequently, the widgets will be inflated in the orientation of the foreground activity
    // (framework issue). On resuming, we ensure that any widgets are inflated for the current
    // orientation.
    getWorkspace().reinflateWidgetsIfNecessary();
    reinflateQSBIfNecessary();
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onResume: " + (System.currentTimeMillis() - startTime));
    }
    if (mWorkspace.getCustomContentCallbacks() != null) {
        // if PagedView#setRestorePage was set to the custom content page in onCreate().
        if (mWorkspace.isOnOrMovingToCustomContent()) {
            mWorkspace.getCustomContentCallbacks().onShow(true);
        }
    }
    updateInteraction(Workspace.State.NORMAL, mWorkspace.getState());
    mWorkspace.onResume();
    if (!isWorkspaceLoading()) {
        // Process any items that were added while Launcher was away.
        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onResume();
    }
    reloadLauncherIfNeeded();
    // Close out Fragments
    Fragment f1 = getFragmentManager().findFragmentByTag(HiddenFolderFragment.HIDDEN_FOLDER_FRAGMENT);
    if (f1 != null && !mHiddenFolderAuth) {
        mHiddenFolderFragment.saveHiddenFolderStatus(-1);
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        fragmentTransaction.remove(mHiddenFolderFragment).commit();
    } else {
        mHiddenFolderAuth = false;
    }
}
#end_block

#method_before
private void setupViews() {
    final DragController dragController = mDragController;
    mLauncherView = findViewById(R.id.launcher);
    mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
    mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
    mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
    mWorkspace.setPageSwitchListener(this);
    mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
    mLauncherView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
    mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
    // Setup the drag layer
    mDragLayer.setup(this, dragController);
    // Setup the hotseat
    mHotseat = (Hotseat) findViewById(R.id.hotseat);
    if (mHotseat != null) {
        mHotseat.setOnLongClickListener(this);
    }
    mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
    mWidgetsButton = findViewById(R.id.widget_button);
    mWidgetsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickAddWidgetButton(arg0);
            }
        }
    });
    mWidgetsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View wallpaperButton = findViewById(R.id.wallpaper_button);
    wallpaperButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickWallpaperPicker(arg0);
            }
        }
    });
    wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View settingsButton = findViewById(R.id.settings_button);
    if (hasSettings()) {
        settingsButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                if (!mWorkspace.isSwitchingState()) {
                    onClickSettingsButton(arg0);
                }
            }
        });
        settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    } else {
        settingsButton.setVisibility(View.GONE);
    }
    mOverviewPanel.setAlpha(0f);
    // Setup the workspace
    mWorkspace.setHapticFeedbackEnabled(false);
    mWorkspace.setOnLongClickListener(this);
    mWorkspace.setup(dragController);
    dragController.addDragListener(mWorkspace);
    // Get the search/delete bar
    mSearchDropTargetBar = (SearchDropTargetBar) mDragLayer.findViewById(R.id.search_drop_target_bar);
    // Setup Apps and Widgets
    mAppsView = (AllAppsContainerView) findViewById(R.id.apps_view);
    mWidgetsView = (WidgetsContainerView) findViewById(R.id.widgets_view);
    if (mLauncherCallbacks != null && mLauncherCallbacks.getAllAppsSearchBarController() != null) {
        mAppsView.setSearchBarController(mLauncherCallbacks.getAllAppsSearchBarController());
    } else {
        mAppsView.setSearchBarController(mAppsView.newDefaultAppSearchController());
    }
    mAppsView.setUseScrubber(mUseScrubber);
    mAppsView.setSectionStrategy(AllAppsContainerView.SECTION_STRATEGY_RAGGED);
    mAppsView.setGridTheme(AllAppsContainerView.GRID_THEME_DARK);
    mWidgetsView.setUseScrubber(false);
    // Setup the drag controller (drop targets have to be added in reverse order in priority)
    dragController.setDragScoller(mWorkspace);
    dragController.setScrollView(mDragLayer);
    dragController.setMoveTarget(mWorkspace);
    dragController.addDropTarget(mWorkspace);
    if (mSearchDropTargetBar != null) {
        mSearchDropTargetBar.setup(this, dragController);
        mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
    }
    if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
        Log.v(TAG, "adding WeightWatcher");
        mWeightWatcher = new WeightWatcher(this);
        mWeightWatcher.setAlpha(0.5f);
        ((FrameLayout) mLauncherView).addView(mWeightWatcher, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
        boolean show = shouldShowWeightWatcher();
        mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
    }
}
#method_after
private void setupViews() {
    final DragController dragController = mDragController;
    mLauncherView = findViewById(R.id.launcher);
    mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
    mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
    mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
    mWorkspace.setPageSwitchListener(this);
    mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
    mLauncherView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
    mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
    // Setup the drag layer
    mDragLayer.setup(this, dragController);
    // Setup the hotseat
    mHotseat = (Hotseat) findViewById(R.id.hotseat);
    if (mHotseat != null) {
        mHotseat.setOnLongClickListener(this);
    }
    // Setup the overview panel
    mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
    mOverviewSettingsPanel = new OverviewSettingsPanel(this);
    mOverviewSettingsPanel.initializeAdapter();
    mWidgetsButton = findViewById(R.id.widget_button);
    mWidgetsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickAddWidgetButton(arg0);
            }
        }
    });
    mWidgetsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View wallpaperButton = findViewById(R.id.wallpaper_button);
    wallpaperButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickWallpaperPicker(arg0);
            }
        }
    });
    wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View settingsButton = findViewById(R.id.settings_button);
    if (hasSettings()) {
        settingsButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                if (!mWorkspace.isSwitchingState()) {
                    onClickSettingsButton(arg0);
                }
            }
        });
        settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    } else {
        settingsButton.setVisibility(View.GONE);
    }
    View defaultScreenButton = findViewById(R.id.default_screen_button);
    defaultScreenButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickDefaultScreenButton(arg0);
            }
        }
    });
    defaultScreenButton.setOnTouchListener(getHapticFeedbackTouchListener());
    final VerticalSlidingPanel verticalSlidingPanel = ((VerticalSlidingPanel) mOverviewPanel);
    verticalSlidingPanel.setPanelSlideListener(new SettingsPanelSlideListener());
    verticalSlidingPanel.setEnableDragViewTouchEvents(true);
    View settingsPaneHeader = mOverviewPanel.findViewById(R.id.settings_pane_header);
    if (settingsPaneHeader != null) {
        verticalSlidingPanel.setDragView(settingsPaneHeader);
        settingsPaneHeader.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (verticalSlidingPanel.isExpanded()) {
                    verticalSlidingPanel.collapsePane();
                } else {
                    verticalSlidingPanel.expandPane();
                }
            }
        });
    }
    mOverviewPanel.setAlpha(0f);
    // Setup the workspace
    mWorkspace.setHapticFeedbackEnabled(false);
    mWorkspace.setOnLongClickListener(this);
    mWorkspace.setup(dragController);
    dragController.addDragListener(mWorkspace);
    // Get the search/delete bar
    mSearchDropTargetBar = (SearchDropTargetBar) mDragLayer.findViewById(R.id.search_drop_target_bar);
    // Setup Apps and Widgets
    mAppsView = (AllAppsContainerView) findViewById(R.id.apps_view);
    mWidgetsView = (WidgetsContainerView) findViewById(R.id.widgets_view);
    if (mLauncherCallbacks != null && mLauncherCallbacks.getAllAppsSearchBarController() != null) {
        mAppsView.setSearchBarController(mLauncherCallbacks.getAllAppsSearchBarController());
    } else {
        mAppsView.setSearchBarController(mAppsView.newDefaultAppSearchController());
    }
    mAppsView.setUseScrubber(mUseScrubber);
    mAppsView.setSectionStrategy(AllAppsContainerView.SECTION_STRATEGY_RAGGED);
    mAppsView.setGridTheme(AllAppsContainerView.GRID_THEME_DARK);
    mWidgetsView.setUseScrubber(false);
    // Setup the drag controller (drop targets have to be added in reverse order in priority)
    dragController.setDragScoller(mWorkspace);
    dragController.setScrollView(mDragLayer);
    dragController.setMoveTarget(mWorkspace);
    dragController.addDropTarget(mWorkspace);
    if (mSearchDropTargetBar != null) {
        mSearchDropTargetBar.setup(this, dragController);
        mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
    }
    if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
        Log.v(TAG, "adding WeightWatcher");
        mWeightWatcher = new WeightWatcher(this);
        mWeightWatcher.setAlpha(0.5f);
        ((FrameLayout) mLauncherView).addView(mWeightWatcher, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
        boolean show = shouldShowWeightWatcher();
        mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
    }
}
#end_block

#method_before
public View createShortcut(ViewGroup parent, ShortcutInfo info) {
    BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon, parent, false);
    favorite.applyFromShortcutInfo(info, mIconCache);
    favorite.setCompoundDrawablePadding(mDeviceProfile.iconDrawablePaddingPx);
    favorite.setOnClickListener(this);
    favorite.setOnFocusChangeListener(mFocusHandler);
    return favorite;
}
#method_after
public View createShortcut(ViewGroup parent, ShortcutInfo info) {
    BubbleTextView favorite = (BubbleTextView) mInflater.inflate(R.layout.app_icon, parent, false);
    favorite.applyFromShortcutInfo(info, mIconCache);
    favorite.setTextVisibility(!mHideIconLabels);
    favorite.setCompoundDrawablePadding(mDeviceProfile.iconDrawablePaddingPx);
    favorite.setOnClickListener(this);
    favorite.setOnFocusChangeListener(mFocusHandler);
    return favorite;
}
#end_block

#method_before
@Override
protected void onNewIntent(Intent intent) {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
    }
    super.onNewIntent(intent);
    // Close the menu
    Folder openFolder = mWorkspace.getOpenFolder();
    boolean alreadyOnHome = mHasFocus && ((intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    boolean isActionMain = Intent.ACTION_MAIN.equals(intent.getAction());
    if (isActionMain) {
        // also will cancel mWaitingForResult.
        closeSystemDialogs();
        if (mWorkspace == null) {
            // Can be cases where mWorkspace is null, this prevents a NPE
            return;
        }
        // In all these cases, only animate if we're already on home
        mWorkspace.exitWidgetResizeMode();
        closeFolder();
        exitSpringLoadedDragMode();
        // otherwise, just wait until onResume to set the state back to Workspace
        if (alreadyOnHome) {
            showWorkspace(true);
        } else {
            mOnResumeState = State.WORKSPACE;
        }
        final View v = getWindow().peekDecorView();
        if (v != null && v.getWindowToken() != null) {
            InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
        }
        // Reset the apps view
        if (!alreadyOnHome && mAppsView != null) {
            mAppsView.scrollToTop();
        }
        // Reset the widgets view
        if (!alreadyOnHome && mWidgetsView != null) {
            mWidgetsView.scrollToTop();
        }
        if (mLauncherCallbacks != null) {
            mLauncherCallbacks.onHomeIntent();
        }
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onNewIntent(intent);
    }
    // animation.
    if (isActionMain) {
        boolean moveToDefaultScreen = mLauncherCallbacks != null ? mLauncherCallbacks.shouldMoveToDefaultScreenOnHomeIntent() : true;
        if (alreadyOnHome && mState == State.WORKSPACE && !mWorkspace.isTouchActive() && openFolder == null && moveToDefaultScreen) {
            mWorkspace.post(new Runnable() {

                @Override
                public void run() {
                    mWorkspace.moveToDefaultScreen(true);
                }
            });
        }
    }
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onNewIntent: " + (System.currentTimeMillis() - startTime));
    }
}
#method_after
@Override
protected void onNewIntent(Intent intent) {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
    }
    super.onNewIntent(intent);
    reloadLauncherIfNeeded();
    // Close the menu
    Folder openFolder = mWorkspace.getOpenFolder();
    boolean alreadyOnHome = mHasFocus && ((intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    boolean isActionMain = Intent.ACTION_MAIN.equals(intent.getAction());
    if (isActionMain) {
        // also will cancel mWaitingForResult.
        closeSystemDialogs();
        if (mWorkspace == null) {
            // Can be cases where mWorkspace is null, this prevents a NPE
            return;
        }
        // In all these cases, only animate if we're already on home
        mWorkspace.exitWidgetResizeMode();
        closeFolder();
        exitSpringLoadedDragMode();
        // otherwise, just wait until onResume to set the state back to Workspace
        if (alreadyOnHome) {
            showWorkspace(true);
        } else {
            mOnResumeState = State.WORKSPACE;
        }
        final View v = getWindow().peekDecorView();
        if (v != null && v.getWindowToken() != null) {
            InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
        }
        // Reset the apps view
        if (!alreadyOnHome && mAppsView != null) {
            mAppsView.scrollToTop();
        }
        // Reset the widgets view
        if (!alreadyOnHome && mWidgetsView != null) {
            mWidgetsView.scrollToTop();
        }
        if (mLauncherCallbacks != null) {
            mLauncherCallbacks.onHomeIntent();
        }
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onNewIntent(intent);
    }
    // animation.
    if (isActionMain) {
        boolean moveToDefaultScreen = mLauncherCallbacks != null ? mLauncherCallbacks.shouldMoveToDefaultScreenOnHomeIntent() : true;
        if (alreadyOnHome && mState == State.WORKSPACE && !mWorkspace.isTouchActive() && openFolder == null && moveToDefaultScreen) {
            mWorkspace.post(new Runnable() {

                @Override
                public void run() {
                    mWorkspace.moveToDefaultScreen(true);
                }
            });
        }
    }
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onNewIntent: " + (System.currentTimeMillis() - startTime));
    }
}
#end_block

#method_before
FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX, int cellY) {
    final FolderInfo folderInfo = new FolderInfo();
    folderInfo.title = getText(R.string.folder_name);
    // Update the model
    LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY);
    sFolders.put(folderInfo.id, folderInfo);
    // Create the view
    FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
    mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1, isWorkspaceLocked());
    // Force measure the new folder icon
    CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
    parent.getShortcutsAndWidgets().measureChild(newFolder);
    return newFolder;
}
#method_after
FolderIcon addFolder(CellLayout layout, long container, final long screenId, int cellX, int cellY) {
    final FolderInfo folderInfo = new FolderInfo();
    folderInfo.title = getText(R.string.folder_name);
    // Update the model
    LauncherModel.addItemToDatabase(Launcher.this, folderInfo, container, screenId, cellX, cellY);
    sFolders.put(folderInfo.id, folderInfo);
    // Create the view
    FolderIcon newFolder = FolderIcon.fromXml(R.layout.folder_icon, this, layout, folderInfo, mIconCache);
    if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
        newFolder.setTextVisible(!mHideIconLabels);
    }
    mWorkspace.addInScreen(newFolder, container, screenId, cellX, cellY, 1, 1, isWorkspaceLocked());
    // Force measure the new folder icon
    CellLayout parent = mWorkspace.getParentCellLayoutForView(newFolder);
    parent.getShortcutsAndWidgets().measureChild(newFolder);
    return newFolder;
}
#end_block

#method_before
public void bindItems(final ArrayList<ItemInfo> shortcuts, final int start, final int end, final boolean forceAnimateIcons) {
    Runnable r = new Runnable() {

        public void run() {
            bindItems(shortcuts, start, end, forceAnimateIcons);
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    // Get the list of added shortcuts and intersect them with the set of shortcuts here
    final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
    final Collection<Animator> bounceAnims = new ArrayList<Animator>();
    final boolean animateIcons = forceAnimateIcons && canRunNewAppsAnimation();
    Workspace workspace = mWorkspace;
    long newShortcutsScreenId = -1;
    for (int i = start; i < end; i++) {
        final ItemInfo item = shortcuts.get(i);
        // Short circuit if we are loading dock items for a configuration which has no dock
        if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT && mHotseat == null) {
            continue;
        }
        final View view;
        switch(item.itemType) {
            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
                ShortcutInfo info = (ShortcutInfo) item;
                view = createShortcut(info);
                /*
                     * TODO: FIX collision case
                     */
                if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
                    CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
                    if (cl != null && cl.isOccupied(item.cellX, item.cellY)) {
                        View v = cl.getChildAt(item.cellX, item.cellY);
                        Object tag = v.getTag();
                        String desc = "Collision while binding workspace item: " + item + ". Collides with " + tag;
                        if (LauncherAppState.isDogfoodBuild()) {
                            throw (new RuntimeException(desc));
                        } else {
                            Log.d(TAG, desc);
                        }
                    }
                }
                break;
            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
                view = FolderIcon.fromXml(R.layout.folder_icon, this, (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()), (FolderInfo) item, mIconCache);
                break;
            default:
                throw new RuntimeException("Invalid Item Type");
        }
        workspace.addInScreenFromBind(view, item.container, item.screenId, item.cellX, item.cellY, 1, 1);
        if (animateIcons) {
            // Animate all the applications up now
            view.setAlpha(0f);
            view.setScaleX(0f);
            view.setScaleY(0f);
            bounceAnims.add(createNewAppBounceAnimation(view, i));
            newShortcutsScreenId = item.screenId;
        }
    }
    if (animateIcons) {
        // Animate to the correct page
        if (newShortcutsScreenId > -1) {
            long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
            final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
            final Runnable startBounceAnimRunnable = new Runnable() {

                public void run() {
                    anim.playTogether(bounceAnims);
                    anim.start();
                }
            };
            if (newShortcutsScreenId != currentScreenId) {
                // We post the animation slightly delayed to prevent slowdowns
                // when we are loading right after we return to launcher.
                mWorkspace.postDelayed(new Runnable() {

                    public void run() {
                        if (mWorkspace != null) {
                            mWorkspace.snapToPage(newScreenIndex);
                            mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
                        }
                    }
                }, NEW_APPS_PAGE_MOVE_DELAY);
            } else {
                mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
            }
        }
    }
    workspace.requestLayout();
}
#method_after
public void bindItems(final ArrayList<ItemInfo> shortcuts, final int start, final int end, final boolean forceAnimateIcons) {
    Runnable r = new Runnable() {

        public void run() {
            bindItems(shortcuts, start, end, forceAnimateIcons);
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    // Get the list of added shortcuts and intersect them with the set of shortcuts here
    final AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
    final Collection<Animator> bounceAnims = new ArrayList<Animator>();
    final boolean animateIcons = forceAnimateIcons && canRunNewAppsAnimation();
    Workspace workspace = mWorkspace;
    long newShortcutsScreenId = -1;
    for (int i = start; i < end; i++) {
        final ItemInfo item = shortcuts.get(i);
        // Short circuit if we are loading dock items for a configuration which has no dock
        if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT && mHotseat == null) {
            continue;
        }
        final View view;
        switch(item.itemType) {
            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
                ShortcutInfo info = (ShortcutInfo) item;
                view = createShortcut(info);
                /*
                     * TODO: FIX collision case
                     */
                if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
                    CellLayout cl = mWorkspace.getScreenWithId(item.screenId);
                    if (cl != null && cl.isOccupied(item.cellX, item.cellY)) {
                        View v = cl.getChildAt(item.cellX, item.cellY);
                        Object tag = v.getTag();
                        String desc = "Collision while binding workspace item: " + item + ". Collides with " + tag;
                        if (LauncherAppState.isDogfoodBuild()) {
                            throw (new RuntimeException(desc));
                        } else {
                            Log.d(TAG, desc);
                        }
                    }
                }
                break;
            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
                view = FolderIcon.fromXml(R.layout.folder_icon, this, (ViewGroup) workspace.getChildAt(workspace.getCurrentPage()), (FolderInfo) item, mIconCache);
                ((FolderIcon) view).setTextVisible(!mHideIconLabels);
                break;
            default:
                throw new RuntimeException("Invalid Item Type");
        }
        workspace.addInScreenFromBind(view, item.container, item.screenId, item.cellX, item.cellY, 1, 1);
        if (animateIcons) {
            // Animate all the applications up now
            view.setAlpha(0f);
            view.setScaleX(0f);
            view.setScaleY(0f);
            bounceAnims.add(createNewAppBounceAnimation(view, i));
            newShortcutsScreenId = item.screenId;
        }
    }
    if (animateIcons) {
        // Animate to the correct page
        if (newShortcutsScreenId > -1) {
            long currentScreenId = mWorkspace.getScreenIdForPageIndex(mWorkspace.getNextPage());
            final int newScreenIndex = mWorkspace.getPageIndexForScreenId(newShortcutsScreenId);
            final Runnable startBounceAnimRunnable = new Runnable() {

                public void run() {
                    anim.playTogether(bounceAnims);
                    anim.start();
                }
            };
            if (newShortcutsScreenId != currentScreenId) {
                // We post the animation slightly delayed to prevent slowdowns
                // when we are loading right after we return to launcher.
                mWorkspace.postDelayed(new Runnable() {

                    public void run() {
                        if (mWorkspace != null) {
                            mWorkspace.snapToPage(newScreenIndex);
                            mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
                        }
                    }
                }, NEW_APPS_PAGE_MOVE_DELAY);
            } else {
                mWorkspace.postDelayed(startBounceAnimRunnable, NEW_APPS_ANIMATION_DELAY);
            }
        }
    }
    workspace.requestLayout();
}
#end_block

#method_before
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (LOGD)
        Log.d(TAG, "onUpgrade triggered: " + oldVersion);
    switch(oldVersion) {
        // version of the DB.
        case 12:
            {
                // With the new shrink-wrapped and re-orderable workspaces, it makes sense
                // to persist workspace screens and their relative order.
                mMaxScreenId = 0;
                addWorkspacesTable(db);
            }
        case 13:
            {
                db.beginTransaction();
                try {
                    // Insert new column for holding widget provider name
                    db.execSQL("ALTER TABLE favorites " + "ADD COLUMN appWidgetProvider TEXT;");
                    db.setTransactionSuccessful();
                } catch (SQLException ex) {
                    Log.e(TAG, ex.getMessage(), ex);
                    // Old version remains, which means we wipe old data
                    break;
                } finally {
                    db.endTransaction();
                }
            }
        case 14:
            {
                db.beginTransaction();
                try {
                    // Insert new column for holding update timestamp
                    db.execSQL("ALTER TABLE favorites " + "ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;");
                    db.execSQL("ALTER TABLE workspaceScreens " + "ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;");
                    db.setTransactionSuccessful();
                } catch (SQLException ex) {
                    Log.e(TAG, ex.getMessage(), ex);
                    // Old version remains, which means we wipe old data
                    break;
                } finally {
                    db.endTransaction();
                }
            }
        case 15:
            {
                if (!addIntegerColumn(db, Favorites.RESTORED, 0)) {
                    // Old version remains, which means we wipe old data
                    break;
                }
            }
        case 16:
            {
                // We use the db version upgrade here to identify users who may not have seen
                // clings yet (because they weren't available), but for whom the clings are now
                // available (tablet users). Because one of the possible cling flows (migration)
                // is very destructive (wipes out workspaces), we want to prevent this from showing
                // until clear data. We do so by marking that the clings have been shown.
                LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
            }
        case 17:
            {
            // No-op
            }
        case 18:
            {
                // Due to a data loss bug, some users may have items associated with screen ids
                // which no longer exist. Since this can cause other problems, and since the user
                // will never see these items anyway, we use database upgrade as an opportunity to
                // clean things up.
                removeOrphanedItems(db);
            }
        case 19:
            {
                // Add userId column
                if (!addProfileColumn(db)) {
                    // Old version remains, which means we wipe old data
                    break;
                }
            }
        case 20:
            if (!updateFolderItemsRank(db, true)) {
                break;
            }
        case 21:
            // Recreate workspace table with screen id a primary key
            if (!recreateWorkspaceTable(db)) {
                break;
            }
        case 22:
            {
                if (!addIntegerColumn(db, Favorites.OPTIONS, 0)) {
                    // Old version remains, which means we wipe old data
                    break;
                }
            }
        case 23:
        // No-op
        case 24:
            ManagedProfileHeuristic.markExistingUsersForNoFolderCreation(mContext);
        case 25:
            convertShortcutsToLauncherActivities(db);
        case 26:
            {
                // DB Upgraded successfully
                return;
            }
    }
    // DB was not upgraded
    Log.w(TAG, "Destroying all old data.");
    createEmptyDB(db);
}
#method_after
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    if (LOGD)
        Log.d(TAG, "onUpgrade triggered: " + oldVersion);
    switch(oldVersion) {
        // version of the DB.
        case 12:
            {
                // With the new shrink-wrapped and re-orderable workspaces, it makes sense
                // to persist workspace screens and their relative order.
                mMaxScreenId = 0;
                addWorkspacesTable(db);
            }
        case 13:
            {
                db.beginTransaction();
                try {
                    // Insert new column for holding widget provider name
                    db.execSQL("ALTER TABLE favorites " + "ADD COLUMN appWidgetProvider TEXT;");
                    db.setTransactionSuccessful();
                } catch (SQLException ex) {
                    Log.e(TAG, ex.getMessage(), ex);
                    // Old version remains, which means we wipe old data
                    break;
                } finally {
                    db.endTransaction();
                }
            }
        case 14:
            {
                db.beginTransaction();
                try {
                    // Insert new column for holding update timestamp
                    db.execSQL("ALTER TABLE favorites " + "ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;");
                    db.execSQL("ALTER TABLE workspaceScreens " + "ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;");
                    db.setTransactionSuccessful();
                } catch (SQLException ex) {
                    Log.e(TAG, ex.getMessage(), ex);
                    // Old version remains, which means we wipe old data
                    break;
                } finally {
                    db.endTransaction();
                }
            }
        case 15:
            {
                if (!addIntegerColumn(db, Favorites.RESTORED, 0)) {
                    // Old version remains, which means we wipe old data
                    break;
                }
            }
        case 16:
            {
                // We use the db version upgrade here to identify users who may not have seen
                // clings yet (because they weren't available), but for whom the clings are now
                // available (tablet users). Because one of the possible cling flows (migration)
                // is very destructive (wipes out workspaces), we want to prevent this from showing
                // until clear data. We do so by marking that the clings have been shown.
                LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
            }
        case 17:
            {
            // No-op
            }
        case 18:
            {
                // Due to a data loss bug, some users may have items associated with screen ids
                // which no longer exist. Since this can cause other problems, and since the user
                // will never see these items anyway, we use database upgrade as an opportunity to
                // clean things up.
                removeOrphanedItems(db);
            }
        case 19:
            {
                // Add userId column
                if (!addProfileColumn(db)) {
                    // Old version remains, which means we wipe old data
                    break;
                }
            }
        case 20:
            if (!updateFolderItemsRank(db, true)) {
                break;
            }
        case 21:
            // Recreate workspace table with screen id a primary key
            if (!recreateWorkspaceTable(db)) {
                break;
            }
        case 22:
            {
                if (!addIntegerColumn(db, Favorites.OPTIONS, 0)) {
                    // Old version remains, which means we wipe old data
                    break;
                }
            }
        case 23:
        // No-op
        case 24:
            ManagedProfileHeuristic.markExistingUsersForNoFolderCreation(mContext);
        case 25:
            convertShortcutsToLauncherActivities(db);
        case 26:
            // add hidden column
            addIntegerColumn(db, "hidden", 0);
        case 27:
            {
                // DB Upgraded successfully
                return;
            }
    }
    // DB was not upgraded
    Log.w(TAG, "Destroying all old data.");
    createEmptyDB(db);
}
#end_block

#method_before
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mContentWrapper = findViewById(R.id.folder_content_wrapper);
    mContent = (FolderPagedView) findViewById(R.id.folder_content);
    mContent.setFolder(this);
    // We find out how tall footer wants to be (it is set to wrap_content), so that
    // we can allocate the appropriate amount of space for it.
    int measureSpec = MeasureSpec.UNSPECIFIED;
    mFolderName = (ExtendedEditText) findViewById(R.id.folder_name);
    mFolderName.setOnBackKeyListener(new ExtendedEditText.OnBackKeyListener() {

        @Override
        public boolean onBackKey() {
            // Close the activity on back key press
            doneEditingFolderName(true);
            return false;
        }
    });
    mFolderName.setOnFocusChangeListener(this);
    // We disable action mode for now since it messes up the view on phones
    mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
    mFolderName.setOnEditorActionListener(this);
    mFolderName.setSelectAllOnFocus(true);
    mFolderName.setInputType(mFolderName.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
    mFolderLock = (ImageView) findViewById(R.id.folder_lock);
    mFolderLock.measure(measureSpec, measureSpec);
    mFolderLock.setOnClickListener(this);
    mFolderLockHeight = mFolderLock.getMeasuredHeight();
    mFooter = findViewById(R.id.folder_footer);
    mFooter.measure(measureSpec, measureSpec);
    mFooterHeight = mFooter.getMeasuredHeight();
}
#method_after
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mContentWrapper = findViewById(R.id.folder_content_wrapper);
    mContent = (FolderPagedView) findViewById(R.id.folder_content);
    mContent.setFolder(this);
    // We find out how tall footer wants to be (it is set to wrap_content), so that
    // we can allocate the appropriate amount of space for it.
    int measureSpec = MeasureSpec.UNSPECIFIED;
    mFolderName = (ExtendedEditText) findViewById(R.id.folder_name);
    mFolderName.setOnBackKeyListener(new ExtendedEditText.OnBackKeyListener() {

        @Override
        public boolean onBackKey() {
            // Close the activity on back key press
            doneEditingFolderName(true);
            return false;
        }
    });
    mFolderName.setOnFocusChangeListener(this);
    // We disable action mode for now since it messes up the view on phones
    mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
    mFolderName.setOnEditorActionListener(this);
    mFolderName.setSelectAllOnFocus(true);
    mFolderName.setInputType(mFolderName.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
    boolean hideLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
    if (hideLabels) {
        mFolderName.setVisibility(View.GONE);
    }
    mFolderLock = (ImageView) findViewById(R.id.folder_lock);
    mFolderLock.measure(measureSpec, measureSpec);
    mFolderLock.setOnClickListener(this);
    mFolderLockHeight = mFolderLock.getMeasuredHeight();
    mFooter = findViewById(R.id.folder_footer);
    mFooter.measure(measureSpec, measureSpec);
    mFooterHeight = mFooter.getMeasuredHeight();
}
#end_block

#method_before
public void doneEditingFolderName(boolean commit) {
    mFolderName.setHint(sHintText);
    // Convert to a string here to ensure that no other state associated with the text field
    // gets saved.
    String newTitle = mFolderName.getText().toString();
    mInfo.setTitle(newTitle);
    LauncherModel.updateItemInDatabase(mLauncher, mInfo);
    if (commit) {
        sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String.format(getContext().getString(R.string.folder_renamed), newTitle));
    }
    // In order to clear the focus from the text field, we set the focus on ourself. This
    // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
    requestFocus();
    Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
    mIsEditingName = false;
}
#method_after
public void doneEditingFolderName(boolean commit) {
    mFolderName.setHint(sHintText);
    // Convert to a string here to ensure that no other state associated with the text field
    // gets saved.
    String newTitle = mFolderName.getText().toString();
    if (!SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default)) {
        mInfo.setTitle(newTitle);
    }
    LauncherModel.updateItemInDatabase(mLauncher, mInfo);
    if (commit) {
        sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String.format(getContext().getString(R.string.folder_renamed), newTitle));
    }
    // In order to clear the focus from the text field, we set the focus on ourself. This
    // ensures that every time the field is clicked, focus is gained, giving reliable behavior.
    requestFocus();
    Selection.setSelection((Spannable) mFolderName.getText(), 0, 0);
    mIsEditingName = false;
}
#end_block

#method_before
public void setWidgetsAndShortcuts(ArrayList<Object> rawWidgetsShortcuts) {
    Utilities.assertWorkerThread();
    mRawList = rawWidgetsShortcuts;
    if (DEBUG) {
        Log.d(TAG, "addWidgetsAndShortcuts, widgetsShortcuts#=" + rawWidgetsShortcuts.size());
    }
    // Temporary list for {@link PackageItemInfos} to avoid having to go through
    // {@link mPackageItemInfos} to locate the key to be used for {@link #mWidgetsList}
    HashMap<String, PackageItemInfo> tmpPackageItemInfos = new HashMap<>();
    // clear the lists.
    mWidgetsList.clear();
    mPackageItemInfos.clear();
    mWidgetAndShortcutNameComparator.reset();
    InvariantDeviceProfile idp = LauncherAppState.getInstance().getInvariantDeviceProfile();
    updateProtectedPackagesList(mContext);
    // add and update.
    for (Object o : rawWidgetsShortcuts) {
        String packageName = "";
        UserHandleCompat userHandle = null;
        ComponentName componentName = null;
        if (o instanceof LauncherAppWidgetProviderInfo) {
            LauncherAppWidgetProviderInfo widgetInfo = (LauncherAppWidgetProviderInfo) o;
            // Ensure that all widgets we show can be added on a workspace of this size
            int minSpanX = Math.min(widgetInfo.spanX, widgetInfo.minSpanX);
            int minSpanY = Math.min(widgetInfo.spanY, widgetInfo.minSpanY);
            if (minSpanX <= (int) idp.numColumns && minSpanY <= (int) idp.numRows) {
                componentName = widgetInfo.provider;
                packageName = widgetInfo.provider.getPackageName();
                userHandle = mAppWidgetMgr.getUser(widgetInfo);
            } else {
                if (DEBUG) {
                    Log.d(TAG, String.format("Widget %s : (%d X %d) can't fit on this device", widgetInfo.provider, minSpanX, minSpanY));
                }
                continue;
            }
        } else if (o instanceof ResolveInfo) {
            ResolveInfo resolveInfo = (ResolveInfo) o;
            componentName = new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);
            packageName = resolveInfo.activityInfo.packageName;
            userHandle = UserHandleCompat.myUserHandle();
        }
        if (componentName == null || userHandle == null) {
            Log.e(TAG, String.format("Widget cannot be set for %s.", o.getClass().toString()));
            continue;
        }
        if (mAppFilter != null && !mAppFilter.shouldShowApp(componentName)) {
            if (DEBUG) {
                Log.d(TAG, String.format("%s is filtered and not added to the widget tray.", packageName));
            }
            continue;
        }
        PackageItemInfo pInfo = tmpPackageItemInfos.get(packageName);
        ArrayList<Object> widgetsShortcutsList = mWidgetsList.get(pInfo);
        if (widgetsShortcutsList != null) {
            if (pInfo != null && isProtectedPackage(pInfo.flags, packageName)) {
                continue;
            }
            widgetsShortcutsList.add(o);
        } else {
            pInfo = new PackageItemInfo(packageName);
            if (isProtectedPackage(pInfo.flags, packageName)) {
                continue;
            }
            widgetsShortcutsList = new ArrayList<>();
            widgetsShortcutsList.add(o);
            mIconCache.getTitleAndIconForApp(packageName, userHandle, true, /* userLowResIcon */
            pInfo);
            pInfo.titleSectionName = mIndexer.computeSectionName(pInfo.title);
            mWidgetsList.put(pInfo, widgetsShortcutsList);
            tmpPackageItemInfos.put(packageName, pInfo);
            mPackageItemInfos.add(pInfo);
        }
    }
    // sort.
    Collections.sort(mPackageItemInfos, mAppNameComparator);
    for (PackageItemInfo p : mPackageItemInfos) {
        Collections.sort(mWidgetsList.get(p), mWidgetAndShortcutNameComparator);
    }
}
#method_after
public void setWidgetsAndShortcuts(ArrayList<Object> rawWidgetsShortcuts) {
    Utilities.assertWorkerThread();
    mRawList = rawWidgetsShortcuts;
    if (DEBUG) {
        Log.d(TAG, "addWidgetsAndShortcuts, widgetsShortcuts#=" + rawWidgetsShortcuts.size());
    }
    // Temporary list for {@link PackageItemInfos} to avoid having to go through
    // {@link mPackageItemInfos} to locate the key to be used for {@link #mWidgetsList}
    HashMap<String, PackageItemInfo> tmpPackageItemInfos = new HashMap<>();
    // clear the lists.
    mWidgetsList.clear();
    mPackageItemInfos.clear();
    mWidgetAndShortcutNameComparator.reset();
    InvariantDeviceProfile idp = LauncherAppState.getInstance().getInvariantDeviceProfile();
    ProtectedComponentsHelper.updateProtectedComponentsLists(mContext);
    // add and update.
    for (Object o : rawWidgetsShortcuts) {
        String packageName = "";
        UserHandleCompat userHandle = null;
        ComponentName componentName = null;
        if (o instanceof LauncherAppWidgetProviderInfo) {
            LauncherAppWidgetProviderInfo widgetInfo = (LauncherAppWidgetProviderInfo) o;
            // Ensure that all widgets we show can be added on a workspace of this size
            int minSpanX = Math.min(widgetInfo.spanX, widgetInfo.minSpanX);
            int minSpanY = Math.min(widgetInfo.spanY, widgetInfo.minSpanY);
            if (minSpanX <= (int) idp.numColumns && minSpanY <= (int) idp.numRows) {
                componentName = widgetInfo.provider;
                packageName = widgetInfo.provider.getPackageName();
                userHandle = mAppWidgetMgr.getUser(widgetInfo);
            } else {
                if (DEBUG) {
                    Log.d(TAG, String.format("Widget %s : (%d X %d) can't fit on this device", widgetInfo.provider, minSpanX, minSpanY));
                }
                continue;
            }
        } else if (o instanceof ResolveInfo) {
            ResolveInfo resolveInfo = (ResolveInfo) o;
            componentName = new ComponentName(resolveInfo.activityInfo.packageName, resolveInfo.activityInfo.name);
            packageName = resolveInfo.activityInfo.packageName;
            userHandle = UserHandleCompat.myUserHandle();
        }
        if (componentName == null || userHandle == null) {
            Log.e(TAG, String.format("Widget cannot be set for %s.", o.getClass().toString()));
            continue;
        }
        if (mAppFilter != null && !mAppFilter.shouldShowApp(componentName)) {
            if (DEBUG) {
                Log.d(TAG, String.format("%s is filtered and not added to the widget tray.", packageName));
            }
            continue;
        }
        PackageItemInfo pInfo = tmpPackageItemInfos.get(packageName);
        ArrayList<Object> widgetsShortcutsList = mWidgetsList.get(pInfo);
        if (widgetsShortcutsList != null) {
            if (pInfo != null && ProtectedComponentsHelper.isProtectedPackage(pInfo.flags, packageName)) {
                continue;
            }
            widgetsShortcutsList.add(o);
        } else {
            pInfo = new PackageItemInfo(packageName);
            if (ProtectedComponentsHelper.isProtectedPackage(pInfo.flags, packageName)) {
                continue;
            }
            widgetsShortcutsList = new ArrayList<>();
            widgetsShortcutsList.add(o);
            mIconCache.getTitleAndIconForApp(packageName, userHandle, true, /* userLowResIcon */
            pInfo);
            pInfo.titleSectionName = mIndexer.computeSectionName(pInfo.title);
            mWidgetsList.put(pInfo, widgetsShortcutsList);
            tmpPackageItemInfos.put(packageName, pInfo);
            mPackageItemInfos.add(pInfo);
        }
    }
    // sort.
    Collections.sort(mPackageItemInfos, mAppNameComparator);
    for (PackageItemInfo p : mPackageItemInfos) {
        Collections.sort(mWidgetsList.get(p), mWidgetAndShortcutNameComparator);
    }
}
#end_block

#method_before
@Override
protected void onResume() {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
        Log.v(TAG, "Launcher.onResume()");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnResume();
    }
    super.onResume();
    // Restore the previous launcher state
    if (mOnResumeState == State.WORKSPACE) {
        showWorkspace(false);
    } else if (mOnResumeState == State.APPS) {
        boolean launchedFromApp = (mWaitingForResume != null);
        // Don't update the predicted apps if the user is returning to launcher in the apps
        // view after launching an app, as they may be depending on the UI to be static to
        // switch to another app, otherwise, if it was
        showAppsView(false, /* animated */
        false, /* resetListToTop */
        !launchedFromApp, /* updatePredictedApps */
        false);
    } else if (mOnResumeState == State.WIDGETS) {
        showWidgetsView(false, false);
    }
    mOnResumeState = State.NONE;
    // Background was set to gradient in onPause(), restore to transparent if in all apps.
    setWorkspaceBackground(mState == State.WORKSPACE ? WORKSPACE_BACKGROUND_GRADIENT : WORKSPACE_BACKGROUND_TRANSPARENT);
    mPaused = false;
    if (mRestoring || mOnResumeNeedsLoad) {
        setWorkspaceLoading(true);
        // If we're starting binding all over again, clear any bind calls we'd postponed in
        // the past (see waitUntilResume) -- we don't need them since we're starting binding
        // from scratch again
        mBindOnResumeCallbacks.clear();
        mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        mRestoring = false;
        mOnResumeNeedsLoad = false;
    }
    if (mBindOnResumeCallbacks.size() > 0) {
        // We might have postponed some bind calls until onResume (see waitUntilResume) --
        // execute them here
        long startTimeCallbacks = 0;
        if (DEBUG_RESUME_TIME) {
            startTimeCallbacks = System.currentTimeMillis();
        }
        for (int i = 0; i < mBindOnResumeCallbacks.size(); i++) {
            mBindOnResumeCallbacks.get(i).run();
        }
        mBindOnResumeCallbacks.clear();
        if (DEBUG_RESUME_TIME) {
            Log.d(TAG, "Time spent processing callbacks in onResume: " + (System.currentTimeMillis() - startTimeCallbacks));
        }
    }
    if (mOnResumeCallbacks.size() > 0) {
        for (int i = 0; i < mOnResumeCallbacks.size(); i++) {
            mOnResumeCallbacks.get(i).run();
        }
        mOnResumeCallbacks.clear();
    }
    // were launching
    if (mWaitingForResume != null) {
        // Resets the previous workspace icon press state
        mWaitingForResume.setStayPressed(false);
    }
    // It is possible that widgets can receive updates while launcher is not in the foreground.
    // Consequently, the widgets will be inflated in the orientation of the foreground activity
    // (framework issue). On resuming, we ensure that any widgets are inflated for the current
    // orientation.
    getWorkspace().reinflateWidgetsIfNecessary();
    reinflateQSBIfNecessary();
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onResume: " + (System.currentTimeMillis() - startTime));
    }
    if (mWorkspace.getCustomContentCallbacks() != null) {
        // if PagedView#setRestorePage was set to the custom content page in onCreate().
        if (mWorkspace.isOnOrMovingToCustomContent()) {
            mWorkspace.getCustomContentCallbacks().onShow(true);
        }
    }
    updateInteraction(Workspace.State.NORMAL, mWorkspace.getState());
    mWorkspace.onResume();
    if (!isWorkspaceLoading()) {
        // Process any items that were added while Launcher was away.
        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onResume();
    }
    // Close out fragments
    Fragment gridFragment = getFragmentManager().findFragmentByTag(DynamicGridSizeFragment.DYNAMIC_GRID_SIZE_FRAGMENT);
    if (gridFragment != null) {
        mDynamicGridSizeFragment.setSize();
    }
    reloadLauncherIfNeeded();
    // Close out Fragments
    Fragment f1 = getFragmentManager().findFragmentByTag(HiddenFolderFragment.HIDDEN_FOLDER_FRAGMENT);
    if (f1 != null && !mHiddenFolderAuth) {
        mHiddenFolderFragment.saveHiddenFolderStatus(-1);
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        fragmentTransaction.remove(mHiddenFolderFragment).commit();
    } else {
        mHiddenFolderAuth = false;
    }
}
#method_after
@Override
protected void onResume() {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
        Log.v(TAG, "Launcher.onResume()");
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnResume();
    }
    super.onResume();
    // Restore the previous launcher state
    if (mOnResumeState == State.WORKSPACE) {
        showWorkspace(false);
    } else if (mOnResumeState == State.APPS) {
        boolean launchedFromApp = (mWaitingForResume != null);
        // Don't update the predicted apps if the user is returning to launcher in the apps
        // view after launching an app, as they may be depending on the UI to be static to
        // switch to another app, otherwise, if it was
        showAppsView(false, /* animated */
        false, /* resetListToTop */
        !launchedFromApp, /* updatePredictedApps */
        false);
    } else if (mOnResumeState == State.WIDGETS) {
        showWidgetsView(false, false);
    }
    mOnResumeState = State.NONE;
    // Background was set to gradient in onPause(), restore to transparent if in all apps.
    setWorkspaceBackground(mState == State.WORKSPACE ? WORKSPACE_BACKGROUND_GRADIENT : WORKSPACE_BACKGROUND_TRANSPARENT);
    mPaused = false;
    if (mRestoring || mOnResumeNeedsLoad) {
        setWorkspaceLoading(true);
        // If we're starting binding all over again, clear any bind calls we'd postponed in
        // the past (see waitUntilResume) -- we don't need them since we're starting binding
        // from scratch again
        mBindOnResumeCallbacks.clear();
        mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        mRestoring = false;
        mOnResumeNeedsLoad = false;
    }
    if (mBindOnResumeCallbacks.size() > 0) {
        // We might have postponed some bind calls until onResume (see waitUntilResume) --
        // execute them here
        long startTimeCallbacks = 0;
        if (DEBUG_RESUME_TIME) {
            startTimeCallbacks = System.currentTimeMillis();
        }
        for (int i = 0; i < mBindOnResumeCallbacks.size(); i++) {
            mBindOnResumeCallbacks.get(i).run();
        }
        mBindOnResumeCallbacks.clear();
        if (DEBUG_RESUME_TIME) {
            Log.d(TAG, "Time spent processing callbacks in onResume: " + (System.currentTimeMillis() - startTimeCallbacks));
        }
    }
    if (mOnResumeCallbacks.size() > 0) {
        for (int i = 0; i < mOnResumeCallbacks.size(); i++) {
            mOnResumeCallbacks.get(i).run();
        }
        mOnResumeCallbacks.clear();
    }
    // were launching
    if (mWaitingForResume != null) {
        // Resets the previous workspace icon press state
        mWaitingForResume.setStayPressed(false);
    }
    // It is possible that widgets can receive updates while launcher is not in the foreground.
    // Consequently, the widgets will be inflated in the orientation of the foreground activity
    // (framework issue). On resuming, we ensure that any widgets are inflated for the current
    // orientation.
    getWorkspace().reinflateWidgetsIfNecessary();
    reinflateQSBIfNecessary();
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onResume: " + (System.currentTimeMillis() - startTime));
    }
    if (mWorkspace.getCustomContentCallbacks() != null) {
        // if PagedView#setRestorePage was set to the custom content page in onCreate().
        if (mWorkspace.isOnOrMovingToCustomContent()) {
            mWorkspace.getCustomContentCallbacks().onShow(true);
        }
    }
    updateInteraction(Workspace.State.NORMAL, mWorkspace.getState());
    mWorkspace.onResume();
    if (!isWorkspaceLoading()) {
        // Process any items that were added while Launcher was away.
        InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onResume();
    }
    // Close out fragments
    Fragment gridFragment = getFragmentManager().findFragmentByTag(DynamicGridSizeFragment.DYNAMIC_GRID_SIZE_FRAGMENT);
    if (gridFragment != null) {
        mDynamicGridSizeFragment.setSize();
    }
    Fragment hiddenFolderFragment = getFragmentManager().findFragmentByTag(HiddenFolderFragment.HIDDEN_FOLDER_FRAGMENT);
    if (hiddenFolderFragment != null && !mHiddenFolderAuth) {
        mHiddenFolderFragment.saveHiddenFolderStatus(-1);
        FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
        fragmentTransaction.remove(mHiddenFolderFragment).commit();
    } else {
        mHiddenFolderAuth = false;
    }
}
#end_block

#method_before
private void setupViews() {
    final DragController dragController = mDragController;
    mLauncherView = findViewById(R.id.launcher);
    mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
    mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
    mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
    mWorkspace.setPageSwitchListener(this);
    mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
    mLauncherView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
    mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
    // Setup the drag layer
    mDragLayer.setup(this, dragController);
    // Setup the hotseat
    mHotseat = (Hotseat) findViewById(R.id.hotseat);
    if (mHotseat != null) {
        mHotseat.setOnLongClickListener(this);
    }
    // Setup the overview panel
    mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
    mOverviewSettingsPanel = new OverviewSettingsPanel(this);
    mOverviewSettingsPanel.initializeAdapter();
    mDarkPanel = mOverviewPanel.findViewById(R.id.dark_panel);
    mWidgetsButton = findViewById(R.id.widget_button);
    mWidgetsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickAddWidgetButton(arg0);
            }
        }
    });
    mWidgetsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View wallpaperButton = findViewById(R.id.wallpaper_button);
    wallpaperButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickWallpaperPicker(arg0);
            }
        }
    });
    wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View settingsButton = findViewById(R.id.settings_button);
    if (hasSettings()) {
        settingsButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                if (!mWorkspace.isSwitchingState()) {
                    onClickSettingsButton(arg0);
                }
            }
        });
        settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    } else {
        settingsButton.setVisibility(View.GONE);
    }
    View defaultScreenButton = findViewById(R.id.default_screen_button);
    defaultScreenButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickDefaultScreenButton(arg0);
            }
        }
    });
    defaultScreenButton.setOnTouchListener(getHapticFeedbackTouchListener());
    final VerticalSlidingPanel verticalSlidingPanel = ((VerticalSlidingPanel) mOverviewPanel);
    verticalSlidingPanel.setPanelSlideListener(new SettingsPanelSlideListener());
    verticalSlidingPanel.setEnableDragViewTouchEvents(true);
    View settingsPaneHeader = mOverviewPanel.findViewById(R.id.settings_pane_header);
    if (settingsPaneHeader != null) {
        verticalSlidingPanel.setDragView(settingsPaneHeader);
        settingsPaneHeader.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (verticalSlidingPanel.isExpanded()) {
                    verticalSlidingPanel.collapsePane();
                } else {
                    verticalSlidingPanel.expandPane();
                }
            }
        });
    }
    mOverviewPanel.setAlpha(0f);
    // Setup the workspace
    mWorkspace.setHapticFeedbackEnabled(false);
    mWorkspace.setOnLongClickListener(this);
    mWorkspace.setup(dragController);
    dragController.addDragListener(mWorkspace);
    // Get the search/delete bar
    mSearchDropTargetBar = (SearchDropTargetBar) mDragLayer.findViewById(R.id.search_drop_target_bar);
    // Setup Apps and Widgets
    mAppsView = (AllAppsContainerView) findViewById(R.id.apps_view);
    mWidgetsView = (WidgetsContainerView) findViewById(R.id.widgets_view);
    if (mLauncherCallbacks != null && mLauncherCallbacks.getAllAppsSearchBarController() != null) {
        mAppsView.setSearchBarController(mLauncherCallbacks.getAllAppsSearchBarController());
    } else {
        mAppsView.setSearchBarController(mAppsView.newDefaultAppSearchController());
    }
    mAppsView.setUseScrubber(mUseScrubber);
    mAppsView.setSectionStrategy(AllAppsContainerView.SECTION_STRATEGY_RAGGED);
    mAppsView.setGridTheme(AllAppsContainerView.GRID_THEME_DARK);
    mWidgetsView.setUseScrubber(false);
    // Setup the drag controller (drop targets have to be added in reverse order in priority)
    dragController.setDragScoller(mWorkspace);
    dragController.setScrollView(mDragLayer);
    dragController.setMoveTarget(mWorkspace);
    dragController.addDropTarget(mWorkspace);
    if (mSearchDropTargetBar != null) {
        mSearchDropTargetBar.setup(this, dragController);
        mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
    }
    if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
        Log.v(TAG, "adding WeightWatcher");
        mWeightWatcher = new WeightWatcher(this);
        mWeightWatcher.setAlpha(0.5f);
        ((FrameLayout) mLauncherView).addView(mWeightWatcher, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
        boolean show = shouldShowWeightWatcher();
        mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
    }
}
#method_after
private void setupViews() {
    final DragController dragController = mDragController;
    mLauncherView = findViewById(R.id.launcher);
    mFocusHandler = (FocusIndicatorView) findViewById(R.id.focus_indicator);
    mDragLayer = (DragLayer) findViewById(R.id.drag_layer);
    mWorkspace = (Workspace) mDragLayer.findViewById(R.id.workspace);
    mWorkspace.setPageSwitchListener(this);
    mPageIndicators = mDragLayer.findViewById(R.id.page_indicator);
    mLauncherView.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION);
    mWorkspaceBackgroundDrawable = getResources().getDrawable(R.drawable.workspace_bg);
    // Setup the drag layer
    mDragLayer.setup(this, dragController);
    // Setup the hotseat
    mHotseat = (Hotseat) findViewById(R.id.hotseat);
    if (mHotseat != null) {
        mHotseat.setOnLongClickListener(this);
    }
    // Setup the overview panel
    mOverviewPanel = (ViewGroup) findViewById(R.id.overview_panel);
    mOverviewSettingsPanel = new OverviewSettingsPanel(this);
    mOverviewSettingsPanel.initializeAdapter();
    mDarkPanel = mOverviewPanel.findViewById(R.id.dark_panel);
    mWidgetsButton = findViewById(R.id.widget_button);
    mWidgetsButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickAddWidgetButton(arg0);
            }
        }
    });
    mWidgetsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View wallpaperButton = findViewById(R.id.wallpaper_button);
    wallpaperButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickWallpaperPicker(arg0);
            }
        }
    });
    wallpaperButton.setOnTouchListener(getHapticFeedbackTouchListener());
    View settingsButton = findViewById(R.id.settings_button);
    if (hasSettings()) {
        settingsButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View arg0) {
                if (!mWorkspace.isSwitchingState()) {
                    onClickSettingsButton(arg0);
                }
            }
        });
        settingsButton.setOnTouchListener(getHapticFeedbackTouchListener());
    } else {
        settingsButton.setVisibility(View.GONE);
    }
    View defaultScreenButton = findViewById(R.id.default_screen_button);
    defaultScreenButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View arg0) {
            if (!mWorkspace.isSwitchingState()) {
                onClickDefaultScreenButton(arg0);
            }
        }
    });
    defaultScreenButton.setOnTouchListener(getHapticFeedbackTouchListener());
    final VerticalSlidingPanel verticalSlidingPanel = ((VerticalSlidingPanel) mOverviewPanel);
    verticalSlidingPanel.setPanelSlideListener(new SettingsPanelSlideListener());
    verticalSlidingPanel.setEnableDragViewTouchEvents(true);
    View settingsPaneHeader = mOverviewPanel.findViewById(R.id.settings_pane_header);
    if (settingsPaneHeader != null) {
        verticalSlidingPanel.setDragView(settingsPaneHeader);
        settingsPaneHeader.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                if (verticalSlidingPanel.isExpanded()) {
                    verticalSlidingPanel.collapsePane();
                } else {
                    verticalSlidingPanel.expandPane();
                }
            }
        });
    }
    mOverviewPanel.setAlpha(0f);
    // Setup the workspace
    mWorkspace.setHapticFeedbackEnabled(false);
    mWorkspace.setOnLongClickListener(this);
    mWorkspace.setup(dragController);
    dragController.addDragListener(mWorkspace);
    // Get the search/delete bar
    mSearchDropTargetBar = (SearchDropTargetBar) mDragLayer.findViewById(R.id.search_drop_target_bar);
    // Setup Apps and Widgets
    mAppsView = (AllAppsContainerView) findViewById(R.id.apps_view);
    mWidgetsView = (WidgetsContainerView) findViewById(R.id.widgets_view);
    if (mLauncherCallbacks != null && mLauncherCallbacks.getAllAppsSearchBarController() != null) {
        mAppsView.setSearchBarController(mLauncherCallbacks.getAllAppsSearchBarController());
    } else {
        mAppsView.setSearchBarController(mAppsView.newDefaultAppSearchController());
    }
    // Setup the drag controller (drop targets have to be added in reverse order in priority)
    dragController.setDragScoller(mWorkspace);
    dragController.setScrollView(mDragLayer);
    dragController.setMoveTarget(mWorkspace);
    dragController.addDropTarget(mWorkspace);
    if (mSearchDropTargetBar != null) {
        mSearchDropTargetBar.setup(this, dragController);
        mSearchDropTargetBar.setQsbSearchBar(getOrCreateQsbBar());
    }
    if (getResources().getBoolean(R.bool.debug_memory_enabled)) {
        Log.v(TAG, "adding WeightWatcher");
        mWeightWatcher = new WeightWatcher(this);
        mWeightWatcher.setAlpha(0.5f);
        ((FrameLayout) mLauncherView).addView(mWeightWatcher, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM));
        boolean show = shouldShowWeightWatcher();
        mWeightWatcher.setVisibility(show ? View.VISIBLE : View.GONE);
    }
}
#end_block

#method_before
public void reloadLauncher(int page) {
    mSearchDropTargetBar.setupQsb(this);
    // Re-initialize device profile
    LauncherAppState app = LauncherAppState.getInstance();
    app.initInvariantDeviceProfile();
    initializeDeviceProfile(app);
    mDeviceProfile.layout(this);
    // Reload
    mModel.resetLoadedState(true, true);
    int flag = mResizeGridRequired ? LauncherModel.LOADER_FLAG_RESIZE_GRID : LauncherModel.LOADER_FLAG_NONE;
    mModel.startLoader(page, flag);
    mWorkspace.updateCustomContentVisibility();
    mAppsView.reset();
    mReloadLauncher = false;
    mResizeGridRequired = false;
}
#method_after
public void reloadLauncher(boolean resizeGrid, boolean reloadAppDrawer) {
    reloadLauncher(mWorkspace.getCurrentPage(), resizeGrid, reloadAppDrawer);
}
#end_block

#method_before
public void setDynamicGridSize(InvariantDeviceProfile.GridSize size) {
    int gridSize = SettingsProvider.getIntCustomDefault(this, SettingsProvider.SETTINGS_UI_DYNAMIC_GRID_SIZE, 0);
    boolean customValuesChanged = false;
    if (gridSize == size.getValue() && size == InvariantDeviceProfile.GridSize.Custom) {
        int tempRows = SettingsProvider.getIntCustomDefault(this, SettingsProvider.SETTINGS_UI_HOMESCREEN_ROWS, mDeviceProfile.inv.numRows);
        int tempColumns = SettingsProvider.getIntCustomDefault(this, SettingsProvider.SETTINGS_UI_HOMESCREEN_COLUMNS, mDeviceProfile.inv.numColumns);
        if (tempColumns != mDeviceProfile.inv.numColumns || tempRows != mDeviceProfile.inv.numRows) {
            customValuesChanged = true;
        }
    }
    if (gridSize != size.getValue() || customValuesChanged) {
        SettingsProvider.putInt(this, SettingsProvider.SETTINGS_UI_DYNAMIC_GRID_SIZE, size.getValue());
        setReloadLauncher(true);
    }
    mOverviewSettingsPanel.notifyDataSetInvalidated();
    FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
    Configuration config = getResources().getConfiguration();
    if (config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
        fragmentTransaction.setCustomAnimations(0, R.anim.exit_out_left);
    } else {
        fragmentTransaction.setCustomAnimations(0, R.anim.exit_out_right);
    }
    fragmentTransaction.remove(mDynamicGridSizeFragment).commit();
    mDarkPanel.setVisibility(View.VISIBLE);
    ObjectAnimator anim = ObjectAnimator.ofFloat(mDarkPanel, "alpha", 0.3f, 0.0f);
    anim.start();
    anim.addListener(mAnimatorListener);
}
#method_after
public void setDynamicGridSize(InvariantDeviceProfile.GridSize size) {
    int gridSize = SettingsProvider.getIntCustomDefault(this, SettingsProvider.SETTINGS_UI_DYNAMIC_GRID_SIZE, 0);
    boolean customValuesChanged = false;
    if (gridSize == size.getValue() && size == InvariantDeviceProfile.GridSize.Custom) {
        int tempRows = SettingsProvider.getIntCustomDefault(this, SettingsProvider.SETTINGS_UI_HOMESCREEN_ROWS, mDeviceProfile.inv.numRows);
        int tempColumns = SettingsProvider.getIntCustomDefault(this, SettingsProvider.SETTINGS_UI_HOMESCREEN_COLUMNS, mDeviceProfile.inv.numColumns);
        if (tempColumns != mDeviceProfile.inv.numColumns || tempRows != mDeviceProfile.inv.numRows) {
            customValuesChanged = true;
        }
    }
    if (gridSize != size.getValue() || customValuesChanged) {
        SettingsProvider.putInt(this, SettingsProvider.SETTINGS_UI_DYNAMIC_GRID_SIZE, size.getValue());
        reloadLauncher(false, true);
    }
    mOverviewSettingsPanel.notifyDataSetInvalidated();
    FragmentTransaction fragmentTransaction = getFragmentManager().beginTransaction();
    Configuration config = getResources().getConfiguration();
    if (config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
        fragmentTransaction.setCustomAnimations(0, R.anim.exit_out_left);
    } else {
        fragmentTransaction.setCustomAnimations(0, R.anim.exit_out_right);
    }
    fragmentTransaction.remove(mDynamicGridSizeFragment).commit();
    mDarkPanel.setVisibility(View.VISIBLE);
    ObjectAnimator anim = ObjectAnimator.ofFloat(mDarkPanel, "alpha", 0.3f, 0.0f);
    anim.start();
    anim.addListener(mAnimatorListener);
}
#end_block

#method_before
@Override
protected void onNewIntent(Intent intent) {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
    }
    super.onNewIntent(intent);
    reloadLauncherIfNeeded();
    // Close the menu
    Folder openFolder = mWorkspace.getOpenFolder();
    boolean alreadyOnHome = mHasFocus && ((intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    boolean isActionMain = Intent.ACTION_MAIN.equals(intent.getAction());
    if (isActionMain) {
        // also will cancel mWaitingForResult.
        closeSystemDialogs();
        if (mWorkspace == null) {
            // Can be cases where mWorkspace is null, this prevents a NPE
            return;
        }
        // In all these cases, only animate if we're already on home
        mWorkspace.exitWidgetResizeMode();
        closeFolder();
        exitSpringLoadedDragMode();
        // otherwise, just wait until onResume to set the state back to Workspace
        if (alreadyOnHome) {
            showWorkspace(true);
        } else {
            mOnResumeState = State.WORKSPACE;
        }
        final View v = getWindow().peekDecorView();
        if (v != null && v.getWindowToken() != null) {
            InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
        }
        // Reset the apps view
        if (!alreadyOnHome && mAppsView != null) {
            mAppsView.scrollToTop();
        }
        // Reset the widgets view
        if (!alreadyOnHome && mWidgetsView != null) {
            mWidgetsView.scrollToTop();
        }
        if (mLauncherCallbacks != null) {
            mLauncherCallbacks.onHomeIntent();
        }
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onNewIntent(intent);
    }
    // animation.
    if (isActionMain) {
        boolean moveToDefaultScreen = mLauncherCallbacks != null ? mLauncherCallbacks.shouldMoveToDefaultScreenOnHomeIntent() : true;
        if (alreadyOnHome && mState == State.WORKSPACE && !mWorkspace.isTouchActive() && openFolder == null && moveToDefaultScreen) {
            mWorkspace.post(new Runnable() {

                @Override
                public void run() {
                    mWorkspace.moveToDefaultScreen(true);
                }
            });
        }
    }
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onNewIntent: " + (System.currentTimeMillis() - startTime));
    }
}
#method_after
@Override
protected void onNewIntent(Intent intent) {
    long startTime = 0;
    if (DEBUG_RESUME_TIME) {
        startTime = System.currentTimeMillis();
    }
    super.onNewIntent(intent);
    // Close the menu
    Folder openFolder = mWorkspace.getOpenFolder();
    boolean alreadyOnHome = mHasFocus && ((intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
    boolean isActionMain = Intent.ACTION_MAIN.equals(intent.getAction());
    if (isActionMain) {
        // also will cancel mWaitingForResult.
        closeSystemDialogs();
        if (mWorkspace == null) {
            // Can be cases where mWorkspace is null, this prevents a NPE
            return;
        }
        // In all these cases, only animate if we're already on home
        mWorkspace.exitWidgetResizeMode();
        closeFolder();
        exitSpringLoadedDragMode();
        // otherwise, just wait until onResume to set the state back to Workspace
        if (alreadyOnHome) {
            showWorkspace(true);
        } else {
            mOnResumeState = State.WORKSPACE;
        }
        final View v = getWindow().peekDecorView();
        if (v != null && v.getWindowToken() != null) {
            InputMethodManager imm = (InputMethodManager) getSystemService(INPUT_METHOD_SERVICE);
            imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
        }
        // Reset the apps view
        if (!alreadyOnHome && mAppsView != null) {
            mAppsView.scrollToTop();
        }
        // Reset the widgets view
        if (!alreadyOnHome && mWidgetsView != null) {
            mWidgetsView.scrollToTop();
        }
        if (mLauncherCallbacks != null) {
            mLauncherCallbacks.onHomeIntent();
        }
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onNewIntent(intent);
    }
    // animation.
    if (isActionMain) {
        boolean moveToDefaultScreen = mLauncherCallbacks != null ? mLauncherCallbacks.shouldMoveToDefaultScreenOnHomeIntent() : true;
        if (alreadyOnHome && mState == State.WORKSPACE && !mWorkspace.isTouchActive() && openFolder == null && moveToDefaultScreen) {
            mWorkspace.post(new Runnable() {

                @Override
                public void run() {
                    mWorkspace.moveToDefaultScreen(true);
                }
            });
        }
    }
    if (DEBUG_RESUME_TIME) {
        Log.d(TAG, "Time spent in onNewIntent: " + (System.currentTimeMillis() - startTime));
    }
}
#end_block

#method_before
void showWorkspace(int snapToPage, boolean animated, Runnable onCompleteRunnable) {
    reloadLauncherIfNeeded();
    boolean changed = mState != State.WORKSPACE || mWorkspace.getState() != Workspace.State.NORMAL;
    if (changed) {
        mWorkspace.setVisibility(View.VISIBLE);
        mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(), Workspace.State.NORMAL, snapToPage, animated, onCompleteRunnable);
        // Set focus to the AppsCustomize button
        if (mAllAppsButton != null) {
            mAllAppsButton.requestFocus();
        }
    }
    // Change the state *after* we've called all the transition code
    mState = State.WORKSPACE;
    // Resume the auto-advance of widgets
    mUserPresent = true;
    updateAutoAdvanceState();
    if (changed) {
        // Send an accessibility event to announce the context change
        getWindow().getDecorView().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
    }
}
#method_after
void showWorkspace(int snapToPage, boolean animated, Runnable onCompleteRunnable) {
    boolean changed = mState != State.WORKSPACE || mWorkspace.getState() != Workspace.State.NORMAL;
    if (changed) {
        mWorkspace.setVisibility(View.VISIBLE);
        mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(), Workspace.State.NORMAL, snapToPage, animated, onCompleteRunnable);
        // Set focus to the AppsCustomize button
        if (mAllAppsButton != null) {
            mAllAppsButton.requestFocus();
        }
    }
    // Change the state *after* we've called all the transition code
    mState = State.WORKSPACE;
    // Resume the auto-advance of widgets
    mUserPresent = true;
    updateAutoAdvanceState();
    if (changed) {
        // Send an accessibility event to announce the context change
        getWindow().getDecorView().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
    }
}
#end_block

#method_before
void showOverviewMode(boolean animated) {
    reloadLauncherIfNeeded();
    mWorkspace.setVisibility(View.VISIBLE);
    mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(), Workspace.State.OVERVIEW, WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated, null);
    mState = State.WORKSPACE;
}
#method_after
void showOverviewMode(boolean animated) {
    mWorkspace.setVisibility(View.VISIBLE);
    mStateTransitionAnimation.startAnimationToWorkspace(mState, mWorkspace.getState(), Workspace.State.OVERVIEW, WorkspaceStateTransitionAnimation.SCROLL_TO_CURRENT_PAGE, animated, null);
    mState = State.WORKSPACE;
}
#end_block

#method_before
public void finishBindingItems() {
    Runnable r = new Runnable() {

        public void run() {
            finishBindingItems();
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    if (mSavedState != null) {
        if (!mWorkspace.hasFocus()) {
            mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
        }
        mSavedState = null;
    }
    mWorkspace.restoreInstanceStateForRemainingPages();
    setWorkspaceLoading(false);
    sendLoadingCompleteBroadcastIfNecessary();
    // widget configuration forced an orientation change), process them now.
    if (sPendingAddItem != null) {
        final long screenId = completeAdd(sPendingAddItem);
        // TODO: this moves the user to the page where the pending item was added. Ideally,
        // the screen would be guaranteed to exist after bind, and the page would be set through
        // the workspace restore process.
        mWorkspace.post(new Runnable() {

            @Override
            public void run() {
                mWorkspace.snapToScreenId(screenId);
            }
        });
        sPendingAddItem = null;
    }
    InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.finishBindingItems(false);
    }
    mWorkspace.stripEmptyScreens();
    if (mWorkspace.isInOverviewMode()) {
        reloadLauncherIfNeeded();
    }
}
#method_after
public void finishBindingItems() {
    Runnable r = new Runnable() {

        public void run() {
            finishBindingItems();
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    if (mSavedState != null) {
        if (!mWorkspace.hasFocus()) {
            mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
        }
        mSavedState = null;
    }
    mWorkspace.restoreInstanceStateForRemainingPages();
    setWorkspaceLoading(false);
    sendLoadingCompleteBroadcastIfNecessary();
    // widget configuration forced an orientation change), process them now.
    if (sPendingAddItem != null) {
        final long screenId = completeAdd(sPendingAddItem);
        // TODO: this moves the user to the page where the pending item was added. Ideally,
        // the screen would be guaranteed to exist after bind, and the page would be set through
        // the workspace restore process.
        mWorkspace.post(new Runnable() {

            @Override
            public void run() {
                mWorkspace.snapToScreenId(screenId);
            }
        });
        sPendingAddItem = null;
    }
    InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.finishBindingItems(false);
    }
    mWorkspace.stripEmptyScreens();
}
#end_block

#method_before
@Override
protected void bindView(View v, int partition, Cursor cursor, int position) {
    TextView text = (TextView) v.findViewById(R.id.item_name);
    // RTL
    Configuration config = mLauncher.getResources().getConfiguration();
    if (config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
        text.setGravity(Gravity.RIGHT);
    }
    String title = cursor.getString(1);
    text.setText(title);
    v.setTag(new SettingsPosition(partition, position));
    Resources res = mLauncher.getResources();
    boolean current;
    String state;
    switch(partition) {
        case OverviewSettingsPanel.HOME_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SEARCH, R.bool.preferences_interface_homescreen_search_default);
                    state = current ? res.getString(R.string.setting_state_on) : res.getString(R.string.setting_state_off);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SCROLLING_WALLPAPER_SCROLL, R.bool.preferences_interface_homescreen_scrolling_wallpaper_scroll_default);
                    state = current ? res.getString(R.string.setting_state_on) : res.getString(R.string.setting_state_off);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 3:
                    updateDynamicGridSizeSettingsItem(v);
                    break;
                default:
                    ((TextView) v.findViewById(R.id.item_state)).setText("");
            }
            break;
        case OverviewSettingsPanel.DRAWER_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                default:
                    ((TextView) v.findViewById(R.id.item_state)).setText("");
            }
            break;
        default:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_GENERAL_ICONS_LARGE, R.bool.preferences_interface_general_icons_large_default);
                    state = current ? res.getString(R.string.setting_state_on) : res.getString(R.string.setting_state_off);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                default:
                    ((TextView) v.findViewById(R.id.item_state)).setText("");
            }
    }
    v.setOnClickListener(mSettingsItemListener);
}
#method_after
@Override
protected void bindView(View v, int partition, Cursor cursor, int position) {
    TextView text = (TextView) v.findViewById(R.id.item_name);
    // RTL
    Configuration config = mLauncher.getResources().getConfiguration();
    if (config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
        text.setGravity(Gravity.RIGHT);
    }
    String title = cursor.getString(1);
    text.setText(title);
    v.setTag(new SettingsPosition(partition, position));
    Resources res = mLauncher.getResources();
    boolean current;
    String state;
    switch(partition) {
        case OverviewSettingsPanel.HOME_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SEARCH, R.bool.preferences_interface_homescreen_search_default);
                    state = current ? res.getString(R.string.setting_state_on) : res.getString(R.string.setting_state_off);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SCROLLING_WALLPAPER_SCROLL, R.bool.preferences_interface_homescreen_scrolling_wallpaper_scroll_default);
                    state = current ? res.getString(R.string.setting_state_on) : res.getString(R.string.setting_state_off);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 3:
                    updateDynamicGridSizeSettingsItem(v);
                    break;
                default:
                    ((TextView) v.findViewById(R.id.item_state)).setText("");
            }
            break;
        case OverviewSettingsPanel.DRAWER_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_STYLE_USE_COMPACT, R.bool.preferences_interface_drawer_compact_default);
                    state = current ? res.getString(R.string.app_drawer_style_compact) : res.getString(R.string.app_drawer_style_sections);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_DARK, R.bool.preferences_interface_drawer_dark_default);
                    state = current ? res.getString(R.string.app_drawer_color_dark) : res.getString(R.string.app_drawer_color_light);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                case 3:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_USE_HORIZONTAL_SCRUBBER, R.bool.preferences_interface_use_horizontal_scrubber_default);
                    state = current ? res.getString(R.string.fast_scroller_type_horizontal) : res.getString(R.string.fast_scroller_type_vertical);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                default:
                    ((TextView) v.findViewById(R.id.item_state)).setText("");
            }
            break;
        default:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_GENERAL_ICONS_LARGE, R.bool.preferences_interface_general_icons_large_default);
                    state = current ? res.getString(R.string.setting_state_on) : res.getString(R.string.setting_state_off);
                    ((TextView) v.findViewById(R.id.item_state)).setText(state);
                    break;
                default:
                    ((TextView) v.findViewById(R.id.item_state)).setText("");
            }
    }
    v.setOnClickListener(mSettingsItemListener);
}
#end_block

#method_before
public void initializeAdapter() {
    // Settings pane Listview
    mListView = (PinnedHeaderListView) mLauncher.findViewById(R.id.settings_home_screen_listview);
    mListView.setOverScrollMode(ListView.OVER_SCROLL_NEVER);
    Resources res = mLauncher.getResources();
    String[] headers = new String[] { res.getString(R.string.home_screen_settings), res.getString(R.string.drawer_settings), res.getString(R.string.app_settings) };
    String[] values = new String[] { res.getString(R.string.home_screen_search_text), res.getString(R.string.icon_labels), res.getString(R.string.scrolling_wallpaper), res.getString(R.string.grid_size_text) };
    String[] valuesDrawer = new String[] { res.getString(R.string.icon_labels) };
    String[] valuesApp = new String[] { res.getString(R.string.larger_icons_text), res.getString(R.string.protected_app_settings) };
    mSettingsAdapter = new SettingsPinnedHeaderAdapter(mLauncher);
    mSettingsAdapter.setHeaders(headers);
    mSettingsAdapter.addPartition(false, true);
    mSettingsAdapter.addPartition(false, true);
    mSettingsAdapter.addPartition(false, true);
    mSettingsAdapter.mPinnedHeaderCount = headers.length;
    mSettingsAdapter.changeCursor(HOME_SETTINGS_POSITION, createCursor(headers[0], values));
    mSettingsAdapter.changeCursor(DRAWER_SETTINGS_POSITION, createCursor(headers[1], valuesDrawer));
    mSettingsAdapter.changeCursor(APP_SETTINGS_POSITION, createCursor(headers[2], valuesApp));
    mListView.setAdapter(mSettingsAdapter);
}
#method_after
public void initializeAdapter() {
    // Settings pane Listview
    mListView = (PinnedHeaderListView) mLauncher.findViewById(R.id.settings_home_screen_listview);
    mListView.setOverScrollMode(ListView.OVER_SCROLL_NEVER);
    Resources res = mLauncher.getResources();
    String[] headers = new String[] { res.getString(R.string.home_screen_settings), res.getString(R.string.drawer_settings), res.getString(R.string.app_settings) };
    String[] values = new String[] { res.getString(R.string.home_screen_search_text), res.getString(R.string.icon_labels), res.getString(R.string.scrolling_wallpaper), res.getString(R.string.grid_size_text) };
    String[] valuesDrawer = new String[] { res.getString(R.string.icon_labels), res.getString(R.string.app_drawer_style), res.getString(R.string.app_drawer_color), res.getString(R.string.fast_scroller_type) };
    String[] valuesApp = new String[] { res.getString(R.string.larger_icons_text), res.getString(R.string.protected_app_settings) };
    mSettingsAdapter = new SettingsPinnedHeaderAdapter(mLauncher);
    mSettingsAdapter.setHeaders(headers);
    mSettingsAdapter.addPartition(false, true);
    mSettingsAdapter.addPartition(false, true);
    mSettingsAdapter.addPartition(false, true);
    mSettingsAdapter.mPinnedHeaderCount = headers.length;
    mSettingsAdapter.changeCursor(HOME_SETTINGS_POSITION, createCursor(headers[0], values));
    mSettingsAdapter.changeCursor(DRAWER_SETTINGS_POSITION, createCursor(headers[1], valuesDrawer));
    mSettingsAdapter.changeCursor(APP_SETTINGS_POSITION, createCursor(headers[2], valuesApp));
    mListView.setAdapter(mSettingsAdapter);
}
#end_block

#method_before
private void updateAdapterItems() {
    SectionInfo lastSectionInfo = null;
    String lastSectionName = null;
    FastScrollSectionInfo lastFastScrollerSectionInfo = null;
    int position = 0;
    int appIndex = 0;
    // Prepare to update the list of sections, filtered apps, etc.
    mFilteredApps.clear();
    mFastScrollerSections.clear();
    mAdapterItems.clear();
    mSections.clear();
    if (DEBUG_PREDICTIONS) {
        if (mPredictedAppComponents.isEmpty() && !mApps.isEmpty()) {
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
        }
    }
    // Process the predicted app components
    mPredictedApps.clear();
    if (mPredictedAppComponents != null && !mPredictedAppComponents.isEmpty() && !hasFilter()) {
        for (ComponentKey ck : mPredictedAppComponents) {
            AppInfo info = mComponentToAppMap.get(ck);
            if (info != null) {
                mPredictedApps.add(info);
            } else {
                if (LauncherAppState.isDogfoodBuild()) {
                    Log.e(TAG, "Predicted app not found: " + ck.flattenToString(mLauncher));
                }
            }
            // Stop at the number of predicted apps
            if (mPredictedApps.size() == mNumPredictedAppsPerRow) {
                break;
            }
        }
        if (!mPredictedApps.isEmpty()) {
            // Add a section for the predictions
            lastSectionInfo = new SectionInfo();
            lastFastScrollerSectionInfo = new FastScrollSectionInfo("");
            AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            mAdapterItems.add(sectionItem);
            // Add the predicted app items
            for (AppInfo info : mPredictedApps) {
                AdapterItem appItem = AdapterItem.asPredictedApp(position++, lastSectionInfo, "", lastSectionInfo.numApps++, info, appIndex++);
                if (lastSectionInfo.firstAppItem == null) {
                    lastSectionInfo.firstAppItem = appItem;
                    lastFastScrollerSectionInfo.fastScrollToItem = appItem;
                }
                mAdapterItems.add(appItem);
                mFilteredApps.add(info);
            }
        }
    }
    updateProtectedAppsList(mLauncher);
    // ordered set of sections
    for (AppInfo info : getFiltersAppInfos()) {
        boolean system = (info.flags & AppInfo.DOWNLOADED_FLAG) == 0;
        if (mProtectedApps.contains(info.componentName) || (system && !getShowSystemApps()) || (!system && !getShowDownloadedApps())) {
            continue;
        }
        String sectionName = getAndUpdateCachedSectionName(info.title);
        // Create a new section if the section names do not match
        if (lastSectionInfo == null || !sectionName.equals(lastSectionName)) {
            lastSectionName = sectionName;
            lastSectionInfo = new SectionInfo();
            lastFastScrollerSectionInfo = new FastScrollSectionInfo(sectionName);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            // Create a new section item to break the flow of items in the list
            if (!hasFilter()) {
                AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
                mAdapterItems.add(sectionItem);
            }
        }
        // Create an app item
        AdapterItem appItem = AdapterItem.asApp(position++, lastSectionInfo, sectionName, lastSectionInfo.numApps++, info, appIndex++);
        if (lastSectionInfo.firstAppItem == null) {
            lastSectionInfo.firstAppItem = appItem;
            lastFastScrollerSectionInfo.fastScrollToItem = appItem;
        }
        mAdapterItems.add(appItem);
        mFilteredApps.add(info);
    }
    // Append the search market item if we are currently searching
    if (hasFilter()) {
        if (hasNoFilteredResults()) {
            mAdapterItems.add(AdapterItem.asEmptySearch(position++));
        } else {
            mAdapterItems.add(AdapterItem.asDivider(position++));
        }
        mAdapterItems.add(AdapterItem.asMarketSearch(position++));
    }
    // Merge multiple sections together as requested by the merge strategy for this device
    mergeSections();
    if (mNumAppsPerRow != 0) {
        // Update the number of rows in the adapter after we do all the merging (otherwise, we
        // would have to shift the values again)
        int numAppsInSection = 0;
        int numAppsInRow = 0;
        int rowIndex = -1;
        for (AdapterItem item : mAdapterItems) {
            item.rowIndex = 0;
            if (item.viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE) {
                numAppsInSection = 0;
            } else if (item.viewType == AllAppsGridAdapter.ICON_VIEW_TYPE || item.viewType == AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                if (numAppsInSection % mNumAppsPerRow == 0) {
                    numAppsInRow = 0;
                    rowIndex++;
                }
                item.rowIndex = rowIndex;
                item.rowAppIndex = numAppsInRow;
                numAppsInSection++;
                numAppsInRow++;
            }
        }
        mNumAppRowsInAdapter = rowIndex + 1;
        // Pre-calculate all the fast scroller fractions
        switch(mFastScrollDistributionMode) {
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_ROWS_FRACTION:
                float rowFraction = 1f / mNumAppRowsInAdapter;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    float subRowFraction = item.rowAppIndex * (rowFraction / mNumAppsPerRow);
                    info.touchFraction = item.rowIndex * rowFraction + subRowFraction;
                }
                break;
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_NUM_SECTIONS:
                float perSectionTouchFraction = 1f / mFastScrollerSections.size();
                float cumulativeTouchFraction = 0f;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    info.touchFraction = cumulativeTouchFraction;
                    cumulativeTouchFraction += perSectionTouchFraction;
                }
                break;
        }
    }
    // Refresh the recycler view
    if (mAdapter != null) {
        mAdapter.notifyDataSetChanged();
    }
}
#method_after
private void updateAdapterItems() {
    SectionInfo lastSectionInfo = null;
    String lastSectionName = null;
    FastScrollSectionInfo lastFastScrollerSectionInfo = null;
    int position = 0;
    int appIndex = 0;
    // Prepare to update the list of sections, filtered apps, etc.
    mFilteredApps.clear();
    mFastScrollerSections.clear();
    mAdapterItems.clear();
    mSections.clear();
    if (DEBUG_PREDICTIONS) {
        if (mPredictedAppComponents.isEmpty() && !mApps.isEmpty()) {
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
        }
    }
    // Process the predicted app components
    mPredictedApps.clear();
    if (mPredictedAppComponents != null && !mPredictedAppComponents.isEmpty() && !hasFilter()) {
        for (ComponentKey ck : mPredictedAppComponents) {
            AppInfo info = mComponentToAppMap.get(ck);
            if (info != null) {
                mPredictedApps.add(info);
            } else {
                if (LauncherAppState.isDogfoodBuild()) {
                    Log.e(TAG, "Predicted app not found: " + ck.flattenToString(mLauncher));
                }
            }
            // Stop at the number of predicted apps
            if (mPredictedApps.size() == mNumPredictedAppsPerRow) {
                break;
            }
        }
        if (!mPredictedApps.isEmpty()) {
            // Add a section for the predictions
            lastSectionInfo = new SectionInfo();
            lastFastScrollerSectionInfo = new FastScrollSectionInfo("");
            AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            mAdapterItems.add(sectionItem);
            // Add the predicted app items
            for (AppInfo info : mPredictedApps) {
                AdapterItem appItem = AdapterItem.asPredictedApp(position++, lastSectionInfo, "", lastSectionInfo.numApps++, info, appIndex++);
                if (lastSectionInfo.firstAppItem == null) {
                    lastSectionInfo.firstAppItem = appItem;
                    lastFastScrollerSectionInfo.fastScrollToItem = appItem;
                }
                mAdapterItems.add(appItem);
                mFilteredApps.add(info);
            }
        }
    }
    ProtectedComponentsHelper.updateProtectedComponentsLists(mLauncher);
    // ordered set of sections
    for (AppInfo info : getFiltersAppInfos()) {
        if (ProtectedComponentsHelper.isProtectedApp(info.flags, info.componentName)) {
            continue;
        }
        String sectionName = getAndUpdateCachedSectionName(info.title);
        // Create a new section if the section names do not match
        if (lastSectionInfo == null || !sectionName.equals(lastSectionName)) {
            lastSectionName = sectionName;
            lastSectionInfo = new SectionInfo();
            lastFastScrollerSectionInfo = new FastScrollSectionInfo(sectionName);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            // Create a new section item to break the flow of items in the list
            if (!hasFilter()) {
                AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
                mAdapterItems.add(sectionItem);
            }
        }
        // Create an app item
        AdapterItem appItem = AdapterItem.asApp(position++, lastSectionInfo, sectionName, lastSectionInfo.numApps++, info, appIndex++);
        if (lastSectionInfo.firstAppItem == null) {
            lastSectionInfo.firstAppItem = appItem;
            lastFastScrollerSectionInfo.fastScrollToItem = appItem;
        }
        mAdapterItems.add(appItem);
        mFilteredApps.add(info);
    }
    // Append the search market item if we are currently searching
    if (hasFilter()) {
        if (hasNoFilteredResults()) {
            mAdapterItems.add(AdapterItem.asEmptySearch(position++));
        } else {
            mAdapterItems.add(AdapterItem.asDivider(position++));
        }
        mAdapterItems.add(AdapterItem.asMarketSearch(position++));
    }
    // Merge multiple sections together as requested by the merge strategy for this device
    mergeSections();
    if (mNumAppsPerRow != 0) {
        // Update the number of rows in the adapter after we do all the merging (otherwise, we
        // would have to shift the values again)
        int numAppsInSection = 0;
        int numAppsInRow = 0;
        int rowIndex = -1;
        for (AdapterItem item : mAdapterItems) {
            item.rowIndex = 0;
            if (item.viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE) {
                numAppsInSection = 0;
            } else if (item.viewType == AllAppsGridAdapter.ICON_VIEW_TYPE || item.viewType == AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                if (numAppsInSection % mNumAppsPerRow == 0) {
                    numAppsInRow = 0;
                    rowIndex++;
                }
                item.rowIndex = rowIndex;
                item.rowAppIndex = numAppsInRow;
                numAppsInSection++;
                numAppsInRow++;
            }
        }
        mNumAppRowsInAdapter = rowIndex + 1;
        // Pre-calculate all the fast scroller fractions
        switch(mFastScrollDistributionMode) {
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_ROWS_FRACTION:
                float rowFraction = 1f / mNumAppRowsInAdapter;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    float subRowFraction = item.rowAppIndex * (rowFraction / mNumAppsPerRow);
                    info.touchFraction = item.rowIndex * rowFraction + subRowFraction;
                }
                break;
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_NUM_SECTIONS:
                float perSectionTouchFraction = 1f / mFastScrollerSections.size();
                float cumulativeTouchFraction = 0f;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    info.touchFraction = cumulativeTouchFraction;
                    cumulativeTouchFraction += perSectionTouchFraction;
                }
                break;
        }
    }
    // Refresh the recycler view
    if (mAdapter != null) {
        mAdapter.notifyDataSetChanged();
    }
}
#end_block

#method_before
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mScrollView = (ScrollView) findViewById(R.id.scroll_view);
    mContent = (CellLayout) findViewById(R.id.folder_content);
    int measureSpec = MeasureSpec.UNSPECIFIED;
    mFocusIndicatorHandler = new FocusIndicatorView(getContext());
    mContent.addView(mFocusIndicatorHandler, 0);
    mFocusIndicatorHandler.getLayoutParams().height = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
    mFocusIndicatorHandler.getLayoutParams().width = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    mContent.setCellDimensions(grid.folderCellWidthPx, grid.folderCellHeightPx);
    mContent.setGridSize(0, 0);
    mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
    mContent.setInvertIfRtl(true);
    mFolderName = (FolderEditText) findViewById(R.id.folder_name);
    mFolderName.setFolder(this);
    mFolderName.setOnFocusChangeListener(this);
    // We find out how tall the text view wants to be (it is set to wrap_content), so that
    // we can allocate the appropriate amount of space for it.
    mFolderName.measure(measureSpec, measureSpec);
    mFolderNameHeight = mFolderName.getMeasuredHeight();
    // We disable action mode for now since it messes up the view on phones
    mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
    mFolderName.setOnEditorActionListener(this);
    mFolderName.setSelectAllOnFocus(true);
    mFolderName.setInputType(mFolderName.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
    mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);
    mHideLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
    if (mHideLabels) {
        mFolderName.setVisibility(View.GONE);
    }
    mFolderNameLockContainer = findViewById(R.id.folder_name_lock_container);
    mFolderLock = (ImageView) findViewById(R.id.folder_lock);
    // Could be null if this Folder an instance of the RemoteFolder subclass
    if (mFolderLock != null) {
        mFolderLock.measure(measureSpec, measureSpec);
        mFolderLock.setOnClickListener(this);
        mFolderLockHeight = mFolderLock.getMeasuredHeight();
    }
    DisplayMetrics displayMetrics = this.getResources().getDisplayMetrics();
    mScreenWidth = displayMetrics.widthPixels;
}
#method_after
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mScrollView = (ScrollView) findViewById(R.id.scroll_view);
    mContent = (CellLayout) findViewById(R.id.folder_content);
    mFocusIndicatorHandler = new FocusIndicatorView(getContext());
    mContent.addView(mFocusIndicatorHandler, 0);
    mFocusIndicatorHandler.getLayoutParams().height = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
    mFocusIndicatorHandler.getLayoutParams().width = FocusIndicatorView.DEFAULT_LAYOUT_SIZE;
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    mContent.setCellDimensions(grid.folderCellWidthPx, grid.folderCellHeightPx);
    mContent.setGridSize(0, 0);
    mContent.getShortcutsAndWidgets().setMotionEventSplittingEnabled(false);
    mContent.setInvertIfRtl(true);
    mFolderName = (FolderEditText) findViewById(R.id.folder_name);
    mFolderName.setFolder(this);
    mFolderName.setOnFocusChangeListener(this);
    // We disable action mode for now since it messes up the view on phones
    mFolderName.setCustomSelectionActionModeCallback(mActionModeCallback);
    mFolderName.setOnEditorActionListener(this);
    mFolderName.setSelectAllOnFocus(true);
    mFolderName.setInputType(mFolderName.getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS | InputType.TYPE_TEXT_FLAG_CAP_WORDS);
    mAutoScrollHelper = new FolderAutoScrollHelper(mScrollView);
    mHideLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
    if (mHideLabels) {
        mFolderName.setVisibility(View.GONE);
    }
    mFolderNameLockContainer = findViewById(R.id.folder_name_lock_container);
    mFolderLock = (ImageView) findViewById(R.id.folder_lock);
    // Could be null if this Folder an instance of the RemoteFolder subclass
    if (mFolderLock != null) {
        mFolderLock.setOnClickListener(this);
    }
    DisplayMetrics displayMetrics = this.getResources().getDisplayMetrics();
    mScreenWidth = displayMetrics.widthPixels;
}
#end_block

#method_before
void bind(final FolderInfo info) {
    mInfo = info;
    ArrayList<ShortcutInfo> children = info.contents;
    ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
    setupContentForNumItems(children.size());
    placeInReadingOrder(children);
    int count = 0;
    for (int i = 0; i < children.size(); i++) {
        ShortcutInfo child = (ShortcutInfo) children.get(i);
        if (createAndAddShortcut(child) == null) {
            overflow.add(child);
        } else {
            count++;
        }
    }
    mItemsInvalidated = true;
    updateTextViewFocus();
    mInfo.addListener(this);
    setFolderName();
    updateItemLocationsInDatabase();
}
#method_after
void bind(final FolderInfo info) {
    mInfo = info;
    ArrayList<ShortcutInfo> children = info.contents;
    ArrayList<ShortcutInfo> overflow = new ArrayList<ShortcutInfo>();
    setupContentForNumItems(children.size());
    placeInReadingOrder(children);
    int count = 0;
    for (int i = 0; i < children.size(); i++) {
        ShortcutInfo child = (ShortcutInfo) children.get(i);
        if (createAndAddShortcut(child) == null) {
            overflow.add(child);
        } else {
            count++;
        }
    }
    // We rearrange the items in case there are any empty gaps
    setupContentForNumItems(count);
    // number of items.
    for (ShortcutInfo item : overflow) {
        mInfo.remove(item);
        LauncherModel.deleteItemFromDatabase(mLauncher, item);
    }
    mItemsInvalidated = true;
    updateTextViewFocus();
    mInfo.addListener(this);
    setFolderName();
    updateItemLocationsInDatabase();
}
#end_block

#method_before
static Folder fromXml(Context context) {
    return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, null);
}
#method_after
static Folder fromXml(Context context, ViewGroup root) {
    return (Folder) LayoutInflater.from(context).inflate(R.layout.user_folder, root, false);
}
#end_block

#method_before
public void animateOpen(Workspace workspace, int[] folderTouch) {
    if (!(getParent() instanceof DragLayer))
        return;
    Animator openFolderAnim = null;
    final Runnable onCompleteRunnable;
    if (!Utilities.isLmpOrAbove()) {
        positionAndSizeAsIcon();
        centerAboutIcon();
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
        final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
        oa.setDuration(mExpandDuration);
        openFolderAnim = oa;
        setLayerType(LAYER_TYPE_HARDWARE, null);
        onCompleteRunnable = new Runnable() {

            @Override
            public void run() {
                setLayerType(LAYER_TYPE_NONE, null);
            }
        };
    } else {
        centerAboutIcon();
        float transX = 0;
        float transY = getResources().getInteger(R.integer.folder_translate_y_dist);
        final float endTransX = 0;
        final float endTransY = 0;
        setTranslationX(transX);
        setTranslationY(transY);
        PropertyValuesHolder tx = PropertyValuesHolder.ofFloat("translationX", transX, endTransX);
        PropertyValuesHolder ty = PropertyValuesHolder.ofFloat("translationY", transY, endTransY);
        AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
        int[] folderLocation = new int[2];
        getLocationOnScreen(folderLocation);
        int circX = folderTouch[0] - folderLocation[0];
        int circY = folderTouch[1] - folderLocation[1];
        Animator circReveal = LauncherAnimUtils.createCircularReveal(this, circX, circY, 0, mScreenWidth);
        final View[] alphaViewSet;
        if (mInfo.isRemote()) {
            alphaViewSet = new View[] { mContent, mFolderName };
        } else {
            alphaViewSet = new View[] { mFolderNameLockContainer, mContent, mFolderName, mFolderLock };
        }
        for (View view : alphaViewSet) {
            view.setAlpha(0f);
        }
        circReveal.setDuration(150);
        circReveal.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                int i = 0;
                for (View view : alphaViewSet) {
                    view.setVisibility(VISIBLE);
                    Animator alphaAnimator = setupAlphaAnimator(view, 0f, 1f, mMaterialExpandDuration, mMaterialExpandStagger);
                    alphaAnimator.setStartDelay(ALPHA_DELAY_MULT * i);
                    alphaAnimator.start();
                    i++;
                }
            }
        });
        circReveal.start();
        Animator drift = LauncherAnimUtils.ofPropertyValuesHolder(this, tx, ty);
        drift.setDuration(mMaterialExpandDuration);
        drift.setStartDelay(mMaterialExpandStagger);
        drift.setInterpolator(new LogDecelerateInterpolator(60, 0));
        drift.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                // in low power mode the animation doesn't play, so set the end value here
                Folder.this.setTranslationX(endTransX);
                Folder.this.setTranslationY(endTransY);
            }
        });
        final ArrayList<View> layerViews = new ArrayList<View>();
        Animator workspaceAnim = workspace.getChangeStateAnimation(Workspace.State.NORMAL_HIDDEN, true, layerViews);
        if (workspaceAnim != null) {
            workspaceAnim.setStartDelay(mMaterialExpandStagger);
        }
        prepareFakeFolderIcon();
        float iconTransY = getResources().getInteger(R.integer.folder_icon_translate_y_dist);
        final View fakeFolderIconView = mLauncher.findViewById(R.id.reveal_fake_folder_icon);
        float baseIconTranslationY = fakeFolderIconView.getTranslationY();
        PropertyValuesHolder iconty = PropertyValuesHolder.ofFloat("translationY", baseIconTranslationY, baseIconTranslationY + iconTransY);
        PropertyValuesHolder iconAlpha = PropertyValuesHolder.ofFloat("alpha", 1f, 0f);
        Animator fakeFolderIcon = LauncherAnimUtils.ofPropertyValuesHolder(fakeFolderIconView, iconty, iconAlpha);
        fakeFolderIcon.setDuration(mMaterialExpandDuration);
        fakeFolderIcon.setInterpolator(new AccelerateInterpolator(1.5f));
        fakeFolderIcon.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationStart(Animator animation) {
                mFolderIcon.setAlpha(0);
                fakeFolderIconView.setVisibility(View.VISIBLE);
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                fakeFolderIconView.setVisibility(View.INVISIBLE);
            }
        });
        Animator revealAnim = null;
        prepareReveal();
        if (revealAnim != null) {
            anim.play(revealAnim);
        }
        anim.play(fakeFolderIcon);
        anim.play(drift);
        if (workspaceAnim != null) {
            anim.play(workspaceAnim);
        }
        openFolderAnim = anim;
        mContent.setLayerType(LAYER_TYPE_HARDWARE, null);
        onCompleteRunnable = new Runnable() {

            @Override
            public void run() {
                mContent.setLayerType(LAYER_TYPE_NONE, null);
            }
        };
    }
    openFolderAnim.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String.format(getContext().getString(R.string.folder_opened), mContent.getCountX(), mContent.getCountY()));
            mState = STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mState = STATE_OPEN;
            if (onCompleteRunnable != null) {
                onCompleteRunnable.run();
            }
            setFocusOnFirstChild();
        }
    });
    openFolderAnim.start();
    // Make sure the folder picks up the last drag move even if the finger doesn't move.
    if (mDragController.isDragging()) {
        mDragController.forceTouchMove();
    }
}
#method_after
public void animateOpen(Workspace workspace, int[] folderTouch) {
    if (!(getParent() instanceof DragLayer))
        return;
    Animator openFolderAnim = null;
    final Runnable onCompleteRunnable;
    if (!Utilities.isLmpOrAbove()) {
        positionAndSizeAsIcon();
        centerAboutIcon();
        PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat("alpha", 1);
        PropertyValuesHolder scaleX = PropertyValuesHolder.ofFloat("scaleX", 1.0f);
        PropertyValuesHolder scaleY = PropertyValuesHolder.ofFloat("scaleY", 1.0f);
        final ObjectAnimator oa = LauncherAnimUtils.ofPropertyValuesHolder(this, alpha, scaleX, scaleY);
        oa.setDuration(mExpandDuration);
        openFolderAnim = oa;
        setLayerType(LAYER_TYPE_HARDWARE, null);
        onCompleteRunnable = new Runnable() {

            @Override
            public void run() {
                setLayerType(LAYER_TYPE_NONE, null);
            }
        };
    } else {
        centerAboutIcon();
        float transX = 0;
        float transY = getResources().getInteger(R.integer.folder_translate_y_dist);
        final float endTransX = 0;
        final float endTransY = 0;
        setTranslationX(transX);
        setTranslationY(transY);
        PropertyValuesHolder tx = PropertyValuesHolder.ofFloat("translationX", transX, endTransX);
        PropertyValuesHolder ty = PropertyValuesHolder.ofFloat("translationY", transY, endTransY);
        AnimatorSet anim = LauncherAnimUtils.createAnimatorSet();
        int[] folderLocation = new int[2];
        getLocationOnScreen(folderLocation);
        int circX = folderTouch[0] - folderLocation[0];
        int circY = folderTouch[1] - folderLocation[1];
        Animator circReveal = LauncherAnimUtils.createCircularReveal(this, circX, circY, 0, mScreenWidth);
        final View[] alphaViewSet = new View[] { mFolderNameLockContainer, mContent, mFolderName, mFolderLock };
        for (View view : alphaViewSet) {
            view.setAlpha(0f);
        }
        circReveal.setDuration(150);
        circReveal.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                int i = 0;
                for (View view : alphaViewSet) {
                    view.setVisibility(VISIBLE);
                    Animator alphaAnimator = setupAlphaAnimator(view, 0f, 1f, mMaterialExpandDuration, mMaterialExpandStagger);
                    alphaAnimator.setStartDelay(ALPHA_DELAY_MULT * i);
                    alphaAnimator.start();
                    i++;
                }
            }
        });
        circReveal.start();
        Animator drift = LauncherAnimUtils.ofPropertyValuesHolder(this, tx, ty);
        drift.setDuration(mMaterialExpandDuration);
        drift.setStartDelay(mMaterialExpandStagger);
        drift.setInterpolator(new LogDecelerateInterpolator(60, 0));
        drift.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                // in low power mode the animation doesn't play, so set the end value here
                Folder.this.setTranslationX(endTransX);
                Folder.this.setTranslationY(endTransY);
            }
        });
        final ArrayList<View> layerViews = new ArrayList<View>();
        Animator workspaceAnim = workspace.getChangeStateAnimation(Workspace.State.NORMAL_HIDDEN, true, layerViews);
        if (workspaceAnim != null) {
            workspaceAnim.setStartDelay(mMaterialExpandStagger);
        }
        prepareFakeFolderIcon();
        float iconTransY = getResources().getInteger(R.integer.folder_icon_translate_y_dist);
        final View fakeFolderIconView = mLauncher.findViewById(R.id.reveal_fake_folder_icon);
        float baseIconTranslationY = fakeFolderIconView.getTranslationY();
        PropertyValuesHolder iconty = PropertyValuesHolder.ofFloat("translationY", baseIconTranslationY, baseIconTranslationY + iconTransY);
        PropertyValuesHolder iconAlpha = PropertyValuesHolder.ofFloat("alpha", 1f, 0f);
        Animator fakeFolderIcon = LauncherAnimUtils.ofPropertyValuesHolder(fakeFolderIconView, iconty, iconAlpha);
        fakeFolderIcon.setDuration(mMaterialExpandDuration);
        fakeFolderIcon.setInterpolator(new AccelerateInterpolator(1.5f));
        fakeFolderIcon.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationStart(Animator animation) {
                mFolderIcon.setAlpha(0);
                fakeFolderIconView.setVisibility(View.VISIBLE);
            }

            @Override
            public void onAnimationEnd(Animator animation) {
                fakeFolderIconView.setVisibility(View.INVISIBLE);
            }
        });
        Animator revealAnim = null;
        prepareReveal();
        if (revealAnim != null) {
            anim.play(revealAnim);
        }
        anim.play(fakeFolderIcon);
        anim.play(drift);
        if (workspaceAnim != null) {
            anim.play(workspaceAnim);
        }
        openFolderAnim = anim;
        mContent.setLayerType(LAYER_TYPE_HARDWARE, null);
        onCompleteRunnable = new Runnable() {

            @Override
            public void run() {
                mContent.setLayerType(LAYER_TYPE_NONE, null);
            }
        };
    }
    openFolderAnim.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animation) {
            sendCustomAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED, String.format(getContext().getString(R.string.folder_opened), mContent.getCountX(), mContent.getCountY()));
            mState = STATE_ANIMATING;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mState = STATE_OPEN;
            if (onCompleteRunnable != null) {
                onCompleteRunnable.run();
            }
            setFocusOnFirstChild();
        }
    });
    openFolderAnim.start();
    // Make sure the folder picks up the last drag move even if the finger doesn't move.
    if (mDragController.isDragging()) {
        mDragController.forceTouchMove();
    }
}
#end_block

#method_before
private void updateItemLocationsInDatabase() {
    ArrayList<View> list = getItemsInReadingOrder();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        ItemInfo info = (ItemInfo) v.getTag();
        LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0, info.cellX, info.cellY);
    }
}
#method_after
private void updateItemLocationsInDatabase() {
    if (!shouldUpdateContentsInDatabase())
        return;
    ArrayList<View> list = getItemsInReadingOrder();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        ItemInfo info = (ItemInfo) v.getTag();
        LauncherModel.moveItemInDatabase(mLauncher, info, mInfo.id, 0, info.cellX, info.cellY);
    }
}
#end_block

#method_before
private void updateItemLocationsInDatabaseBatch() {
    ArrayList<View> list = getItemsInReadingOrder();
    ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        ItemInfo info = (ItemInfo) v.getTag();
        items.add(info);
    }
    LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
}
#method_after
private void updateItemLocationsInDatabaseBatch() {
    if (!shouldUpdateContentsInDatabase())
        return;
    ArrayList<View> list = getItemsInReadingOrder();
    ArrayList<ItemInfo> items = new ArrayList<ItemInfo>();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        ItemInfo info = (ItemInfo) v.getTag();
        items.add(info);
    }
    LauncherModel.moveItemsInDatabase(mLauncher, items, mInfo.id, 0);
}
#end_block

#method_before
public void addItemLocationsInDatabase() {
    ArrayList<View> list = getItemsInReadingOrder();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        ItemInfo info = (ItemInfo) v.getTag();
        LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0, info.cellX, info.cellY, false);
    }
}
#method_after
public void addItemLocationsInDatabase() {
    if (!shouldUpdateContentsInDatabase())
        return;
    ArrayList<View> list = getItemsInReadingOrder();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        ItemInfo info = (ItemInfo) v.getTag();
        LauncherModel.addItemToDatabase(mLauncher, info, mInfo.id, 0, info.cellX, info.cellY, false);
    }
}
#end_block

#method_before
protected void centerAboutIcon() {
    int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
    int height = getFolderHeight();
    centerAboutIcon(width, height);
}
#method_after
protected void centerAboutIcon() {
    requestLayout();
    int width = getMeasuredWidth();
    int height = getMeasuredHeight();
    if (width > 0 && height > 0) {
        centerAboutIcon(width, height);
    }
}
#end_block

#method_before
protected void centerAboutIcon(int width, int height) {
    DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
    DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
    float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
    int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
    int centeredLeft = centerX - width / 2;
    int centeredTop = centerY - height / 2;
    int currentPage = mLauncher.getWorkspace().getNextPage();
    // In case the workspace is scrolling, we need to use the final scroll to compute
    // the folders bounds.
    mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
    // We first fetch the currently visible CellLayoutChildren
    CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
    ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
    Rect bounds = new Rect();
    parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
    // We reset the workspaces scroll
    mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);
    // Center the folder
    int left = (grid.availableWidthPx - width) / 2;
    // Drop the top down a little so it isn't bounded by the page indicators
    int top = (int) (bounds.top + (bounds.height() * 1.15) - height);
    if (width >= bounds.width()) {
        // If the folder doesn't fit within the bounds, center it about the desired bounds
        left = bounds.left + (bounds.width() - width) / 2;
    }
    int folderPivotX = width / 2 + (centeredLeft - left);
    int folderPivotY = height / 2 + (centeredTop - top);
    setPivotX(folderPivotX);
    setPivotY(folderPivotY);
    mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() * (1.0f * folderPivotX / width));
    mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() * (1.0f * folderPivotY / height));
    lp.width = width;
    lp.height = height;
    lp.x = left;
    lp.y = top;
    mLeft = left;
    mTop = top;
}
#method_after
private void centerAboutIcon(int width, int height) {
    DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
    DragLayer parent = (DragLayer) mLauncher.findViewById(R.id.drag_layer);
    float scale = parent.getDescendantRectRelativeToSelf(mFolderIcon, mTempRect);
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    int centerX = (int) (mTempRect.left + mTempRect.width() * scale / 2);
    int centerY = (int) (mTempRect.top + mTempRect.height() * scale / 2);
    int centeredLeft = centerX - width / 2;
    int centeredTop = centerY - height / 2;
    int currentPage = mLauncher.getWorkspace().getNextPage();
    // In case the workspace is scrolling, we need to use the final scroll to compute
    // the folders bounds.
    mLauncher.getWorkspace().setFinalScrollForPageChange(currentPage);
    // We first fetch the currently visible CellLayoutChildren
    CellLayout currentLayout = (CellLayout) mLauncher.getWorkspace().getChildAt(currentPage);
    ShortcutAndWidgetContainer boundingLayout = currentLayout.getShortcutsAndWidgets();
    Rect bounds = new Rect();
    parent.getDescendantRectRelativeToSelf(boundingLayout, bounds);
    // We reset the workspaces scroll
    mLauncher.getWorkspace().resetFinalScrollForPageChange(currentPage);
    // Center the folder
    int left = (grid.availableWidthPx - width) / 2;
    // Drop the top down a little so it isn't bounded by the page indicators
    int top = (int) (bounds.top + (bounds.height() * 1.15) - height);
    if (width >= bounds.width()) {
        // If the folder doesn't fit within the bounds, center it about the desired bounds
        left = bounds.left + (bounds.width() - width) / 2;
    }
    int folderPivotX = width / 2 + (centeredLeft - left);
    int folderPivotY = height / 2 + (centeredTop - top);
    setPivotX(folderPivotX);
    setPivotY(folderPivotY);
    mFolderIconPivotX = (int) (mFolderIcon.getMeasuredWidth() * (1.0f * folderPivotX / width));
    mFolderIconPivotY = (int) (mFolderIcon.getMeasuredHeight() * (1.0f * folderPivotY / height));
    lp.width = width;
    lp.height = height;
    lp.x = left;
    lp.y = top;
    mLeft = left;
    mTop = top;
}
#end_block

#method_before
private void setupContentForNumItems(int count) {
    setupContentDimensions(count);
    DragLayer.LayoutParams lp = (DragLayer.LayoutParams) getLayoutParams();
    if (lp == null) {
        lp = new DragLayer.LayoutParams(0, 0);
        lp.customPosition = true;
        setLayoutParams(lp);
    }
    centerAboutIcon();
}
#method_after
private void setupContentForNumItems(int count) {
    setupContentDimensions(count);
}
#end_block

#method_before
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int width = getPaddingLeft() + getPaddingRight() + mContent.getDesiredWidth();
    int height = getFolderHeight();
    int contentAreaWidthSpec = MeasureSpec.makeMeasureSpec(getContentAreaWidth(), MeasureSpec.EXACTLY);
    int contentAreaHeightSpec = MeasureSpec.makeMeasureSpec(getContentAreaHeight(), MeasureSpec.EXACTLY);
    if (LauncherAppState.isDisableAllApps()) {
        // Don't cap the height of the content to allow scrolling.
        mContent.setFixedSize(getContentAreaWidth(), mContent.getDesiredHeight());
    } else {
        mContent.setFixedSize(getContentAreaWidth(), getContentAreaHeight());
    }
    mScrollView.measure(contentAreaWidthSpec, contentAreaHeightSpec);
    if (TextUtils.isEmpty(mInfo.title)) {
        mFolderName.measure(contentAreaWidthSpec, MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
    }
    mFolderNameLockContainer.measure(contentAreaWidthSpec, MeasureSpec.makeMeasureSpec(mFolderNameHeight, MeasureSpec.EXACTLY));
    setMeasuredDimension(width, height);
}
#method_after
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    if (LauncherAppState.isDisableAllApps()) {
        // Don't cap the height of the content to allow scrolling.
        mContent.setFixedSize(getContentAreaWidth(), mContent.getDesiredHeight());
    } else {
        mContent.setFixedSize(getContentAreaWidth(), getContentAreaHeight());
    }
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
}
#end_block

#method_before
private void arrangeChildren(ArrayList<View> list) {
    int[] vacant = new int[2];
    if (list == null) {
        list = getItemsInReadingOrder();
    }
    mContent.removeAllViews();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        mContent.getVacantCell(vacant, 1, 1);
        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
        lp.cellX = vacant[0];
        lp.cellY = vacant[1];
        ItemInfo info = (ItemInfo) v.getTag();
        if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
            info.cellX = vacant[0];
            info.cellY = vacant[1];
            LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0, info.cellX, info.cellY);
        }
        boolean insert = false;
        mContent.addViewToCellLayout(v, insert ? 0 : -1, (int) info.id, lp, true);
    }
    mItemsInvalidated = true;
}
#method_after
private void arrangeChildren(ArrayList<View> list) {
    int[] vacant = new int[2];
    if (list == null) {
        list = getItemsInReadingOrder();
    }
    mContent.removeAllViews();
    for (int i = 0; i < list.size(); i++) {
        View v = list.get(i);
        mContent.getVacantCell(vacant, 1, 1);
        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) v.getLayoutParams();
        lp.cellX = vacant[0];
        lp.cellY = vacant[1];
        ItemInfo info = (ItemInfo) v.getTag();
        if (info.cellX != vacant[0] || info.cellY != vacant[1]) {
            info.cellX = vacant[0];
            info.cellY = vacant[1];
            if (shouldUpdateContentsInDatabase()) {
                LauncherModel.addOrMoveItemInDatabase(mLauncher, info, mInfo.id, 0, info.cellX, info.cellY);
            }
        }
        boolean insert = false;
        mContent.addViewToCellLayout(v, insert ? 0 : -1, (int) info.id, lp, true);
    }
    mItemsInvalidated = true;
}
#end_block

#method_before
private void replaceFolderWithFinalItem() {
    if (mInfo.isRemote()) {
        return;
    }
    if (mInfo.hidden && getItemCount() >= 1) {
        return;
    }
    // Add the last remaining child to the workspace in place of the folder
    Runnable onCompleteRunnable = new Runnable() {

        @Override
        public void run() {
            CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);
            View child = null;
            // Move the item from the folder to the workspace, in the position of the folder
            if (getItemCount() == 1) {
                ShortcutInfo finalItem = mInfo.contents.get(0);
                child = mLauncher.createShortcut(R.layout.application, cellLayout, finalItem);
                LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container, mInfo.screenId, mInfo.cellX, mInfo.cellY);
            }
            if (getItemCount() <= 1) {
                // Remove the folder
                LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                if (cellLayout != null) {
                    // b/12446428 -- sometimes the cell layout has already gone away?
                    cellLayout.removeView(mFolderIcon);
                }
                if (mFolderIcon instanceof DropTarget) {
                    mDragController.removeDropTarget((DropTarget) mFolderIcon);
                }
                mLauncher.removeFolder(mInfo);
            }
            // to ensure that hotseat items are placed correctly.
            if (child != null) {
                mLauncher.getWorkspace().addInScreenFromBind(child, mInfo.container, mInfo.screenId, mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
            }
        }
    };
    View finalChild = getItemAt(0);
    if (finalChild != null) {
        mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
    } else {
        mLauncher.runOnUiThread(onCompleteRunnable);
    }
    mDestroyed = true;
}
#method_after
protected void replaceFolderWithFinalItem() {
    if (mInfo.hidden && getItemCount() >= 1) {
        return;
    }
    // Add the last remaining child to the workspace in place of the folder
    Runnable onCompleteRunnable = new Runnable() {

        @Override
        public void run() {
            CellLayout cellLayout = mLauncher.getCellLayout(mInfo.container, mInfo.screenId);
            View child = null;
            // Move the item from the folder to the workspace, in the position of the folder
            if (getItemCount() == 1) {
                ShortcutInfo finalItem = mInfo.contents.get(0);
                child = mLauncher.createShortcut(R.layout.application, cellLayout, finalItem);
                LauncherModel.addOrMoveItemInDatabase(mLauncher, finalItem, mInfo.container, mInfo.screenId, mInfo.cellX, mInfo.cellY);
            }
            if (getItemCount() <= 1) {
                // Remove the folder
                LauncherModel.deleteItemFromDatabase(mLauncher, mInfo);
                if (cellLayout != null) {
                    // b/12446428 -- sometimes the cell layout has already gone away?
                    cellLayout.removeView(mFolderIcon);
                }
                if (mFolderIcon instanceof DropTarget) {
                    mDragController.removeDropTarget((DropTarget) mFolderIcon);
                }
                mLauncher.removeFolder(mInfo);
            }
            // to ensure that hotseat items are placed correctly.
            if (child != null) {
                mLauncher.getWorkspace().addInScreenFromBind(child, mInfo.container, mInfo.screenId, mInfo.cellX, mInfo.cellY, mInfo.spanX, mInfo.spanY);
            }
        }
    };
    View finalChild = getItemAt(0);
    if (finalChild != null) {
        mFolderIcon.performDestroyAnimation(finalChild, onCompleteRunnable);
    } else {
        mLauncher.runOnUiThread(onCompleteRunnable);
    }
    mDestroyed = true;
}
#end_block

#method_before
public void onDrop(DragObject d) {
    Runnable cleanUpRunnable = null;
    // until the folder closes
    if (d.dragSource != mLauncher.getWorkspace() && !(d.dragSource instanceof Folder)) {
        cleanUpRunnable = new Runnable() {

            @Override
            public void run() {
                mLauncher.exitSpringLoadedDragModeDelayed(true, Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
            }
        };
    }
    View currentDragView;
    ShortcutInfo si = mCurrentDragInfo;
    if (mIsExternalDrag) {
        si.cellX = mEmptyCell[0];
        si.cellY = mEmptyCell[1];
        // Actually move the item in the database if it was an external drag. Call this
        // before creating the view, so that ShortcutInfo is updated appropriately.
        LauncherModel.addOrMoveItemInDatabase(mLauncher, si, mInfo.id, 0, si.cellX, si.cellY);
        // We only need to update the locations if it doesn't get handled in #onDropCompleted.
        if (d.dragSource != this) {
            updateItemLocationsInDatabaseBatch();
        }
        mIsExternalDrag = false;
        currentDragView = createAndAddShortcut(si);
    } else {
        currentDragView = mCurrentDragView;
        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) currentDragView.getLayoutParams();
        si.cellX = lp.cellX = mEmptyCell[0];
        si.cellX = lp.cellY = mEmptyCell[1];
        mContent.addViewToCellLayout(currentDragView, -1, (int) si.id, lp, true);
    }
    if (d.dragView.hasDrawn()) {
        // Temporarily reset the scale such that the animation target gets calculated correctly.
        float scaleX = getScaleX();
        float scaleY = getScaleY();
        setScaleX(1.0f);
        setScaleY(1.0f);
        mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, currentDragView, cleanUpRunnable, null);
        setScaleX(scaleX);
        setScaleY(scaleY);
    } else {
        d.deferDragViewCleanupPostAnimation = false;
        currentDragView.setVisibility(VISIBLE);
    }
    mItemsInvalidated = true;
    setupContentDimensions(getItemCount());
    // Temporarily suppress the listener, as we did all the work already here.
    mSuppressOnAdd = true;
    mInfo.add(si);
    mSuppressOnAdd = false;
    // Clear the drag info, as it is no longer being dragged.
    mCurrentDragInfo = null;
}
#method_after
public void onDrop(DragObject d) {
    Runnable cleanUpRunnable = null;
    // until the folder closes
    if (d.dragSource != mLauncher.getWorkspace() && !(d.dragSource instanceof Folder)) {
        cleanUpRunnable = new Runnable() {

            @Override
            public void run() {
                mLauncher.exitSpringLoadedDragModeDelayed(true, Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
            }
        };
    }
    View currentDragView;
    ShortcutInfo si = mCurrentDragInfo;
    if (mIsExternalDrag) {
        si.cellX = mEmptyCell[0];
        si.cellY = mEmptyCell[1];
        // before creating the view, so that ShortcutInfo is updated appropriately.
        if (shouldUpdateContentsInDatabase()) {
            LauncherModel.addOrMoveItemInDatabase(mLauncher, si, mInfo.id, 0, si.cellX, si.cellY);
        }
        // We only need to update the locations if it doesn't get handled in #onDropCompleted.
        if (d.dragSource != this) {
            updateItemLocationsInDatabaseBatch();
        }
        mIsExternalDrag = false;
        currentDragView = createAndAddShortcut(si);
    } else {
        currentDragView = mCurrentDragView;
        CellLayout.LayoutParams lp = (CellLayout.LayoutParams) currentDragView.getLayoutParams();
        si.cellX = lp.cellX = mEmptyCell[0];
        si.cellX = lp.cellY = mEmptyCell[1];
        mContent.addViewToCellLayout(currentDragView, -1, (int) si.id, lp, true);
    }
    if (d.dragView.hasDrawn()) {
        // Temporarily reset the scale such that the animation target gets calculated correctly.
        float scaleX = getScaleX();
        float scaleY = getScaleY();
        setScaleX(1.0f);
        setScaleY(1.0f);
        mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, currentDragView, cleanUpRunnable, null);
        setScaleX(scaleX);
        setScaleY(scaleY);
    } else {
        d.deferDragViewCleanupPostAnimation = false;
        currentDragView.setVisibility(VISIBLE);
    }
    mItemsInvalidated = true;
    setupContentDimensions(getItemCount());
    // Temporarily suppress the listener, as we did all the work already here.
    mSuppressOnAdd = true;
    mInfo.add(si);
    mSuppressOnAdd = false;
    // Clear the drag info, as it is no longer being dragged.
    mCurrentDragInfo = null;
}
#end_block

#method_before
public void onAdd(ShortcutInfo item) {
    mItemsInvalidated = true;
    // with adding the item to the folder, as indicated by mSuppressOnAdd being set
    if (mSuppressOnAdd)
        return;
    if (!findAndSetEmptyCells(item)) {
        // The current layout is full, can we expand it?
        setupContentForNumItems(getItemCount() + 1);
        findAndSetEmptyCells(item);
    }
    createAndAddShortcut(item);
    LauncherModel.addOrMoveItemInDatabase(mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
}
#method_after
public void onAdd(ShortcutInfo item) {
    mItemsInvalidated = true;
    // with adding the item to the folder, as indicated by mSuppressOnAdd being set
    if (mSuppressOnAdd)
        return;
    if (!findAndSetEmptyCells(item)) {
        // The current layout is full, can we expand it?
        setupContentForNumItems(getItemCount() + 1);
        findAndSetEmptyCells(item);
    }
    createAndAddShortcut(item);
    if (shouldUpdateContentsInDatabase()) {
        LauncherModel.addOrMoveItemInDatabase(mLauncher, item, mInfo.id, 0, item.cellX, item.cellY);
    }
}
#end_block

#method_before
protected View getViewForInfo(ShortcutInfo item) {
    for (int j = 0; j < mContent.getCountY(); j++) {
        for (int i = 0; i < mContent.getCountX(); i++) {
            View v = mContent.getChildAt(i, j);
            if (v != null && v.getTag() == item) {
                return v;
            }
        }
    }
    return null;
}
#method_after
protected View getViewForInfo(ShortcutInfo item) {
    for (int j = 0; j < mContent.getCountY(); j++) {
        for (int i = 0; i < mContent.getCountX(); i++) {
            View v = mContent.getChildAt(i, j);
            if (v.getTag() == item) {
                return v;
            }
        }
    }
    return null;
}
#end_block

#method_before
public void setSearchBarController(AllAppsSearchBarController searchController) {
    if (mSearchBarController != null) {
        throw new RuntimeException("Expected search bar controller to only be set once");
    }
    mSearchBarController = searchController;
    mSearchBarController.initialize(mApps, this);
    // Add the new search view to the layout
    View searchBarView = searchController.getView(mSearchBarContainerView);
    mSearchBarContainerView.addView(searchBarView);
    mSearchBarContainerView.setVisibility(View.VISIBLE);
    mSearchBarView = searchBarView;
    setHasSearchBar(true);
    updateBackgroundAndPaddings();
}
#method_after
public void setSearchBarController(AllAppsSearchBarController searchController) {
    if (searchController == null) {
        mSearchBarController = null;
        return;
    }
    if (mSearchBarController != null) {
        throw new RuntimeException("Expected search bar controller to only be set once");
    }
    mSearchBarController = searchController;
    mSearchBarController.initialize(mApps, this);
    // Add the new search view to the layout
    View searchBarView = searchController.getView(mSearchBarContainerView);
    mSearchBarContainerView.addView(searchBarView);
    mSearchBarContainerView.setVisibility(View.VISIBLE);
    mSearchBarView = searchBarView;
    setHasSearchBar(true);
    updateBackgroundAndPaddings();
}
#end_block

#method_before
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Update the number of items in the grid before we measure the view
    int availableWidth = !mContentBounds.isEmpty() ? mContentBounds.width() : MeasureSpec.getSize(widthMeasureSpec);
    DeviceProfile grid = mLauncher.getDeviceProfile();
    grid.updateAppsViewNumCols(getResources(), availableWidth, mSectionStrategy);
    if (mNumAppsPerRow != grid.allAppsNumCols || mNumPredictedAppsPerRow != grid.allAppsNumPredictiveCols) {
        mNumAppsPerRow = grid.allAppsNumCols;
        mNumPredictedAppsPerRow = grid.allAppsNumPredictiveCols;
        // If there is a start margin to draw section names, determine how we are going to merge
        // app sections
        boolean mergeSectionsFully = mSectionStrategy == SECTION_STRATEGY_GRID;
        AlphabeticalAppsList.MergeAlgorithm mergeAlgorithm = mergeSectionsFully ? new FullMergeAlgorithm() : new SimpleSectionMergeAlgorithm((int) Math.ceil(mNumAppsPerRow / 2f), MIN_ROWS_IN_MERGED_SECTION_PHONE, MAX_NUM_MERGES_PHONE);
        mAppsRecyclerView.setNumAppsPerRow(grid, mNumAppsPerRow);
        mAdapter.setNumAppsPerRow(mNumAppsPerRow);
        mApps.setNumAppsPerRow(mNumAppsPerRow, mNumPredictedAppsPerRow, mergeAlgorithm);
    }
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
}
#method_after
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Update the number of items in the grid before we measure the view
    int availableWidth = !mContentBounds.isEmpty() ? mContentBounds.width() : MeasureSpec.getSize(widthMeasureSpec);
    DeviceProfile grid = mLauncher.getDeviceProfile();
    grid.updateAppsViewNumCols(getResources(), availableWidth, mSectionStrategy);
    if (mNumAppsPerRow != grid.allAppsNumCols || mNumPredictedAppsPerRow != grid.allAppsNumPredictiveCols) {
        mNumAppsPerRow = grid.allAppsNumCols;
        mNumPredictedAppsPerRow = grid.allAppsNumPredictiveCols;
        mAppsRecyclerView.setNumAppsPerRow(grid, mNumAppsPerRow);
        mAdapter.setNumAppsPerRow(mNumAppsPerRow);
        boolean mergeSections = mSectionStrategy == SECTION_STRATEGY_GRID;
        mApps.setNumAppsPerRow(mNumAppsPerRow, mNumPredictedAppsPerRow, mergeSections);
        mLauncher.getRemoteFolderManager().onMeasureDrawer(mNumPredictedAppsPerRow);
    }
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
}
#end_block

#method_before
@Override
public boolean dispatchKeyEvent(KeyEvent event) {
    // the key normally so that it can process this key event
    if (!mSearchBarController.isSearchFieldFocused() && event.getAction() == KeyEvent.ACTION_DOWN) {
        final int unicodeChar = event.getUnicodeChar();
        final boolean isKeyNotWhitespace = unicodeChar > 0 && !Character.isWhitespace(unicodeChar) && !Character.isSpaceChar(unicodeChar);
        if (isKeyNotWhitespace) {
            boolean gotKey = TextKeyListener.getInstance().onKeyDown(this, mSearchQueryBuilder, event.getKeyCode(), event);
            if (gotKey && mSearchQueryBuilder.length() > 0) {
                mSearchBarController.focusSearchField();
            }
        }
    }
    return super.dispatchKeyEvent(event);
}
#method_after
@Override
public boolean dispatchKeyEvent(KeyEvent event) {
    // the key normally so that it can process this key event
    if (mSearchBarController != null && !mSearchBarController.isSearchFieldFocused() && event.getAction() == KeyEvent.ACTION_DOWN) {
        final int unicodeChar = event.getUnicodeChar();
        final boolean isKeyNotWhitespace = unicodeChar > 0 && !Character.isWhitespace(unicodeChar) && !Character.isSpaceChar(unicodeChar);
        if (isKeyNotWhitespace) {
            boolean gotKey = TextKeyListener.getInstance().onKeyDown(this, mSearchQueryBuilder, event.getKeyCode(), event);
            if (gotKey && mSearchQueryBuilder.length() > 0) {
                mSearchBarController.focusSearchField();
            }
        }
    }
    return super.dispatchKeyEvent(event);
}
#end_block

#method_before
@Override
protected void bindView(View v, int partition, Cursor cursor, int position) {
    TextView nameView = (TextView) v.findViewById(R.id.item_name);
    TextView stateView = (TextView) v.findViewById(R.id.item_state);
    Switch settingSwitch = (Switch) v.findViewById(R.id.setting_switch);
    settingSwitch.setClickable(false);
    // RTL
    Configuration config = mLauncher.getResources().getConfiguration();
    if (config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
        nameView.setGravity(Gravity.RIGHT);
    }
    String title = cursor.getString(1);
    nameView.setText(title);
    v.setTag(new SettingsPosition(partition, position));
    Resources res = mLauncher.getResources();
    boolean current;
    String state;
    switch(partition) {
        case OverviewSettingsPanel.HOME_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SEARCH, R.bool.preferences_interface_homescreen_search_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SCROLLING_WALLPAPER_SCROLL, R.bool.preferences_interface_homescreen_scrolling_wallpaper_scroll_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 3:
                    updateDynamicGridSizeSettingsItem(v);
                    break;
                case 4:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_REMOTE_FOLDER, R.bool.preferences_interface_homescreen_remote_folder_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                default:
                    hideStates(stateView, settingSwitch);
            }
            break;
        case OverviewSettingsPanel.DRAWER_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_STYLE_USE_COMPACT, R.bool.preferences_interface_drawer_compact_default);
                    state = current ? res.getString(R.string.app_drawer_style_compact) : res.getString(R.string.app_drawer_style_sections);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_DARK, R.bool.preferences_interface_drawer_dark_default);
                    state = current ? res.getString(R.string.app_drawer_color_dark) : res.getString(R.string.app_drawer_color_light);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 3:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_USE_SCROLLER, R.bool.preferences_interface_use_scroller_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 4:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_USE_HORIZONTAL_SCRUBBER, R.bool.preferences_interface_use_horizontal_scrubber_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 5:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_SEARCH, R.bool.preferences_interface_drawer_search_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                default:
                    hideStates(stateView, settingSwitch);
            }
            break;
        case OverviewSettingsPanel.APP_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_GENERAL_ICONS_LARGE, R.bool.preferences_interface_general_icons_large_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_ALLOW_ROTATION, R.bool.preferences_interface_allow_rotation);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                default:
                    hideStates(stateView, settingSwitch);
            }
    }
    v.setOnClickListener(mSettingsItemListener);
}
#method_after
@Override
protected void bindView(View v, int partition, Cursor cursor, int position) {
    TextView nameView = (TextView) v.findViewById(R.id.item_name);
    TextView stateView = (TextView) v.findViewById(R.id.item_state);
    Switch settingSwitch = (Switch) v.findViewById(R.id.setting_switch);
    settingSwitch.setClickable(false);
    // RTL
    Configuration config = mLauncher.getResources().getConfiguration();
    if (config.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
        nameView.setGravity(Gravity.RIGHT);
    }
    String title = cursor.getString(1);
    nameView.setText(title);
    v.setTag(new SettingsPosition(partition, position));
    Resources res = mLauncher.getResources();
    boolean current;
    String state;
    switch(partition) {
        case OverviewSettingsPanel.HOME_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SEARCH, R.bool.preferences_interface_homescreen_search_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_HIDE_ICON_LABELS, R.bool.preferences_interface_homescreen_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_SCROLLING_WALLPAPER_SCROLL, R.bool.preferences_interface_homescreen_scrolling_wallpaper_scroll_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 3:
                    updateDynamicGridSizeSettingsItem(v);
                    break;
                case 4:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_HOMESCREEN_REMOTE_FOLDER, R.bool.preferences_interface_homescreen_remote_folder_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                default:
                    hideStates(stateView, settingSwitch);
            }
            break;
        case OverviewSettingsPanel.DRAWER_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
                    state = current ? res.getString(R.string.icon_labels_hide) : res.getString(R.string.icon_labels_show);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 1:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_STYLE_USE_COMPACT, R.bool.preferences_interface_drawer_compact_default);
                    state = current ? res.getString(R.string.app_drawer_style_compact) : res.getString(R.string.app_drawer_style_sections);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_DARK, R.bool.preferences_interface_drawer_dark_default);
                    state = current ? res.getString(R.string.app_drawer_color_dark) : res.getString(R.string.app_drawer_color_light);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 3:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_USE_SCROLLER, R.bool.preferences_interface_use_scroller_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 4:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_USE_HORIZONTAL_SCRUBBER, R.bool.preferences_interface_use_horizontal_scrubber_default);
                    state = current ? res.getString(R.string.fast_scroller_type_horizontal) : res.getString(R.string.fast_scroller_type_vertical);
                    setStateText(stateView, settingSwitch, state);
                    break;
                case 5:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_DRAWER_SEARCH, R.bool.preferences_interface_drawer_search_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                default:
                    hideStates(stateView, settingSwitch);
            }
            break;
        case OverviewSettingsPanel.APP_SETTINGS_POSITION:
            switch(position) {
                case 0:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_GENERAL_ICONS_LARGE, R.bool.preferences_interface_general_icons_large_default);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                case 2:
                    current = SettingsProvider.getBoolean(mContext, SettingsProvider.SETTINGS_UI_ALLOW_ROTATION, R.bool.preferences_interface_allow_rotation);
                    setSettingSwitch(stateView, settingSwitch, current);
                    break;
                default:
                    hideStates(stateView, settingSwitch);
            }
    }
    v.setOnClickListener(mSettingsItemListener);
}
#end_block

#method_before
public void removeAll() {
    contents.clear();
    for (int i = 0; i < listeners.size(); i++) {
        listeners.get(i).onRemoveAll();
    }
    itemsChanged();
}
#method_after
public void removeAll() {
    if (contents.isEmpty())
        return;
    contents.clear();
    for (int i = 0; i < listeners.size(); i++) {
        listeners.get(i).onRemoveAll();
    }
    itemsChanged();
}
#end_block

#method_before
public void removeAll(ArrayList<ShortcutInfo> items) {
    contents.removeAll(items);
    for (int i = 0; i < listeners.size(); i++) {
        listeners.get(i).onRemoveAll(items);
    }
    itemsChanged();
}
#method_after
public void removeAll(ArrayList<ShortcutInfo> items) {
    if (items.isEmpty())
        return;
    contents.removeAll(items);
    for (int i = 0; i < listeners.size(); i++) {
        listeners.get(i).onRemoveAll(items);
    }
    itemsChanged();
}
#end_block

#method_before
public void onDropCompleted(final View target, final DragObject d, final boolean isFlingToDelete, final boolean success) {
    if (mDeferDropAfterUninstall) {
        mDeferredAction = new Runnable() {

            public void run() {
                onDropCompleted(target, d, isFlingToDelete, success);
                mDeferredAction = null;
            }
        };
        return;
    }
    boolean beingCalledAfterUninstall = mDeferredAction != null;
    if (success && !(beingCalledAfterUninstall && !mUninstallSuccessful)) {
        if (target != this && mDragInfo != null) {
            removeWorkspaceItem(mDragInfo.cell);
        }
    } else if (mDragInfo != null) {
        final CellLayout cellLayout = mLauncher.getCellLayout(mDragInfo.container, mDragInfo.screenId);
        if (cellLayout != null) {
            cellLayout.onDropChild(mDragInfo.cell);
            cellLayout.setUseTempCoords(false);
            ((CellLayout.LayoutParams) target.getLayoutParams()).useTmpCoords = false;
        } else if (LauncherAppState.isDogfoodBuild()) {
            throw new RuntimeException("Invalid state: cellLayout == null in " + "Workspace#onDropCompleted. Please file a bug. ");
        }
        ;
    }
    if ((d.cancelled || (beingCalledAfterUninstall && !mUninstallSuccessful)) && mDragInfo.cell != null) {
        mDragInfo.cell.setVisibility(VISIBLE);
    }
    mDragOutline = null;
    mDragInfo = null;
}
#method_after
public void onDropCompleted(final View target, final DragObject d, final boolean isFlingToDelete, final boolean success) {
    if (mDeferDropAfterUninstall) {
        mDeferredAction = new Runnable() {

            public void run() {
                onDropCompleted(target, d, isFlingToDelete, success);
                mDeferredAction = null;
            }
        };
        return;
    }
    // Drop is finished, so we should use our actual cell coordinates now.
    if (mDragInfo != null) {
        ((CellLayout.LayoutParams) mDragInfo.cell.getLayoutParams()).useTmpCoords = false;
    }
    boolean beingCalledAfterUninstall = mDeferredAction != null;
    if (success && !(beingCalledAfterUninstall && !mUninstallSuccessful)) {
        if (target != this && mDragInfo != null) {
            removeWorkspaceItem(mDragInfo.cell);
        }
    } else if (mDragInfo != null) {
        final CellLayout cellLayout = mLauncher.getCellLayout(mDragInfo.container, mDragInfo.screenId);
        if (cellLayout != null) {
            cellLayout.onDropChild(mDragInfo.cell);
        } else if (LauncherAppState.isDogfoodBuild()) {
            throw new RuntimeException("Invalid state: cellLayout == null in " + "Workspace#onDropCompleted. Please file a bug. ");
        }
        ;
    }
    if ((d.cancelled || (beingCalledAfterUninstall && !mUninstallSuccessful)) && mDragInfo.cell != null) {
        mDragInfo.cell.setVisibility(VISIBLE);
    }
    mDragOutline = null;
    mDragInfo = null;
}
#end_block

#method_before
private void prepareFakeFolderIcon() {
    mFolderIcon.buildDrawingCache(true);
    Bitmap fakeFolderIcon = Bitmap.createBitmap(mFolderIcon.getDrawingCache());
    View fakeFolderIconView = mLauncher.findViewById(R.id.reveal_fake_folder_icon);
    FrameLayout.LayoutParams flp = (FrameLayout.LayoutParams) fakeFolderIconView.getLayoutParams();
    // Get globalVisibleRect of the folderIcon. getWidth and getHeight are inaccurate for
    // hotseat icons
    Rect rect = new Rect();
    mFolderIcon.getGlobalVisibleRect(rect);
    flp.height = rect.height();
    flp.width = rect.width();
    fakeFolderIconView.setLayoutParams(flp);
    int[] folderIconXY = new int[2];
    mFolderIcon.getLocationOnScreen(folderIconXY);
    fakeFolderIconView.setX(folderIconXY[0]);
    fakeFolderIconView.setY(folderIconXY[1]);
    fakeFolderIconView.setBackground(new BitmapDrawable(null, fakeFolderIcon));
    fakeFolderIconView.setVisibility(View.INVISIBLE);
}
#method_after
private void prepareFakeFolderIcon() {
    mFolderIcon.destroyDrawingCache();
    mFolderIcon.buildDrawingCache(true);
    Bitmap fakeFolderIcon = Bitmap.createBitmap(mFolderIcon.getDrawingCache());
    View fakeFolderIconView = mLauncher.findViewById(R.id.reveal_fake_folder_icon);
    FrameLayout.LayoutParams flp = (FrameLayout.LayoutParams) fakeFolderIconView.getLayoutParams();
    // Get globalVisibleRect of the folderIcon. getWidth and getHeight are inaccurate for
    // hotseat icons
    Rect rect = new Rect();
    mFolderIcon.getGlobalVisibleRect(rect);
    flp.height = rect.height();
    flp.width = rect.width();
    fakeFolderIconView.setLayoutParams(flp);
    int[] folderIconXY = new int[2];
    mFolderIcon.getLocationOnScreen(folderIconXY);
    fakeFolderIconView.setX(folderIconXY[0]);
    fakeFolderIconView.setY(folderIconXY[1]);
    fakeFolderIconView.setBackground(new BitmapDrawable(null, fakeFolderIcon));
    fakeFolderIconView.setVisibility(View.INVISIBLE);
}
#end_block

#method_before
public void onRemove(ShortcutInfo item) {
    mItemsInvalidated = true;
    // the work associated with removing the item, so we don't have to do anything here.
    if (item == mCurrentDragInfo)
        return;
    mContent.removeView(getViewForInfo(item));
    if (mState == STATE_ANIMATING) {
        mRearrangeOnClose = true;
    } else {
        rearrangeChildren();
    }
    if (getItemCount() <= 1) {
        replaceFolderWithFinalItem();
    }
}
#method_after
public void onRemove(ShortcutInfo item) {
    mItemsInvalidated = true;
    // the work associated with removing the item, so we don't have to do anything here.
    if (item == mCurrentDragInfo)
        return;
    mContent.removeItem(getViewForInfo(item));
    if (mState == STATE_ANIMATING) {
        mRearrangeOnClose = true;
    } else {
        rearrangeChildren();
    }
    if (getItemCount() <= 1) {
        replaceFolderWithFinalItem();
    }
}
#end_block

#method_before
@Override
public void onRemoveAll(ArrayList<ShortcutInfo> items) {
    removeViewsForItems(items);
    if (mInfo.contents.isEmpty()) {
        mLauncher.closeFolder(this);
    }
    replaceFolderWithFinalItem();
}
#method_after
@Override
public void onRemoveAll(ArrayList<ShortcutInfo> items) {
    removeViewsForItems(items);
    if (mState == STATE_ANIMATING) {
        mRearrangeOnClose = true;
    } else {
        rearrangeChildren();
    }
    if (mInfo.contents.isEmpty()) {
        mLauncher.closeFolder(this);
    }
    replaceFolderWithFinalItem();
}
#end_block

#method_before
protected void removeViewsForItems(ArrayList<ShortcutInfo> items) {
    if (items == null) {
        mContent.removeAllViews();
    } else {
        for (ShortcutInfo item : items) {
            mContent.removeView(getViewForInfo(item));
        }
    }
}
#method_after
protected void removeViewsForItems(ArrayList<ShortcutInfo> items) {
    mItemsInvalidated = true;
    if (items == null) {
        mContent.removeAllItems();
    } else {
        for (ShortcutInfo item : items) {
            mContent.removeItem(getViewForInfo(item));
        }
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    super.onCreate(savedInstanceState);
    LauncherAppState.setApplicationContext(getApplicationContext());
    LauncherAppState app = LauncherAppState.getInstance();
    initializeDeviceProfile(app);
    mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mDragController = new DragController(this);
    mInflater = getLayoutInflater();
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this);
    mStats = new Stats(this);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    mRemoteFolderManager = new RemoteFolderManager(this);
    mRemoteDrawerEnabled = SettingsProvider.getBoolean(this, null, R.bool.preferences_interface_homescreen_remote_folder_default);
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    if (PROFILE_STARTUP) {
        android.os.Debug.startMethodTracing(Environment.getExternalStorageDirectory() + "/launcher");
    }
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this);
    lockAllApps();
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (PROFILE_STARTUP) {
        android.os.Debug.stopMethodTracing();
    }
    if (!mRestoring) {
        if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
            // If the user leaves launcher, then we should just load items asynchronously when
            // they return.
            mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        } else {
            // We only load the page synchronously if the user rotates (or triggers a
            // configuration change) while launcher is in the foreground
            mModel.startLoader(mWorkspace.getRestorePage());
        }
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    registerReceiver(mCloseSystemDialogsReceiver, filter);
    mRotationEnabled = Utilities.isRotationAllowedForDevice(getApplicationContext());
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext(), false);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
        if (mLauncherCallbacks.hasLauncherOverlay()) {
            ViewStub stub = (ViewStub) findViewById(R.id.launcher_overlay_stub);
            mLauncherOverlayContainer = (InsettableFrameLayout) stub.inflate();
            mLauncherOverlay = mLauncherCallbacks.setLauncherOverlayView(mLauncherOverlayContainer, mLauncherOverlayCallbacks);
            mWorkspace.setLauncherOverlay(mLauncherOverlay);
        }
    }
    if (shouldShowIntroScreen()) {
        showIntroScreen();
    } else {
        showFirstRunActivity();
        showFirstRunClings();
    }
    IntentFilter protectedAppsFilter = new IntentFilter(cyanogenmod.content.Intent.ACTION_PROTECTED_CHANGED);
    registerReceiver(protectedAppsChangedReceiver, protectedAppsFilter, cyanogenmod.platform.Manifest.permission.PROTECTED_APP, null);
    IntentFilter searchBarVisibilityFilter = new IntentFilter(SettingsPinnedHeaderAdapter.ACTION_SEARCH_BAR_VISIBILITY_CHANGED);
    registerReceiver(searchBarVisibilityChangedReceiver, searchBarVisibilityFilter);
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG_STRICT_MODE) {
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectDiskReads().detectDiskWrites().detectNetwork().penaltyLog().build());
        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder().detectLeakedSqlLiteObjects().detectLeakedClosableObjects().penaltyLog().penaltyDeath().build());
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.preOnCreate();
    }
    super.onCreate(savedInstanceState);
    LauncherAppState.setApplicationContext(getApplicationContext());
    LauncherAppState app = LauncherAppState.getInstance();
    initializeDeviceProfile(app);
    mSharedPrefs = getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE);
    mIsSafeModeEnabled = getPackageManager().isSafeMode();
    mDragController = new DragController(this);
    mInflater = getLayoutInflater();
    mStateTransitionAnimation = new LauncherStateTransitionAnimation(this);
    mStats = new Stats(this);
    mAppWidgetManager = AppWidgetManagerCompat.getInstance(this);
    mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
    mAppWidgetHost.startListening();
    if (sRemoteFolderManager == null) {
        sRemoteFolderManager = new RemoteFolderManager(this);
    } else {
        sRemoteFolderManager.onRecreateLauncher(this);
    }
    mRemoteDrawerEnabled = SettingsProvider.getBoolean(this, null, R.bool.preferences_interface_homescreen_remote_folder_default);
    // If we are getting an onCreate, we can actually preempt onResume and unset mPaused here,
    // this also ensures that any synchronous binding below doesn't re-trigger another
    // LauncherModel load.
    mPaused = false;
    if (PROFILE_STARTUP) {
        android.os.Debug.startMethodTracing(Environment.getExternalStorageDirectory() + "/launcher");
    }
    setContentView(R.layout.launcher);
    setupViews();
    mDeviceProfile.layout(this);
    lockAllApps();
    mSavedState = savedInstanceState;
    restoreState(mSavedState);
    if (PROFILE_STARTUP) {
        android.os.Debug.stopMethodTracing();
    }
    if (!mRestoring) {
        if (DISABLE_SYNCHRONOUS_BINDING_CURRENT_PAGE) {
            // If the user leaves launcher, then we should just load items asynchronously when
            // they return.
            mModel.startLoader(PagedView.INVALID_RESTORE_PAGE);
        } else {
            // We only load the page synchronously if the user rotates (or triggers a
            // configuration change) while launcher is in the foreground
            mModel.startLoader(mWorkspace.getRestorePage());
        }
    }
    // For handling default keys
    mDefaultKeySsb = new SpannableStringBuilder();
    Selection.setSelection(mDefaultKeySsb, 0);
    IntentFilter filter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    registerReceiver(mCloseSystemDialogsReceiver, filter);
    mRotationEnabled = Utilities.isRotationAllowedForDevice(getApplicationContext());
    // if the user has specifically allowed rotation.
    if (!mRotationEnabled) {
        mRotationEnabled = Utilities.isAllowRotationPrefEnabled(getApplicationContext(), false);
    }
    // On large interfaces, or on devices that a user has specifically enabled screen rotation,
    // we want the screen to auto-rotate based on the current orientation
    setOrientation();
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.onCreate(savedInstanceState);
        if (mLauncherCallbacks.hasLauncherOverlay()) {
            ViewStub stub = (ViewStub) findViewById(R.id.launcher_overlay_stub);
            mLauncherOverlayContainer = (InsettableFrameLayout) stub.inflate();
            mLauncherOverlay = mLauncherCallbacks.setLauncherOverlayView(mLauncherOverlayContainer, mLauncherOverlayCallbacks);
            mWorkspace.setLauncherOverlay(mLauncherOverlay);
        }
    }
    if (shouldShowIntroScreen()) {
        showIntroScreen();
    } else {
        showFirstRunActivity();
        showFirstRunClings();
    }
    IntentFilter protectedAppsFilter = new IntentFilter(cyanogenmod.content.Intent.ACTION_PROTECTED_CHANGED);
    registerReceiver(protectedAppsChangedReceiver, protectedAppsFilter, cyanogenmod.platform.Manifest.permission.PROTECTED_APP, null);
    IntentFilter searchBarVisibilityFilter = new IntentFilter(SettingsPinnedHeaderAdapter.ACTION_SEARCH_BAR_VISIBILITY_CHANGED);
    registerReceiver(searchBarVisibilityChangedReceiver, searchBarVisibilityFilter);
}
#end_block

#method_before
public void reloadAppDrawer() {
    List<AppInfo> addedApps = mAppsView.getApps();
    mDragLayer.removeView(mAppsView);
    mAppsView = (AllAppsContainerView) LayoutInflater.from(this).inflate(R.layout.all_apps, mDragLayer, false);
    mDragLayer.addView(mAppsView, mDragLayer.getChildCount() - 1);
    mAppsView.setVisibility(View.INVISIBLE);
    setupSearchBar(this);
    mAppsView.addApps(addedApps);
    tryAndUpdatePredictedApps();
    mAppsView.reset();
    mRemoteFolderManager.onReloadAppDrawer();
}
#method_after
public void reloadAppDrawer() {
    List<AppInfo> addedApps = mAppsView.getApps();
    mDragLayer.removeView(mAppsView);
    mAppsView = (AllAppsContainerView) LayoutInflater.from(this).inflate(R.layout.all_apps, mDragLayer, false);
    mDragLayer.addView(mAppsView, mDragLayer.getChildCount() - 1);
    mAppsView.setVisibility(View.INVISIBLE);
    setupSearchBar(this);
    mAppsView.addApps(addedApps);
    tryAndUpdatePredictedApps();
    mAppsView.reset();
    sRemoteFolderManager.onReloadAppDrawer();
}
#end_block

#method_before
public RemoteFolderManager getRemoteFolderManager() {
    return mRemoteFolderManager;
}
#method_after
public RemoteFolderManager getRemoteFolderManager() {
    return sRemoteFolderManager;
}
#end_block

#method_before
public void openFolder(FolderIcon folderIcon, int[] folderTouch) {
    Folder folder = folderIcon.getFolder();
    if (folder.getState() == Folder.STATE_ANIMATING) {
        return;
    }
    Folder openFolder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
    if (openFolder != null && openFolder != folder) {
        // Close any open folder before opening a folder.
        closeFolder();
    }
    FolderInfo info = folder.mInfo;
    if (info.hidden) {
        folder.startHiddenFolderManager();
        return;
    }
    info.opened = true;
    // While the folder is open, the position of the icon cannot change.
    ((CellLayout.LayoutParams) folderIcon.getLayoutParams()).canReorder = false;
    // There was a one-off crash where the folder had a parent already.
    if (folder.getParent() == null) {
        mDragLayer.addView(folder);
        mDragController.addDropTarget((DropTarget) folder);
    } else {
        Log.w(TAG, "Opening folder (" + folder + ") which already has a parent (" + folder.getParent() + ").");
    }
    folder.animateOpen();
    /*growAndFadeOutFolderIcon(folderIcon);*/
    // Notify the accessibility manager that this folder "window" has appeared and occluded
    // the workspace items
    folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
    getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
}
#method_after
public void openFolder(FolderIcon folderIcon, int[] folderTouch) {
    Folder folder = folderIcon.getFolder();
    if (folder.getState() == Folder.STATE_ANIMATING) {
        return;
    }
    Folder openFolder = mWorkspace != null ? mWorkspace.getOpenFolder() : null;
    if (openFolder != null && openFolder != folder) {
        // Close any open folder before opening a folder.
        closeFolder();
    }
    FolderInfo info = folder.mInfo;
    if (info.hidden) {
        folder.startHiddenFolderManager();
        return;
    }
    info.opened = true;
    // While the folder is open, the position of the icon cannot change.
    ((CellLayout.LayoutParams) folderIcon.getLayoutParams()).canReorder = false;
    // There was a one-off crash where the folder had a parent already.
    if (folder.getParent() == null) {
        mDragLayer.addView(folder);
        mDragController.addDropTarget((DropTarget) folder);
    } else {
        Log.w(TAG, "Opening folder (" + folder + ") which already has a parent (" + folder.getParent() + ").");
        return;
    }
    folder.animateOpen();
    /*growAndFadeOutFolderIcon(folderIcon);*/
    // Notify the accessibility manager that this folder "window" has appeared and occluded
    // the workspace items
    folder.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);
    getDragLayer().sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED);
}
#end_block

#method_before
void showAppsView(boolean animated, boolean resetListToTop, boolean updatePredictedApps, boolean focusSearchBar) {
    if (resetListToTop) {
        mAppsView.scrollToTop();
    }
    if (updatePredictedApps) {
        tryAndUpdatePredictedApps();
    }
    showAppsOrWidgets(State.APPS, animated, focusSearchBar);
    mRemoteFolderManager.onAppDrawerOpened();
}
#method_after
void showAppsView(boolean animated, boolean resetListToTop, boolean updatePredictedApps, boolean focusSearchBar) {
    if (resetListToTop) {
        mAppsView.scrollToTop();
    }
    if (updatePredictedApps) {
        tryAndUpdatePredictedApps();
    }
    showAppsOrWidgets(State.APPS, animated, focusSearchBar);
    sRemoteFolderManager.onAppDrawerOpened();
}
#end_block

#method_before
public void bindAppsAdded(final ArrayList<Long> newScreens, final ArrayList<ItemInfo> addNotAnimated, final ArrayList<ItemInfo> addAnimated, final ArrayList<AppInfo> addedApps) {
    Runnable r = new Runnable() {

        public void run() {
            bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    // Add the new screens
    if (newScreens != null) {
        bindAddScreens(newScreens);
    }
    // animations on the new page (which we will try and snap to).
    if (addNotAnimated != null && !addNotAnimated.isEmpty()) {
        bindItems(addNotAnimated, 0, addNotAnimated.size(), false);
    }
    if (addAnimated != null && !addAnimated.isEmpty()) {
        bindItems(addAnimated, 0, addAnimated.size(), true);
    }
    // Remove the extra empty screen
    mWorkspace.removeExtraEmptyScreen(false, false);
    if (addedApps != null && mAppsView != null) {
        mAppsView.addApps(addedApps);
        mRemoteFolderManager.onBindAddApps(addedApps);
    }
}
#method_after
public void bindAppsAdded(final ArrayList<Long> newScreens, final ArrayList<ItemInfo> addNotAnimated, final ArrayList<ItemInfo> addAnimated, final ArrayList<AppInfo> addedApps) {
    Runnable r = new Runnable() {

        public void run() {
            bindAppsAdded(newScreens, addNotAnimated, addAnimated, addedApps);
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    // Add the new screens
    if (newScreens != null) {
        bindAddScreens(newScreens);
    }
    // animations on the new page (which we will try and snap to).
    if (addNotAnimated != null && !addNotAnimated.isEmpty()) {
        bindItems(addNotAnimated, 0, addNotAnimated.size(), false);
    }
    if (addAnimated != null && !addAnimated.isEmpty()) {
        bindItems(addAnimated, 0, addAnimated.size(), true);
    }
    // Remove the extra empty screen
    mWorkspace.removeExtraEmptyScreen(false, false);
    if (addedApps != null && mAppsView != null) {
        mAppsView.addApps(addedApps);
        sRemoteFolderManager.onBindAddApps(addedApps);
    }
}
#end_block

#method_before
public void finishBindingItems() {
    Runnable r = new Runnable() {

        public void run() {
            finishBindingItems();
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    if (mSavedState != null) {
        if (!mWorkspace.hasFocus()) {
            mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
        }
        mSavedState = null;
    }
    mWorkspace.restoreInstanceStateForRemainingPages();
    setWorkspaceLoading(false);
    sendLoadingCompleteBroadcastIfNecessary();
    // widget configuration forced an orientation change), process them now.
    if (sPendingAddItem != null) {
        final long screenId = completeAdd(sPendingAddItem);
        // TODO: this moves the user to the page where the pending item was added. Ideally,
        // the screen would be guaranteed to exist after bind, and the page would be set through
        // the workspace restore process.
        mWorkspace.post(new Runnable() {

            @Override
            public void run() {
                mWorkspace.snapToScreenId(screenId);
            }
        });
        sPendingAddItem = null;
    }
    InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.finishBindingItems(false);
    }
    mWorkspace.stripEmptyScreens();
    mRemoteFolderManager.bindFinished();
}
#method_after
public void finishBindingItems() {
    Runnable r = new Runnable() {

        public void run() {
            finishBindingItems();
        }
    };
    if (waitUntilResume(r)) {
        return;
    }
    if (mSavedState != null) {
        if (!mWorkspace.hasFocus()) {
            mWorkspace.getChildAt(mWorkspace.getCurrentPage()).requestFocus();
        }
        mSavedState = null;
    }
    mWorkspace.restoreInstanceStateForRemainingPages();
    setWorkspaceLoading(false);
    sendLoadingCompleteBroadcastIfNecessary();
    // widget configuration forced an orientation change), process them now.
    if (sPendingAddItem != null) {
        final long screenId = completeAdd(sPendingAddItem);
        // TODO: this moves the user to the page where the pending item was added. Ideally,
        // the screen would be guaranteed to exist after bind, and the page would be set through
        // the workspace restore process.
        mWorkspace.post(new Runnable() {

            @Override
            public void run() {
                mWorkspace.snapToScreenId(screenId);
            }
        });
        sPendingAddItem = null;
    }
    InstallShortcutReceiver.disableAndFlushInstallQueue(this);
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.finishBindingItems(false);
    }
    mWorkspace.stripEmptyScreens();
    sRemoteFolderManager.bindFinished();
}
#end_block

#method_before
public void bindAllApplications(final ArrayList<AppInfo> apps) {
    if (waitUntilResume(mBindAllApplicationsRunnable, true)) {
        mTmpAppsList = apps;
        return;
    }
    if (mAppsView != null) {
        mAppsView.setApps(apps);
    // mRemoteFolderManager.onSetApps();
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.bindAllApplications(apps);
    }
}
#method_after
public void bindAllApplications(final ArrayList<AppInfo> apps) {
    if (waitUntilResume(mBindAllApplicationsRunnable, true)) {
        mTmpAppsList = apps;
        return;
    }
    if (mAppsView != null) {
        mAppsView.setApps(apps);
    }
    if (mLauncherCallbacks != null) {
        mLauncherCallbacks.bindAllApplications(apps);
    }
}
#end_block

#method_before
private void setupSearchBar(Context context) {
    boolean isDrawerSearchBarEnabled = SettingsProvider.getBoolean(context, SettingsProvider.SETTINGS_UI_DRAWER_SEARCH, R.bool.preferences_interface_homescreen_search_default);
    if (mLauncherCallbacks != null && mLauncherCallbacks.getAllAppsSearchBarController() != null) {
        mAppsView.setSearchBarController(mLauncherCallbacks.getAllAppsSearchBarController());
    } else {
        mAppsView.setSearchBarController(mAppsView.newDefaultAppSearchController());
    }
    mAppsView.setHasSearchBar(isDrawerSearchBarEnabled);
    mAppsView.setSearchBarContainerViewVisibility(isDrawerSearchBarEnabled ? View.VISIBLE : View.GONE);
}
#method_after
private void setupSearchBar(Context context) {
    mIsDrawerSearchBarEnabled = SettingsProvider.getBoolean(context, SettingsProvider.SETTINGS_UI_DRAWER_SEARCH, R.bool.preferences_interface_homescreen_search_default);
    if (mIsDrawerSearchBarEnabled) {
        if (mLauncherCallbacks != null && mLauncherCallbacks.getAllAppsSearchBarController() != null) {
            mAppsView.setSearchBarController(mLauncherCallbacks.getAllAppsSearchBarController());
        } else {
            mAppsView.setSearchBarController(mAppsView.newDefaultAppSearchController());
        }
    } else {
        mAppsView.setSearchBarController(null);
        mAppsView.setHasSearchBar(mIsDrawerSearchBarEnabled);
        mAppsView.setSearchBarContainerViewVisibility(mIsDrawerSearchBarEnabled ? View.VISIBLE : View.GONE);
        mAppsView.updateBackgroundAndPaddings();
    }
}
#end_block

#method_before
public void setNumAppsPerRow(int numAppsPerRow, int numPredictedAppsPerRow, MergeAlgorithm mergeAlgorithm) {
    mNumAppsPerRow = numAppsPerRow;
    mNumPredictedAppsPerRow = numPredictedAppsPerRow;
    mMergeAlgorithm = mergeAlgorithm;
    updateAdapterItems();
}
#method_after
public void setNumAppsPerRow(int numAppsPerRow, int numPredictedAppsPerRow, boolean mergeSections) {
    mNumAppsPerRow = numAppsPerRow;
    mNumPredictedAppsPerRow = numPredictedAppsPerRow;
    mMergeSections = mergeSections;
    updateAdapterItems();
}
#end_block

#method_before
private void updateAdapterItems() {
    SectionInfo lastSectionInfo = null;
    String lastSectionName = null;
    FastScrollSectionInfo lastFastScrollerSectionInfo = null;
    int position = 0;
    int appIndex = 0;
    // Prepare to update the list of sections, filtered apps, etc.
    mFilteredApps.clear();
    mFastScrollerSections.clear();
    mAdapterItems.clear();
    mSections.clear();
    if (DEBUG_PREDICTIONS) {
        if (mPredictedAppComponents.isEmpty() && !mApps.isEmpty()) {
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
        }
    }
    // Process the predicted app components
    boolean hasPredictedApps;
    // We haven't measured yet. Skip this for now. We will set properly after measure.
    if (mNumPredictedAppsPerRow == 0) {
        hasPredictedApps = false;
    } else if (mCustomPredictedAppsEnabled) {
        hasPredictedApps = !mPredictedApps.isEmpty();
    } else {
        mPredictedApps.clear();
        hasPredictedApps = mPredictedAppComponents != null && !mPredictedAppComponents.isEmpty();
    }
    if (hasPredictedApps && !hasFilter()) {
        if (!mCustomPredictedAppsEnabled) {
            for (ComponentKey ck : mPredictedAppComponents) {
                AppInfo info = mComponentToAppMap.get(ck);
                if (info != null) {
                    mPredictedApps.add(info);
                } else {
                    if (LauncherAppState.isDogfoodBuild()) {
                        Log.e(TAG, "Predicted app not found: " + ck.flattenToString(mLauncher));
                    }
                }
                // Stop at the number of predicted apps
                if (mPredictedApps.size() == mNumPredictedAppsPerRow) {
                    break;
                }
            }
        } else {
            // Shrink to column count.
            if (mPredictedApps.size() > mNumPredictedAppsPerRow) {
                mPredictedApps.subList(mNumAppsPerRow, mPredictedApps.size()).clear();
            }
        }
        if (!mPredictedApps.isEmpty()) {
            // Add a section for the predictions
            lastSectionInfo = new SectionInfo();
            String text = mCustomPredictedAppsEnabled ? CUSTOM_PREDICTIONS_SCRUBBER : " ";
            lastFastScrollerSectionInfo = new FastScrollSectionInfo(text);
            AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            mAdapterItems.add(sectionItem);
            // Add the predicted app items
            for (AppInfo info : mPredictedApps) {
                text = mCustomPredictedAppsEnabled ? CUSTOM_PREDICTIONS_HEADER : " ";
                AdapterItem appItem = AdapterItem.asPredictedApp(position++, lastSectionInfo, text, lastSectionInfo.numApps++, info, appIndex++);
                if (lastSectionInfo.firstAppItem == null) {
                    lastSectionInfo.firstAppItem = appItem;
                    lastFastScrollerSectionInfo.fastScrollToItem = appItem;
                }
                mAdapterItems.add(appItem);
                mFilteredApps.add(info);
            }
        }
    }
    ProtectedComponentsHelper.updateProtectedComponentsLists(mLauncher);
    // ordered set of sections
    for (AppInfo info : getFiltersAppInfos()) {
        if (ProtectedComponentsHelper.isProtectedApp(info.flags, info.componentName)) {
            continue;
        }
        String sectionName = getAndUpdateCachedSectionName(info.title);
        // Create a new section if the section names do not match
        if (lastSectionInfo == null || !sectionName.equals(lastSectionName)) {
            lastSectionName = sectionName;
            lastSectionInfo = new SectionInfo();
            lastFastScrollerSectionInfo = new FastScrollSectionInfo(sectionName);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            // Create a new section item to break the flow of items in the list
            if (!hasFilter()) {
                AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
                mAdapterItems.add(sectionItem);
            }
        }
        // Create an app item
        AdapterItem appItem = AdapterItem.asApp(position++, lastSectionInfo, sectionName, lastSectionInfo.numApps++, info, appIndex++);
        if (lastSectionInfo.firstAppItem == null) {
            lastSectionInfo.firstAppItem = appItem;
            lastFastScrollerSectionInfo.fastScrollToItem = appItem;
        }
        mAdapterItems.add(appItem);
        mFilteredApps.add(info);
    }
    // Append the search market item if we are currently searching
    if (hasFilter()) {
        if (hasNoFilteredResults()) {
            mAdapterItems.add(AdapterItem.asEmptySearch(position++));
        } else {
            mAdapterItems.add(AdapterItem.asDivider(position++));
        }
        mAdapterItems.add(AdapterItem.asMarketSearch(position++));
    }
    // Merge multiple sections together as requested by the merge strategy for this device
    mergeSections();
    if (mNumAppsPerRow != 0) {
        // Update the number of rows in the adapter after we do all the merging (otherwise, we
        // would have to shift the values again)
        int numAppsInSection = 0;
        int numAppsInRow = 0;
        int rowIndex = -1;
        for (AdapterItem item : mAdapterItems) {
            item.rowIndex = 0;
            if (item.viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE) {
                numAppsInSection = 0;
            } else if (item.viewType == AllAppsGridAdapter.ICON_VIEW_TYPE || item.viewType == AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                if (numAppsInSection % mNumAppsPerRow == 0) {
                    numAppsInRow = 0;
                    rowIndex++;
                }
                item.rowIndex = rowIndex;
                item.rowAppIndex = numAppsInRow;
                numAppsInSection++;
                numAppsInRow++;
            }
        }
        mNumAppRowsInAdapter = rowIndex + 1;
        // Pre-calculate all the fast scroller fractions
        switch(mFastScrollDistributionMode) {
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_ROWS_FRACTION:
                float rowFraction = 1f / mNumAppRowsInAdapter;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    float subRowFraction = item.rowAppIndex * (rowFraction / mNumAppsPerRow);
                    info.touchFraction = item.rowIndex * rowFraction + subRowFraction;
                }
                break;
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_NUM_SECTIONS:
                float perSectionTouchFraction = 1f / mFastScrollerSections.size();
                float cumulativeTouchFraction = 0f;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    info.touchFraction = cumulativeTouchFraction;
                    cumulativeTouchFraction += perSectionTouchFraction;
                }
                break;
        }
    }
    // Refresh the recycler view
    if (mAdapter != null) {
        mAdapter.notifyDataSetChanged();
    }
}
#method_after
private void updateAdapterItems() {
    SectionInfo lastSectionInfo = null;
    String lastSectionName = null;
    FastScrollSectionInfo lastFastScrollerSectionInfo = null;
    int position = 0;
    int appIndex = 0;
    // Prepare to update the list of sections, filtered apps, etc.
    mFilteredApps.clear();
    mFastScrollerSections.clear();
    mAdapterItems.clear();
    mSections.clear();
    if (DEBUG_PREDICTIONS) {
        if (mPredictedAppComponents.isEmpty() && !mApps.isEmpty()) {
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
            mPredictedAppComponents.add(new ComponentKey(mApps.get(0).componentName, UserHandleCompat.myUserHandle()));
        }
    }
    // Process the predicted app components
    boolean hasPredictedApps;
    // We haven't measured yet. Skip this for now. We will set properly after measure.
    if (mNumPredictedAppsPerRow == 0) {
        hasPredictedApps = false;
    } else if (mCustomPredictedAppsEnabled) {
        hasPredictedApps = !mPredictedApps.isEmpty();
    } else {
        mPredictedApps.clear();
        hasPredictedApps = mPredictedAppComponents != null && !mPredictedAppComponents.isEmpty();
    }
    if (hasPredictedApps && !hasFilter()) {
        if (!mCustomPredictedAppsEnabled) {
            for (ComponentKey ck : mPredictedAppComponents) {
                AppInfo info = mComponentToAppMap.get(ck);
                if (info != null) {
                    mPredictedApps.add(info);
                } else {
                    if (LauncherAppState.isDogfoodBuild()) {
                        Log.e(TAG, "Predicted app not found: " + ck.flattenToString(mLauncher));
                    }
                }
                // Stop at the number of predicted apps
                if (mPredictedApps.size() == mNumPredictedAppsPerRow) {
                    break;
                }
            }
        } else {
            // Shrink to column count.
            if (mPredictedApps.size() > mNumPredictedAppsPerRow) {
                mPredictedApps.subList(mNumAppsPerRow, mPredictedApps.size()).clear();
            }
        }
        if (!mPredictedApps.isEmpty()) {
            // Add a section for the predictions
            lastSectionInfo = new SectionInfo();
            String text = mCustomPredictedAppsEnabled ? CUSTOM_PREDICTIONS_SCRUBBER : " ";
            lastFastScrollerSectionInfo = new FastScrollSectionInfo(text, lastSectionInfo);
            AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            mAdapterItems.add(sectionItem);
            // Add the predicted app items
            for (AppInfo info : mPredictedApps) {
                text = mCustomPredictedAppsEnabled ? CUSTOM_PREDICTIONS_HEADER : " ";
                AdapterItem appItem = AdapterItem.asPredictedApp(position++, lastSectionInfo, text, lastSectionInfo.numApps++, info, appIndex++);
                if (lastSectionInfo.firstAppItem == null) {
                    lastSectionInfo.firstAppItem = appItem;
                    lastFastScrollerSectionInfo.fastScrollToItem = appItem;
                }
                mAdapterItems.add(appItem);
                mFilteredApps.add(info);
            }
            if (mCustomPredictedAppsEnabled) {
                position = mLauncher.getRemoteFolderManager().onUpdateAdapterItems(mAdapterItems, lastFastScrollerSectionInfo, lastSectionInfo, position);
            }
        }
    }
    ProtectedComponentsHelper.updateProtectedComponentsLists(mLauncher);
    // ordered set of sections
    for (AppInfo info : getFiltersAppInfos()) {
        if (ProtectedComponentsHelper.isProtectedApp(info.flags, info.componentName)) {
            continue;
        }
        String sectionName = getAndUpdateCachedSectionName(info.title);
        // Create a new section if the section names do not match
        if (lastSectionInfo == null || !sectionName.equals(lastSectionName)) {
            lastSectionName = sectionName;
            lastSectionInfo = new SectionInfo();
            lastFastScrollerSectionInfo = new FastScrollSectionInfo(sectionName, lastSectionInfo);
            mSections.add(lastSectionInfo);
            mFastScrollerSections.add(lastFastScrollerSectionInfo);
            // Create a new section item to break the flow of items in the list
            if (!hasFilter()) {
                AdapterItem sectionItem = AdapterItem.asSectionBreak(position++, lastSectionInfo);
                mAdapterItems.add(sectionItem);
            }
        }
        // Create an app item
        AdapterItem appItem = AdapterItem.asApp(position++, lastSectionInfo, sectionName, lastSectionInfo.numApps++, info, appIndex++);
        if (lastSectionInfo.firstAppItem == null) {
            lastSectionInfo.firstAppItem = appItem;
            lastFastScrollerSectionInfo.fastScrollToItem = appItem;
        }
        mAdapterItems.add(appItem);
        mFilteredApps.add(info);
    }
    // Append the search market item if we are currently searching
    if (hasFilter()) {
        if (hasNoFilteredResults()) {
            mAdapterItems.add(AdapterItem.asEmptySearch(position++));
        } else {
            mAdapterItems.add(AdapterItem.asDivider(position++));
        }
        mAdapterItems.add(AdapterItem.asMarketSearch(position++));
    }
    // Merge multiple sections together as needed.
    mergeSections();
    if (mNumAppsPerRow != 0) {
        // Update the number of rows in the adapter after we do all the merging (otherwise, we
        // would have to shift the values again)
        int numAppsInSection = 0;
        int numAppsInRow = 0;
        int rowIndex = -1;
        for (AdapterItem item : mAdapterItems) {
            item.rowIndex = 0;
            if (item.viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE) {
                numAppsInSection = 0;
            } else if (item.viewType == AllAppsGridAdapter.ICON_VIEW_TYPE || item.viewType == AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
                if (numAppsInSection % mNumAppsPerRow == 0) {
                    numAppsInRow = 0;
                    rowIndex++;
                }
                item.rowIndex = rowIndex;
                item.rowAppIndex = numAppsInRow;
                numAppsInSection++;
                numAppsInRow++;
            }
        }
        mNumAppRowsInAdapter = rowIndex + 1;
        // Pre-calculate all the fast scroller fractions
        switch(mFastScrollDistributionMode) {
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_ROWS_FRACTION:
                float rowFraction = 1f / mNumAppRowsInAdapter;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.CUSTOM_PREDICTED_APPS_HEADER_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    float subRowFraction = item.rowAppIndex * (rowFraction / mNumAppsPerRow);
                    info.touchFraction = item.rowIndex * rowFraction + subRowFraction;
                }
                break;
            case FAST_SCROLL_FRACTION_DISTRIBUTE_BY_NUM_SECTIONS:
                float perSectionTouchFraction = 1f / mFastScrollerSections.size();
                float cumulativeTouchFraction = 0f;
                for (FastScrollSectionInfo info : mFastScrollerSections) {
                    AdapterItem item = info.fastScrollToItem;
                    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.CUSTOM_PREDICTED_APPS_HEADER_VIEW_TYPE) {
                        info.touchFraction = 0f;
                        continue;
                    }
                    info.touchFraction = cumulativeTouchFraction;
                    cumulativeTouchFraction += perSectionTouchFraction;
                }
                break;
        }
    }
    // Refresh the recycler view
    if (mAdapter != null) {
        mAdapter.notifyDataSetChanged();
    }
}
#end_block

#method_before
private void mergeSections() {
    // Ignore merging until we have an algorithm and a valid row size
    if (mMergeAlgorithm == null || mNumAppsPerRow == 0) {
        return;
    }
    // Go through each section and try and merge some of the sections
    if (!hasFilter()) {
        int sectionAppCount = 0;
        for (int i = 0; i < mSections.size() - 1; i++) {
            SectionInfo section = mSections.get(i);
            sectionAppCount = section.numApps;
            int mergeCount = 1;
            // Merge rows based on the current strategy
            while (i < (mSections.size() - 1) && mMergeAlgorithm.continueMerging(section, mSections.get(i + 1), sectionAppCount, mNumAppsPerRow, mergeCount)) {
                SectionInfo nextSection = mSections.remove(i + 1);
                // Remove the next section break
                mAdapterItems.remove(nextSection.sectionBreakItem);
                int pos = mAdapterItems.indexOf(section.firstAppItem);
                // Point the section for these new apps to the merged section
                int nextPos = pos + section.numApps;
                for (int j = nextPos; j < (nextPos + nextSection.numApps); j++) {
                    AdapterItem item = mAdapterItems.get(j);
                    item.sectionInfo = section;
                    item.sectionAppIndex += section.numApps;
                }
                // Update the following adapter items of the removed section item
                pos = mAdapterItems.indexOf(nextSection.firstAppItem);
                for (int j = pos; j < mAdapterItems.size(); j++) {
                    AdapterItem item = mAdapterItems.get(j);
                    item.position--;
                }
                section.numApps += nextSection.numApps;
                sectionAppCount += nextSection.numApps;
                if (DEBUG) {
                    Log.d(TAG, "Merging: " + nextSection.firstAppItem.sectionName + " to " + section.firstAppItem.sectionName + " mergedNumRows: " + (sectionAppCount / mNumAppsPerRow));
                }
                mergeCount++;
            }
        }
    }
}
#method_after
private void mergeSections() {
    // Ignore merging until we have an algorithm and a valid row size
    if (!mMergeSections || mNumAppsPerRow == 0 || hasFilter()) {
        return;
    }
    Iterator<AdapterItem> iter = mAdapterItems.iterator();
    int positionShift = 0;
    while (iter.hasNext()) {
        AdapterItem item = iter.next();
        item.position -= positionShift;
        if (item.viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE) {
            iter.remove();
            positionShift++;
        }
    }
}
#end_block

#method_before
@Override
public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
    // XXX-RTL: This will be fixed in a future CL
    if (mCurrentPage >= 0 && mCurrentPage < getPageCount()) {
        getPageAt(mCurrentPage).addFocusables(views, direction, focusableMode);
    }
    if (direction == View.FOCUS_LEFT) {
        if (mCurrentPage > 0) {
            getPageAt(mCurrentPage - 1).addFocusables(views, direction, focusableMode);
        }
    } else if (direction == View.FOCUS_RIGHT) {
        if (mCurrentPage < getPageCount() - 1) {
            getPageAt(mCurrentPage + 1).addFocusables(views, direction, focusableMode);
        }
    }
}
#method_after
@Override
public void addFocusables(ArrayList<View> views, int direction, int focusableMode) {
    // XXX-RTL: This will be fixed in a future CL
    if (mCurrentPage >= 0 && mCurrentPage < getPageCount()) {
        View page = getPageAt(mCurrentPage);
        if (page != null) {
            page.addFocusables(views, direction, focusableMode);
        }
    }
    if (direction == View.FOCUS_LEFT) {
        if (mCurrentPage > 0) {
            View page = getPageAt(mCurrentPage - 1);
            if (page != null) {
                page.addFocusables(views, direction, focusableMode);
            }
        }
    } else if (direction == View.FOCUS_RIGHT) {
        if (mCurrentPage < getPageCount() - 1) {
            View page = getPageAt(mCurrentPage + 1);
            if (page != null) {
                page.addFocusables(views, direction, focusableMode);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
    if (mApps.hasFilter() || mAppsPerRow == 0) {
        return;
    }
    if (DEBUG_SECTION_MARGIN) {
        Paint p = new Paint();
        p.setColor(0x33ff0000);
        c.drawRect(mBackgroundPadding.left, 0, mBackgroundPadding.left + mSectionNamesMargin, parent.getMeasuredHeight(), p);
    }
    List<AlphabeticalAppsList.AdapterItem> items = mApps.getAdapterItems();
    boolean hasDrawnPredictedAppsDivider = false;
    boolean showSectionNames = mSectionNamesMargin > 0;
    int childCount = parent.getChildCount();
    int lastSectionTop = 0;
    int lastSectionHeight = 0;
    for (int i = 0; i < childCount; i++) {
        View child = parent.getChildAt(i);
        ViewHolder holder = (ViewHolder) parent.getChildViewHolder(child);
        if (!isValidHolderAndChild(holder, child, items)) {
            continue;
        }
        if (shouldDrawItemDivider(holder, items) && !hasDrawnPredictedAppsDivider) {
            // Draw the divider under the predicted apps
            int top = child.getTop() + child.getHeight() + mPredictionBarDividerOffset;
            c.drawLine(mBackgroundPadding.left, top, parent.getWidth() - mBackgroundPadding.right, top, mPredictedAppsDividerPaint);
            hasDrawnPredictedAppsDivider = true;
            if (!mApps.mCustomPredictedAppsEnabled)
                continue;
        }
        if (showSectionNames && shouldDrawItemSection(holder, i, items)) {
            // At this point, we only draw sections for each section break;
            int viewTopOffset = (2 * child.getPaddingTop());
            int pos = holder.getPosition();
            AlphabeticalAppsList.AdapterItem item = items.get(pos);
            AlphabeticalAppsList.SectionInfo sectionInfo = item.sectionInfo;
            // Draw all the sections for this index
            String lastSectionName = item.sectionName;
            for (int j = item.sectionAppIndex; j < sectionInfo.numApps; j++, pos++) {
                AlphabeticalAppsList.AdapterItem nextItem = items.get(pos);
                String sectionName = nextItem.sectionName;
                if (nextItem.sectionInfo != sectionInfo) {
                    break;
                }
                if (j > item.sectionAppIndex && sectionName.equals(lastSectionName)) {
                    continue;
                }
                // Find the section name bounds
                PointF sectionBounds = getAndCacheSectionBounds(sectionName);
                // Calculate where to draw the section
                int sectionBaseline = (int) (viewTopOffset + sectionBounds.y);
                int x = mIsRtl ? parent.getWidth() - mBackgroundPadding.left - mSectionNamesMargin : mBackgroundPadding.left;
                x += (int) ((mSectionNamesMargin - sectionBounds.x) / 2f);
                int y = child.getTop() + sectionBaseline;
                // Determine whether this is the last row with apps in that section, if
                // so, then fix the section to the row allowing it to scroll past the
                // baseline, otherwise, bound it to the baseline so it's in the viewport
                int appIndexInSection = items.get(pos).sectionAppIndex;
                int nextRowPos = Math.min(items.size() - 1, pos + mAppsPerRow - (appIndexInSection % mAppsPerRow));
                AlphabeticalAppsList.AdapterItem nextRowItem = items.get(nextRowPos);
                boolean fixedToRow = !sectionName.equals(nextRowItem.sectionName);
                if (!fixedToRow) {
                    y = Math.max(sectionBaseline, y);
                }
                // offset it so that it does not overlap
                if (lastSectionHeight > 0 && y <= (lastSectionTop + lastSectionHeight)) {
                    y += lastSectionTop - y + lastSectionHeight;
                }
                // Draw the section header
                if (FADE_OUT_SECTIONS) {
                    int alpha = 255;
                    if (fixedToRow) {
                        alpha = Math.min(255, (int) (255 * (Math.max(0, y) / (float) sectionBaseline)));
                    }
                    mSectionTextPaint.setAlpha(alpha);
                }
                c.drawText(sectionName, x, y, mSectionTextPaint);
                lastSectionTop = y;
                lastSectionHeight = (int) (sectionBounds.y + mSectionHeaderOffset);
                lastSectionName = sectionName;
            }
            i += (sectionInfo.numApps - item.sectionAppIndex);
        }
    }
}
#method_after
@Override
public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
    if (mApps.hasFilter() || mAppsPerRow == 0) {
        return;
    }
    if (DEBUG_SECTION_MARGIN) {
        Paint p = new Paint();
        p.setColor(0x33ff0000);
        c.drawRect(mBackgroundPadding.left, 0, mBackgroundPadding.left + mSectionNamesMargin, parent.getMeasuredHeight(), p);
    }
    List<AlphabeticalAppsList.AdapterItem> items = mApps.getAdapterItems();
    boolean hasDrawnPredictedAppsDivider = false;
    boolean showSectionNames = mSectionNamesMargin > 0;
    int childCount = parent.getChildCount();
    int lastSectionTop = 0;
    int lastSectionHeight = 0;
    for (int i = 0; i < childCount; i++) {
        View child = parent.getChildAt(i);
        ViewHolder holder = (ViewHolder) parent.getChildViewHolder(child);
        if (!isValidHolderAndChild(holder, child, items)) {
            continue;
        }
        if (shouldDrawItemDivider(holder, items) && !hasDrawnPredictedAppsDivider) {
            // Draw the divider under the predicted apps
            int top = child.getTop() + child.getHeight() + mPredictionBarDividerOffset;
            c.drawLine(mBackgroundPadding.left, top, parent.getWidth() - mBackgroundPadding.right, top, mPredictedAppsDividerPaint);
            hasDrawnPredictedAppsDivider = true;
            // Only customized predicted apps will draw a section name.
            if (!mApps.mCustomPredictedAppsEnabled)
                continue;
        }
        if (showSectionNames && shouldDrawItemSection(holder, items)) {
            // Draw the section name for the first visible item
            int viewTopOffset = (2 * child.getPaddingTop());
            int pos = holder.getPosition();
            AlphabeticalAppsList.AdapterItem item = items.get(pos);
            AlphabeticalAppsList.SectionInfo sectionInfo = item.sectionInfo;
            String lastSectionName = item.sectionName;
            // Find the section name bounds
            PointF sectionBounds = getAndCacheSectionBounds(lastSectionName);
            // Calculate where to draw the section
            int sectionBaseline = (int) (viewTopOffset + sectionBounds.y);
            int x = mIsRtl ? parent.getWidth() - mBackgroundPadding.left - mSectionNamesMargin : mBackgroundPadding.left;
            x += (int) ((mSectionNamesMargin - sectionBounds.x) / 2f);
            int y;
            boolean fixedToRow = false;
            if (item.viewType == PREDICTION_ICON_VIEW_TYPE) {
                y = child.getTop() - (int) mSectionTextPaint.getTextSize() / 2;
            } else {
                y = child.getTop() + sectionBaseline;
                // Determine whether this is the last row with apps in that section, if
                // so, then fix the section to the row allowing it to scroll past the
                // baseline, otherwise, bound it to the baseline so it's in the viewport
                int appIndexInSection = items.get(pos).sectionAppIndex;
                int nextRowPos = Math.min(items.size() - 1, pos + mAppsPerRow - (appIndexInSection % mAppsPerRow));
                AlphabeticalAppsList.AdapterItem nextRowItem = items.get(nextRowPos);
                fixedToRow = !lastSectionName.equals(nextRowItem.sectionName);
                if (!fixedToRow) {
                    y = Math.max(sectionBaseline, y);
                }
                // offset it so that it does not overlap
                if (lastSectionHeight > 0 && y <= (lastSectionTop + lastSectionHeight)) {
                    y += lastSectionTop - y + lastSectionHeight;
                }
            }
            // Draw the section header
            if (FADE_OUT_SECTIONS) {
                int alpha = 255;
                if (fixedToRow) {
                    alpha = Math.min(255, (int) (255 * (Math.max(0, y) / (float) sectionBaseline)));
                }
                mSectionTextPaint.setAlpha(alpha);
            }
            c.drawText(lastSectionName, x, y, mSectionTextPaint);
            lastSectionTop = y;
            lastSectionHeight = (int) (sectionBounds.y + mSectionHeaderOffset);
            i += (sectionInfo.numApps - item.sectionAppIndex);
        }
    }
}
#end_block

#method_before
private boolean shouldDrawItemSection(ViewHolder holder, int childIndex, List<AlphabeticalAppsList.AdapterItem> items) {
    int pos = holder.getPosition();
    AlphabeticalAppsList.AdapterItem item = items.get(pos);
    // Ensure it's an icon
    if (item.viewType != AllAppsGridAdapter.ICON_VIEW_TYPE && item.viewType != AllAppsGridAdapter.PREDICTION_ICON_VIEW_TYPE) {
        return false;
    }
    // Draw the section header for the first item in each section
    return (childIndex == 0) || (items.get(pos - 1).viewType == AllAppsGridAdapter.SECTION_BREAK_VIEW_TYPE);
}
#method_after
private boolean shouldDrawItemSection(ViewHolder holder, List<AlphabeticalAppsList.AdapterItem> items) {
    int pos = holder.getPosition();
    AlphabeticalAppsList.AdapterItem item = items.get(pos);
    // Ensure it's an icon
    if (item.viewType != ICON_VIEW_TYPE && item.viewType != PREDICTION_ICON_VIEW_TYPE) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    boolean hideIconLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
    switch(viewType) {
        case SECTION_BREAK_VIEW_TYPE:
            return new ViewHolder(new View(parent.getContext()));
        case ICON_VIEW_TYPE:
            {
                BubbleTextView icon = (BubbleTextView) mLayoutInflater.inflate(R.layout.all_apps_icon, parent, false);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.setOnTouchListener(mTouchListener);
                icon.setOnClickListener(mIconClickListener);
                icon.setOnLongClickListener(mIconLongClickListener);
                icon.setLongPressTimeout(ViewConfiguration.get(parent.getContext()).getLongPressTimeout());
                icon.setFocusable(true);
                return new ViewHolder(icon);
            }
        case PREDICTION_ICON_VIEW_TYPE:
            {
                BubbleTextView icon = (BubbleTextView) mLayoutInflater.inflate(R.layout.all_apps_prediction_bar_icon, parent, false);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.setOnTouchListener(mTouchListener);
                icon.setOnClickListener(mIconClickListener);
                icon.setOnLongClickListener(mIconLongClickListener);
                icon.setLongPressTimeout(ViewConfiguration.get(parent.getContext()).getLongPressTimeout());
                icon.setFocusable(true);
                ViewHolder holder = new ViewHolder(icon);
                mRemoteFolderManager.onCreateViewHolder(holder);
                return holder;
            }
        case EMPTY_SEARCH_VIEW_TYPE:
            return new ViewHolder(mLayoutInflater.inflate(R.layout.all_apps_empty_search, parent, false));
        case SEARCH_MARKET_DIVIDER_VIEW_TYPE:
            return new ViewHolder(mLayoutInflater.inflate(R.layout.all_apps_search_market_divider, parent, false));
        case SEARCH_MARKET_VIEW_TYPE:
            View searchMarketView = mLayoutInflater.inflate(R.layout.all_apps_search_market, parent, false);
            searchMarketView.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    mLauncher.startSearchFromAllApps(v, mMarketSearchIntent, mLastSearchQuery);
                }
            });
            return new ViewHolder(searchMarketView);
        default:
            throw new RuntimeException("Unexpected view type");
    }
}
#method_after
@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    boolean hideIconLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
    switch(viewType) {
        case SECTION_BREAK_VIEW_TYPE:
            return new ViewHolder(new View(parent.getContext()));
        case ICON_VIEW_TYPE:
            {
                BubbleTextView icon = (BubbleTextView) mLayoutInflater.inflate(R.layout.all_apps_icon, parent, false);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.setOnTouchListener(mTouchListener);
                icon.setOnClickListener(mIconClickListener);
                icon.setOnLongClickListener(mIconLongClickListener);
                icon.setLongPressTimeout(ViewConfiguration.get(parent.getContext()).getLongPressTimeout());
                icon.setFocusable(true);
                FastScrollFocusApplicator.createApplicator(icon, FastScrollFocusable.FAST_SCROLL_FOCUS_DIMMABLE | FastScrollFocusable.FAST_SCROLL_FOCUS_SCALABLE);
                return new ViewHolder(icon);
            }
        case PREDICTION_ICON_VIEW_TYPE:
            {
                BubbleTextView icon = (BubbleTextView) mLayoutInflater.inflate(R.layout.all_apps_prediction_bar_icon, parent, false);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.setOnTouchListener(mTouchListener);
                icon.setOnClickListener(mIconClickListener);
                icon.setOnLongClickListener(mIconLongClickListener);
                icon.setLongPressTimeout(ViewConfiguration.get(parent.getContext()).getLongPressTimeout());
                icon.setFocusable(true);
                FastScrollFocusApplicator.createApplicator(icon, FastScrollFocusable.FAST_SCROLL_FOCUS_DIMMABLE | FastScrollFocusable.FAST_SCROLL_FOCUS_SCALABLE);
                ViewHolder holder = new ViewHolder(icon);
                mRemoteFolderManager.onCreateViewHolder(holder, viewType);
                return holder;
            }
        case EMPTY_SEARCH_VIEW_TYPE:
            return new ViewHolder(mLayoutInflater.inflate(R.layout.all_apps_empty_search, parent, false));
        case SEARCH_MARKET_DIVIDER_VIEW_TYPE:
            return new ViewHolder(mLayoutInflater.inflate(R.layout.all_apps_search_market_divider, parent, false));
        case SEARCH_MARKET_VIEW_TYPE:
            View searchMarketView = mLayoutInflater.inflate(R.layout.all_apps_search_market, parent, false);
            searchMarketView.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    mLauncher.startSearchFromAllApps(v, mMarketSearchIntent, mLastSearchQuery);
                }
            });
            return new ViewHolder(searchMarketView);
        case CUSTOM_PREDICTED_APPS_HEADER_VIEW_TYPE:
            {
                View v = mLayoutInflater.inflate(R.layout.custom_predicted_apps_header, parent, false);
                FastScrollFocusApplicator.createApplicator(v, FastScrollFocusable.FAST_SCROLL_FOCUS_DIMMABLE);
                ViewHolder holder = new ViewHolder(v);
                mRemoteFolderManager.onCreateViewHolder(holder, viewType);
                return holder;
            }
        case CUSTOM_PREDICTED_APPS_FOOTER_VIEW_TYPE:
            {
                View v = mLayoutInflater.inflate(R.layout.custom_predicted_apps_footer, parent, false);
                ViewHolder holder = new ViewHolder(v);
                mRemoteFolderManager.onCreateViewHolder(holder, viewType);
                return holder;
            }
        default:
            throw new RuntimeException("Unexpected view type");
    }
}
#end_block

#method_before
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    boolean hideIconLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
    switch(holder.getItemViewType()) {
        case ICON_VIEW_TYPE:
            {
                AppInfo info = mApps.getAdapterItems().get(position).appInfo;
                BubbleTextView icon = (BubbleTextView) holder.mContent;
                icon.setTextColor(mAllAppsTextColor);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.applyFromApplicationInfo(info);
                icon.setFastScrollDimmed(mIconsDimmed, !mIconsDimmed);
                break;
            }
        case PREDICTION_ICON_VIEW_TYPE:
            {
                AppInfo info = mApps.getAdapterItems().get(position).appInfo;
                BubbleTextView icon = (BubbleTextView) holder.mContent;
                icon.setTextColor(mAllAppsTextColor);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.applyFromApplicationInfo(info);
                icon.setFastScrollDimmed(mIconsDimmed, !mIconsDimmed);
                mRemoteFolderManager.onBindViewHolder(holder, info);
                break;
            }
        case EMPTY_SEARCH_VIEW_TYPE:
            TextView emptyViewText = (TextView) holder.mContent;
            emptyViewText.setText(mEmptySearchMessage);
            emptyViewText.setGravity(mApps.hasNoFilteredResults() ? Gravity.CENTER : Gravity.START | Gravity.CENTER_VERTICAL);
            break;
        case SEARCH_MARKET_VIEW_TYPE:
            TextView searchView = (TextView) holder.mContent;
            if (mMarketSearchIntent != null) {
                searchView.setVisibility(View.VISIBLE);
                searchView.setContentDescription(mMarketSearchMessage);
                searchView.setGravity(mApps.hasNoFilteredResults() ? Gravity.CENTER : Gravity.START | Gravity.CENTER_VERTICAL);
                searchView.setText(mMarketSearchMessage);
            } else {
                searchView.setVisibility(View.GONE);
            }
            break;
    }
}
#method_after
@Override
public void onBindViewHolder(ViewHolder holder, int position) {
    boolean hideIconLabels = SettingsProvider.getBoolean(mLauncher, SettingsProvider.SETTINGS_UI_DRAWER_HIDE_ICON_LABELS, R.bool.preferences_interface_drawer_hide_icon_labels_default);
    switch(holder.getItemViewType()) {
        case ICON_VIEW_TYPE:
            {
                AppInfo info = mApps.getAdapterItems().get(position).appInfo;
                BubbleTextView icon = (BubbleTextView) holder.mContent;
                icon.setTextColor(mAllAppsTextColor);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.applyFromApplicationInfo(info);
                FastScrollFocusApplicator.setFastScrollDimmed(icon, mIconsDimmed, !mIconsDimmed);
                FastScrollFocusApplicator.setFastScrollFocused(icon, false, !mIconsDimmed);
                break;
            }
        case PREDICTION_ICON_VIEW_TYPE:
            {
                AppInfo info = mApps.getAdapterItems().get(position).appInfo;
                BubbleTextView icon = (BubbleTextView) holder.mContent;
                icon.setTextColor(mAllAppsTextColor);
                if (hideIconLabels) {
                    icon.setTextVisibility(!hideIconLabels);
                }
                icon.applyFromApplicationInfo(info);
                FastScrollFocusApplicator.setFastScrollDimmed(icon, mIconsDimmed, !mIconsDimmed);
                FastScrollFocusApplicator.setFastScrollFocused(icon, false, !mIconsDimmed);
                mRemoteFolderManager.onBindViewHolder(holder, info);
                break;
            }
        case EMPTY_SEARCH_VIEW_TYPE:
            TextView emptyViewText = (TextView) holder.mContent;
            emptyViewText.setText(mEmptySearchMessage);
            emptyViewText.setGravity(mApps.hasNoFilteredResults() ? Gravity.CENTER : Gravity.START | Gravity.CENTER_VERTICAL);
            break;
        case SEARCH_MARKET_VIEW_TYPE:
            TextView searchView = (TextView) holder.mContent;
            if (mMarketSearchIntent != null) {
                searchView.setVisibility(View.VISIBLE);
                searchView.setContentDescription(mMarketSearchMessage);
                searchView.setGravity(mApps.hasNoFilteredResults() ? Gravity.CENTER : Gravity.START | Gravity.CENTER_VERTICAL);
                searchView.setText(mMarketSearchMessage);
            } else {
                searchView.setVisibility(View.GONE);
            }
            break;
        case CUSTOM_PREDICTED_APPS_HEADER_VIEW_TYPE:
            {
                TextView title = (TextView) holder.mContent.findViewById(R.id.title);
                title.setTextColor(mAllAppsTextColor);
                FastScrollFocusApplicator.setFastScrollDimmed(holder.mContent, mIconsDimmed, !mIconsDimmed);
                FastScrollFocusApplicator.setFastScrollFocused(holder.mContent, false, !mIconsDimmed);
                ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) holder.mContent.getLayoutParams();
                mCustomPredictedAppsHeaderHeight = holder.mContent.getHeight() + lp.topMargin + lp.bottomMargin;
                break;
            }
        case CUSTOM_PREDICTED_APPS_FOOTER_VIEW_TYPE:
            ViewGroup.MarginLayoutParams lp = (ViewGroup.MarginLayoutParams) holder.mContent.getLayoutParams();
            mCustomPredictedAppsFooterHeight = holder.mContent.getHeight() + lp.topMargin + lp.bottomMargin;
    }
}
#end_block

#method_before
public void setGridTheme(int gridTheme) {
    mGridTheme = gridTheme;
    int sectionTextColorId = mGridTheme == AllAppsContainerView.GRID_THEME_DARK ? R.color.all_apps_grid_section_text_color_dark : R.color.all_apps_grid_section_text_color;
    mSectionTextPaint.setColor(mLauncher.getResources().getColor(sectionTextColorId));
    Resources res = mLauncher.getResources();
    mAllAppsTextColor = mGridTheme == AllAppsContainerView.GRID_THEME_DARK ? res.getColor(R.color.quantum_panel_text_color_dark) : res.getColor(R.color.quantum_panel_text_color);
}
#method_after
public void setGridTheme(int gridTheme) {
    mGridTheme = gridTheme;
    int sectionTextColorId = mGridTheme == AllAppsContainerView.GRID_THEME_DARK ? R.color.all_apps_grid_section_text_color_dark : R.color.all_apps_grid_section_text_color;
    mSectionTextPaint.setColor(mLauncher.getColor(sectionTextColorId));
    mAllAppsTextColor = mGridTheme == AllAppsContainerView.GRID_THEME_DARK ? mLauncher.getColor(R.color.quantum_panel_text_color_dark) : mLauncher.getColor(R.color.quantum_panel_text_color);
    int mPredictedAppsDividerColorId = mGridTheme == AllAppsContainerView.GRID_THEME_DARK ? R.color.drawer_divider_dark : R.color.drawer_divider_light;
    mPredictedAppsDividerPaint.setColor(mLauncher.getColor(mPredictedAppsDividerColorId));
}
#end_block

#method_before
public void verifyHighRes() {
    if (mIconLoadRequest != null) {
        mIconLoadRequest.cancel();
        mIconLoadRequest = null;
    }
    if (getTag() instanceof AppInfo) {
        AppInfo info = (AppInfo) getTag();
        if (info.usingLowResIcon) {
            mIconLoadRequest = LauncherAppState.getInstance().getIconCache().updateIconInBackground(BubbleTextView.this, info);
        }
    } else if (getTag() instanceof ShortcutInfo) {
        ShortcutInfo info = (ShortcutInfo) getTag();
        if (info.usingLowResIcon) {
            mIconLoadRequest = LauncherAppState.getInstance().getIconCache().updateIconInBackground(BubbleTextView.this, info);
        }
    } else if (getTag() instanceof PackageItemInfo) {
        PackageItemInfo info = (PackageItemInfo) getTag();
        if (info.usingLowResIcon) {
            mIconLoadRequest = LauncherAppState.getInstance().getIconCache().updateIconInBackground(BubbleTextView.this, info);
        }
    }
}
#method_after
public void verifyHighRes() {
    // Custom drawables cannot be verified.
    if (getTag() instanceof ItemInfo && ((ItemInfo) getTag()).customDrawable != null) {
        return;
    }
    if (mIconLoadRequest != null) {
        mIconLoadRequest.cancel();
        mIconLoadRequest = null;
    }
    if (getTag() instanceof AppInfo) {
        AppInfo info = (AppInfo) getTag();
        if (info.usingLowResIcon) {
            mIconLoadRequest = LauncherAppState.getInstance().getIconCache().updateIconInBackground(BubbleTextView.this, info);
        }
    } else if (getTag() instanceof ShortcutInfo) {
        ShortcutInfo info = (ShortcutInfo) getTag();
        if (info.usingLowResIcon) {
            mIconLoadRequest = LauncherAppState.getInstance().getIconCache().updateIconInBackground(BubbleTextView.this, info);
        }
    } else if (getTag() instanceof PackageItemInfo) {
        PackageItemInfo info = (PackageItemInfo) getTag();
        if (info.usingLowResIcon) {
            mIconLoadRequest = LauncherAppState.getInstance().getIconCache().updateIconInBackground(BubbleTextView.this, info);
        }
    }
}
#end_block

#method_before
@Override
public void setFastScrollFocused(final boolean focused, boolean animated) {
    if (mFastScrollMode == FAST_SCROLL_FOCUS_MODE_NONE) {
        return;
    }
    if (mFastScrollFocused != focused) {
        mFastScrollFocused = focused;
        if (animated) {
            // Clean up the previous focus animator
            if (mFastScrollFocusAnimator != null) {
                mFastScrollFocusAnimator.cancel();
            }
            mFastScrollFocusAnimator = ObjectAnimator.ofFloat(this, "fastScrollFocus", focused ? 1f : 0f);
            if (focused) {
                mFastScrollFocusAnimator.setInterpolator(new DecelerateInterpolator());
            } else {
                mFastScrollFocusAnimator.setInterpolator(new AccelerateInterpolator());
            }
            mFastScrollFocusAnimator.setDuration(focused ? FAST_SCROLL_FOCUS_FADE_IN_DURATION : FAST_SCROLL_FOCUS_FADE_OUT_DURATION);
            mFastScrollFocusAnimator.start();
        } else {
            mFastScrollFocusFraction = focused ? 1f : 0f;
        }
    }
}
#method_after
@Override
public void setFastScrollFocused(final boolean focused, boolean animated) {
    if (mFastScrollMode == FAST_SCROLL_FOCUS_MODE_NONE) {
        return;
    }
    if (!animated) {
        mFastScrollFocusFraction = focused ? 1f : 0f;
    }
}
#end_block

#method_before
@Override
public void setFastScrollDimmed(boolean dimmed, boolean animated) {
    if (mFastScrollMode == FAST_SCROLL_FOCUS_MODE_NONE) {
        return;
    }
    if (!animated) {
        mFastScrollDimmed = dimmed;
        setAlpha(dimmed ? 0.4f : 1f);
    } else if (mFastScrollDimmed != dimmed) {
        mFastScrollDimmed = dimmed;
        // Clean up the previous dim animator
        if (mFastScrollDimAnimator != null) {
            mFastScrollDimAnimator.cancel();
        }
        mFastScrollDimAnimator = ObjectAnimator.ofFloat(this, View.ALPHA, dimmed ? 0.4f : 1f);
        mFastScrollDimAnimator.setDuration(dimmed ? FAST_SCROLL_FOCUS_FADE_IN_DURATION : FAST_SCROLL_FOCUS_FADE_OUT_DURATION);
        mFastScrollDimAnimator.start();
    }
}
#method_after
@Override
public void setFastScrollDimmed(boolean dimmed, boolean animated) {
// No special functionality here.
}
#end_block

#method_before
static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
    ItemInfo modelItem = sBgItemsIdMap.get(itemId);
    if (modelItem != null && item != modelItem) {
        // check all the data is consistent
        if (modelItem instanceof ShortcutInfo && item instanceof ShortcutInfo) {
            ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
            ShortcutInfo shortcut = (ShortcutInfo) item;
            if (modelShortcut.title.toString().equals(shortcut.title.toString()) && modelShortcut.intent.filterEquals(shortcut.intent) && modelShortcut.id == shortcut.id && modelShortcut.itemType == shortcut.itemType && modelShortcut.container == shortcut.container && modelShortcut.screenId == shortcut.screenId && modelShortcut.cellX == shortcut.cellX && modelShortcut.cellY == shortcut.cellY && modelShortcut.spanX == shortcut.spanX && modelShortcut.spanY == shortcut.spanY && ((modelShortcut.dropPos == null && shortcut.dropPos == null) || (modelShortcut.dropPos != null && shortcut.dropPos != null && modelShortcut.dropPos[0] == shortcut.dropPos[0] && modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
                // For all intents and purposes, this is the same object
                return;
            }
        }
        // the modelItem needs to match up perfectly with item if our model is
        // to be consistent with the database-- for now, just require
        // modelItem == item or the equality check above
        String msg = "item: " + ((item != null) ? item.toString() : "null") + "modelItem: " + ((modelItem != null) ? modelItem.toString() : "null") + "Error: ItemInfo passed to checkItemInfo doesn't match original";
        RuntimeException e = new RuntimeException(msg);
        if (stackTrace != null) {
            e.setStackTrace(stackTrace);
        }
        throw e;
    }
}
#method_after
static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
    ItemInfo modelItem = sBgItemsIdMap.get(itemId);
    if (modelItem != null && item != modelItem) {
        // check all the data is consistent
        if (modelItem instanceof ShortcutInfo && item instanceof ShortcutInfo) {
            ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
            ShortcutInfo shortcut = (ShortcutInfo) item;
            if (modelShortcut.title.toString().equals(shortcut.title.toString()) && modelShortcut.intent.filterEquals(shortcut.intent) && modelShortcut.id == shortcut.id && modelShortcut.itemType == shortcut.itemType && modelShortcut.container == shortcut.container && modelShortcut.screenId == shortcut.screenId && modelShortcut.cellX == shortcut.cellX && modelShortcut.cellY == shortcut.cellY && modelShortcut.spanX == shortcut.spanX && modelShortcut.spanY == shortcut.spanY && ((modelShortcut.dropPos == null && shortcut.dropPos == null) || (modelShortcut.dropPos != null && shortcut.dropPos != null && modelShortcut.dropPos[0] == shortcut.dropPos[0] && modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
                // For all intents and purposes, this is the same object
                return;
            }
            // the modelItem needs to match up perfectly with item if our model is
            // to be consistent with the database-- for now, just require
            // modelItem == item or the equality check above
            String msg = "item: " + ((item != null) ? item.toString() : "null") + "modelItem: " + ((modelItem != null) ? modelItem.toString() : "null") + "Error: ItemInfo passed to checkItemInfo doesn't match original";
            RuntimeException e = new RuntimeException(msg);
            if (stackTrace != null) {
                e.setStackTrace(stackTrace);
            }
            throw e;
        }
    }
}
#end_block

#method_before
private void removeHiddenAppsWorkspaceItems(final ArrayList<ItemInfo> workspaceItems, final ArrayList<LauncherAppWidgetInfo> appWidgets, final LongArrayMap<FolderInfo> folders) {
    // Get hidden apps
    ArrayList<ComponentName> mHiddenApps = new ArrayList<ComponentName>();
    ArrayList<String> mHiddenAppsPackages = new ArrayList<String>();
    Context context = mApp.getContext();
    String protectedComponents = CMSettings.Secure.getString(context.getContentResolver(), CMSettings.Secure.PROTECTED_COMPONENTS);
    protectedComponents = protectedComponents == null ? "" : protectedComponents;
    String[] flattened = protectedComponents.split("\\|");
    for (String flat : flattened) {
        ComponentName cmp = ComponentName.unflattenFromString(flat);
        if (cmp != null) {
            mHiddenApps.add(cmp);
            mHiddenAppsPackages.add(cmp.getPackageName());
        }
    }
    // Shortcuts
    int N = workspaceItems.size() - 1;
    for (int i = N; i >= 0; i--) {
        final ItemInfo item = workspaceItems.get(i);
        if (item instanceof ShortcutInfo) {
            ShortcutInfo shortcut = (ShortcutInfo) item;
            if (shortcut.intent != null && shortcut.intent.getComponent() != null) {
                if (mHiddenApps.contains(shortcut.intent.getComponent())) {
                    LauncherModel.deleteItemFromDatabase(mContext, shortcut);
                    workspaceItems.remove(i);
                }
            }
        } else {
            // Only remove items from folders that aren't hidden
            final FolderInfo folder = (FolderInfo) item;
            List<ShortcutInfo> shortcuts = folder.contents;
            int NN = shortcuts.size() - 1;
            for (int j = NN; j >= 0; j--) {
                final ShortcutInfo sci = shortcuts.get(j);
                if (sci.intent != null && sci.intent.getComponent() != null) {
                    if (!folder.hidden) {
                        if (mHiddenApps.contains(sci.intent.getComponent())) {
                            LauncherModel.deleteItemFromDatabase(mContext, sci);
                            Runnable r = new Runnable() {

                                public void run() {
                                    folder.remove(sci);
                                }
                            };
                            runOnMainThread(r);
                        }
                    } else {
                        if (!mHiddenApps.contains(sci.intent.getComponent())) {
                            LauncherModel.deleteItemFromDatabase(mContext, sci);
                            Runnable r = new Runnable() {

                                public void run() {
                                    folder.remove(sci);
                                }
                            };
                            runOnMainThread(r);
                        }
                    }
                }
            }
            if (folder.contents.size() == 1 && !folder.hidden) {
                ShortcutInfo finalItem = folder.contents.get(0);
                finalItem.container = folder.container;
                LauncherModel.deleteItemFromDatabase(mContext, folder);
                // only replace this item back on the workspace if it's not protected
                if (!mHiddenApps.contains(finalItem.intent.getComponent())) {
                    LauncherModel.addOrMoveItemInDatabase(mContext, finalItem, folder.container, folder.screenId, folder.cellX, folder.cellY);
                    workspaceItems.add(finalItem);
                }
                workspaceItems.remove(i);
                folders.remove(Long.valueOf(item.id));
            } else if (folder.contents.size() == 0) {
                LauncherModel.deleteFolderContentsFromDatabase(mContext, folder);
                workspaceItems.remove(i);
                folders.remove(Long.valueOf(item.id));
            }
        }
    }
    // AppWidgets
    N = appWidgets.size() - 1;
    for (int i = N; i >= 0; i--) {
        final LauncherAppWidgetInfo item = appWidgets.get(i);
        if (item.providerName != null) {
            if (mHiddenAppsPackages.contains(item.providerName.getPackageName())) {
                LauncherModel.deleteItemFromDatabase(mContext, item);
                appWidgets.remove(i);
            }
        }
    }
}
#method_after
private void removeHiddenAppsWorkspaceItems(final ArrayList<ItemInfo> workspaceItems, final ArrayList<LauncherAppWidgetInfo> appWidgets, final LongArrayMap<FolderInfo> folders) {
    // Get hidden apps
    ArrayList<ComponentName> mHiddenApps = new ArrayList<ComponentName>();
    ArrayList<String> mHiddenAppsPackages = new ArrayList<String>();
    Context context = mApp.getContext();
    String protectedComponents = CMSettings.Secure.getString(context.getContentResolver(), CMSettings.Secure.PROTECTED_COMPONENTS);
    protectedComponents = protectedComponents == null ? "" : protectedComponents;
    String[] flattened = protectedComponents.split("\\|");
    for (String flat : flattened) {
        ComponentName cmp = ComponentName.unflattenFromString(flat);
        if (cmp != null) {
            mHiddenApps.add(cmp);
            mHiddenAppsPackages.add(cmp.getPackageName());
        }
    }
    // Shortcuts
    int N = workspaceItems.size() - 1;
    for (int i = N; i >= 0; i--) {
        final ItemInfo item = workspaceItems.get(i);
        if (item instanceof ShortcutInfo) {
            ShortcutInfo shortcut = (ShortcutInfo) item;
            if (shortcut.intent != null && shortcut.intent.getComponent() != null) {
                if (mHiddenApps.contains(shortcut.intent.getComponent())) {
                    LauncherModel.deleteItemFromDatabase(mContext, shortcut);
                    workspaceItems.remove(i);
                }
            }
        } else {
            // Only remove items from folders that aren't hidden
            final FolderInfo folder = (FolderInfo) item;
            List<ShortcutInfo> shortcuts = folder.contents;
            int NN = shortcuts.size() - 1;
            for (int j = NN; j >= 0; j--) {
                final ShortcutInfo sci = shortcuts.get(j);
                if (sci.intent != null && sci.intent.getComponent() != null) {
                    if (!folder.hidden) {
                        if (mHiddenApps.contains(sci.intent.getComponent())) {
                            LauncherModel.deleteItemFromDatabase(mContext, sci);
                            Runnable r = new Runnable() {

                                public void run() {
                                    folder.remove(sci);
                                }
                            };
                            runOnMainThread(r);
                        }
                    } else {
                        if (!mHiddenApps.contains(sci.intent.getComponent())) {
                            LauncherModel.deleteItemFromDatabase(mContext, sci);
                            Runnable r = new Runnable() {

                                public void run() {
                                    folder.remove(sci);
                                }
                            };
                            runOnMainThread(r);
                        }
                    }
                }
            }
            if (folder.contents.size() == 1 && !folder.hidden) {
                ShortcutInfo finalItem = folder.contents.get(0);
                finalItem.container = folder.container;
                LauncherModel.deleteItemFromDatabase(mContext, folder);
                // only replace this item back on the workspace if it's not protected
                if (!mHiddenApps.contains(finalItem.intent.getComponent())) {
                    LauncherModel.addOrMoveItemInDatabase(mContext, finalItem, folder.container, folder.screenId, folder.cellX, folder.cellY);
                    workspaceItems.add(finalItem);
                }
                workspaceItems.remove(i);
                folders.remove(Long.valueOf(item.id));
            // Remote folders are always empty on bind.
            } else if (folder.contents.size() == 0 && !folder.isRemote()) {
                LauncherModel.deleteFolderContentsFromDatabase(mContext, folder);
                workspaceItems.remove(i);
                folders.remove(Long.valueOf(item.id));
            }
        }
    }
    // AppWidgets
    N = appWidgets.size() - 1;
    for (int i = N; i >= 0; i--) {
        final LauncherAppWidgetInfo item = appWidgets.get(i);
        if (item.providerName != null) {
            if (mHiddenAppsPackages.contains(item.providerName.getPackageName())) {
                LauncherModel.deleteItemFromDatabase(mContext, item);
                appWidgets.remove(i);
            }
        }
    }
}
#end_block

#method_before
public void onCreateViewHolder(final AllAppsGridAdapter.ViewHolder holder) {
}
#method_after
public void onCreateViewHolder(final AllAppsGridAdapter.ViewHolder holder, final int viewType) {
}
#end_block

#method_before
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    mPkgName = getArguments().getString("pkgName");
    ArrayList<String> filters = getArguments().getStringArrayList(ChooserActivity.EXTRA_COMPONENT_FILTER);
    mComponentFilters = (filters != null) ? filters : new ArrayList<String>(0);
    View v = inflater.inflate(R.layout.fragment_chooser_theme_pager_item, container, false);
    mTitle = (TextView) v.findViewById(R.id.title);
    mAuthor = (TextView) v.findViewById(R.id.author);
    mPager = (ViewPager) v.findViewById(R.id.pager);
    mPagerAdapter = new ThemeDetailPagerAdapter(getChildFragmentManager());
    mPager.setAdapter(mPagerAdapter);
    mApply = (Button) v.findViewById(R.id.apply);
    mApply.setOnClickListener(new OnClickListener() {

        public void onClick(View view) {
            List<String> components = getCheckedComponents();
            mService.requestThemeChange(mPkgName, components);
            mApply.setText(R.string.applying);
        }
    });
    mSlidingPanel = (SlidingupPanelLayout) v.findViewById(R.id.sliding_layout);
    // Find all the checkboxes for theme components (ex wallpaper)
    for (Map.Entry<String, Integer> entry : sComponentToId.entrySet()) {
        CheckBox componentCheckbox = (CheckBox) v.findViewById(entry.getValue());
        mComponentToCheckbox.put(entry.getKey(), componentCheckbox);
    }
    getLoaderManager().initLoader(LOADER_ID_THEME_INFO, null, this);
    getLoaderManager().initLoader(LOADER_ID_APPLIED_THEME, null, this);
    mService = (ThemeManager) getActivity().getSystemService(Context.THEME_SERVICE);
    return v;
}
#method_after
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    mPkgName = getArguments().getString("pkgName");
    ArrayList<String> filters = getArguments().getStringArrayList(ChooserActivity.EXTRA_COMPONENT_FILTER);
    mComponentFilters = (filters != null) ? filters : new ArrayList<String>(0);
    View v = inflater.inflate(R.layout.fragment_chooser_theme_pager_item, container, false);
    mTitle = (TextView) v.findViewById(R.id.title);
    mAuthor = (TextView) v.findViewById(R.id.author);
    mPager = (ViewPager) v.findViewById(R.id.pager);
    mPagerAdapter = new ThemeDetailPagerAdapter(getChildFragmentManager());
    mPager.setAdapter(mPagerAdapter);
    mApply = (Button) v.findViewById(R.id.apply);
    mApply.setOnClickListener(new OnClickListener() {

        public void onClick(View view) {
            List<String> components = getCheckedComponents();
            mService.requestThemeChange(mPkgName, components);
            mApply.setText(R.string.applying);
        }
    });
    mSlidingPanel = (SlidingupPanelLayout) v.findViewById(R.id.sliding_layout);
    // Find all the checkboxes for theme components (ex wallpaper)
    for (Map.Entry<String, Integer> entry : sComponentToId.entrySet()) {
        CheckBox componentCheckbox = (CheckBox) v.findViewById(entry.getValue());
        mComponentToCheckbox.put(entry.getKey(), componentCheckbox);
        componentCheckbox.setOnCheckedChangeListener(mComponentCheckChangedListener);
    }
    getLoaderManager().initLoader(LOADER_ID_THEME_INFO, null, this);
    getLoaderManager().initLoader(LOADER_ID_APPLIED_THEME, null, this);
    mService = (ThemeManager) getActivity().getSystemService(Context.THEME_SERVICE);
    return v;
}
#end_block

#method_before
private void refreshChecksForCheckboxes() {
    // Determine which components are applied
    List<String> appliedComponents = new ArrayList<String>();
    if (mAppliedThemeCursor != null) {
        mAppliedThemeCursor.moveToPosition(-1);
        while (mAppliedThemeCursor.moveToNext()) {
            String mixnmatchkey = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_KEY));
            String component = ThemesContract.MixnMatchColumns.mixNMatchKeyToComponent(mixnmatchkey);
            String pkg = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_VALUE));
            if (pkg.equals(mPkgName)) {
                appliedComponents.add(component);
            }
        }
    }
    // Apply checks
    for (Map.Entry<String, CheckBox> entry : mComponentToCheckbox.entrySet()) {
        String componentName = entry.getKey();
        CheckBox componentCheckbox = entry.getValue();
        if (appliedComponents.contains(componentName)) {
            componentCheckbox.setChecked(true);
        }
    }
}
#method_after
private void refreshChecksForCheckboxes() {
    // Determine which components are applied
    List<String> appliedComponents = new ArrayList<String>();
    if (mAppliedThemeCursor != null) {
        mAppliedThemeCursor.moveToPosition(-1);
        while (mAppliedThemeCursor.moveToNext()) {
            String mixnmatchkey = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_KEY));
            String component = ThemesContract.MixnMatchColumns.mixNMatchKeyToComponent(mixnmatchkey);
            String pkg = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_VALUE));
            if (pkg.equals(mPkgName)) {
                appliedComponents.add(component);
            }
        }
    }
    // Apply checks
    for (Map.Entry<String, CheckBox> entry : mComponentToCheckbox.entrySet()) {
        String componentName = entry.getKey();
        CheckBox componentCheckbox = entry.getValue();
        if (appliedComponents.contains(componentName)) {
            componentCheckbox.setChecked(true);
        }
        if (mLoadInitialCheckboxStates) {
            mInitialCheckboxStates.put(componentCheckbox.getId(), componentCheckbox.isChecked());
        }
        mCurrentCheckboxStates.put(componentCheckbox.getId(), componentCheckbox.isChecked());
    }
}
#end_block

#method_before
private void refreshApplyButton() {
    // Default
    mApply.setText(R.string.apply);
    mApply.setEnabled(true);
    LayerDrawable bg = (LayerDrawable) mApply.getBackground();
    final ClipDrawable clip = (ClipDrawable) bg.findDrawableByLayerId(android.R.id.progress);
    clip.setLevel(0);
    // Determine whether the apply button should show "apply" or "update"
    if (mAppliedThemeCursor != null) {
        mAppliedThemeCursor.moveToPosition(-1);
        while (mAppliedThemeCursor.moveToNext()) {
            String component = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_KEY));
            String pkg = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_VALUE));
            // At least one component is set here for this theme
            if (pkg != null && mPkgName.equals(pkg)) {
                mApply.setText(R.string.update);
                break;
            }
        }
    }
    // Determine if the apply button's progress
    int progress = (mService == null) ? 0 : mService.getProgress(mPkgName);
    if (progress != 0) {
        clip.setLevel(progress * 100);
        mApply.setText(R.string.applying);
        mApply.setEnabled(false);
    }
}
#method_after
private void refreshApplyButton() {
    // Default
    mApply.setText(R.string.apply);
    StateListDrawable d = (StateListDrawable) mApply.getBackground();
    LayerDrawable bg = (LayerDrawable) d.getStateDrawable(d.getStateDrawableIndex(new int[] { android.R.attr.state_enabled }));
    final ClipDrawable clip = (ClipDrawable) bg.findDrawableByLayerId(android.R.id.progress);
    clip.setLevel(0);
    // Determine whether the apply button should show "apply" or "update"
    if (mAppliedThemeCursor != null) {
        mAppliedThemeCursor.moveToPosition(-1);
        while (mAppliedThemeCursor.moveToNext()) {
            String component = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_KEY));
            String pkg = mAppliedThemeCursor.getString(mAppliedThemeCursor.getColumnIndex(MixnMatchColumns.COL_VALUE));
            // At least one component is set here for this theme
            if (pkg != null && mPkgName.equals(pkg)) {
                mApply.setText(R.string.update);
                break;
            }
        }
    }
    // Determine if the apply button's progress
    int progress = (mService == null) ? 0 : mService.getProgress(mPkgName);
    if (progress != 0) {
        clip.setLevel(progress * 100);
        mApply.setText(R.string.applying);
        mApply.setClickable(false);
    } else {
        mApply.setClickable(true);
    }
}
#end_block

#method_before
@Override
protected Boolean doInBackground(Void... params) {
    InputStream is;
    if ("default".equals(mPkgName)) {
        try {
            is = new ZipInputStream(new FileInputStream(BootAnimationHelper.SYSTEM_BOOT_ANI_PATH));
        } catch (FileNotFoundException e) {
            return Boolean.FALSE;
        }
    } else {
        PackageManager pm = mContext.getPackageManager();
        try {
            ApplicationInfo ai = pm.getApplicationInfo(mPkgName, 0);
            ZipFile zip = new ZipFile(new File(ai.sourceDir));
            is = zip.getInputStream(zip.getEntry(BootAnimationHelper.THEME_INTERNAL_BOOT_ANI_PATH));
        } catch (PackageManager.NameNotFoundException e) {
            return Boolean.FALSE;
        } catch (ZipException e) {
            return Boolean.FALSE;
        } catch (IOException e) {
            return Boolean.FALSE;
        }
    }
    if (is != null) {
        try {
            synchronized (mAnimationLock) {
                mAnimationParts = BootAnimationHelper.loadAnimation(getActivity(), is);
            }
        } catch (IOException e) {
            return Boolean.FALSE;
        }
    }
    return Boolean.TRUE;
}
#method_after
@Override
protected Boolean doInBackground(Void... params) {
    if (mContext == null) {
        return Boolean.FALSE;
    }
    InputStream is;
    if ("default".equals(mPkgName)) {
        try {
            is = new ZipInputStream(new FileInputStream(BootAnimationHelper.SYSTEM_BOOT_ANI_PATH));
        } catch (FileNotFoundException e) {
            return Boolean.FALSE;
        }
    } else {
        PackageManager pm = mContext.getPackageManager();
        try {
            ApplicationInfo ai = pm.getApplicationInfo(mPkgName, 0);
            ZipFile zip = new ZipFile(new File(ai.sourceDir));
            is = zip.getInputStream(zip.getEntry(BootAnimationHelper.THEME_INTERNAL_BOOT_ANI_PATH));
        } catch (PackageManager.NameNotFoundException e) {
            return Boolean.FALSE;
        } catch (ZipException e) {
            return Boolean.FALSE;
        } catch (IOException e) {
            return Boolean.FALSE;
        }
    }
    if (is != null) {
        try {
            synchronized (mAnimationLock) {
                mAnimationParts = BootAnimationHelper.loadAnimation(mContext, is);
            }
        } catch (IOException e) {
            return Boolean.FALSE;
        }
    }
    return Boolean.TRUE;
}
#end_block

#method_before
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    mPkgName = getArguments().getString("pkgName");
    ArrayList<String> filters = getArguments().getStringArrayList(ChooserActivity.EXTRA_COMPONENT_FILTER);
    mComponentFilters = (filters != null) ? filters : new ArrayList<String>(0);
    View v = inflater.inflate(R.layout.fragment_chooser_theme_pager_item, container, false);
    mTitle = (TextView) v.findViewById(R.id.title);
    mAuthor = (TextView) v.findViewById(R.id.author);
    mPager = (ViewPager) v.findViewById(R.id.pager);
    mPager.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View view) {
            // Scroll between 3 different heights when pager is clicked
            int visibleHeight = mSlidingPanel.getHeight();
            // **WARNING** Clark don't let me ship this!
            View handle = ((ViewGroup) mSlidingPanel.getChildAt(0)).getChildAt(1);
            visibleHeight -= handle.getHeight();
            int scrollY = mSlidingPanel.getScrollY();
            int percentageScrolled = (scrollY * 100) / (visibleHeight);
            int percentScroll = 0;
            if (percentageScrolled < 25) {
                percentScroll = 26;
            } else if (percentageScrolled < 50) {
                percentScroll = 100;
            }
            int newScrollY = percentScroll * (visibleHeight) / 100;
            mSlidingPanel.smoothScrollTo(0, newScrollY);
        }
    });
    mPagerAdapter = new ThemeDetailPagerAdapter(getChildFragmentManager());
    mPager.setAdapter(mPagerAdapter);
    mApply = (Button) v.findViewById(R.id.apply);
    mApply.setOnClickListener(new OnClickListener() {

        public void onClick(View view) {
            List<String> components = getCheckedComponents();
            mService.requestThemeChange(mPkgName, components);
            mApply.setText(R.string.applying);
        }
    });
    mSlidingPanel = (ChooserDetailScrollView) v.findViewById(R.id.sliding_layout);
    // Find all the checkboxes for theme components (ex wallpaper)
    for (Map.Entry<String, Integer> entry : sComponentToId.entrySet()) {
        CheckBox componentCheckbox = (CheckBox) v.findViewById(entry.getValue());
        mComponentToCheckbox.put(entry.getKey(), componentCheckbox);
        componentCheckbox.setOnCheckedChangeListener(mComponentCheckChangedListener);
    }
    getLoaderManager().initLoader(LOADER_ID_THEME_INFO, null, this);
    getLoaderManager().initLoader(LOADER_ID_APPLIED_THEME, null, this);
    mService = (ThemeManager) getActivity().getSystemService(Context.THEME_SERVICE);
    return v;
}
#method_after
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    mPkgName = getArguments().getString("pkgName");
    ArrayList<String> filters = getArguments().getStringArrayList(ChooserActivity.EXTRA_COMPONENT_FILTER);
    mComponentFilters = (filters != null) ? filters : new ArrayList<String>(0);
    View v = inflater.inflate(R.layout.fragment_chooser_theme_pager_item, container, false);
    mTitle = (TextView) v.findViewById(R.id.title);
    mAuthor = (TextView) v.findViewById(R.id.author);
    mPager = (ViewPager) v.findViewById(R.id.pager);
    mPager.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View view) {
            int state = getDrawerState();
            switch(state) {
                case DRAWER_CLOSED:
                    smoothScrollDrawerTo(DRAWER_PARTIALLY_OPEN);
                    break;
                case DRAWER_PARTIALLY_OPEN:
                case DRAWER_MOSTLY_OPEN:
                    smoothScrollDrawerTo(DRAWER_OPEN);
                    break;
                case DRAWER_OPEN:
                    smoothScrollDrawerTo(DRAWER_CLOSED);
                    break;
            }
        }
    });
    mPagerAdapter = new ThemeDetailPagerAdapter(getChildFragmentManager());
    mPager.setAdapter(mPagerAdapter);
    mApply = (Button) v.findViewById(R.id.apply);
    mApply.setOnClickListener(new OnClickListener() {

        public void onClick(View view) {
            List<String> components = getCheckedComponents();
            mService.requestThemeChange(mPkgName, components);
            mApply.setText(R.string.applying);
        }
    });
    mSlidingPanel = (ChooserDetailScrollView) v.findViewById(R.id.sliding_layout);
    // Find all the checkboxes for theme components (ex wallpaper)
    for (Map.Entry<String, Integer> entry : sComponentToId.entrySet()) {
        CheckBox componentCheckbox = (CheckBox) v.findViewById(entry.getValue());
        mComponentToCheckbox.put(entry.getKey(), componentCheckbox);
        componentCheckbox.setOnCheckedChangeListener(mComponentCheckChangedListener);
    }
    getLoaderManager().initLoader(LOADER_ID_THEME_INFO, null, this);
    getLoaderManager().initLoader(LOADER_ID_APPLIED_THEME, null, this);
    mService = (ThemeManager) getActivity().getSystemService(Context.THEME_SERVICE);
    return v;
}
#end_block

#method_before
private boolean hasAllPermissions() {
    int hasMicPerm = checkSelfPermission(Manifest.permission.RECORD_AUDIO);
    int hasStoragePerm = checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE);
    if (hasMicPerm == PackageManager.PERMISSION_GRANTED && hasStoragePerm == PackageManager.PERMISSION_GRANTED) {
        return true;
    } else {
        return false;
    }
}
#method_after
private boolean hasAllPermissions() {
    int hasMicPerm = checkSelfPermission(Manifest.permission.RECORD_AUDIO);
    int hasStoragePerm = checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE);
    int hasPhonePerm = checkSelfPermission(Manifest.permission.READ_PHONE_STATE);
    if (hasMicPerm == PackageManager.PERMISSION_GRANTED && hasStoragePerm == PackageManager.PERMISSION_GRANTED && hasPhonePerm == PackageManager.PERMISSION_GRANTED) {
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    if (requestCode == REQUEST_PERMISSIONS) {
        if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "Permissions granted, good to go");
            // Now that wer have permissions start recording
            recordButtonAction();
        } else {
            showPermsDialog();
        }
    }
}
#method_after
@Override
public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    if (hasAllPermissions()) {
        Log.i(TAG, "All required permissions were granted");
        // Start Recording now
        recordButtonAction();
    } else {
        boolean showMic = shouldShowRequestPermissionRationale(Manifest.permission.RECORD_AUDIO);
        boolean showStorage = shouldShowRequestPermissionRationale(Manifest.permission.WRITE_EXTERNAL_STORAGE);
        boolean showPhone = shouldShowRequestPermissionRationale(Manifest.permission.READ_PHONE_STATE);
        if (showMic || showStorage || showPhone) {
            // Show our dialog with specific info
            showPermsDialog();
        } else {
            // User has denied all required permissions
            Toast toast = Toast.makeText(SoundRecorder.this, getString(R.string.perm_toast), Toast.LENGTH_LONG);
            toast.show();
        }
    }
}
#end_block

#method_before
private void showPermsDialog() {
    String mPermDialogMessage = getString(R.string.error_unknown);
    int mPermError = 0;
    /**
     * 1 = Microphone
     * 2 = Storage
     * 5 = Phone -> We can live without it
     * 3 = 1+2
     * 6 = 1+5
     * 7 = 2+5
     * 8 = what a rude user!
     */
    int hasMicPerm = checkSelfPermission(Manifest.permission.RECORD_AUDIO);
    int hasStoragePerm = checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE);
    int hasPhonePerm = checkSelfPermission(Manifest.permission.READ_PHONE_STATE);
    if (hasMicPerm != PackageManager.PERMISSION_GRANTED) {
        mPermError = mPermError + 1;
        Log.e(TAG, "Microphone permission not granted!");
    }
    if (hasStoragePerm != PackageManager.PERMISSION_GRANTED) {
        mPermError = mPermError + 2;
        Log.e(TAG, "Storage permission not granted!");
    }
    if (hasPhonePerm != PackageManager.PERMISSION_GRANTED) {
        mPermError = mPermError + 5;
        Log.w(TAG, "Phone permission not granted. We can live without this...");
    }
    switch(mPermError) {
        case 1:
            mPermDialogMessage = getString(R.string.error_mic);
        case 2:
            mPermDialogMessage = getString(R.string.error_storage);
        case 3:
            mPermDialogMessage = getString(R.string.error_micstorage);
        case 5:
            mPermDialogMessage = getString(R.string.error_phone);
        case 6:
            mPermDialogMessage = getString(R.string.error_micphone);
        case 7:
            mPermDialogMessage = getString(R.string.error_storagephone);
        case 8:
            mPermDialogMessage = getString(R.string.error_allperms);
    }
    new AlertDialog.Builder(this).setTitle(getResources().getString(R.string.denied_title)).setMessage(mPermDialogMessage).setPositiveButton(getResources().getString(R.string.allow), new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            checkSRecPermissions();
        }
    }).setNegativeButton(getResources().getString(R.string.dismiss), new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            Log.w(TAG, "We're given nothing, we give nothing!");
        }
    }).show();
}
#method_after
private void showPermsDialog() {
    String mPermDialogMessage = getString(R.string.perm_unknown);
    int mPermError = 0;
    /**
     * mPermError values
     * 1 = Microphone
     * 2 = Storage
     * 5 = Phone Status
     * 3 = 1+2
     * 6 = 1+5
     * 7 = 2+5
     * 8 = 1+2+5
     */
    int hasMicPerm = checkSelfPermission(Manifest.permission.RECORD_AUDIO);
    int hasStoragePerm = checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE);
    int hasPhonePerm = checkSelfPermission(Manifest.permission.READ_PHONE_STATE);
    if (hasMicPerm != PackageManager.PERMISSION_GRANTED) {
        mPermError += 1;
        Log.e(TAG, "Microphone permission not granted!");
    }
    if (hasStoragePerm != PackageManager.PERMISSION_GRANTED) {
        mPermError += 2;
        Log.e(TAG, "Storage permission not granted!");
    }
    if (hasPhonePerm != PackageManager.PERMISSION_GRANTED) {
        mPermError += 5;
        Log.e(TAG, "Phone Status permission not granted!");
    }
    // Choose the message basing on what permissions are missing
    switch(mPermError) {
        case 1:
            mPermDialogMessage = getString(R.string.perm_mic);
            break;
        case 2:
            mPermDialogMessage = getString(R.string.perm_storage);
            break;
        case 3:
            mPermDialogMessage = getString(R.string.perm_micstorage);
            break;
        case 5:
            mPermDialogMessage = getString(R.string.perm_phone);
            break;
        case 6:
            mPermDialogMessage = getString(R.string.perm_micphone);
            break;
        case 7:
            mPermDialogMessage = getString(R.string.perm_storagephone);
            break;
        case 8:
            mPermDialogMessage = getString(R.string.perm_allperms);
            break;
    }
    new AlertDialog.Builder(this).setTitle(getResources().getString(R.string.denied_title)).setMessage(mPermDialogMessage).setPositiveButton(getResources().getString(R.string.ask_again), new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            checkSRecPermissions();
        }
    }).setNegativeButton(getResources().getString(R.string.dismiss), new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            Log.w(TAG, "Required permissions were denied!");
        }
    }).show();
}
#end_block

#method_before
private void recordButtonAction() {
    if (!hasAllPermissions()) {
        checkSRecPermissions();
    } else {
        if (mRecorder.state() == Recorder.PAUSE_STATE) {
            mRecordHandler.sendEmptyMessage(RESUME_RECORDING);
            mUiHandler.post(mUpdateUiRunnable);
            return;
        } else if (mRecorder.state() == Recorder.RECORDING_STATE) {
            mRecordHandler.sendEmptyMessage(PAUSE_RECORDING);
            mUiHandler.post(mUpdateUiRunnable);
            return;
        }
        mRemainingTimeCalculator.reset();
        mRemainingTimeCalculator.setStoragePath(mPath);
        mRecorder.setStoragePath(mStoragePath);
        if (mPath == 0 && !Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
            mSampleInterrupted = true;
            mErrorUiMessage = getResources().getString(R.string.no_phonestorage);
            mUiHandler.post(mUpdateUiRunnable);
        } else if (mPath == 1 && !getSDState(SoundRecorder.this).equals(Environment.MEDIA_MOUNTED)) {
            mSampleInterrupted = true;
            mErrorUiMessage = getResources().getString(R.string.insert_sd_card);
            mUiHandler.post(mUpdateUiRunnable);
        } else if (!mRemainingTimeCalculator.diskSpaceAvailable()) {
            mSampleInterrupted = true;
            mErrorUiMessage = getResources().getString(R.string.storage_is_full);
            mUiHandler.post(mUpdateUiRunnable);
        } else {
            stopAudioPlayback();
            if ((mAudioManager.getMode() == AudioManager.MODE_IN_CALL) && (mAudioSourceType == MediaRecorder.AudioSource.MIC)) {
                mAudioSourceType = MediaRecorder.AudioSource.VOICE_UPLINK;
                Log.e(TAG, "Selected Voice Tx only Source: sourcetype" + mAudioSourceType);
            }
            if (AUDIO_AMR.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.RAW_AMR, MediaRecorder.AudioEncoder.AMR_NB).sendToTarget();
            } else if (AUDIO_EVRC.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.QCP, MediaRecorder.AudioEncoder.AMR_NB).sendToTarget();
            } else if (AUDIO_QCELP.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.QCP, MediaRecorder.AudioEncoder.QCELP).sendToTarget();
            } else if (AUDIO_3GPP.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.THREE_GPP, MediaRecorder.AudioEncoder.AMR_NB).sendToTarget();
            } else if (AUDIO_AAC_MP4.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.THREE_GPP, MediaRecorder.AudioEncoder.AAC).sendToTarget();
            } else if (AUDIO_AAC_5POINT1_CHANNEL.equals(mRequestedType)) {
                // AAC  6-channel recording
                if (bSSRSupported) {
                    mRecorder.setChannels(6);
                    mAudioSourceType = MediaRecorder.AudioSource.MIC;
                    mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.THREE_GPP, MediaRecorder.AudioEncoder.AAC).sendToTarget();
                } else {
                    throw new IllegalArgumentException("Invalid output file type requested");
                }
            } else if (AUDIO_WAVE_6CH_LPCM.equals(mRequestedType)) {
                // WAVE LPCM  6-channel recording
                if (bSSRSupported) {
                    mRecorder.setChannels(6);
                    mAudioSourceType = MediaRecorder.AudioSource.MIC;
                    mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.WAVE, MediaRecorder.AudioEncoder.LPCM).sendToTarget();
                } else {
                    throw new IllegalArgumentException("Invalid output file type requested");
                }
            } else if (AUDIO_WAVE_2CH_LPCM.equals(mRequestedType)) {
                // WAVE LPCM  2-channel recording
                mRecorder.setChannels(2);
                mAudioSourceType = MediaRecorder.AudioSource.MIC;
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.WAVE, MediaRecorder.AudioEncoder.LPCM).sendToTarget();
            } else if (AUDIO_WAVE_1CH_LPCM.equals(mRequestedType)) {
                // WAVE LPCM  1-channel recording
                mRecorder.setChannels(1);
                mAudioSourceType = MediaRecorder.AudioSource.MIC;
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.WAVE, MediaRecorder.AudioEncoder.LPCM).sendToTarget();
            } else if (AUDIO_AMR_WB.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB).sendToTarget();
            } else {
                throw new IllegalArgumentException("Invalid output file type requested");
            }
            if (mMaxFileSize != -1) {
                mRemainingTimeCalculator.setFileSizeLimit(mRecorder.sampleFile(), mMaxFileSize);
            }
            mRecorderStop = false;
            mRecorderProcessed = false;
        }
        invalidateOptionsMenu();
    }
}
#method_after
private void recordButtonAction() {
    if (!hasAllPermissions()) {
        checkSRecPermissions();
    } else {
        if (mRecorder.state() == Recorder.PAUSE_STATE) {
            mRecordHandler.sendEmptyMessage(RESUME_RECORDING);
            mUiHandler.post(mUpdateUiRunnable);
            return;
        } else if (mRecorder.state() == Recorder.RECORDING_STATE) {
            mRecordHandler.sendEmptyMessage(PAUSE_RECORDING);
            mUiHandler.post(mUpdateUiRunnable);
            return;
        }
        mRemainingTimeCalculator.reset();
        mRemainingTimeCalculator.setStoragePath(mPath);
        mRecorder.setStoragePath(mStoragePath);
        if (mPath == 0 && !Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
            mSampleInterrupted = true;
            mErrorUiMessage = getResources().getString(R.string.no_phonestorage);
            mUiHandler.post(mUpdateUiRunnable);
        } else if (mPath == 1 && !getSDState(SoundRecorder.this).equals(Environment.MEDIA_MOUNTED)) {
            mSampleInterrupted = true;
            mErrorUiMessage = getResources().getString(R.string.insert_sd_card);
            mUiHandler.post(mUpdateUiRunnable);
        } else if (!mRemainingTimeCalculator.diskSpaceAvailable()) {
            mSampleInterrupted = true;
            mErrorUiMessage = getResources().getString(R.string.storage_is_full);
            mUiHandler.post(mUpdateUiRunnable);
        } else {
            stopAudioPlayback();
            if ((mAudioManager.getMode() == AudioManager.MODE_IN_CALL) && (mAudioSourceType == MediaRecorder.AudioSource.MIC)) {
                mAudioSourceType = MediaRecorder.AudioSource.VOICE_UPLINK;
                Log.e(TAG, "Selected Voice Tx only Source: sourcetype" + mAudioSourceType);
            }
            if (AUDIO_AMR.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.RAW_AMR, MediaRecorder.AudioEncoder.AMR_NB).sendToTarget();
            } else if (AUDIO_EVRC.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.QCP, MediaRecorder.AudioEncoder.AMR_NB).sendToTarget();
            } else if (AUDIO_QCELP.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.QCP, MediaRecorder.AudioEncoder.QCELP).sendToTarget();
            } else if (AUDIO_3GPP.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.THREE_GPP, MediaRecorder.AudioEncoder.AMR_NB).sendToTarget();
            } else if (AUDIO_AAC_MP4.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.THREE_GPP, MediaRecorder.AudioEncoder.AAC).sendToTarget();
            } else if (AUDIO_AAC_5POINT1_CHANNEL.equals(mRequestedType)) {
                // AAC 6-channel recording
                if (bSSRSupported) {
                    mRecorder.setChannels(6);
                    mAudioSourceType = MediaRecorder.AudioSource.MIC;
                    mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.THREE_GPP, MediaRecorder.AudioEncoder.AAC).sendToTarget();
                } else {
                    throw new IllegalArgumentException("Invalid output file type requested");
                }
            } else if (AUDIO_WAVE_6CH_LPCM.equals(mRequestedType)) {
                // WAVE LPCM 6-channel recording
                if (bSSRSupported) {
                    mRecorder.setChannels(6);
                    mAudioSourceType = MediaRecorder.AudioSource.MIC;
                    mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.WAVE, MediaRecorder.AudioEncoder.LPCM).sendToTarget();
                } else {
                    throw new IllegalArgumentException("Invalid output file type requested");
                }
            } else if (AUDIO_WAVE_2CH_LPCM.equals(mRequestedType)) {
                // WAVE LPCM 2-channel recording
                mRecorder.setChannels(2);
                mAudioSourceType = MediaRecorder.AudioSource.MIC;
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.WAVE, MediaRecorder.AudioEncoder.LPCM).sendToTarget();
            } else if (AUDIO_WAVE_1CH_LPCM.equals(mRequestedType)) {
                // WAVE LPCM 1-channel recording
                mRecorder.setChannels(1);
                mAudioSourceType = MediaRecorder.AudioSource.MIC;
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.WAVE, MediaRecorder.AudioEncoder.LPCM).sendToTarget();
            } else if (AUDIO_AMR_WB.equals(mRequestedType)) {
                mRecordHandler.obtainMessage(START_RECORDING, MediaRecorder.OutputFormat.AMR_WB, MediaRecorder.AudioEncoder.AMR_WB).sendToTarget();
            } else {
                throw new IllegalArgumentException("Invalid output file type requested");
            }
            if (mMaxFileSize != -1) {
                mRemainingTimeCalculator.setFileSizeLimit(mRecorder.sampleFile(), mMaxFileSize);
            }
            mRecorderStop = false;
            mRecorderProcessed = false;
        }
        invalidateOptionsMenu();
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case SETUP_PREVIEW:
            {
                setupPreview();
                break;
            }
        case CLEAR_SCREEN_DELAY:
            {
                mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                break;
            }
        case FIRST_TIME_INIT:
            {
                initializeFirstTime();
                break;
            }
        case SET_CAMERA_PARAMETERS_WHEN_IDLE:
            {
                setCameraParametersWhenIdle(0);
                break;
            }
        case SHOW_TAP_TO_FOCUS_TOAST:
            {
                showTapToFocusToast();
                break;
            }
        case SWITCH_CAMERA:
            {
                switchCamera();
                break;
            }
        case SWITCH_CAMERA_START_ANIMATION:
            {
                // ((CameraScreenNail) mActivity.mCameraScreenNail).animateSwitchCamera();
                break;
            }
        case CAMERA_OPEN_DONE:
            {
                onCameraOpened();
                break;
            }
        case OPEN_CAMERA_FAIL:
            {
                mOpenCameraFail = true;
                CameraUtil.showErrorAndFinish(mActivity, R.string.cannot_connect_camera);
                break;
            }
        case CAMERA_DISABLED:
            {
                mCameraDisabled = true;
                CameraUtil.showErrorAndFinish(mActivity, R.string.camera_disabled);
                break;
            }
        case SET_PHOTO_UI_PARAMS:
            {
                setCameraParametersWhenIdle(UPDATE_PARAM_PREFERENCE);
                mUI.updateOnScreenIndicators(mParameters, mPreferenceGroup, mPreferences);
                break;
            }
        case SWITCH_TO_GCAM_MODULE:
            {
                mActivity.onModuleSelected(ModuleSwitcher.GCAM_MODULE_INDEX);
                break;
            }
        case ON_PREVIEW_STARTED:
            {
                onPreviewStarted();
                break;
            }
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case SETUP_PREVIEW:
            {
                setupPreview();
                break;
            }
        case CLEAR_SCREEN_DELAY:
            {
                mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
                break;
            }
        case FIRST_TIME_INIT:
            {
                initializeFirstTime();
                break;
            }
        case SET_CAMERA_PARAMETERS_WHEN_IDLE:
            {
                setCameraParametersWhenIdle(0);
                break;
            }
        case SHOW_TAP_TO_FOCUS_TOAST:
            {
                showTapToFocusToast();
                break;
            }
        case SWITCH_CAMERA:
            {
                switchCamera();
                break;
            }
        case SWITCH_CAMERA_START_ANIMATION:
            {
                // ((CameraScreenNail) mActivity.mCameraScreenNail).animateSwitchCamera();
                break;
            }
        case CAMERA_OPEN_DONE:
            {
                onCameraOpened();
                break;
            }
        case OPEN_CAMERA_FAIL:
            {
                mOpenCameraFail = true;
                CameraUtil.showErrorAndFinish(mActivity, R.string.cannot_connect_camera);
                break;
            }
        case CAMERA_DISABLED:
            {
                mCameraDisabled = true;
                CameraUtil.showErrorAndFinish(mActivity, R.string.camera_disabled);
                break;
            }
        case SET_PHOTO_UI_PARAMS:
            {
                setCameraParametersWhenIdle(UPDATE_PARAM_PREFERENCE);
                mUI.updateOnScreenIndicators(mParameters, mPreferenceGroup, mPreferences);
                break;
            }
        case SWITCH_TO_GCAM_MODULE:
            {
                mActivity.onModuleSelected(ModuleSwitcher.GCAM_MODULE_INDEX);
                break;
            }
        case ON_PREVIEW_STARTED:
            {
                onPreviewStarted();
                break;
            }
        case UPDATE_GESTURES_UI:
            {
                updateGesturesUI();
                break;
            }
    }
}
#end_block

#method_before
private void onPreviewStarted() {
    if (mCameraState == SNAPSHOT_IN_PROGRESS) {
        return;
    }
    mUI.hidePreviewCover();
    setCameraState(IDLE);
    mFocusManager.onPreviewStarted();
    startFaceDetection();
    locationFirstRun();
    mUI.enableShutter(true);
}
#method_after
private void onPreviewStarted() {
    if (mCameraState == SNAPSHOT_IN_PROGRESS) {
        return;
    }
    mFocusManager.onPreviewStarted();
    startFaceDetection();
    locationFirstRun();
    mUI.enableShutter(true);
}
#end_block

#method_before
@Override
public void onCameraMetaData(byte[] data, android.hardware.Camera camera) {
    int[] metadata = new int[3];
    if (data.length <= 12) {
        for (int i = 0; i < 3; i++) {
            metadata[i] = byteToInt((byte[]) data, i * 4);
        }
        if (metadata[2] == 1) {
            mAutoHdrEnable = true;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null)
                        mDrawAutoHDR.AutoHDR();
                }
            });
        } else {
            mAutoHdrEnable = false;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null)
                        mDrawAutoHDR.AutoHDR();
                }
            });
        }
    }
}
#method_after
@Override
public void onCameraMetaData(byte[] data, android.hardware.Camera camera) {
    int[] metadata = new int[3];
    if (data.length >= 12) {
        for (int i = 0; i < 3; i++) {
            metadata[i] = byteToInt((byte[]) data, i * 4);
        }
        if (metadata[2] == 1) {
            mAutoHdrEnable = true;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null)
                        mDrawAutoHDR.AutoHDR();
                }
            });
        } else {
            mAutoHdrEnable = false;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null)
                        mDrawAutoHDR.AutoHDR();
                }
            });
        }
    }
}
#end_block

#method_before
@Override
public void onPictureTaken(final byte[] jpegData, CameraProxy camera) {
    if (mCameraState != LONGSHOT) {
        mUI.enableShutter(true);
    }
    if (mPaused) {
        return;
    }
    if (mIsImageCaptureIntent) {
        stopPreview();
    } else if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
        mUI.showSwitcher();
        mUI.setSwipingEnabled(true);
    }
    mReceivedSnapNum = mReceivedSnapNum + 1;
    mJpegPictureCallbackTime = System.currentTimeMillis();
    if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
        Log.v(TAG, "JpegPictureCallback : in zslmode");
        mParameters = mCameraDevice.getParameters();
        if (CameraUtil.isBurstSupported(mParameters)) {
            mBurstSnapNum = mParameters.getInt("num-snaps-per-shutter");
        } else {
            mBurstSnapNum = 1;
        }
    }
    Log.v(TAG, "JpegPictureCallback: Received = " + mReceivedSnapNum + "Burst count = " + mBurstSnapNum);
    // raw picture callback.
    if (mPostViewPictureCallbackTime != 0) {
        mShutterToPictureDisplayedTime = mPostViewPictureCallbackTime - mShutterCallbackTime;
        mPictureDisplayedToJpegCallbackTime = mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
    } else {
        mShutterToPictureDisplayedTime = mRawPictureCallbackTime - mShutterCallbackTime;
        mPictureDisplayedToJpegCallbackTime = mJpegPictureCallbackTime - mRawPictureCallbackTime;
    }
    Log.v(TAG, "mPictureDisplayedToJpegCallbackTime = " + mPictureDisplayedToJpegCallbackTime + "ms");
    // Ensure focus indicator is hidden.
    mFocusManager.updateFocusUI();
    if (isLongshotDone()) {
        mCameraDevice.setLongshot(false);
    }
    boolean needRestartPreview = !mIsImageCaptureIntent && !mPreviewRestartSupport && (mCameraState != LONGSHOT) && (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL) && ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT));
    needRestartPreview |= (isLongshotDone() && !mFocusManager.isZslEnabled());
    boolean backCameraRestartPreviewOnPictureTaken = mApplicationContext.getResources().getBoolean(R.bool.back_camera_restart_preview_onPictureTaken);
    boolean frontCameraRestartPreviewOnPictureTaken = mApplicationContext.getResources().getBoolean(R.bool.front_camera_restart_preview_onPictureTaken);
    CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
    if ((info.facing == CameraInfo.CAMERA_FACING_BACK && backCameraRestartPreviewOnPictureTaken) || (info.facing == CameraInfo.CAMERA_FACING_FRONT && frontCameraRestartPreviewOnPictureTaken)) {
        needRestartPreview = true;
    }
    if (needRestartPreview) {
        setupPreview();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode()) || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
            mCameraDevice.cancelAutoFocus();
        }
    } else if (((mCameraState != LONGSHOT) && (mReceivedSnapNum == mBurstSnapNum)) || isLongshotDone()) {
        mUI.enableShutter(true);
        mFocusManager.resetTouchFocus();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode()) || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
            mCameraDevice.cancelAutoFocus();
        }
        mUI.resumeFaceDetection();
        if (!mIsImageCaptureIntent) {
            setCameraState(IDLE);
        }
        startFaceDetection();
    }
    mLastPhotoTakenWithRefocus = mRefocus;
    if (mRefocus) {
        final String[] NAMES = { "00.jpg", "01.jpg", "02.jpg", "03.jpg", "04.jpg", "DepthMapImage.y", "AllFocusImage.jpg" };
        try {
            FileOutputStream out = mActivity.openFileOutput(NAMES[mReceivedSnapNum - 1], Context.MODE_PRIVATE);
            out.write(jpegData, 0, jpegData.length);
            out.close();
        } catch (Exception e) {
        }
    }
    if (!mRefocus || (mRefocus && mReceivedSnapNum == 7)) {
        ExifInterface exif = Exif.getExif(jpegData);
        int orientation = Exif.getOrientation(exif);
        if (!mIsImageCaptureIntent) {
            // Burst snapshot. Generate new image name.
            if (mReceivedSnapNum > 1) {
                mNamedImages.nameNewImage(mCaptureStartTime, mRefocus);
            }
            // Calculate the width and the height of the jpeg.
            Size s = mParameters.getPictureSize();
            int width, height;
            if ((mJpegRotation + orientation) % 180 == 0) {
                width = s.width;
                height = s.height;
            } else {
                width = s.height;
                height = s.width;
            }
            String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
            if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
                // overwrite width and height if raw picture
                String pair = mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
                if (pair != null) {
                    int pos = pair.indexOf('x');
                    if (pos != -1) {
                        width = Integer.parseInt(pair.substring(0, pos));
                        height = Integer.parseInt(pair.substring(pos + 1));
                    }
                }
            }
            NamedEntity name = mNamedImages.getNextNameEntity();
            String title = (name == null) ? null : name.title;
            long date = (name == null) ? -1 : name.date;
            // Handle debug mode outputs
            if (mDebugUri != null) {
                // If using a debug uri, save jpeg there.
                saveToDebugUri(jpegData);
                // Adjust the title of the debug image shown in mediastore.
                if (title != null) {
                    title = DEBUG_IMAGE_PREFIX + title;
                }
            }
            if (title == null) {
                Log.e(TAG, "Unbalanced name/data pair");
            } else {
                if (date == -1) {
                    date = mCaptureStartTime;
                }
                if (mHeading >= 0) {
                    // heading direction has been updated by the sensor.
                    ExifTag directionRefTag = exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION_REF, ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
                    ExifTag directionTag = exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION, new Rational(mHeading, 1));
                    exif.setTag(directionRefTag);
                    exif.setTag(directionTag);
                }
                String mPictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
                mActivity.getMediaSaveService().addImage(jpegData, title, date, mLocation, width, height, orientation, exif, mOnMediaSavedListener, mContentResolver, mPictureFormat);
                if (mRefocus && mReceivedSnapNum == 7) {
                    mUI.showRefocusToast(mRefocus);
                }
            }
            // Animate capture with real jpeg data instead of a preview frame.
            if ((mCameraState != LONGSHOT) || isLongshotDone()) {
                Size pic_size = mParameters.getPictureSize();
                if ((pic_size.width <= 352) && (pic_size.height <= 288)) {
                    // Downsample by 2 for CIF & below
                    mUI.setDownFactor(2);
                } else {
                    mUI.setDownFactor(4);
                }
                if (mAnimateCapture) {
                    mUI.animateCapture(jpegData, orientation, mMirror);
                }
            } else {
                // In long shot mode, we do not want to update the preview thumbnail
                // for each snapshot, instead, keep the last jpeg data and orientation,
                // use it to show the final one at the end of long shot.
                mLastJpegData = jpegData;
                mLastJpegOrientation = orientation;
            }
        } else {
            mJpegImageData = jpegData;
            if (!mQuickCapture) {
                mUI.showCapturedImageForReview(jpegData, orientation, mMirror);
            } else {
                onCaptureDone();
            }
        }
        // Check this in advance of each shot so we don't add to shutter
        // latency. It's true that someone else could write to the SD card in
        // the mean time and fill it, but that could have happened between the
        // shutter press and saving the JPEG too.
        mActivity.updateStorageSpaceAndHint();
        mUI.updateRemainingPhotos(--mRemainingPhotos);
        long now = System.currentTimeMillis();
        mJpegCallbackFinishTime = now - mJpegPictureCallbackTime;
        Log.v(TAG, "mJpegCallbackFinishTime = " + mJpegCallbackFinishTime + "ms");
        if (mReceivedSnapNum == mBurstSnapNum) {
            mJpegPictureCallbackTime = 0;
        }
        if (isLongshotDone()) {
            mLongshotSnapNum = 0;
        }
        if (mHiston && (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL)) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mGraphView != null) {
                        mGraphView.setVisibility(View.VISIBLE);
                        mGraphView.PreviewChanged();
                    }
                }
            });
        }
        if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL && mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum && !mIsImageCaptureIntent) {
            cancelAutoFocus();
        }
    }
}
#method_after
@Override
public void onPictureTaken(final byte[] jpegData, CameraProxy camera) {
    if (mCameraState != LONGSHOT) {
        mUI.enableShutter(true);
    }
    if (mPaused) {
        return;
    }
    if (mIsImageCaptureIntent) {
        stopPreview();
    } else if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
        mUI.showSwitcher();
        mUI.setSwipingEnabled(true);
    }
    mReceivedSnapNum = mReceivedSnapNum + 1;
    mJpegPictureCallbackTime = System.currentTimeMillis();
    if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
        Log.v(TAG, "JpegPictureCallback : in zslmode");
        mParameters = mCameraDevice.getParameters();
        if (CameraUtil.isBurstSupported(mParameters)) {
            mBurstSnapNum = mParameters.getInt("num-snaps-per-shutter");
        } else {
            mBurstSnapNum = 1;
        }
    }
    Log.v(TAG, "JpegPictureCallback: Received = " + mReceivedSnapNum + "Burst count = " + mBurstSnapNum);
    // raw picture callback.
    if (mPostViewPictureCallbackTime != 0) {
        mShutterToPictureDisplayedTime = mPostViewPictureCallbackTime - mShutterCallbackTime;
        mPictureDisplayedToJpegCallbackTime = mJpegPictureCallbackTime - mPostViewPictureCallbackTime;
    } else {
        mShutterToPictureDisplayedTime = mRawPictureCallbackTime - mShutterCallbackTime;
        mPictureDisplayedToJpegCallbackTime = mJpegPictureCallbackTime - mRawPictureCallbackTime;
    }
    Log.v(TAG, "mPictureDisplayedToJpegCallbackTime = " + mPictureDisplayedToJpegCallbackTime + "ms");
    // Ensure focus indicator is hidden.
    mFocusManager.updateFocusUI();
    if (isLongshotDone()) {
        mCameraDevice.setLongshot(false);
    }
    boolean needRestartPreview = !mIsImageCaptureIntent && !mPreviewRestartSupport && (mCameraState != LONGSHOT) && (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL) && ((mReceivedSnapNum == mBurstSnapNum) && (mCameraState != LONGSHOT));
    needRestartPreview |= (isLongshotDone() && !mFocusManager.isZslEnabled());
    needRestartPreview |= ((mReceivedSnapNum == mBurstSnapNum) && !mFocusManager.isZslEnabled() && CameraUtil.SCENE_MODE_HDR.equals(mSceneMode));
    boolean backCameraRestartPreviewOnPictureTaken = mApplicationContext.getResources().getBoolean(R.bool.back_camera_restart_preview_onPictureTaken);
    boolean frontCameraRestartPreviewOnPictureTaken = mApplicationContext.getResources().getBoolean(R.bool.front_camera_restart_preview_onPictureTaken);
    CameraInfo info = CameraHolder.instance().getCameraInfo()[mCameraId];
    if ((info.facing == CameraInfo.CAMERA_FACING_BACK && backCameraRestartPreviewOnPictureTaken) || (info.facing == CameraInfo.CAMERA_FACING_FRONT && frontCameraRestartPreviewOnPictureTaken)) {
        needRestartPreview = true;
    }
    if (needRestartPreview) {
        setupPreview();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode()) || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
            mCameraDevice.cancelAutoFocus();
        }
    } else if (((mCameraState != LONGSHOT) && (mReceivedSnapNum == mBurstSnapNum)) || isLongshotDone()) {
        mUI.enableShutter(true);
        mFocusManager.resetTouchFocus();
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode()) || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
            mCameraDevice.cancelAutoFocus();
        }
        mUI.resumeFaceDetection();
        if (!mIsImageCaptureIntent) {
            setCameraState(IDLE);
        }
        startFaceDetection();
    }
    mLastPhotoTakenWithRefocus = mRefocus;
    if (mRefocus) {
        final String[] NAMES = { "00.jpg", "01.jpg", "02.jpg", "03.jpg", "04.jpg", "DepthMapImage.y", "AllFocusImage.jpg" };
        try {
            FileOutputStream out = mActivity.openFileOutput(NAMES[mReceivedSnapNum - 1], Context.MODE_PRIVATE);
            out.write(jpegData, 0, jpegData.length);
            out.close();
        } catch (Exception e) {
        }
    }
    if (!mRefocus || (mRefocus && mReceivedSnapNum == 7)) {
        ExifInterface exif = Exif.getExif(jpegData);
        int orientation = Exif.getOrientation(exif);
        if (!mIsImageCaptureIntent) {
            // Burst snapshot. Generate new image name.
            if (mReceivedSnapNum > 1) {
                mNamedImages.nameNewImage(mCaptureStartTime, mRefocus);
            }
            // Calculate the width and the height of the jpeg.
            Size s = mParameters.getPictureSize();
            int width, height;
            if ((mJpegRotation + orientation) % 180 == 0) {
                width = s.width;
                height = s.height;
            } else {
                width = s.height;
                height = s.width;
            }
            String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
            if (pictureFormat != null && !pictureFormat.equalsIgnoreCase(PIXEL_FORMAT_JPEG)) {
                // overwrite width and height if raw picture
                String pair = mParameters.get(KEY_QC_RAW_PICUTRE_SIZE);
                if (pair != null) {
                    int pos = pair.indexOf('x');
                    if (pos != -1) {
                        width = Integer.parseInt(pair.substring(0, pos));
                        height = Integer.parseInt(pair.substring(pos + 1));
                    }
                }
            }
            NamedEntity name = mNamedImages.getNextNameEntity();
            String title = (name == null) ? null : name.title;
            long date = (name == null) ? -1 : name.date;
            // Handle debug mode outputs
            if (mDebugUri != null) {
                // If using a debug uri, save jpeg there.
                saveToDebugUri(jpegData);
                // Adjust the title of the debug image shown in mediastore.
                if (title != null) {
                    title = DEBUG_IMAGE_PREFIX + title;
                }
            }
            if (title == null) {
                Log.e(TAG, "Unbalanced name/data pair");
            } else {
                if (date == -1) {
                    date = mCaptureStartTime;
                }
                if (mHeading >= 0) {
                    // heading direction has been updated by the sensor.
                    ExifTag directionRefTag = exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION_REF, ExifInterface.GpsTrackRef.MAGNETIC_DIRECTION);
                    ExifTag directionTag = exif.buildTag(ExifInterface.TAG_GPS_IMG_DIRECTION, new Rational(mHeading, 1));
                    exif.setTag(directionRefTag);
                    exif.setTag(directionTag);
                }
                String mPictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
                mActivity.getMediaSaveService().addImage(jpegData, title, date, mLocation, width, height, orientation, exif, mOnMediaSavedListener, mContentResolver, mPictureFormat);
                if (mRefocus && mReceivedSnapNum == 7) {
                    mUI.showRefocusToast(mRefocus);
                }
            }
            // Animate capture with real jpeg data instead of a preview frame.
            if ((mCameraState != LONGSHOT) || isLongshotDone()) {
                Size pic_size = mParameters.getPictureSize();
                if ((pic_size.width <= 352) && (pic_size.height <= 288)) {
                    // Downsample by 2 for CIF & below
                    mUI.setDownFactor(2);
                } else {
                    mUI.setDownFactor(4);
                }
                if (mAnimateCapture) {
                    mUI.animateCapture(jpegData, orientation, mMirror);
                }
            } else {
                // In long shot mode, we do not want to update the preview thumbnail
                // for each snapshot, instead, keep the last jpeg data and orientation,
                // use it to show the final one at the end of long shot.
                mLastJpegData = jpegData;
                mLastJpegOrientation = orientation;
            }
        } else {
            mJpegImageData = jpegData;
            if (!mQuickCapture) {
                mUI.showCapturedImageForReview(jpegData, orientation, mMirror);
            } else {
                onCaptureDone();
            }
        }
        // Check this in advance of each shot so we don't add to shutter
        // latency. It's true that someone else could write to the SD card in
        // the mean time and fill it, but that could have happened between the
        // shutter press and saving the JPEG too.
        mActivity.updateStorageSpaceAndHint();
        mUI.updateRemainingPhotos(--mRemainingPhotos);
        long now = System.currentTimeMillis();
        mJpegCallbackFinishTime = now - mJpegPictureCallbackTime;
        Log.v(TAG, "mJpegCallbackFinishTime = " + mJpegCallbackFinishTime + "ms");
        if (mReceivedSnapNum == mBurstSnapNum) {
            mJpegPictureCallbackTime = 0;
        }
        if (isLongshotDone()) {
            mLongshotSnapNum = 0;
        }
        if (mHiston && (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL)) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mGraphView != null) {
                        mGraphView.setVisibility(View.VISIBLE);
                        mGraphView.PreviewChanged();
                    }
                }
            });
        }
        if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL && mCameraState != LONGSHOT && mReceivedSnapNum == mBurstSnapNum && !mIsImageCaptureIntent) {
            cancelAutoFocus();
        }
    }
}
#end_block

#method_before
private void setCameraState(int state) {
    mCameraState = state;
    switch(state) {
        case PhotoController.PREVIEW_STOPPED:
        case PhotoController.SNAPSHOT_IN_PROGRESS:
        case PhotoController.LONGSHOT:
        case PhotoController.SWITCHING_CAMERA:
            mUI.enableGestures(false);
            break;
        case PhotoController.IDLE:
            mUI.enableGestures(true);
            break;
    }
}
#method_after
private void setCameraState(int state) {
    mCameraState = state;
    /*
         * If the current thread is UI thread, update gestures UI directly.
         * If the current thread is background thread, post a handler message
         * to update gestures UI.
         */
    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
        updateGesturesUI();
    } else {
        mHandler.sendEmptyMessage(UPDATE_GESTURES_UI);
    }
}
#end_block

#method_before
@Override
public boolean capture() {
    // is full then ignore.
    if (mCameraDevice == null || mCameraState == SNAPSHOT_IN_PROGRESS || mCameraState == SWITCHING_CAMERA || mActivity.getMediaSaveService() == null || mActivity.getMediaSaveService().isQueueFull()) {
        return false;
    }
    mCaptureStartTime = System.currentTimeMillis();
    mPostViewPictureCallbackTime = 0;
    mJpegImageData = null;
    final boolean animateBefore = (mSceneMode == CameraUtil.SCENE_MODE_HDR);
    if (mHiston) {
        if (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
            mHiston = false;
            mCameraDevice.setHistogramMode(null);
        }
        mActivity.runOnUiThread(new Runnable() {

            public void run() {
                if (mGraphView != null)
                    mGraphView.setVisibility(View.INVISIBLE);
            }
        });
    }
    if (animateBefore) {
        animateAfterShutter();
    }
    if (mCameraState == LONGSHOT) {
        mLongshotSnapNum = 0;
        mCameraDevice.setLongshot(true);
    }
    // Set rotation and gps data.
    int orientation = mOrientation;
    mJpegRotation = CameraUtil.getJpegRotation(mCameraId, orientation);
    String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
    Location loc = getLocationAccordPictureFormat(pictureFormat);
    synchronized (mCameraDevice) {
        mParameters.setRotation(mJpegRotation);
        CameraUtil.setGpsParameters(mParameters, loc);
        if (mRefocus) {
            mParameters.set(CameraSettings.KEY_QC_LEGACY_BURST, CameraSettings.KEY_QC_RE_FOCUS_COUNT);
        } else {
            mParameters.remove(CameraSettings.KEY_QC_LEGACY_BURST);
        }
        mCameraDevice.setParameters(mParameters);
        mParameters = mCameraDevice.getParameters();
    }
    // LGE G4: Disable hdr if luminance is low and flash get's used
    if (CameraUtil.isLowLuminance(mParameters)) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE, "0");
        mCameraDevice.setParameters(mParameters);
        mParameters = mCameraDevice.getParameters();
    }
    if (CameraUtil.isBurstSupported(mParameters)) {
        mBurstSnapNum = mParameters.getInt("num-snaps-per-shutter");
    } else {
        mBurstSnapNum = 1;
    }
    mReceivedSnapNum = 0;
    mPreviewRestartSupport = SystemProperties.getBoolean(PERSIST_PREVIEW_RESTART, false);
    mPreviewRestartSupport &= CameraSettings.isInternalPreviewSupported(mParameters);
    mPreviewRestartSupport &= (mBurstSnapNum == 1);
    mPreviewRestartSupport &= PIXEL_FORMAT_JPEG.equalsIgnoreCase(pictureFormat);
    // multi-second HDR photo. For longshot, no need to disable.
    if (mCameraState != LONGSHOT) {
        mUI.enableShutter(false);
    }
    if (mCameraState == LONGSHOT) {
        if (mLongshotSave) {
            mCameraDevice.takePicture(mHandler, new LongshotShutterCallback(), mRawPictureCallback, mPostViewPictureCallback, new LongshotPictureCallback(loc));
        } else {
            mCameraDevice.takePicture(mHandler, new LongshotShutterCallback(), mRawPictureCallback, mPostViewPictureCallback, new JpegPictureCallback(loc));
        }
    } else {
        mCameraDevice.enableShutterSound(!mRefocus);
        mCameraDevice.takePicture(mHandler, new ShutterCallback(!animateBefore), mRawPictureCallback, mPostViewPictureCallback, new JpegPictureCallback(loc));
        setCameraState(SNAPSHOT_IN_PROGRESS);
        // LGE G4: Preview needs to be restarted when flash got used while luminance is low
        if (CameraUtil.isLowLuminance(mParameters)) {
            setupPreview();
        }
    }
    mNamedImages.nameNewImage(mCaptureStartTime, mRefocus);
    if (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
        mFaceDetectionStarted = false;
    }
    UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA, UsageStatistics.ACTION_CAPTURE_DONE, "Photo", 0, UsageStatistics.hashFileName(mNamedImages.mQueue.lastElement().title + ".jpg"));
    return true;
}
#method_after
@Override
public boolean capture() {
    // is full then ignore.
    if (mCameraDevice == null || mCameraState == SNAPSHOT_IN_PROGRESS || mCameraState == SWITCHING_CAMERA || mActivity.getMediaSaveService() == null || mActivity.getMediaSaveService().isQueueFull()) {
        return false;
    }
    mCaptureStartTime = System.currentTimeMillis();
    mPostViewPictureCallbackTime = 0;
    mJpegImageData = null;
    final boolean animateBefore = (mSceneMode == CameraUtil.SCENE_MODE_HDR);
    if (mHiston) {
        if (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
            mHiston = false;
            mCameraDevice.setHistogramMode(null);
        }
        mActivity.runOnUiThread(new Runnable() {

            public void run() {
                if (mGraphView != null)
                    mGraphView.setVisibility(View.INVISIBLE);
            }
        });
    }
    if (animateBefore) {
        animateAfterShutter();
    }
    if (mCameraState == LONGSHOT) {
        mLongshotSnapNum = 0;
        mCameraDevice.setLongshot(true);
    }
    // Set rotation and gps data.
    int orientation = mOrientation;
    mJpegRotation = CameraUtil.getJpegRotation(mCameraId, orientation);
    String pictureFormat = mParameters.get(KEY_PICTURE_FORMAT);
    Location loc = getLocationAccordPictureFormat(pictureFormat);
    synchronized (mCameraDevice) {
        mParameters.setRotation(mJpegRotation);
        CameraUtil.setGpsParameters(mParameters, loc);
        if (mRefocus) {
            mParameters.set(CameraSettings.KEY_QC_LEGACY_BURST, CameraSettings.KEY_QC_RE_FOCUS_COUNT);
        } else {
            mParameters.remove(CameraSettings.KEY_QC_LEGACY_BURST);
        }
        // Unlock AE&AWB, if they continue
        // to be locked during snapshot, then
        // side effects could be triggered w.r.t.
        // flash.
        mFocusManager.setAeAwbLock(false);
        setAutoExposureLockIfSupported();
        setAutoWhiteBalanceLockIfSupported();
        mCameraDevice.setParameters(mParameters);
        mParameters = mCameraDevice.getParameters();
    }
    // LGE G4: Disable hdr if luminance is low and flash get's used
    if (CameraUtil.isLowLuminance(mParameters)) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE, "0");
        mCameraDevice.setParameters(mParameters);
        mParameters = mCameraDevice.getParameters();
    }
    if (CameraUtil.isBurstSupported(mParameters)) {
        mBurstSnapNum = mParameters.getInt("num-snaps-per-shutter");
    } else {
        mBurstSnapNum = 1;
    }
    mReceivedSnapNum = 0;
    mPreviewRestartSupport = SystemProperties.getBoolean(PERSIST_PREVIEW_RESTART, false);
    mPreviewRestartSupport &= CameraSettings.isInternalPreviewSupported(mParameters);
    mPreviewRestartSupport &= (mBurstSnapNum == 1);
    mPreviewRestartSupport &= PIXEL_FORMAT_JPEG.equalsIgnoreCase(pictureFormat);
    // multi-second HDR photo. For longshot, no need to disable.
    if (mCameraState != LONGSHOT) {
        mUI.enableShutter(false);
    }
    if (mCameraState == LONGSHOT) {
        if (mLongshotSave) {
            mCameraDevice.takePicture(mHandler, new LongshotShutterCallback(), mRawPictureCallback, mPostViewPictureCallback, new LongshotPictureCallback(loc));
        } else {
            mCameraDevice.takePicture(mHandler, new LongshotShutterCallback(), mRawPictureCallback, mPostViewPictureCallback, new JpegPictureCallback(loc));
        }
    } else {
        mCameraDevice.enableShutterSound(!mRefocus);
        mCameraDevice.takePicture(mHandler, new ShutterCallback(!animateBefore), mRawPictureCallback, mPostViewPictureCallback, new JpegPictureCallback(loc));
        setCameraState(SNAPSHOT_IN_PROGRESS);
        // LGE G4: Preview needs to be restarted when flash got used while luminance is low
        if (CameraUtil.isLowLuminance(mParameters)) {
            setupPreview();
        }
    }
    mNamedImages.nameNewImage(mCaptureStartTime, mRefocus);
    if (mSnapshotMode != CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
        mFaceDetectionStarted = false;
    }
    UsageStatistics.onEvent(UsageStatistics.COMPONENT_CAMERA, UsageStatistics.ACTION_CAPTURE_DONE, "Photo", 0, UsageStatistics.hashFileName(mNamedImages.mQueue.lastElement().title + ".jpg"));
    return true;
}
#end_block

#method_before
private void updateCameraSettings() {
    String sceneMode = null;
    String flashMode = null;
    String redeyeReduction = null;
    String aeBracketing = null;
    String focusMode = null;
    String colorEffect = null;
    String exposureCompensation = null;
    String touchAfAec = null;
    boolean disableLongShot = false;
    String ubiFocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
    String continuousShotOn = mActivity.getString(R.string.setting_on_value);
    String reFocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
    String chromaFlashOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
    String optiZoomOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
    String fssrOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
    String truPortraitOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
    String multiTouchFocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
    String optiZoom = mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
    String chromaFlash = mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
    String ubiFocus = mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
    String fssr = mParameters.get(CameraSettings.KEY_QC_FSSR);
    String truePortrait = mParameters.get(CameraSettings.KEY_QC_TP);
    String multiTouchFocus = mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
    String continuousShot = mParameters.get("long-shot");
    if (mManual3AEnabled > 0) {
        disableLongShot = true;
    }
    if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
    } else {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, null);
    }
    String reFocus = mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
    if (mFocusManager.isZslEnabled()) {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
    } else {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, null);
    }
    if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn)) || (fssr != null && fssr.equals(fssrOn)) || (truePortrait != null && truePortrait.equals(truPortraitOn))) {
        mSceneMode = sceneMode = Parameters.SCENE_MODE_AUTO;
        flashMode = Parameters.FLASH_MODE_OFF;
        focusMode = Parameters.FOCUS_MODE_INFINITY;
        redeyeReduction = mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
        aeBracketing = mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
        colorEffect = mActivity.getString(R.string.pref_camera_coloreffect_default);
        exposureCompensation = CameraSettings.EXPOSURE_DEFAULT_VALUE;
        overrideCameraSettings(flashMode, null, focusMode, exposureCompensation, touchAfAec, null, null, null, null, colorEffect, sceneMode, redeyeReduction, aeBracketing);
        disableLongShot = true;
        RotateTextToast.makeText(mActivity, R.string.advanced_capture_disable_continuous_shot, Toast.LENGTH_LONG).show();
    }
    // read settings from preferences so we retain user preferences.
    if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
        flashMode = mParameters.getFlashMode();
        String whiteBalance = Parameters.WHITE_BALANCE_AUTO;
        focusMode = mFocusManager.getFocusMode();
        colorEffect = mParameters.getColorEffect();
        exposureCompensation = Integer.toString(mParameters.getExposureCompensation());
        touchAfAec = mCurrTouchAfAec;
        overrideCameraSettings(flashMode, whiteBalance, focusMode, exposureCompensation, touchAfAec, mParameters.getAutoExposure(), getSaturationSafe(), getContrastSafe(), getSharpnessSafe(), colorEffect, sceneMode, redeyeReduction, aeBracketing);
        if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
            disableLongShot = true;
        }
    } else if (mFocusManager.isZslEnabled()) {
        focusMode = mParameters.getFocusMode();
        overrideCameraSettings(flashMode, null, focusMode, exposureCompensation, touchAfAec, null, null, null, null, colorEffect, sceneMode, redeyeReduction, aeBracketing);
    } else {
        if (mManual3AEnabled > 0) {
            updateCommonManual3ASettings();
        } else {
            overrideCameraSettings(flashMode, null, focusMode, exposureCompensation, touchAfAec, null, null, null, null, colorEffect, sceneMode, redeyeReduction, aeBracketing);
        }
    }
    /* Disable focus if aebracket is ON */
    String aeBracket = mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
    if (aeBracket != null && !aeBracket.equalsIgnoreCase("off")) {
        String fMode = Parameters.FLASH_MODE_OFF;
        mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE, fMode);
        mParameters.setFlashMode(fMode);
    }
    if (disableLongShot) {
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT, mActivity.getString(R.string.setting_off_value));
    } else {
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT, null);
    }
}
#method_after
private void updateCameraSettings() {
    String sceneMode = null;
    String flashMode = null;
    String redeyeReduction = null;
    String aeBracketing = null;
    String focusMode = null;
    String colorEffect = null;
    String exposureCompensation = null;
    String touchAfAec = null;
    boolean disableLongShot = false;
    String ubiFocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on);
    String continuousShotOn = mActivity.getString(R.string.setting_on_value);
    String reFocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
    String chromaFlashOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on);
    String optiZoomOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on);
    String fssrOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on);
    String truPortraitOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on);
    String multiTouchFocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on);
    String optiZoom = mParameters.get(CameraSettings.KEY_QC_OPTI_ZOOM);
    String chromaFlash = mParameters.get(CameraSettings.KEY_QC_CHROMA_FLASH);
    String ubiFocus = mParameters.get(CameraSettings.KEY_QC_AF_BRACKETING);
    String fssr = mParameters.get(CameraSettings.KEY_QC_FSSR);
    String truePortrait = mParameters.get(CameraSettings.KEY_QC_TP);
    String multiTouchFocus = mParameters.get(CameraSettings.KEY_QC_MULTI_TOUCH_FOCUS);
    String continuousShot = mParameters.get("long-shot");
    if (mManual3AEnabled > 0) {
        disableLongShot = true;
    }
    if ((continuousShot != null) && continuousShot.equals(continuousShotOn)) {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
    } else {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, null);
    }
    String reFocus = mParameters.get(CameraSettings.KEY_QC_RE_FOCUS);
    if (mFocusManager.isZslEnabled()) {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
    } else {
        mUI.overrideSettings(CameraSettings.KEY_PICTURE_FORMAT, null);
    }
    if ((multiTouchFocus != null && multiTouchFocus.equals(multiTouchFocusOn)) || (chromaFlash != null && chromaFlash.equals(chromaFlashOn)) || (optiZoom != null && optiZoom.equals(optiZoomOn)) || (fssr != null && fssr.equals(fssrOn)) || (truePortrait != null && truePortrait.equals(truPortraitOn))) {
        mSceneMode = sceneMode = Parameters.SCENE_MODE_AUTO;
        flashMode = Parameters.FLASH_MODE_OFF;
        focusMode = Parameters.FOCUS_MODE_INFINITY;
        redeyeReduction = mActivity.getString(R.string.pref_camera_redeyereduction_entry_disable);
        aeBracketing = mActivity.getString(R.string.pref_camera_ae_bracket_hdr_entry_off);
        colorEffect = mActivity.getString(R.string.pref_camera_coloreffect_default);
        exposureCompensation = CameraSettings.EXPOSURE_DEFAULT_VALUE;
        overrideCameraSettings(flashMode, null, focusMode, exposureCompensation, touchAfAec, null, null, null, null, colorEffect, sceneMode, redeyeReduction, aeBracketing);
        disableLongShot = true;
        RotateTextToast.makeText(mActivity, R.string.advanced_capture_disable_continuous_shot, Toast.LENGTH_LONG).show();
    }
    // read settings from preferences so we retain user preferences.
    if (!Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
        flashMode = mParameters.FLASH_MODE_OFF;
        String whiteBalance = Parameters.WHITE_BALANCE_AUTO;
        focusMode = mFocusManager.getFocusMode();
        colorEffect = mParameters.getColorEffect();
        exposureCompensation = Integer.toString(mParameters.getExposureCompensation());
        touchAfAec = mCurrTouchAfAec;
        overrideCameraSettings(flashMode, whiteBalance, focusMode, exposureCompensation, touchAfAec, mParameters.getAutoExposure(), getSaturationSafe(), getContrastSafe(), getSharpnessSafe(), colorEffect, sceneMode, redeyeReduction, aeBracketing);
        if (CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
            disableLongShot = true;
        }
    } else if (mFocusManager.isZslEnabled()) {
        focusMode = mParameters.getFocusMode();
        overrideCameraSettings(flashMode, null, focusMode, exposureCompensation, touchAfAec, null, null, null, null, colorEffect, sceneMode, redeyeReduction, aeBracketing);
    } else {
        if (mManual3AEnabled > 0) {
            updateCommonManual3ASettings();
        } else {
            overrideCameraSettings(flashMode, null, focusMode, exposureCompensation, touchAfAec, null, null, null, null, colorEffect, sceneMode, redeyeReduction, aeBracketing);
        }
    }
    /* Disable focus if aebracket is ON */
    String aeBracket = mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
    if (aeBracket != null && !aeBracket.equalsIgnoreCase("off")) {
        String fMode = Parameters.FLASH_MODE_OFF;
        mUI.overrideSettings(CameraSettings.KEY_FLASH_MODE, fMode);
        mParameters.setFlashMode(fMode);
    }
    if (disableLongShot) {
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT, mActivity.getString(R.string.setting_off_value));
    } else {
        mUI.overrideSettings(CameraSettings.KEY_LONGSHOT, null);
    }
}
#end_block

#method_before
@Override
public void onShutterButtonFocus(boolean pressed) {
    if (mCameraDevice == null || mPaused || mUI.collapseCameraControls() || (mCameraState == SNAPSHOT_IN_PROGRESS) || (mCameraState == PREVIEW_STOPPED)) {
        Log.v(TAG, "onShutterButtonFocus error case mCameraState = " + mCameraState + "mCameraDevice = " + mCameraDevice + "mPaused =" + mPaused);
        return;
    }
    synchronized (mCameraDevice) {
        if (mCameraState == LONGSHOT) {
            mLongshotActive = false;
            mUI.enableShutter(false);
        }
    }
    // Do not do focus if there is not enough storage.
    if (pressed && !canTakePicture())
        return;
    if (pressed) {
        mFocusManager.onShutterDown();
    } else {
        // i.e. lock the focus during countdown.
        if (!mUI.isCountingDown()) {
            mFocusManager.onShutterUp();
        }
    }
}
#method_after
@Override
public void onShutterButtonFocus(boolean pressed) {
    if (mCameraDevice == null || mPaused || mUI.collapseCameraControls() || (mCameraState == SNAPSHOT_IN_PROGRESS) || (mCameraState == PREVIEW_STOPPED) || (null == mFocusManager)) {
        Log.v(TAG, "onShutterButtonFocus error case mCameraState = " + mCameraState + "mCameraDevice = " + mCameraDevice + "mPaused =" + mPaused);
        return;
    }
    synchronized (mCameraDevice) {
        if (mCameraState == LONGSHOT) {
            mLongshotActive = false;
            mUI.enableShutter(false);
        }
    }
    // Do not do focus if there is not enough storage.
    if (pressed && !canTakePicture())
        return;
    if (pressed) {
        mFocusManager.onShutterDown();
    } else {
        // i.e. lock the focus during countdown.
        if (!mUI.isCountingDown()) {
            mFocusManager.onShutterUp();
        }
    }
}
#end_block

#method_before
@Override
public synchronized void onShutterButtonClick() {
    if (mPaused || mShutterPressing || mUI.collapseCameraControls() || (mCameraState == SWITCHING_CAMERA) || (mCameraState == PREVIEW_STOPPED))
        return;
    mShutterPressing = true;
    // Do not take the picture if there is not enough storage.
    if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
        Log.i(TAG, "Not enough space or storage not ready. remaining=" + mActivity.getStorageSpaceBytes());
        mShutterPressing = false;
        return;
    }
    Log.v(TAG, "onShutterButtonClick: mCameraState=" + mCameraState);
    if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
        mUI.hideSwitcher();
        mUI.setSwipingEnabled(false);
    }
    // Need to disable focus for ZSL mode
    if (mFocusManager != null) {
        if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
            mFocusManager.setZslEnable(true);
        } else {
            mFocusManager.setZslEnable(false);
        }
    }
    // focus callback arrives.
    if ((((mFocusManager != null) && mFocusManager.isFocusingSnapOnFinish()) || mCameraState == SNAPSHOT_IN_PROGRESS) && !mIsImageCaptureIntent) {
        mSnapshotOnIdle = true;
        mShutterPressing = false;
        return;
    }
    String timer = mPreferences.getString(CameraSettings.KEY_TIMER, mActivity.getString(R.string.pref_camera_timer_default));
    boolean playSound = mPreferences.getString(CameraSettings.KEY_TIMER_SOUND_EFFECTS, mActivity.getString(R.string.pref_camera_timer_sound_default)).equals(mActivity.getString(R.string.setting_on_value));
    int seconds = Integer.parseInt(timer);
    // finished. If not, cancel the previous countdown and start a new one.
    if (mUI.isCountingDown()) {
        mUI.cancelCountDown();
    }
    if (seconds > 0) {
        String zsl = mPreferences.getString(CameraSettings.KEY_ZSL, mActivity.getString(R.string.pref_camera_zsl_default));
        mUI.overrideSettings(CameraSettings.KEY_ZSL, zsl);
        mUI.startCountDown(seconds, playSound);
    } else {
        mSnapshotOnIdle = false;
        mFocusManager.doSnap();
    }
    mShutterPressing = false;
}
#method_after
@Override
public synchronized void onShutterButtonClick() {
    if (mPaused || mShutterPressing || mUI.collapseCameraControls() || (mCameraState == SWITCHING_CAMERA) || (mCameraState == PREVIEW_STOPPED) || (null == mFocusManager) || (null == mUI.getSurfaceHolder()))
        return;
    mShutterPressing = true;
    // Do not take the picture if there is not enough storage.
    if (mActivity.getStorageSpaceBytes() <= Storage.LOW_STORAGE_THRESHOLD_BYTES) {
        Log.i(TAG, "Not enough space or storage not ready. remaining=" + mActivity.getStorageSpaceBytes());
        mShutterPressing = false;
        return;
    }
    Log.v(TAG, "onShutterButtonClick: mCameraState=" + mCameraState);
    if (mSceneMode == CameraUtil.SCENE_MODE_HDR) {
        mUI.hideSwitcher();
        mUI.setSwipingEnabled(false);
    }
    // Need to disable focus for ZSL mode
    if (mFocusManager != null) {
        if (mSnapshotMode == CameraInfo.CAMERA_SUPPORT_MODE_ZSL) {
            mFocusManager.setZslEnable(true);
        } else {
            mFocusManager.setZslEnable(false);
        }
    }
    // focus callback arrives.
    if ((((mFocusManager != null) && mFocusManager.isFocusingSnapOnFinish()) || mCameraState == SNAPSHOT_IN_PROGRESS) && !mIsImageCaptureIntent) {
        mSnapshotOnIdle = true;
        mShutterPressing = false;
        return;
    }
    String timer = mPreferences.getString(CameraSettings.KEY_TIMER, mActivity.getString(R.string.pref_camera_timer_default));
    boolean playSound = mPreferences.getString(CameraSettings.KEY_TIMER_SOUND_EFFECTS, mActivity.getString(R.string.pref_camera_timer_sound_default)).equals(mActivity.getString(R.string.setting_on_value));
    int seconds = Integer.parseInt(timer);
    // finished. If not, cancel the previous countdown and start a new one.
    if (mUI.isCountingDown()) {
        mUI.cancelCountDown();
    }
    if (seconds > 0) {
        String zsl = mPreferences.getString(CameraSettings.KEY_ZSL, mActivity.getString(R.string.pref_camera_zsl_default));
        mUI.overrideSettings(CameraSettings.KEY_ZSL, zsl);
        mUI.startCountDown(seconds, playSound);
    } else {
        mSnapshotOnIdle = false;
        mFocusManager.doSnap();
    }
    mShutterPressing = false;
}
#end_block

#method_before
private void startPreview() {
    if (mPaused || mCameraDevice == null || mParameters == null) {
        return;
    }
    synchronized (mCameraDevice) {
        SurfaceHolder sh = null;
        Log.v(TAG, "startPreview: SurfaceHolder (MDP path)");
        if (mUI != null) {
            sh = mUI.getSurfaceHolder();
        }
        // Let UI set its expected aspect ratio
        mCameraDevice.setPreviewDisplay(sh);
    }
    if (!mCameraPreviewParamsReady) {
        Log.w(TAG, "startPreview: parameters for preview are not ready.");
        return;
    }
    mErrorCallback.setActivity(mActivity);
    mCameraDevice.setErrorCallback(mErrorCallback);
    // Reset camera state after taking a picture
    if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
        setCameraState(IDLE);
    }
    // Preview needs to be stopped when changing resolution
    if (mRestartPreview && mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
        stopPreview();
        mRestartPreview = false;
    }
    if (mFocusManager == null)
        initializeFocusManager();
    if (!mSnapshotOnIdle) {
        // Unlock AE and AWB.
        mFocusManager.setAeAwbLock(false);
    }
    setCameraParameters(UPDATE_PARAM_ALL);
    mCameraDevice.startPreview();
    mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
    setDisplayOrientation();
    if (!mSnapshotOnIdle) {
        // resume it because it may have been paused by autoFocus call.
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode()) || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
            mCameraDevice.cancelAutoFocus();
        }
    } else {
        mHandler.post(mDoSnapRunnable);
    }
}
#method_after
private void startPreview() {
    if (mPaused || (mCameraDevice == null) || (null == mFocusManager) || (mParameters == null)) {
        return;
    }
    synchronized (mCameraDevice) {
        SurfaceHolder sh = null;
        Log.v(TAG, "startPreview: SurfaceHolder (MDP path)");
        if (mUI != null) {
            sh = mUI.getSurfaceHolder();
        }
        // Let UI set its expected aspect ratio
        mCameraDevice.setPreviewDisplay(sh);
    }
    if (!mCameraPreviewParamsReady) {
        Log.w(TAG, "startPreview: parameters for preview are not ready.");
        return;
    }
    mErrorCallback.setActivity(mActivity);
    mCameraDevice.setErrorCallback(mErrorCallback);
    // Reset camera state after taking a picture
    if (mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
        setCameraState(IDLE);
    }
    // Preview needs to be stopped when changing resolution
    if (mRestartPreview && mCameraState != PREVIEW_STOPPED && mCameraState != INIT) {
        stopPreview();
        mRestartPreview = false;
    }
    if (mFocusManager == null)
        initializeFocusManager();
    if (!mSnapshotOnIdle) {
        // Unlock AE and AWB.
        mFocusManager.setAeAwbLock(false);
    }
    setCameraParameters(UPDATE_PARAM_ALL);
    mCameraDevice.startPreview();
    setCameraState(IDLE);
    mCameraDevice.setOneShotPreviewCallback(mHandler, new CameraManager.CameraPreviewDataCallback() {

        @Override
        public void onPreviewFrame(byte[] data, CameraProxy camera) {
            mUI.hidePreviewCover();
        }
    });
    mHandler.sendEmptyMessage(ON_PREVIEW_STARTED);
    setDisplayOrientation();
    if (!mSnapshotOnIdle) {
        // resume it because it may have been paused by autoFocus call.
        if (CameraUtil.FOCUS_MODE_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode()) || CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE.equals(mFocusManager.getFocusMode())) {
            mCameraDevice.cancelAutoFocus();
        }
    } else {
        mHandler.post(mDoSnapRunnable);
    }
}
#end_block

#method_before
@Override
public void stopPreview() {
    if (mCameraDevice != null && mCameraState != PREVIEW_STOPPED) {
        if (mCameraState == LONGSHOT) {
            mCameraDevice.setLongshot(false);
            mLongshotActive = false;
        }
        Log.v(TAG, "stopPreview");
        mCameraDevice.stopPreview();
    }
    setCameraState(PREVIEW_STOPPED);
    if (mFocusManager != null)
        mFocusManager.onPreviewStopped();
    stopFaceDetection();
}
#method_after
@Override
public void stopPreview() {
    boolean isPreviewing = mCameraDevice.getCamera().previewEnabled();
    if (mCameraDevice != null && isPreviewing) {
        if (mCameraState == LONGSHOT) {
            mCameraDevice.setLongshot(false);
            mLongshotActive = false;
        }
        Log.v(TAG, "stopPreview");
        mCameraDevice.stopPreview();
    }
    setCameraState(PREVIEW_STOPPED);
    if (mFocusManager != null)
        mFocusManager.onPreviewStopped();
    stopFaceDetection();
}
#end_block

#method_before
private void qcomUpdateCameraParametersPreference() {
    // qcom Related Parameter update
    String longshot_enable = mPreferences.getString(CameraSettings.KEY_LONGSHOT, mActivity.getString(R.string.pref_camera_longshot_default));
    mParameters.set("long-shot", longshot_enable);
    if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
        // Set Touch AF/AEC parameter.
        String touchAfAec = mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC, mActivity.getString(R.string.pref_camera_touchafaec_default));
        if (CameraUtil.isSupported(touchAfAec, mParameters.getSupportedTouchAfAec())) {
            mCurrTouchAfAec = touchAfAec;
            mParameters.setTouchAfAec(touchAfAec);
        }
    } else {
        mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
        mFocusManager.resetTouchFocus();
    }
    try {
        if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))
            this.mTouchAfAecFlag = true;
        else
            this.mTouchAfAecFlag = false;
    } catch (Exception e) {
        Log.e(TAG, "Handled NULL pointer Exception");
    }
    // Set Picture Format
    // Picture Formats specified in UI should be consistent with
    // PIXEL_FORMAT_JPEG and PIXEL_FORMAT_RAW constants
    String pictureFormat = mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT, mActivity.getString(R.string.pref_camera_picture_format_default));
    // Change picture format to JPEG if camera is start from other APK by intent.
    if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
        pictureFormat = PIXEL_FORMAT_JPEG;
        Editor editor = mPreferences.edit();
        editor.putString(CameraSettings.KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
        editor.apply();
    }
    Log.v(TAG, "Picture format value =" + pictureFormat);
    mParameters.set(KEY_PICTURE_FORMAT, pictureFormat);
    // Set JPEG quality.
    String jpegQuality = mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY, mActivity.getString(R.string.pref_camera_jpegquality_default));
    // mUnsupportedJpegQuality = false;
    Size pic_size = mParameters.getPictureSize();
    if (pic_size == null) {
        Log.e(TAG, "error getPictureSize: size is null");
    } else {
        if ("100".equals(jpegQuality) && (pic_size.width >= 3200)) {
        // mUnsupportedJpegQuality = true;
        } else {
            mParameters.setJpegQuality(Integer.parseInt(jpegQuality));
            int jpegFileSize = estimateJpegFileSize(pic_size, jpegQuality);
            if (jpegFileSize != mJpegFileSizeEstimation) {
                mJpegFileSizeEstimation = jpegFileSize;
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        updateRemainingPhotos();
                    }
                });
            }
        }
    }
    // Set Selectable Zone Af parameter.
    String selectableZoneAf = mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF, mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
    List<String> str = mParameters.getSupportedSelectableZoneAf();
    if (CameraUtil.isSupported(selectableZoneAf, mParameters.getSupportedSelectableZoneAf())) {
        mParameters.setSelectableZoneAf(selectableZoneAf);
    }
    // Set wavelet denoise mode
    if (mParameters.getSupportedDenoiseModes() != null) {
        String Denoise = mPreferences.getString(CameraSettings.KEY_DENOISE, mActivity.getString(R.string.pref_camera_denoise_default));
        mParameters.setDenoise(Denoise);
    }
    // Set Redeye Reduction
    String redeyeReduction = mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION, mActivity.getString(R.string.pref_camera_redeyereduction_default));
    if (CameraUtil.isSupported(redeyeReduction, mParameters.getSupportedRedeyeReductionModes())) {
        mParameters.setRedeyeReductionMode(redeyeReduction);
    }
    // Set ISO parameter
    if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
        String iso = mPreferences.getString(CameraSettings.KEY_ISO, mActivity.getString(R.string.pref_camera_iso_default));
        if (CameraUtil.isSupported(iso, CameraSettings.getSupportedIsoValues(mParameters))) {
            CameraSettings.setISOValue(mParameters, iso);
        }
    }
    // Set shutter speed parameter
    String shutterSpeed = mPreferences.getString(CameraSettings.KEY_SHUTTER_SPEED, mActivity.getString(R.string.pref_camera_shutter_speed_default));
    if (CameraUtil.isSupported(shutterSpeed, CameraSettings.getSupportedShutterSpeedValues(mParameters))) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED, shutterSpeed);
        ;
    }
    // Set color effect parameter.
    String colorEffect = mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT, mActivity.getString(R.string.pref_camera_coloreffect_default));
    Log.v(TAG, "Color effect value =" + colorEffect);
    if (CameraUtil.isSupported(colorEffect, mParameters.getSupportedColorEffects())) {
        mParameters.setColorEffect(colorEffect);
    }
    // Set Saturation
    String saturationStr = getSaturationSafe();
    if (saturationStr != null) {
        int saturation = Integer.parseInt(saturationStr);
        Log.v(TAG, "Saturation value =" + saturation);
        if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
            mParameters.setSaturation(saturation);
        }
    }
    // Set contrast parameter.
    String contrastStr = getContrastSafe();
    if (contrastStr != null) {
        int contrast = Integer.parseInt(contrastStr);
        Log.v(TAG, "Contrast value =" + contrast);
        if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
            mParameters.setContrast(contrast);
        }
    }
    // Set sharpness parameter
    String sharpnessStr = getSharpnessSafe();
    if (sharpnessStr != null) {
        int sharpness = Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
        Log.v(TAG, "Sharpness value =" + sharpness);
        if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
            mParameters.setSharpness(sharpness);
        }
    }
    // Set Face Recognition
    String faceRC = mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION, mActivity.getString(R.string.pref_camera_facerc_default));
    Log.v(TAG, "Face Recognition value = " + faceRC);
    if (CameraUtil.isSupported(faceRC, CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION, faceRC);
    }
    // Set AE Bracketing
    String aeBracketing = mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR, mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
    Log.v(TAG, "AE Bracketing value =" + aeBracketing);
    if (CameraUtil.isSupported(aeBracketing, CameraSettings.getSupportedAEBracketingModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING, aeBracketing);
    }
    // Set CDS
    String cds = mPreferences.getString(CameraSettings.KEY_CDS_MODE, mActivity.getString(R.string.pref_camera_cds_default));
    if ((mPrevSavedCDS == null) && (cds != null)) {
        mPrevSavedCDS = cds;
    }
    if (CameraUtil.isSupported(cds, CameraSettings.getSupportedCDSModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_QC_CDS_MODE, cds);
    }
    // Set TNR
    String tnr = mPreferences.getString(CameraSettings.KEY_TNR_MODE, mActivity.getString(R.string.pref_camera_tnr_default));
    if (CameraUtil.isSupported(tnr, CameraSettings.getSupportedTNRModes(mParameters))) {
        if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
            mParameters.set(CameraSettings.KEY_QC_CDS_MODE, mActivity.getString(R.string.pref_camera_cds_value_off));
            mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE, mActivity.getString(R.string.pref_camera_cds_value_off));
            if (cds != null) {
                mPrevSavedCDS = cds;
            }
            isTNREnabled = true;
        } else if (isTNREnabled) {
            mParameters.set(CameraSettings.KEY_QC_CDS_MODE, mPrevSavedCDS);
            mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE, mPrevSavedCDS);
            isTNREnabled = false;
        }
        mParameters.set(CameraSettings.KEY_QC_TNR_MODE, tnr);
    }
    // Set hdr mode
    String hdrMode = mPreferences.getString(CameraSettings.KEY_HDR_MODE, mActivity.getString(R.string.pref_camera_hdr_mode_default));
    Log.v(TAG, "HDR Mode value =" + hdrMode);
    if (CameraUtil.isSupported(hdrMode, CameraSettings.getSupportedHDRModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE, hdrMode);
    }
    // Set hdr need 1x
    String hdrNeed1x = mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X, mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
    Log.v(TAG, "HDR need 1x value =" + hdrNeed1x);
    if (CameraUtil.isSupported(hdrNeed1x, CameraSettings.getSupportedHDRNeed1x(mParameters))) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X, hdrNeed1x);
    }
    // Set Advanced features.
    String advancedFeature = mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES, mActivity.getString(R.string.pref_camera_advanced_feature_default));
    Log.e(TAG, " advancedFeature value =" + advancedFeature);
    mRefocus = false;
    if (advancedFeature != null) {
        String ubiFocusOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
        String chromaFlashOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
        String optiZoomOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
        String reFocusOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
        String fssrOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
        String truePortraitOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
        String multiTouchFocusOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
        if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
            qcomUpdateAdvancedFeatures(advancedFeature, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, advancedFeature, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, advancedFeature, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
            mRefocus = true;
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, advancedFeature, fssrOff, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, advancedFeature, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, advancedFeature, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, advancedFeature);
        } else {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
        }
    }
    // Set auto exposure parameter.
    String autoExposure = mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE, mActivity.getString(R.string.pref_camera_autoexposure_default));
    Log.v(TAG, "autoExposure value =" + autoExposure);
    if (CameraUtil.isSupported(autoExposure, mParameters.getSupportedAutoexposure())) {
        mParameters.setAutoExposure(autoExposure);
    }
    // Set anti banding parameter.
    String antiBanding = mPreferences.getString(CameraSettings.KEY_ANTIBANDING, mActivity.getString(R.string.pref_camera_antibanding_default));
    Log.v(TAG, "antiBanding value =" + antiBanding);
    if (CameraUtil.isSupported(antiBanding, mParameters.getSupportedAntibanding())) {
        mParameters.setAntibanding(antiBanding);
    }
    String zsl = mPreferences.getString(CameraSettings.KEY_ZSL, mActivity.getString(R.string.pref_camera_zsl_default));
    String auto_hdr = mPreferences.getString(CameraSettings.KEY_AUTO_HDR, mActivity.getString(R.string.pref_camera_hdr_default));
    if (CameraUtil.isAutoHDRSupported(mParameters)) {
        mParameters.set("auto-hdr-enable", auto_hdr);
        if (auto_hdr.equals("enable")) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null) {
                        mDrawAutoHDR.setVisibility(View.VISIBLE);
                    }
                }
            });
            mParameters.setSceneMode("asd");
            mCameraDevice.setMetadataCb(mMetaDataCallback);
        } else {
            mAutoHdrEnable = false;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null) {
                        mDrawAutoHDR.setVisibility(View.INVISIBLE);
                    }
                }
            });
        }
    }
    mParameters.setZSLMode(zsl);
    if (zsl.equals("on")) {
        // Switch on ZSL Camera mode
        mSnapshotMode = CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
        mParameters.setCameraMode(1);
        mFocusManager.setZslEnable(true);
        // Raw picture format is not supported under ZSL mode
        mParameters.set(KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
        // Try to set CAF for ZSL
        if (!mFocusManager.isTouch()) {
            if (CameraUtil.isSupported(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE, mParameters.getSupportedFocusModes())) {
                mFocusManager.overrideFocusMode(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE);
                mParameters.setFocusMode(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE);
            } else if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE, mParameters.getSupportedFocusModes())) {
                mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
                mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
            }
        } else if (mFocusManager.isTouch()) {
            mFocusManager.overrideFocusMode(null);
            mParameters.setFocusMode(mFocusManager.getFocusMode());
        } else {
            // If not supported use the current mode
            mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
        }
        if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_raw, Toast.LENGTH_SHORT).show();
                }
            });
        }
    } else if (zsl.equals("off")) {
        mSnapshotMode = CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
        mParameters.setCameraMode(0);
        mFocusManager.setZslEnable(false);
        if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
            mFocusManager.overrideFocusMode(null);
            mParameters.setFocusMode(mFocusManager.getFocusMode());
        }
    }
    // Set face detetction parameter.
    String faceDetection = mPreferences.getString(CameraSettings.KEY_FACE_DETECTION, mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection, mParameters.getSupportedFaceDetectionModes())) {
        mParameters.setFaceDetectionMode(faceDetection);
        if (faceDetection.equals("on") && mFaceDetectionEnabled == false) {
            mFaceDetectionEnabled = true;
            startFaceDetection();
        }
        if (faceDetection.equals("off") && mFaceDetectionEnabled == true) {
            stopFaceDetection();
            mFaceDetectionEnabled = false;
        }
    }
    // Set Histogram
    String histogram = mPreferences.getString(CameraSettings.KEY_HISTOGRAM, mActivity.getString(R.string.pref_camera_histogram_default));
    if (CameraUtil.isSupported(histogram, mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
        // Call for histogram
        if (histogram.equals("enable")) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mGraphView != null) {
                        mGraphView.setVisibility(View.VISIBLE);
                        mGraphView.PreviewChanged();
                    }
                }
            });
            mCameraDevice.setHistogramMode(mStatsCallback);
            mHiston = true;
        } else {
            mHiston = false;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mGraphView != null)
                        mGraphView.setVisibility(View.INVISIBLE);
                }
            });
            mCameraDevice.setHistogramMode(null);
        }
    }
    setFlipValue();
    /* Disable focus if aebracket is ON */
    String aeBracket = mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
    if (aeBracket != null && !aeBracket.equalsIgnoreCase("off")) {
        String fMode = Parameters.FLASH_MODE_OFF;
        mParameters.setFlashMode(fMode);
    }
    updatePowerMode();
    mLongShotMaxSnap = SystemProperties.getInt(PERSIST_LONGSHOT_MAX_SNAP, -1);
    mParameters.set("max-longshot-snap", mLongShotMaxSnap);
}
#method_after
private void qcomUpdateCameraParametersPreference() {
    // qcom Related Parameter update
    String longshot_enable = mPreferences.getString(CameraSettings.KEY_LONGSHOT, mActivity.getString(R.string.pref_camera_longshot_default));
    mParameters.set("long-shot", longshot_enable);
    if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode) || CameraUtil.SCENE_MODE_HDR.equals(mSceneMode)) {
        // Set Touch AF/AEC parameter.
        String touchAfAec = mPreferences.getString(CameraSettings.KEY_TOUCH_AF_AEC, mActivity.getString(R.string.pref_camera_touchafaec_default));
        if (CameraUtil.isSupported(touchAfAec, mParameters.getSupportedTouchAfAec())) {
            mCurrTouchAfAec = touchAfAec;
            mParameters.setTouchAfAec(touchAfAec);
        }
    } else {
        mParameters.setTouchAfAec(mParameters.TOUCH_AF_AEC_OFF);
        mFocusManager.resetTouchFocus();
    }
    try {
        if (mParameters.getTouchAfAec().equals(mParameters.TOUCH_AF_AEC_ON))
            this.mTouchAfAecFlag = true;
        else
            this.mTouchAfAecFlag = false;
    } catch (Exception e) {
        Log.e(TAG, "Handled NULL pointer Exception");
    }
    // Set Picture Format
    // Picture Formats specified in UI should be consistent with
    // PIXEL_FORMAT_JPEG and PIXEL_FORMAT_RAW constants
    String pictureFormat = mPreferences.getString(CameraSettings.KEY_PICTURE_FORMAT, mActivity.getString(R.string.pref_camera_picture_format_default));
    // Change picture format to JPEG if camera is start from other APK by intent.
    if (mIsImageCaptureIntent && !pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
        pictureFormat = PIXEL_FORMAT_JPEG;
        Editor editor = mPreferences.edit();
        editor.putString(CameraSettings.KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
        editor.apply();
    }
    Log.v(TAG, "Picture format value =" + pictureFormat);
    mParameters.set(KEY_PICTURE_FORMAT, pictureFormat);
    // Set JPEG quality.
    String jpegQuality = mPreferences.getString(CameraSettings.KEY_JPEG_QUALITY, mActivity.getString(R.string.pref_camera_jpegquality_default));
    // mUnsupportedJpegQuality = false;
    Size pic_size = mParameters.getPictureSize();
    if (pic_size == null) {
        Log.e(TAG, "error getPictureSize: size is null");
    } else {
        if ("100".equals(jpegQuality) && (pic_size.width >= 3200)) {
        // mUnsupportedJpegQuality = true;
        } else {
            mParameters.setJpegQuality(Integer.parseInt(jpegQuality));
            int jpegFileSize = estimateJpegFileSize(pic_size, jpegQuality);
            if (jpegFileSize != mJpegFileSizeEstimation) {
                mJpegFileSizeEstimation = jpegFileSize;
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        updateRemainingPhotos();
                    }
                });
            }
        }
    }
    // Set Selectable Zone Af parameter.
    String selectableZoneAf = mPreferences.getString(CameraSettings.KEY_SELECTABLE_ZONE_AF, mActivity.getString(R.string.pref_camera_selectablezoneaf_default));
    List<String> str = mParameters.getSupportedSelectableZoneAf();
    if (CameraUtil.isSupported(selectableZoneAf, mParameters.getSupportedSelectableZoneAf())) {
        mParameters.setSelectableZoneAf(selectableZoneAf);
    }
    // Set wavelet denoise mode
    if (mParameters.getSupportedDenoiseModes() != null) {
        String Denoise = mPreferences.getString(CameraSettings.KEY_DENOISE, mActivity.getString(R.string.pref_camera_denoise_default));
        mParameters.setDenoise(Denoise);
    }
    // Set Redeye Reduction
    String redeyeReduction = mPreferences.getString(CameraSettings.KEY_REDEYE_REDUCTION, mActivity.getString(R.string.pref_camera_redeyereduction_default));
    if (CameraUtil.isSupported(redeyeReduction, mParameters.getSupportedRedeyeReductionModes())) {
        mParameters.setRedeyeReductionMode(redeyeReduction);
    }
    // Set ISO parameter
    if ((mManual3AEnabled & MANUAL_EXPOSURE) == 0) {
        String iso = mPreferences.getString(CameraSettings.KEY_ISO, mActivity.getString(R.string.pref_camera_iso_default));
        if (CameraUtil.isSupported(iso, CameraSettings.getSupportedIsoValues(mParameters))) {
            CameraSettings.setISOValue(mParameters, iso);
        }
    }
    // Set shutter speed parameter
    String shutterSpeed = mPreferences.getString(CameraSettings.KEY_SHUTTER_SPEED, mActivity.getString(R.string.pref_camera_shutter_speed_default));
    if (CameraUtil.isSupported(shutterSpeed, CameraSettings.getSupportedShutterSpeedValues(mParameters))) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED, shutterSpeed);
    }
    // Set color effect parameter.
    String colorEffect = mPreferences.getString(CameraSettings.KEY_COLOR_EFFECT, mActivity.getString(R.string.pref_camera_coloreffect_default));
    Log.v(TAG, "Color effect value =" + colorEffect);
    if (CameraUtil.isSupported(colorEffect, mParameters.getSupportedColorEffects())) {
        mParameters.setColorEffect(colorEffect);
    }
    // Set Saturation
    String saturationStr = getSaturationSafe();
    if (saturationStr != null) {
        int saturation = Integer.parseInt(saturationStr);
        Log.v(TAG, "Saturation value =" + saturation);
        if ((0 <= saturation) && (saturation <= mParameters.getMaxSaturation())) {
            mParameters.setSaturation(saturation);
        }
    }
    // Set contrast parameter.
    String contrastStr = getContrastSafe();
    if (contrastStr != null) {
        int contrast = Integer.parseInt(contrastStr);
        Log.v(TAG, "Contrast value =" + contrast);
        if ((0 <= contrast) && (contrast <= mParameters.getMaxContrast())) {
            mParameters.setContrast(contrast);
        }
    }
    // Set sharpness parameter
    String sharpnessStr = getSharpnessSafe();
    if (sharpnessStr != null) {
        int sharpness = Integer.parseInt(sharpnessStr) * (mParameters.getMaxSharpness() / MAX_SHARPNESS_LEVEL);
        Log.v(TAG, "Sharpness value =" + sharpness);
        if ((0 <= sharpness) && (sharpness <= mParameters.getMaxSharpness())) {
            mParameters.setSharpness(sharpness);
        }
    }
    // Set Face Recognition
    String faceRC = mPreferences.getString(CameraSettings.KEY_FACE_RECOGNITION, mActivity.getString(R.string.pref_camera_facerc_default));
    Log.v(TAG, "Face Recognition value = " + faceRC);
    if (CameraUtil.isSupported(faceRC, CameraSettings.getSupportedFaceRecognitionModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_QC_FACE_RECOGNITION, faceRC);
    }
    // Set AE Bracketing
    String aeBracketing = mPreferences.getString(CameraSettings.KEY_AE_BRACKET_HDR, mActivity.getString(R.string.pref_camera_ae_bracket_hdr_default));
    Log.v(TAG, "AE Bracketing value =" + aeBracketing);
    if (CameraUtil.isSupported(aeBracketing, CameraSettings.getSupportedAEBracketingModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_QC_AE_BRACKETING, aeBracketing);
    }
    // Set CDS
    String cds = mPreferences.getString(CameraSettings.KEY_CDS_MODE, mActivity.getString(R.string.pref_camera_cds_default));
    if ((mPrevSavedCDS == null) && (cds != null)) {
        mPrevSavedCDS = cds;
    }
    if (CameraUtil.isSupported(cds, CameraSettings.getSupportedCDSModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_QC_CDS_MODE, cds);
    }
    // Set TNR
    String tnr = mPreferences.getString(CameraSettings.KEY_TNR_MODE, mActivity.getString(R.string.pref_camera_tnr_default));
    if (CameraUtil.isSupported(tnr, CameraSettings.getSupportedTNRModes(mParameters))) {
        if (!tnr.equals(mActivity.getString(R.string.pref_camera_tnr_value_off))) {
            mParameters.set(CameraSettings.KEY_QC_CDS_MODE, mActivity.getString(R.string.pref_camera_cds_value_off));
            mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE, mActivity.getString(R.string.pref_camera_cds_value_off));
            if (cds != null) {
                mPrevSavedCDS = cds;
            }
            isTNREnabled = true;
        } else if (isTNREnabled) {
            mParameters.set(CameraSettings.KEY_QC_CDS_MODE, mPrevSavedCDS);
            mUI.overrideSettings(CameraSettings.KEY_QC_CDS_MODE, mPrevSavedCDS);
            isTNREnabled = false;
        }
        mParameters.set(CameraSettings.KEY_QC_TNR_MODE, tnr);
    }
    // Set hdr mode
    String hdrMode = mPreferences.getString(CameraSettings.KEY_HDR_MODE, mActivity.getString(R.string.pref_camera_hdr_mode_default));
    Log.v(TAG, "HDR Mode value =" + hdrMode);
    if (CameraUtil.isSupported(hdrMode, CameraSettings.getSupportedHDRModes(mParameters))) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_MODE, hdrMode);
    }
    // Set hdr need 1x
    String hdrNeed1x = mPreferences.getString(CameraSettings.KEY_HDR_NEED_1X, mActivity.getString(R.string.pref_camera_hdr_need_1x_default));
    Log.v(TAG, "HDR need 1x value =" + hdrNeed1x);
    if (CameraUtil.isSupported(hdrNeed1x, CameraSettings.getSupportedHDRNeed1x(mParameters))) {
        mParameters.set(CameraSettings.KEY_SNAPCAM_HDR_NEED_1X, hdrNeed1x);
    }
    // Set Advanced features.
    String advancedFeature = mPreferences.getString(CameraSettings.KEY_ADVANCED_FEATURES, mActivity.getString(R.string.pref_camera_advanced_feature_default));
    Log.e(TAG, " advancedFeature value =" + advancedFeature);
    mRefocus = false;
    if (advancedFeature != null) {
        String ubiFocusOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_off);
        String chromaFlashOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_off);
        String optiZoomOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_off);
        String reFocusOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_off);
        String fssrOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_off);
        String truePortraitOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_off);
        String multiTouchFocusOff = mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_off);
        if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_ubifocus_on))) {
            qcomUpdateAdvancedFeatures(advancedFeature, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_chromaflash_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, advancedFeature, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, advancedFeature, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
            mRefocus = true;
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_optizoom_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, advancedFeature, fssrOff, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_FSSR_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, advancedFeature, truePortraitOff, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_trueportrait_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, advancedFeature, multiTouchFocusOff);
        } else if (advancedFeature.equals(mActivity.getString(R.string.pref_camera_advanced_feature_value_multi_touch_focus_on))) {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, advancedFeature);
        } else {
            qcomUpdateAdvancedFeatures(ubiFocusOff, chromaFlashOff, reFocusOff, optiZoomOff, fssrOff, truePortraitOff, multiTouchFocusOff);
        }
    }
    // Set auto exposure parameter.
    String autoExposure = mPreferences.getString(CameraSettings.KEY_AUTOEXPOSURE, mActivity.getString(R.string.pref_camera_autoexposure_default));
    Log.v(TAG, "autoExposure value =" + autoExposure);
    if (CameraUtil.isSupported(autoExposure, mParameters.getSupportedAutoexposure())) {
        mParameters.setAutoExposure(autoExposure);
    }
    // Set anti banding parameter.
    String antiBanding = mPreferences.getString(CameraSettings.KEY_ANTIBANDING, mActivity.getString(R.string.pref_camera_antibanding_default));
    Log.v(TAG, "antiBanding value =" + antiBanding);
    if (CameraUtil.isSupported(antiBanding, mParameters.getSupportedAntibanding())) {
        mParameters.setAntibanding(antiBanding);
    }
    String zsl = mPreferences.getString(CameraSettings.KEY_ZSL, mActivity.getString(R.string.pref_camera_zsl_default));
    String auto_hdr = mPreferences.getString(CameraSettings.KEY_AUTO_HDR, mActivity.getString(R.string.pref_camera_hdr_default));
    if (CameraUtil.isAutoHDRSupported(mParameters)) {
        mParameters.set("auto-hdr-enable", auto_hdr);
        if (auto_hdr.equals("enable")) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null) {
                        mDrawAutoHDR.setVisibility(View.VISIBLE);
                    }
                }
            });
            mParameters.setSceneMode("asd");
            mCameraDevice.setMetadataCb(mMetaDataCallback);
        } else {
            mAutoHdrEnable = false;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mDrawAutoHDR != null) {
                        mDrawAutoHDR.setVisibility(View.INVISIBLE);
                    }
                }
            });
        }
    }
    mParameters.setZSLMode(zsl);
    if (zsl.equals("on")) {
        // Switch on ZSL Camera mode
        mSnapshotMode = CameraInfo.CAMERA_SUPPORT_MODE_ZSL;
        mParameters.setCameraMode(1);
        mFocusManager.setZslEnable(true);
        // Raw picture format is not supported under ZSL mode
        mParameters.set(KEY_PICTURE_FORMAT, PIXEL_FORMAT_JPEG);
        // Try to set CAF for ZSL
        if (!mFocusManager.isTouch()) {
            if (CameraUtil.isSupported(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE, mParameters.getSupportedFocusModes())) {
                mFocusManager.overrideFocusMode(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE);
                mParameters.setFocusMode(CameraUtil.FOCUS_MODE_MW_CONTINUOUS_PICTURE);
            } else if (CameraUtil.isSupported(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE, mParameters.getSupportedFocusModes())) {
                mFocusManager.overrideFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
                mParameters.setFocusMode(Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
            }
        } else if (mFocusManager.isTouch()) {
            mFocusManager.overrideFocusMode(null);
            mParameters.setFocusMode(mFocusManager.getFocusMode());
        } else {
            // If not supported use the current mode
            mFocusManager.overrideFocusMode(mFocusManager.getFocusMode());
        }
        if (!pictureFormat.equals(PIXEL_FORMAT_JPEG)) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    RotateTextToast.makeText(mActivity, R.string.error_app_unsupported_raw, Toast.LENGTH_SHORT).show();
                }
            });
        }
    } else if (zsl.equals("off")) {
        mSnapshotMode = CameraInfo.CAMERA_SUPPORT_MODE_NONZSL;
        mParameters.setCameraMode(0);
        mFocusManager.setZslEnable(false);
        if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
            mFocusManager.overrideFocusMode(null);
            mParameters.setFocusMode(mFocusManager.getFocusMode());
        }
    }
    // Set face detetction parameter.
    String faceDetection = mPreferences.getString(CameraSettings.KEY_FACE_DETECTION, mActivity.getString(R.string.pref_camera_facedetection_default));
    if (CameraUtil.isSupported(faceDetection, mParameters.getSupportedFaceDetectionModes())) {
        mParameters.setFaceDetectionMode(faceDetection);
        if (faceDetection.equals("on") && mFaceDetectionEnabled == false) {
            mFaceDetectionEnabled = true;
            startFaceDetection();
        }
        if (faceDetection.equals("off") && mFaceDetectionEnabled == true) {
            stopFaceDetection();
            mFaceDetectionEnabled = false;
        }
    }
    // Set Histogram
    String histogram = mPreferences.getString(CameraSettings.KEY_HISTOGRAM, mActivity.getString(R.string.pref_camera_histogram_default));
    if (CameraUtil.isSupported(histogram, mParameters.getSupportedHistogramModes()) && mCameraDevice != null) {
        // Call for histogram
        if (histogram.equals("enable")) {
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mGraphView != null) {
                        mGraphView.setVisibility(View.VISIBLE);
                        mGraphView.PreviewChanged();
                    }
                }
            });
            mCameraDevice.setHistogramMode(mStatsCallback);
            mHiston = true;
        } else {
            mHiston = false;
            mActivity.runOnUiThread(new Runnable() {

                public void run() {
                    if (mGraphView != null)
                        mGraphView.setVisibility(View.INVISIBLE);
                }
            });
            mCameraDevice.setHistogramMode(null);
        }
    }
    setFlipValue();
    /* Disable focus if aebracket is ON */
    String aeBracket = mParameters.get(CameraSettings.KEY_QC_AE_BRACKETING);
    if (aeBracket != null && !aeBracket.equalsIgnoreCase("off")) {
        String fMode = Parameters.FLASH_MODE_OFF;
        mParameters.setFlashMode(fMode);
    }
    updatePowerMode();
    mLongShotMaxSnap = SystemProperties.getInt(PERSIST_LONGSHOT_MAX_SNAP, -1);
    mParameters.set("max-longshot-snap", mLongShotMaxSnap);
}
#end_block

#method_before
private boolean updateCameraParametersPreference() {
    setAutoExposureLockIfSupported();
    setAutoWhiteBalanceLockIfSupported();
    setFocusAreasIfSupported();
    setMeteringAreasIfSupported();
    // initialize focus mode
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
        mFocusManager.overrideFocusMode(null);
        mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
    // Set picture size.
    String pictureSize = mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE, null);
    if (pictureSize == null) {
        CameraSettings.initialCameraPictureSize(mActivity, mParameters);
    } else {
        Size old_size = mParameters.getPictureSize();
        Log.v(TAG, "old picture_size = " + old_size.width + " x " + old_size.height);
        List<Size> supported = mParameters.getSupportedPictureSizes();
        CameraSettings.setCameraPictureSize(pictureSize, supported, mParameters);
        Size size = mParameters.getPictureSize();
        Log.v(TAG, "new picture_size = " + size.width + " x " + size.height);
        if (old_size != null && size != null) {
            if (!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
                Log.v(TAG, "Picture Size changed. Restart Preview");
                mRestartPreview = true;
            }
        }
    }
    Size size = mParameters.getPictureSize();
    // Set a preview size that is closest to the viewfinder height and has
    // the right aspect ratio.
    List<Size> sizes = mParameters.getSupportedPreviewSizes();
    Size optimalSize = CameraUtil.getOptimalPreviewSize(mActivity, sizes, (double) size.width / size.height);
    // Read Preview Resolution from adb command
    // value: 0(default) - Default value as per snapshot aspect ratio
    // value: 1 - 640x480
    // value: 2 - 720x480
    // value: 3 - 1280x720
    // value: 4 - 1920x1080
    int preview_resolution = SystemProperties.getInt("persist.camera.preview.size", 0);
    switch(preview_resolution) {
        case 1:
            {
                optimalSize.width = 640;
                optimalSize.height = 480;
                Log.v(TAG, "Preview resolution hardcoded to 640x480");
                break;
            }
        case 2:
            {
                optimalSize.width = 720;
                optimalSize.height = 480;
                Log.v(TAG, "Preview resolution hardcoded to 720x480");
                break;
            }
        case 3:
            {
                optimalSize.width = 1280;
                optimalSize.height = 720;
                Log.v(TAG, "Preview resolution hardcoded to 1280x720");
                break;
            }
        case 4:
            {
                optimalSize.width = 1920;
                optimalSize.height = 1080;
                Log.v(TAG, "Preview resolution hardcoded to 1920x1080");
                break;
            }
        default:
            {
                Log.v(TAG, "Preview resolution as per Snapshot aspect ratio");
                break;
            }
    }
    Size original = mParameters.getPreviewSize();
    if (!original.equals(optimalSize)) {
        mParameters.setPreviewSize(optimalSize.width, optimalSize.height);
        // sizes, so set and read the parameters to get latest values
        if (mHandler.getLooper() == Looper.myLooper()) {
            // On UI thread only, not when camera starts up
            setupPreview();
        } else {
            mCameraDevice.setParameters(mParameters);
        }
        mParameters = mCameraDevice.getParameters();
        Log.v(TAG, "Preview Size changed. Restart Preview");
        mRestartPreview = true;
    }
    Log.v(TAG, "Preview size is " + optimalSize.width + "x" + optimalSize.height);
    size = mParameters.getPictureSize();
    // Set jpegthumbnail size
    // Set a jpegthumbnail size that is closest to the Picture height and has
    // the right aspect ratio.
    List<Size> supported = mParameters.getSupportedJpegThumbnailSizes();
    optimalSize = CameraUtil.getOptimalJpegThumbnailSize(supported, (double) size.width / size.height);
    original = mParameters.getJpegThumbnailSize();
    if (!original.equals(optimalSize)) {
        mParameters.setJpegThumbnailSize(optimalSize.width, optimalSize.height);
    }
    Log.v(TAG, "Thumbnail size is " + optimalSize.width + "x" + optimalSize.height);
    // Since changing scene mode may change supported values, set scene mode
    // first. HDR is a scene mode. To promote it in UI, it is stored in a
    // separate preference.
    String onValue = mActivity.getString(R.string.setting_on_value);
    String hdr = mPreferences.getString(CameraSettings.KEY_CAMERA_HDR, mActivity.getString(R.string.pref_camera_hdr_default));
    String hdrPlus = mPreferences.getString(CameraSettings.KEY_CAMERA_HDR_PLUS, mActivity.getString(R.string.pref_camera_hdr_plus_default));
    boolean hdrOn = onValue.equals(hdr);
    boolean hdrPlusOn = onValue.equals(hdrPlus);
    boolean doGcamModeSwitch = false;
    if (hdrPlusOn && GcamHelper.hasGcamCapture()) {
        // Kick off mode switch to gcam.
        doGcamModeSwitch = true;
    } else {
        if (hdrOn) {
            mSceneMode = CameraUtil.SCENE_MODE_HDR;
            if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode()) && !(Parameters.SCENE_MODE_HDR).equals(mParameters.getSceneMode())) {
                mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
                mCameraDevice.setParameters(mParameters);
                mParameters = mCameraDevice.getParameters();
            }
        } else {
            mSceneMode = mPreferences.getString(CameraSettings.KEY_SCENE_MODE, mActivity.getString(R.string.pref_camera_scenemode_default));
        }
    }
    String refocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
    if (CameraUtil.isSupported(mSceneMode, mParameters.getSupportedSceneModes())) {
        if (!mParameters.getSceneMode().equals(mSceneMode)) {
            mParameters.setSceneMode(mSceneMode);
            // Setting scene mode will change the settings of flash mode,
            // white balance, and focus mode. Here we read back the
            // parameters, so we can know those settings.
            mCameraDevice.setParameters(mParameters);
            mParameters = mCameraDevice.getParameters();
        }
    } else {
        if (refocusOn.equals(mSceneMode)) {
            try {
                mUI.setPreference(CameraSettings.KEY_ADVANCED_FEATURES, refocusOn);
            } catch (NullPointerException e) {
            }
        } else {
            mSceneMode = mParameters.getSceneMode();
            if (mSceneMode == null) {
                mSceneMode = Parameters.SCENE_MODE_AUTO;
            }
        }
    }
    // For the following settings, we need to check if the settings are
    // still supported by latest driver, if not, ignore the settings.
    // Set exposure compensation
    int value = CameraSettings.readExposure(mPreferences);
    int max = mParameters.getMaxExposureCompensation();
    int min = mParameters.getMinExposureCompensation();
    if (value >= min && value <= max) {
        mParameters.setExposureCompensation(value);
    } else {
        Log.w(TAG, "invalid exposure range: " + value);
    }
    if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
        // Set flash mode.
        String flashMode = mPreferences.getString(CameraSettings.KEY_FLASH_MODE, mActivity.getString(R.string.pref_camera_flashmode_default));
        List<String> supportedFlash = mParameters.getSupportedFlashModes();
        if (CameraUtil.isSupported(flashMode, supportedFlash)) {
            mParameters.setFlashMode(flashMode);
        } else {
            flashMode = mParameters.getFlashMode();
            if (flashMode == null) {
                flashMode = mActivity.getString(R.string.pref_camera_flashmode_no_flash);
            }
        }
        // Set white balance parameter.
        if ((mManual3AEnabled & MANUAL_WB) == 0) {
            String whiteBalance = mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE, mActivity.getString(R.string.pref_camera_whitebalance_default));
            if (CameraUtil.isSupported(whiteBalance, mParameters.getSupportedWhiteBalance())) {
                mParameters.setWhiteBalance(whiteBalance);
            } else {
                whiteBalance = mParameters.getWhiteBalance();
                if (whiteBalance == null) {
                    whiteBalance = Parameters.WHITE_BALANCE_AUTO;
                }
            }
        }
        // Set focus mode.
        if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
            mFocusManager.overrideFocusMode(null);
            mParameters.setFocusMode(mFocusManager.getFocusMode());
        }
        // Set focus time.
        mFocusManager.setFocusTime(Integer.valueOf(mPreferences.getString(CameraSettings.KEY_FOCUS_TIME, mActivity.getString(R.string.pref_camera_focustime_default))));
    } else {
        mFocusManager.overrideFocusMode(mParameters.getFocusMode());
        if (hdrOn)
            mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
        else {
            mParameters.setFlashMode(Parameters.FLASH_MODE_AUTO);
        }
        if (CameraUtil.isSupported(Parameters.WHITE_BALANCE_AUTO, mParameters.getSupportedWhiteBalance())) {
            mParameters.setWhiteBalance(Parameters.WHITE_BALANCE_AUTO);
        }
    }
    if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
        updateAutoFocusMoveCallback();
    }
    // QCom related parameters updated here.
    qcomUpdateCameraParametersPreference();
    return doGcamModeSwitch;
}
#method_after
private boolean updateCameraParametersPreference() {
    setAutoExposureLockIfSupported();
    setAutoWhiteBalanceLockIfSupported();
    setFocusAreasIfSupported();
    setMeteringAreasIfSupported();
    // initialize focus mode
    if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
        mFocusManager.overrideFocusMode(null);
        mParameters.setFocusMode(mFocusManager.getFocusMode());
    }
    // Set picture size.
    String pictureSize = mPreferences.getString(CameraSettings.KEY_PICTURE_SIZE, null);
    if (pictureSize == null) {
        CameraSettings.initialCameraPictureSize(mActivity, mParameters);
    } else {
        Size old_size = mParameters.getPictureSize();
        Log.v(TAG, "old picture_size = " + old_size.width + " x " + old_size.height);
        List<Size> supported = mParameters.getSupportedPictureSizes();
        CameraSettings.setCameraPictureSize(pictureSize, supported, mParameters);
        Size size = mParameters.getPictureSize();
        Log.v(TAG, "new picture_size = " + size.width + " x " + size.height);
        if (old_size != null && size != null) {
            if (!size.equals(old_size) && mCameraState != PREVIEW_STOPPED) {
                Log.v(TAG, "Picture Size changed. Restart Preview.");
                mRestartPreview = true;
            }
        }
    }
    Size size = mParameters.getPictureSize();
    // Set a preview size that is closest to the viewfinder height and has
    // the right aspect ratio.
    List<Size> sizes = mParameters.getSupportedPreviewSizes();
    Size optimalSize = CameraUtil.getOptimalPreviewSize(mActivity, sizes, (double) size.width / size.height);
    // Read Preview Resolution from adb command
    // value: 0(default) - Default value as per snapshot aspect ratio
    // value: 1 - 640x480
    // value: 2 - 720x480
    // value: 3 - 1280x720
    // value: 4 - 1920x1080
    int preview_resolution = SystemProperties.getInt("persist.camera.preview.size", 0);
    switch(preview_resolution) {
        case 1:
            {
                optimalSize.width = 640;
                optimalSize.height = 480;
                Log.v(TAG, "Preview resolution hardcoded to 640x480");
                break;
            }
        case 2:
            {
                optimalSize.width = 720;
                optimalSize.height = 480;
                Log.v(TAG, "Preview resolution hardcoded to 720x480");
                break;
            }
        case 3:
            {
                optimalSize.width = 1280;
                optimalSize.height = 720;
                Log.v(TAG, "Preview resolution hardcoded to 1280x720");
                break;
            }
        case 4:
            {
                optimalSize.width = 1920;
                optimalSize.height = 1080;
                Log.v(TAG, "Preview resolution hardcoded to 1920x1080");
                break;
            }
        default:
            {
                Log.v(TAG, "Preview resolution as per Snapshot aspect ratio");
                break;
            }
    }
    Size original = mParameters.getPreviewSize();
    if (!original.equals(optimalSize)) {
        mParameters.setPreviewSize(optimalSize.width, optimalSize.height);
        // sizes, so set and read the parameters to get latest values
        if (mHandler.getLooper() == Looper.myLooper()) {
            // On UI thread only, not when camera starts up
            setupPreview();
        } else {
            mCameraDevice.setParameters(mParameters);
        }
        mParameters = mCameraDevice.getParameters();
        Log.v(TAG, "Preview Size changed. Restart Preview");
        mRestartPreview = true;
    }
    Log.v(TAG, "Preview size is " + optimalSize.width + "x" + optimalSize.height);
    size = mParameters.getPictureSize();
    // Set jpegthumbnail size
    // Set a jpegthumbnail size that is closest to the Picture height and has
    // the right aspect ratio.
    List<Size> supported = mParameters.getSupportedJpegThumbnailSizes();
    optimalSize = CameraUtil.getOptimalJpegThumbnailSize(supported, (double) size.width / size.height);
    original = mParameters.getJpegThumbnailSize();
    if (!original.equals(optimalSize)) {
        mParameters.setJpegThumbnailSize(optimalSize.width, optimalSize.height);
    }
    Log.v(TAG, "Thumbnail size is " + optimalSize.width + "x" + optimalSize.height);
    // Since changing scene mode may change supported values, set scene mode
    // first. HDR is a scene mode. To promote it in UI, it is stored in a
    // separate preference.
    String onValue = mActivity.getString(R.string.setting_on_value);
    String hdr = mPreferences.getString(CameraSettings.KEY_CAMERA_HDR, mActivity.getString(R.string.pref_camera_hdr_default));
    String hdrPlus = mPreferences.getString(CameraSettings.KEY_CAMERA_HDR_PLUS, mActivity.getString(R.string.pref_camera_hdr_plus_default));
    boolean hdrOn = onValue.equals(hdr);
    boolean hdrPlusOn = onValue.equals(hdrPlus);
    boolean doGcamModeSwitch = false;
    if (hdrPlusOn && GcamHelper.hasGcamCapture()) {
        // Kick off mode switch to gcam.
        doGcamModeSwitch = true;
    } else {
        if (hdrOn) {
            mSceneMode = CameraUtil.SCENE_MODE_HDR;
            if (!(Parameters.SCENE_MODE_AUTO).equals(mParameters.getSceneMode()) && !(Parameters.SCENE_MODE_HDR).equals(mParameters.getSceneMode())) {
                mParameters.setSceneMode(Parameters.SCENE_MODE_AUTO);
                mCameraDevice.setParameters(mParameters);
                mParameters = mCameraDevice.getParameters();
            }
        } else {
            mSceneMode = mPreferences.getString(CameraSettings.KEY_SCENE_MODE, mActivity.getString(R.string.pref_camera_scenemode_default));
        }
    }
    String refocusOn = mActivity.getString(R.string.pref_camera_advanced_feature_value_refocus_on);
    if (CameraUtil.isSupported(mSceneMode, mParameters.getSupportedSceneModes())) {
        if (!mParameters.getSceneMode().equals(mSceneMode)) {
            mParameters.setSceneMode(mSceneMode);
            // Setting scene mode will change the settings of flash mode,
            // white balance, and focus mode. Here we read back the
            // parameters, so we can know those settings.
            mCameraDevice.setParameters(mParameters);
            mParameters = mCameraDevice.getParameters();
        }
    } else {
        if (refocusOn.equals(mSceneMode)) {
            try {
                mUI.setPreference(CameraSettings.KEY_ADVANCED_FEATURES, refocusOn);
            } catch (NullPointerException e) {
            }
        } else {
            mSceneMode = mParameters.getSceneMode();
            if (mSceneMode == null) {
                mSceneMode = Parameters.SCENE_MODE_AUTO;
            }
        }
    }
    // When shutter speed gets disabled preview needs to be restarted
    if (CameraUtil.isSupported(mParameters, CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED)) {
        String shutterSpeed = mPreferences.getString(CameraSettings.KEY_SHUTTER_SPEED, null);
        if (shutterSpeed != null) {
            String oldShutterSpeed = mParameters.get(CameraSettings.KEY_SNAPCAM_SHUTTER_SPEED);
            if (!shutterSpeed.equals(oldShutterSpeed) && shutterSpeed.equals("0") && mCameraState != PREVIEW_STOPPED) {
                Log.v(TAG, "Shutter speed disabled. Restart Preview.");
                mRestartPreview = true;
            }
        }
    }
    // For the following settings, we need to check if the settings are
    // still supported by latest driver, if not, ignore the settings.
    // Set exposure compensation
    int value = CameraSettings.readExposure(mPreferences);
    int max = mParameters.getMaxExposureCompensation();
    int min = mParameters.getMinExposureCompensation();
    if (value >= min && value <= max) {
        mParameters.setExposureCompensation(value);
    } else {
        Log.w(TAG, "invalid exposure range: " + value);
    }
    if (Parameters.SCENE_MODE_AUTO.equals(mSceneMode)) {
        // Set flash mode.
        String flashMode = mPreferences.getString(CameraSettings.KEY_FLASH_MODE, mActivity.getString(R.string.pref_camera_flashmode_default));
        List<String> supportedFlash = mParameters.getSupportedFlashModes();
        if (CameraUtil.isSupported(flashMode, supportedFlash)) {
            mParameters.setFlashMode(flashMode);
        } else {
            flashMode = mParameters.getFlashMode();
            if (flashMode == null) {
                flashMode = mActivity.getString(R.string.pref_camera_flashmode_no_flash);
            }
        }
        // Set white balance parameter.
        if ((mManual3AEnabled & MANUAL_WB) == 0) {
            String whiteBalance = mPreferences.getString(CameraSettings.KEY_WHITE_BALANCE, mActivity.getString(R.string.pref_camera_whitebalance_default));
            if (CameraUtil.isSupported(whiteBalance, mParameters.getSupportedWhiteBalance())) {
                mParameters.setWhiteBalance(whiteBalance);
            } else {
                whiteBalance = mParameters.getWhiteBalance();
                if (whiteBalance == null) {
                    whiteBalance = Parameters.WHITE_BALANCE_AUTO;
                }
            }
        }
        // Set focus mode.
        if ((mManual3AEnabled & MANUAL_FOCUS) == 0) {
            mFocusManager.overrideFocusMode(null);
            mParameters.setFocusMode(mFocusManager.getFocusMode());
        }
        // Set focus time.
        mFocusManager.setFocusTime(Integer.valueOf(mPreferences.getString(CameraSettings.KEY_FOCUS_TIME, mActivity.getString(R.string.pref_camera_focustime_default))));
    } else {
        mFocusManager.overrideFocusMode(mParameters.getFocusMode());
        if (CameraUtil.isSupported(Parameters.FLASH_MODE_OFF, mParameters.getSupportedFlashModes())) {
            mParameters.setFlashMode(Parameters.FLASH_MODE_OFF);
        }
        if (CameraUtil.isSupported(Parameters.WHITE_BALANCE_AUTO, mParameters.getSupportedWhiteBalance())) {
            mParameters.setWhiteBalance(Parameters.WHITE_BALANCE_AUTO);
        }
    }
    if (mContinuousFocusSupported && ApiHelper.HAS_AUTO_FOCUS_MOVE_CALLBACK) {
        updateAutoFocusMoveCallback();
    }
    // QCom related parameters updated here.
    qcomUpdateCameraParametersPreference();
    return doGcamModeSwitch;
}
#end_block

#method_before
@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
    Log.v(TAG, "surfaceChanged: width =" + width + ", height = " + height);
}
#method_after
@Override
public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
    Log.v(TAG, "surfaceChanged: width =" + width + ", height = " + height);
    RectF r = new RectF(mSurfaceView.getLeft(), mSurfaceView.getTop(), mSurfaceView.getRight(), mSurfaceView.getBottom());
    mController.onPreviewRectChanged(CameraUtil.rectFToRect(r));
}
#end_block

#method_before
public void initializeControlByIntent() {
    mThumbnail = (ImageView) mRootView.findViewById(R.id.preview_thumb);
    mMenuButton = mRootView.findViewById(R.id.menu);
    mMenuButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mMenu != null) {
                mMenu.openFirstLevel();
            }
        }
    });
    if (mController.isImageCaptureIntent()) {
        hideSwitcher();
        ViewGroup cameraControls = (ViewGroup) mRootView.findViewById(R.id.camera_controls);
        mActivity.getLayoutInflater().inflate(R.layout.review_module_control, cameraControls);
        mReviewDoneButton = mRootView.findViewById(R.id.btn_done);
        mReviewCancelButton = mRootView.findViewById(R.id.btn_cancel);
        mReviewRetakeButton = mRootView.findViewById(R.id.btn_retake);
        mReviewImage = (ImageView) mRootView.findViewById(R.id.review_image);
        mReviewCancelButton.setVisibility(View.VISIBLE);
        mReviewDoneButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mController.onCaptureDone();
            }
        });
        mReviewCancelButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mController.onCaptureCancelled();
            }
        });
        mReviewRetakeButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mController.onCaptureRetake();
            }
        });
    }
}
#method_after
public void initializeControlByIntent() {
    mThumbnail = (ImageView) mRootView.findViewById(R.id.preview_thumb);
    mThumbnail.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            if (!CameraControls.isAnimating() && mController.getCameraState() != PhotoController.SNAPSHOT_IN_PROGRESS)
                mActivity.gotoGallery();
        }
    });
    mMenuButton = mRootView.findViewById(R.id.menu);
    mMenuButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mMenu != null) {
                mMenu.openFirstLevel();
            }
        }
    });
    if (mController.isImageCaptureIntent()) {
        hideSwitcher();
        mSwitcher.setSwitcherVisibility(false);
        ViewGroup cameraControls = (ViewGroup) mRootView.findViewById(R.id.camera_controls);
        mActivity.getLayoutInflater().inflate(R.layout.review_module_control, cameraControls);
        mReviewDoneButton = mRootView.findViewById(R.id.btn_done);
        mReviewCancelButton = mRootView.findViewById(R.id.btn_cancel);
        mReviewRetakeButton = mRootView.findViewById(R.id.btn_retake);
        mReviewImage = (ImageView) mRootView.findViewById(R.id.review_image);
        mReviewCancelButton.setVisibility(View.VISIBLE);
        mReviewDoneButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mController.onCaptureDone();
            }
        });
        mReviewCancelButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mController.onCaptureCancelled();
            }
        });
        mReviewRetakeButton.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                mController.onCaptureRetake();
            }
        });
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.lockscreen_interface_settings);
    mChooseLockSettingsHelper = new ChooseLockSettingsHelper(getActivity());
    mLockUtils = mChooseLockSettingsHelper.utils();
    mDPM = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
    // Find categories
    PreferenceCategory generalCategory = (PreferenceCategory) findPreference(LOCKSCREEN_GENERAL_CATEGORY);
    PreferenceCategory widgetsCategory = (PreferenceCategory) findPreference(LOCKSCREEN_WIDGETS_CATEGORY);
    backgroundCategory = (PreferenceCategory) findPreference(LOCKSCREEN_BACKGROUND_CATEGORY);
    // Find preferences
    mEnableKeyguardWidgets = (CheckBoxPreference) findPreference(KEY_ENABLE_WIDGETS);
    mEnableCameraWidget = (CheckBoxPreference) findPreference(KEY_ENABLE_CAMERA);
    mBatteryStatus = (ListPreference) findPreference(KEY_BATTERY_STATUS);
    if (mBatteryStatus != null) {
        mBatteryStatus.setOnPreferenceChangeListener(this);
    }
    // Remove lockscreen button actions if device doesn't have hardware keys
    if (!hasButtons()) {
        generalCategory.removePreference(findPreference(KEY_LOCKSCREEN_BUTTONS));
    }
    // Enable or disable lockscreen widgets based on policy
    checkDisabledByPolicy(mEnableKeyguardWidgets, DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL);
    // Enable or disable camera widget based on device and policy
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA) || Camera.getNumberOfCameras() == 0) {
        widgetsCategory.removePreference(mEnableCameraWidget);
        mEnableCameraWidget = null;
    } else if (mLockUtils.isSecure()) {
        checkDisabledByPolicy(mEnableCameraWidget, DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);
    }
    // Remove cLock settings item if not installed
    if (!isPackageInstalled("com.cyanogenmod.lockclock")) {
        widgetsCategory.removePreference(findPreference(KEY_LOCK_CLOCK));
    }
    // Remove maximize widgets on tablets
    if (!Utils.isPhone(getActivity())) {
        widgetsCategory.removePreference(findPreference(Settings.System.LOCKSCREEN_MAXIMIZE_WIDGETS));
    }
    mLockBackground = (ListPreference) findPreference(LOCKSCREEN_BACKGROUND_STYLE);
    mLockBackground.setOnPreferenceChangeListener(this);
    mLockBackground.setValue(Integer.toString(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_STYLE, 2)));
    mLockBackground.setSummary(mLockBackground.getEntry());
    mWallpaperAlpha = (SeekBarPreference) findPreference(LOCKSCREEN_WALLPAPER_ALPHA);
    mWallpaperAlpha.setOnPreferenceChangeListener(this);
    float mWallpaperAlphaTransparency = 1.0f;
    try {
        mWallpaperAlphaTransparency = Settings.System.getFloat(getContentResolver(), Settings.System.LOCKSCREEN_WALLPAPER_ALPHA);
    } catch (Exception e) {
        mWallpaperAlphaTransparency = 1.0f;
        Settings.System.putFloat(getContentResolver(), Settings.System.LOCKSCREEN_WALLPAPER_ALPHA, 1.0f);
    }
    mWallpaperAlpha.setInitValue((int) (mWallpaperAlphaTransparency * 100));
    wallpaperImage = new File(getActivity().getFilesDir() + "/lockwallpaper");
    wallpaperTemporary = new File(getActivity().getCacheDir() + "/lockwallpaper.tmp");
    updateVisiblePreferences();
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.lockscreen_interface_settings);
    mChooseLockSettingsHelper = new ChooseLockSettingsHelper(getActivity());
    mLockUtils = mChooseLockSettingsHelper.utils();
    mDPM = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
    // Find categories
    PreferenceCategory generalCategory = (PreferenceCategory) findPreference(LOCKSCREEN_GENERAL_CATEGORY);
    PreferenceCategory widgetsCategory = (PreferenceCategory) findPreference(LOCKSCREEN_WIDGETS_CATEGORY);
    // Find preferences
    mEnableKeyguardWidgets = (CheckBoxPreference) findPreference(KEY_ENABLE_WIDGETS);
    mEnableCameraWidget = (CheckBoxPreference) findPreference(KEY_ENABLE_CAMERA);
    mBatteryStatus = (ListPreference) findPreference(KEY_BATTERY_STATUS);
    if (mBatteryStatus != null) {
        mBatteryStatus.setOnPreferenceChangeListener(this);
    }
    // Remove lockscreen button actions if device doesn't have hardware keys
    if (!hasButtons()) {
        generalCategory.removePreference(findPreference(KEY_LOCKSCREEN_BUTTONS));
    }
    // Enable or disable lockscreen widgets based on policy
    checkDisabledByPolicy(mEnableKeyguardWidgets, DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL);
    // Enable or disable camera widget based on device and policy
    if (Camera.getNumberOfCameras() == 0) {
        widgetsCategory.removePreference(mEnableCameraWidget);
        mEnableCameraWidget = null;
        mLockUtils.setCameraEnabled(false);
    } else if (mLockUtils.isSecure()) {
        checkDisabledByPolicy(mEnableCameraWidget, DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);
    }
    // Remove cLock settings item if not installed
    if (!Utils.isPackageInstalled(getActivity(), "com.cyanogenmod.lockclock")) {
        widgetsCategory.removePreference(findPreference(KEY_LOCK_CLOCK));
    }
    // Remove maximize widgets on tablets
    if (!Utils.isPhone(getActivity())) {
        widgetsCategory.removePreference(findPreference(Settings.System.LOCKSCREEN_MAXIMIZE_WIDGETS));
    }
    mLockBackground = (ListPreference) findPreference(LOCKSCREEN_BACKGROUND_STYLE);
    mLockBackground.setOnPreferenceChangeListener(this);
    mTempWallpaper = getActivity().getFileStreamPath(LOCKSCREEN_WALLPAPER_TEMP_NAME);
    mWallpaper = LockscreenBackgroundUtil.getWallpaperFile(getActivity());
}
#end_block

#method_before
@Override
public void onResume() {
    super.onResume();
    // Update custom widgets and camera
    if (mEnableKeyguardWidgets != null) {
        mEnableKeyguardWidgets.setChecked(mLockUtils.getWidgetsEnabled());
    }
    if (mEnableCameraWidget != null) {
        mEnableCameraWidget.setChecked(mLockUtils.getCameraEnabled());
    }
    // Update battery status
    if (mBatteryStatus != null) {
        ContentResolver cr = getActivity().getContentResolver();
        int batteryStatus = Settings.System.getInt(cr, Settings.System.LOCKSCREEN_BATTERY_VISIBILITY, 0);
        mBatteryStatus.setValueIndex(batteryStatus);
        mBatteryStatus.setSummary(mBatteryStatus.getEntries()[batteryStatus]);
    }
    updateVisiblePreferences();
}
#method_after
@Override
public void onResume() {
    super.onResume();
    // Update custom widgets and camera
    if (mEnableKeyguardWidgets != null) {
        mEnableKeyguardWidgets.setChecked(mLockUtils.getWidgetsEnabled());
    }
    if (mEnableCameraWidget != null) {
        mEnableCameraWidget.setChecked(mLockUtils.getCameraEnabled());
    }
    // Update battery status
    if (mBatteryStatus != null) {
        ContentResolver cr = getActivity().getContentResolver();
        int batteryStatus = Settings.System.getInt(cr, Settings.System.LOCKSCREEN_BATTERY_VISIBILITY, 0);
        mBatteryStatus.setValueIndex(batteryStatus);
        mBatteryStatus.setSummary(mBatteryStatus.getEntries()[batteryStatus]);
    }
    updateBackgroundPreference();
}
#end_block

#method_before
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver cr = getActivity().getContentResolver();
    if (preference == mBatteryStatus) {
        int value = Integer.valueOf((String) objValue);
        int index = mBatteryStatus.findIndexOfValue((String) objValue);
        Settings.System.putInt(cr, Settings.System.LOCKSCREEN_BATTERY_VISIBILITY, value);
        mBatteryStatus.setSummary(mBatteryStatus.getEntries()[index]);
        return true;
    } else if (preference == mLockBackground) {
        int index = mLockBackground.findIndexOfValue(objValue.toString());
        preference.setSummary(mLockBackground.getEntries()[index]);
        handleBackgroundSelection(index);
        return true;
    } else if (preference == mWallpaperAlpha) {
        float value = Float.parseFloat((String) objValue);
        Settings.System.putFloat(getContentResolver(), Settings.System.LOCKSCREEN_WALLPAPER_ALPHA, value / 100);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver cr = getActivity().getContentResolver();
    if (preference == mBatteryStatus) {
        int value = Integer.valueOf((String) objValue);
        int index = mBatteryStatus.findIndexOfValue((String) objValue);
        Settings.System.putInt(cr, Settings.System.LOCKSCREEN_BATTERY_VISIBILITY, value);
        mBatteryStatus.setSummary(mBatteryStatus.getEntries()[index]);
        return true;
    } else if (preference == mLockBackground) {
        int index = mLockBackground.findIndexOfValue((String) objValue);
        handleBackgroundSelection(index);
    }
    return false;
}
#end_block

#method_before
public boolean hasButtons() {
    return !getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar);
}
#method_after
public boolean hasButtons() {
    return (getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys) > 0);
}
#end_block

#method_before
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == REQUEST_PICK_WALLPAPER) {
        if (resultCode == Activity.RESULT_OK) {
            if (wallpaperTemporary.exists()) {
                wallpaperTemporary.renameTo(wallpaperImage);
            }
            wallpaperImage.setReadable(true, false);
            Toast.makeText(getActivity(), getResources().getString(R.string.background_result_successful), Toast.LENGTH_LONG).show();
            Settings.System.putInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_STYLE, 1);
            updateVisiblePreferences();
        } else {
            if (wallpaperTemporary.exists()) {
                wallpaperTemporary.delete();
            }
            Toast.makeText(getActivity(), getResources().getString(R.string.background_result_not_successful), Toast.LENGTH_LONG).show();
        }
    }
}
#method_after
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == REQUEST_PICK_WALLPAPER) {
        if (resultCode == Activity.RESULT_OK) {
            Uri uri = data != null ? data.getData() : null;
            if (uri == null) {
                uri = Uri.fromFile(mTempWallpaper);
            }
            new SaveUserWallpaperTask().execute(uri);
        } else {
            toastLockscreenWallpaperStatus(false);
        }
    }
}
#end_block

#method_before
private boolean handleBackgroundSelection(int index) {
    if (index == COLOR_FILL) {
        final ColorPickerView colorView = new ColorPickerView(getActivity());
        int currentColor = Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_COLOR, -1);
        if (currentColor != -1) {
            colorView.setColor(currentColor);
        }
        colorView.setAlphaSliderVisible(true);
        new AlertDialog.Builder(getActivity()).setTitle(R.string.background_color_fill_title).setPositiveButton(R.string.ok, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                Settings.System.putInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_STYLE, 0);
                Settings.System.putInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_COLOR, colorView.getColor());
                updateVisiblePreferences();
            }
        }).setNegativeButton(R.string.cancel, new DialogInterface.OnClickListener() {

            @Override
            public void onClick(DialogInterface dialog, int which) {
                dialog.dismiss();
            }
        }).setView(colorView).show();
    } else if (index == CUSTOM_IMAGE) {
        // Launches intent for user to select an image/crop it to set as background
        final Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
        intent.setType("image/*");
        intent.putExtra("crop", "true");
        intent.putExtra("scale", true);
        intent.putExtra("scaleUpIfNeeded", false);
        intent.putExtra("scaleType", 6);
        intent.putExtra("layout_width", -1);
        intent.putExtra("layout_height", -2);
        intent.putExtra("outputFormat", Bitmap.CompressFormat.PNG.toString());
        final Display display = getActivity().getWindowManager().getDefaultDisplay();
        boolean isPortrait = getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
        int width = display.getWidth();
        int height = display.getHeight();
        intent.putExtra("aspectX", isPortrait ? width : height);
        intent.putExtra("aspectY", isPortrait ? height : width);
        try {
            wallpaperTemporary.createNewFile();
            wallpaperTemporary.setWritable(true, false);
            intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(wallpaperTemporary));
            intent.putExtra("return-data", false);
            getActivity().startActivityFromFragment(this, intent, REQUEST_PICK_WALLPAPER);
        } catch (IOException e) {
        } catch (ActivityNotFoundException e) {
        }
    } else if (index == DEFAULT) {
        // Sets background to default
        Settings.System.putInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_STYLE, 2);
        updateVisiblePreferences();
        return true;
    }
    return false;
}
#method_after
private void handleBackgroundSelection(int index) {
    if (index == LockscreenBackgroundUtil.LOCKSCREEN_STYLE_IMAGE) {
        // Launches intent for user to select an image/crop it to set as background
        final Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
        intent.setType("image/*");
        intent.putExtra("crop", "true");
        intent.putExtra("scale", true);
        intent.putExtra("scaleUpIfNeeded", false);
        intent.putExtra("scaleType", 6);
        intent.putExtra("layout_width", -1);
        intent.putExtra("layout_height", -2);
        intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
        final Display display = getActivity().getWindowManager().getDefaultDisplay();
        boolean isPortrait = getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT;
        Point screenDimension = new Point();
        display.getSize(screenDimension);
        int width = screenDimension.x;
        int height = screenDimension.y;
        intent.putExtra("aspectX", isPortrait ? width : height);
        intent.putExtra("aspectY", isPortrait ? height : width);
        try {
            mTempWallpaper.createNewFile();
            mTempWallpaper.setWritable(true, false);
            intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(mTempWallpaper));
            intent.putExtra("return-data", false);
            getActivity().startActivityFromFragment(this, intent, REQUEST_PICK_WALLPAPER);
        } catch (IOException e) {
            toastLockscreenWallpaperStatus(false);
        } catch (ActivityNotFoundException e) {
            toastLockscreenWallpaperStatus(false);
        }
    } else if (index == LockscreenBackgroundUtil.LOCKSCREEN_STYLE_DEFAULT) {
        // Sets background to default
        Settings.System.putInt(getContentResolver(), Settings.System.LOCKSCREEN_BACKGROUND_STYLE, LockscreenBackgroundUtil.LOCKSCREEN_STYLE_DEFAULT);
        if (mWallpaper.exists()) {
            mWallpaper.delete();
        }
        updateKeyguardWallpaper();
        updateBackgroundPreference();
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.multi_sim_settings);
    mVoice = (ListPreference) findPreference(KEY_VOICE);
    mVoice.setOnPreferenceChangeListener(this);
    mData = (ListPreference) findPreference(KEY_DATA);
    mData.setOnPreferenceChangeListener(this);
    mSms = (ListPreference) findPreference(KEY_SMS);
    mSms.setOnPreferenceChangeListener(this);
    mConfigSub = (PreferenceScreen) findPreference(KEY_CONFIG_SUB);
    mConfigSub.getIntent().putExtra(CONFIG_SUB, true);
    mTuneAway = (CheckBoxPreference) findPreference(TUNE_AWAY);
    mTuneAway.setOnPreferenceChangeListener(this);
    mPrioritySub = (ListPreference) findPreference(PRIORITY_SUB);
    mPrioritySub.setOnPreferenceChangeListener(this);
    mPhone = MSimPhoneFactory.getPhone(MSimConstants.SUB1);
    for (int subId = 0; subId < SubscriptionManager.NUM_SUBSCRIPTIONS; subId++) {
        mSubManager.registerForSubscriptionActivated(subId, mHandler, EVENT_SUBSCRIPTION_ACTIVATED, null);
        mSubManager.registerForSubscriptionDeactivated(subId, mHandler, EVENT_SUBSCRIPTION_DEACTIVATED, null);
    }
    // Create and Intialize the strings required for MultiSIM
    // Dynamic creation of entries instead of using static array vlues.
    // entries are Subscription1, Subscription2, Subscription3 ....
    // EntryValues are 0, 1 ,2 ....
    // Summaries are Subscription1, Subscription2, Subscription3 ....
    entries = new CharSequence[MAX_SUBSCRIPTIONS];
    entryValues = new CharSequence[MAX_SUBSCRIPTIONS];
    summaries = new CharSequence[MAX_SUBSCRIPTIONS];
    entriesPrompt = new CharSequence[MAX_SUBSCRIPTIONS + 1];
    entryValuesPrompt = new CharSequence[MAX_SUBSCRIPTIONS + 1];
    summariesPrompt = new CharSequence[MAX_SUBSCRIPTIONS + 1];
    int i = 0;
    for (i = 0; i < MAX_SUBSCRIPTIONS; i++) {
        String operatorName = MSimTelephonyManager.getDefault().getNetworkOperatorName(i);
        entries[i] = operatorName;
        summaries[i] = operatorName;
        summariesPrompt[i] = operatorName;
        entriesPrompt[i] = operatorName;
        entryValues[i] = Integer.toString(i);
        entryValuesPrompt[i] = Integer.toString(i);
    }
    entryValuesPrompt[i] = Integer.toString(i);
    entriesPrompt[i] = getResources().getString(R.string.prompt);
    summariesPrompt[i] = getResources().getString(R.string.prompt_user);
    mReceiver = new AirplaneModeBroadcastReceiver();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.multi_sim_settings);
    mVoice = (ListPreference) findPreference(KEY_VOICE);
    mVoice.setOnPreferenceChangeListener(this);
    mData = (ListPreference) findPreference(KEY_DATA);
    mData.setOnPreferenceChangeListener(this);
    mSms = (ListPreference) findPreference(KEY_SMS);
    mSms.setOnPreferenceChangeListener(this);
    mConfigSub = (PreferenceScreen) findPreference(KEY_CONFIG_SUB);
    mConfigSub.getIntent().putExtra(CONFIG_SUB, true);
    mTuneAway = (CheckBoxPreference) findPreference(TUNE_AWAY);
    mTuneAway.setOnPreferenceChangeListener(this);
    mPrioritySub = (ListPreference) findPreference(PRIORITY_SUB);
    mPrioritySub.setOnPreferenceChangeListener(this);
    mPhone = MSimPhoneFactory.getPhone(MSimConstants.SUB1);
    for (int subId = 0; subId < SubscriptionManager.NUM_SUBSCRIPTIONS; subId++) {
        mSubManager.registerForSubscriptionActivated(subId, mHandler, EVENT_SUBSCRIPTION_ACTIVATED, null);
        mSubManager.registerForSubscriptionDeactivated(subId, mHandler, EVENT_SUBSCRIPTION_DEACTIVATED, null);
    }
    // Create and Intialize the strings required for MultiSIM
    // Dynamic creation of entries instead of using static array vlues.
    // entries are based on operatorName-slotNumber
    entries = new CharSequence[MAX_SUBSCRIPTIONS];
    entryValues = new CharSequence[MAX_SUBSCRIPTIONS];
    summaries = new CharSequence[MAX_SUBSCRIPTIONS];
    entriesPrompt = new CharSequence[MAX_SUBSCRIPTIONS + 1];
    entryValuesPrompt = new CharSequence[MAX_SUBSCRIPTIONS + 1];
    summariesPrompt = new CharSequence[MAX_SUBSCRIPTIONS + 1];
    MSimTelephonyManager tm = MSimTelephonyManager.getDefault();
    int i = 0;
    for (i = 0; i < MAX_SUBSCRIPTIONS; i++) {
        String operatorName = tm.getSimState(i) != SIM_STATE_ABSENT ? tm.getNetworkOperatorName(i) : getString(R.string.sub_no_sim);
        String label = getString(R.string.multi_sim_entry_format, operatorName, i + 1);
        entries[i] = summaries[i] = label;
        entriesPrompt[i] = summariesPrompt[i] = label;
        entryValues[i] = Integer.toString(i);
        entryValuesPrompt[i] = Integer.toString(i);
    }
    entryValuesPrompt[i] = Integer.toString(i);
    entriesPrompt[i] = getResources().getString(R.string.prompt);
    summariesPrompt[i] = getResources().getString(R.string.prompt_user);
    mReceiver = new AirplaneModeBroadcastReceiver();
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.lockscreen_interface_settings);
    mChooseLockSettingsHelper = new ChooseLockSettingsHelper(getActivity());
    mLockUtils = mChooseLockSettingsHelper.utils();
    mDPM = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
    // Find categories
    PreferenceCategory generalCategory = (PreferenceCategory) findPreference(LOCKSCREEN_GENERAL_CATEGORY);
    PreferenceCategory widgetsCategory = (PreferenceCategory) findPreference(LOCKSCREEN_WIDGETS_CATEGORY);
    // Find preferences
    mEnableKeyguardWidgets = (CheckBoxPreference) findPreference(KEY_ENABLE_WIDGETS);
    mEnableCameraWidget = (CheckBoxPreference) findPreference(KEY_ENABLE_CAMERA);
    mEnableMaximizeWidgets = (CheckBoxPreference) findPreference(KEY_ENABLE_MAXIMIZE_WIGETS);
    mEnableModLock = (CheckBoxPreference) findPreference(KEY_LOCKSCREEN_MODLOCK_ENABLED);
    if (mEnableModLock != null) {
        mEnableModLock.setOnPreferenceChangeListener(this);
    }
    mBatteryStatus = (ListPreference) findPreference(KEY_BATTERY_STATUS);
    if (mBatteryStatus != null) {
        mBatteryStatus.setOnPreferenceChangeListener(this);
    }
    // Remove lockscreen button actions if device doesn't have hardware keys
    if (!hasButtons()) {
        generalCategory.removePreference(findPreference(KEY_LOCKSCREEN_BUTTONS));
    }
    // Enable or disable camera widget based on device and policy
    if (Camera.getNumberOfCameras() == 0) {
        widgetsCategory.removePreference(mEnableCameraWidget);
        mEnableCameraWidget = null;
        mLockUtils.setCameraEnabled(false);
    } else if (mLockUtils.isSecure()) {
        checkDisabledByPolicy(mEnableCameraWidget, DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);
    }
    boolean canEnableModLockscreen = false;
    final Bundle keyguard_metadata = Utils.getApplicationMetadata(getActivity(), "com.android.keyguard");
    if (keyguard_metadata != null) {
        canEnableModLockscreen = keyguard_metadata.getBoolean("com.cyanogenmod.keyguard", false);
    }
    if (mEnableModLock != null && !canEnableModLockscreen) {
        generalCategory.removePreference(mEnableModLock);
        mEnableModLock = null;
    }
    // Remove cLock settings item if not installed
    if (!Utils.isPackageInstalled(getActivity(), "com.cyanogenmod.lockclock")) {
        widgetsCategory.removePreference(findPreference(KEY_LOCK_CLOCK));
    }
    // Remove maximize widgets on tablets
    if (!Utils.isPhone(getActivity())) {
        widgetsCategory.removePreference(mEnableMaximizeWidgets);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.lockscreen_interface_settings);
    mChooseLockSettingsHelper = new ChooseLockSettingsHelper(getActivity());
    mLockUtils = mChooseLockSettingsHelper.utils();
    mDPM = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
    // Find categories
    PreferenceCategory generalCategory = (PreferenceCategory) findPreference(LOCKSCREEN_GENERAL_CATEGORY);
    PreferenceCategory widgetsCategory = (PreferenceCategory) findPreference(LOCKSCREEN_WIDGETS_CATEGORY);
    // Find preferences
    mEnableKeyguardWidgets = (CheckBoxPreference) findPreference(KEY_ENABLE_WIDGETS);
    mEnableCameraWidget = (CheckBoxPreference) findPreference(KEY_ENABLE_CAMERA);
    mEnableMaximizeWidgets = (CheckBoxPreference) findPreference(KEY_ENABLE_MAXIMIZE_WIGETS);
    mLockscreenTargets = findPreference(KEY_LOCKSCREEN_TARGETS);
    mEnableModLock = (CheckBoxPreference) findPreference(KEY_LOCKSCREEN_MODLOCK_ENABLED);
    if (mEnableModLock != null) {
        mEnableModLock.setOnPreferenceChangeListener(this);
    }
    mBatteryStatus = (ListPreference) findPreference(KEY_BATTERY_STATUS);
    if (mBatteryStatus != null) {
        mBatteryStatus.setOnPreferenceChangeListener(this);
    }
    // Remove lockscreen button actions if device doesn't have hardware keys
    if (!hasButtons()) {
        generalCategory.removePreference(findPreference(KEY_LOCKSCREEN_BUTTONS));
    }
    // Enable or disable camera widget based on device and policy
    if (Camera.getNumberOfCameras() == 0) {
        widgetsCategory.removePreference(mEnableCameraWidget);
        mEnableCameraWidget = null;
        mLockUtils.setCameraEnabled(false);
    } else if (mLockUtils.isSecure()) {
        checkDisabledByPolicy(mEnableCameraWidget, DevicePolicyManager.KEYGUARD_DISABLE_SECURE_CAMERA);
    }
    boolean canEnableModLockscreen = false;
    final String keyguardPackage = getActivity().getString(com.android.internal.R.string.config_keyguardPackage);
    final Bundle keyguard_metadata = Utils.getApplicationMetadata(getActivity(), keyguardPackage);
    if (keyguard_metadata != null) {
        canEnableModLockscreen = keyguard_metadata.getBoolean("com.cyanogenmod.keyguard", false);
    }
    if (mEnableModLock != null && !canEnableModLockscreen) {
        generalCategory.removePreference(mEnableModLock);
        mEnableModLock = null;
    }
    // Remove cLock settings item if not installed
    if (!Utils.isPackageInstalled(getActivity(), "com.cyanogenmod.lockclock")) {
        widgetsCategory.removePreference(findPreference(KEY_LOCK_CLOCK));
    }
    // Remove maximize widgets on tablets
    if (!Utils.isPhone(getActivity())) {
        widgetsCategory.removePreference(mEnableMaximizeWidgets);
    }
}
#end_block

#method_before
private void updateAvailableModLockPreferences() {
    if (mEnableModLock == null) {
        return;
    }
    boolean enabled = !mEnableModLock.isChecked();
    if (mEnableKeyguardWidgets != null) {
        // Enable or disable lockscreen widgets based on policy
        if (!checkDisabledByPolicy(mEnableKeyguardWidgets, DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL)) {
            mEnableKeyguardWidgets.setEnabled(enabled);
        }
    }
    if (mEnableMaximizeWidgets != null) {
        mEnableMaximizeWidgets.setEnabled(enabled);
    }
}
#method_after
private void updateAvailableModLockPreferences() {
    if (mEnableModLock == null) {
        return;
    }
    boolean enabled = !mEnableModLock.isChecked();
    if (mEnableKeyguardWidgets != null) {
        // Enable or disable lockscreen widgets based on policy
        if (!checkDisabledByPolicy(mEnableKeyguardWidgets, DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL)) {
            mEnableKeyguardWidgets.setEnabled(enabled);
        }
    }
    if (mEnableMaximizeWidgets != null) {
        mEnableMaximizeWidgets.setEnabled(enabled);
    }
    if (mLockscreenTargets != null) {
        mLockscreenTargets.setEnabled(enabled);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    addPreferencesFromResource(R.xml.tether_prefs);
    final Activity activity = getActivity();
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter != null && adapter.getState() == BluetoothAdapter.STATE_ON) {
        adapter.getProfileProxy(activity.getApplicationContext(), mProfileServiceListener, BluetoothProfile.PAN);
    }
    Preference wifiApSettings = findPreference(WIFI_AP_SSID_AND_SECURITY);
    mUsbTether = (CheckBoxPreference) findPreference(USB_TETHER_SETTINGS);
    mBluetoothTether = (CheckBoxPreference) findPreference(ENABLE_BLUETOOTH_TETHERING);
    ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
    mUsbRegexs = cm.getTetherableUsbRegexs();
    mWifiRegexs = cm.getTetherableWifiRegexs();
    mBluetoothRegexs = cm.getTetherableBluetoothRegexs();
    final boolean usbAvailable = mUsbRegexs.length != 0;
    final boolean wifiAvailable = mWifiRegexs.length != 0;
    final boolean bluetoothAvailable = mBluetoothRegexs.length != 0;
    if (!usbAvailable || Utils.isMonkeyRunning()) {
        getPreferenceScreen().removePreference(mUsbTether);
    }
    if (!wifiAvailable && Utils.isMonkeyRunning()) {
        getPreferenceScreen().removePreference(wifiApSettings);
    }
    if (!bluetoothAvailable) {
        getPreferenceScreen().removePreference(mBluetoothTether);
    } else {
        BluetoothPan pan = mBluetoothPan.get();
        if (pan != null && pan.isTetheringOn()) {
            mBluetoothTether.setChecked(true);
        } else {
            mBluetoothTether.setChecked(false);
        }
    }
    mProvisionApp = getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app);
    mView = new WebView(activity);
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    addPreferencesFromResource(R.xml.tether_prefs);
    final Activity activity = getActivity();
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    if (adapter != null && adapter.getState() == BluetoothAdapter.STATE_ON) {
        adapter.getProfileProxy(activity.getApplicationContext(), mProfileServiceListener, BluetoothProfile.PAN);
    }
    Preference wifiApSettings = findPreference(KEY_WIFI_AP_SETTINGS);
    mUsbTether = (CheckBoxPreference) findPreference(USB_TETHER_SETTINGS);
    mBluetoothTether = (CheckBoxPreference) findPreference(ENABLE_BLUETOOTH_TETHERING);
    ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
    mUsbRegexs = cm.getTetherableUsbRegexs();
    mWifiRegexs = cm.getTetherableWifiRegexs();
    mBluetoothRegexs = cm.getTetherableBluetoothRegexs();
    final boolean usbAvailable = mUsbRegexs.length != 0;
    final boolean wifiAvailable = mWifiRegexs.length != 0;
    final boolean bluetoothAvailable = mBluetoothRegexs.length != 0;
    if (!usbAvailable || Utils.isMonkeyRunning()) {
        getPreferenceScreen().removePreference(mUsbTether);
    }
    if (!wifiAvailable && Utils.isMonkeyRunning()) {
        getPreferenceScreen().removePreference(wifiApSettings);
    }
    if (!bluetoothAvailable) {
        getPreferenceScreen().removePreference(mBluetoothTether);
    } else {
        BluetoothPan pan = mBluetoothPan.get();
        if (pan != null && pan.isTetheringOn()) {
            mBluetoothTether.setChecked(true);
        } else {
            mBluetoothTether.setChecked(false);
        }
    }
    mProvisionApp = getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app);
    mView = new WebView(activity);
}
#end_block

#method_before
@Override
public void onStart() {
    super.onStart();
    final Activity activity = getActivity();
    mMassStorageActive = Environment.MEDIA_SHARED.equals(Environment.getExternalStorageState());
    mTetherChangeReceiver = new TetherChangeReceiver();
    IntentFilter filter = new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    Intent intent = activity.registerReceiver(mTetherChangeReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(UsbManager.ACTION_USB_STATE);
    activity.registerReceiver(mTetherChangeReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_MEDIA_SHARED);
    filter.addAction(Intent.ACTION_MEDIA_UNSHARED);
    filter.addDataScheme("file");
    activity.registerReceiver(mTetherChangeReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
    activity.registerReceiver(mTetherChangeReceiver, filter);
    if (intent != null)
        mTetherChangeReceiver.onReceive(activity, intent);
    /*if (mWifiApEnabler != null) {
            mEnableWifiAp.setOnPreferenceChangeListener(this);
            mWifiApEnabler.resume();
        }*/
    updateState();
}
#method_after
@Override
public void onStart() {
    super.onStart();
    final Activity activity = getActivity();
    mMassStorageActive = Environment.MEDIA_SHARED.equals(Environment.getExternalStorageState());
    mTetherChangeReceiver = new TetherChangeReceiver();
    IntentFilter filter = new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED);
    Intent intent = activity.registerReceiver(mTetherChangeReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(UsbManager.ACTION_USB_STATE);
    activity.registerReceiver(mTetherChangeReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_MEDIA_SHARED);
    filter.addAction(Intent.ACTION_MEDIA_UNSHARED);
    filter.addDataScheme("file");
    activity.registerReceiver(mTetherChangeReceiver, filter);
    filter = new IntentFilter();
    filter.addAction(BluetoothAdapter.ACTION_STATE_CHANGED);
    activity.registerReceiver(mTetherChangeReceiver, filter);
    if (intent != null)
        mTetherChangeReceiver.onReceive(activity, intent);
    updateState();
}
#end_block

#method_before
@Override
public void onStop() {
    super.onStop();
    getActivity().unregisterReceiver(mTetherChangeReceiver);
    mTetherChangeReceiver = null;
/*if (mWifiApEnabler != null) {
            mEnableWifiAp.setOnPreferenceChangeListener(null);
            mWifiApEnabler.pause();
        }*/
}
#method_after
@Override
public void onStop() {
    super.onStop();
    getActivity().unregisterReceiver(mTetherChangeReceiver);
    mTetherChangeReceiver = null;
}
#end_block

#method_before
private void startTethering() {
    switch(mTetherChoice) {
        /*case WIFI_TETHERING:
                mWifiApEnabler.setSoftapEnabled(true);
                break;*/
        case BLUETOOTH_TETHERING:
            // turn on Bluetooth first
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            if (adapter != null) {
                if (adapter.getState() == BluetoothAdapter.STATE_OFF) {
                    // Get the Pan Profile proxy object while turning on BT
                    adapter.getProfileProxy(getActivity().getApplicationContext(), mProfileServiceListener, BluetoothProfile.PAN);
                    mBluetoothEnableForTether = true;
                    adapter.enable();
                    mBluetoothTether.setSummary(R.string.bluetooth_turning_on);
                    mBluetoothTether.setEnabled(false);
                } else {
                    BluetoothPan bluetoothPan = mBluetoothPan.get();
                    if (bluetoothPan != null)
                        bluetoothPan.setBluetoothTethering(true);
                    mBluetoothTether.setSummary(R.string.bluetooth_tethering_available_subtext);
                }
            }
            break;
        case USB_TETHERING:
            setUsbTethering(true);
            break;
        default:
            // should not happen
            break;
    }
}
#method_after
private void startTethering() {
    switch(mTetherChoice) {
        case BLUETOOTH_TETHERING:
            // turn on Bluetooth first
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            if (adapter != null) {
                if (adapter.getState() == BluetoothAdapter.STATE_OFF) {
                    // Get the Pan Profile proxy object while turning on BT
                    adapter.getProfileProxy(getActivity().getApplicationContext(), mProfileServiceListener, BluetoothProfile.PAN);
                    mBluetoothEnableForTether = true;
                    adapter.enable();
                    mBluetoothTether.setSummary(R.string.bluetooth_turning_on);
                    mBluetoothTether.setEnabled(false);
                } else {
                    BluetoothPan bluetoothPan = mBluetoothPan.get();
                    if (bluetoothPan != null)
                        bluetoothPan.setBluetoothTethering(true);
                    mBluetoothTether.setSummary(R.string.bluetooth_tethering_available_subtext);
                }
            }
            break;
        case USB_TETHERING:
            setUsbTethering(true);
            break;
        default:
            // should not happen
            break;
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    if (PROTECTED_ACTION.equals(intent.getAction())) {
        boolean protect = intent.getBooleanExtra(PROTECTED_STATE, PackageManager.COMPONENT_VISIBLE_STATUS);
        ArrayList<ComponentName> components = intent.getParcelableArrayListExtra(PROTECTED_COMPONENTS);
        if (components != null) {
            updateProtectedAppComponentsAndNotify(context, components, protect);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    if (ACTION_PROTECTED.equals(intent.getAction())) {
        boolean protect = intent.getBooleanExtra(EXTRA_PROTECTED_STATE, PackageManager.COMPONENT_VISIBLE_STATUS);
        ArrayList<ComponentName> components = intent.getParcelableArrayListExtra(EXTRA_PROTECTED_COMPONENTS);
        if (components != null) {
            updateProtectedAppComponentsAndNotify(context, components, protect);
        }
    }
}
#end_block

#method_before
public static void notifyProtectedChanged(Context context, ArrayList<ComponentName> components, boolean state) {
    Intent intent = new Intent(PROTECTED_CHANGED_ACTION);
    intent.putExtra(PROTECTED_STATE, state);
    intent.putExtra(PROTECTED_COMPONENTS, components);
    context.sendBroadcast(intent, PROTECTED_APP_PERMISSION);
}
#method_after
public static void notifyProtectedChanged(Context context, ArrayList<ComponentName> components, boolean state) {
    Intent intent = new Intent(ACTION_PROTECTED_CHANGED);
    intent.putExtra(EXTRA_PROTECTED_STATE, state);
    intent.putExtra(EXTRA_PROTECTED_COMPONENTS, components);
    context.sendBroadcast(intent, PROTECTED_APP_PERMISSION);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.zen_mode_priority_settings);
    final PreferenceScreen root = getPreferenceScreen();
    mReminders = (SwitchPreference) root.findPreference(KEY_REMINDERS);
    mReminders.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            if (mDisableListeners)
                return true;
            final boolean val = (Boolean) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_REMINDERS, val);
            if (val == mConfig.allowReminders)
                return true;
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowReminders=" + val);
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowReminders = val;
            return setZenModeConfig(newConfig);
        }
    });
    mEvents = (SwitchPreference) root.findPreference(KEY_EVENTS);
    mEvents.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            if (mDisableListeners)
                return true;
            final boolean val = (Boolean) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_EVENTS, val);
            if (val == mConfig.allowEvents)
                return true;
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowEvents=" + val);
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowEvents = val;
            return setZenModeConfig(newConfig);
        }
    });
    mMessages = (DropDownPreference) root.findPreference(KEY_MESSAGES);
    addSources(mMessages);
    mMessages.setCallback(new DropDownPreference.Callback() {

        @Override
        public boolean onItemSelected(int pos, Object newValue) {
            if (mDisableListeners)
                return true;
            final int val = (Integer) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_MESSAGES, val);
            final boolean allowMessages = val != SOURCE_NONE;
            final int allowMessagesFrom = val == SOURCE_NONE ? mConfig.allowMessagesFrom : val;
            if (allowMessages == mConfig.allowMessages && allowMessagesFrom == mConfig.allowMessagesFrom) {
                return true;
            }
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowMessages=" + allowMessages + " allowMessagesFrom=" + ZenModeConfig.sourceToString(allowMessagesFrom));
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowMessages = allowMessages;
            newConfig.allowMessagesFrom = allowMessagesFrom;
            return setZenModeConfig(newConfig);
        }
    });
    mCalls = (DropDownPreference) root.findPreference(KEY_CALLS);
    addSources(mCalls);
    mCalls.setCallback(new DropDownPreference.Callback() {

        @Override
        public boolean onItemSelected(int pos, Object newValue) {
            if (mDisableListeners)
                return true;
            final int val = (Integer) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_CALLS, val);
            final boolean allowCalls = val != SOURCE_NONE;
            final int allowCallsFrom = val == SOURCE_NONE ? mConfig.allowCallsFrom : val;
            if (allowCalls == mConfig.allowCalls && allowCallsFrom == mConfig.allowCallsFrom) {
                return true;
            }
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowCalls=" + allowCalls + " allowCallsFrom=" + ZenModeConfig.sourceToString(allowCallsFrom));
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowCalls = allowCalls;
            newConfig.allowCallsFrom = allowCallsFrom;
            return setZenModeConfig(newConfig);
        }
    });
    mRepeatCallers = (SwitchPreference) root.findPreference(KEY_REPEAT_CALLERS);
    mRepeatCallers.setSummary(mContext.getString(R.string.zen_mode_repeat_callers_summary, mContext.getResources().getInteger(com.android.internal.R.integer.config_zen_repeat_callers_threshold)));
    mRepeatCallers.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            if (mDisableListeners)
                return true;
            final boolean val = (Boolean) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_REPEAT_CALLS, val);
            if (val == mConfig.allowRepeatCallers)
                return true;
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowRepeatCallers=" + val);
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowRepeatCallers = val;
            return setZenModeConfig(newConfig);
        }
    });
    // Remove of the "Allow notification light" setting if an led is not supported
    if (!getResources().getBoolean(com.android.internal.R.bool.config_intrusiveNotificationLed)) {
        root.removePreference(findPreference(KEY_ALLOW_LIGHTS));
    }
    updateControls();
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.zen_mode_priority_settings);
    final PreferenceScreen root = getPreferenceScreen();
    mReminders = (SwitchPreference) root.findPreference(KEY_REMINDERS);
    mReminders.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            if (mDisableListeners)
                return true;
            final boolean val = (Boolean) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_REMINDERS, val);
            if (val == mConfig.allowReminders)
                return true;
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowReminders=" + val);
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowReminders = val;
            return setZenModeConfig(newConfig);
        }
    });
    mEvents = (SwitchPreference) root.findPreference(KEY_EVENTS);
    mEvents.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            if (mDisableListeners)
                return true;
            final boolean val = (Boolean) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_EVENTS, val);
            if (val == mConfig.allowEvents)
                return true;
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowEvents=" + val);
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowEvents = val;
            return setZenModeConfig(newConfig);
        }
    });
    mMessages = (DropDownPreference) root.findPreference(KEY_MESSAGES);
    addSources(mMessages);
    mMessages.setCallback(new DropDownPreference.Callback() {

        @Override
        public boolean onItemSelected(int pos, Object newValue) {
            if (mDisableListeners)
                return true;
            final int val = (Integer) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_MESSAGES, val);
            final boolean allowMessages = val != SOURCE_NONE;
            final int allowMessagesFrom = val == SOURCE_NONE ? mConfig.allowMessagesFrom : val;
            if (allowMessages == mConfig.allowMessages && allowMessagesFrom == mConfig.allowMessagesFrom) {
                return true;
            }
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowMessages=" + allowMessages + " allowMessagesFrom=" + ZenModeConfig.sourceToString(allowMessagesFrom));
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowMessages = allowMessages;
            newConfig.allowMessagesFrom = allowMessagesFrom;
            return setZenModeConfig(newConfig);
        }
    });
    mCalls = (DropDownPreference) root.findPreference(KEY_CALLS);
    addSources(mCalls);
    mCalls.setCallback(new DropDownPreference.Callback() {

        @Override
        public boolean onItemSelected(int pos, Object newValue) {
            if (mDisableListeners)
                return true;
            final int val = (Integer) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_CALLS, val);
            final boolean allowCalls = val != SOURCE_NONE;
            final int allowCallsFrom = val == SOURCE_NONE ? mConfig.allowCallsFrom : val;
            if (allowCalls == mConfig.allowCalls && allowCallsFrom == mConfig.allowCallsFrom) {
                return true;
            }
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowCalls=" + allowCalls + " allowCallsFrom=" + ZenModeConfig.sourceToString(allowCallsFrom));
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowCalls = allowCalls;
            newConfig.allowCallsFrom = allowCallsFrom;
            return setZenModeConfig(newConfig);
        }
    });
    mRepeatCallers = (SwitchPreference) root.findPreference(KEY_REPEAT_CALLERS);
    mRepeatCallers.setSummary(mContext.getString(R.string.zen_mode_repeat_callers_summary, mContext.getResources().getInteger(com.android.internal.R.integer.config_zen_repeat_callers_threshold)));
    mRepeatCallers.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

        @Override
        public boolean onPreferenceChange(Preference preference, Object newValue) {
            if (mDisableListeners)
                return true;
            final boolean val = (Boolean) newValue;
            MetricsLogger.action(mContext, MetricsLogger.ACTION_ZEN_ALLOW_REPEAT_CALLS, val);
            if (val == mConfig.allowRepeatCallers)
                return true;
            if (DEBUG)
                Log.d(TAG, "onPrefChange allowRepeatCallers=" + val);
            final ZenModeConfig newConfig = mConfig.copy();
            newConfig.allowRepeatCallers = val;
            return setZenModeConfig(newConfig);
        }
    });
    // Remove of the "Allow notification light" setting if LED is not supported
    if (!getResources().getBoolean(com.android.internal.R.bool.config_intrusiveNotificationLed)) {
        root.removePreference(findPreference(KEY_ALLOW_LIGHTS));
    }
    updateControls();
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.weather_settings);
    setHasOptionsMenu(true);
    final PreferenceScreen ps = getPreferenceScreen();
    mGeneralSettingsCategory = (PreferenceCategory) ps.findPreference(PREFERENCE_GENERAL);
    mProvidersCategory = (PreferenceCategory) ps.findPreference(PREFERENCE_PROVIDERS);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.weather_settings);
    final PreferenceScreen ps = getPreferenceScreen();
    mGeneralSettingsCategory = (PreferenceCategory) ps.findPreference(PREFERENCE_GENERAL);
    mProvidersCategory = (PreferenceCategory) ps.findPreference(PREFERENCE_PROVIDERS);
    mTemperatureUnit = (ListPreference) ps.findPreference(PREFERENCE_TEMP_UNIT);
    mTemperatureUnit.setOnPreferenceChangeListener(this);
}
#end_block

#method_before
@Override
public void onResume() {
    super.onResume();
    updateAdapter();
    registerPackageMonitor();
}
#method_after
@Override
public void onResume() {
    super.onResume();
    updateAdapter();
    registerPackageMonitor();
    mTemperatureUnit.setValue(String.valueOf(getSelectedTemperatureUnit(mContext)));
}
#end_block

#method_before
private void launchGetWeatherProviders() {
    try {
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(getString(R.string.weather_settings_play_store_market_url))));
    } catch (ActivityNotFoundException e) {
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(getString(R.string.weather_settings_play_store_http_url))));
    }
}
#method_after
private void launchGetWeatherProviders() {
    try {
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(getString(R.string.weather_settings_play_store_market_url))).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
    } catch (ActivityNotFoundException e) {
        startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(getString(R.string.weather_settings_play_store_http_url))).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
    }
}
#end_block

#method_before
private void updateAdapter() {
    final PackageManager pm = getContext().getPackageManager();
    final Intent intent = new Intent(WeatherProviderService.SERVICE_INTERFACE);
    List<ResolveInfo> resolveInfoList = pm.queryIntentServices(intent, PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
    List<WeatherProviderServiceInfo> weatherProviderServiceInfos = new ArrayList<>(resolveInfoList.size());
    ComponentName activeService = getEnabledWeatherServiceProvider();
    for (ResolveInfo resolveInfo : resolveInfoList) {
        if (resolveInfo.serviceInfo == null)
            continue;
        if (resolveInfo.serviceInfo.packageName == null || resolveInfo.serviceInfo.name == null) {
            // Really?
            continue;
        }
        if (!resolveInfo.serviceInfo.permission.equals(cyanogenmod.platform.Manifest.permission.BIND_WEATHER_PROVIDER_SERVICE)) {
            continue;
        }
        WeatherProviderServiceInfo serviceInfo = new WeatherProviderServiceInfo();
        serviceInfo.componentName = new ComponentName(resolveInfo.serviceInfo.packageName, resolveInfo.serviceInfo.name);
        serviceInfo.isActive = serviceInfo.componentName.equals(activeService);
        serviceInfo.caption = resolveInfo.loadLabel(pm);
        serviceInfo.icon = resolveInfo.loadIcon(pm);
        serviceInfo.settingsComponentName = getSettingsComponent(pm, resolveInfo);
        weatherProviderServiceInfos.add(serviceInfo);
    }
    final PreferenceScreen ps = getPreferenceScreen();
    if (!weatherProviderServiceInfos.isEmpty()) {
        if (ps.findPreference(PREFERENCE_GENERAL) == null) {
            ps.addPreference(mGeneralSettingsCategory);
        }
        if (ps.findPreference(PREFERENCE_PROVIDERS) == null) {
            ps.addPreference(mProvidersCategory);
        }
        mProvidersCategory.removeAll();
        for (WeatherProviderServiceInfo info : weatherProviderServiceInfos) {
            mProvidersCategory.addPreference(new WeatherProviderPreference(mContext, info));
        }
    } else {
        ps.removePreference(mGeneralSettingsCategory);
        ps.removePreference(mProvidersCategory);
    }
}
#method_after
private void updateAdapter() {
    final PackageManager pm = getContext().getPackageManager();
    final Intent intent = new Intent(WeatherProviderService.SERVICE_INTERFACE);
    List<ResolveInfo> resolveInfoList = pm.queryIntentServices(intent, PackageManager.GET_SERVICES | PackageManager.GET_META_DATA);
    List<WeatherProviderServiceInfo> weatherProviderServiceInfos = new ArrayList<>(resolveInfoList.size());
    ComponentName activeService = getEnabledWeatherServiceProvider();
    for (ResolveInfo resolveInfo : resolveInfoList) {
        if (resolveInfo.serviceInfo == null)
            continue;
        if (resolveInfo.serviceInfo.packageName == null || resolveInfo.serviceInfo.name == null) {
            // Really?
            continue;
        }
        if (!resolveInfo.serviceInfo.permission.equals(cyanogenmod.platform.Manifest.permission.BIND_WEATHER_PROVIDER_SERVICE)) {
            continue;
        }
        WeatherProviderServiceInfo serviceInfo = new WeatherProviderServiceInfo();
        serviceInfo.componentName = new ComponentName(resolveInfo.serviceInfo.packageName, resolveInfo.serviceInfo.name);
        serviceInfo.isActive = serviceInfo.componentName.equals(activeService);
        serviceInfo.caption = resolveInfo.loadLabel(pm);
        serviceInfo.icon = resolveInfo.loadIcon(pm);
        serviceInfo.settingsComponentName = getSettingsComponent(pm, resolveInfo);
        weatherProviderServiceInfos.add(serviceInfo);
    }
    final PreferenceScreen ps = getPreferenceScreen();
    if (!weatherProviderServiceInfos.isEmpty()) {
        if (ps.findPreference(PREFERENCE_GENERAL) == null) {
            ps.addPreference(mGeneralSettingsCategory);
        }
        if (ps.findPreference(PREFERENCE_PROVIDERS) == null) {
            ps.addPreference(mProvidersCategory);
        }
        mProvidersCategory.removeAll();
        for (WeatherProviderServiceInfo info : weatherProviderServiceInfos) {
            mProvidersCategory.addPreference(new WeatherProviderPreference(mContext, info));
        }
        Preference addServicePreference = new Preference(mContext);
        addServicePreference.setTitle(R.string.weather_settings_add_weather_provider);
        addServicePreference.setIcon(R.drawable.ic_add);
        addServicePreference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                launchGetWeatherProviders();
                return false;
            }
        });
        mProvidersCategory.addPreference(addServicePreference);
    } else {
        ps.removePreference(mGeneralSettingsCategory);
        ps.removePreference(mProvidersCategory);
    }
}
#end_block

#method_before
@Override
public void onClick(View v) {
    if (v == mSettingsButton) {
        launchSettingsActivity(mInfo);
    } else if (v == mView) {
        v.setPressed(true);
        setActiveWeatherProviderService();
    }
}
#method_after
@Override
public void onClick(View v) {
    if (v == mView) {
        v.setPressed(true);
        setActiveWeatherProviderService();
    }
    launchSettingsActivity(mInfo);
}
#end_block

#method_before
private void markAsActiveProvider() {
    // Check for current active provider
    int count = mProvidersCategory.getPreferenceCount();
    for (int index = 0; index < count; index++) {
        Preference p = mProvidersCategory.getPreference(index);
        if (p instanceof WeatherProviderPreference) {
            WeatherProviderPreference preference = (WeatherProviderPreference) p;
            if (preference.isActiveProvider()) {
                preference.setActiveState(false);
                break;
            }
        }
    }
    // Mark this provider as active
    setActiveState(true);
}
#method_after
private void markAsActiveProvider() {
    // Check for current active provider
    PreferenceCategory providersCategory = (PreferenceCategory) findPreferenceInHierarchy(WeatherServiceSettings.PREFERENCE_PROVIDERS);
    if (providersCategory != null) {
        final int count = providersCategory.getPreferenceCount();
        for (int index = 0; index < count; index++) {
            Preference p = providersCategory.getPreference(index);
            if (p instanceof WeatherProviderPreference) {
                WeatherProviderPreference preference = (WeatherProviderPreference) p;
                if (preference.isActiveProvider()) {
                    preference.setActiveState(false);
                    break;
                }
            }
        }
    }
    // Mark this provider as active
    setActiveState(true);
}
#end_block

#method_before
@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    ViewGroup contentRoot = (ViewGroup) getListView().getParent();
    View emptyView = getActivity().getLayoutInflater().inflate(R.layout.empty_weather_state, contentRoot, false);
    TextView emptyTextView = (TextView) emptyView.findViewById(R.id.message);
    emptyTextView.setText(R.string.weather_settings_no_services_prompt);
    contentRoot.addView(emptyView);
    ListView listView = getListView();
    listView.setEmptyView(emptyView);
}
#method_after
@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    ViewGroup contentRoot = (ViewGroup) getListView().getParent();
    View emptyView = getActivity().getLayoutInflater().inflate(R.layout.empty_weather_state, contentRoot, false);
    TextView emptyTextView = (TextView) emptyView.findViewById(R.id.message);
    emptyTextView.setText(R.string.weather_settings_no_services_prompt);
    Button addProviderButton = (Button) emptyView.findViewById(R.id.add_weather_provider);
    addProviderButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            launchGetWeatherProviders();
        }
    });
    contentRoot.addView(emptyView);
    ListView listView = getListView();
    listView.setEmptyView(emptyView);
}
#end_block

#method_before
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    mWindowManager = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
    mBackupManager = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
    mDpm = (DevicePolicyManager) getActivity().getSystemService(Context.DEVICE_POLICY_SERVICE);
    mUm = (UserManager) getSystemService(Context.USER_SERVICE);
    mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    if (android.os.Process.myUserHandle().getIdentifier() != UserHandle.USER_OWNER || mUm.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES) || Settings.Global.getInt(getActivity().getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
        // Block access to developer options if the user is not the owner, if user policy
        // restricts it, or if the device has not been provisioned
        mUnavailable = true;
        setPreferenceScreen(new PreferenceScreen(getActivity(), null));
        return;
    }
    addPreferencesFromResource(R.xml.development_prefs);
    final PreferenceGroup debugDebuggingCategory = (PreferenceGroup) findPreference(DEBUG_DEBUGGING_CATEGORY_KEY);
    mEnableAdb = findAndInitSwitchPref(ENABLE_ADB);
    mAdbNotify = (SwitchPreference) findPreference(ADB_NOTIFY);
    mAllPrefs.add(mAdbNotify);
    mAdbOverNetwork = findAndInitSwitchPref(ADB_TCPIP);
    mClearAdbKeys = findPreference(CLEAR_ADB_KEYS);
    if (!SystemProperties.getBoolean("ro.adb.secure", false)) {
        if (debugDebuggingCategory != null) {
            debugDebuggingCategory.removePreference(mClearAdbKeys);
        }
    }
    mAllPrefs.add(mClearAdbKeys);
    mEnableTerminal = findAndInitSwitchPref(ENABLE_TERMINAL);
    if (!isPackageInstalled(getActivity(), TERMINAL_APP_PACKAGE)) {
        debugDebuggingCategory.removePreference(mEnableTerminal);
        mEnableTerminal = null;
    }
    mBugreport = findPreference(BUGREPORT);
    mBugreportInPower = findAndInitSwitchPref(BUGREPORT_IN_POWER_KEY);
    mKeepScreenOn = addListPreference(KEEP_SCREEN_ON_MODES);
    mBtHciSnoopLog = findAndInitSwitchPref(BT_HCI_SNOOP_LOG);
    mEnableOemUnlock = findAndInitSwitchPref(ENABLE_OEM_UNLOCK);
    if (!showEnableOemUnlockPreference()) {
        removePreference(mEnableOemUnlock);
        mEnableOemUnlock = null;
    }
    mDebugViewAttributes = findAndInitSwitchPref(DEBUG_VIEW_ATTRIBUTES);
    mPassword = (PreferenceScreen) findPreference(LOCAL_BACKUP_PASSWORD);
    mAllPrefs.add(mPassword);
    mAdvancedReboot = findAndInitSwitchPref(ADVANCED_REBOOT_KEY);
    mUpdateRecovery = findAndInitSwitchPref(UPDATE_RECOVERY_KEY);
    mDevelopmentShortcut = findAndInitSwitchPref(DEVELOPMENT_SHORTCUT_KEY);
    if (!android.os.Process.myUserHandle().equals(UserHandle.OWNER)) {
        disableForUser(mEnableAdb);
        disableForUser(mClearAdbKeys);
        disableForUser(mEnableTerminal);
        disableForUser(mPassword);
        disableForUser(mAdvancedReboot);
        disableForUser(mUpdateRecovery);
        disableForUser(mDevelopmentShortcut);
    }
    mDebugAppPref = findPreference(DEBUG_APP_KEY);
    mAllPrefs.add(mDebugAppPref);
    mWaitForDebugger = findAndInitSwitchPref(WAIT_FOR_DEBUGGER_KEY);
    mMockLocationAppPref = findPreference(MOCK_LOCATION_APP_KEY);
    mAllPrefs.add(mMockLocationAppPref);
    mVerifyAppsOverUsb = (SwitchPreference) findPreference(VERIFY_APPS_OVER_USB_KEY);
    mAllPrefs.add(mVerifyAppsOverUsb);
    if (!showVerifierSetting()) {
        if (debugDebuggingCategory != null) {
            debugDebuggingCategory.removePreference(mVerifyAppsOverUsb);
        } else {
            mVerifyAppsOverUsb.setEnabled(false);
        }
    }
    mStrictMode = findAndInitSwitchPref(STRICT_MODE_KEY);
    mPointerLocation = findAndInitSwitchPref(POINTER_LOCATION_KEY);
    mShowTouches = findAndInitSwitchPref(SHOW_TOUCHES_KEY);
    mShowScreenUpdates = findAndInitSwitchPref(SHOW_SCREEN_UPDATES_KEY);
    mDisableOverlays = findAndInitSwitchPref(DISABLE_OVERLAYS_KEY);
    mShowCpuUsage = findAndInitSwitchPref(SHOW_CPU_USAGE_KEY);
    mForceHardwareUi = findAndInitSwitchPref(FORCE_HARDWARE_UI_KEY);
    mForceMsaa = findAndInitSwitchPref(FORCE_MSAA_KEY);
    mTrackFrameTime = addListPreference(TRACK_FRAME_TIME_KEY);
    mShowNonRectClip = addListPreference(SHOW_NON_RECTANGULAR_CLIP_KEY);
    mShowHwScreenUpdates = findAndInitSwitchPref(SHOW_HW_SCREEN_UPDATES_KEY);
    mShowHwLayersUpdates = findAndInitSwitchPref(SHOW_HW_LAYERS_UPDATES_KEY);
    mDebugLayout = findAndInitSwitchPref(DEBUG_LAYOUT_KEY);
    mForceRtlLayout = findAndInitSwitchPref(FORCE_RTL_LAYOUT_KEY);
    mDebugHwOverdraw = addListPreference(DEBUG_HW_OVERDRAW_KEY);
    mWifiDisplayCertification = findAndInitSwitchPref(WIFI_DISPLAY_CERTIFICATION_KEY);
    mWifiVerboseLogging = findAndInitSwitchPref(WIFI_VERBOSE_LOGGING_KEY);
    mWifiAggressiveHandover = findAndInitSwitchPref(WIFI_AGGRESSIVE_HANDOVER_KEY);
    mWifiAllowScansWithTraffic = findAndInitSwitchPref(WIFI_ALLOW_SCAN_WITH_TRAFFIC_KEY);
    mLegacyDhcpClient = findAndInitSwitchPref(WIFI_LEGACY_DHCP_CLIENT_KEY);
    mMobileDataAlwaysOn = findAndInitSwitchPref(MOBILE_DATA_ALWAYS_ON);
    mLogdSize = addListPreference(SELECT_LOGD_SIZE_KEY);
    mUsbConfiguration = addListPreference(USB_CONFIGURATION_KEY);
    mWindowAnimationScale = findAndInitAnimationScalePreference(WINDOW_ANIMATION_SCALE_KEY);
    mTransitionAnimationScale = findAndInitAnimationScalePreference(TRANSITION_ANIMATION_SCALE_KEY);
    mAnimatorDurationScale = findAndInitAnimationScalePreference(ANIMATOR_DURATION_SCALE_KEY);
    mOverlayDisplayDevices = addListPreference(OVERLAY_DISPLAY_DEVICES_KEY);
    mEnableMultiWindow = findAndInitSwitchPref(ENABLE_MULTI_WINDOW_KEY);
    if (!showEnableMultiWindowPreference()) {
        final PreferenceGroup drawingGroup = (PreferenceGroup) findPreference("debug_drawing_category");
        if (drawingGroup != null) {
            drawingGroup.removePreference(mEnableMultiWindow);
        } else {
            mEnableMultiWindow.setEnabled(false);
        }
        removePreference(mEnableMultiWindow);
        mEnableMultiWindow = null;
    }
    mOpenGLTraces = addListPreference(OPENGL_TRACES_KEY);
    mSimulateColorSpace = addListPreference(SIMULATE_COLOR_SPACE);
    mUSBAudio = findAndInitSwitchPref(USB_AUDIO_KEY);
    mImmediatelyDestroyActivities = (SwitchPreference) findPreference(IMMEDIATELY_DESTROY_ACTIVITIES_KEY);
    mAllPrefs.add(mImmediatelyDestroyActivities);
    mResetSwitchPrefs.add(mImmediatelyDestroyActivities);
    mAppProcessLimit = addListPreference(APP_PROCESS_LIMIT_KEY);
    mShowAllANRs = (SwitchPreference) findPreference(SHOW_ALL_ANRS_KEY);
    mAllPrefs.add(mShowAllANRs);
    mResetSwitchPrefs.add(mShowAllANRs);
    mKillAppLongpressBack = findAndInitSwitchPref(KILL_APP_LONGPRESS_BACK);
    Preference hdcpChecking = findPreference(HDCP_CHECKING_KEY);
    if (hdcpChecking != null) {
        mAllPrefs.add(hdcpChecking);
        removePreferenceForProduction(hdcpChecking);
    }
    mRootAccess = (ListPreference) findPreference(ROOT_ACCESS_KEY);
    mRootAccess.setOnPreferenceChangeListener(this);
    Log.i(TAG, "Root: setting root pref");
    if (!removeRootOptionsIfRequired()) {
        if (isRootForAppsAvailable()) {
            Log.i(TAG, "Root: su available");
            mRootAccess.setEntries(R.array.root_access_entries);
            mRootAccess.setEntryValues(R.array.root_access_values);
        } else {
            Log.i(TAG, "Root: su missing");
            mRootAccess.setEntries(R.array.root_access_entries_adb);
            mRootAccess.setEntryValues(R.array.root_access_values_adb);
        }
        mAllPrefs.add(mRootAccess);
    }
    mDevelopmentTools = (PreferenceScreen) findPreference(DEVELOPMENT_TOOLS);
    if (Utils.updatePreferenceToSpecificActivityOrRemove(getActivity(), getPreferenceScreen(), mDevelopmentTools.getKey(), 0)) {
        mAllPrefs.add(mDevelopmentTools);
    }
    mColorModePreference = (ColorModePreference) findPreference(KEY_COLOR_MODE);
    mColorModePreference.updateCurrentAndSupported();
    if (mColorModePreference.getTransformsCount() < 2) {
        removePreference(KEY_COLOR_MODE);
        mColorModePreference = null;
    }
    mColorTemperaturePreference = (SwitchPreference) findPreference(COLOR_TEMPERATURE_KEY);
    if (getResources().getBoolean(R.bool.config_enableColorTemperature)) {
        mAllPrefs.add(mColorTemperaturePreference);
        mResetSwitchPrefs.add(mColorTemperaturePreference);
    } else {
        removePreference(COLOR_TEMPERATURE_KEY);
        mColorTemperaturePreference = null;
    }
}
#method_after
@Override
public void onCreate(Bundle icicle) {
    super.onCreate(icicle);
    mWindowManager = IWindowManager.Stub.asInterface(ServiceManager.getService("window"));
    mBackupManager = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
    mDpm = (DevicePolicyManager) getActivity().getSystemService(Context.DEVICE_POLICY_SERVICE);
    mUm = (UserManager) getSystemService(Context.USER_SERVICE);
    mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    if (android.os.Process.myUserHandle().getIdentifier() != UserHandle.USER_OWNER || mUm.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES) || Settings.Global.getInt(getActivity().getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
        // Block access to developer options if the user is not the owner, if user policy
        // restricts it, or if the device has not been provisioned
        mUnavailable = true;
        setPreferenceScreen(new PreferenceScreen(getActivity(), null));
        return;
    }
    addPreferencesFromResource(R.xml.development_prefs);
    final PreferenceGroup debugDebuggingCategory = (PreferenceGroup) findPreference(DEBUG_DEBUGGING_CATEGORY_KEY);
    mEnableAdb = findAndInitSwitchPref(ENABLE_ADB);
    mAdbNotify = (SwitchPreference) findPreference(ADB_NOTIFY);
    mAllPrefs.add(mAdbNotify);
    mAdbOverNetwork = findAndInitSwitchPref(ADB_TCPIP);
    mClearAdbKeys = findPreference(CLEAR_ADB_KEYS);
    if (!SystemProperties.getBoolean("ro.adb.secure", false)) {
        if (debugDebuggingCategory != null) {
            debugDebuggingCategory.removePreference(mClearAdbKeys);
        }
    }
    mAllPrefs.add(mClearAdbKeys);
    mEnableTerminal = findAndInitSwitchPref(ENABLE_TERMINAL);
    if (!isPackageInstalled(getActivity(), TERMINAL_APP_PACKAGE)) {
        debugDebuggingCategory.removePreference(mEnableTerminal);
        mEnableTerminal = null;
    }
    mBugreport = findPreference(BUGREPORT);
    mBugreportInPower = findAndInitSwitchPref(BUGREPORT_IN_POWER_KEY);
    mKeepScreenOn = addListPreference(KEEP_SCREEN_ON_MODES);
    mBtHciSnoopLog = findAndInitSwitchPref(BT_HCI_SNOOP_LOG);
    mEnableOemUnlock = findAndInitSwitchPref(ENABLE_OEM_UNLOCK);
    if (!showEnableOemUnlockPreference()) {
        removePreference(mEnableOemUnlock);
        mEnableOemUnlock = null;
    }
    mDebugViewAttributes = findAndInitSwitchPref(DEBUG_VIEW_ATTRIBUTES);
    mPassword = (PreferenceScreen) findPreference(LOCAL_BACKUP_PASSWORD);
    mAllPrefs.add(mPassword);
    mAdvancedReboot = findAndInitSwitchPref(ADVANCED_REBOOT_KEY);
    mUpdateRecovery = findAndInitSwitchPref(UPDATE_RECOVERY_KEY);
    mDevelopmentShortcut = findAndInitSwitchPref(DEVELOPMENT_SHORTCUT_KEY);
    if (!android.os.Process.myUserHandle().equals(UserHandle.OWNER)) {
        disableForUser(mEnableAdb);
        disableForUser(mClearAdbKeys);
        disableForUser(mEnableTerminal);
        disableForUser(mPassword);
        disableForUser(mAdvancedReboot);
        disableForUser(mUpdateRecovery);
        disableForUser(mDevelopmentShortcut);
    }
    mDebugAppPref = findPreference(DEBUG_APP_KEY);
    mAllPrefs.add(mDebugAppPref);
    mWaitForDebugger = findAndInitSwitchPref(WAIT_FOR_DEBUGGER_KEY);
    mMockLocationAppPref = findPreference(MOCK_LOCATION_APP_KEY);
    mAllPrefs.add(mMockLocationAppPref);
    mVerifyAppsOverUsb = (SwitchPreference) findPreference(VERIFY_APPS_OVER_USB_KEY);
    mAllPrefs.add(mVerifyAppsOverUsb);
    if (!showVerifierSetting()) {
        if (debugDebuggingCategory != null) {
            debugDebuggingCategory.removePreference(mVerifyAppsOverUsb);
        } else {
            mVerifyAppsOverUsb.setEnabled(false);
        }
    }
    mStrictMode = findAndInitSwitchPref(STRICT_MODE_KEY);
    mPointerLocation = findAndInitSwitchPref(POINTER_LOCATION_KEY);
    mShowTouches = findAndInitSwitchPref(SHOW_TOUCHES_KEY);
    mShowScreenUpdates = findAndInitSwitchPref(SHOW_SCREEN_UPDATES_KEY);
    mDisableOverlays = findAndInitSwitchPref(DISABLE_OVERLAYS_KEY);
    mShowCpuUsage = findAndInitSwitchPref(SHOW_CPU_USAGE_KEY);
    mForceHardwareUi = findAndInitSwitchPref(FORCE_HARDWARE_UI_KEY);
    mForceMsaa = findAndInitSwitchPref(FORCE_MSAA_KEY);
    mTrackFrameTime = addListPreference(TRACK_FRAME_TIME_KEY);
    mShowNonRectClip = addListPreference(SHOW_NON_RECTANGULAR_CLIP_KEY);
    mShowHwScreenUpdates = findAndInitSwitchPref(SHOW_HW_SCREEN_UPDATES_KEY);
    mShowHwLayersUpdates = findAndInitSwitchPref(SHOW_HW_LAYERS_UPDATES_KEY);
    mDebugLayout = findAndInitSwitchPref(DEBUG_LAYOUT_KEY);
    mForceRtlLayout = findAndInitSwitchPref(FORCE_RTL_LAYOUT_KEY);
    mDebugHwOverdraw = addListPreference(DEBUG_HW_OVERDRAW_KEY);
    mWifiDisplayCertification = findAndInitSwitchPref(WIFI_DISPLAY_CERTIFICATION_KEY);
    mWifiVerboseLogging = findAndInitSwitchPref(WIFI_VERBOSE_LOGGING_KEY);
    mWifiAggressiveHandover = findAndInitSwitchPref(WIFI_AGGRESSIVE_HANDOVER_KEY);
    mWifiAllowScansWithTraffic = findAndInitSwitchPref(WIFI_ALLOW_SCAN_WITH_TRAFFIC_KEY);
    mLegacyDhcpClient = findAndInitSwitchPref(WIFI_LEGACY_DHCP_CLIENT_KEY);
    mMobileDataAlwaysOn = findAndInitSwitchPref(MOBILE_DATA_ALWAYS_ON);
    mLogdSize = addListPreference(SELECT_LOGD_SIZE_KEY);
    mUsbConfiguration = addListPreference(USB_CONFIGURATION_KEY);
    mWindowAnimationScale = findAndInitAnimationScalePreference(WINDOW_ANIMATION_SCALE_KEY);
    mTransitionAnimationScale = findAndInitAnimationScalePreference(TRANSITION_ANIMATION_SCALE_KEY);
    mAnimatorDurationScale = findAndInitAnimationScalePreference(ANIMATOR_DURATION_SCALE_KEY);
    mOverlayDisplayDevices = addListPreference(OVERLAY_DISPLAY_DEVICES_KEY);
    mEnableMultiWindow = findAndInitSwitchPref(ENABLE_MULTI_WINDOW_KEY);
    if (!showEnableMultiWindowPreference()) {
        final PreferenceGroup drawingGroup = (PreferenceGroup) findPreference("debug_drawing_category");
        if (drawingGroup != null) {
            drawingGroup.removePreference(mEnableMultiWindow);
        } else {
            mEnableMultiWindow.setEnabled(false);
        }
        removePreference(mEnableMultiWindow);
        mEnableMultiWindow = null;
    }
    mOpenGLTraces = addListPreference(OPENGL_TRACES_KEY);
    mSimulateColorSpace = addListPreference(SIMULATE_COLOR_SPACE);
    mUSBAudio = findAndInitSwitchPref(USB_AUDIO_KEY);
    mImmediatelyDestroyActivities = (SwitchPreference) findPreference(IMMEDIATELY_DESTROY_ACTIVITIES_KEY);
    mAllPrefs.add(mImmediatelyDestroyActivities);
    mResetSwitchPrefs.add(mImmediatelyDestroyActivities);
    mAppProcessLimit = addListPreference(APP_PROCESS_LIMIT_KEY);
    mShowAllANRs = (SwitchPreference) findPreference(SHOW_ALL_ANRS_KEY);
    mAllPrefs.add(mShowAllANRs);
    mResetSwitchPrefs.add(mShowAllANRs);
    mKillAppLongpressBack = findAndInitSwitchPref(KILL_APP_LONGPRESS_BACK);
    Preference hdcpChecking = findPreference(HDCP_CHECKING_KEY);
    if (hdcpChecking != null) {
        mAllPrefs.add(hdcpChecking);
        removePreferenceForProduction(hdcpChecking);
    }
    mRootAccess = (ListPreference) findPreference(ROOT_ACCESS_KEY);
    mRootAccess.setOnPreferenceChangeListener(this);
    if (!removeRootOptionsIfRequired()) {
        if (isRootForAppsAvailable()) {
            mRootAccess.setEntries(R.array.root_access_entries);
            mRootAccess.setEntryValues(R.array.root_access_values);
        } else {
            mRootAccess.setEntries(R.array.root_access_entries_adb);
            mRootAccess.setEntryValues(R.array.root_access_values_adb);
        }
        mAllPrefs.add(mRootAccess);
    }
    mDevelopmentTools = (PreferenceScreen) findPreference(DEVELOPMENT_TOOLS);
    if (Utils.updatePreferenceToSpecificActivityOrRemove(getActivity(), getPreferenceScreen(), mDevelopmentTools.getKey(), 0)) {
        mAllPrefs.add(mDevelopmentTools);
    }
    mColorModePreference = (ColorModePreference) findPreference(KEY_COLOR_MODE);
    mColorModePreference.updateCurrentAndSupported();
    if (mColorModePreference.getTransformsCount() < 2) {
        removePreference(KEY_COLOR_MODE);
        mColorModePreference = null;
    }
    mColorTemperaturePreference = (SwitchPreference) findPreference(COLOR_TEMPERATURE_KEY);
    if (getResources().getBoolean(R.bool.config_enableColorTemperature)) {
        mAllPrefs.add(mColorTemperaturePreference);
        mResetSwitchPrefs.add(mColorTemperaturePreference);
    } else {
        removePreference(COLOR_TEMPERATURE_KEY);
        mColorTemperaturePreference = null;
    }
}
#end_block

#method_before
public boolean isRootForAppsAvailable() {
    File f = new File("/system/xbin/su");
    return f.exists();
}
#method_after
private boolean isRootForAppsAvailable() {
    boolean exists = false;
    try {
        File f = new File(SUPERUSER_BINARY_PATH);
        exists = f.exists();
    } catch (SecurityException e) {
    // Ignore
    }
    return exists;
}
#end_block

#method_before
public void setSoftapEnabled(boolean enable) {
    int wifiSavedState = 0;
    /**
     * Check if we have to wait for the WIFI_STATE_CHANGED intent
     * before we re-enable the Checkbox.
     */
    if (!enable) {
        try {
            wifiSavedState = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WIFI_SAVED_STATE);
        } catch (Settings.SettingNotFoundException e) {
            ;
        }
        /**
         * If Wi-Fi is turned of as part of SoftAp turn on process,
         * we need to restore, Wi-Fi state after SoftAp turn Off.
         * WIFI_SAVED_STATE inficates the state.
         */
        if (wifiSavedState == 1) {
            mWaitForWifiStateChange = true;
        }
    }
    if (TetherUtil.setWifiTethering(enable, mContext)) {
        /* Disable here, enabled on receiving success broadcast */
        mSwitch.setEnabled(false);
    } else {
        mSwitch.setSummary(R.string.wifi_error);
    }
}
#method_after
public void setSoftapEnabled(boolean enable) {
    if (!enable) {
        mWaitForWifiStateChange = (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WIFI_SAVED_STATE, 0) == 1);
    }
    if (TetherUtil.setWifiTethering(enable, mContext)) {
        /* Disable here, enabled on receiving success broadcast */
        mSwitch.setEnabled(false);
    } else {
        mSwitch.setSummary(R.string.wifi_error);
    }
}
#end_block

#method_before
private void updateHotspotTimeoutSummary(WifiConfiguration wifiConfig) {
    if (wifiConfig == null) {
        mHotspotInactivityTimeout.setValue("0");
        mHotspotInactivityTimeout.setSummary(getString(R.string.hotstpot_inactivity_timeout_never_summary_text));
    } else {
        mHotspotInactivityTimeout.setValue(Long.toString(wifiConfig.wifiApInactivityTimeout));
        if (wifiConfig.wifiApInactivityTimeout > 0) {
            mHotspotInactivityTimeout.setSummary(String.format(getString(R.string.hotstpot_inactivity_timeout_summary_text, mHotspotInactivityTimeout.getEntry())));
        } else {
            mHotspotInactivityTimeout.setSummary(getString(R.string.hotstpot_inactivity_timeout_never_summary_text));
        }
    }
}
#method_after
private void updateHotspotTimeoutSummary(WifiConfiguration wifiConfig) {
    mHotspotInactivityTimeout.setValue((wifiConfig == null) ? "0" : Long.toString(wifiConfig.wifiApInactivityTimeout));
    mHotspotInactivityTimeout.setSummary(String.format(getString(R.string.hotstpot_inactivity_timeout_summary_text, mHotspotInactivityTimeout.getEntry())));
}
#end_block

#method_before
// === Pulse notification light ===
private void initPulse() {
    mNotificationCategory = (PreferenceCategory) findPreference(KEY_LIGHTS);
    mNotificationPulse = (TwoStatePreference) mNotificationCategory.findPreference(KEY_NOTIFICATION_PULSE);
    if (mNotificationPulse == null) {
        Log.i(TAG, "Preference not found: " + KEY_NOTIFICATION_PULSE);
        return;
    }
    if (!getResources().getBoolean(com.android.internal.R.bool.config_intrusiveNotificationLed)) {
        mNotificationCategory.removePreference(mNotificationPulse);
    } else {
        updatePulse();
        mNotificationPulse.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final boolean val = (Boolean) newValue;
                return Settings.System.putInt(getContentResolver(), Settings.System.NOTIFICATION_LIGHT_PULSE, val ? 1 : 0);
            }
        });
    }
}
#method_after
// === Pulse notification light ===
private void initPulse() {
    final PreferenceCategory category = (PreferenceCategory) findPreference("lights");
    mNotificationPulse = (TwoStatePreference) category.findPreference(KEY_NOTIFICATION_PULSE);
    if (mNotificationPulse == null) {
        Log.i(TAG, "Preference not found: " + KEY_NOTIFICATION_PULSE);
        return;
    }
    if (!getResources().getBoolean(com.android.internal.R.bool.config_intrusiveNotificationLed)) {
        category.removePreference(mNotificationPulse);
    } else {
        updatePulse();
        mNotificationPulse.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                final boolean val = (Boolean) newValue;
                return Settings.System.putInt(getContentResolver(), Settings.System.NOTIFICATION_LIGHT_PULSE, val ? 1 : 0);
            }
        });
    }
}
#end_block

#method_before
@Override
public void creditInfoUpdated(GetCreditInfoResult gcir) throws RemoteException {
    if (DEBUG) {
        Log.d(TAG, "getting creditInfoUpdated for: " + mComponentName + " gcir: " + gcir);
    }
    InCallResults.updateCreditInfo(mContext, mComponentName, gcir);
}
#method_after
@Override
public void creditInfoUpdated(GetCreditInfoResult gcir) throws RemoteException {
    if (DEBUG) {
        Log.d(TAG, "got creditInfoUpdated for: " + mComponentName + " gcir: " + gcir);
    }
    InCallResults.updateCreditInfo(DialerDataSubscription.get(mContext), mComponentName, gcir);
}
#end_block

#method_before
@Override
public void onDynamicRefreshRequested(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodAuthenticated(mContext, componentName));
    queries.add(InCallQueries.getCallMethodAccountHandle(mContext, componentName));
}
#method_after
@Override
public void onDynamicRefreshRequested(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodAuthenticated(mClient, componentName));
    queries.add(InCallQueries.getCallMethodAccountHandle(mClient, componentName));
}
#end_block

#method_before
@Override
protected void enableListeners(CallMethodInfo mod) {
    InCallListeners.enableAuthListener(mContext, mod);
}
#method_after
@Override
protected void enableListeners(CallMethodInfo mod) {
    InCallListeners.enableAuthListener(this, mod);
}
#end_block

#method_before
@Override
protected void disableListeners(CallMethodInfo mod) {
    InCallListeners.disableAuthListener(mContext, mod);
}
#method_after
@Override
protected void disableListeners(CallMethodInfo mod) {
    InCallListeners.disableAuthListener(this, mod);
}
#end_block

#method_before
@Override
protected void requestedModInfo(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodInfo(mContext, componentName));
    queries.add(InCallQueries.getCallMethodStatus(mContext, componentName));
    queries.add(InCallQueries.getCallMethodMimeType(mContext, componentName));
    queries.add(InCallQueries.getCallMethodVideoCallableMimeType(mContext, componentName));
    queries.add(InCallQueries.getCallMethodAuthenticated(mContext, componentName));
    queries.add(InCallQueries.getLoginIntent(mContext, componentName));
    queries.add(InCallQueries.getDefaultDirectorySearchIntent(mContext, componentName));
    queries.add(InCallQueries.getCallMethodImMimeType(mContext, componentName));
    TypedPendingResult fragLogin = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CONTACT_FRAGMENT_LOGIN);
    if (fragLogin != null) {
        queries.add(fragLogin);
    }
    TypedPendingResult cardLogin = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CONTACT_CARD_LOGIN);
    if (cardLogin != null) {
        queries.add(cardLogin);
    }
    TypedPendingResult cardDownload = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CONTACT_CARD_DOWNLOAD);
    if (cardDownload != null) {
        queries.add(cardDownload);
    }
}
#method_after
@Override
protected void requestedModInfo(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodInfo(mClient, componentName));
    queries.add(InCallQueries.getCallMethodStatus(mClient, componentName));
    queries.add(InCallQueries.getCallMethodMimeType(mClient, componentName));
    queries.add(InCallQueries.getCallMethodVideoCallableMimeType(mClient, componentName));
    queries.add(InCallQueries.getCallMethodAuthenticated(mClient, componentName));
    queries.add(InCallQueries.getLoginIntent(mClient, componentName));
    queries.add(InCallQueries.getDefaultDirectorySearchIntent(mClient, componentName));
    queries.add(InCallQueries.getCallMethodImMimeType(mClient, componentName));
    TypedPendingResult fragLogin = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CONTACT_FRAGMENT_LOGIN);
    if (fragLogin != null) {
        queries.add(fragLogin);
    }
    TypedPendingResult cardLogin = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CONTACT_CARD_LOGIN);
    if (cardLogin != null) {
        queries.add(cardLogin);
    }
    TypedPendingResult cardDownload = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CONTACT_CARD_DOWNLOAD);
    if (cardDownload != null) {
        queries.add(cardDownload);
    }
}
#end_block

#method_before
public Set<String> getAllPluginComponentNames() {
    Set<String> names = new HashSet<String>();
    HashMap<ComponentName, CallMethodInfo> plugins = get(mContext).getPluginInfo();
    for (ComponentName cn : plugins.keySet()) {
        names.add(cn.flattenToString());
    }
    return names;
}
#method_after
public Set<String> getAllPluginComponentNames() {
    Set<String> names = new HashSet<String>();
    HashMap<ComponentName, CallMethodInfo> plugins = this.getPluginInfo();
    for (ComponentName cn : plugins.keySet()) {
        names.add(cn.flattenToString());
    }
    return names;
}
#end_block

#method_before
private static String getMimeTypes(Context c, boolean enabledOnly, int mimeID) {
    String mimeTypes = "";
    List<String> mimeTypesList = new ArrayList<>();
    for (CallMethodInfo cmi : getInstance(c).getPluginInfo().values()) {
        String mimeType = null;
        switch(mimeID) {
            case GENERAL_MIME_TYPE:
                mimeType = cmi.mMimeType;
                break;
            case IM_MIME_TYPE:
                mimeType = cmi.mVideoCallableMimeType;
                break;
            case VIDEO_MIME_TYPE:
                mimeType = cmi.mImMimeType;
        }
        if (!enabledOnly) {
            mimeTypesList.add(mimeType);
            continue;
        }
        if (cmi.mStatus == PluginStatus.ENABLED) {
            mimeTypesList.add(mimeType);
        }
    }
    if (!mimeTypesList.isEmpty()) {
        mimeTypes = Joiner.on(",").skipNulls().join(mimeTypesList);
    }
    return mimeTypes;
}
#method_after
private static String getMimeTypes(AmbientDataSubscription<CallMethodInfo> instance, boolean enabledOnly, int mimeID) {
    String mimeTypes = "";
    List<String> mimeTypesList = new ArrayList<>();
    for (CallMethodInfo cmi : instance.getPluginInfo().values()) {
        String mimeType = null;
        switch(mimeID) {
            case GENERAL_MIME_TYPE:
                mimeType = cmi.mMimeType;
                break;
            case IM_MIME_TYPE:
                mimeType = cmi.mVideoCallableMimeType;
                break;
            case VIDEO_MIME_TYPE:
                mimeType = cmi.mImMimeType;
        }
        if (!enabledOnly) {
            mimeTypesList.add(mimeType);
            continue;
        }
        if (cmi.mStatus == PluginStatus.ENABLED) {
            mimeTypesList.add(mimeType);
        }
    }
    if (!mimeTypesList.isEmpty()) {
        mimeTypes = Joiner.on(",").skipNulls().join(mimeTypesList);
    }
    return mimeTypes;
}
#end_block

#method_before
public static String getAllMimeTypes(Context c) {
    return getMimeTypes(c, false, GENERAL_MIME_TYPE);
}
#method_after
public static String getAllMimeTypes(AmbientDataSubscription<CallMethodInfo> instance) {
    return getMimeTypes(instance, false, GENERAL_MIME_TYPE);
}
#end_block

#method_before
public static String getAllEnabledMimeTypes(Context c) {
    return getMimeTypes(c, true, GENERAL_MIME_TYPE);
}
#method_after
public static String getAllEnabledMimeTypes(AmbientDataSubscription<CallMethodInfo> instance) {
    return getMimeTypes(instance, true, GENERAL_MIME_TYPE);
}
#end_block

#method_before
public static String getAllEnabledVideoCallableMimeTypes(Context c) {
    return getMimeTypes(c, true, VIDEO_MIME_TYPE);
}
#method_after
public static String getAllEnabledVideoCallableMimeTypes(AmbientDataSubscription<CallMethodInfo> instance) {
    return getMimeTypes(instance, true, VIDEO_MIME_TYPE);
}
#end_block

#method_before
public static String getAllEnabledImMimeTypes(Context c) {
    return getMimeTypes(c, true, IM_MIME_TYPE);
}
#method_after
public static String getAllEnabledImMimeTypes(AmbientDataSubscription<CallMethodInfo> instance) {
    return getMimeTypes(instance, true, IM_MIME_TYPE);
}
#end_block

#method_before
public static Set<String> getAllEnabledVideoImMimeSet(Context c) {
    String[] videoMimes = getAllEnabledVideoCallableMimeTypes(c).split(",");
    String[] imMimes = getAllEnabledImMimeTypes(c).split(",");
    HashSet<String> mimeSet = new HashSet<>();
    if (videoMimes != null) {
        mimeSet.addAll(Arrays.asList(videoMimes));
    }
    if (imMimes != null) {
        mimeSet.addAll(Arrays.asList(imMimes));
    }
    return mimeSet;
}
#method_after
public static Set<String> getAllEnabledVideoImMimeSet(AmbientDataSubscription<CallMethodInfo> instance) {
    String[] videoMimes = getAllEnabledVideoCallableMimeTypes(instance).split(",");
    String[] imMimes = getAllEnabledImMimeTypes(instance).split(",");
    HashSet<String> mimeSet = new HashSet<>();
    if (videoMimes != null) {
        mimeSet.addAll(Arrays.asList(videoMimes));
    }
    if (imMimes != null) {
        mimeSet.addAll(Arrays.asList(imMimes));
    }
    return mimeSet;
}
#end_block

#method_before
public static Set<String> getAllEnabledVoiceMimeSet(Context c) {
    String[] mimes = getAllEnabledMimeTypes(c).split(",");
    HashSet<String> mimeSet = new HashSet<>();
    if (mimes != null) {
        mimeSet.addAll(Arrays.asList(mimes));
    }
    return mimeSet;
}
#method_after
public static Set<String> getAllEnabledVoiceMimeSet(AmbientDataSubscription<CallMethodInfo> instance) {
    String[] mimes = getAllEnabledMimeTypes(instance).split(",");
    HashSet<String> mimeSet = new HashSet<>();
    if (mimes != null) {
        mimeSet.addAll(Arrays.asList(mimes));
    }
    return mimeSet;
}
#end_block

#method_before
public static HashMap<ComponentName, CallMethodInfo> getAllEnabledCallMethods(Context c) {
    HashMap<ComponentName, CallMethodInfo> cmi = new HashMap<>();
    removeDisabled(getInstance(c).getPluginInfo(), cmi);
    return cmi;
}
#method_after
public static HashMap<ComponentName, CallMethodInfo> getAllEnabledCallMethods(AmbientDataSubscription<CallMethodInfo> instance) {
    HashMap<ComponentName, CallMethodInfo> cmi = new HashMap<>();
    removeDisabled(instance.getPluginInfo(), cmi);
    return cmi;
}
#end_block

#method_before
public static HashMap<ComponentName, CallMethodInfo> getAllEnabledAndHiddenCallMethods(Context c) {
    HashMap<ComponentName, CallMethodInfo> cmi = new HashMap<>();
    for (Map.Entry<ComponentName, CallMethodInfo> entry : getInstance(c).getPluginInfo().entrySet()) {
        ComponentName key = entry.getKey();
        CallMethodInfo value = entry.getValue();
        if (value.mStatus == PluginStatus.ENABLED || value.mStatus == PluginStatus.HIDDEN) {
            cmi.put(key, value);
        }
    }
    return cmi;
}
#method_after
public static HashMap<ComponentName, CallMethodInfo> getAllEnabledAndHiddenCallMethods(AmbientDataSubscription<CallMethodInfo> instance) {
    HashMap<ComponentName, CallMethodInfo> cmi = new HashMap<>();
    for (Map.Entry<ComponentName, CallMethodInfo> entry : instance.getPluginInfo().entrySet()) {
        ComponentName key = entry.getKey();
        CallMethodInfo value = entry.getValue();
        if (value.mStatus == PluginStatus.ENABLED || value.mStatus == PluginStatus.HIDDEN) {
            cmi.put(key, value);
        }
    }
    return cmi;
}
#end_block

#method_before
public static CallMethodInfo getMethodForMimeType(String mimeType, boolean enableOnly, Context c) {
    CallMethodInfo targetEntry = null;
    for (CallMethodInfo entry : getInstance(c).getPluginInfo().values()) {
        // TODO: find out why mimetype may be null
        if (!TextUtils.isEmpty(entry.mMimeType)) {
            if (enableOnly && entry.mStatus != PluginStatus.ENABLED) {
                continue;
            }
            if (entry.mMimeType.equals(mimeType)) {
                targetEntry = entry;
                break;
            }
        }
    }
    return targetEntry;
}
#method_after
public static CallMethodInfo getMethodForMimeType(String mimeType, boolean enableOnly, AmbientDataSubscription<CallMethodInfo> instance) {
    CallMethodInfo targetEntry = null;
    for (CallMethodInfo entry : instance.getPluginInfo().values()) {
        // TODO: find out why mimetype may be null
        if (!TextUtils.isEmpty(entry.mMimeType)) {
            if (enableOnly && entry.mStatus != PluginStatus.ENABLED) {
                continue;
            }
            if (entry.mMimeType.equals(mimeType)) {
                targetEntry = entry;
                break;
            }
        }
    }
    return targetEntry;
}
#end_block

#method_before
private void disableModListeners(ComponentName cn) {
    if (mEnabledListeners.containsKey(cn) || mEnabledListeners.get(cn)) {
        M plugin = getPluginIfExists(cn);
        disableListeners(plugin);
        mEnabledListeners.put(cn, false);
    }
}
#method_after
private void disableModListeners(ComponentName cn) {
    if (mEnabledListeners.containsKey(cn) && mEnabledListeners.get(cn)) {
        M plugin = getPluginIfExists(cn);
        disableListeners(plugin);
        mEnabledListeners.put(cn, false);
    }
}
#end_block

#method_before
private void executeAll(final ArrayList<TypedPendingResult> apiCallbacks, final ComponentName componentName) {
    final ArrayList<PendingResult> pendingResults = new ArrayList<>();
    for (final TypedPendingResult pendingResult : apiCallbacks) {
        pendingResult.setResultCallback(new ResultCallback() {

            @Override
            public void onResult(Result result) {
                if (result == null) {
                    // Our plugin failed to make this call, log out what and why
                    Log.e(TAG, "Result from: " + componentName.getPackageName() + " failed");
                    pendingResults.remove(pendingResult.mPendingResult);
                    maybeBroadcastToSubscribers(pendingResults);
                    return;
                }
                if (result.getStatus().isSuccess()) {
                    M plugin = getPluginIfExists(componentName);
                    onPostResult(plugin, result, pendingResult.mType);
                    // check to see if our onPostResult removed the plugin.
                    if (getPluginIfExists(componentName) == null) {
                        // and broadcast changes.
                        for (PendingResult pr : pendingResults) {
                            pr.cancel();
                        }
                        pendingResults.clear();
                        maybeBroadcastToSubscribers(pendingResults);
                        return;
                    }
                } else if (result.getStatus().isCanceled()) {
                    // Our plugin was found invalid or no longer exists.
                    Log.e(TAG, "Queries to: " + componentName.getPackageName() + " are cancelled");
                } else {
                    Log.e(TAG, "Query to: " + componentName.getPackageName() + " " + result.getClass().getSimpleName() + " failed. Code: " + result.getStatus().getStatusMessage());
                }
                pendingResults.remove(pendingResult.mPendingResult);
                maybeBroadcastToSubscribers(pendingResults);
            }
        }, TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
        // Add items that we've already added to our queue for so we can cancel them if
        // need be. Set resultcallback will return instantly but onResult will not.
        // So we can use this as our "counter" to determine if we should broadcast
        pendingResults.add(pendingResult.mPendingResult);
    }
    enableModListeners(componentName);
}
#method_after
private void executeAll(final ArrayList<TypedPendingResult> apiCallbacks, final ComponentName componentName) {
    final ArrayList<PendingResult> pendingResults = new ArrayList<>();
    for (final TypedPendingResult pendingResult : apiCallbacks) {
        pendingResult.setResultCallback(new ResultCallback() {

            @Override
            public void onResult(Result result) {
                pendingResults.remove(pendingResult.mPendingResult);
                if (result == null) {
                    // Our plugin failed to make this call, log out what and why
                    Log.e(TAG, "Result from: " + componentName.getPackageName() + " failed");
                } else {
                    if (result.getStatus().isSuccess()) {
                        M plugin = getPluginIfExists(componentName);
                        onPostResult(plugin, result, pendingResult.mType);
                        // check to see if our onPostResult removed the plugin.
                        if (!getPluginInfo().containsKey(componentName)) {
                            // and broadcast changes.
                            for (PendingResult pr : pendingResults) {
                                pr.cancel();
                            }
                            pendingResults.clear();
                        }
                    } else if (result.getStatus().isCanceled()) {
                        // Our plugin was found invalid or no longer exists.
                        Log.e(TAG, "Queries to: " + componentName.getPackageName() + " are cancelled");
                    } else {
                        Log.e(TAG, "Query to: " + componentName.getPackageName() + " " + result.getClass().getSimpleName() + " failed. Code: " + result.getStatus().getStatusMessage());
                    }
                }
                maybeBroadcastToSubscribers(pendingResults);
            }
        }, TIMEOUT_MILLISECONDS, TimeUnit.MILLISECONDS);
        // Add items that we've already added to our queue for so we can cancel them if
        // need be. Set resultcallback will return instantly but onResult will not.
        // So we can use this as our "counter" to determine if we should broadcast
        pendingResults.add(pendingResult.mPendingResult);
    }
    enableModListeners(componentName);
}
#end_block

#method_before
public M getPluginIfExists(ComponentName cn) {
    if (getPluginInfo().containsKey(cn)) {
        return getPluginInfo().get(cn);
    } else {
        return null;
    }
}
#method_after
public M getPluginIfExists(ComponentName cn) {
    return getPluginInfo().get(cn);
}
#end_block

#method_before
public static void enableCreditListener(Context context, CallMethodInfo callMethodInfo) {
    CallCreditListenerImpl listener = CallCreditListenerImpl.getInstance(context, callMethodInfo.mComponent);
    thisApi().addCreditListener(getInstance(context).mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setCreditListener(listener);
}
#method_after
public static void enableCreditListener(AmbientDataSubscription<CallMethodInfo> instance, CallMethodInfo callMethodInfo) {
    CallCreditListenerImpl listener = CallCreditListenerImpl.getInstance(instance.mContext, callMethodInfo.mComponent);
    thisApi().addCreditListener(instance.mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setCreditListener(listener);
}
#end_block

#method_before
public static void disableCreditListener(Context context, CallMethodInfo callMethodInfo) {
    CallCreditListenerImpl listener = callMethodInfo.getCreditListener();
    thisApi().removeCreditListener(getInstance(context).mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setCreditListener(null);
}
#method_after
public static void disableCreditListener(AmbientDataSubscription<CallMethodInfo> instance, CallMethodInfo callMethodInfo) {
    CallCreditListenerImpl listener = callMethodInfo.getCreditListener();
    thisApi().removeCreditListener(instance.mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setCreditListener(null);
}
#end_block

#method_before
public static void enableAuthListener(Context context, CallMethodInfo callMethodInfo) {
    AuthenticationListenerImpl listener = AuthenticationListenerImpl.getInstance(context, callMethodInfo.mComponent);
    thisApi().addAuthenticationListener(getInstance(context).mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setAuthListener(listener);
}
#method_after
public static void enableAuthListener(AmbientDataSubscription<CallMethodInfo> instance, CallMethodInfo callMethodInfo) {
    AuthenticationListenerImpl listener = AuthenticationListenerImpl.getInstance(instance.mContext, callMethodInfo.mComponent);
    thisApi().addAuthenticationListener(instance.mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setAuthListener(listener);
}
#end_block

#method_before
public static void disableAuthListener(Context context, CallMethodInfo callMethodInfo) {
    AuthenticationListenerImpl listener = callMethodInfo.getAuthListener();
    thisApi().removeAuthenticationListener(getInstance(context).mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setAuthListener(null);
}
#method_after
public static void disableAuthListener(AmbientDataSubscription<CallMethodInfo> instance, CallMethodInfo callMethodInfo) {
    AuthenticationListenerImpl listener = callMethodInfo.getAuthListener();
    thisApi().removeAuthenticationListener(instance.mClient, callMethodInfo.mComponent, listener);
    callMethodInfo.setAuthListener(null);
}
#end_block

#method_before
public static void gotMimeType(CallMethodInfo callMethodInfo, MimeTypeResult result, int type) {
    switch(type) {
        case InCallTypedResult.GENERAL_MIME_TYPE:
            callMethodInfo.mMimeType = result.mimeType;
            break;
        case InCallTypedResult.VIDEO_MIME_TYPE:
            callMethodInfo.mVideoCallableMimeType = result.mimeType;
            break;
        case InCallTypedResult.IM_MIME_TYPE:
            callMethodInfo.mImMimeType = result.mimeType;
            break;
    }
}
#method_after
public static void gotMimeType(CallMethodInfo callMethodInfo, MimeTypeResult result, int type) {
    switch(type) {
        case TypedPendingResult.GENERAL_MIME_TYPE:
            callMethodInfo.mMimeType = result.mimeType;
            break;
        case TypedPendingResult.VIDEO_MIME_TYPE:
            callMethodInfo.mVideoCallableMimeType = result.mimeType;
            break;
        case TypedPendingResult.IM_MIME_TYPE:
            callMethodInfo.mImMimeType = result.mimeType;
            break;
    }
}
#end_block

#method_before
public static void gotIntent(CallMethodInfo callMethodInfo, PendingIntentResult result, int type) {
    switch(type) {
        case InCallTypedResult.LOGIN_INTENT:
            callMethodInfo.mLoginIntent = result.intent;
            break;
        case InCallTypedResult.CREDIT_INTENT:
            callMethodInfo.mManageCreditIntent = result.intent;
            break;
        case InCallTypedResult.SETTINGS_INTENT:
            callMethodInfo.mSettingsIntent = result.intent;
            break;
        case InCallTypedResult.DEFAULT_DIRECTORY_SEARCH_INTENT:
            callMethodInfo.mDefaultDirectorySearchIntent = result.intent;
            break;
    }
}
#method_after
public static void gotIntent(CallMethodInfo callMethodInfo, PendingIntentResult result, int type) {
    switch(type) {
        case TypedPendingResult.LOGIN_INTENT:
            callMethodInfo.mLoginIntent = result.intent;
            break;
        case TypedPendingResult.CREDIT_INTENT:
            callMethodInfo.mManageCreditIntent = result.intent;
            break;
        case TypedPendingResult.SETTINGS_INTENT:
            callMethodInfo.mSettingsIntent = result.intent;
            break;
        case TypedPendingResult.DEFAULT_DIRECTORY_SEARCH_INTENT:
            callMethodInfo.mDefaultDirectorySearchIntent = result.intent;
            break;
    }
}
#end_block

#method_before
public static void gotGeneralInfo(CallMethodInfo callMethodInfo, Context context, InCallProviderInfoResult result) {
    ComponentName componentName = callMethodInfo.mComponent;
    InCallProviderInfo icpi = result.inCallProviderInfo;
    if (icpi == null) {
        getInstance(context).getPluginInfo().remove(componentName);
        return;
    }
    Resources resources = ModUtils.getPluginResources(context, componentName);
    if (resources == null) {
        return;
    }
    callMethodInfo.mBrandIconId = icpi.getBrandIcon();
    callMethodInfo.mLoginIconId = icpi.getLoginIcon();
    try {
        callMethodInfo.mSingleColorBrandIcon = resources.getDrawable(icpi.getSingleColorBrandIcon());
        callMethodInfo.mBrandIcon = resources.getDrawable(callMethodInfo.mBrandIconId);
        callMethodInfo.mLoginIcon = resources.getDrawable(callMethodInfo.mLoginIconId);
        callMethodInfo.mVoiceIcon = resources.getDrawable(icpi.getVoiceMimeIcon());
        callMethodInfo.mImIcon = resources.getDrawable(icpi.getImMimeIcon());
        callMethodInfo.mBadgeIcon = resources.getDrawable(icpi.getBadgeIcon());
    } catch (Resources.NotFoundException e) {
        Log.e(TAG, "Resource Not found: " + componentName.flattenToShortString());
        getInstance(context).getPluginInfo().remove(componentName);
        return;
    }
    callMethodInfo.mSubscriptionButtonText = icpi.getSubscriptionButtonText();
    callMethodInfo.mCreditButtonText = icpi.getCreditsButtonText();
    // If present, use the deprecated attribute defined hint text.
    // These values may be overwritten by getHintText.
    callMethodInfo.mT9HintDescriptionNoCreditOrSub = icpi.getT9HintDescription();
    callMethodInfo.mT9HintDescriptionHasCreditOrSub = icpi.getT9HintDescription();
    callMethodInfo.mDependentPackage = icpi.getDependentPackage();
    callMethodInfo.mName = icpi.getTitle();
    callMethodInfo.mSummary = icpi.getSummary();
    callMethodInfo.mAccountType = icpi.getAccountType();
    gotAccountHandle(callMethodInfo, context, icpi.getAccountHandle());
}
#method_after
public static void gotGeneralInfo(CallMethodInfo callMethodInfo, AmbientDataSubscription<CallMethodInfo> instance, InCallProviderInfoResult result) {
    ComponentName componentName = callMethodInfo.mComponent;
    InCallProviderInfo icpi = result.inCallProviderInfo;
    if (icpi == null) {
        instance.getPluginInfo().remove(componentName);
        return;
    }
    Resources resources = ModUtils.getPluginResources(instance.mContext, componentName);
    if (resources == null) {
        return;
    }
    callMethodInfo.mBrandIconId = icpi.getBrandIcon();
    callMethodInfo.mLoginIconId = icpi.getLoginIcon();
    try {
        callMethodInfo.mSingleColorBrandIcon = resources.getDrawable(icpi.getSingleColorBrandIcon());
        callMethodInfo.mBrandIcon = resources.getDrawable(callMethodInfo.mBrandIconId);
        callMethodInfo.mLoginIcon = resources.getDrawable(callMethodInfo.mLoginIconId);
        callMethodInfo.mVoiceIcon = resources.getDrawable(icpi.getVoiceMimeIcon());
        callMethodInfo.mImIcon = resources.getDrawable(icpi.getImMimeIcon());
        callMethodInfo.mBadgeIcon = resources.getDrawable(icpi.getBadgeIcon());
    } catch (Resources.NotFoundException e) {
        Log.e(TAG, "Resource Not found: " + componentName.flattenToShortString());
        instance.getPluginInfo().remove(componentName);
        return;
    }
    callMethodInfo.mSubscriptionButtonText = icpi.getSubscriptionButtonText();
    callMethodInfo.mCreditButtonText = icpi.getCreditsButtonText();
    // If present, use the deprecated attribute defined hint text.
    // These values may be overwritten by getHintText.
    callMethodInfo.mT9HintDescriptionNoCreditOrSub = icpi.getT9HintDescription();
    callMethodInfo.mT9HintDescriptionHasCreditOrSub = icpi.getT9HintDescription();
    callMethodInfo.mDependentPackage = icpi.getDependentPackage();
    callMethodInfo.mName = icpi.getTitle();
    callMethodInfo.mSummary = icpi.getSummary();
    callMethodInfo.mAccountType = icpi.getAccountType();
    gotAccountHandle(callMethodInfo, instance.mContext, icpi.getAccountHandle());
}
#end_block

#method_before
public static void updateCreditInfo(Context context, ComponentName name, GetCreditInfoResult result) {
    CallMethodInfo callMethodInfo = getInstance(context).getPluginIfExists(name);
    if (callMethodInfo != null) {
        gotCreditData(callMethodInfo, result);
        getInstance(context).getPluginInfo().put(name, callMethodInfo);
        // Since a CallMethodInfo object was updated here, we should let the subscribers know
        getInstance(context).broadcast();
    } else {
        Log.wtf(TAG, "Call method does not exist, this should not happen");
    }
}
#method_after
public static void updateCreditInfo(AmbientDataSubscription<CallMethodInfo> instance, ComponentName name, GetCreditInfoResult result) {
    CallMethodInfo callMethodInfo = instance.getPluginIfExists(name);
    if (callMethodInfo != null) {
        gotCreditData(callMethodInfo, result);
        instance.getPluginInfo().put(name, callMethodInfo);
        // Since a CallMethodInfo object was updated here, we should let the subscribers know
        instance.broadcast();
    } else {
        Log.wtf(TAG, "Call method does not exist, this should not happen");
    }
}
#end_block

#method_before
public static void updateAuthenticationState(Context context, ComponentName name, int state) {
    CallMethodInfo callMethodInfo = getInstance(context).getPluginIfExists(name);
    if (callMethodInfo != null) {
        callMethodInfo.mIsAuthenticated = state == StatusCodes.AuthenticationState.LOGGED_IN;
        getInstance(context).getPluginInfo().put(name, callMethodInfo);
        // Since a CallMethodInfo object was updated here, we should let the subscribers know
        getInstance(context).broadcast();
    } else {
        Log.wtf(TAG, "Call method does not exist, this should not happen");
    }
}
#method_after
public static void updateAuthenticationState(AmbientDataSubscription<CallMethodInfo> instance, ComponentName name, int state) {
    CallMethodInfo callMethodInfo = instance.getPluginIfExists(name);
    if (callMethodInfo != null) {
        callMethodInfo.mIsAuthenticated = state == StatusCodes.AuthenticationState.LOGGED_IN;
        instance.getPluginInfo().put(name, callMethodInfo);
        // Since a CallMethodInfo object was updated here, we should let the subscribers know
        instance.broadcast();
    } else {
        Log.wtf(TAG, "Call method does not exist, this should not happen");
    }
}
#end_block

#method_before
private static void gotContactCardLogin(CallMethodInfo callMethodInfo, String key, Bundle bundle, Context c) {
    callMethodInfo.mLoginNudgeEnable = bundle.getBoolean(NudgeKey.NUDGE_PARAM_ENABLED, true) && PreferenceManager.getDefaultSharedPreferences(c).getBoolean(callMethodInfo.mComponent.getClassName() + "." + key, true);
    callMethodInfo.mLoginNudgeSubtitle = bundle.getString(NudgeKey.NUDGE_PARAM_SUBTITLE);
    callMethodInfo.mLoginNudgeActionText = bundle.getString(NudgeKey.NUDGE_PARAM_ACTION_TEXT);
}
#method_after
private static void gotContactCardLogin(CallMethodInfo callMethodInfo, String key, Bundle bundle, Context c) {
    callMethodInfo.mLoginNudgeEnable = bundle.getBoolean(NudgeKey.NUDGE_PARAM_ENABLED, true) && PreferenceManager.getDefaultSharedPreferences(c).getBoolean(getKey(key, callMethodInfo), true);
    callMethodInfo.mLoginNudgeSubtitle = bundle.getString(NudgeKey.NUDGE_PARAM_SUBTITLE);
    callMethodInfo.mLoginNudgeActionText = bundle.getString(NudgeKey.NUDGE_PARAM_ACTION_TEXT);
}
#end_block

#method_before
private static void gotContactCardDownload(CallMethodInfo callMethodInfo, String key, Bundle bundle, Context context) {
    callMethodInfo.mInstallNudgeEnable = bundle.getBoolean(NudgeKey.NUDGE_PARAM_ENABLED, true) && PreferenceManager.getDefaultSharedPreferences(context).getBoolean(callMethodInfo.mComponent.getClassName() + "." + key, true);
    callMethodInfo.mInstallNudgeSubtitle = bundle.getString(NudgeKey.NUDGE_PARAM_SUBTITLE);
    callMethodInfo.mInstallNudgeActionText = bundle.getString(NudgeKey.NUDGE_PARAM_ACTION_TEXT);
}
#method_after
private static void gotContactCardDownload(CallMethodInfo callMethodInfo, String key, Bundle bundle, Context context) {
    callMethodInfo.mInstallNudgeEnable = bundle.getBoolean(NudgeKey.NUDGE_PARAM_ENABLED, true) && PreferenceManager.getDefaultSharedPreferences(context).getBoolean(getKey(key, callMethodInfo), true);
    callMethodInfo.mInstallNudgeSubtitle = bundle.getString(NudgeKey.NUDGE_PARAM_SUBTITLE);
    callMethodInfo.mInstallNudgeActionText = bundle.getString(NudgeKey.NUDGE_PARAM_ACTION_TEXT);
}
#end_block

#method_before
@Override
protected void onRefreshRequested() {
    InCallQueries.updateCallPlugins(mContext);
}
#method_after
@Override
protected void onRefreshRequested() {
    InCallQueries.updateCallPlugins(this);
}
#end_block

#method_before
@Override
protected void requestedModInfo(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodInfo(mContext, componentName));
    queries.add(InCallQueries.getCallMethodStatus(mContext, componentName));
    queries.add(InCallQueries.getCallMethodMimeType(mContext, componentName));
    queries.add(InCallQueries.getCallMethodVideoCallableMimeType(mContext, componentName));
    queries.add(InCallQueries.getCallMethodAuthenticated(mContext, componentName));
    queries.add(InCallQueries.getLoginIntent(mContext, componentName));
    queries.add(InCallQueries.getSettingsIntent(mContext, componentName));
    queries.add(InCallQueries.getCreditInfo(mContext, componentName));
    queries.add(InCallQueries.getHintText(mContext, componentName));
    queries.add(InCallQueries.getManageCreditsIntent(mContext, componentName));
    TypedPendingResult creditQuery = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CREDIT_NUDGE);
    if (creditQuery != null) {
        queries.add(creditQuery);
    }
}
#method_after
@Override
protected void requestedModInfo(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodInfo(mClient, componentName));
    queries.add(InCallQueries.getCallMethodStatus(mClient, componentName));
    queries.add(InCallQueries.getCallMethodMimeType(mClient, componentName));
    queries.add(InCallQueries.getCallMethodVideoCallableMimeType(mClient, componentName));
    queries.add(InCallQueries.getCallMethodAuthenticated(mClient, componentName));
    queries.add(InCallQueries.getLoginIntent(mClient, componentName));
    queries.add(InCallQueries.getSettingsIntent(mClient, componentName));
    queries.add(InCallQueries.getCreditInfo(mClient, componentName));
    queries.add(InCallQueries.getHintText(mClient, componentName));
    queries.add(InCallQueries.getManageCreditsIntent(mClient, componentName));
    TypedPendingResult creditQuery = NudgeQueries.getNudgeConfig(mClient, mContext, componentName, NudgeKey.INCALL_CREDIT_NUDGE);
    if (creditQuery != null) {
        queries.add(creditQuery);
    }
}
#end_block

#method_before
@Override
protected void onDynamicRefreshRequested(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodAuthenticated(mContext, componentName));
    queries.add(InCallQueries.getCreditInfo(mContext, componentName));
}
#method_after
@Override
protected void onDynamicRefreshRequested(ArrayList<TypedPendingResult> queries, ComponentName componentName) {
    queries.add(InCallQueries.getCallMethodAuthenticated(mClient, componentName));
    queries.add(InCallQueries.getCreditInfo(mClient, componentName));
}
#end_block

#method_before
@Override
protected void enableListeners(CallMethodInfo cn) {
    InCallListeners.enableCreditListener(mContext, cn);
    InCallListeners.enableAuthListener(mContext, cn);
}
#method_after
@Override
protected void enableListeners(CallMethodInfo cn) {
    InCallListeners.enableCreditListener(this, cn);
    InCallListeners.enableAuthListener(this, cn);
}
#end_block

#method_before
@Override
protected void disableListeners(CallMethodInfo cn) {
    InCallListeners.disableCreditListener(mContext, cn);
    InCallListeners.disableAuthListener(mContext, cn);
}
#method_after
@Override
protected void disableListeners(CallMethodInfo cn) {
    InCallListeners.disableCreditListener(this, cn);
    InCallListeners.disableAuthListener(this, cn);
}
#end_block

#method_before
@Override
protected void onPostResult(CallMethodInfo cmi, Result r, int type) {
    if (r instanceof InCallProviderInfoResult) {
        InCallResults.gotGeneralInfo(cmi, mContext, (InCallProviderInfoResult) r);
    } else if (r instanceof PluginStatusResult) {
        InCallResults.gotStatus(cmi, (PluginStatusResult) r);
    } else if (r instanceof MimeTypeResult) {
        InCallResults.gotMimeType(cmi, (MimeTypeResult) r, type);
    } else if (r instanceof AuthenticationStateResult) {
        InCallResults.gotAuthenticationState(cmi, (AuthenticationStateResult) r);
    } else if (r instanceof AccountHandleResult) {
        InCallResults.gotAccountHandle(cmi, mContext, (AccountHandleResult) r);
    } else if (r instanceof PendingIntentResult) {
        InCallResults.gotIntent(cmi, (PendingIntentResult) r, type);
    } else if (r instanceof GetCreditInfoResultResult) {
        GetCreditInfoResult gcir = ((GetCreditInfoResultResult) r).result;
        InCallResults.gotCreditData(cmi, gcir);
    } else if (r instanceof BundleResult) {
        InCallResults.gotNudgeData(mContext, cmi, (BundleResult) r, type);
    } else if (r instanceof HintTextResultResult) {
        InCallResults.gotHintText(cmi, (HintTextResultResult) r);
    }
}
#method_after
@Override
protected void onPostResult(CallMethodInfo cmi, Result r, int type) {
    switch(type) {
        case TypedPendingResult.GENERAL_MIME_TYPE:
        case TypedPendingResult.IM_MIME_TYPE:
        case TypedPendingResult.VIDEO_MIME_TYPE:
            InCallResults.gotMimeType(cmi, (MimeTypeResult) r, type);
            break;
        case TypedPendingResult.SETTINGS_INTENT:
        case TypedPendingResult.CREDIT_INTENT:
        case TypedPendingResult.LOGIN_INTENT:
        case TypedPendingResult.DEFAULT_DIRECTORY_SEARCH_INTENT:
            InCallResults.gotIntent(cmi, (PendingIntentResult) r, type);
            break;
        case TypedPendingResult.GENERAL_DATA:
            InCallResults.gotGeneralInfo(cmi, this, (InCallProviderInfoResult) r);
            break;
        case TypedPendingResult.STATUS:
            InCallResults.gotStatus(cmi, (PluginStatusResult) r);
            break;
        case TypedPendingResult.AUTHENTICATION:
            InCallResults.gotAuthenticationState(cmi, (AuthenticationStateResult) r);
            break;
        case TypedPendingResult.CREDIT_INFO:
            GetCreditInfoResult gcir = ((GetCreditInfoResultResult) r).result;
            InCallResults.gotCreditData(cmi, gcir);
            break;
        case TypedPendingResult.ACCOUNT_HANDLE:
            InCallResults.gotAccountHandle(cmi, mContext, (AccountHandleResult) r);
            break;
        case TypedPendingResult.HINT_TEXT:
            InCallResults.gotHintText(cmi, (HintTextResultResult) r);
            break;
        default:
            Log.e(TAG, "Unhandled result type!");
            break;
    }
}
#end_block

#method_before
public static void updateCallPlugins(Context context) {
    thisApi().getInstalledPlugins(getInstance(context).mClient).setResultCallback(getInstance(context).BOOTSTRAP);
}
#method_after
public static void updateCallPlugins(AmbientDataSubscription<CallMethodInfo> instance) {
    thisApi().getInstalledPlugins(instance.mClient).setResultCallback(instance.BOOTSTRAP);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodInfo(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getProviderInfo(getInstance(context).mClient, componentName), InCallTypedResult.NONE);
}
#method_after
public static TypedPendingResult getCallMethodInfo(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getProviderInfo(client, componentName), TypedPendingResult.GENERAL_DATA);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodStatus(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getPluginStatus(getInstance(context).mClient, componentName), InCallTypedResult.NONE);
}
#method_after
public static TypedPendingResult getCallMethodStatus(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getPluginStatus(client, componentName), TypedPendingResult.STATUS);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodMimeType(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getCallableMimeType(getInstance(context).mClient, componentName), InCallTypedResult.GENERAL_MIME_TYPE);
}
#method_after
public static TypedPendingResult getCallMethodMimeType(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getCallableMimeType(client, componentName), TypedPendingResult.GENERAL_MIME_TYPE);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodVideoCallableMimeType(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getVideoCallableMimeType(getInstance(context).mClient, componentName), InCallTypedResult.VIDEO_MIME_TYPE);
}
#method_after
public static TypedPendingResult getCallMethodVideoCallableMimeType(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getVideoCallableMimeType(client, componentName), TypedPendingResult.VIDEO_MIME_TYPE);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodImMimeType(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getImMimeType(getInstance(context).mClient, componentName), InCallTypedResult.IM_MIME_TYPE);
}
#method_after
public static TypedPendingResult getCallMethodImMimeType(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getImMimeType(client, componentName), TypedPendingResult.IM_MIME_TYPE);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodAuthenticated(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getAuthenticationState(getInstance(context).mClient, componentName), InCallTypedResult.NONE);
}
#method_after
public static TypedPendingResult getCallMethodAuthenticated(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getAuthenticationState(client, componentName), TypedPendingResult.AUTHENTICATION);
}
#end_block

#method_before
public static InCallTypedResult getManageCreditsIntent(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getManageCreditsIntent(getInstance(context).mClient, componentName), InCallTypedResult.CREDIT_INTENT);
}
#method_after
public static TypedPendingResult getManageCreditsIntent(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getManageCreditsIntent(client, componentName), TypedPendingResult.CREDIT_INTENT);
}
#end_block

#method_before
public static InCallTypedResult getLoginIntent(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getLoginIntent(getInstance(context).mClient, componentName), InCallTypedResult.LOGIN_INTENT);
}
#method_after
public static TypedPendingResult getLoginIntent(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getLoginIntent(client, componentName), TypedPendingResult.LOGIN_INTENT);
}
#end_block

#method_before
public static InCallTypedResult getSettingsIntent(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getSettingsIntent(getInstance(context).mClient, componentName), InCallTypedResult.SETTINGS_INTENT);
}
#method_after
public static TypedPendingResult getSettingsIntent(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getSettingsIntent(client, componentName), TypedPendingResult.SETTINGS_INTENT);
}
#end_block

#method_before
public static InCallTypedResult getCreditInfo(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getCreditInfo(getInstance(context).mClient, componentName), InCallTypedResult.NONE);
}
#method_after
public static TypedPendingResult getCreditInfo(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getCreditInfo(client, componentName), TypedPendingResult.CREDIT_INFO);
}
#end_block

#method_before
public static InCallTypedResult getCallMethodAccountHandle(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getAccountHandle(getInstance(context).mClient, componentName), InCallTypedResult.NONE);
}
#method_after
public static TypedPendingResult getCallMethodAccountHandle(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getAccountHandle(client, componentName), TypedPendingResult.ACCOUNT_HANDLE);
}
#end_block

#method_before
public static InCallTypedResult getHintText(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getHintText(getInstance(context).mClient, componentName), InCallTypedResult.NONE);
}
#method_after
public static TypedPendingResult getHintText(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getHintText(client, componentName), TypedPendingResult.HINT_TEXT);
}
#end_block

#method_before
public static InCallTypedResult getDefaultDirectorySearchIntent(Context context, ComponentName componentName) {
    return new InCallTypedResult(thisApi().getDirectorySearchIntent(getInstance(context).mClient, componentName, null), InCallTypedResult.DEFAULT_DIRECTORY_SEARCH_INTENT);
}
#method_after
public static TypedPendingResult getDefaultDirectorySearchIntent(AmbientApiClient client, ComponentName componentName) {
    return new TypedPendingResult(thisApi().getDirectorySearchIntent(client, componentName, null), TypedPendingResult.DEFAULT_DIRECTORY_SEARCH_INTENT);
}
#end_block

#method_before
public static void shipAnalyticsToPlugin(Context context, ComponentName componentName, Event event) {
    if (componentName == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "componentName: " + componentName.toShortString() + ":Event: " + event.toString());
    }
    thisApi().sendAnalyticsEventToPlugin(getInstance(context).mClient, componentName, event).setResultCallback(new ResultCallback<Result>() {

        @Override
        public void onResult(Result result) {
            if (DEBUG) {
                Log.v(TAG, "Event sent with result: " + result.getStatus().getStatusMessage());
            }
        }
    });
}
#method_after
public static void shipAnalyticsToPlugin(AmbientApiClient client, ComponentName componentName, Event event) {
    if (componentName == null) {
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "componentName: " + componentName.toShortString() + ":Event: " + event.toString());
    }
    thisApi().sendAnalyticsEventToPlugin(client, componentName, event).setResultCallback(new ResultCallback<Result>() {

        @Override
        public void onResult(Result result) {
            if (DEBUG) {
                Log.v(TAG, "Event sent with result: " + result.getStatus().getStatusMessage());
            }
        }
    });
}
#end_block

#method_before
public static int getNudgeTypeForKey(String key) {
    switch(key) {
        case NudgeKey.INCALL_CREDIT_NUDGE:
            return INCALL_CREDIT_NUDGE;
        case NudgeKey.INCALL_CONTACT_CARD_LOGIN:
            return INCALL_CONTACT_CARD_LOGIN;
        case NudgeKey.INCALL_CONTACT_CARD_DOWNLOAD:
            return INCALL_CONTACT_CARD_DOWNLOAD;
        case NudgeKey.INCALL_CONTACT_FRAGMENT_LOGIN:
            return INCALL_CONTACT_FRAGMENT_LOGIN;
        default:
            Log.e(TAG, "No nudge type!");
            return NONE;
    }
}
#method_after
static int getNudgeTypeForKey(String key) {
    switch(key) {
        case NudgeKey.INCALL_CREDIT_NUDGE:
            return INCALL_CREDIT_NUDGE;
        case NudgeKey.INCALL_CONTACT_CARD_LOGIN:
            return INCALL_CONTACT_CARD_LOGIN;
        case NudgeKey.INCALL_CONTACT_CARD_DOWNLOAD:
            return INCALL_CONTACT_CARD_DOWNLOAD;
        case NudgeKey.INCALL_CONTACT_FRAGMENT_LOGIN:
            return INCALL_CONTACT_FRAGMENT_LOGIN;
        default:
            Log.e(TAG, "No nudge type!");
            return NONE;
    }
}
#end_block

#method_before
@Override
public void authenticationStateUpdated(int state) throws RemoteException {
    if (DEBUG) {
        Log.d(TAG, "Getting authenticationStateUpdated for: " + mComponentName + " state: " + state);
    }
    InCallResults.updateAuthenticationState(mContext, mComponentName, state);
}
#method_after
@Override
public void authenticationStateUpdated(int state) throws RemoteException {
    if (DEBUG) {
        Log.d(TAG, "Got authenticationStateUpdated for: " + mComponentName + " state: " + state);
    }
    InCallResults.updateAuthenticationState(DialerDataSubscription.get(mContext), mComponentName, state);
}
#end_block

#method_before
public static void gotCreditData(CallMethodInfo callMethodInfo, GetCreditInfoResult result) {
    if (result.creditInfo == null) {
        // Build zero credit dummy if no result found.
        callMethodInfo.mProviderCreditInfo = new CreditInfo(new CreditBalance(0, null), null);
    } else {
        callMethodInfo.mProviderCreditInfo = result.creditInfo;
    }
}
#method_after
public static void gotCreditData(CallMethodInfo callMethodInfo, GetCreditInfoResult result) {
    if (result == null || result.creditInfo == null) {
        // Build zero credit dummy if no result found.
        callMethodInfo.mProviderCreditInfo = new CreditInfo(new CreditBalance(0, null), null);
    } else {
        callMethodInfo.mProviderCreditInfo = result.creditInfo;
    }
}
#end_block

#method_before
public WeatherInfo queryWeather(WeatherLocation weatherLocation) throws InvalidApiKeyException {
    if (!maybeValidApiKey(mApiKey)) {
        throw new InvalidApiKeyException();
    }
    String language = getLanguageCode();
    Call<CurrentWeatherResponse> weatherResponseCall = mOpenWeatherMapInterface.queryCurrentWeather(weatherLocation.getCityId(), RESULT_FORMAT, UNITS, language, mApiKey);
    Response<CurrentWeatherResponse> currentWeatherResponse;
    try {
        logd(weatherResponseCall.request().toString());
        currentWeatherResponse = weatherResponseCall.execute();
    } catch (IOException e) {
        // An error occurred while talking to the server
        return null;
    }
    if (currentWeatherResponse.code() == 200) {
        // Query the forecast now. We can return a valid WeatherInfo object without the forecast
        // but the user is expecting both the current weather and the forecast
        Call<ForecastResponse> forecastResponseCall = mOpenWeatherMapInterface.queryForecast(weatherLocation.getCityId(), RESULT_FORMAT, UNITS, language, FORECAST_DAYS, mApiKey);
        ForecastResponse forecastResponse = null;
        try {
            logd(forecastResponseCall.request().toString());
            Response<ForecastResponse> r = forecastResponseCall.execute();
            if (r.code() == 200)
                forecastResponse = r.body();
        } catch (IOException e) {
            // this is an error we can live with
            logd("IOException while requesting forecast " + e);
        }
        return processWeatherResponse(currentWeatherResponse.body(), forecastResponse);
    } else {
        return null;
    }
}
#method_after
public WeatherInfo queryWeather(WeatherLocation weatherLocation) throws InvalidApiKeyException {
    if (!maybeValidApiKey(mApiKey)) {
        throw new InvalidApiKeyException();
    }
    String language = getLanguageCode();
    final int tempUnit = getTempUnitFromSettings();
    final String units = mapTempUnit(tempUnit);
    Call<CurrentWeatherResponse> weatherResponseCall = mOpenWeatherMapInterface.queryCurrentWeather(weatherLocation.getCityId(), RESULT_FORMAT, units, language, mApiKey);
    Response<CurrentWeatherResponse> currentWeatherResponse;
    try {
        logd(weatherResponseCall.request().toString());
        currentWeatherResponse = weatherResponseCall.execute();
    } catch (IOException e) {
        // An error occurred while talking to the server
        return null;
    }
    if (currentWeatherResponse.code() == 200) {
        // Query the forecast now. We can return a valid WeatherInfo object without the forecast
        // but the user is expecting both the current weather and the forecast
        Call<ForecastResponse> forecastResponseCall = mOpenWeatherMapInterface.queryForecast(weatherLocation.getCityId(), RESULT_FORMAT, units, language, FORECAST_DAYS, mApiKey);
        ForecastResponse forecastResponse = null;
        try {
            logd(forecastResponseCall.request().toString());
            Response<ForecastResponse> r = forecastResponseCall.execute();
            if (r.code() == 200)
                forecastResponse = r.body();
        } catch (IOException e) {
            // this is an error we can live with
            logd("IOException while requesting forecast " + e);
        }
        return processWeatherResponse(currentWeatherResponse.body(), forecastResponse, tempUnit);
    } else {
        return null;
    }
}
#end_block

#method_before
public WeatherInfo queryWeather(Location location) throws InvalidApiKeyException {
    if (!maybeValidApiKey(mApiKey)) {
        throw new InvalidApiKeyException();
    }
    String language = getLanguageCode();
    Call<CurrentWeatherResponse> weatherResponseCall = mOpenWeatherMapInterface.queryCurrentWeather(location.getLatitude(), location.getLongitude(), RESULT_FORMAT, UNITS, language, mApiKey);
    Response<CurrentWeatherResponse> currentWeatherResponse;
    try {
        logd(weatherResponseCall.request().toString());
        currentWeatherResponse = weatherResponseCall.execute();
    } catch (IOException e) {
        // An error occurred while talking to the server
        logd("IOException while requesting weather " + e);
        return null;
    }
    if (currentWeatherResponse.code() == 200) {
        // Query the forecast now. We can return a valid WeatherInfo object without the forecast
        // but the user is expecting both the current weather and the forecast
        Call<ForecastResponse> forecastResponseCall = mOpenWeatherMapInterface.queryForecast(location.getLatitude(), location.getLongitude(), RESULT_FORMAT, UNITS, language, FORECAST_DAYS, mApiKey);
        ForecastResponse forecastResponse = null;
        try {
            logd(forecastResponseCall.request().toString());
            Response<ForecastResponse> r = forecastResponseCall.execute();
            if (r.code() == 200)
                forecastResponse = r.body();
        } catch (IOException e) {
            // this is an error we can live with
            logd("IOException while requesting forecast " + e);
        }
        return processWeatherResponse(currentWeatherResponse.body(), forecastResponse);
    } else {
        return null;
    }
}
#method_after
public WeatherInfo queryWeather(Location location) throws InvalidApiKeyException {
    if (!maybeValidApiKey(mApiKey)) {
        throw new InvalidApiKeyException();
    }
    String language = getLanguageCode();
    final int tempUnit = getTempUnitFromSettings();
    final String units = mapTempUnit(tempUnit);
    Call<CurrentWeatherResponse> weatherResponseCall = mOpenWeatherMapInterface.queryCurrentWeather(location.getLatitude(), location.getLongitude(), RESULT_FORMAT, units, language, mApiKey);
    Response<CurrentWeatherResponse> currentWeatherResponse;
    try {
        logd(weatherResponseCall.request().toString());
        currentWeatherResponse = weatherResponseCall.execute();
    } catch (IOException e) {
        // An error occurred while talking to the server
        logd("IOException while requesting weather " + e);
        return null;
    }
    if (currentWeatherResponse.code() == 200) {
        // Query the forecast now. We can return a valid WeatherInfo object without the forecast
        // but the user is expecting both the current weather and the forecast
        Call<ForecastResponse> forecastResponseCall = mOpenWeatherMapInterface.queryForecast(location.getLatitude(), location.getLongitude(), RESULT_FORMAT, units, language, FORECAST_DAYS, mApiKey);
        ForecastResponse forecastResponse = null;
        try {
            logd(forecastResponseCall.request().toString());
            Response<ForecastResponse> r = forecastResponseCall.execute();
            if (r.code() == 200)
                forecastResponse = r.body();
        } catch (IOException e) {
            // this is an error we can live with
            logd("IOException while requesting forecast " + e);
        }
        return processWeatherResponse(currentWeatherResponse.body(), forecastResponse, tempUnit);
    } else {
        return null;
    }
}
#end_block

#method_before
private WeatherInfo processWeatherResponse(CurrentWeatherResponse currentWeatherResponse, ForecastResponse forecastResponse) {
    if (currentWeatherResponse.getInternalCode() == 404) {
        // city ID that we got by looking up a city...not our fault
        return null;
    }
    final String cityName = currentWeatherResponse.getCityName();
    final double temperature = currentWeatherResponse.getTemperature();
    // We need at least the city name and current temperature
    if (cityName == null || Double.isNaN(temperature))
        return null;
    WeatherInfo.Builder builder = new WeatherInfo.Builder(cityName, sanitizeTemperature(temperature, true), WeatherContract.WeatherColumns.TempUnit.CELSIUS).setTimestamp(System.currentTimeMillis());
    builder.setWeatherCondition(mapConditionIconToCode(currentWeatherResponse.getWeatherIconId(), currentWeatherResponse.getConditionCode()));
    final double humidity = currentWeatherResponse.getHumidity();
    if (!Double.isNaN(humidity)) {
        builder.setHumidity(humidity);
    }
    final double todaysHigh = currentWeatherResponse.getTodaysMaxTemp();
    if (!Double.isNaN(todaysHigh)) {
        builder.setTodaysHigh(todaysHigh);
    }
    final double todaysLow = currentWeatherResponse.getTodaysMinTemp();
    if (!Double.isNaN(todaysLow)) {
        builder.setTodaysLow(todaysLow);
    }
    final double windDir = currentWeatherResponse.getWindDirection();
    final double windSpeed = currentWeatherResponse.getWindSpeed();
    if (!Double.isNaN(windDir) && !Double.isNaN(windSpeed)) {
        builder.setWind(windSpeed, windDir, WeatherContract.WeatherColumns.WindSpeedUnit.KPH);
    }
    if (forecastResponse != null) {
        List<WeatherInfo.DayForecast> forecastList = new ArrayList<>();
        for (ForecastResponse.DayForecast forecast : forecastResponse.getForecastList()) {
            WeatherInfo.DayForecast.Builder forecastBuilder = new WeatherInfo.DayForecast.Builder(mapConditionIconToCode(forecast.getWeatherIconId(), forecast.getConditionCode()));
            final double max = forecast.getMaxTemp();
            if (!Double.isNaN(max)) {
                forecastBuilder.setHigh(max);
            }
            final double min = forecast.getMinTemp();
            if (!Double.isNaN(min)) {
                forecastBuilder.setLow(min);
            }
            forecastList.add(forecastBuilder.build());
        }
        builder.setForecast(forecastList);
    }
    return builder.build();
}
#method_after
private WeatherInfo processWeatherResponse(CurrentWeatherResponse currentWeatherResponse, ForecastResponse forecastResponse, int tempUnit) {
    if (currentWeatherResponse.getInternalCode() == 404) {
        // city ID that we got by looking up a city...not our fault
        return null;
    }
    final String cityName = currentWeatherResponse.getCityName();
    final double temperature = currentWeatherResponse.getTemperature();
    // We need at least the city name and current temperature
    if (cityName == null || Double.isNaN(temperature))
        return null;
    WeatherInfo.Builder builder = new WeatherInfo.Builder(cityName, sanitizeTemperature(temperature, true), tempUnit).setTimestamp(System.currentTimeMillis());
    builder.setWeatherCondition(mapConditionIconToCode(currentWeatherResponse.getWeatherIconId(), currentWeatherResponse.getConditionCode()));
    final double humidity = currentWeatherResponse.getHumidity();
    if (!Double.isNaN(humidity)) {
        builder.setHumidity(humidity);
    }
    final double todaysHigh = currentWeatherResponse.getTodaysMaxTemp();
    if (!Double.isNaN(todaysHigh)) {
        builder.setTodaysHigh(todaysHigh);
    }
    final double todaysLow = currentWeatherResponse.getTodaysMinTemp();
    if (!Double.isNaN(todaysLow)) {
        builder.setTodaysLow(todaysLow);
    }
    final double windDir = currentWeatherResponse.getWindDirection();
    final double windSpeed = currentWeatherResponse.getWindSpeed();
    if (!Double.isNaN(windDir) && !Double.isNaN(windSpeed)) {
        builder.setWind(windSpeed, windDir, WeatherContract.WeatherColumns.WindSpeedUnit.KPH);
    }
    if (forecastResponse != null) {
        List<WeatherInfo.DayForecast> forecastList = new ArrayList<>();
        for (ForecastResponse.DayForecast forecast : forecastResponse.getForecastList()) {
            WeatherInfo.DayForecast.Builder forecastBuilder = new WeatherInfo.DayForecast.Builder(mapConditionIconToCode(forecast.getWeatherIconId(), forecast.getConditionCode()));
            final double max = forecast.getMaxTemp();
            if (!Double.isNaN(max)) {
                forecastBuilder.setHigh(max);
            }
            final double min = forecast.getMinTemp();
            if (!Double.isNaN(min)) {
                forecastBuilder.setLow(min);
            }
            forecastList.add(forecastBuilder.build());
        }
        builder.setForecast(forecastList);
    }
    return builder.build();
}
#end_block

#method_before
private void setupActionBar() {
    mToolbar = (Toolbar) findViewById(R.id.toolbar);
    setActionBar(mToolbar);
    ActionBar actionBar = getActionBar();
}
#method_after
private void setupActionBar() {
    mToolbar = (Toolbar) findViewById(R.id.toolbar);
    setActionBar(mToolbar);
}
#end_block

#method_before
private void initListAdapter() {
    mListAdapter = new ConversationListAdapter(this, null);
    mListAdapter.setOnContentChangedListener(mContentChangedListener);
    mListHeadersListView.setAdapter(mListAdapter);
    getListView().getWrappedList().setRecyclerListener(mListAdapter);
}
#method_after
private void initListAdapter() {
    mListAdapter = new ConversationListAdapter(this, null);
    mListAdapter.setOnContentChangedListener(mContentChangedListener);
    mListHeadersListView.setAdapter(mListAdapter);
    getListView().getWrappedList().setRecyclerListener(mListAdapter);
    MmsApp.getApplication().addPhoneNumberLookupListener(mListAdapter);
}
#end_block

#method_before
@Override
protected void onDestroy() {
    super.onDestroy();
    mListAdapter.destroy();
    MessageUtils.removeDialogs();
}
#method_after
@Override
protected void onDestroy() {
    super.onDestroy();
    MmsApp.getApplication().removePhoneNumberLookupListener(mListAdapter);
    MessageUtils.removeDialogs();
}
#end_block

#method_before
@Override
public boolean onCreateActionMode(ActionMode mode, Menu menu) {
    MenuInflater inflater = getMenuInflater();
    mSelectedThreadIds = new HashSet<Long>();
    inflater.inflate(R.menu.conversation_multi_select_menu, menu);
    if (mFilterSpinner.getVisibility() == View.VISIBLE) {
        mFilterSpinner.setEnabled(false);
    }
    return true;
}
#method_after
@Override
public boolean onCreateActionMode(ActionMode mode, Menu menu) {
    MenuInflater inflater = getMenuInflater();
    mSelectedThreadIds = new HashSet<Long>();
    mSelectedThreadNumbers = new HashSet<String>();
    inflater.inflate(R.menu.conversation_multi_select_menu, menu);
    if (mFilterSpinner.getVisibility() == View.VISIBLE) {
        mFilterSpinner.setEnabled(false);
    }
    int actionBarColor = getResources().getColor(R.color.mms_next_theme_bulkedit_actionbar);
    int statusBarColor = getResources().getColor(R.color.mms_next_theme_bulkedit_statusbar);
    // Start with theme color
    mStatusBarColor = actionBarColor;
    setStatusBarColor(statusBarColor);
    return true;
}
#end_block

#method_before
@Override
public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
    switch(item.getItemId()) {
        case R.id.delete:
            if (mSelectedThreadIds.size() > 0) {
                confirmDeleteThreads(mSelectedThreadIds, mQueryHandler);
            }
            mode.finish();
            break;
        case R.id.selection_toggle:
            if (allItemsSelected()) {
                unCheckAll();
            } else {
                checkAll();
                mode.invalidate();
            }
            break;
        case R.id.markAsUnread:
            if (mSelectedThreadIds.size() > 0) {
                confirmMarkAsUnreadDialog(new MarkAsUnreadThreadListener(mSelectedThreadIds, mQueryHandler, ConversationList.this), mSelectedThreadIds, ConversationList.this);
            }
            mode.finish();
            break;
        case R.id.markAsRead:
            if (mSelectedThreadIds.size() > 0) {
                confirmMarkAsReadDialog(new MarkAsReadThreadListener(mSelectedThreadIds, mQueryHandler, ConversationList.this), mSelectedThreadIds, ConversationList.this);
            }
            mode.finish();
            break;
        default:
            break;
    }
    return true;
}
#method_after
@Override
public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
    switch(item.getItemId()) {
        case R.id.block:
            if (mSelectedThreadIds.size() > 0) {
                String[] numbers = new String[mSelectedThreadNumbers.size()];
                mSelectedThreadNumbers.toArray(numbers);
                confirmBlockUsersFromThreads(numbers);
            }
            mode.finish();
            break;
        case R.id.delete:
            if (mSelectedThreadIds.size() > 0) {
                confirmDeleteThreads(mSelectedThreadIds, mQueryHandler);
            }
            mode.finish();
            break;
        case R.id.selection_toggle:
            if (allItemsSelected()) {
                unCheckAll();
            } else {
                checkAll();
                mode.invalidate();
            }
            break;
        case R.id.markAsUnread:
            if (mSelectedThreadIds.size() > 0) {
                confirmMarkAsUnreadDialog(new MarkAsUnreadThreadListener(mSelectedThreadIds, mQueryHandler, ConversationList.this), mSelectedThreadIds, ConversationList.this);
            }
            mode.finish();
            break;
        case R.id.markAsRead:
            if (mSelectedThreadIds.size() > 0) {
                confirmMarkAsReadDialog(new MarkAsReadThreadListener(mSelectedThreadIds, mQueryHandler, ConversationList.this), mSelectedThreadIds, ConversationList.this);
            }
            mode.finish();
            break;
        default:
            break;
    }
    return true;
}
#end_block

#method_before
@Override
public void onDestroyActionMode(ActionMode mode) {
    ConversationListAdapter adapter = (ConversationListAdapter) getListView().getAdapter();
    adapter.uncheckAll();
    mSelectedThreadIds = null;
    if (mFilterSpinner.getVisibility() == View.VISIBLE) {
        mFilterSpinner.setEnabled(true);
    }
}
#method_after
@Override
public void onDestroyActionMode(ActionMode mode) {
    ConversationListAdapter adapter = (ConversationListAdapter) getListView().getAdapter();
    adapter.uncheckAll();
    mSelectedThreadIds = null;
    mSelectedThreadNumbers = null;
    setStatusBarColor(getResources().getColor(R.color.mms_next_theme_color_dark));
    if (mFilterSpinner.getVisibility() == View.VISIBLE) {
        mFilterSpinner.setEnabled(true);
    }
}
#end_block

#method_before
@Override
public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {
    final int checkedCount = mListHeadersListView.getCheckedItemCount();
    mode.setTitle(getString(R.string.selected_count, checkedCount));
    mode.getMenu().findItem(R.id.selection_toggle).setTitle(getString(allItemsSelected() ? R.string.deselected_all : R.string.selected_all));
    Cursor cursor = (Cursor) mListHeadersListView.getItemAtPosition(position);
    Conversation conv = Conversation.from(ConversationList.this, cursor);
    conv.setIsChecked(checked);
    long threadId = conv.getThreadId();
    if (checked) {
        mSelectedThreadIds.add(threadId);
    } else {
        mSelectedThreadIds.remove(threadId);
    }
}
#method_after
@Override
public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) {
    final int checkedCount = mListHeadersListView.getCheckedItemCount();
    mode.setTitle(getString(R.string.selected_count, checkedCount));
    mode.getMenu().findItem(R.id.selection_toggle).setTitle(getString(allItemsSelected() ? R.string.deselected_all : R.string.selected_all));
    Cursor cursor = (Cursor) mListHeadersListView.getItemAtPosition(position);
    Conversation conv = Conversation.from(ConversationList.this, cursor);
    conv.setIsChecked(checked);
    long threadId = conv.getThreadId();
    if (checked) {
        mSelectedThreadIds.add(threadId);
        for (Contact contact : conv.getRecipients()) {
            mSelectedThreadNumbers.add(contact.getNumber());
        }
    } else {
        mSelectedThreadIds.remove(threadId);
        for (Contact contact : conv.getRecipients()) {
            mSelectedThreadNumbers.remove(contact.getNumber());
        }
    }
}
#end_block

#method_before
private void updateAvatarView(String addr, boolean isSelf) {
    Drawable avatarDrawable;
    if (isSelf || !TextUtils.isEmpty(addr)) {
        Contact contact = isSelf ? Contact.getMe(false) : Contact.get(addr, true);
        contact.bindAvatar(mAvatar);
        if (isSelf) {
            mAvatar.assignContactUri(Profile.CONTENT_URI);
        } else {
            if (contact.existsInDatabase()) {
                mAvatar.assignContactUri(contact.getUri());
            } else if (MessageUtils.isWapPushNumber(contact.getNumber())) {
                mAvatar.assignContactFromPhone(MessageUtils.getWapPushNumber(contact.getNumber()), true);
            } else {
                mAvatar.assignContactFromPhone(contact.getNumber(), true);
            }
        }
        checkForUnknownContact(this, contact);
    } else {
        mAvatar.setImageDrawable(sDefaultContactImage);
    }
}
#method_after
private void updateAvatarView(String addr, boolean isSelf) {
    Drawable avatarDrawable;
    if (isSelf || !TextUtils.isEmpty(addr)) {
        Contact contact = isSelf ? Contact.getMe(false) : Contact.get(addr, true);
        contact.bindAvatar(mAvatar);
        if (isSelf) {
            mAvatar.assignContactUri(Profile.CONTENT_URI);
        } else {
            if (contact.existsInDatabase()) {
                mAvatar.assignContactUri(contact.getUri());
            } else if (MessageUtils.isWapPushNumber(contact.getNumber())) {
                mAvatar.assignContactFromPhone(MessageUtils.getWapPushNumber(contact.getNumber()), true);
            } else {
                mAvatar.assignContactFromPhone(contact.getNumber(), true);
            }
        }
        checkForUnknownContact(contact);
    } else {
        mAvatar.setImageDrawable(sDefaultContactImage);
    }
}
#end_block

#method_before
private void checkForUnknownContact(MessageListItem listItem, Contact contact) {
    if (!contact.existsInDatabase()) {
        String number = AddressUtils.normalizePhoneNumber(contact.getNumber());
        LookupResponse lookupResponse = MmsApp.getApplication().getPhoneNumberLookupResponse(number);
        if (lookupResponse != null) {
            listItem.updateView(lookupResponse);
        } else {
            // request info for this contact
            MmsApp.getApplication().lookupInfoForPhoneNumber(number);
        }
    }
}
#method_after
private void checkForUnknownContact(Contact contact) {
    if (!contact.existsInDatabase()) {
        String number = AddressUtils.normalizePhoneNumber(contact.getNumber());
        LookupResponse lookupResponse = MmsApp.getApplication().getPhoneNumberLookupResponse(number);
        if (lookupResponse != null) {
            updateView(lookupResponse);
        } else {
            // request info for this contact
            MmsApp.getApplication().lookupInfoForPhoneNumber(number);
        }
    }
}
#end_block

#method_before
@Override
public void onNewInfoAvailable() {
    notifyDataSetChanged();
}
#method_after
@Override
public void onNewInfoAvailable() {
    if (!mHandler.hasMessages(MSG_REDRAW)) {
        mHandler.sendEmptyMessageDelayed(MSG_REDRAW, 500);
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    if (Log.isLoggable(LogTag.STRICT_MODE_TAG, Log.DEBUG)) {
        // Log tag for enabling/disabling StrictMode violation log. This will dump a stack
        // in the log that shows the StrictMode violator.
        // To enable: adb shell setprop log.tag.Mms:strictmode DEBUG
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
    }
    sMmsApp = this;
    // Load the default preference values
    PreferenceManager.setDefaultValues(this, R.xml.preferences, false);
    // Figure out the country *before* loading contacts and formatting numbers
    mCountryDetector = (CountryDetector) getSystemService(Context.COUNTRY_DETECTOR);
    mCountryListener = new CountryListener() {

        @Override
        public synchronized void onCountryDetected(Country country) {
            mCountryIso = country.getCountryIso();
        }
    };
    mCountryDetector.addCountryListener(mCountryListener, getMainLooper());
    Context context = getApplicationContext();
    mPduLoaderManager = new PduLoaderManager(context);
    mThumbnailManager = new ThumbnailManager(context);
    JodaTimeAndroid.init(this);
    MmsConfig.init(this);
    Contact.init(this);
    DraftCache.init(this);
    Conversation.init(this);
    DownloadManager.init(this);
    RateController.init(this);
    LayoutManager.init(this);
    SmileyParser.init(this);
    MessagingNotification.init(this);
    activePendingMessages();
    // TODO : explore lazy initialization
    initializePhoneNumberLookup();
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    if (Log.isLoggable(LogTag.STRICT_MODE_TAG, Log.DEBUG)) {
        // Log tag for enabling/disabling StrictMode violation log. This will dump a stack
        // in the log that shows the StrictMode violator.
        // To enable: adb shell setprop log.tag.Mms:strictmode DEBUG
        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder().detectAll().penaltyLog().build());
    }
    sMmsApp = this;
    // Load the default preference values
    PreferenceManager.setDefaultValues(this, R.xml.preferences, false);
    // Figure out the country *before* loading contacts and formatting numbers
    mCountryDetector = (CountryDetector) getSystemService(Context.COUNTRY_DETECTOR);
    mCountryListener = new CountryListener() {

        @Override
        public synchronized void onCountryDetected(Country country) {
            mCountryIso = country.getCountryIso();
        }
    };
    mCountryDetector.addCountryListener(mCountryListener, getMainLooper());
    Context context = getApplicationContext();
    mPduLoaderManager = new PduLoaderManager(context);
    mThumbnailManager = new ThumbnailManager(context);
    JodaTimeAndroid.init(this);
    MmsConfig.init(this);
    Contact.init(this);
    DraftCache.init(this);
    Conversation.init(this);
    DownloadManager.init(this);
    RateController.init(this);
    LayoutManager.init(this);
    SmileyParser.init(this);
    MessagingNotification.init(this);
    activePendingMessages();
    mPhoneNumberLookupCache = new ConcurrentHashMap<>();
    mLookupListeners = new HashSet<>();
    registerActivityLifecycleCallbacks(this);
}
#end_block

#method_before
@Override
public void onActivityDestroyed(Activity activity) {
    --mActivityCount;
    if (mActivityCount == 0) {
        if (isPhoneNumberLookupInitialized) {
            // tear down the phone number lookup-cache and handler thread
            mLookupHandlerThread.quit();
            mLookupHandlerThread = null;
            mPhoneNumberLookupCache.clear();
            mPhoneNumberLookupCache = null;
            mLookupListeners.clear();
            mLookupListeners = null;
        }
    }
}
#method_after
@Override
public void onActivityDestroyed(Activity activity) {
    --mActivityCount;
    if (mActivityCount == 0) {
        if (isPhoneNumberLookupInitialized) {
            // tear down the phone number lookup-cache and handler thread
            tearDownPhoneLookup();
        }
    }
}
#end_block

#method_before
public boolean lookupInfoForPhoneNumber(String phoneNumber, boolean requery) {
    if (!isPhoneNumberLookupInitialized || phoneNumber == null)
        return false;
    // don't
    if (!requery && mPhoneNumberLookupCache.get(phoneNumber) != null) {
        return false;
    }
    LookupRequest lookupRequest = new LookupRequest(phoneNumber, this);
    return mLookupHandlerThread.fetchInfoForPhoneNumber(lookupRequest);
}
#method_after
public boolean lookupInfoForPhoneNumber(String phoneNumber, boolean requery) {
    if (!isPhoneNumberLookupInitialized || phoneNumber == null)
        return false;
    if (!requery && mPhoneNumberLookupCache.get(phoneNumber) != null) {
        return false;
    }
    LookupRequest lookupRequest = new LookupRequest(phoneNumber, this);
    // lookup handler thread should be initialized already due to onResume
    return getLookupHandlerThread().fetchInfoForPhoneNumber(lookupRequest);
}
#end_block

#method_before
public void addPhoneNumberLookupListener(PhoneNumberLookupListener listener) {
    if (!isPhoneNumberLookupInitialized)
        return;
    mLookupListeners.add(listener);
}
#method_after
public void addPhoneNumberLookupListener(PhoneNumberLookupListener listener) {
    mLookupListeners.add(listener);
}
#end_block

#method_before
public void removePhoneNumberLookupListener(PhoneNumberLookupListener listener) {
    if (!isPhoneNumberLookupInitialized)
        return;
    mLookupListeners.remove(listener);
}
#method_after
public void removePhoneNumberLookupListener(PhoneNumberLookupListener listener) {
    mLookupListeners.remove(listener);
}
#end_block

#method_before
@Override
public void onActivityResumed(Activity activity) {
}
#method_after
@Override
public void onActivityResumed(Activity activity) {
    if (isPhoneNumberLookupInitialized && !getLookupHandlerThread().isProviderEnabled()) {
        // tear down if transitioning to not enabled
        tearDownPhoneLookup();
        return;
    }
    isPhoneNumberLookupInitialized = getLookupHandlerThread().initialize();
}
#end_block

#method_before
private void confirmSendMessageIfNeeded(int slotId) {
    if (isLTEOnlyMode(slotId)) {
        showDisableLTEOnlyDialog(slotId);
        return;
    }
    boolean isMms = mWorkingMessage.requiresMms();
    int[] subIds = SubscriptionManager.getSubId(slotId);
    if (subIds == null || subIds.length == 0) {
        return;
    }
    if (!isRecipientsEditorVisible()) {
        sendMsimMessage(true, subIds[0]);
        return;
    }
    if (mRecipientsEditor.hasInvalidRecipient(isMms)) {
        showInvalidRecipientDialog();
    } else {
        // The recipients editor is still open. Make sure we use what's showing there
        // as the destination.
        ContactList contacts = mRecipientsEditor.constructContactsFromInput(false);
        mDebugRecipients = contacts.serialize();
        sendMsimMessage(true, subIds[0]);
    }
}
#method_after
private void confirmSendMessageIfNeeded(int slotId) {
    if (isLTEOnlyMode(slotId)) {
        showDisableLTEOnlyDialog(slotId);
        return;
    }
    boolean isMms = mWorkingMessage.requiresMms();
    int[] subIds = SubscriptionManager.getSubId(slotId);
    if (subIds == null || subIds.length == 0) {
        return;
    }
    if (!isRecipientsEditorVisible()) {
        sendMsimMessage(true, subIds[0]);
        return;
    }
    if (mRecipientsEditor.hasInvalidRecipient(isMms)) {
        showInvalidRecipientDialog();
    } else {
        // The recipients editor is still open. Make sure we use what's showing there
        // as the destination.
        mRecipients = mRecipientsEditor.constructContactsFromInput(false);
        sendMsimMessage(true, subIds[0]);
    }
}
#end_block

#method_before
private void confirmSendMessageIfNeeded() {
    int slot = SubscriptionManager.getSlotId(SubscriptionManager.getDefaultSmsSubId());
    if ((TelephonyManager.getDefault().isMultiSimEnabled() && isLTEOnlyMode(slot)) || (!TelephonyManager.getDefault().isMultiSimEnabled() && isLTEOnlyMode())) {
        showDisableLTEOnlyDialog(slot);
        return;
    }
    if (!isRecipientsEditorVisible()) {
        if ((TelephonyManager.getDefault().getPhoneCount()) > 1) {
            sendMsimMessage(true);
        } else {
            sendMessage(true);
        }
        return;
    }
    boolean isMms = mWorkingMessage.requiresMms();
    if (mRecipientsEditor.hasInvalidRecipient(isMms)) {
        showInvalidRecipientDialog();
    } else {
        // The recipients editor is still open. Make sure we use what's showing there
        // as the destination.
        ContactList contacts = mRecipientsEditor.constructContactsFromInput(false);
        mDebugRecipients = contacts.serialize();
        if ((TelephonyManager.getDefault().getPhoneCount()) > 1) {
            sendMsimMessage(true);
        } else {
            sendMessage(true);
        }
    }
}
#method_after
private void confirmSendMessageIfNeeded() {
    int slot = SubscriptionManager.getSlotId(SubscriptionManager.getDefaultSmsSubId());
    if ((TelephonyManager.getDefault().isMultiSimEnabled() && isLTEOnlyMode(slot)) || (!TelephonyManager.getDefault().isMultiSimEnabled() && isLTEOnlyMode())) {
        showDisableLTEOnlyDialog(slot);
        return;
    }
    if (!isRecipientsEditorVisible()) {
        if ((TelephonyManager.getDefault().getPhoneCount()) > 1) {
            sendMsimMessage(true);
        } else {
            sendMessage(true);
        }
        return;
    }
    boolean isMms = mWorkingMessage.requiresMms();
    if (mRecipientsEditor.hasInvalidRecipient(isMms)) {
        showInvalidRecipientDialog();
    } else {
        // The recipients editor is still open. Make sure we use what's showing there
        // as the destination.
        mRecipients = mRecipientsEditor.constructContactsFromInput(false);
        if ((TelephonyManager.getDefault().getPhoneCount()) > 1) {
            sendMsimMessage(true);
        } else {
            sendMessage(true);
        }
    }
}
#end_block

#method_before
private void updateTitle(ContactList list) {
    String title = null;
    String subTitle = null;
    int cnt = list.size();
    switch(cnt) {
        case 0:
            {
                String recipient = null;
                if (mRecipientsEditor != null) {
                    recipient = mRecipientsEditor.getText().toString();
                }
                if (MessageUtils.isWapPushNumber(recipient)) {
                    String[] mAddresses = recipient.split(":");
                    title = mAddresses[getResources().getInteger(R.integer.wap_push_address_index)];
                } else {
                    title = TextUtils.isEmpty(recipient) ? getString(R.string.new_message) : recipient;
                }
                break;
            }
        case 1:
            {
                // get name returns the number if there's no
                title = list.get(0).getName();
                // name available.
                String number = list.get(0).getNumber();
                if (MessageUtils.isWapPushNumber(number)) {
                    String[] mTitleNumber = number.split(":");
                    number = mTitleNumber[getResources().getInteger(R.integer.wap_push_address_index)];
                }
                if (MessageUtils.isWapPushNumber(title)) {
                    String[] mTitle = title.split(":");
                    title = mTitle[getResources().getInteger(R.integer.wap_push_address_index)];
                }
                String formattedNumber = PhoneNumberUtils.formatNumber(number, number, MmsApp.getApplication().getCurrentCountryIso());
                if (mTextCounter.isLayoutRtl()) {
                    // Change the phonenumber display normally for RTL.
                    if (formattedNumber.charAt(0) != '\u202D') {
                        formattedNumber = '\u202D' + formattedNumber + '\u202C';
                    }
                }
                if (title.equals(number)) {
                    title = formattedNumber;
                } else {
                    subTitle = formattedNumber;
                }
                break;
            }
        default:
            {
                // Handle multiple recipients
                title = list.formatNames(", ");
                subTitle = getResources().getQuantityString(R.plurals.recipient_count, cnt, cnt);
                break;
            }
    }
    mDebugRecipients = list.serialize();
    if (cnt > 0 && !mAccentColorLoaded && !mLoadingAccentColor) {
        final Contact contact = list.get(0);
        // first see whether there's a cached color already
        int color = contact.getAccentColor(this, false);
        if (color != 0) {
            mAccentColorLoaded = true;
            updateColorPalette(color);
        } else {
            mLoadingAccentColor = true;
            new AsyncTask<Void, Void, Integer>() {

                @Override
                protected Integer doInBackground(Void... params) {
                    return contact.getAccentColor(ComposeMessageActivity.this, true);
                }

                @Override
                protected void onPostExecute(Integer color) {
                    if (mLoadingAccentColor) {
                        mLoadingAccentColor = false;
                        mAccentColorLoaded = true;
                        updateColorPalette(color);
                    }
                }
            }.execute();
        }
    } else if (cnt == 0) {
        mLoadingAccentColor = false;
        if (mAccentColorLoaded) {
            mAccentColorLoaded = false;
            updateAccentColorFromTheme(false);
        }
    }
    // the cnt is already be added recipients count
    mExistsRecipientsCount = cnt;
    mToolBar.setTitle(title);
    mToolBar.setSubtitle(subTitle);
}
#method_after
private void updateTitle(ContactList list) {
    String title = null;
    String subTitle = null;
    int cnt = list.size();
    switch(cnt) {
        case 0:
            {
                String recipient = null;
                if (mRecipientsEditor != null) {
                    recipient = mRecipientsEditor.getText().toString();
                }
                if (MessageUtils.isWapPushNumber(recipient)) {
                    String[] mAddresses = recipient.split(":");
                    title = mAddresses[getResources().getInteger(R.integer.wap_push_address_index)];
                } else {
                    title = TextUtils.isEmpty(recipient) ? getString(R.string.new_message) : recipient;
                }
                break;
            }
        case 1:
            {
                // get name returns the number if there's no
                title = list.get(0).getName();
                // name available.
                String number = list.get(0).getNumber();
                if (MessageUtils.isWapPushNumber(number)) {
                    String[] mTitleNumber = number.split(":");
                    number = mTitleNumber[getResources().getInteger(R.integer.wap_push_address_index)];
                }
                if (MessageUtils.isWapPushNumber(title)) {
                    String[] mTitle = title.split(":");
                    title = mTitle[getResources().getInteger(R.integer.wap_push_address_index)];
                }
                String formattedNumber = PhoneNumberUtils.formatNumber(number, number, MmsApp.getApplication().getCurrentCountryIso());
                if (mTextCounter.isLayoutRtl()) {
                    // Change the phonenumber display normally for RTL.
                    if (formattedNumber.charAt(0) != '\u202D') {
                        formattedNumber = '\u202D' + formattedNumber + '\u202C';
                    }
                }
                if (title.equals(number)) {
                    title = formattedNumber;
                } else {
                    subTitle = formattedNumber;
                }
                break;
            }
        case 2:
        case 3:
            // Handle multiple recipients
            title = list.formatNames(", ");
            subTitle = getResources().getQuantityString(R.plurals.recipient_count, cnt, cnt);
            break;
        default:
            {
                // Handle many recipients
                title = getResources().getQuantityString(R.plurals.recipient_count, cnt, cnt);
                subTitle = null;
            }
    }
    mRecipients = list;
    if (cnt > 0 && !mAccentColorLoaded && !mLoadingAccentColor) {
        final Contact contact = list.get(0);
        // first see whether there's a cached color already
        int color = contact.getAccentColor(this, false);
        if (color != 0) {
            mAccentColorLoaded = true;
            updateColorPalette(color);
        } else {
            mLoadingAccentColor = true;
            new AsyncTask<Void, Void, Integer>() {

                @Override
                protected Integer doInBackground(Void... params) {
                    return contact.getAccentColor(ComposeMessageActivity.this, true);
                }

                @Override
                protected void onPostExecute(Integer color) {
                    if (mLoadingAccentColor) {
                        mLoadingAccentColor = false;
                        mAccentColorLoaded = true;
                        updateColorPalette(color);
                    }
                }
            }.execute();
        }
    } else if (cnt == 0) {
        mLoadingAccentColor = false;
        if (mAccentColorLoaded) {
            mAccentColorLoaded = false;
            updateAccentColorFromTheme(false);
        }
    }
    // the cnt is already be added recipients count
    mExistsRecipientsCount = cnt;
    mToolBar.setTitle(title);
    mToolBar.setSubtitle(subTitle);
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    mIsSmsEnabled = MmsConfig.isSmsEnabled(this);
    super.onCreate(savedInstanceState);
    resetConfiguration(getResources().getConfiguration());
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    String unicodeStripping = prefs.getString(MessagingPreferenceActivity.UNICODE_STRIPPING, MessagingPreferenceActivity.UNICODE_STRIPPING_LEAVE_INTACT);
    if (!TextUtils.equals(unicodeStripping, MessagingPreferenceActivity.UNICODE_STRIPPING_LEAVE_INTACT)) {
        boolean stripNonDecodableOnly = TextUtils.equals(unicodeStripping, MessagingPreferenceActivity.UNICODE_STRIPPING_NON_DECODABLE);
        mUnicodeFilter = new UnicodeFilter(stripNonDecodableOnly);
    }
    mEnableEmoticons = prefs.getBoolean(MessagingPreferenceActivity.ENABLE_EMOTICONS, true);
    View inflate = getLayoutInflater().inflate(R.layout.compose_message_activity, null);
    mZoomGestureOverlayView = new ZoomGestureOverlayView(this);
    mZoomGestureOverlayView.addZoomListener(this);
    mZoomGestureOverlayView.addView(inflate);
    mZoomGestureOverlayView.setEventsInterceptionEnabled(true);
    mZoomGestureOverlayView.setGestureVisible(false);
    setContentView(mZoomGestureOverlayView);
    setProgressBarVisibility(false);
    mShowAttachIcon = getResources().getBoolean(R.bool.config_show_attach_icon_always);
    // Initialize members for UI elements.
    initResourceRefs();
    mContentResolver = getContentResolver();
    mBackgroundQueryHandler = new BackgroundQueryHandler(mContentResolver);
    updateAccentColorFromTheme(true);
    initialize(savedInstanceState, 0);
    mPickupDetector = new PickupGestureDetector(ComposeMessageActivity.this, this);
    if (TRACE) {
        android.os.Debug.startMethodTracing("compose");
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    mIsSmsEnabled = MmsConfig.isSmsEnabled(this);
    mIsMsim = MessageUtils.isMsimIccCardActive();
    super.onCreate(savedInstanceState);
    resetConfiguration(getResources().getConfiguration());
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    String unicodeStripping = prefs.getString(MessagingPreferenceActivity.UNICODE_STRIPPING, MessagingPreferenceActivity.UNICODE_STRIPPING_LEAVE_INTACT);
    if (!TextUtils.equals(unicodeStripping, MessagingPreferenceActivity.UNICODE_STRIPPING_LEAVE_INTACT)) {
        boolean stripNonDecodableOnly = TextUtils.equals(unicodeStripping, MessagingPreferenceActivity.UNICODE_STRIPPING_NON_DECODABLE);
        mUnicodeFilter = new UnicodeFilter(stripNonDecodableOnly);
    }
    mEnableEmoticons = prefs.getBoolean(MessagingPreferenceActivity.ENABLE_EMOTICONS, true);
    View inflate = getLayoutInflater().inflate(R.layout.compose_message_activity, null);
    mZoomGestureOverlayView = new ZoomGestureOverlayView(this);
    mZoomGestureOverlayView.addZoomListener(this);
    mZoomGestureOverlayView.addView(inflate);
    mZoomGestureOverlayView.setEventsInterceptionEnabled(true);
    mZoomGestureOverlayView.setGestureVisible(false);
    setContentView(mZoomGestureOverlayView);
    setProgressBarVisibility(false);
    mShowAttachIcon = getResources().getBoolean(R.bool.config_show_attach_icon_always);
    // Initialize members for UI elements.
    initResourceRefs();
    mContentResolver = getContentResolver();
    mBackgroundQueryHandler = new BackgroundQueryHandler(mContentResolver);
    updateAccentColorFromTheme(true);
    initialize(savedInstanceState, 0);
    mPickupDetector = new PickupGestureDetector(ComposeMessageActivity.this, this);
    if (mIsMsim) {
        SimInfo simInfo = MessageUtils.getDefaultDataSimInfo(this);
        if (simInfo != null) {
            mCurrentSimInfo = simInfo;
            updateSimSelectionDrawable();
        }
    }
    if (TRACE) {
        android.os.Debug.startMethodTracing("compose");
    }
}
#end_block

#method_before
private void showSubjectEditor(boolean show) {
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("" + show);
    }
    if (mSubjectWrapper == null) {
        mSubjectWrapper = (LinearLayout) findViewById(R.id.subject_wrapper);
    }
    if (mSubjectTextEditor == null) {
        mSubjectTextEditor = (EditText) findViewById(R.id.subject);
        mSubjectTextEditor.setFilters(new InputFilter[] { new LengthFilter(SUBJECT_MAX_LENGTH) });
    }
    if (mSubjectRemoveButton == null) {
        mSubjectRemoveButton = (ImageView) findViewById(R.id.subject_cancel);
        // Adding this removal button so we don't have to rely on the broken on key listener
        // which only works on select third party soft IMEs or hardware keyboards from back
        // in the old days. Lollipop LatinIME specifies that it will refuse to send backward
        // compat updown key events for anything less than jelly bean.
        mSubjectRemoveButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View view) {
                showSubjectEditor(false);
                mWorkingMessage.setSubject(null, true);
                updateSendButtonState();
            }
        });
    }
    if (show) {
        mSubjectTextEditor.addTextChangedListener(mSubjectEditorWatcher);
    } else {
        mSubjectTextEditor.removeTextChangedListener(mSubjectEditorWatcher);
    }
    mSubjectTextEditor.setOnKeyListener(show ? mSubjectKeyListener : null);
    mSubjectTextEditor.setText(mWorkingMessage.getSubject());
    mSubjectWrapper.setVisibility(show ? View.VISIBLE : View.GONE);
    hideOrShowTopPanel();
}
#method_after
private void showSubjectEditor(boolean show) {
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("" + show);
    }
    if (mSubjectWrapper == null) {
        mSubjectWrapper = (LinearLayout) findViewById(R.id.subject_wrapper);
    }
    if (mSubjectTextEditor == null) {
        mSubjectTextEditor = (EditText) findViewById(R.id.subject);
        mSubjectTextEditor.setFilters(new InputFilter[] { new LengthFilter(SUBJECT_MAX_LENGTH) });
    }
    if (mSubjectRemoveButton == null) {
        mSubjectRemoveButton = (ImageView) findViewById(R.id.subject_cancel);
        // Adding this removal button so we don't have to rely on the broken on key listener
        // which only works on select third party soft IMEs or hardware keyboards from back
        // in the old days. Lollipop LatinIME specifies that it will refuse to send backward
        // compat updown key events for anything less than jelly bean.
        mSubjectRemoveButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View view) {
                showSubjectEditor(false);
                mWorkingMessage.setSubject(null, true);
                updateSendButtonState();
            }
        });
    }
    if (show) {
        mSubjectTextEditor.addTextChangedListener(mSubjectEditorWatcher);
        // Ensure the "to" label is hidden when Subject editor shows
        TextView toLabel = (TextView) findViewById(R.id.to_label);
        if (toLabel != null) {
            toLabel.setVisibility(View.GONE);
        }
    } else {
        mSubjectTextEditor.removeTextChangedListener(mSubjectEditorWatcher);
    }
    mSubjectTextEditor.setOnKeyListener(show ? mSubjectKeyListener : null);
    mSubjectTextEditor.setText(mWorkingMessage.getSubject());
    mSubjectWrapper.setVisibility(show ? View.VISIBLE : View.GONE);
    hideOrShowTopPanel();
}
#end_block

#method_before
public void initialize(Bundle savedInstanceState, long originalThreadId) {
    // Create a new empty working message.
    mWorkingMessage = WorkingMessage.createEmpty(this);
    // Read parameters or previously saved state of this activity. This will load a new
    // mConversation
    initActivityState(savedInstanceState);
    if (LogTag.SEVERE_WARNING && originalThreadId != 0 && originalThreadId == mConversation.getThreadId()) {
        LogTag.warnPossibleRecipientMismatch("ComposeMessageActivity.initialize: " + " threadId didn't change from: " + originalThreadId, this);
    }
    log("savedInstanceState = " + savedInstanceState + " intent = " + getIntent() + " mConversation = " + mConversation);
    if (MessageUtils.cancelFailedToDeliverNotification(getIntent(), this)) {
        // Show a pop-up dialog to inform user the message was
        // failed to deliver.
        undeliveredMessageDialog(getMessageDate(null));
    }
    MessageUtils.cancelFailedDownloadNotification(getIntent(), this);
    // Set up the message history ListAdapter
    initMessageList();
    mShouldLoadDraft = true;
    // Load the draft for this thread, if we aren't already handling
    // existing data, such as a shared picture or forwarded message.
    boolean isForwardedMessage = false;
    // handled the attachment or the send, so we don't try and parse the intent again.
    if (savedInstanceState == null && (handleSendIntent() || handleForwardedMessage())) {
        mShouldLoadDraft = false;
    }
    // Let the working message know what conversation it belongs to
    mWorkingMessage.setConversation(mConversation);
    handleResendMessage();
    // Show the recipients editor if we don't have a valid thread. Hide it otherwise.
    if (mConversation.getThreadId() <= 0) {
        // Hide the recipients editor so the call to initRecipientsEditor won't get
        // short-circuited.
        hideRecipientEditor();
        initRecipientsEditor();
    } else {
        hideRecipientEditor();
    }
    updateSendButtonState();
    drawTopPanel(false);
    if (!mShouldLoadDraft) {
        // We're not loading a draft, so we can draw the bottom panel immediately.
        drawBottomPanel();
    }
    onKeyboardStateChanged();
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("update title, mConversation=" + mConversation.toString());
    }
    updateTitle(mConversation.getRecipients());
    if (isForwardedMessage && isRecipientsEditorVisible()) {
        // The user is forwarding the message to someone. Put the focus on the
        // recipient editor rather than in the message editor.
        mRecipientsEditor.requestFocus();
    }
    mMsgListAdapter.setIsGroupConversation(mConversation.getRecipients().size() > 1);
}
#method_after
public void initialize(Bundle savedInstanceState, long originalThreadId) {
    // Create a new empty working message.
    mWorkingMessage = WorkingMessage.createEmpty(this);
    // Read parameters or previously saved state of this activity. This will load a new
    // mConversation
    initActivityState(savedInstanceState);
    if (LogTag.SEVERE_WARNING && originalThreadId != 0 && originalThreadId == mConversation.getThreadId()) {
        LogTag.warnPossibleRecipientMismatch("ComposeMessageActivity.initialize: " + " threadId didn't change from: " + originalThreadId, this);
    }
    log("savedInstanceState = " + savedInstanceState + " intent = " + getIntent() + " mConversation = " + mConversation);
    if (MessageUtils.cancelFailedToDeliverNotification(getIntent(), this)) {
        // Show a pop-up dialog to inform user the message was
        // failed to deliver.
        undeliveredMessageDialog(getMessageDate(null));
    }
    MessageUtils.cancelFailedDownloadNotification(getIntent(), this);
    // Set up the message history ListAdapter
    initMessageList();
    mShouldLoadDraft = true;
    // Load the draft for this thread, if we aren't already handling
    // existing data, such as a shared picture or forwarded message.
    boolean isForwardedMessage = false;
    // handled the attachment or the send, so we don't try and parse the intent again.
    if (savedInstanceState == null && (handleSendIntent() || handleForwardedMessage())) {
        mShouldLoadDraft = false;
    }
    // Let the working message know what conversation it belongs to
    mWorkingMessage.setConversation(mConversation);
    handleResendMessage();
    // Show the recipients editor if we don't have a valid thread. Hide it otherwise.
    if (mConversation.getThreadId() <= 0) {
        // Hide the recipients editor so the call to initRecipientsEditor won't get
        // short-circuited.
        hideRecipientEditor();
        initRecipientsEditor();
    } else {
        hideRecipientEditor();
    }
    updateSendButtonState();
    drawTopPanel(false);
    if (!mShouldLoadDraft) {
        // We're not loading a draft, so we can draw the bottom panel immediately.
        drawBottomPanel();
    }
    onKeyboardStateChanged();
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("update title, mConversation=" + mConversation.toString());
    }
    if (isForwardedMessage && isRecipientsEditorVisible()) {
        // The user is forwarding the message to someone. Put the focus on the
        // recipient editor rather than in the message editor.
        mRecipientsEditor.requestFocus();
    }
    mMsgListAdapter.setIsGroupConversation(mConversation.getRecipients().size() > 1);
}
#end_block

#method_before
@Override
protected void onStart() {
    super.onStart();
    boolean isSmsEnabled = MmsConfig.isSmsEnabled(this);
    if (isSmsEnabled != mIsSmsEnabled) {
        mIsSmsEnabled = isSmsEnabled;
        invalidateOptionsMenu();
    }
    initFocus();
    // Register a BroadcastReceiver to listen on HTTP I/O process.
    registerReceiver(mHttpProgressReceiver, mHttpProgressFilter);
    registerReceiver(mDelayedSendProgressReceiver, DELAYED_SEND_COUNTDOWN_FILTER);
    // figure out whether we need to show the keyboard or not.
    // if there is draft to be loaded for 'mConversation', we'll show the keyboard;
    // otherwise we hide the keyboard. In any event, delay loading
    // message history and draft (controlled by DEFER_LOADING_MESSAGES_AND_DRAFT).
    int mode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    if (DraftCache.getInstance().hasDraft(mConversation.getThreadId())) {
        mode |= WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
    } else if (mConversation.getThreadId() <= 0) {
        // For composing a new message, bring up the softkeyboard so the user can
        // immediately enter recipients. This call won't do anything on devices with
        // a hard keyboard.
        mode |= WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
    } else {
        mode |= WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN;
    }
    getWindow().setSoftInputMode(mode);
    // reset mMessagesAndDraftLoaded
    mMessagesAndDraftLoaded = false;
    CharSequence text = mWorkingMessage.getText();
    if (text != null) {
        mTextEditor.setTextKeepState(text);
    }
    if (!DEFER_LOADING_MESSAGES_AND_DRAFT) {
        loadMessagesAndDraft(1);
    } else {
        // HACK: force load messages+draft after max delay, if it's not already loaded.
        // this is to work around when coming out of sleep mode. WindowManager behaves
        // strangely and hides the keyboard when it should be shown, or sometimes initially
        // shows it when we want to hide it. In that case, we never get the onSizeChanged()
        // callback w/ keyboard shown, so we wouldn't know to load the messages+draft.
        mHandler.postDelayed(new Runnable() {

            public void run() {
                loadMessagesAndDraft(2);
            }
        }, LOADING_MESSAGES_AND_DRAFT_MAX_DELAY_MS);
    }
    // Update the fasttrack info in case any of the recipients' contact info changed
    // while we were paused. This can happen, for example, if a user changes or adds
    // an avatar associated with a contact.
    mWorkingMessage.syncWorkingRecipients();
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("update title, mConversation=" + mConversation.toString());
    }
    updateTitle(mConversation.getRecipients());
    ActionBar actionBar = getActionBar();
    actionBar.setDisplayHomeAsUpEnabled(true);
}
#method_after
@Override
protected void onStart() {
    super.onStart();
    boolean isSmsEnabled = MmsConfig.isSmsEnabled(this);
    if (isSmsEnabled != mIsSmsEnabled) {
        mIsSmsEnabled = isSmsEnabled;
        invalidateOptionsMenu();
    }
    initFocus();
    // Register a BroadcastReceiver to listen on HTTP I/O process.
    registerReceiver(mHttpProgressReceiver, mHttpProgressFilter);
    registerReceiver(mDelayedSendProgressReceiver, DELAYED_SEND_COUNTDOWN_FILTER);
    // figure out whether we need to show the keyboard or not.
    // if there is draft to be loaded for 'mConversation', we'll show the keyboard;
    // otherwise we hide the keyboard. In any event, delay loading
    // message history and draft (controlled by DEFER_LOADING_MESSAGES_AND_DRAFT).
    int mode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;
    if (DraftCache.getInstance().hasDraft(mConversation.getThreadId())) {
        mode |= WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
    } else if (mConversation.getThreadId() <= 0) {
        // For composing a new message, bring up the softkeyboard so the user can
        // immediately enter recipients. This call won't do anything on devices with
        // a hard keyboard.
        mode |= WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE;
    } else {
        mode |= WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN;
    }
    getWindow().setSoftInputMode(mode);
    // reset mMessagesAndDraftLoaded
    mMessagesAndDraftLoaded = false;
    CharSequence text = mWorkingMessage.getText();
    if (text != null) {
        mTextEditor.setTextKeepState(text);
    }
    if (!DEFER_LOADING_MESSAGES_AND_DRAFT) {
        loadMessagesAndDraft(1);
    } else {
        // HACK: force load messages+draft after max delay, if it's not already loaded.
        // this is to work around when coming out of sleep mode. WindowManager behaves
        // strangely and hides the keyboard when it should be shown, or sometimes initially
        // shows it when we want to hide it. In that case, we never get the onSizeChanged()
        // callback w/ keyboard shown, so we wouldn't know to load the messages+draft.
        mHandler.postDelayed(new Runnable() {

            public void run() {
                loadMessagesAndDraft(2);
            }
        }, LOADING_MESSAGES_AND_DRAFT_MAX_DELAY_MS);
    }
    // Update the fasttrack info in case any of the recipients' contact info changed
    // while we were paused. This can happen, for example, if a user changes or adds
    // an avatar associated with a contact.
    mWorkingMessage.syncWorkingRecipients();
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("update title, mConversation=" + mConversation.toString());
    }
    ActionBar actionBar = getActionBar();
    actionBar.setDisplayHomeAsUpEnabled(true);
}
#end_block

#method_before
@Override
protected void onResume() {
    super.onResume();
    mSendButton.setActionDrawable(getResources().getDrawable(R.drawable.send_button));
    // Fetch contact info and contact bitmap
    mSendButtonContactImageTask = new AsyncTask<Void, Void, Contact>() {

        @Override
        protected Contact doInBackground(Void... params) {
            return Contact.getMe(true);
        }

        @Override
        protected void onPostExecute(Contact contact) {
            contact.getBitmap(ComposeMessageActivity.this, mSendButton.getWidth(), new Contact.BitmapRequestCallback() {

                @Override
                public void onBitmapAvailable(Bitmap photo) {
                    RoundedBitmapDrawable drawable = RoundedBitmapDrawableFactory.create(getResources(), photo);
                    drawable.setCornerRadius(Math.min(drawable.getMinimumWidth(), drawable.getMinimumHeight()));
                    drawable.setAntiAlias(true);
                    mSendButton.setPlaceholderDrawable(drawable);
                }
            });
        }
    }.execute();
    // OLD: get notified of presence updates to update the titlebar.
    // NEW: we are using ContactHeaderWidget which displays presence, but updating presence
    // there is out of our control.
    // Contact.startPresenceObserver();
    mIsPickingContact = false;
    addRecipientsListeners();
    if (isRecipientsEditorVisible()) {
        mRecipientsEditor.addTextChangedListener(mRecipientsWatcher);
    }
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("update title, mConversation=" + mConversation.toString());
    }
    // There seems to be a bug in the framework such that setting the title
    // here gets overwritten to the original title.  Do this delayed as a
    // workaround.
    mMessageListItemHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            ContactList recipients = isRecipientsEditorVisible() ? mRecipientsEditor.constructContactsFromInput(false) : getRecipients();
            updateTitle(recipients);
        }
    }, 100);
    TelephonyManager tm = (TelephonyManager) getSystemService(Service.TELEPHONY_SERVICE);
    if (MessagingPreferenceActivity.isSmartCallEnabled(ComposeMessageActivity.this) && tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
        mPickupDetector.enable();
    }
    mIsRunning = true;
    updateThreadIdIfRunning();
    mConversation.markAsRead(true);
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    mSendButton.setActionDrawable(getResources().getDrawable(R.drawable.send_button));
    // Fetch contact info and contact bitmap
    mSendButtonContactImageTask = new AsyncTask<Void, Void, Contact>() {

        @Override
        protected Contact doInBackground(Void... params) {
            return Contact.getMe(true);
        }

        @Override
        protected void onPostExecute(Contact contact) {
            contact.getBitmap(ComposeMessageActivity.this, mSendButton.getWidth(), new Contact.BitmapRequestCallback() {

                @Override
                public void onBitmapAvailable(Bitmap photo) {
                    RoundedBitmapDrawable drawable = RoundedBitmapDrawableFactory.create(getResources(), photo);
                    drawable.setCornerRadius(Math.min(drawable.getMinimumWidth(), drawable.getMinimumHeight()));
                    drawable.setAntiAlias(true);
                    mSendButton.setPlaceholderDrawable(drawable);
                }
            });
        }
    }.execute();
    // OLD: get notified of presence updates to update the titlebar.
    // NEW: we are using ContactHeaderWidget which displays presence, but updating presence
    // there is out of our control.
    // Contact.startPresenceObserver();
    mIsPickingContact = false;
    addRecipientsListeners();
    if (isRecipientsEditorVisible() && (mAddNumbersTask == null || mAddNumbersTask.getStatus() == AsyncTask.Status.FINISHED)) {
        mRecipientsEditor.addTextChangedListener(mRecipientsWatcher);
    }
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("update title, mConversation=" + mConversation.toString());
    }
    // There seems to be a bug in the framework such that setting the title
    // here gets overwritten to the original title.  Do this delayed as a
    // workaround.
    mMessageListItemHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            ContactList recipients = isRecipientsEditorVisible() ? mRecipientsEditor.constructContactsFromInput(false) : getRecipients();
            updateTitle(recipients);
        }
    }, 100);
    TelephonyManager tm = (TelephonyManager) getSystemService(Service.TELEPHONY_SERVICE);
    if (MessagingPreferenceActivity.isSmartCallEnabled(ComposeMessageActivity.this) && tm.getCallState() == TelephonyManager.CALL_STATE_IDLE) {
        mPickupDetector.enable();
    }
    mIsRunning = true;
    updateThreadIdIfRunning();
    mConversation.markAsRead(true);
}
#end_block

#method_before
@Override
protected void onStop() {
    super.onStop();
    if (mSendButtonContactImageTask != null) {
        mSendButtonContactImageTask.cancel(true);
    }
    // No need to do the querying when finished this activity
    mBackgroundQueryHandler.cancelOperation(MESSAGE_LIST_QUERY_TOKEN);
    mBackgroundQueryHandler.cancelOperation(MESSAGE_LIST_TYPE_QUERY_TOKEN);
    // Allow any blocked calls to update the thread's read status.
    mConversation.blockMarkAsRead(false);
    if (mMsgListAdapter != null) {
        // Close the cursor in the ListAdapter if the activity stopped.
        Cursor cursor = mMsgListAdapter.getCursor();
        if (cursor != null && !cursor.isClosed()) {
            cursor.close();
        }
        MmsApp.getApplication().removePhoneNumberLookupListener(mMsgListAdapter);
        mMsgListAdapter.changeCursor(null);
        mMsgListAdapter.cancelBackgroundLoading();
        // resets multi select mode
        getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
    }
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("save draft");
    }
    saveDraft(true);
    // set 'mShouldLoadDraft' to true, so when coming back to ComposeMessageActivity, we would
    // load the draft, unless we are coming back to the activity after attaching a photo, etc,
    // in which case we should set 'mShouldLoadDraft' to false.
    mShouldLoadDraft = true;
    // Cleanup the BroadcastReceiver.
    unregisterReceiver(mHttpProgressReceiver);
    unregisterReceiver(mDelayedSendProgressReceiver);
}
#method_after
@Override
protected void onStop() {
    super.onStop();
    if (mSendButtonContactImageTask != null) {
        mSendButtonContactImageTask.cancel(true);
    }
    // No need to do the querying when finished this activity
    mBackgroundQueryHandler.cancelOperation(MESSAGE_LIST_QUERY_TOKEN);
    mBackgroundQueryHandler.cancelOperation(MESSAGE_LIST_TYPE_QUERY_TOKEN);
    // Allow any blocked calls to update the thread's read status.
    mConversation.blockMarkAsRead(false);
    if (mMsgListAdapter != null) {
        // Close the cursor in the ListAdapter if the activity stopped.
        Cursor cursor = mMsgListAdapter.getCursor();
        if (cursor != null && !cursor.isClosed()) {
            cursor.close();
        }
        mMsgListAdapter.changeCursor(null);
        mMsgListAdapter.cancelBackgroundLoading();
        // resets multi select mode
        getListView().setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
    }
    if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
        log("save draft");
    }
    saveDraft(true);
    // set 'mShouldLoadDraft' to true, so when coming back to ComposeMessageActivity, we would
    // load the draft, unless we are coming back to the activity after attaching a photo, etc,
    // in which case we should set 'mShouldLoadDraft' to false.
    mShouldLoadDraft = true;
    // Cleanup the BroadcastReceiver.
    unregisterReceiver(mHttpProgressReceiver);
    unregisterReceiver(mDelayedSendProgressReceiver);
}
#end_block

#method_before
@Override
protected void onDestroy() {
    if (TRACE) {
        android.os.Debug.stopMethodTracing();
    }
    if (mZoomGestureOverlayView != null) {
        mZoomGestureOverlayView.removeZoomListener(this);
    }
    super.onDestroy();
}
#method_after
@Override
protected void onDestroy() {
    if (TRACE) {
        android.os.Debug.stopMethodTracing();
    }
    if (mZoomGestureOverlayView != null) {
        mZoomGestureOverlayView.removeZoomListener(this);
    }
    MmsApp.getApplication().removePhoneNumberLookupListener(mMsgListAdapter);
    super.onDestroy();
}
#end_block

#method_before
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    super.onPrepareOptionsMenu(menu);
    menu.clear();
    if (mSendDiscreetMode && !mForwardMessageMode && !mReplyMessageMode) {
        // any menus.
        return true;
    }
    buildAddAddressToContactMenuItem(menu);
    if (MmsConfig.getMmsEnabled() && mIsSmsEnabled) {
        if (!isSubjectEditorVisible()) {
            menu.add(0, MENU_ADD_SUBJECT, 0, R.string.add_subject).setIcon(R.drawable.ic_menu_edit);
        }
    }
    if (mConversation.getThreadId() > 0) {
        menu.add(0, MENU_CONVERSATION_OPTIONS, 0, R.string.menu_conversation_options);
    }
    // Add to Blacklist item (if enabled)
    if (BlacklistUtils.isBlacklistEnabled(this)) {
        menu.add(0, MENU_ADD_TO_BLACKLIST, 0, R.string.add_to_blacklist).setIcon(R.drawable.ic_block_message_holo_dark).setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
    }
    if (mMsgListAdapter.getCount() > 0 && mIsSmsEnabled) {
        // Removed search as part of b/1205708
        // menu.add(0, MENU_SEARCH, 0, R.string.menu_search).setIcon(
        // R.drawable.ic_menu_search);
        Cursor cursor = mMsgListAdapter.getCursor();
        if ((null != cursor) && (cursor.getCount() > 0)) {
            menu.add(0, MENU_DELETE_CONVERSATION, 0, R.string.compose_menu_delete_conversation).setIcon(android.R.drawable.ic_menu_delete);
        }
    } else if (mIsSmsEnabled) {
        menu.add(0, MENU_DISCARD, 0, R.string.discard).setIcon(android.R.drawable.ic_menu_delete);
    }
    // Don't show the call icon if the device don't support voice calling.
    boolean voiceCapable = getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
    if (isRecipientCallable() && voiceCapable) {
        MenuItem item = menu.add(0, MENU_CALL_RECIPIENT, 0, R.string.menu_call).setIcon(R.drawable.ic_call_white_24dp).setTitle(R.string.menu_call);
        if (!isRecipientsEditorVisible()) {
            // If we're not composing a new message, show the call icon in the actionbar
            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
        }
    }
    if (LogTag.DEBUG_DUMP) {
        menu.add(0, MENU_DEBUG_DUMP, 0, R.string.menu_debug_dump);
    }
    return true;
}
#method_after
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    super.onPrepareOptionsMenu(menu);
    menu.clear();
    if (mSendDiscreetMode && !mForwardMessageMode && !mReplyMessageMode) {
        // any menus.
        return true;
    }
    buildAddAddressToContactMenuItem(menu);
    if (MmsConfig.getMmsEnabled() && mIsSmsEnabled) {
        if (!isSubjectEditorVisible()) {
            menu.add(0, MENU_ADD_SUBJECT, 0, R.string.add_subject).setIcon(R.drawable.ic_menu_edit);
        }
    }
    if (mConversation.getThreadId() > 0) {
        menu.add(0, MENU_CONVERSATION_OPTIONS, 0, R.string.menu_conversation_options);
    }
    menu.add(0, MENU_IMPORT_TEMPLATE, 0, R.string.import_quick_message);
    // Add to Blacklist item (if enabled)
    if (BlacklistUtils.isBlacklistEnabled(this)) {
        menu.add(0, MENU_ADD_TO_BLACKLIST, 0, R.string.add_to_blacklist).setIcon(R.drawable.ic_block_message_holo_dark).setShowAsAction(MenuItem.SHOW_AS_ACTION_NEVER);
    }
    if (mMsgListAdapter.getCount() > 0 && mIsSmsEnabled) {
        // Removed search as part of b/1205708
        // menu.add(0, MENU_SEARCH, 0, R.string.menu_search).setIcon(
        // R.drawable.ic_menu_search);
        Cursor cursor = mMsgListAdapter.getCursor();
        if ((null != cursor) && (cursor.getCount() > 0)) {
            menu.add(0, MENU_DELETE_CONVERSATION, 0, R.string.compose_menu_delete_conversation).setIcon(android.R.drawable.ic_menu_delete);
        }
    } else if (mIsSmsEnabled) {
        menu.add(0, MENU_DISCARD, 0, R.string.discard).setIcon(android.R.drawable.ic_menu_delete);
    }
    // Don't show the call icon if the device don't support voice calling.
    boolean voiceCapable = getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
    if (isRecipientCallable() && voiceCapable) {
        MenuItem item = menu.add(0, MENU_CALL_RECIPIENT, 0, R.string.menu_call).setIcon(R.drawable.ic_call_white_24dp).setTitle(R.string.menu_call);
        if (!isRecipientsEditorVisible()) {
            // If we're not composing a new message, show the call icon in the actionbar
            item.setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS);
        }
    }
    if (LogTag.DEBUG_DUMP) {
        menu.add(0, MENU_DEBUG_DUMP, 0, R.string.menu_debug_dump);
    }
    return true;
}
#end_block

#method_before
private Dialog showImportTemplateDialog() {
    String[] smsTempArray = null;
    Uri uri = Uri.parse("content://com.android.mms.MessageTemplateProvider/messages");
    Cursor cur = null;
    try {
        cur = getContentResolver().query(uri, null, null, null, null);
        if (cur != null && cur.moveToFirst()) {
            int index = 0;
            smsTempArray = new String[cur.getCount()];
            String title = null;
            do {
                title = cur.getString(cur.getColumnIndex("message"));
                smsTempArray[index++] = title;
            } while (cur.moveToNext());
        }
    } finally {
        if (cur != null) {
            cur.close();
        }
    }
    TemplateSelectListener listener = new TemplateSelectListener(smsTempArray);
    return new AlertDialog.Builder(ComposeMessageActivity.this).setTitle(R.string.import_message_template).setItems(smsTempArray, listener).create();
}
#method_after
private Dialog showImportTemplateDialog() {
    String[] smsTempArray = null;
    Uri uri = Uri.parse("content://com.android.mms.MessageTemplateProvider/messages");
    Cursor cur = null;
    try {
        cur = getContentResolver().query(uri, null, null, null, null);
        if (cur != null && cur.moveToFirst()) {
            int index = 0;
            smsTempArray = new String[cur.getCount()];
            String title = null;
            do {
                title = cur.getString(cur.getColumnIndex("message"));
                smsTempArray[index++] = title;
            } while (cur.moveToNext());
        }
    } finally {
        if (cur != null) {
            cur.close();
        }
    }
    TemplateSelectListener listener = new TemplateSelectListener(smsTempArray);
    return new AlertDialog.Builder(ComposeMessageActivity.this).setTitle(R.string.import_quick_message).setItems(smsTempArray, listener).create();
}
#end_block

#method_before
@Override
protected void onActivityResult(int maskResultCode, int resultCode, Intent data) {
    if (LogTag.VERBOSE) {
        log("onActivityResult: requestCode=" + getRequestCode(maskResultCode) + ", resultCode=" + resultCode + ", data=" + data);
    }
    // We're back!
    mWaitingForSubActivity = false;
    mShouldLoadDraft = false;
    int requestCode = getRequestCode(maskResultCode);
    boolean append = isAppendRequest(maskResultCode);
    if (mWorkingMessage.isFakeMmsForDraft()) {
        // We no longer have to fake the fact we're an Mms. At this point we are or we aren't,
        // based on attachments and other Mms attrs.
        mWorkingMessage.removeFakeMmsForDraft();
    }
    if (requestCode == REQUEST_CODE_PICK) {
        mWorkingMessage.asyncDeleteDraftSmsMessage(mConversation);
    }
    if (requestCode == REQUEST_CODE_ADD_CONTACT) {
        // and it will update the title bar, etc.
        if (mAddContactIntent != null) {
            String address = mAddContactIntent.getStringExtra(ContactsContract.Intents.Insert.EMAIL);
            if (address == null) {
                address = mAddContactIntent.getStringExtra(ContactsContract.Intents.Insert.PHONE);
            }
            if (address != null) {
                Contact contact = Contact.get(address, false);
                if (contact != null) {
                    contact.reload();
                }
            }
        }
    }
    if (resultCode != RESULT_OK) {
        if (LogTag.VERBOSE)
            log("bail due to resultCode=" + resultCode);
        return;
    }
    switch(requestCode) {
        case REQUEST_CODE_CREATE_SLIDESHOW:
            if (data != null) {
                WorkingMessage newMessage = WorkingMessage.load(this, data.getData());
                if (newMessage != null) {
                    // Here we should keep the subject from the old mWorkingMessage.
                    setNewMessageSubject(newMessage);
                    mWorkingMessage = newMessage;
                    mWorkingMessage.setConversation(mConversation);
                    updateThreadIdIfRunning();
                    updateMmsSizeIndicator();
                    drawTopPanel(false);
                    drawBottomPanel();
                    updateSendButtonState();
                }
            }
            break;
        case REQUEST_CODE_TAKE_PICTURE:
            {
                // create a file based uri and pass to addImage(). We want to read the JPEG
                // data directly from file (using UriImage) instead of decoding it into a Bitmap,
                // which takes up too much memory and could easily lead to OOM.
                File file = new File(TempFileProvider.getScrapPath(this));
                Uri uri = Uri.fromFile(file);
                // Remove the old captured picture's thumbnail from the cache
                MmsApp.getApplication().getThumbnailManager().removeThumbnail(uri);
                addImageAsync(uri, append);
                break;
            }
        case REQUEST_CODE_ATTACH_IMAGE:
            {
                if (data != null) {
                    addImageAsync(data.getData(), append);
                }
                break;
            }
        case REQUEST_CODE_TAKE_VIDEO:
            Uri videoUri = TempFileProvider.renameScrapFile(".3gp", null, this);
            // Remove the old captured video's thumbnail from the cache
            MmsApp.getApplication().getThumbnailManager().removeThumbnail(videoUri);
            // can handle null videoUri
            addVideoAsync(videoUri, append);
            break;
        case REQUEST_CODE_ATTACH_VIDEO:
            if (data != null) {
                addVideoAsync(data.getData(), append);
            }
            break;
        case REQUEST_CODE_ATTACH_SOUND:
            {
                // Attempt to add the audio to the  attachment.
                Uri uri = (Uri) data.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);
                if (uri == null) {
                    uri = data.getData();
                } else if (Settings.System.DEFAULT_RINGTONE_URI.equals(uri)) {
                    break;
                }
                addAudio(uri, append);
                break;
            }
        case REQUEST_CODE_RECORD_SOUND:
            if (data != null) {
                addAudio(data.getData(), append);
            }
            break;
        case REQUEST_CODE_ECM_EXIT_DIALOG:
            boolean outOfEmergencyMode = data.getBooleanExtra(EXIT_ECM_RESULT, false);
            if (outOfEmergencyMode) {
                sendMessage(false);
            }
            break;
        case REQUEST_CODE_PICK:
            if (data != null) {
                processPickResult(data);
            }
            break;
        case REQUEST_CODE_ATTACH_REPLACE_CONTACT_INFO:
            // the attachment and then add the contact info to text.
            if (data != null) {
                mWorkingMessage.removeAttachment(true);
            }
        case REQUEST_CODE_ATTACH_ADD_CONTACT_INFO:
            if (data != null) {
                String newText = mWorkingMessage.getText() + data.getStringExtra(SelectRecipientsList.EXTRA_INFO);
                mWorkingMessage.setText(newText);
            }
            break;
        case REQUEST_CODE_ATTACH_ADD_CONTACT_VCARD:
            if (data != null) {
                String extraVCard = data.getStringExtra(SelectRecipientsList.EXTRA_VCARD);
                if (extraVCard != null) {
                    Uri vcard = Uri.parse(extraVCard);
                    addVcard(vcard);
                }
            }
            break;
        case REQUEST_CODE_ADD_RECIPIENTS:
            mAddNumbersTask = new AddNumbersTask();
            mAddNumbersTask.execute(data.getStringArrayListExtra(SelectRecipientsList.EXTRA_RECIPIENTS));
            break;
        case REQUEST_CODE_ADD_CALENDAR_EVENTS:
            if (data != null) {
                // get shared event files (.vcs)
                ArrayList<Uri> uris = data.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                // and only event requested
                if (uris.size() > 0) {
                    addVCal(uris.get(0));
                }
            }
        default:
            if (LogTag.VERBOSE)
                log("bail due to unknown requestCode=" + requestCode);
            break;
    }
}
#method_after
@Override
protected void onActivityResult(int maskResultCode, int resultCode, Intent data) {
    if (LogTag.VERBOSE) {
        log("onActivityResult: requestCode=" + getRequestCode(maskResultCode) + ", resultCode=" + resultCode + ", data=" + data);
    }
    // We're back!
    mWaitingForSubActivity = false;
    mShouldLoadDraft = false;
    int requestCode = getRequestCode(maskResultCode);
    boolean append = isAppendRequest(maskResultCode);
    if (mWorkingMessage.isFakeMmsForDraft()) {
        // We no longer have to fake the fact we're an Mms. At this point we are or we aren't,
        // based on attachments and other Mms attrs.
        mWorkingMessage.removeFakeMmsForDraft();
    }
    if (requestCode == REQUEST_CODE_ADD_CONTACT) {
        // and it will update the title bar, etc.
        if (mAddContactIntent != null) {
            String address = mAddContactIntent.getStringExtra(ContactsContract.Intents.Insert.EMAIL);
            if (address == null) {
                address = mAddContactIntent.getStringExtra(ContactsContract.Intents.Insert.PHONE);
            }
            if (address != null) {
                Contact contact = Contact.get(address, false);
                if (contact != null) {
                    contact.reload();
                }
            }
        }
    }
    if (resultCode != RESULT_OK) {
        if (LogTag.VERBOSE)
            log("bail due to resultCode=" + resultCode);
        return;
    }
    switch(requestCode) {
        case REQUEST_CODE_CREATE_SLIDESHOW:
            if (data != null) {
                WorkingMessage newMessage = WorkingMessage.load(this, data.getData());
                if (newMessage != null) {
                    // Here we should keep the subject from the old mWorkingMessage.
                    setNewMessageSubject(newMessage);
                    mWorkingMessage = newMessage;
                    mWorkingMessage.setConversation(mConversation);
                    updateThreadIdIfRunning();
                    updateMmsSizeIndicator();
                    drawTopPanel(false);
                    drawBottomPanel();
                    updateSendButtonState();
                }
            }
            break;
        case REQUEST_CODE_TAKE_PICTURE:
            {
                // create a file based uri and pass to addImage(). We want to read the JPEG
                // data directly from file (using UriImage) instead of decoding it into a Bitmap,
                // which takes up too much memory and could easily lead to OOM.
                File file = new File(TempFileProvider.getScrapPath(this));
                Uri uri = Uri.fromFile(file);
                // Remove the old captured picture's thumbnail from the cache
                MmsApp.getApplication().getThumbnailManager().removeThumbnail(uri);
                addImageAsync(uri, append);
                break;
            }
        case REQUEST_CODE_ATTACH_IMAGE:
            {
                if (data != null) {
                    addImageAsync(data.getData(), append);
                }
                break;
            }
        case REQUEST_CODE_TAKE_VIDEO:
            Uri videoUri = TempFileProvider.renameScrapFile(".3gp", null, this);
            // Remove the old captured video's thumbnail from the cache
            MmsApp.getApplication().getThumbnailManager().removeThumbnail(videoUri);
            // can handle null videoUri
            addVideoAsync(videoUri, append);
            break;
        case REQUEST_CODE_ATTACH_VIDEO:
            if (data != null) {
                addVideoAsync(data.getData(), append);
            }
            break;
        case REQUEST_CODE_ATTACH_SOUND:
            {
                // Attempt to add the audio to the  attachment.
                Uri uri = (Uri) data.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI);
                if (uri == null) {
                    uri = data.getData();
                } else if (Settings.System.DEFAULT_RINGTONE_URI.equals(uri)) {
                    break;
                }
                addAudio(uri, append);
                break;
            }
        case REQUEST_CODE_RECORD_SOUND:
            if (data != null) {
                addAudio(data.getData(), append);
            }
            break;
        case REQUEST_CODE_ECM_EXIT_DIALOG:
            boolean outOfEmergencyMode = data.getBooleanExtra(EXIT_ECM_RESULT, false);
            if (outOfEmergencyMode) {
                sendMessage(false);
            }
            break;
        case REQUEST_CODE_ATTACH_REPLACE_CONTACT_INFO:
            // the attachment and then add the contact info to text.
            if (data != null) {
                mWorkingMessage.removeAttachment(true);
            }
        case REQUEST_CODE_ATTACH_ADD_CONTACT_INFO:
            if (data != null) {
                String newText = mWorkingMessage.getText() + data.getStringExtra(SelectRecipientsList.EXTRA_INFO);
                mWorkingMessage.setText(newText);
            }
            break;
        case REQUEST_CODE_ATTACH_ADD_CONTACT_VCARD:
            if (data != null) {
                String extraVCard = data.getStringExtra(SelectRecipientsList.EXTRA_VCARD);
                if (extraVCard != null) {
                    Uri vcard = Uri.parse(extraVCard);
                    addVcard(vcard);
                }
            }
            break;
        case REQUEST_CODE_ADD_RECIPIENTS:
            mWorkingMessage.asyncDeleteDraftMessage(mConversation);
            mAddNumbersTask = new AddNumbersTask();
            mAddNumbersTask.execute(data.getStringArrayListExtra(SelectRecipientsList.EXTRA_RECIPIENTS));
            break;
        case REQUEST_CODE_ADD_CALENDAR_EVENTS:
            if (data != null) {
                // get shared event files (.vcs)
                ArrayList<Uri> uris = data.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
                // and only event requested
                if (uris.size() > 0) {
                    addVCal(uris.get(0));
                }
            }
        default:
            if (LogTag.VERBOSE)
                log("bail due to unknown requestCode=" + requestCode);
            break;
    }
}
#end_block

#method_before
@Override
protected void onPreExecute() {
    super.onPreExecute();
    mPD = new ProgressDialog(ComposeMessageActivity.this);
    mPD.setMessage(getString(R.string.adding_selected_recipients_dialog_text));
    mPD.show();
}
#method_after
@Override
protected void onPreExecute() {
    super.onPreExecute();
    mPD = new ProgressDialog(ComposeMessageActivity.this);
    mPD.setMessage(getString(R.string.adding_selected_recipients_dialog_text));
    mPD.setCancelable(false);
    mPD.show();
    mRecipientsEditor.removeTextChangedListener(mRecipientsWatcher);
}
#end_block

#method_before
@Override
protected void onPostExecute(Void aVoid) {
    super.onPostExecute(aVoid);
    if (mPD != null && mPD.isShowing()) {
        mPD.dismiss();
    }
}
#method_after
@Override
protected void onPostExecute(Void aVoid) {
    super.onPostExecute(aVoid);
    if (mPD != null && mPD.isShowing()) {
        mPD.dismiss();
    }
    mRecipientsEditor.addTextChangedListener(mRecipientsWatcher);
    mRecipientsWatcher.afterTextChanged(mRecipientsEditor.getText());
}
#end_block

#method_before
private void handleAddAttachmentError(final int error, final int mediaTypeStringId) {
    if (error == WorkingMessage.OK) {
        return;
    }
    Log.d(TAG, "handleAddAttachmentError: " + error);
    runOnUiThread(new Runnable() {

        @Override
        public void run() {
            Resources res = getResources();
            String mediaType = res.getString(mediaTypeStringId);
            String title, message;
            switch(error) {
                case WorkingMessage.UNKNOWN_ERROR:
                    message = res.getString(R.string.failed_to_add_media, mediaType);
                    Toast.makeText(ComposeMessageActivity.this, message, Toast.LENGTH_SHORT).show();
                    return;
                case WorkingMessage.UNSUPPORTED_TYPE:
                    title = res.getString(R.string.unsupported_media_format, mediaType);
                    message = res.getString(R.string.select_different_media, mediaType);
                    break;
                case WorkingMessage.MESSAGE_SIZE_EXCEEDED:
                    title = res.getString(R.string.exceed_message_size_limitation, mediaType);
                    // cannot send out message" while we send out the Mms.
                    if (mIsAttachmentErrorOnSend) {
                        message = res.getString(R.string.media_size_limit);
                        mIsAttachmentErrorOnSend = false;
                    } else {
                        message = res.getString(R.string.failed_to_add_media, mediaType);
                    }
                    break;
                case WorkingMessage.IMAGE_TOO_LARGE:
                    title = res.getString(R.string.failed_to_resize_image);
                    message = res.getString(R.string.resize_image_error_information);
                    break;
                case WorkingMessage.NEGATIVE_MESSAGE_OR_INCREASE_SIZE:
                    title = res.getString(R.string.illegal_message_or_increase_size);
                    message = res.getString(R.string.failed_to_add_media, mediaType);
                    break;
                default:
                    throw new IllegalArgumentException("unknown error " + error);
            }
            MessageUtils.showErrorDialog(ComposeMessageActivity.this, title, message);
        }
    });
}
#method_after
private void handleAddAttachmentError(final int error, final int mediaTypeStringId) {
    if (error == WorkingMessage.OK) {
        return;
    }
    Log.d(TAG, "handleAddAttachmentError: " + error);
    runOnUiThread(new Runnable() {

        @Override
        public void run() {
            Resources res = getResources();
            String mediaType = res.getString(mediaTypeStringId);
            String title, message;
            switch(error) {
                case WorkingMessage.UNKNOWN_ERROR:
                    message = res.getString(R.string.failed_to_add_media, mediaType);
                    Toast.makeText(ComposeMessageActivity.this, message, Toast.LENGTH_SHORT).show();
                    return;
                case WorkingMessage.UNSUPPORTED_TYPE:
                    title = res.getString(R.string.unsupported_media_format, mediaType);
                    message = res.getString(R.string.select_different_media, mediaType);
                    break;
                case WorkingMessage.MESSAGE_SIZE_EXCEEDED:
                    title = res.getString(R.string.exceed_message_size_limitation, mediaType);
                    // cannot send out message" while we send out the Mms.
                    if (mIsAttachmentErrorOnSend) {
                        message = res.getString(R.string.media_size_limit);
                        mIsAttachmentErrorOnSend = false;
                    } else {
                        message = res.getString(R.string.failed_to_add_media, mediaType);
                    }
                    break;
                case WorkingMessage.IMAGE_TOO_LARGE:
                    title = res.getString(R.string.failed_to_resize_image);
                    message = res.getString(R.string.resize_image_error_information);
                    break;
                case WorkingMessage.NEGATIVE_MESSAGE_OR_INCREASE_SIZE:
                    title = res.getString(R.string.illegal_message_or_increase_size);
                    message = res.getString(R.string.failed_to_add_media, mediaType);
                    break;
                case WorkingMessage.FAILED_TO_QUERY_CONTACT:
                    title = res.getString(R.string.attach_add_contact_as_vcard);
                    message = res.getString(R.string.failed_to_add_media, title);
                    Toast.makeText(ComposeMessageActivity.this, message, Toast.LENGTH_SHORT).show();
                    deleteLastMms();
                    return;
                default:
                    throw new IllegalArgumentException("unknown error " + error);
            }
            MessageUtils.showErrorDialog(ComposeMessageActivity.this, title, message);
        }
    });
}
#end_block

#method_before
// ==========================================================
// Interface methods
// ==========================================================
@Override
public void onClick(View v) {
    if (v == mSendButton && isPreparedForSending()) {
        confirmSendMessageIfNeeded();
    } else if (v == mRecipientsSelector) {
        pickContacts(SelectRecipientsList.MODE_DEFAULT, REQUEST_CODE_ADD_RECIPIENTS);
    }
}
#method_after
// ==========================================================
// Interface methods
// ==========================================================
@Override
public void onClick(View v) {
    if (v == mSendButton && isPreparedForSending()) {
        if (mCurrentSimInfo == null) {
            confirmSendMessageIfNeeded();
        } else {
            confirmSendMessageIfNeeded(mCurrentSimInfo.mSlotId);
        }
    } else if (v == mRecipientsSelector) {
        pickContacts(SelectRecipientsList.MODE_DEFAULT, REQUEST_CODE_ADD_RECIPIENTS);
    }
}
#end_block

#method_before
// ==========================================================
// Private methods
// ==========================================================
private void initResourceRefs() {
    mToolBar = (Toolbar) findViewById(R.id.toolbar);
    setActionBar(mToolBar);
    mMsgListView = (MessageListView) findViewById(R.id.history);
    // no divider so we look like IM conversation.
    mMsgListView.setDivider(null);
    // called to enable us to show some padding between the message list and the
    // input field but when the message list is scrolled that padding area is filled
    // in with message content
    mMsgListView.setClipToPadding(false);
    mMsgListView.setOnSizeChangedListener(new OnSizeChangedListener() {

        public void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                Log.v(TAG, "onSizeChanged: w=" + width + " h=" + height + " oldw=" + oldWidth + " oldh=" + oldHeight);
            }
            if (!mMessagesAndDraftLoaded && (oldHeight - height > SMOOTH_SCROLL_THRESHOLD)) {
                // perform the delayed loading now, after keyboard opens
                loadMessagesAndDraft(3);
            }
            // The message list view changed size, most likely because the keyboard
            // appeared or disappeared or the user typed/deleted chars in the message
            // box causing it to change its height when expanding/collapsing to hold more
            // lines of text.
            smoothScrollToEnd(false, height - oldHeight);
        }
    });
    mBottomPanel = findViewById(R.id.bottom_panel);
    mBottomPanel.setVisibility(View.VISIBLE);
    mTextEditor = (EditText) findViewById(R.id.embedded_text_editor);
    mTextEditorFontSize = mTextEditor.getTextSize();
    mTextCounter = (TextView) findViewById(R.id.text_counter);
    mMmsMarker = (TextView) findViewById(R.id.mms_marker);
    mSendButton = (FluctuatingImageButton) findViewById(R.id.send_button);
    mSendButton.setOnClickListener(this);
    mTextEditor.setOnEditorActionListener(this);
    mTextEditor.addTextChangedListener(mTextEditorWatcher);
    if (getResources().getInteger(R.integer.limit_count) == 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(MmsConfig.getMaxTextLimit()) });
    } else if (getResources().getInteger(R.integer.slide_text_limit_size) != 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(getResources().getInteger(R.integer.slide_text_limit_size)) });
    }
    if (getResources().getInteger(R.integer.limit_count) == 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(MmsConfig.getMaxTextLimit()) });
    } else if (getResources().getInteger(R.integer.slide_text_limit_size) != 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(getResources().getInteger(R.integer.slide_text_limit_size)) });
    }
    mTopPanel = findViewById(R.id.recipients_subject_linear);
    mTopPanel.setFocusable(false);
    mAttachmentEditor = (AttachmentEditor) findViewById(R.id.attachment_editor);
    mAttachmentEditor.setHandler(mAttachmentEditorHandler);
    mAttachmentEditorScrollView = findViewById(R.id.attachment_editor_scroll_view);
    // initialize attachment
    findViewById(R.id.add_attachment).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            ComposeMessageActivity.this.showAddAttachmentDialog(false);
        }
    });
}
#method_after
// ==========================================================
// Private methods
// ==========================================================
private void initResourceRefs() {
    mToolBar = (Toolbar) findViewById(R.id.toolbar);
    setActionBar(mToolBar);
    mMsgListView = (MessageListView) findViewById(R.id.history);
    // no divider so we look like IM conversation.
    mMsgListView.setDivider(null);
    // called to enable us to show some padding between the message list and the
    // input field but when the message list is scrolled that padding area is filled
    // in with message content
    mMsgListView.setClipToPadding(false);
    mMsgListView.setOnSizeChangedListener(new OnSizeChangedListener() {

        public void onSizeChanged(int width, int height, int oldWidth, int oldHeight) {
            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                Log.v(TAG, "onSizeChanged: w=" + width + " h=" + height + " oldw=" + oldWidth + " oldh=" + oldHeight);
            }
            if (!mMessagesAndDraftLoaded && (oldHeight - height > SMOOTH_SCROLL_THRESHOLD)) {
                // perform the delayed loading now, after keyboard opens
                loadMessagesAndDraft(3);
            }
            // The message list view changed size, most likely because the keyboard
            // appeared or disappeared or the user typed/deleted chars in the message
            // box causing it to change its height when expanding/collapsing to hold more
            // lines of text.
            smoothScrollToEnd(false, height - oldHeight);
        }
    });
    mBottomPanel = findViewById(R.id.bottom_panel);
    mBottomPanel.setVisibility(View.VISIBLE);
    mTextEditor = (EditText) findViewById(R.id.embedded_text_editor);
    mTextEditorFontSize = mTextEditor.getTextSize();
    mTextCounter = (TextView) findViewById(R.id.text_counter);
    mMmsMarker = (TextView) findViewById(R.id.mms_marker);
    mSendButton = (FluctuatingImageButton) findViewById(R.id.send_button);
    mSendButton.setOnClickListener(this);
    mTextEditor.setOnEditorActionListener(this);
    mTextEditor.addTextChangedListener(mTextEditorWatcher);
    if (getResources().getInteger(R.integer.limit_count) == 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(MmsConfig.getMaxTextLimit()) });
    } else if (getResources().getInteger(R.integer.slide_text_limit_size) != 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(getResources().getInteger(R.integer.slide_text_limit_size)) });
    }
    if (getResources().getInteger(R.integer.limit_count) == 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(MmsConfig.getMaxTextLimit()) });
    } else if (getResources().getInteger(R.integer.slide_text_limit_size) != 0) {
        mTextEditor.setFilters(new InputFilter[] { new LengthFilter(getResources().getInteger(R.integer.slide_text_limit_size)) });
    }
    if (mIsMsim) {
        mTextEditor.setOnTouchListener(new View.OnTouchListener() {

            private int mClickBounds = ComposeMessageActivity.this.getResources().getDimensionPixelSize(R.dimen.sim_selector_click_bounds);

            @Override
            public boolean onTouch(View v, MotionEvent event) {
                int action = event.getAction();
                switch(action) {
                    case MotionEvent.ACTION_DOWN:
                    case MotionEvent.ACTION_MOVE:
                        return true;
                    case MotionEvent.ACTION_UP:
                        if (event.getX() <= mClickBounds && event.getY() <= mClickBounds) {
                            // build and launch sim select popup
                            showSimSelectionPopup();
                            return true;
                        }
                        break;
                }
                return false;
            }
        });
    }
    mTopPanel = findViewById(R.id.recipients_subject_linear);
    mTopPanel.setFocusable(false);
    mAttachmentEditor = (AttachmentEditor) findViewById(R.id.attachment_editor);
    mAttachmentEditor.setHandler(mAttachmentEditorHandler);
    mAttachmentEditorScrollView = findViewById(R.id.attachment_editor_scroll_view);
    // initialize attachment
    findViewById(R.id.add_attachment).setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            ComposeMessageActivity.this.showAddAttachmentDialog(false);
        }
    });
}
#end_block

#method_before
private void initMessageList() {
    if (mMsgListAdapter != null) {
        return;
    }
    String highlightString = getIntent().getStringExtra("highlight");
    Pattern highlight = highlightString == null ? null : Pattern.compile("\\b" + Pattern.quote(highlightString), Pattern.CASE_INSENSITIVE);
    // Initialize the list adapter with a null cursor.
    mMsgListAdapter = new MessageListAdapter(this, null, mMsgListView, true, highlight);
    mMsgListAdapter.setOnDataSetChangedListener(mDataSetChangedListener);
    mMsgListAdapter.setMsgListItemHandler(mMessageListItemHandler);
    mMsgListView.setAdapter(mMsgListAdapter);
    mMsgListView.setItemsCanFocus(false);
    mMsgListView.setVisibility((mSendDiscreetMode || MessageUtils.isMailboxMode()) ? View.INVISIBLE : View.VISIBLE);
    mMsgListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (view != null) {
                ((MessageListItem) view).onMessageListItemClick();
            }
        }
    });
    mMsgListView.setMultiChoiceModeListener(new ModeCallback());
    mMsgListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
}
#method_after
private void initMessageList() {
    if (mMsgListAdapter != null) {
        return;
    }
    String highlightString = getIntent().getStringExtra("highlight");
    Pattern highlight = highlightString == null ? null : Pattern.compile("\\b" + Pattern.quote(highlightString), Pattern.CASE_INSENSITIVE);
    // Initialize the list adapter with a null cursor.
    mMsgListAdapter = new MessageListAdapter(this, null, mMsgListView, true, highlight);
    mMsgListAdapter.setOnDataSetChangedListener(mDataSetChangedListener);
    mMsgListAdapter.setMsgListItemHandler(mMessageListItemHandler);
    MmsApp.getApplication().addPhoneNumberLookupListener(mMsgListAdapter);
    mMsgListView.setAdapter(mMsgListAdapter);
    mMsgListView.setItemsCanFocus(false);
    mMsgListView.setVisibility((mSendDiscreetMode || MessageUtils.isMailboxMode()) ? View.INVISIBLE : View.VISIBLE);
    mMsgListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            if (view != null) {
                ((MessageListItem) view).onMessageListItemClick();
            }
        }
    });
    mMsgListView.setOnScrollListener(new AbsListView.OnScrollListener() {

        private boolean scrolling = false;

        @Override
        public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {
            if (mIsKeyboardOpen && scrolling) {
                final int first = mMsgListView.getFirstVisiblePosition();
                final int last = mMsgListView.getLastVisiblePosition();
                final int count = mMsgListAdapter.getCount();
                if (count > (last - first + 1)) {
                    hideKeyboard();
                }
            }
        }

        @Override
        public void onScrollStateChanged(AbsListView view, int scrollState) {
            scrolling = scrollState != AbsListView.OnScrollListener.SCROLL_STATE_IDLE;
        }
    });
    mMsgListView.setMultiChoiceModeListener(new ModeCallback());
    mMsgListView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL);
}
#end_block

#method_before
private void sendMessage(boolean bCheckEcmMode) {
    // Check message size, if >= max message size, do not send message.
    if (checkMessageSizeExceeded()) {
        return;
    }
    if (bCheckEcmMode) {
        // TODO: expose this in telephony layer for SDK build
        String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE);
        if (Boolean.parseBoolean(inEcm)) {
            try {
                startActivityForResult(new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null), REQUEST_CODE_ECM_EXIT_DIALOG);
                return;
            } catch (ActivityNotFoundException e) {
                // continue to send message
                Log.e(TAG, "Cannot find EmergencyCallbackModeExitDialog", e);
            }
        }
    }
    if (!mSendingMessage) {
        if (LogTag.SEVERE_WARNING) {
            String sendingRecipients = mConversation.getRecipients().serialize();
            if (!sendingRecipients.equals(mDebugRecipients)) {
                String workingRecipients = mWorkingMessage.getWorkingRecipients();
                if (!mDebugRecipients.equals(workingRecipients)) {
                    LogTag.warnPossibleRecipientMismatch("ComposeMessageActivity.sendMessage" + " recipients in window: \"" + mDebugRecipients + "\" differ from recipients from conv: \"" + sendingRecipients + "\" and working recipients: " + workingRecipients, this);
                }
            }
            sanityCheckConversation();
        }
        // send can change the recipients. Make sure we remove the listeners first and then add
        // them back once the recipient list has settled.
        removeRecipientsListeners();
        // strip unicode chars before sending (if applicable)
        mWorkingMessage.setText(stripUnicodeIfRequested(mWorkingMessage.getText()));
        if (mWorkingMessage.getResendMultiRecipients()) {
            // If resend sms recipient is more than one, use mResendSmsRecipient
            mWorkingMessage.send(mResendSmsRecipient);
        } else {
            mWorkingMessage.send(mDebugRecipients);
        }
        mSentMessage = true;
        mSendingMessage = true;
        addRecipientsListeners();
        // in the next onQueryComplete, scroll the list to the end.
        mScrollOnSend = true;
    }
    // But bail out if we are supposed to exit after the message is sent.
    if (mSendDiscreetMode || MessageUtils.isMailboxMode()) {
        finish();
    }
}
#method_after
private void sendMessage(boolean bCheckEcmMode) {
    // Check message size, if >= max message size, do not send message.
    if (checkMessageSizeExceeded()) {
        return;
    }
    if (bCheckEcmMode) {
        // TODO: expose this in telephony layer for SDK build
        String inEcm = SystemProperties.get(TelephonyProperties.PROPERTY_INECM_MODE);
        if (Boolean.parseBoolean(inEcm)) {
            try {
                startActivityForResult(new Intent(TelephonyIntents.ACTION_SHOW_NOTICE_ECM_BLOCK_OTHERS, null), REQUEST_CODE_ECM_EXIT_DIALOG);
                return;
            } catch (ActivityNotFoundException e) {
                // continue to send message
                Log.e(TAG, "Cannot find EmergencyCallbackModeExitDialog", e);
            }
        }
    }
    String mCurrentRecipients = mRecipients.serialize();
    if (!mSendingMessage) {
        if (LogTag.SEVERE_WARNING) {
            String sendingRecipients = mConversation.getRecipients().serialize();
            if (DEBUG && !sendingRecipients.equals(mCurrentRecipients)) {
                String workingRecipients = mWorkingMessage.getWorkingRecipients();
                if (!mCurrentRecipients.equals(workingRecipients)) {
                    LogTag.warnPossibleRecipientMismatch("ComposeMessageActivity.sendMessage" + " recipients in window: \"" + mCurrentRecipients + "\" differ from recipients from conv: \"" + sendingRecipients + "\" and working recipients: " + workingRecipients, this);
                }
            }
            sanityCheckConversation();
        }
        // send can change the recipients. Make sure we remove the listeners first and then add
        // them back once the recipient list has settled.
        removeRecipientsListeners();
        // strip unicode chars before sending (if applicable)
        mWorkingMessage.setText(stripUnicodeIfRequested(mWorkingMessage.getText()));
        if (mWorkingMessage.getResendMultiRecipients()) {
            // If resend sms recipient is more than one, use mResendSmsRecipient
            mWorkingMessage.send(mResendSmsRecipient);
        } else {
            mWorkingMessage.send(mCurrentRecipients);
        }
        mSentMessage = true;
        mSendingMessage = true;
        addRecipientsListeners();
        // in the next onQueryComplete, scroll the list to the end.
        mScrollOnSend = true;
    }
    // But bail out if we are supposed to exit after the message is sent.
    if (mSendDiscreetMode || MessageUtils.isMailboxMode()) {
        finish();
    }
}
#end_block

#method_before
private void initActivityState(Bundle bundle) {
    Intent intent = getIntent();
    if (bundle != null) {
        setIntent(getIntent().setAction(Intent.ACTION_VIEW));
        String recipients = bundle.getString(RECIPIENTS);
        if (LogTag.VERBOSE)
            log("get mConversation by recipients " + recipients);
        mConversation = Conversation.get(this, ContactList.getByNumbers(recipients, false, /* don't block */
        true), false);
        addRecipientsListeners();
        mSendDiscreetMode = bundle.getBoolean(KEY_EXIT_ON_SENT, false);
        mForwardMessageMode = bundle.getBoolean(KEY_FORWARDED_MESSAGE, false);
        if (mSendDiscreetMode) {
            mMsgListView.setVisibility(View.INVISIBLE);
        }
        mWorkingMessage.readStateFromBundle(bundle);
        return;
    }
    // If we have been passed a thread_id, use that to find our conversation.
    long threadId = intent.getLongExtra(THREAD_ID, 0);
    if (threadId > 0) {
        if (LogTag.VERBOSE)
            log("get mConversation by threadId " + threadId);
        mConversation = Conversation.get(this, threadId, false);
    } else {
        Uri intentData = intent.getData();
        if (intentData != null) {
            // try to get a conversation based on the data URI passed to our intent.
            if (LogTag.VERBOSE)
                log("get mConversation by intentData " + intentData);
            mConversation = Conversation.get(this, intentData, false);
            mWorkingMessage.setText(getBody(intentData));
        } else {
            // special intent extra parameter to specify the address
            String address = intent.getStringExtra("address");
            if (!TextUtils.isEmpty(address)) {
                if (LogTag.VERBOSE)
                    log("get mConversation by address " + address);
                mConversation = Conversation.get(this, ContactList.getByNumbers(address, false, /* don't block */
                true), false);
            } else {
                if (LogTag.VERBOSE)
                    log("create new conversation");
                mConversation = Conversation.createNew(this);
            }
        }
    }
    addRecipientsListeners();
    updateThreadIdIfRunning();
    mSendDiscreetMode = intent.getBooleanExtra(KEY_EXIT_ON_SENT, false);
    mForwardMessageMode = intent.getBooleanExtra(KEY_FORWARDED_MESSAGE, false);
    mReplyMessageMode = intent.getBooleanExtra(KEY_REPLY_MESSAGE, false);
    if (mSendDiscreetMode) {
        mMsgListView.setVisibility(View.INVISIBLE);
    }
    if (intent.hasExtra("sms_body")) {
        mWorkingMessage.setText(intent.getStringExtra("sms_body"));
    }
    mWorkingMessage.setSubject(intent.getStringExtra("subject"), false);
}
#method_after
private void initActivityState(Bundle bundle) {
    Intent intent = getIntent();
    if (bundle != null) {
        setIntent(getIntent().setAction(Intent.ACTION_VIEW));
        String recipients = bundle.getString(RECIPIENTS);
        if (LogTag.VERBOSE)
            log("get mConversation by recipients " + recipients);
        mConversation = Conversation.get(this, ContactList.getByNumbers(recipients, false, /* don't block */
        true), false);
        addRecipientsListeners();
        mSendDiscreetMode = bundle.getBoolean(KEY_EXIT_ON_SENT, false);
        mForwardMessageMode = bundle.getBoolean(KEY_FORWARDED_MESSAGE, false);
        if (mSendDiscreetMode) {
            mMsgListView.setVisibility(View.INVISIBLE);
        }
        mWorkingMessage.readStateFromBundle(bundle);
        return;
    }
    // If we have been passed a thread_id, use that to find our conversation.
    long threadId = intent.getLongExtra(THREAD_ID, 0);
    if (threadId > 0) {
        if (LogTag.VERBOSE)
            log("get mConversation by threadId " + threadId);
        mConversation = Conversation.get(this, threadId, false);
    } else {
        Uri intentData = intent.getData();
        if (intentData != null) {
            // try to get a conversation based on the data URI passed to our intent.
            if (LogTag.VERBOSE)
                log("get mConversation by intentData " + intentData);
            mConversation = Conversation.get(this, intentData, false);
            mWorkingMessage.setText(getBody(intentData));
        } else {
            // special intent extra parameter to specify the address
            String address = intent.getStringExtra("address");
            if (!TextUtils.isEmpty(address)) {
                if (LogTag.VERBOSE)
                    log("get mConversation by address " + address);
                mConversation = Conversation.get(this, ContactList.getByNumbers(address, false, /* don't block */
                true), false);
            } else {
                if (LogTag.VERBOSE)
                    log("create new conversation");
                mConversation = Conversation.createNew(this);
            }
        }
    }
    updateThreadIdIfRunning();
    mSendDiscreetMode = intent.getBooleanExtra(KEY_EXIT_ON_SENT, false);
    mForwardMessageMode = intent.getBooleanExtra(KEY_FORWARDED_MESSAGE, false);
    mReplyMessageMode = intent.getBooleanExtra(KEY_REPLY_MESSAGE, false);
    if (mSendDiscreetMode) {
        mMsgListView.setVisibility(View.INVISIBLE);
    }
    if (intent.hasExtra("sms_body")) {
        mWorkingMessage.setText(intent.getStringExtra("sms_body"));
    }
    mWorkingMessage.setSubject(intent.getStringExtra("subject"), false);
}
#end_block

#method_before
@Override
public void onUpdate(final Contact updated) {
    // Using an existing handler for the post, rather than conjuring up a new one.
    mMessageListItemHandler.post(new Runnable() {

        @Override
        public void run() {
            ContactList recipients = isRecipientsEditorVisible() ? mRecipientsEditor.constructContactsFromInput(false) : getRecipients();
            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                log("[CMA] onUpdate contact updated: " + updated);
                log("[CMA] onUpdate recipients: " + recipients);
            }
            updateTitle(recipients);
            // The contact information for one (or more) of the recipients has changed.
            // Rebuild the message list so each MessageItem will get the last contact info.
            ComposeMessageActivity.this.mMsgListAdapter.notifyDataSetChanged();
            if (mRecipientsEditor != null && (mAddNumbersTask == null || mAddNumbersTask.getStatus() != AsyncTask.Status.RUNNING) && updated.getPersonId() != 0) {
                mRecipientsEditor.populate(recipients);
            }
        }
    });
}
#method_after
@Override
public void onUpdate(final Contact updated) {
    // Using an existing handler for the post, rather than conjuring up a new one.
    mMessageListItemHandler.post(new Runnable() {

        @Override
        public void run() {
            ContactList recipients = isRecipientsEditorVisible() ? mRecipientsEditor.constructContactsFromInput(false) : getRecipients();
            if (Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                log("[CMA] onUpdate contact updated: " + updated);
                log("[CMA] onUpdate recipients: " + recipients);
            }
            if (recipients.size() > 0) {
                updateTitle(recipients);
            }
            // The contact information for one (or more) of the recipients has changed.
            // Rebuild the message list so each MessageItem will get the last contact info.
            ComposeMessageActivity.this.mMsgListAdapter.notifyDataSetChanged();
            if (mRecipientsEditor != null && (mAddNumbersTask == null || mAddNumbersTask.getStatus() != AsyncTask.Status.RUNNING) && updated.getPersonId() != 0) {
                mRecipientsEditor.populate(recipients);
            }
        }
    });
}
#end_block

#method_before
private CharSequence formatMessage() {
    final int color = android.R.styleable.Theme_textColorSecondary;
    String from = mConversation.getRecipients().formatNames(", ");
    if (MessageUtils.isWapPushNumber(from)) {
        String[] mAddresses = from.split(":");
        from = mAddresses[mContext.getResources().getInteger(R.integer.wap_push_address_index)];
    }
    /**
     * Add boolean to know that the "from" haven't the Arabic and '+'.
     * Make sure the "from" display normally for RTL.
     */
    boolean isEnName = false;
    boolean isLayoutRtl = (TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()) == View.LAYOUT_DIRECTION_RTL);
    if (isLayoutRtl && from != null) {
        if (from.length() >= 1) {
            Pattern pattern = Pattern.compile("[^أ-ي]+");
            Matcher matcher = pattern.matcher(from);
            isEnName = matcher.matches();
            if (isEnName && from.charAt(0) != '\u202D') {
                from = "\u202D" + from + "\u202C";
            }
        }
    }
    SpannableStringBuilder buf = new SpannableStringBuilder(from);
    if (mConversation.getMessageCount() > 1) {
        int before = buf.length();
        if (isLayoutRtl && isEnName) {
            buf.insert(1, mConversation.getMessageCount() + " ");
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.color.message_count_color)), 1, buf.length() - before, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        } else {
            buf.append(mContext.getResources().getString(R.string.message_count_format, mConversation.getMessageCount()));
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.color.message_count_color)), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        }
    }
    if (mConversation.hasDraft()) {
        if (isLayoutRtl && isEnName) {
            int before = buf.length();
            buf.insert(1, '\u202E' + mContext.getResources().getString(R.string.draft_separator) + '\u202C');
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.drawable.text_color_black)), 1, buf.length() - before + 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
            before = buf.length();
            int size;
            buf.insert(1, mContext.getResources().getString(R.string.has_draft));
            size = android.R.style.TextAppearance_Small;
            buf.setSpan(new TextAppearanceSpan(mContext, size), 1, buf.length() - before + 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.drawable.text_color_red)), 1, buf.length() - before + 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        } else {
            buf.append(mContext.getResources().getString(R.string.draft_separator));
            int before = buf.length();
            int size;
            buf.append(mContext.getResources().getString(R.string.has_draft));
            size = android.R.style.TextAppearance_Small;
            buf.setSpan(new TextAppearanceSpan(mContext, size, color), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.drawable.text_color_red)), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        }
    }
    // Unread messages are shown in bold
    if (mConversation.hasUnreadMessages()) {
        buf.setSpan(STYLE_BOLD, 0, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
    }
    return buf;
}
#method_after
private CharSequence formatMessage() {
    final int color = android.R.styleable.Theme_textColorSecondary;
    String from = mConversation.getRecipients().formatNames(", ");
    if (MessageUtils.isWapPushNumber(from)) {
        String[] mAddresses = from.split(":");
        from = mAddresses[mContext.getResources().getInteger(R.integer.wap_push_address_index)];
    }
    /**
     * Add boolean to know that the "from" haven't the Arabic and '+'.
     * Make sure the "from" display normally for RTL.
     */
    boolean isEnName = false;
    boolean isLayoutRtl = (TextUtils.getLayoutDirectionFromLocale(Locale.getDefault()) == View.LAYOUT_DIRECTION_RTL);
    if (isLayoutRtl && from != null) {
        if (from.length() >= 1) {
            Matcher matcher = RTL_CHARACTERS.matcher(from);
            isEnName = !matcher.find();
            if (isEnName && from.charAt(0) != '\u202D') {
                from = "\u202D" + from + "\u202C";
            }
        }
    }
    SpannableStringBuilder buf = new SpannableStringBuilder(from);
    if (mConversation.getMessageCount() > 1) {
        int before = buf.length();
        if (isLayoutRtl && isEnName) {
            buf.insert(1, mConversation.getMessageCount() + " ");
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.color.message_count_color)), 1, buf.length() - before, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        } else {
            buf.append(mContext.getResources().getString(R.string.message_count_format, mConversation.getMessageCount()));
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.color.message_count_color)), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        }
    }
    if (mConversation.hasDraft()) {
        if (isLayoutRtl && isEnName) {
            int before = buf.length();
            buf.insert(1, '\u202E' + mContext.getResources().getString(R.string.draft_separator) + '\u202C');
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.drawable.text_color_black)), 1, buf.length() - before + 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
            before = buf.length();
            int size;
            buf.insert(1, mContext.getResources().getString(R.string.has_draft));
            size = android.R.style.TextAppearance_Small;
            buf.setSpan(new TextAppearanceSpan(mContext, size), 1, buf.length() - before + 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.drawable.text_color_red)), 1, buf.length() - before + 1, Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        } else {
            buf.append(mContext.getResources().getString(R.string.draft_separator));
            int before = buf.length();
            int size;
            buf.append(mContext.getResources().getString(R.string.has_draft));
            size = android.R.style.TextAppearance_Small;
            buf.setSpan(new TextAppearanceSpan(mContext, size, color), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
            buf.setSpan(new ForegroundColorSpan(mContext.getResources().getColor(R.drawable.text_color_red)), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        }
    }
    // Unread messages are shown in bold
    if (mConversation.hasUnreadMessages()) {
        buf.setSpan(STYLE_BOLD, 0, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
    }
    return buf;
}
#end_block

#method_before
public final void bind(Context context, final Conversation conversation) {
    // if (DEBUG) Log.v(TAG, "bind()");
    boolean sameItem = mConversation != null && mConversation.getThreadId() == conversation.getThreadId();
    mConversation = conversation;
    LayoutParams attachmentLayout = (LayoutParams) mAttachmentView.getLayoutParams();
    boolean hasError = conversation.hasError();
    // As far as I know, there's no way to specify that relationship in xml.
    if (hasError) {
        attachmentLayout.addRule(RelativeLayout.LEFT_OF, R.id.error);
    } else {
        attachmentLayout.addRule(RelativeLayout.LEFT_OF, R.id.date);
    }
    boolean hasAttachment = conversation.hasAttachment();
    mAttachmentView.setVisibility(hasAttachment ? VISIBLE : GONE);
    // Date
    mDateView.setText(MessageUtils.formatTimeStampString(context, conversation.getDate()));
    // From.
    mFromView.setText(formatMessage());
    // Register for updates in changes of any of the contacts in this conversation.
    ContactList contacts = conversation.getRecipients();
    if (Log.isLoggable(LogTag.CONTACT, Log.DEBUG)) {
        Log.v(TAG, "bind: contacts.addListeners " + this);
    }
    Contact.addListener(this);
    // Subject
    SmileyParser parser = SmileyParser.getInstance();
    final String snippet = conversation.getSnippet();
    if (mConversation.hasUnreadMessages()) {
        SpannableStringBuilder buf = new SpannableStringBuilder(parser.addSmileySpans(snippet));
        buf.setSpan(STYLE_BOLD, 0, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        mSubjectView.setText(buf);
    } else {
        mSubjectView.setText(parser.addSmileySpans(snippet));
    }
    // Transmission error indicator.
    mErrorIndicator.setVisibility(hasError ? VISIBLE : GONE);
    updateAvatarView();
    mAvatarView.setChecked(isChecked(), sameItem);
}
#method_after
public final void bind(Context context, final Conversation conversation) {
    // if (DEBUG) Log.v(TAG, "bind()");
    boolean sameItem = mConversation != null && mConversation.getThreadId() == conversation.getThreadId();
    mConversation = conversation;
    LayoutParams attachmentLayout = (LayoutParams) mAttachmentView.getLayoutParams();
    boolean hasError = conversation.hasError();
    // As far as I know, there's no way to specify that relationship in xml.
    if (hasError) {
        attachmentLayout.addRule(RelativeLayout.LEFT_OF, R.id.error);
    } else {
        attachmentLayout.addRule(RelativeLayout.LEFT_OF, R.id.date);
    }
    boolean hasAttachment = conversation.hasAttachment();
    mAttachmentView.setVisibility(hasAttachment ? VISIBLE : GONE);
    // Date
    mDateView.setText(MessageUtils.formatTimeStampString(context, conversation.getDate()));
    // From.
    mFromView.setText(formatMessage());
    // Register for updates in changes of any of the contacts in this conversation.
    ContactList contacts = conversation.getRecipients();
    if (Log.isLoggable(LogTag.CONTACT, Log.DEBUG)) {
        Log.v(TAG, "bind: contacts.addListeners " + this);
    }
    Contact.addListener(this);
    // Subject
    SmileyParser parser = SmileyParser.getInstance();
    final String snippet = conversation.getSnippet();
    if (mConversation.hasUnreadMessages()) {
        SpannableStringBuilder buf = new SpannableStringBuilder(parser.addSmileySpans(snippet));
        buf.setSpan(STYLE_BOLD, 0, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
        mSubjectView.setText(buf);
    } else {
        mSubjectView.setText(parser.addSmileySpans(snippet));
    }
    // Transmission error indicator.
    mErrorIndicator.setVisibility(hasError ? VISIBLE : GONE);
    updateAvatarView();
    mAvatarView.setChecked(isChecked(), sameItem);
    mAvatarView.setAttributionDrawable(null);
}
#end_block

#method_before
@Override
public void setChecked(boolean checked) {
    mConversation.setIsChecked(checked);
    mAvatarView.setChecked(isChecked(), true);
    setActivated(checked);
}
#method_after
@Override
public void setChecked(boolean checked) {
    mConversation.setIsChecked(checked);
    mAvatarView.setChecked(isChecked(), true);
}
#end_block

#method_before
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
    if (getArguments() != null) {
        Bundle bundle = getArguments();
        mNumbers = bundle.getStringArray(NUMBERS_EXTRA);
        mOrigin = bundle.getInt(ORIGIN_EXTRA, ORIGIN_UNKNOWN);
    }
    mProgressMessage = getResources().getString(R.string.block_dialog_progress_message);
    AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
    LayoutInflater inflater = (LayoutInflater) getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View v = inflater.inflate(R.layout.block_dialog_view, null);
    mCheckBox = (CheckBox) v.findViewById(R.id.spamCheckbox);
    // Should be provider.getTitle();
    // [TODO][MSB]: Get provider title somehow
    String providerTitle = "Truecaller";
    mCheckBox.setText(getActivity().getResources().getString(R.string.block_dialog_report_spam, providerTitle));
    mCheckBox.setVisibility(View.VISIBLE);
    builder.setTitle(R.string.block_dialog_title).setView(v).setPositiveButton(R.string.block_dialog_positive, this).setNegativeButton(R.string.block_dialog_negative, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            if (mFinishListener != null) {
                mFinishListener.onFinish();
            }
        }
    });
    MetricsHelper.init(MmsApp.getApplication());
    return builder.create();
}
#method_after
@Override
public Dialog onCreateDialog(Bundle savedInstanceState) {
    if (getArguments() != null) {
        Bundle bundle = getArguments();
        mNumbers = bundle.getStringArray(NUMBERS_EXTRA);
        mOrigin = bundle.getInt(ORIGIN_EXTRA, ORIGIN_UNKNOWN);
    }
    mProgressMessage = getResources().getString(R.string.block_dialog_progress_message);
    AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());
    LayoutInflater inflater = (LayoutInflater) getActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    View v = inflater.inflate(R.layout.block_dialog_view, null);
    mCheckBox = (CheckBox) v.findViewById(R.id.spamCheckbox);
    String providerTitle = MmsApp.getApplication().getProviderName();
    if (MmsApp.getApplication().hasSpamReporting()) {
        mCheckBox.setText(getActivity().getResources().getString(R.string.block_dialog_report_spam, providerTitle));
        mCheckBox.setVisibility(View.VISIBLE);
    } else {
        mCheckBox.setVisibility(View.GONE);
    }
    builder.setTitle(R.string.block_dialog_title).setView(v).setPositiveButton(R.string.block_dialog_positive, this).setNegativeButton(R.string.block_dialog_negative, new DialogInterface.OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            if (mFinishListener != null) {
                mFinishListener.onFinish();
            }
        }
    });
    MetricsHelper.init(MmsApp.getApplication());
    return builder.create();
}
#end_block

#method_before
@Override
protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
    switch(token) {
        case MESSAGE_LIST_QUERY_TOKEN:
            /* test validity of cursor - sometimes (when repeatedly clicking on message 
                    during and after Delivery delay) the cursor passed to this callback is invalid
                    probably some more beautiful solution is possible */
            if (cursor != null && !cursor.isClosed()) {
                try {
                    int cp = cursor.getPosition();
                    cursor.moveToLast();
                    cursor.moveToPosition(cp);
                } catch (IllegalStateException e) {
                    cursor.close();
                    Log.e(TAG, "Bad cursor.", e);
                    return;
                }
            }
            mConversation.blockMarkAsRead(false);
            // check consistency between the query result and 'mConversation'
            long tid = (Long) cookie;
            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                log("##### onQueryComplete: msg history result for threadId " + tid);
            }
            if (tid != mConversation.getThreadId()) {
                log("onQueryComplete: msg history query result is for threadId " + tid + ", but mConversation has threadId " + mConversation.getThreadId() + " starting a new query");
                if (cursor != null) {
                    cursor.close();
                }
                startMsgListQuery();
                return;
            }
            // check consistency b/t mConversation & mWorkingMessage.mConversation
            ComposeMessageActivity.this.sanityCheckConversation();
            int newSelectionPos = -1;
            long targetMsgId = getIntent().getLongExtra("select_id", -1);
            if (targetMsgId != -1) {
                if (cursor != null) {
                    cursor.moveToPosition(-1);
                    while (cursor.moveToNext()) {
                        long msgId = cursor.getLong(COLUMN_ID);
                        if (msgId == targetMsgId) {
                            newSelectionPos = cursor.getPosition();
                            break;
                        }
                    }
                }
            } else if (mSavedScrollPosition != -1) {
                // visible.
                if (mSavedScrollPosition == Integer.MAX_VALUE) {
                    int cnt = mMsgListAdapter.getCount();
                    if (cnt > 0) {
                        // Have to wait until the adapter is loaded before jumping to
                        // the end.
                        newSelectionPos = cnt - 1;
                        mSavedScrollPosition = -1;
                    }
                } else {
                    // remember the saved scroll position before the activity is paused.
                    // reset it after the message list query is done
                    newSelectionPos = mSavedScrollPosition;
                    mSavedScrollPosition = -1;
                }
            }
            mMsgListAdapter.changeCursor(cursor);
            if (newSelectionPos != -1) {
                // jump the list to the pos
                mMsgListView.setSelection(newSelectionPos);
            } else {
                int count = mMsgListAdapter.getCount();
                long lastMsgId = 0;
                if (cursor != null && count > 0) {
                    cursor.moveToLast();
                    lastMsgId = cursor.getLong(COLUMN_ID);
                }
                // mScrollOnSend is set when we send a message. We always want to scroll
                // the message list to the end when we send a message, but have to wait
                // until the DB has changed. We also want to scroll the list when a
                // new message has arrived.
                smoothScrollToEnd(mScrollOnSend || lastMsgId != mLastMessageId, 0);
                mLastMessageId = lastMsgId;
                mScrollOnSend = false;
            }
            // Adjust the conversation's message count to match reality. The
            // conversation's message count is eventually used in
            // WorkingMessage.clearConversation to determine whether to delete
            // the conversation or not.
            mConversation.setMessageCount(mMsgListAdapter.getCount());
            // more people before the conversation begins.
            if (cursor != null && cursor.getCount() == 0 && !isRecipientsEditorVisible() && !mSentMessage) {
                initRecipientsEditor();
            }
            // FIXME: freshing layout changes the focused view to an unexpected
            // one, set it back to TextEditor forcely.
            mTextEditor.requestFocus();
            // some menu items depend on the adapter's count
            invalidateOptionsMenu();
            return;
        case ConversationList.HAVE_LOCKED_MESSAGES_TOKEN:
            @SuppressWarnings("unchecked")
            ArrayList<Long> threadIds = (ArrayList<Long>) cookie;
            ConversationList.confirmDeleteThreadDialog(new ConversationList.DeleteThreadListener(threadIds, mBackgroundQueryHandler, ComposeMessageActivity.this), threadIds, cursor != null && cursor.getCount() > 0, ComposeMessageActivity.this);
            if (cursor != null) {
                cursor.close();
            }
            break;
        case MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN:
            // check consistency between the query result and 'mConversation'
            tid = (Long) cookie;
            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                log("##### onQueryComplete (after delete): msg history result for threadId " + tid);
            }
            if (cursor == null) {
                return;
            }
            if (tid > 0 && cursor.getCount() == 0) {
                // We just deleted the last message and the thread will get deleted
                // by a trigger in the database. Clear the threadId so next time we
                // need the threadId a new thread will get created.
                log("##### MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN clearing thread id: " + tid);
                Conversation conv = Conversation.get(ComposeMessageActivity.this, tid, false);
                if (conv != null) {
                    conv.clearThreadId();
                    conv.setDraftState(false);
                }
                // The last message in this converation was just deleted. Send the user
                // to the conversation list.
                exitComposeMessageActivity(new Runnable() {

                    @Override
                    public void run() {
                        goToConversationList();
                    }
                });
            }
            cursor.close();
    }
}
#method_after
@Override
protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
    switch(token) {
        case MESSAGE_LIST_QUERY_TOKEN:
            if (cursor != null && !cursor.isClosed()) {
                try {
                    cursor.moveToLast();
                } catch (IllegalStateException e) {
                    cursor.close();
                    Log.e(TAG, "Bad cursor.", e);
                    return;
                }
            }
            mConversation.blockMarkAsRead(false);
            // check consistency between the query result and 'mConversation'
            long tid = (Long) cookie;
            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                log("##### onQueryComplete: msg history result for threadId " + tid);
            }
            if (tid != mConversation.getThreadId()) {
                log("onQueryComplete: msg history query result is for threadId " + tid + ", but mConversation has threadId " + mConversation.getThreadId() + " starting a new query");
                if (cursor != null) {
                    cursor.close();
                }
                startMsgListQuery();
                return;
            }
            // check consistency b/t mConversation & mWorkingMessage.mConversation
            ComposeMessageActivity.this.sanityCheckConversation();
            int newSelectionPos = -1;
            long targetMsgId = getIntent().getLongExtra("select_id", -1);
            if (targetMsgId != -1) {
                if (cursor != null) {
                    cursor.moveToPosition(-1);
                    while (cursor.moveToNext()) {
                        long msgId = cursor.getLong(COLUMN_ID);
                        if (msgId == targetMsgId) {
                            newSelectionPos = cursor.getPosition();
                            break;
                        }
                    }
                }
            } else if (mSavedScrollPosition != -1) {
                // visible.
                if (mSavedScrollPosition == Integer.MAX_VALUE) {
                    int cnt = mMsgListAdapter.getCount();
                    if (cnt > 0) {
                        // Have to wait until the adapter is loaded before jumping to
                        // the end.
                        newSelectionPos = cnt - 1;
                        mSavedScrollPosition = -1;
                    }
                } else {
                    // remember the saved scroll position before the activity is paused.
                    // reset it after the message list query is done
                    newSelectionPos = mSavedScrollPosition;
                    mSavedScrollPosition = -1;
                }
            }
            mMsgListAdapter.changeCursor(cursor);
            if (newSelectionPos != -1) {
                // jump the list to the pos
                mMsgListView.setSelection(newSelectionPos);
            } else {
                int count = mMsgListAdapter.getCount();
                long lastMsgId = 0;
                if (cursor != null && count > 0) {
                    cursor.moveToLast();
                    lastMsgId = cursor.getLong(COLUMN_ID);
                }
                // mScrollOnSend is set when we send a message. We always want to scroll
                // the message list to the end when we send a message, but have to wait
                // until the DB has changed. We also want to scroll the list when a
                // new message has arrived.
                smoothScrollToEnd(mScrollOnSend || lastMsgId != mLastMessageId, 0);
                mLastMessageId = lastMsgId;
                mScrollOnSend = false;
            }
            // Adjust the conversation's message count to match reality. The
            // conversation's message count is eventually used in
            // WorkingMessage.clearConversation to determine whether to delete
            // the conversation or not.
            mConversation.setMessageCount(mMsgListAdapter.getCount());
            // more people before the conversation begins.
            if (cursor != null && cursor.getCount() == 0 && !isRecipientsEditorVisible() && !mSentMessage) {
                initRecipientsEditor();
            }
            // FIXME: freshing layout changes the focused view to an unexpected
            // one, set it back to TextEditor forcely.
            mTextEditor.requestFocus();
            // some menu items depend on the adapter's count
            invalidateOptionsMenu();
            return;
        case ConversationList.HAVE_LOCKED_MESSAGES_TOKEN:
            @SuppressWarnings("unchecked")
            ArrayList<Long> threadIds = (ArrayList<Long>) cookie;
            ConversationList.confirmDeleteThreadDialog(new ConversationList.DeleteThreadListener(threadIds, mBackgroundQueryHandler, ComposeMessageActivity.this), threadIds, cursor != null && cursor.getCount() > 0, ComposeMessageActivity.this);
            if (cursor != null) {
                cursor.close();
            }
            break;
        case MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN:
            // check consistency between the query result and 'mConversation'
            tid = (Long) cookie;
            if (LogTag.VERBOSE || Log.isLoggable(LogTag.APP, Log.VERBOSE)) {
                log("##### onQueryComplete (after delete): msg history result for threadId " + tid);
            }
            if (cursor == null) {
                return;
            }
            if (tid > 0 && cursor.getCount() == 0) {
                // We just deleted the last message and the thread will get deleted
                // by a trigger in the database. Clear the threadId so next time we
                // need the threadId a new thread will get created.
                log("##### MESSAGE_LIST_QUERY_AFTER_DELETE_TOKEN clearing thread id: " + tid);
                Conversation conv = Conversation.get(ComposeMessageActivity.this, tid, false);
                if (conv != null) {
                    conv.clearThreadId();
                    conv.setDraftState(false);
                }
                // The last message in this converation was just deleted. Send the user
                // to the conversation list.
                exitComposeMessageActivity(new Runnable() {

                    @Override
                    public void run() {
                        goToConversationList();
                    }
                });
            }
            cursor.close();
    }
}
#end_block

#method_before
public static int getValidityPeriod(int slot) {
    final BuglePrefs prefs = BuglePrefs.getApplicationPrefs();
    final Context context = Factory.get().getApplicationContext();
    String validityPeriod = context.getString(R.string.def_sms_validity_period_value);
    switch(slot) {
        case -1:
            validityPeriod = prefs.getString("pref_key_sms_validity_period", null);
            break;
        case 0:
            validityPeriod = prefs.getString("pref_key_sms_validity_period_slot1", null);
            break;
        case 1:
            validityPeriod = prefs.getString("pref_key_sms_validity_period_slot2", null);
            break;
        default:
            break;
    }
    return (validityPeriod == null) ? -1 : Integer.parseInt(validityPeriod);
}
#method_after
public static int getValidityPeriod(int slot) {
    final BuglePrefs prefs = BuglePrefs.getApplicationPrefs();
    final Context context = Factory.get().getApplicationContext();
    String validityPeriod = context.getString(R.string.def_sms_validity_period_value);
    String prefKey = context.getString(R.string.pref_key_sms_validity_period);
    if (PhoneUtils.getDefault().isMultiSimEnabledMms()) {
        String prefKeySlot1 = context.getString(R.string.pref_key_sms_validity_period_slot1);
        String prefKeySlot2 = context.getString(R.string.pref_key_sms_validity_period_slot2);
        validityPeriod = prefs.getString((slot == 0) ? prefKeySlot1 : prefKeySlot2, null);
    } else {
        validityPeriod = prefs.getString(prefKey, null);
    }
    return (validityPeriod == null) ? -1 : Integer.parseInt(validityPeriod);
}
#end_block

#method_before
private static void sendInternal(final Context context, final int subId, String dest, final ArrayList<String> messages, final String serviceCenter, final boolean requireDeliveryReport, final Uri messageUri) throws SmsException {
    Assert.notNull(context);
    final SmsManager smsManager = PhoneUtils.get(subId).getSmsManager();
    final int messageCount = messages.size();
    final ArrayList<PendingIntent> deliveryIntents = new ArrayList<PendingIntent>(messageCount);
    final ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(messageCount);
    for (int i = 0; i < messageCount; i++) {
        // Make pending intents different for each message part
        final int partId = (messageCount <= 1 ? 0 : i + 1);
        if (requireDeliveryReport && (i == (messageCount - 1))) {
            // TODO we only care about the delivery status of the last part
            // Shall we have better tracking of delivery status of all parts?
            deliveryIntents.add(PendingIntent.getBroadcast(context, partId, getSendStatusIntent(context, SendStatusReceiver.MESSAGE_DELIVERED_ACTION, messageUri, partId, subId), 0));
        } else {
            deliveryIntents.add(null);
        }
        sentIntents.add(PendingIntent.getBroadcast(context, partId, getSendStatusIntent(context, SendStatusReceiver.MESSAGE_SENT_ACTION, messageUri, partId, subId), 0));
    }
    if (sSendMultipartSmsAsSeparateMessages == null) {
        sSendMultipartSmsAsSeparateMessages = MmsConfig.get(subId).getSendMultipartSmsAsSeparateMessages();
    }
    try {
        if (sSendMultipartSmsAsSeparateMessages) {
            // If multipart sms is not supported, send them as separate messages
            for (int i = 0; i < messageCount; i++) {
                smsManager.sendTextMessage(dest, serviceCenter, messages.get(i), sentIntents.get(i), deliveryIntents.get(i));
            }
        } else {
            int validityPeriod = PrefsUtils.getValidityPeriod(SubscriptionManager.getPhoneId(subId));
            // Remove all attributes for CDMA international roaming.
            if (PhoneUtils.getDefault().isCDMAInternationalRoaming(subId)) {
                LogUtil.v(TAG, "sendMessage during CDMA international roaming.");
                validityPeriod = -1;
            }
            smsManager.sendMultipartTextMessage(dest, serviceCenter, messages, sentIntents, deliveryIntents, -1, false, validityPeriod);
        }
    } catch (final Exception e) {
        throw new SmsException("SmsSender: caught exception in sending " + e);
    }
}
#method_after
private static void sendInternal(final Context context, final int subId, String dest, final ArrayList<String> messages, final String serviceCenter, final boolean requireDeliveryReport, final Uri messageUri) throws SmsException {
    Assert.notNull(context);
    final SmsManager smsManager = PhoneUtils.get(subId).getSmsManager();
    final int messageCount = messages.size();
    final ArrayList<PendingIntent> deliveryIntents = new ArrayList<PendingIntent>(messageCount);
    final ArrayList<PendingIntent> sentIntents = new ArrayList<PendingIntent>(messageCount);
    for (int i = 0; i < messageCount; i++) {
        // Make pending intents different for each message part
        final int partId = (messageCount <= 1 ? 0 : i + 1);
        if (requireDeliveryReport && (i == (messageCount - 1))) {
            // TODO we only care about the delivery status of the last part
            // Shall we have better tracking of delivery status of all parts?
            deliveryIntents.add(PendingIntent.getBroadcast(context, partId, getSendStatusIntent(context, SendStatusReceiver.MESSAGE_DELIVERED_ACTION, messageUri, partId, subId), 0));
        } else {
            deliveryIntents.add(null);
        }
        sentIntents.add(PendingIntent.getBroadcast(context, partId, getSendStatusIntent(context, SendStatusReceiver.MESSAGE_SENT_ACTION, messageUri, partId, subId), 0));
    }
    if (sSendMultipartSmsAsSeparateMessages == null) {
        sSendMultipartSmsAsSeparateMessages = MmsConfig.get(subId).getSendMultipartSmsAsSeparateMessages();
    }
    try {
        if (sSendMultipartSmsAsSeparateMessages) {
            // If multipart sms is not supported, send them as separate messages
            for (int i = 0; i < messageCount; i++) {
                smsManager.sendTextMessage(dest, serviceCenter, messages.get(i), sentIntents.get(i), deliveryIntents.get(i));
            }
        } else {
            int validityPeriod = PrefsUtils.getValidityPeriod(SubscriptionManager.getPhoneId(subId));
            // Remove all attributes for CDMA international roaming.
            if (PhoneUtils.getDefault().isCDMAInternationalRoaming(subId)) {
                LogUtil.v(TAG, "sendMessage during CDMA international roaming.");
                validityPeriod = -1;
                mPriority = -1;
            }
            smsManager.sendMultipartTextMessage(dest, serviceCenter, messages, sentIntents, deliveryIntents, mPriority, false, validityPeriod);
        }
    } catch (final Exception e) {
        throw new SmsException("SmsSender: caught exception in sending " + e);
    }
}
#end_block

#method_before
public static Uri insertSendingMmsMessage(final Context context, final List<String> recipients, final MessageData content, final int subId, final String subPhoneNumber, final long timestamp) {
    final boolean requireDeliveryReport = isMmsDeliveryReportRequired(subId);
    final boolean requireReadReport = isMmsDeliveryReportRequired(subId);
    final long expiryTime = getExpiryTime(subId);
    final SendReq sendReq = createMmsSendReq(context, subId, recipients.toArray(new String[recipients.size()]), content, requireDeliveryReport, requireReadReport, expiryTime, DEFAULT_PRIORITY, timestamp);
    Uri messageUri = null;
    if (sendReq != null) {
        final Uri outboxUri = MmsUtils.insertSendReq(context, sendReq, subId, subPhoneNumber);
        if (outboxUri != null) {
            messageUri = ContentUris.withAppendedId(Telephony.Mms.CONTENT_URI, ContentUris.parseId(outboxUri));
            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
                LogUtil.d(TAG, "Mmsutils: Inserted sending MMS message into telephony, uri: " + outboxUri);
            }
        } else {
            LogUtil.e(TAG, "insertSendingMmsMessage: failed to persist message into telephony");
        }
    }
    return messageUri;
}
#method_after
public static Uri insertSendingMmsMessage(final Context context, final List<String> recipients, final MessageData content, final int subId, final String subPhoneNumber, final long timestamp) {
    final boolean requireDeliveryReport = isMmsDeliveryReportRequired(subId);
    final boolean requireReadReport = isMmsDeliveryReportRequired(subId);
    final long expiryTime = getExpiryTime(subId);
    final SendReq sendReq = createMmsSendReq(context, subId, recipients.toArray(new String[recipients.size()]), content, requireDeliveryReport, requireReadReport, expiryTime, getSendPriority(subId), timestamp);
    Uri messageUri = null;
    if (sendReq != null) {
        final Uri outboxUri = MmsUtils.insertSendReq(context, sendReq, subId, subPhoneNumber);
        if (outboxUri != null) {
            messageUri = ContentUris.withAppendedId(Telephony.Mms.CONTENT_URI, ContentUris.parseId(outboxUri));
            if (LogUtil.isLoggable(TAG, LogUtil.DEBUG)) {
                LogUtil.d(TAG, "Mmsutils: Inserted sending MMS message into telephony, uri: " + outboxUri);
            }
        } else {
            LogUtil.e(TAG, "insertSendingMmsMessage: failed to persist message into telephony");
        }
    }
    return messageUri;
}
#end_block

#method_before
static SendReq createSendReq(final Context context, final int subId, final String[] recipients, final MessageData message, final boolean requireDeliveryReport, final boolean requireReadReport, final long expiryTime, final int priority, final long timestampMillis) throws InvalidHeaderValueException {
    final SendReq req = new SendReq();
    // From, per spec
    final String lineNumber = PhoneUtils.get(subId).getCanonicalForSelf(true);
    if (!TextUtils.isEmpty(lineNumber)) {
        req.setFrom(new EncodedStringValue(lineNumber));
    }
    // To
    final EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(recipients);
    if (encodedNumbers != null) {
        req.setTo(encodedNumbers);
    }
    // Subject
    if (!TextUtils.isEmpty(message.getMmsSubject())) {
        req.setSubject(new EncodedStringValue(message.getMmsSubject()));
    }
    // Date
    req.setDate(timestampMillis / 1000L);
    // Body
    final MmsInfo bodyInfo = MmsUtils.makePduBody(context, message, subId);
    req.setBody(bodyInfo.mPduBody);
    // Message size
    req.setMessageSize(bodyInfo.mMessageSize);
    // Message class
    req.setMessageClass(PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes());
    // Expiry
    req.setExpiry(expiryTime);
    // Priority
    req.setPriority(priority);
    // Delivery report
    req.setDeliveryReport(requireDeliveryReport ? PduHeaders.VALUE_YES : PduHeaders.VALUE_NO);
    // Read report
    req.setReadReport(requireReadReport ? PduHeaders.VALUE_YES : PduHeaders.VALUE_NO);
    return req;
}
#method_after
static SendReq createSendReq(final Context context, final int subId, final String[] recipients, final MessageData message, final boolean requireDeliveryReport, final boolean requireReadReport, final long expiryTime, final int priority, final long timestampMillis) throws InvalidHeaderValueException {
    final SendReq req = new SendReq();
    // From, per spec
    final String lineNumber = PhoneUtils.get(subId).getCanonicalForSelf(true);
    if (!TextUtils.isEmpty(lineNumber)) {
        req.setFrom(new EncodedStringValue(lineNumber));
    }
    // To
    final EncodedStringValue[] encodedNumbers = EncodedStringValue.encodeStrings(recipients);
    if (encodedNumbers != null) {
        req.setTo(encodedNumbers);
    }
    // Subject
    if (!TextUtils.isEmpty(message.getMmsSubject())) {
        req.setSubject(new EncodedStringValue(message.getMmsSubject()));
    }
    // Date
    req.setDate(timestampMillis / 1000L);
    // Body
    final MmsInfo bodyInfo = MmsUtils.makePduBody(context, message, subId);
    req.setBody(bodyInfo.mPduBody);
    // Message size
    req.setMessageSize(bodyInfo.mMessageSize);
    // Message class
    req.setMessageClass(PduHeaders.MESSAGE_CLASS_PERSONAL_STR.getBytes());
    // Expiry
    if (expiryTime != -1) {
        // Set only if != -1 (MAX). For -1,  not calling setExpiry leads to use MAX as default.
        req.setExpiry(expiryTime);
    }
    // Priority
    req.setPriority(priority);
    // Delivery report
    req.setDeliveryReport(requireDeliveryReport ? PduHeaders.VALUE_YES : PduHeaders.VALUE_NO);
    // Read report
    req.setReadReport(requireReadReport ? PduHeaders.VALUE_YES : PduHeaders.VALUE_NO);
    return req;
}
#end_block

#method_before
public static boolean isDeliveryReportRequired(final int subId) {
    if (!MmsConfig.get(subId).getSMSDeliveryReportsEnabled()) {
        return false;
    }
    final Context context = Factory.get().getApplicationContext();
    final Resources res = context.getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String deliveryReportKey = res.getString(R.string.delivery_reports_pref_key);
    final boolean defaultValue = res.getBoolean(R.bool.delivery_reports_pref_default);
    return prefs.getBoolean(deliveryReportKey, defaultValue);
}
#method_after
public static boolean isDeliveryReportRequired(final int subId) {
    if (!MmsConfig.get(subId).getSMSDeliveryReportsEnabled()) {
        return false;
    }
    final Resources res = Factory.get().getApplicationContext().getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String deliveryReportKey = res.getString(R.string.delivery_reports_pref_key);
    final boolean defaultValue = res.getBoolean(R.bool.delivery_reports_pref_default);
    return prefs.getBoolean(deliveryReportKey, defaultValue);
}
#end_block

#method_before
public static boolean isMmsDeliveryReportRequired(final int subId) {
    final Context context = Factory.get().getApplicationContext();
    final Resources res = context.getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String mmsDeliveryReportKey = res.getString(R.string.pref_key_mms_delivery_reports);
    final boolean defaultValue = res.getBoolean(R.bool.def_mms_delivery_reports);
    return prefs.getBoolean(mmsDeliveryReportKey, defaultValue);
}
#method_after
private static boolean isMmsDeliveryReportRequired(final int subId) {
    final Resources res = Factory.get().getApplicationContext().getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String mmsDeliveryReportKey = res.getString(R.string.delivery_reports_mms_pref_key);
    final boolean defaultValue = res.getBoolean(R.bool.def_mms_delivery_reports);
    return prefs.getBoolean(mmsDeliveryReportKey, defaultValue);
}
#end_block

#method_before
public static boolean isMmsReadReportRequired(final int subId) {
    final Context context = Factory.get().getApplicationContext();
    final Resources res = context.getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String readReportKey = res.getString(R.string.pref_key_mms_read_reports);
    final boolean defaultValue = DEFAULT_READ_REPORT_MODE;
    return prefs.getBoolean(readReportKey, defaultValue);
}
#method_after
private static boolean isMmsReadReportRequired(final int subId) {
    final Resources res = Factory.get().getApplicationContext().getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String readReportKey = res.getString(R.string.read_reports_mms_pref_key);
    final boolean defaultValue = DEFAULT_READ_REPORT_MODE;
    return prefs.getBoolean(readReportKey, defaultValue);
}
#end_block

#method_before
public static long getExpiryTime(final int subId) {
    final Context context = Factory.get().getApplicationContext();
    final Resources res = context.getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String expiryStr = res.getString(R.string.pref_key_mms_expiry);
    final String expiryStr1 = res.getString(R.string.pref_key_mms_expiry_slot1);
    final String expiryStr2 = res.getString(R.string.pref_key_mms_expiry_slot2);
    final int mPhoneId = SubscriptionManager.getPhoneId(subId);
    // Expiry.
    long expiryTime = DEFAULT_EXPIRY_TIME_IN_SECONDS;
    if (PhoneUtils.getDefault().isMultiSimEnabledMms()) {
        expiryTime = Long.parseLong(prefs.getString((mPhoneId == 0) ? expiryStr1 : expiryStr2, "0"));
    } else {
        expiryTime = Long.parseLong(prefs.getString(expiryStr, "0"));
    }
    if (0 != expiryTime) {
        // Add for sub , if don't set , net will set to Maxinum to default
        return expiryTime;
    }
    return expiryTime;
}
#method_after
private static long getExpiryTime(final int subId) {
    final Resources res = Factory.get().getApplicationContext().getResources();
    final BuglePrefs prefs = BuglePrefs.getSubscriptionPrefs(subId);
    final String expiryStr = res.getString(R.string.expiry_mms_pref_key);
    final String expiryStr1 = res.getString(R.string.expiry_slot1_mms_pref_key);
    final String expiryStr2 = res.getString(R.string.expiry_slot2_mms_pref_key);
    final int mPhoneId = SubscriptionManager.getPhoneId(subId);
    // Expiry.
    long expiryTime = 0;
    if (PhoneUtils.getDefault().isMultiSimEnabledMms()) {
        expiryTime = Long.parseLong(prefs.getString((mPhoneId == 0) ? expiryStr1 : expiryStr2, "0"));
    } else {
        expiryTime = Long.parseLong(prefs.getString(expiryStr, "0"));
    }
    return expiryTime != 0 ? expiryTime : DEFAULT_EXPIRY_TIME_IN_SECONDS;
}
#end_block

#method_before
@Override
public void onCreate(final Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Get sub id from launch intent
    final Intent intent = getActivity().getIntent();
    Assert.notNull(intent);
    mSubId = (intent != null) ? intent.getIntExtra(UIIntents.UI_INTENT_EXTRA_SUB_ID, ParticipantData.DEFAULT_SELF_SUB_ID) : ParticipantData.DEFAULT_SELF_SUB_ID;
    final BuglePrefs subPrefs = Factory.get().getSubscriptionPrefs(mSubId);
    getPreferenceManager().setSharedPreferencesName(subPrefs.getSharedPreferencesName());
    addPreferencesFromResource(R.xml.preferences_per_subscription);
    mPhoneNumberKey = getString(R.string.mms_phone_number_pref_key);
    mPhoneNumberPreference = (PhoneNumberPreference) findPreference(mPhoneNumberKey);
    final PreferenceCategory advancedCategory = (PreferenceCategory) findPreference(getString(R.string.advanced_category_pref_key));
    final PreferenceCategory mmsCategory = (PreferenceCategory) findPreference(getString(R.string.mms_messaging_category_pref_key));
    mPhoneNumberPreference.setDefaultPhoneNumber(PhoneUtils.get(mSubId).getCanonicalForSelf(false), mSubId);
    mGroupMmsPrefKey = getString(R.string.group_mms_pref_key);
    mGroupMmsPreference = findPreference(mGroupMmsPrefKey);
    if (!MmsConfig.get(mSubId).getGroupMmsEnabled()) {
        // Always show group messaging setting even if the SIM has no number
        // If broadcast sms is selected, the SIM number is not needed
        // If group mms is selected, the phone number dialog will popup when message
        // is being sent, making sure we will have a self number for group mms.
        mmsCategory.removePreference(mGroupMmsPreference);
    } else {
        mGroupMmsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference pref) {
                GroupMmsSettingDialog.showDialog(getActivity(), mSubId);
                return true;
            }
        });
        updateGroupMmsPrefSummary();
    }
    if (!MmsConfig.get(mSubId).getSMSDeliveryReportsEnabled()) {
        final Preference deliveryReportsPref = findPreference(getString(R.string.delivery_reports_pref_key));
        mmsCategory.removePreference(deliveryReportsPref);
    }
    final Preference wirelessAlertPref = findPreference(getString(R.string.wireless_alerts_key));
    if (!isCellBroadcastAppLinkEnabled()) {
        advancedCategory.removePreference(wirelessAlertPref);
    } else {
        wirelessAlertPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(final Preference preference) {
                try {
                    startActivity(UIIntents.get().getWirelessAlertsIntent());
                } catch (final ActivityNotFoundException e) {
                    // Handle so we shouldn't crash if the wireless alerts
                    // implementation is broken.
                    LogUtil.e(LogUtil.BUGLE_TAG, "Failed to launch wireless alerts activity", e);
                }
                return true;
            }
        });
    }
    // Access Point Names (APNs)
    final Preference apnsPref = findPreference(getString(R.string.sms_apns_key));
    if (MmsUtils.useSystemApnTable() && !ApnDatabase.doesDatabaseExist()) {
        // Don't remove the ability to edit the local APN prefs if this device lets us
        // access the system APN, but we can't find the MCC/MNC in the APN table and we
        // created the local APN table in case the MCC/MNC was in there. In other words,
        // if the local APN table exists, let the user edit it.
        advancedCategory.removePreference(apnsPref);
    } else {
        final PreferenceScreen apnsScreen = (PreferenceScreen) findPreference(getString(R.string.sms_apns_key));
        apnsScreen.setIntent(UIIntents.get().getApnSettingsIntent(getPreferenceScreen().getContext(), mSubId));
    }
    // above first so that the user sees the correct information on the screen
    if (!PhoneUtils.getDefault().isDefaultSmsApp()) {
        mGroupMmsPreference.setEnabled(false);
        final Preference autoRetrieveMmsPreference = findPreference(getString(R.string.auto_retrieve_mms_pref_key));
        autoRetrieveMmsPreference.setEnabled(false);
        final Preference deliveryReportsPreference = findPreference(getString(R.string.delivery_reports_pref_key));
        deliveryReportsPreference.setEnabled(false);
    }
    mMmsExpiryPref = (ListPreference) findPreference(getString(R.string.pref_key_mms_expiry));
    mMmsExpiryCard1Pref = (ListPreference) findPreference(getString(R.string.pref_key_mms_expiry_slot1));
    mMmsExpiryCard2Pref = (ListPreference) findPreference(getString(R.string.pref_key_mms_expiry_slot2));
    if (PhoneUtils.getDefault().isMultiSimEnabledMms()) {
        mmsCategory.removePreference(mMmsExpiryPref);
    } else {
        mmsCategory.removePreference(mMmsExpiryCard1Pref);
        mmsCategory.removePreference(mMmsExpiryCard2Pref);
    }
}
#method_after
@Override
public void onCreate(final Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Get sub id from launch intent
    final Intent intent = getActivity().getIntent();
    Assert.notNull(intent);
    mSubId = (intent != null) ? intent.getIntExtra(UIIntents.UI_INTENT_EXTRA_SUB_ID, ParticipantData.DEFAULT_SELF_SUB_ID) : ParticipantData.DEFAULT_SELF_SUB_ID;
    final BuglePrefs subPrefs = Factory.get().getSubscriptionPrefs(mSubId);
    getPreferenceManager().setSharedPreferencesName(subPrefs.getSharedPreferencesName());
    addPreferencesFromResource(R.xml.preferences_per_subscription);
    mPhoneNumberKey = getString(R.string.mms_phone_number_pref_key);
    mPhoneNumberPreference = (PhoneNumberPreference) findPreference(mPhoneNumberKey);
    final PreferenceCategory advancedCategory = (PreferenceCategory) findPreference(getString(R.string.advanced_category_pref_key));
    final PreferenceCategory mmsCategory = (PreferenceCategory) findPreference(getString(R.string.mms_messaging_category_pref_key));
    mPhoneNumberPreference.setDefaultPhoneNumber(PhoneUtils.get(mSubId).getCanonicalForSelf(false), mSubId);
    mGroupMmsPrefKey = getString(R.string.group_mms_pref_key);
    mGroupMmsPreference = findPreference(mGroupMmsPrefKey);
    if (!MmsConfig.get(mSubId).getGroupMmsEnabled()) {
        // Always show group messaging setting even if the SIM has no number
        // If broadcast sms is selected, the SIM number is not needed
        // If group mms is selected, the phone number dialog will popup when message
        // is being sent, making sure we will have a self number for group mms.
        mmsCategory.removePreference(mGroupMmsPreference);
    } else {
        mGroupMmsPreference.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference pref) {
                GroupMmsSettingDialog.showDialog(getActivity(), mSubId);
                return true;
            }
        });
        updateGroupMmsPrefSummary();
    }
    if (!MmsConfig.get(mSubId).getSMSDeliveryReportsEnabled()) {
        final Preference deliveryReportsPref = findPreference(getString(R.string.delivery_reports_pref_key));
        mmsCategory.removePreference(deliveryReportsPref);
    }
    final Preference wirelessAlertPref = findPreference(getString(R.string.wireless_alerts_key));
    if (!isCellBroadcastAppLinkEnabled()) {
        advancedCategory.removePreference(wirelessAlertPref);
    } else {
        wirelessAlertPref.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(final Preference preference) {
                try {
                    startActivity(UIIntents.get().getWirelessAlertsIntent());
                } catch (final ActivityNotFoundException e) {
                    // Handle so we shouldn't crash if the wireless alerts
                    // implementation is broken.
                    LogUtil.e(LogUtil.BUGLE_TAG, "Failed to launch wireless alerts activity", e);
                }
                return true;
            }
        });
    }
    // Access Point Names (APNs)
    final Preference apnsPref = findPreference(getString(R.string.sms_apns_key));
    if (MmsUtils.useSystemApnTable() && !ApnDatabase.doesDatabaseExist()) {
        // Don't remove the ability to edit the local APN prefs if this device lets us
        // access the system APN, but we can't find the MCC/MNC in the APN table and we
        // created the local APN table in case the MCC/MNC was in there. In other words,
        // if the local APN table exists, let the user edit it.
        advancedCategory.removePreference(apnsPref);
    } else {
        final PreferenceScreen apnsScreen = (PreferenceScreen) findPreference(getString(R.string.sms_apns_key));
        apnsScreen.setIntent(UIIntents.get().getApnSettingsIntent(getPreferenceScreen().getContext(), mSubId));
    }
    // above first so that the user sees the correct information on the screen
    if (!PhoneUtils.getDefault().isDefaultSmsApp()) {
        mGroupMmsPreference.setEnabled(false);
        final Preference autoRetrieveMmsPreference = findPreference(getString(R.string.auto_retrieve_mms_pref_key));
        autoRetrieveMmsPreference.setEnabled(false);
        final Preference deliveryReportsPreference = findPreference(getString(R.string.delivery_reports_pref_key));
        deliveryReportsPreference.setEnabled(false);
    }
    mMmsExpiryPref = (ListPreference) findPreference(getString(R.string.expiry_mms_pref_key));
    mMmsExpiryCard1Pref = (ListPreference) findPreference(getString(R.string.expiry_slot1_mms_pref_key));
    mMmsExpiryCard2Pref = (ListPreference) findPreference(getString(R.string.expiry_slot2_mms_pref_key));
    if (PhoneUtils.getDefault().isMultiSimEnabledMms()) {
        mmsCategory.removePreference(mMmsExpiryPref);
    } else {
        mmsCategory.removePreference(mMmsExpiryCard1Pref);
        mmsCategory.removePreference(mMmsExpiryCard2Pref);
    }
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, final Uri uri) {
    // depending on the Thread in which the handler was created, this function
    // may or may not run on the UI thread, to be sure that it doesn't, launch
    // it via AsyncTask
    new SafeAsyncTask<Void, Void, Void>() {

        @Override
        protected Void doInBackgroundTimed(Void... params) {
            if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
                Log.i(TAG, "BlacklistObserver: onChange: Uri:" + uri.toString());
            }
            // we need to find the phone number being blacklisted and add/update it
            // in the bugle database
            Cursor cursor = null;
            try {
                cursor = mResolver.query(uri, null, null, null, null);
                int normalizedNumberIndex = cursor.getColumnIndex("normalized_number");
                int blockedIndex = cursor.getColumnIndex("message");
                // if the column indices are not valid, don't perform the queries
                if (normalizedNumberIndex < 0 || blockedIndex < 0) {
                    if (cursor != null) {
                        cursor.close();
                    }
                    return null;
                }
                DatabaseWrapper db = DataModel.get().getDatabase();
                while (cursor.moveToNext()) {
                    String number = cursor.getString(normalizedNumberIndex);
                    String blocked = cursor.getString(blockedIndex);
                    boolean isBlocked = blocked.compareTo("1") == 0;
                    // don't update the framework db - the 'false' argument
                    int updateCount = BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
                    String orgNumber = cursor.getString(cursor.getColumnIndex("number"));
                    BlackListUtils.putDeNormalizedNumber(number, orgNumber);
                    if (updateCount == 0) {
                        // there was no phone number in the local participants database that was
                        // blacklisted in the framework blacklist database,
                        // create a new participant
                        // and insert him into the local participants database
                        ParticipantData participant = ParticipantData.getFromRawPhoneBySystemLocale(number);
                        BugleDatabaseOperations.getOrCreateParticipantInTransaction(db, participant);
                        BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
                    }
                    String conversationId = BugleDatabaseOperations.getConversationFromOtherParticipantDestination(db, number);
                    if (conversationId != null) {
                        if (isBlocked) {
                            UpdateConversationArchiveStatusAction.archiveConversation(conversationId);
                        } else {
                            UpdateConversationArchiveStatusAction.unarchiveConversation(conversationId);
                        }
                        MessagingContentProvider.notifyParticipantsChanged(conversationId);
                    }
                }
            } catch (Exception e) {
                Log.e(TAG, "BlacklistObserver: onChange: " + e.getMessage());
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
            return null;
        }
    }.executeOnThreadPool();
}
#method_after
@Override
public void onChange(boolean selfChange, final Uri uri) {
    // depending on the Thread in which the handler was created, this function
    // may or may not run on the UI thread, to be sure that it doesn't, launch
    // it via AsyncTask
    new SafeAsyncTask<Void, Void, Void>() {

        @Override
        protected Void doInBackgroundTimed(Void... params) {
            if (LogUtil.isLoggable(TAG, LogUtil.VERBOSE)) {
                Log.i(TAG, "BlacklistObserver: onChange: Uri:" + uri.toString());
            }
            // we need to find the phone number being blacklisted and add/update it
            // in the bugle database
            Cursor cursor = null;
            try {
                cursor = mResolver.query(uri, null, null, null, null);
                int normalizedNumberIndex = cursor.getColumnIndex("normalized_number");
                int blockedIndex = cursor.getColumnIndex("message");
                int nonNormalizedNumberIndex = cursor.getColumnIndex("number");
                int regexIndex = cursor.getColumnIndex("is_regex");
                // if the column indices are not valid, don't perform the queries
                if (normalizedNumberIndex < 0 || blockedIndex < 0) {
                    if (cursor != null) {
                        cursor.close();
                    }
                    return null;
                }
                DatabaseWrapper db = DataModel.get().getDatabase();
                while (cursor.moveToNext()) {
                    String number = cursor.getString(normalizedNumberIndex);
                    String blocked = cursor.getString(blockedIndex);
                    boolean isBlocked = blocked.compareTo("1") == 0;
                    String formattedNumber = cursor.getInt(regexIndex) != 0 ? cursor.getString(nonNormalizedNumberIndex) : null;
                    // don't update the framework db - the 'false' argument
                    int updateCount = BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
                    if (updateCount == 0) {
                        // there was no phone number in the local participants database that was
                        // blacklisted in the framework blacklist database,
                        // create a new participant
                        // and insert him into the local participants database
                        ParticipantData participant = ParticipantData.getFromRawPhoneBySystemLocale(number, formattedNumber);
                        BugleDatabaseOperations.getOrCreateParticipantInTransaction(db, participant);
                        BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
                    }
                    String conversationId = BugleDatabaseOperations.getConversationFromOtherParticipantDestination(db, number);
                    if (conversationId != null) {
                        if (isBlocked) {
                            UpdateConversationArchiveStatusAction.archiveConversation(conversationId);
                        } else {
                            UpdateConversationArchiveStatusAction.unarchiveConversation(conversationId);
                        }
                        MessagingContentProvider.notifyParticipantsChanged(conversationId);
                    }
                }
            } catch (Exception e) {
                Log.e(TAG, "BlacklistObserver: onChange: " + e.getMessage());
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
            return null;
        }
    }.executeOnThreadPool();
}
#end_block

#method_before
@Override
protected Void doInBackground(Void... params) {
    // TODO - need to extract URI from TelephonyProvider
    Uri CONTENT_URI = Uri.parse("content://blacklist");
    Cursor cursor;
    // need to update local blacklist database - we are simply overwriting the
    // local database with the framework database - the local database is used
    // as a WriteThrough Cache of the Framework Database
    cursor = mContext.getContentResolver().query(CONTENT_URI, null, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
        int normalizedNumberIndex = cursor.getColumnIndex("normalized_number");
        int blockedIndex = cursor.getColumnIndex("message");
        int updateCount;
        if (normalizedNumberIndex < 0 || blockedIndex < 0) {
            cursor.close();
            return null;
        }
        DatabaseWrapper db = DataModel.get().getDatabase();
        while (cursor.moveToNext()) {
            String number = cursor.getString(normalizedNumberIndex);
            String blocked = cursor.getString(blockedIndex);
            boolean isBlocked = blocked.compareTo("1") == 0;
            updateCount = BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
            String orgNumber = cursor.getString(cursor.getColumnIndex("number"));
            BlackListUtils.putDeNormalizedNumber(number, orgNumber);
            if (updateCount == 0) {
                // there was no phone number in the local participants database that was
                // blacklisted in the framework blacklist database, create a new participant
                // and insert him into the local participants database
                db.beginTransaction();
                try {
                    ParticipantData participant = ParticipantData.getFromRawPhoneBySystemLocale(number);
                    BugleDatabaseOperations.getOrCreateParticipantInTransaction(db, participant);
                    BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
        }
    }
    if (cursor != null) {
        cursor.close();
    }
    return null;
}
#method_after
@Override
protected Void doInBackground(Void... params) {
    // TODO - need to extract URI from TelephonyProvider
    Uri CONTENT_URI = Uri.parse("content://blacklist");
    Cursor cursor;
    // need to update local blacklist database - we are simply overwriting the
    // local database with the framework database - the local database is used
    // as a WriteThrough Cache of the Framework Database
    cursor = mContext.getContentResolver().query(CONTENT_URI, null, null, null, null);
    if (cursor != null && cursor.getCount() > 0) {
        int normalizedNumberIndex = cursor.getColumnIndex("normalized_number");
        int blockedIndex = cursor.getColumnIndex("message");
        int nonNormalizedNumberIndex = cursor.getColumnIndex("number");
        int regexIndex = cursor.getColumnIndex("is_regex");
        int updateCount;
        if (normalizedNumberIndex < 0 || blockedIndex < 0) {
            cursor.close();
            return null;
        }
        DatabaseWrapper db = DataModel.get().getDatabase();
        while (cursor.moveToNext()) {
            String number = cursor.getString(normalizedNumberIndex);
            String blocked = cursor.getString(blockedIndex);
            boolean isBlocked = blocked.compareTo("1") == 0;
            String formattedNumber = cursor.getInt(regexIndex) != 0 ? cursor.getString(nonNormalizedNumberIndex) : null;
            updateCount = BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
            if (updateCount == 0) {
                // there was no phone number in the local participants database that was
                // blacklisted in the framework blacklist database, create a new participant
                // and insert him into the local participants database
                db.beginTransaction();
                try {
                    ParticipantData participant = ParticipantData.getFromRawPhoneBySystemLocale(number, formattedNumber);
                    BugleDatabaseOperations.getOrCreateParticipantInTransaction(db, participant);
                    BugleDatabaseOperations.updateDestination(db, number, isBlocked, false);
                    db.setTransactionSuccessful();
                } finally {
                    db.endTransaction();
                }
            }
        }
    }
    if (cursor != null) {
        cursor.close();
    }
    return null;
}
#end_block

#method_before
@Override
public void onLoaderReset(final Loader<Cursor> loader) {
    final BoundCursorLoader cursorLoader = (BoundCursorLoader) loader;
    if (isBound(cursorLoader.getBindingId())) {
        switch(loader.getId()) {
            case GALLERY_IMAGE_LOADER:
                Log.v(TAG, "GK: onLoaderReset: Image");
                mImageListener.onMediaPickerDataUpdated(MediaPickerData.this, null, GALLERY_IMAGE_LOADER);
                break;
            case GALLERY_AUDIO_LOADER:
                Log.v(TAG, "GK: onLoaderReset: Audio");
                mAudioListener.onMediaPickerDataUpdated(MediaPickerData.this, null, GALLERY_AUDIO_LOADER);
                break;
            default:
                Assert.fail("Unknown loader id for media picker!");
                break;
        }
    } else {
        LogUtil.w(LogUtil.BUGLE_TAG, "Loader reset after unbinding the media picker");
    }
}
#method_after
@Override
public void onLoaderReset(final Loader<Cursor> loader) {
    final BoundCursorLoader cursorLoader = (BoundCursorLoader) loader;
    if (isBound(cursorLoader.getBindingId())) {
        switch(loader.getId()) {
            case GALLERY_IMAGE_LOADER:
                mImageListener.onMediaPickerDataUpdated(MediaPickerData.this, null, GALLERY_IMAGE_LOADER);
                break;
            case GALLERY_AUDIO_LOADER:
                mAudioListener.onMediaPickerDataUpdated(MediaPickerData.this, null, GALLERY_AUDIO_LOADER);
                break;
            default:
                Assert.fail("Unknown loader id for media picker!");
                break;
        }
    } else {
        LogUtil.w(LogUtil.BUGLE_TAG, "Loader reset after unbinding the media picker");
    }
}
#end_block

#method_before
public String getAudioFilename() {
    return mAudioUri.getLastPathSegment();
}
#method_after
public String getAudioFilename() {
    if (mAudioUri != null) {
        return mAudioUri.getLastPathSegment();
    } else {
        return "";
    }
}
#end_block

#method_before
@Override
public int getIconResource() {
    return R.drawable.ic_library_music_white_24dp;
}
#method_after
@Override
public int getIconResource() {
    return R.drawable.ic_library_music_white_24px;
}
#end_block

#method_before
private boolean checkSize() {
    // only perform the check for videos, since they are not being compressed
    // images will be compressed, so exclude them from this check
    // determine the maximum message size, this will be computed only once per this class
    Log.v(TAG, "GK: Setting MaxMessageSize:" + mMaxMessageSize);
    if (mMaxMessageSize == 0) {
        int subId = mHostInterface.getSubscriptionProviderSubId();
        mMaxMessageSize = MmsConfig.get(subId).getMaxMessageSize();
        Log.v(TAG, "GK: Setting MaxMessageSize:" + mMaxMessageSize);
    }
    long contentSize = UriUtil.getContentSize(mData.getImageUri());
    if (mHostInterface.isMultiSelectEnabled()) {
        if (mData.isVideoItem()) {
            if (mHostInterface.isItemSelected(mData)) {
                // un-selecting
                mTotalContentSize -= contentSize;
                if (mTotalContentSize < 0) {
                    mTotalContentSize = 0;
                }
            } else {
                // selecting
                mTotalContentSize += contentSize;
            }
        }
    } else {
        // short click or first long click
        if (mData.isVideoItem()) {
            mTotalContentSize = contentSize;
        } else {
            mTotalContentSize = 0;
        }
    }
    Log.v(TAG, "GK: TotalContentSize:" + mTotalContentSize + " MaxMessageSize:" + mMaxMessageSize);
    if (mTotalContentSize > mMaxMessageSize) {
        mTotalContentSize -= contentSize;
        if (mTotalContentSize < 0) {
            mTotalContentSize = 0;
        }
        Log.v(TAG, "GK: " + getContext().getString(R.string.mediapicker_gallery_image_item_attachment_too_large));
        Toast.makeText(getContext(), getContext().getString(R.string.mediapicker_gallery_image_item_attachment_too_large), Toast.LENGTH_LONG).show();
        return false;
    }
    return true;
}
#method_after
private boolean checkSize() {
    if (mData.isDocumentPickerItem()) {
        return true;
    }
    // determine the maximum message size, this will be computed only once per this class
    if (mMaxMessageSize == 0) {
        int subId = mHostInterface.getSubscriptionProviderSubId();
        mMaxMessageSize = MmsConfig.get(subId).getMaxMessageSize();
    }
    long contentSize = mData.getContentSize();
    if (mHostInterface.isMultiSelectEnabled()) {
        if (mData.isVideoItem()) {
            if (mHostInterface.isItemSelected(mData)) {
                // un-selecting
                mTotalContentSize -= contentSize;
                if (mTotalContentSize < 0) {
                    mTotalContentSize = 0;
                }
            } else {
                // selecting
                mTotalContentSize += contentSize;
            }
        }
    } else {
        // short click or first long click
        if (mData.isVideoItem()) {
            mTotalContentSize = contentSize;
        } else {
            mTotalContentSize = 0;
        }
    }
    if (mTotalContentSize > mMaxMessageSize) {
        mTotalContentSize -= contentSize;
        if (mTotalContentSize < 0) {
            mTotalContentSize = 0;
        }
        Toast.makeText(getContext(), getContext().getString(R.string.mediapicker_gallery_image_item_attachment_too_large), Toast.LENGTH_LONG).show();
        return false;
    }
    return true;
}
#end_block

#method_before
public void bind(final Cursor cursor, final int desiredWidth, final int desiredHeight) {
    mIsDocumentPickerItem = TextUtils.equals(cursor.getString(INDEX_ID), ID_DOCUMENT_PICKER_ITEM);
    if (mIsDocumentPickerItem) {
        mImageData = null;
        mContentType = null;
    } else {
        String mimeType = (cursor.getString(INDEX_MIME_TYPE));
        mIsVideoItem = (mimeType != null && mimeType.toLowerCase().contains("video/"));
        int sourceWidth = cursor.getInt(INDEX_WIDTH);
        int sourceHeight = cursor.getInt(INDEX_HEIGHT);
        // Guard against bad data
        if (sourceWidth <= 0) {
            sourceWidth = ImageRequest.UNSPECIFIED_SIZE;
        }
        if (sourceHeight <= 0) {
            sourceHeight = ImageRequest.UNSPECIFIED_SIZE;
        }
        mContentType = cursor.getString(INDEX_MIME_TYPE);
        final String dateModified = cursor.getString(INDEX_DATE_MODIFIED);
        mDateSeconds = !TextUtils.isEmpty(dateModified) ? Long.parseLong(dateModified) : -1;
        if (mIsVideoItem) {
            mImageData = new VideoThumbnailRequestDescriptor(cursor.getLong(INDEX_ID), cursor.getString(INDEX_DATA_PATH), desiredWidth, desiredHeight, sourceWidth, sourceHeight);
        } else {
            mImageData = new FileImageRequestDescriptor(cursor.getString(INDEX_DATA_PATH), desiredWidth, desiredHeight, sourceWidth, sourceHeight, true, /* canUseThumbnail */
            true, /* allowCompression */
            true);
        }
    }
}
#method_after
public void bind(final Cursor cursor, final int desiredWidth, final int desiredHeight) {
    mIsDocumentPickerItem = TextUtils.equals(cursor.getString(INDEX_ID), ID_DOCUMENT_PICKER_ITEM);
    if (mIsDocumentPickerItem) {
        mImageData = null;
        mContentType = null;
    } else {
        String mimeType = (cursor.getString(INDEX_MIME_TYPE));
        mIsVideoItem = (mimeType != null && mimeType.toLowerCase().contains("video/"));
        int sourceWidth = cursor.getInt(INDEX_WIDTH);
        int sourceHeight = cursor.getInt(INDEX_HEIGHT);
        // Guard against bad data
        if (sourceWidth <= 0) {
            sourceWidth = ImageRequest.UNSPECIFIED_SIZE;
        }
        if (sourceHeight <= 0) {
            sourceHeight = ImageRequest.UNSPECIFIED_SIZE;
        }
        mContentType = cursor.getString(INDEX_MIME_TYPE);
        final String dateModified = cursor.getString(INDEX_DATE_MODIFIED);
        mDateSeconds = !TextUtils.isEmpty(dateModified) ? Long.parseLong(dateModified) : -1;
        if (mIsVideoItem) {
            mImageData = new VideoThumbnailRequestDescriptor(cursor.getLong(INDEX_ID), cursor.getString(INDEX_DATA_PATH), desiredWidth, desiredHeight, sourceWidth, sourceHeight);
        } else {
            mImageData = new FileImageRequestDescriptor(cursor.getString(INDEX_DATA_PATH), desiredWidth, desiredHeight, sourceWidth, sourceHeight, true, /* canUseThumbnail */
            true, /* allowCompression */
            true);
        }
        // TODO - at selection time
        if (mIsVideoItem) {
            new AsyncTask<Void, Void, Long>() {

                @Override
                protected Long doInBackground(Void... params) {
                    Long size = UriUtil.getContentSize(getImageUri());
                    return size;
                }

                @Override
                protected void onPostExecute(Long result) {
                    mContentSize = result;
                }
            }.execute();
        }
    }
}
#end_block

#method_before
public static boolean useMetricUnits(Context context) {
    if (getPrefs(context).contains(Constants.WEATHER_USE_METRIC)) {
        return getPrefs(context).getBoolean(Constants.WEATHER_USE_METRIC, true);
    } else {
        Locale locale = context.getResources().getConfiguration().locale;
        return !locale.equals(Locale.US) || // Malaysia
        !locale.equals("ms_MY") || // Sri Lanka
        !locale.equals("si_LK");
    }
}
#method_after
public static boolean useMetricUnits(Context context) {
    Locale locale = context.getResources().getConfiguration().locale;
    boolean defValue = !(locale.equals(Locale.US) || // Malaysia
    locale.toString().equals("ms_MY") || // Sri Lanka
    locale.toString().equals("si_LK"));
    return getPrefs(context).getBoolean(Constants.WEATHER_USE_METRIC, defValue);
}
#end_block

#method_before
@Override
public void onCreate() {
    mWorkerThread = new WorkerThread(this);
    mWorkerThread.start();
    mWorkerThread.prepareHandler();
    mHandler = new Handler(Looper.getMainLooper());
}
#method_after
@Override
public void onCreate() {
    Log.d(TAG, "onCreate");
    mWorkerThread = new WorkerThread(getApplicationContext());
    mWorkerThread.start();
    mWorkerThread.prepareHandler();
    mHandler = new Handler(Looper.getMainLooper());
}
#end_block

#method_before
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (D)
        Log.v(TAG, "Got intent " + intent);
    if (ACTION_CANCEL_LOCATION_UPDATE.equals(intent.getAction())) {
        WeatherLocationListener.cancel(this);
        if (!mWorkerThread.isProcessing()) {
            stopSelf();
        }
        return START_NOT_STICKY;
    }
    if (ACTION_CANCEL_UPDATE_WEATHER_REQUEST.equals(intent.getAction())) {
        if (mWorkerThread.isProcessing()) {
            mWorkerThread.getHandler().obtainMessage(WorkerThread.MSG_CANCEL_UPDATE_WEATHER_REQUEST).sendToTarget();
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    final Context context = getApplicationContext();
                    final CMWeatherManager weatherManager = CMWeatherManager.getInstance(context);
                    final String activeProviderLabel = weatherManager.getActiveWeatherServiceProviderLabel();
                    final String noData = getString(R.string.weather_cannot_reach_provider, activeProviderLabel);
                    Toast.makeText(context, noData, Toast.LENGTH_SHORT).show();
                }
            });
        }
        return START_NOT_STICKY;
    }
    boolean force = ACTION_FORCE_UPDATE.equals(intent.getAction());
    if (!shouldUpdate(force)) {
        Log.d(TAG, "Service started, but shouldn't update ... stopping");
        sendCancelledBroadcast();
        stopSelf();
        return START_NOT_STICKY;
    }
    mWorkerThread.getHandler().obtainMessage(WorkerThread.MSG_ON_NEW_WEATHER_REQUEST).sendToTarget();
    return START_REDELIVER_INTENT;
}
#method_after
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (D)
        Log.v(TAG, "Got intent " + intent);
    if (ACTION_CANCEL_LOCATION_UPDATE.equals(intent.getAction())) {
        WeatherLocationListener.cancel(this);
        if (!mWorkerThread.isProcessing()) {
            stopSelf();
        }
        return START_NOT_STICKY;
    }
    if (ACTION_CANCEL_UPDATE_WEATHER_REQUEST.equals(intent.getAction())) {
        if (mWorkerThread.isProcessing()) {
            mWorkerThread.getHandler().obtainMessage(WorkerThread.MSG_CANCEL_UPDATE_WEATHER_REQUEST).sendToTarget();
            mHandler.post(new Runnable() {

                @Override
                public void run() {
                    final Context context = getApplicationContext();
                    final CMWeatherManager weatherManager = CMWeatherManager.getInstance(context);
                    final String activeProviderLabel = weatherManager.getActiveWeatherServiceProviderLabel();
                    final String noData = getString(R.string.weather_cannot_reach_provider, activeProviderLabel);
                    Toast.makeText(context, noData, Toast.LENGTH_SHORT).show();
                }
            });
        }
        stopSelf();
        return START_NOT_STICKY;
    }
    boolean force = ACTION_FORCE_UPDATE.equals(intent.getAction());
    if (!shouldUpdate(force)) {
        Log.d(TAG, "Service started, but shouldn't update ... stopping");
        sendCancelledBroadcast();
        stopSelf();
        return START_NOT_STICKY;
    }
    mWorkerThread.getHandler().obtainMessage(WorkerThread.MSG_ON_NEW_WEATHER_REQUEST).sendToTarget();
    return START_REDELIVER_INTENT;
}
#end_block

#method_before
private boolean shouldUpdate(boolean force) {
    long interval = Preferences.weatherRefreshIntervalInMs(this);
    if (interval == 0 && !force) {
        if (D)
            Log.v(TAG, "Interval set to manual and update not forced, skip");
        return false;
    }
    if (!WeatherPreferences.hasLocationPermission(this)) {
        if (D)
            Log.v(TAG, "Application does not have the location permission, skip");
        return false;
    }
    if (WidgetUtils.isNetworkAvailable(this)) {
        if (force) {
            Preferences.setCachedWeatherInfo(this, 0, null);
            return true;
        } else {
            final long now = SystemClock.elapsedRealtime();
            final long lastUpdate = Preferences.lastWeatherUpdateTimestamp(this);
            final long due = lastUpdate + interval;
            if (D)
                Log.d(TAG, "Now " + now + " Last update " + lastUpdate + " Due in " + (due - now) + " ms");
            if (lastUpdate != 0 && now < due) {
                if (D)
                    Log.v(TAG, "Next weather update due in " + (due - now) + " ms, skip");
                return false;
            } else {
                return true;
            }
        }
    } else {
        if (D)
            Log.d(TAG, "Network is not available, skip");
        return false;
    }
}
#method_after
private boolean shouldUpdate(boolean force) {
    final CMWeatherManager weatherManager = CMWeatherManager.getInstance(getApplicationContext());
    if (weatherManager.getActiveWeatherServiceProviderLabel() == null) {
        // Why bother if we don't even have an active provider
        if (D)
            Log.d(TAG, "No active weather service provider found, skip");
        return false;
    }
    final long interval = Preferences.weatherRefreshIntervalInMs(this);
    if (interval == 0 && !force) {
        if (D)
            Log.v(TAG, "Interval set to manual and update not forced, skip");
        return false;
    }
    if (!WeatherPreferences.hasLocationPermission(this)) {
        if (D)
            Log.v(TAG, "Application does not have the location permission, skip");
        return false;
    }
    if (WidgetUtils.isNetworkAvailable(this)) {
        if (force) {
            if (D)
                Log.d(TAG, "Forcing weather update");
            return true;
        } else {
            final long now = SystemClock.elapsedRealtime();
            final long lastUpdate = Preferences.lastWeatherUpdateTimestamp(this);
            final long due = lastUpdate + interval;
            if (D) {
                Log.d(TAG, "Now " + now + " Last update " + lastUpdate + " interval " + interval);
            }
            if (lastUpdate == 0 || due - now < 0) {
                if (D)
                    Log.d(TAG, "Should update");
                return true;
            } else {
                if (D)
                    Log.v(TAG, "Next weather update due in " + (due - now) + " ms, skip");
                return false;
            }
        }
    } else {
        if (D)
            Log.d(TAG, "Network is not available, skip");
        return false;
    }
}
#end_block

#method_before
public synchronized void prepareHandler() {
    mHandler = new Handler(getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            if (D)
                Log.d(TAG, "Msg " + msg.what);
            switch(msg.what) {
                case MSG_ON_NEW_WEATHER_REQUEST:
                    onNewWeatherRequest();
                    break;
                case MSG_ON_WEATHER_REQUEST_COMPLETED:
                    WeatherInfo info = (WeatherInfo) msg.obj;
                    onWeatherRequestCompleted(info);
                    break;
                case MSG_WEATHER_DATA_NOT_AVAILABLE:
                    onWeatherDataNotAvailable();
                    break;
                case MSG_CANCEL_UPDATE_WEATHER_REQUEST:
                    onCancelUpdateWeatherRequest();
                    break;
                default:
                    // Unknown message, pass it on...
                    super.handleMessage(msg);
            }
        }
    };
}
#method_after
public synchronized void prepareHandler() {
    mHandler = new Handler(getLooper()) {

        @Override
        public void handleMessage(Message msg) {
            if (D)
                Log.d(TAG, "Msg " + msg.what);
            switch(msg.what) {
                case MSG_ON_NEW_WEATHER_REQUEST:
                    onNewWeatherRequest();
                    break;
                case MSG_ON_WEATHER_REQUEST_COMPLETED:
                    WeatherInfo info = (WeatherInfo) msg.obj;
                    onWeatherRequestCompleted(info);
                    break;
                case MSG_WEATHER_REQUEST_FAILED:
                    int status = msg.arg1;
                    onWeatherRequestFailed(status);
                    break;
                case MSG_CANCEL_UPDATE_WEATHER_REQUEST:
                    onCancelUpdateWeatherRequest();
                    break;
                default:
                    // Unknown message, pass it on...
                    super.handleMessage(msg);
            }
        }
    };
}
#end_block

#method_before
private void onNewWeatherRequest() {
    if (mIsProcessingWeatherUpdate) {
        Log.d(TAG, "Already processing weather update, discarding request...");
        return;
    }
    mIsProcessingWeatherUpdate = true;
    final PowerManager pm = (PowerManager) mContext.getSystemService(POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    mWakeLock.setReferenceCounted(false);
    if (D)
        Log.v(TAG, "ACQUIRING WAKELOCK");
    mWakeLock.acquire();
    WeatherLocation customWeatherLocation = null;
    if (Preferences.useCustomWeatherLocation(mContext)) {
        customWeatherLocation = Preferences.getCustomWeatherLocation(mContext);
    }
    if (customWeatherLocation != null) {
        mRequestId = mWeatherManager.requestWeatherUpdate(customWeatherLocation, mWeakWeatherUpdateServiceRef.get());
        if (D)
            Log.d(TAG, "Request submitted using WeatherLocation");
        startTimeoutAlarm();
    } else {
        final Location location = getCurrentLocation();
        if (location != null) {
            mRequestId = mWeatherManager.requestWeatherUpdate(location, mWeakWeatherUpdateServiceRef.get());
            if (D)
                Log.d(TAG, "Request submitted using Location");
            startTimeoutAlarm();
        } else {
            // work with cached location from last request for now
            // a listener to update it is already scheduled if possible
            WeatherInfo cachedInfo = Preferences.getCachedWeatherInfo(mContext);
            if (cachedInfo != null) {
                mHandler.obtainMessage(MSG_ON_WEATHER_REQUEST_COMPLETED, cachedInfo).sendToTarget();
                if (D)
                    Log.d(TAG, "Returning cached weather data [ " + cachedInfo.toString() + " ]");
            } else {
                mHandler.obtainMessage(MSG_WEATHER_DATA_NOT_AVAILABLE).sendToTarget();
            }
        }
    }
}
#method_after
private void onNewWeatherRequest() {
    if (mIsProcessingWeatherUpdate) {
        Log.d(TAG, "Already processing weather update, discarding request...");
        return;
    }
    mIsProcessingWeatherUpdate = true;
    final PowerManager pm = (PowerManager) mContext.getSystemService(POWER_SERVICE);
    mWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
    mWakeLock.setReferenceCounted(false);
    if (D)
        Log.v(TAG, "ACQUIRING WAKELOCK");
    mWakeLock.acquire();
    WeatherLocation customWeatherLocation = null;
    if (Preferences.useCustomWeatherLocation(mContext)) {
        customWeatherLocation = Preferences.getCustomWeatherLocation(mContext);
    }
    if (customWeatherLocation != null) {
        mRequestId = mWeatherManager.requestWeatherUpdate(customWeatherLocation, this);
        if (D)
            Log.d(TAG, "Request submitted using WeatherLocation");
        startTimeoutAlarm();
    } else {
        final Location location = getCurrentLocation();
        if (location != null) {
            mRequestId = mWeatherManager.requestWeatherUpdate(location, this);
            if (D)
                Log.d(TAG, "Request submitted using Location");
            startTimeoutAlarm();
        } else {
            // work with cached location from last request for now
            // a listener to update it is already scheduled if possible
            WeatherInfo cachedInfo = Preferences.getCachedWeatherInfo(mContext);
            if (cachedInfo != null) {
                mHandler.obtainMessage(MSG_ON_WEATHER_REQUEST_COMPLETED, cachedInfo).sendToTarget();
                if (D)
                    Log.d(TAG, "Returning cached weather data [ " + cachedInfo.toString() + " ]");
            } else {
                mHandler.obtainMessage(MSG_WEATHER_REQUEST_FAILED).sendToTarget();
            }
        }
    }
}
#end_block

#method_before
public void tearDown() {
    if (isProcessing())
        mWeatherManager.cancelRequest(mRequestId);
    mWeakWeatherUpdateServiceRef.clear();
    quitSafely();
}
#method_after
public void tearDown() {
    if (D)
        Log.d(TAG, "Tearing down worker thread");
    if (isProcessing())
        mWeatherManager.cancelRequest(mRequestId);
    quit();
}
#end_block

#method_before
private void onWeatherRequestCompleted(WeatherInfo result) {
    if (D)
        Log.d(TAG, "Weather update received, caching data and updating widget");
    cancelTimeoutAlarm();
    long now = SystemClock.elapsedRealtime();
    Preferences.setCachedWeatherInfo(mContext, now, result);
    scheduleUpdate(mContext, Preferences.weatherRefreshIntervalInMs(mContext), false);
    Intent updateIntent = new Intent(mContext, ClockWidgetProvider.class);
    mWeakWeatherUpdateServiceRef.get().sendBroadcast(updateIntent);
    broadcastAndCleanUp(false);
}
#method_after
private void onWeatherRequestCompleted(WeatherInfo result) {
    if (D)
        Log.d(TAG, "Weather update received, caching data and updating widget");
    cancelTimeoutAlarm();
    long now = SystemClock.elapsedRealtime();
    Preferences.setCachedWeatherInfo(mContext, now, result);
    scheduleUpdate(mContext, Preferences.weatherRefreshIntervalInMs(mContext), false);
    Intent updateIntent = new Intent(mContext, ClockWidgetProvider.class);
    mContext.sendBroadcast(updateIntent);
    broadcastAndCleanUp(false);
}
#end_block

#method_before
private void broadcastAndCleanUp(boolean updateCancelled) {
    Intent finishedIntent = new Intent(ACTION_UPDATE_FINISHED);
    finishedIntent.putExtra(EXTRA_UPDATE_CANCELLED, updateCancelled);
    mWeakWeatherUpdateServiceRef.get().sendBroadcast(finishedIntent);
    if (D)
        Log.d(TAG, "RELEASING WAKELOCK");
    mWakeLock.release();
    mIsProcessingWeatherUpdate = false;
    mWeakWeatherUpdateServiceRef.get().stopSelf();
}
#method_after
private void broadcastAndCleanUp(boolean updateCancelled) {
    Intent finishedIntent = new Intent(ACTION_UPDATE_FINISHED);
    finishedIntent.putExtra(EXTRA_UPDATE_CANCELLED, updateCancelled);
    mContext.sendBroadcast(finishedIntent);
    if (D)
        Log.d(TAG, "RELEASING WAKELOCK");
    mWakeLock.release();
    mIsProcessingWeatherUpdate = false;
    mContext.stopService(new Intent(mContext, WeatherUpdateService.class));
}
#end_block

#method_before
private void onWeatherRequestCompleted(WeatherInfo result) {
    if (D)
        Log.d(TAG, "Weather update received, caching data and updating widget");
    cancelTimeoutAlarm();
    long now = SystemClock.elapsedRealtime();
    Preferences.setCachedWeatherInfo(mContext, now, result);
    scheduleUpdate(mContext, Preferences.weatherRefreshIntervalInMs(mContext), false);
    Intent updateIntent = new Intent(mContext, ClockWidgetProvider.class);
    mWeakWeatherUpdateServiceRef.get().sendBroadcast(updateIntent);
    broadcastAndCleanUp(false);
}
#method_after
@Override
public void onWeatherRequestCompleted(int state, WeatherInfo weatherInfo) {
    if (state == CMWeatherManager.RequestStatus.COMPLETED) {
        mHandler.obtainMessage(WorkerThread.MSG_ON_WEATHER_REQUEST_COMPLETED, weatherInfo).sendToTarget();
    } else {
        mHandler.obtainMessage(WorkerThread.MSG_WEATHER_REQUEST_FAILED, state, 0).sendToTarget();
    }
}
#end_block

#method_before
@Override
public void onDestroy() {
    mWorkerThread.tearDown();
}
#method_after
@Override
public void onDestroy() {
    Log.d(TAG, "onDestroy");
    mWorkerThread.tearDown();
}
#end_block

#method_before
@Override
public void onLocationChanged(Location location) {
    // Now, we have a location to use. Schedule a weather update right now.
    if (D)
        Log.d(TAG, "The location has changed, schedule an update ");
    synchronized (WeatherLocationListener.class) {
        WeatherUpdateService.scheduleUpdate(mContext, 0, true);
        cancelTimeoutAlarm();
        sInstance = null;
    }
}
#method_after
@Override
public void onLocationChanged(Location location) {
    // Now, we have a location to use. Schedule a weather update right now.
    if (D)
        Log.d(TAG, "The location has changed, schedule an update ");
    synchronized (WeatherLocationListener.class) {
        scheduleUpdate(mContext, 0, true);
        cancelTimeoutAlarm();
        sInstance = null;
    }
}
#end_block

#method_before
@Override
public void onStatusChanged(String provider, int status, Bundle extras) {
    // Now, we have a location to use. Schedule a weather update right now.
    if (D)
        Log.d(TAG, "The location service has become available, schedule an update ");
    if (status == LocationProvider.AVAILABLE) {
        synchronized (WeatherLocationListener.class) {
            WeatherUpdateService.scheduleUpdate(mContext, 0, true);
            cancelTimeoutAlarm();
            sInstance = null;
        }
    }
}
#method_after
@Override
public void onStatusChanged(String provider, int status, Bundle extras) {
    // Now, we have a location to use. Schedule a weather update right now.
    if (D)
        Log.d(TAG, "The location service has become available, schedule an update ");
    if (status == LocationProvider.AVAILABLE) {
        synchronized (WeatherLocationListener.class) {
            scheduleUpdate(mContext, 0, true);
            cancelTimeoutAlarm();
            sInstance = null;
        }
    }
}
#end_block

#method_before
public static void scheduleNextUpdate(Context context, boolean force) {
    final long lastUpdate = Preferences.lastWeatherUpdateTimestamp(context);
    if (lastUpdate == 0 || force) {
        if (D)
            Log.d(TAG, "Scheduling next update immediately");
        scheduleUpdate(context, 0, true);
    } else {
        final long interval = Preferences.weatherRefreshIntervalInMs(context);
        final long due = lastUpdate + interval - SystemClock.elapsedRealtime();
        if (D)
            Log.d(TAG, "Scheduling in " + due + " ms");
        scheduleUpdate(context, due < 0 ? 0 : due, false);
    }
}
#method_after
public static void scheduleNextUpdate(Context context, boolean force) {
    if (force) {
        if (D)
            Log.d(TAG, "Scheduling next update immediately");
        scheduleUpdate(context, 0, true);
    } else {
        final long lastUpdate = Preferences.lastWeatherUpdateTimestamp(context);
        final long interval = Preferences.weatherRefreshIntervalInMs(context);
        final long now = SystemClock.elapsedRealtime();
        long due = (interval + lastUpdate) - now;
        if (due < 0)
            due = 0;
        if (D)
            Log.d(TAG, "Scheduling in " + due + " ms");
        scheduleUpdate(context, due, false);
    }
}
#end_block

#method_before
@Override
public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    Preference pref = findPreference(key);
    if (pref instanceof ListPreference) {
        ListPreference listPref = (ListPreference) pref;
        pref.setSummary(listPref.getEntry());
    }
    boolean needWeatherUpdate = false;
    boolean forceWeatherUpdate = false;
    if (pref == mUseCustomLoc || pref == mCustomWeatherLoc) {
        updateLocationSummary();
    }
    if (pref == mIconSet) {
        updateIconSetSummary();
    }
    if (pref == mUseMetric) {
        // The display format of the temperatures have changed
        // Force a weather update to refresh the display
        forceWeatherUpdate = true;
    }
    // back to GeoLocation to force the user to specify a new custom location if needed
    if (TextUtils.equals(key, Constants.WEATHER_SOURCE)) {
        Preferences.setCustomWeatherLocationCity(mContext, null);
        Preferences.setCustomWeatherLocation(mContext, null);
        Preferences.setUseCustomWeatherLocation(mContext, false);
        mUseCustomlocation.setChecked(false);
        updateLocationSummary();
        // Since we don't know if the user will set a custom location, we force a weather update
        // using the new provider, otherwise we'll be showing weather data from a non active
        // weather service provider
        WeatherUpdateService.scheduleNextUpdate(mContext, true);
    }
    if (key.equals(Constants.WEATHER_USE_CUSTOM_LOCATION)) {
        if (!mUseCustomLoc.isChecked() || (mUseCustomLoc.isChecked() && Preferences.getCustomWeatherLocation(mContext) != null)) {
            forceWeatherUpdate = true;
        }
    }
    if (key.equals(Constants.WEATHER_CUSTOM_LOCATION_CITY) && mUseCustomLoc.isChecked()) {
        forceWeatherUpdate = true;
    }
    if (key.equals(Constants.SHOW_WEATHER) || key.equals(Constants.WEATHER_REFRESH_INTERVAL)) {
        needWeatherUpdate = true;
    }
    if (key.equals(Constants.SHOW_WEATHER)) {
        mWeatherSource.setEnabled(mShowWeather.isChecked());
        if (Preferences.getWeatherSource(mContext) != null && mShowWeather.isChecked()) {
            mWeatherSource.notifyDependencyChange(false);
        } else {
            mWeatherSource.notifyDependencyChange(true);
        }
    }
    if (Constants.DEBUG) {
        Log.v(TAG, "Preference " + key + " changed, need update " + needWeatherUpdate + " force update " + forceWeatherUpdate);
    }
    if (Preferences.showWeather(mContext) && (needWeatherUpdate || forceWeatherUpdate)) {
        Intent updateIntent = new Intent(mContext, WeatherUpdateService.class);
        if (forceWeatherUpdate) {
            updateIntent.setAction(WeatherUpdateService.ACTION_FORCE_UPDATE);
        }
        mContext.startService(updateIntent);
    }
    Intent updateIntent = new Intent(mContext, ClockWidgetProvider.class);
    mContext.sendBroadcast(updateIntent);
}
#method_after
@Override
public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    Preference pref = findPreference(key);
    if (pref instanceof ListPreference) {
        ListPreference listPref = (ListPreference) pref;
        pref.setSummary(listPref.getEntry());
    }
    boolean needWeatherUpdate = false;
    boolean forceWeatherUpdate = false;
    if (pref == mUseCustomLoc || pref == mCustomWeatherLoc) {
        updateLocationSummary();
    }
    if (pref == mIconSet) {
        updateIconSetSummary();
    }
    if (pref == mUseMetric) {
        // The display format of the temperatures have changed
        // Force a weather update to refresh the display
        forceWeatherUpdate = true;
    }
    if (TextUtils.equals(key, Constants.WEATHER_SOURCE)) {
        // The weather source changed, invalidate the custom location settings and change
        // back to GeoLocation to force the user to specify a new custom location if needed
        Preferences.setCustomWeatherLocationCity(mContext, null);
        Preferences.setCustomWeatherLocation(mContext, null);
        Preferences.setUseCustomWeatherLocation(mContext, false);
        mUseCustomlocation.setChecked(false);
        updateLocationSummary();
    }
    if (key.equals(Constants.WEATHER_USE_CUSTOM_LOCATION)) {
        if (!mUseCustomLoc.isChecked() || (mUseCustomLoc.isChecked() && Preferences.getCustomWeatherLocation(mContext) != null)) {
            forceWeatherUpdate = true;
        }
    }
    if (key.equals(Constants.WEATHER_CUSTOM_LOCATION_CITY) && mUseCustomLoc.isChecked()) {
        forceWeatherUpdate = true;
    }
    if (key.equals(Constants.SHOW_WEATHER) || key.equals(Constants.WEATHER_REFRESH_INTERVAL)) {
        needWeatherUpdate = true;
    }
    if (key.equals(Constants.SHOW_WEATHER)) {
        mWeatherSource.setEnabled(mShowWeather.isChecked());
        if (Preferences.getWeatherSource(mContext) != null && mShowWeather.isChecked()) {
            mWeatherSource.notifyDependencyChange(false);
        } else {
            mWeatherSource.notifyDependencyChange(true);
        }
    }
    if (Constants.DEBUG) {
        Log.v(TAG, "Preference " + key + " changed, need update " + needWeatherUpdate + " force update " + forceWeatherUpdate);
    }
    if (Preferences.showWeather(mContext) && (needWeatherUpdate || forceWeatherUpdate)) {
        Intent updateIntent = new Intent(mContext, WeatherUpdateService.class);
        if (forceWeatherUpdate) {
            updateIntent.setAction(WeatherUpdateService.ACTION_FORCE_UPDATE);
        }
        mContext.startService(updateIntent);
    }
    Intent updateIntent = new Intent(mContext, ClockWidgetProvider.class);
    mContext.sendBroadcast(updateIntent);
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    // Deal with received broadcasts that force a refresh
    String action = intent.getAction();
    if (D)
        Log.v(TAG, "Received intent " + intent);
    // Network connection has changed, make sure the weather update service knows about it
    if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action)) {
        boolean hasConnection = !intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
        if (D)
            Log.d(TAG, "Got connectivity change, has connection: " + hasConnection);
        Intent i = new Intent(context, WeatherUpdateService.class);
        if (hasConnection) {
            context.startService(i);
        } else {
            context.stopService(i);
        }
    // Boot completed, schedule next weather update
    } else if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
        // Since we're using elapsed time since boot, we can't use the timestamp from the
        // previous boot so we need to reset the timer
        Preferences.setLastWeatherUpadteTimestamp(context, 0);
        WeatherUpdateService.scheduleNextUpdate(context, false);
    // A widget has been deleted, prevent our handling and ask the super class handle it
    } else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action) || AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
        super.onReceive(context, intent);
    // Calendar, Time or a settings change, force a calendar refresh
    } else if (Intent.ACTION_PROVIDER_CHANGED.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action) || Intent.ACTION_DATE_CHANGED.equals(action) || Intent.ACTION_LOCALE_CHANGED.equals(action) || "android.app.action.NEXT_ALARM_CLOCK_CHANGED".equals(action) || ClockWidgetService.ACTION_REFRESH_CALENDAR.equals(action)) {
        updateWidgets(context, true, false);
    // There are no events to show in the Calendar panel, hide it explicitly
    } else if (ClockWidgetService.ACTION_HIDE_CALENDAR.equals(action)) {
        updateWidgets(context, false, true);
    // The intent is to launch the modal pop-up forecast dialog
    } else if (Constants.ACTION_SHOW_FORECAST.equals(action)) {
        Intent i = new Intent(context, ForecastActivity.class);
        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(i);
    // Something we did not handle, let the super class deal with it.
    // This includes the REFRESH_CLOCK intent from Clock settings
    } else {
        if (D)
            Log.v(TAG, "We did not handle the intent, trigger normal handling");
        super.onReceive(context, intent);
        updateWidgets(context, false, false);
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    // Deal with received broadcasts that force a refresh
    String action = intent.getAction();
    if (D)
        Log.v(TAG, "Received intent " + intent);
    // Network connection has changed, make sure the weather update service knows about it
    if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action)) {
        boolean hasConnection = !intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false);
        if (D)
            Log.d(TAG, "Got connectivity change, has connection: " + hasConnection);
        Intent i = new Intent(context, WeatherUpdateService.class);
        if (hasConnection) {
            context.startService(i);
        } else {
            context.stopService(i);
        }
    // Boot completed, schedule next weather update
    } else if (Intent.ACTION_BOOT_COMPLETED.equals(action)) {
        // Since we're using elapsed time since boot, we can't use the timestamp from the
        // previous boot so we need to reset the timer
        Preferences.setLastWeatherUpadteTimestamp(context, 0);
    // A widget has been deleted, prevent our handling and ask the super class handle it
    } else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action) || AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
        super.onReceive(context, intent);
    // Calendar, Time or a settings change, force a calendar refresh
    } else if (Intent.ACTION_PROVIDER_CHANGED.equals(action) || Intent.ACTION_TIME_CHANGED.equals(action) || Intent.ACTION_TIMEZONE_CHANGED.equals(action) || Intent.ACTION_DATE_CHANGED.equals(action) || Intent.ACTION_LOCALE_CHANGED.equals(action) || "android.app.action.NEXT_ALARM_CLOCK_CHANGED".equals(action) || ClockWidgetService.ACTION_REFRESH_CALENDAR.equals(action)) {
        updateWidgets(context, true, false);
    // There are no events to show in the Calendar panel, hide it explicitly
    } else if (ClockWidgetService.ACTION_HIDE_CALENDAR.equals(action)) {
        updateWidgets(context, false, true);
    // The intent is to launch the modal pop-up forecast dialog
    } else if (Constants.ACTION_SHOW_FORECAST.equals(action)) {
        Intent i = new Intent(context, ForecastActivity.class);
        i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(i);
    // Something we did not handle, let the super class deal with it.
    // This includes the REFRESH_CLOCK intent from Clock settings
    } else {
        if (D)
            Log.v(TAG, "We did not handle the intent, trigger normal handling");
        super.onReceive(context, intent);
        updateWidgets(context, false, false);
    }
}
#end_block

#method_before
@Override
public void onEnabled(Context context) {
    if (D)
        Log.d(TAG, "Scheduling next weather update");
    WeatherUpdateService.scheduleNextUpdate(context, true);
    // Once triggered, the receiver will unregister itself when its work is done
    if (!WidgetUtils.isTextClockAvailable()) {
        final WidgetApplication app = (WidgetApplication) context.getApplicationContext();
        app.startTickReceiver();
    }
}
#method_after
@Override
public void onEnabled(Context context) {
    if (D)
        Log.d(TAG, "Scheduling next weather update");
    context.startService(new Intent(context, WeatherSourceListenerService.class));
    WeatherUpdateService.scheduleNextUpdate(context, true);
    // Once triggered, the receiver will unregister itself when its work is done
    if (!WidgetUtils.isTextClockAvailable()) {
        final WidgetApplication app = (WidgetApplication) context.getApplicationContext();
        app.startTickReceiver();
    }
}
#end_block

#method_before
@Override
public void onDisabled(Context context) {
    if (D)
        Log.d(TAG, "Cleaning up: Clearing all pending alarms");
    ClockWidgetService.cancelUpdates(context);
    WeatherUpdateService.cancelUpdates(context);
    // Stop the clock update event (API 16 devices)
    if (!WidgetUtils.isTextClockAvailable()) {
        WidgetApplication.cancelClockRefresh(context);
    }
}
#method_after
@Override
public void onDisabled(Context context) {
    if (D)
        Log.d(TAG, "Cleaning up: Clearing all pending alarms");
    context.stopService(new Intent(context, WeatherSourceListenerService.class));
    ClockWidgetService.cancelUpdates(context);
    WeatherUpdateService.cancelUpdates(context);
    // Stop the clock update event (API 16 devices)
    if (!WidgetUtils.isTextClockAvailable()) {
        WidgetApplication.cancelClockRefresh(context);
    }
}
#end_block

#method_before
public static void setCustomWeatherLocation(Context context, WeatherLocation weatherLocation) {
    if (weatherLocation == null) {
        getPrefs(context).edit().putString(Constants.WEATHER_CUSTOM_LOCATION, null).apply();
        return;
    }
    try {
        JSONObject jsonObject = weatherLocationToJSON(weatherLocation);
        getPrefs(context).edit().putString(Constants.WEATHER_CUSTOM_LOCATION, jsonObject.toString()).apply();
    } catch (JSONException e) {
    }
}
#method_after
public static boolean setCustomWeatherLocation(Context context, WeatherLocation weatherLocation) {
    if (weatherLocation == null) {
        getPrefs(context).edit().remove(Constants.WEATHER_CUSTOM_LOCATION).apply();
        return true;
    }
    try {
        JSONObject jsonObject = weatherLocationToJSON(weatherLocation);
        getPrefs(context).edit().putString(Constants.WEATHER_CUSTOM_LOCATION, jsonObject.toString()).apply();
        return true;
    } catch (JSONException e) {
        // Either way, it means the pref was not updated
        return false;
    }
}
#end_block

#method_before
private static WeatherLocation JSONToWeatherLocation(JSONObject jsonObject) throws JSONException {
    String cityId;
    String cityName;
    String state;
    String postalCode;
    String countryId;
    String countryName;
    cityId = jsonObject.getString("city_id");
    cityName = jsonObject.getString("city_name");
    state = jsonObject.getString("state");
    postalCode = jsonObject.getString("postal_code");
    countryId = jsonObject.getString("country_id");
    countryName = jsonObject.getString("country_name");
    // We need at least city id and city name to build a WeatherLocation
    if (cityId == null && cityName == null) {
        return null;
    }
    WeatherLocation.Builder location = new WeatherLocation.Builder(cityId, cityName);
    if (countryId != null)
        location.setCountryId(countryId);
    if (countryName != null)
        location.setCountry(countryName);
    if (state != null)
        location.setState(state);
    if (postalCode != null)
        location.setPostalCode(postalCode);
    return location.build();
}
#method_after
private static WeatherLocation JSONToWeatherLocation(JSONObject jsonObject) throws JSONException {
    String cityId;
    String cityName;
    String state;
    String postalCode;
    String countryId;
    String countryName;
    cityId = jsonObject.getString(WEATHER_LOCATION_CITY_ID);
    cityName = jsonObject.getString(WEATHER_LOCATION_CITY_NAME);
    state = jsonObject.getString(WEATHER_LOCATION_STATE);
    postalCode = jsonObject.getString(WEATHER_LOCATION_POSTAL_CODE);
    countryId = jsonObject.getString(WEATHER_LOCATION_COUNTRY_ID);
    countryName = jsonObject.getString(WEATHER_LOCATION_COUNTRY_NAME);
    // We need at least city id and city name to build a WeatherLocation
    if (cityId == null && cityName == null) {
        return null;
    }
    WeatherLocation.Builder location = new WeatherLocation.Builder(cityId, cityName);
    if (countryId != null)
        location.setCountryId(countryId);
    if (countryName != null)
        location.setCountry(countryName);
    if (state != null)
        location.setState(state);
    if (postalCode != null)
        location.setPostalCode(postalCode);
    return location.build();
}
#end_block

#method_before
private static JSONObject weatherLocationToJSON(WeatherLocation location) throws JSONException {
    return new JSONObject().put("city_id", location.getCityId()).put("city_name", location.getCity()).put("state", location.getState()).put("postal_code", location.getPostalCode()).put("country_id", location.getCountryId()).put("country_name", location.getCountry());
}
#method_after
private static JSONObject weatherLocationToJSON(WeatherLocation location) throws JSONException {
    return new JSONObject().put(WEATHER_LOCATION_CITY_ID, location.getCityId()).put(WEATHER_LOCATION_CITY_NAME, location.getCity()).put(WEATHER_LOCATION_STATE, location.getState()).put(WEATHER_LOCATION_POSTAL_CODE, location.getPostalCode()).put(WEATHER_LOCATION_COUNTRY_ID, location.getCountryId()).put(WEATHER_LOCATION_COUNTRY_NAME, location.getCountry());
}
#end_block

#method_before
public static void setCachedWeatherInfo(Context context, long timestamp, WeatherInfo info) {
    SharedPreferences.Editor editor = getPrefs(context).edit();
    editor.putLong(Constants.WEATHER_LAST_UPDATE, timestamp);
    if (info != null) {
        // We now have valid weather data to display
        JSONStringer stringer = new JSONStringer();
        boolean serialized = false;
        try {
            stringer.object().key("city").value(info.getCity()).key("condition_code").value(info.getConditionCode()).key("temperature").value(info.getTemperature()).key("temperature_unit").value(info.getTemperatureUnit()).key("humidity").value(info.getHumidity()).key("wind_speed").value(info.getWindSpeed()).key("wind_speed_unit").value(info.getWindSpeedUnit()).key("wind_speed_direction").value(info.getWindDirection()).key("todays_high").value(info.getTodaysHigh()).key("todays_low").value(info.getTodaysLow()).key("timestamp").value(info.getTimestamp());
            stringer.key("forecasts").array();
            for (WeatherInfo.DayForecast forecast : info.getForecasts()) {
                stringer.object().key("low").value(forecast.getLow()).key("high").value(forecast.getHigh()).key("condition_code").value(forecast.getConditionCode()).endObject();
            }
            stringer.endArray();
            stringer.endObject();
            serialized = true;
        } catch (JSONException e) {
        }
        if (serialized) {
            editor.putString(Constants.WEATHER_DATA, stringer.toString());
            editor.putBoolean(Constants.WEATHER_FIRST_UPDATE, false);
        }
    }
    editor.apply();
}
#method_after
public static void setCachedWeatherInfo(Context context, long timestamp, WeatherInfo info) {
    SharedPreferences.Editor editor = getPrefs(context).edit();
    editor.putLong(Constants.WEATHER_LAST_UPDATE, timestamp);
    if (info != null) {
        // We now have valid weather data to display
        JSONObject jsonObject = new JSONObject();
        boolean serialized = false;
        try {
            // These members always return a value that can be parsed
            jsonObject.put(WEATHER_INFO_CITY, info.getCity()).put(WEATHER_INFO_CONDITION_CODE, info.getConditionCode()).put(WEATHER_INFO_TEMPERATURE, info.getTemperature()).put(WEATHER_INFO_TEMPERATURE_UNIT, info.getTemperatureUnit()).put(WEATHER_INFO_TIMESTAMP, info.getTimestamp());
            // Handle special cases. JSONObject.put(key, double) does not allow
            // Double.NaN, so we store it as a string. JSONObject.getDouble() will parse the
            // "NaN" string and return Double.NaN, which is what we want
            double humidity = info.getHumidity();
            jsonObject.put(WEATHER_INFO_HUMIDITY, Double.isNaN(humidity) ? "NaN" : humidity);
            double todaysHigh = info.getTodaysHigh();
            jsonObject.put(WEATHER_INFO_TODAYS_HIGH, Double.isNaN(todaysHigh) ? "NaN" : todaysHigh);
            double todaysLow = info.getTodaysLow();
            jsonObject.put(WEATHER_INFO_TODAYS_LOW, Double.isNaN(todaysLow) ? "NaN" : todaysLow);
            double windSpeed = info.getWindSpeed();
            double windDirection = info.getWindDirection();
            jsonObject.put(WEATHER_INFO_WIND_SPEED, Double.isNaN(windSpeed) ? "NaN" : windSpeed).put(WEATHER_INFO_WIND_SPEED_UNIT, info.getWindSpeedUnit()).put(WEATHER_INFO_WIND_SPEED_DIRECTION, Double.isNaN(windDirection) ? "NaN" : windDirection);
            JSONArray forecastArray = new JSONArray();
            for (WeatherInfo.DayForecast forecast : info.getForecasts()) {
                JSONObject jsonForecast = new JSONObject().put(DAY_FORECAST_CONDITION_CODE, forecast.getConditionCode());
                double low = forecast.getLow();
                jsonForecast.put(DAY_FORECAST_LOW, Double.isNaN(low) ? "NaN" : low);
                double high = forecast.getHigh();
                jsonForecast.put(DAY_FORECAST_HIGH, Double.isNaN(high) ? "NaN" : high);
                forecastArray.put(jsonForecast);
            }
            jsonObject.put(WEATHER_INFO_FORECAST, forecastArray);
            serialized = true;
        } catch (JSONException e) {
        // We're here because something went wrong while creating the JSON object.
        // The code below will check for success and proceed accordingly
        }
        if (serialized) {
            editor.putString(Constants.WEATHER_DATA, jsonObject.toString());
            editor.putBoolean(Constants.WEATHER_FIRST_UPDATE, false);
        }
    } else {
        editor.remove(Constants.WEATHER_DATA);
    }
    editor.apply();
}
#end_block

#method_before
public static WeatherInfo getCachedWeatherInfo(Context context) {
    final String cachedInfo = getPrefs(context).getString(Constants.WEATHER_DATA, null);
    if (cachedInfo == null)
        return null;
    String city;
    int conditionCode;
    double temperature;
    int tempUnit;
    double humidity;
    double windSpeed;
    double windDirection;
    double todaysHigh;
    double todaysLow;
    int windSpeedUnit;
    long timestamp;
    ArrayList<WeatherInfo.DayForecast> forecastList = new ArrayList<>();
    try {
        JSONObject cached = new JSONObject(cachedInfo);
        city = cached.getString("city");
        conditionCode = cached.getInt("condition_code");
        temperature = cached.getDouble("temperature");
        tempUnit = cached.getInt("temperature_unit");
        humidity = cached.getDouble("humidity");
        windSpeed = cached.getDouble("wind_speed");
        windDirection = cached.getDouble("wind_speed_direction");
        windSpeedUnit = cached.getInt("wind_speed_unit");
        timestamp = cached.getLong("timestamp");
        todaysHigh = cached.getDouble("todays_high");
        todaysLow = cached.getDouble("todays_low");
        JSONArray forecasts = cached.getJSONArray("forecasts");
        for (int indx = 0; indx < forecasts.length(); indx++) {
            JSONObject forecast = forecasts.getJSONObject(indx);
            double low;
            double high;
            int code;
            low = forecast.getDouble("low");
            high = forecast.getDouble("high");
            code = forecast.getInt("condition_code");
            forecastList.add(new WeatherInfo.DayForecast.Builder(code).setLow(low).setHigh(high).build());
        }
        WeatherInfo.Builder weatherInfo = new WeatherInfo.Builder(city, temperature, tempUnit).setWeatherCondition(conditionCode).setTimestamp(timestamp);
        if (!Double.isNaN(humidity))
            weatherInfo.setHumidity(humidity);
        if (!Double.isNaN(windSpeed) && !Double.isNaN(windDirection)) {
            weatherInfo.setWind(windSpeed, windDirection, windSpeedUnit);
        }
        if (forecastList.size() > 0)
            weatherInfo.setForecast(forecastList);
        if (!Double.isNaN(todaysHigh))
            weatherInfo.setTodaysHigh(todaysHigh);
        if (!Double.isNaN(todaysLow))
            weatherInfo.setTodaysLow(todaysLow);
        return weatherInfo.build();
    } catch (JSONException e) {
    }
    return null;
}
#method_after
public static WeatherInfo getCachedWeatherInfo(Context context) {
    final String cachedInfo = getPrefs(context).getString(Constants.WEATHER_DATA, null);
    if (cachedInfo == null)
        return null;
    String city;
    int conditionCode;
    double temperature;
    int tempUnit;
    double humidity;
    double windSpeed;
    double windDirection;
    double todaysHigh;
    double todaysLow;
    int windSpeedUnit;
    long timestamp;
    ArrayList<WeatherInfo.DayForecast> forecastList = new ArrayList<>();
    try {
        JSONObject cached = new JSONObject(cachedInfo);
        city = cached.getString(WEATHER_INFO_CITY);
        conditionCode = cached.getInt(WEATHER_INFO_CONDITION_CODE);
        temperature = cached.getDouble(WEATHER_INFO_TEMPERATURE);
        tempUnit = cached.getInt(WEATHER_INFO_TEMPERATURE_UNIT);
        humidity = cached.getDouble(WEATHER_INFO_HUMIDITY);
        windSpeed = cached.getDouble(WEATHER_INFO_WIND_SPEED);
        windDirection = cached.getDouble(WEATHER_INFO_WIND_SPEED_DIRECTION);
        windSpeedUnit = cached.getInt(WEATHER_INFO_WIND_SPEED_UNIT);
        timestamp = cached.getLong(WEATHER_INFO_TIMESTAMP);
        todaysHigh = cached.getDouble(WEATHER_INFO_TODAYS_HIGH);
        todaysLow = cached.getDouble(WEATHER_INFO_TODAYS_LOW);
        JSONArray forecasts = cached.getJSONArray(WEATHER_INFO_FORECAST);
        for (int indx = 0; indx < forecasts.length(); indx++) {
            JSONObject forecast = forecasts.getJSONObject(indx);
            double low;
            double high;
            int code;
            low = forecast.getDouble(DAY_FORECAST_LOW);
            high = forecast.getDouble(DAY_FORECAST_HIGH);
            code = forecast.getInt(DAY_FORECAST_CONDITION_CODE);
            WeatherInfo.DayForecast.Builder f = new WeatherInfo.DayForecast.Builder(code);
            if (!Double.isNaN(low))
                f.setLow(low);
            if (!Double.isNaN(high))
                f.setHigh(high);
            forecastList.add(f.build());
        }
        WeatherInfo.Builder weatherInfo = new WeatherInfo.Builder(city, temperature, tempUnit).setWeatherCondition(conditionCode).setTimestamp(timestamp);
        if (!Double.isNaN(humidity))
            weatherInfo.setHumidity(humidity);
        if (!Double.isNaN(windSpeed) && !Double.isNaN(windDirection)) {
            weatherInfo.setWind(windSpeed, windDirection, windSpeedUnit);
        }
        if (forecastList.size() > 0)
            weatherInfo.setForecast(forecastList);
        if (!Double.isNaN(todaysHigh))
            weatherInfo.setTodaysHigh(todaysHigh);
        if (!Double.isNaN(todaysLow))
            weatherInfo.setTodaysLow(todaysLow);
        return weatherInfo.build();
    } catch (JSONException e) {
    }
    return null;
}
#end_block

#method_before
@Override
protected void showDialog(Bundle state) {
    super.showDialog(state);
    mHandler = new Handler(getContext().getMainLooper());
    final AlertDialog d = (AlertDialog) getDialog();
    final Button okButton = d.getButton(DialogInterface.BUTTON_POSITIVE);
    okButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            CustomLocationPreference.this.onClick(d, DialogInterface.BUTTON_POSITIVE);
            final String customLocationToLookUp = getEditText().getText().toString();
            final CMWeatherManager weatherManager = CMWeatherManager.getInstance(getContext());
            mProgressDialog = new ProgressDialog(getContext());
            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
            mProgressDialog.setMessage(getContext().getString(R.string.weather_progress_title));
            mProgressDialog.setOnCancelListener(new DialogInterface.OnCancelListener() {

                @Override
                public void onCancel(DialogInterface dialog) {
                    weatherManager.cancelRequest(mCustomLocationRequestId);
                }
            });
            mCustomLocationRequestId = weatherManager.lookupCity(customLocationToLookUp, CustomLocationPreference.this);
            mProgressDialog.show();
        }
    });
}
#method_after
@Override
protected void showDialog(Bundle state) {
    super.showDialog(state);
    mHandler = new Handler(getContext().getMainLooper());
    final AlertDialog d = (AlertDialog) getDialog();
    final Button okButton = d.getButton(DialogInterface.BUTTON_POSITIVE);
    okButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            CustomLocationPreference.this.onClick(d, DialogInterface.BUTTON_POSITIVE);
            final String customLocationToLookUp = getEditText().getText().toString();
            if (TextUtils.equals(customLocationToLookUp, ""))
                return;
            final CMWeatherManager weatherManager = CMWeatherManager.getInstance(getContext());
            mProgressDialog = new ProgressDialog(getContext());
            mProgressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
            mProgressDialog.setMessage(getContext().getString(R.string.weather_progress_title));
            mProgressDialog.setOnCancelListener(new DialogInterface.OnCancelListener() {

                @Override
                public void onCancel(DialogInterface dialog) {
                    weatherManager.cancelRequest(mCustomLocationRequestId);
                }
            });
            mCustomLocationRequestId = weatherManager.lookupCity(customLocationToLookUp, CustomLocationPreference.this);
            mProgressDialog.show();
        }
    });
}
#end_block

#method_before
private void applyLocation(final WeatherLocation result) {
    Preferences.setCustomWeatherLocation(getContext(), result);
    setText(result.getCity());
    final AlertDialog d = (AlertDialog) getDialog();
    d.dismiss();
}
#method_after
private void applyLocation(final WeatherLocation result) {
    if (Preferences.setCustomWeatherLocation(getContext(), result)) {
        String cityName = result.getCity();
        String state = result.getState();
        String country = result.getCountry();
        setText(cityName + "," + state + "/" + country);
    }
    final AlertDialog d = (AlertDialog) getDialog();
    d.dismiss();
}
#end_block

#method_before
// ===============================================================================================
// Weather related functionality
// ===============================================================================================
private void setWeatherData(RemoteViews weatherViews, boolean smallWidget, WeatherInfo w) {
    int color = Preferences.weatherFontColor(this);
    int timestampColor = Preferences.weatherTimestampFontColor(this);
    String iconsSet = Preferences.getWeatherIconSet(this);
    // Reset no weather visibility
    weatherViews.setViewVisibility(R.id.weather_no_data, View.GONE);
    weatherViews.setViewVisibility(R.id.weather_refresh, View.GONE);
    // Weather Image
    int resId = IconUtils.getWeatherIconResource(mContext, iconsSet, w.getConditionCode());
    weatherViews.setViewVisibility(R.id.weather_image, View.VISIBLE);
    if (resId != 0) {
        weatherViews.setImageViewResource(R.id.weather_image, IconUtils.getWeatherIconResource(mContext, iconsSet, w.getConditionCode()));
    } else {
        weatherViews.setImageViewBitmap(R.id.weather_image, IconUtils.getWeatherIconBitmap(mContext, iconsSet, color, w.getConditionCode()));
    }
    // Weather Condition
    weatherViews.setTextViewText(R.id.weather_condition, Utils.resolveWeatherCondition(mContext, w.getConditionCode()));
    weatherViews.setViewVisibility(R.id.weather_condition, View.VISIBLE);
    weatherViews.setTextColor(R.id.weather_condition, color);
    // Weather Temps Panel
    weatherViews.setTextViewText(R.id.weather_temp, WeatherUtils.formatTemperature(w.getTemperature(), w.getTemperatureUnit()));
    weatherViews.setViewVisibility(R.id.weather_temps_panel, View.VISIBLE);
    weatherViews.setTextColor(R.id.weather_temp, color);
    if (!smallWidget) {
        // Display the full weather information panel items
        // Load the preferences
        boolean showLocation = Preferences.showWeatherLocation(this);
        boolean showTimestamp = Preferences.showWeatherTimestamp(this);
        // City
        weatherViews.setTextViewText(R.id.weather_city, w.getCity());
        weatherViews.setViewVisibility(R.id.weather_city, showLocation ? View.VISIBLE : View.GONE);
        weatherViews.setTextColor(R.id.weather_city, color);
        // Weather Update Time
        if (showTimestamp) {
            Date updateTime = new Date(w.getTimestamp());
            StringBuilder sb = new StringBuilder();
            sb.append(DateFormat.format("E", updateTime));
            sb.append(" ");
            sb.append(DateFormat.getTimeFormat(this).format(updateTime));
            weatherViews.setTextViewText(R.id.update_time, sb.toString());
            weatherViews.setViewVisibility(R.id.update_time, View.VISIBLE);
            weatherViews.setTextColor(R.id.update_time, timestampColor);
        } else {
            weatherViews.setViewVisibility(R.id.update_time, View.GONE);
        }
        // Weather Temps Panel additional items
        boolean invertLowhigh = Preferences.invertLowHighTemperature(this);
        final String low = WeatherUtils.formatTemperature(w.getTodaysLow(), w.getTemperatureUnit());
        final String high = WeatherUtils.formatTemperature(w.getTodaysHigh(), w.getTemperatureUnit());
        weatherViews.setTextViewText(R.id.weather_low_high, invertLowhigh ? high + " | " + low : low + " | " + high);
        weatherViews.setTextColor(R.id.weather_low_high, color);
    }
    // Register an onClickListener on Weather
    setWeatherClickListener(weatherViews, false);
}
#method_after
// ===============================================================================================
// Weather related functionality
// ===============================================================================================
private void setWeatherData(RemoteViews weatherViews, boolean smallWidget, WeatherInfo w) {
    int color = Preferences.weatherFontColor(this);
    int timestampColor = Preferences.weatherTimestampFontColor(this);
    String iconsSet = Preferences.getWeatherIconSet(this);
    final boolean useMetric = Preferences.useMetricUnits(mContext);
    // Reset no weather visibility
    weatherViews.setViewVisibility(R.id.weather_no_data, View.GONE);
    weatherViews.setViewVisibility(R.id.weather_refresh, View.GONE);
    // Weather Image
    int resId = IconUtils.getWeatherIconResource(mContext, iconsSet, w.getConditionCode());
    weatherViews.setViewVisibility(R.id.weather_image, View.VISIBLE);
    if (resId != 0) {
        weatherViews.setImageViewResource(R.id.weather_image, IconUtils.getWeatherIconResource(mContext, iconsSet, w.getConditionCode()));
    } else {
        weatherViews.setImageViewBitmap(R.id.weather_image, IconUtils.getWeatherIconBitmap(mContext, iconsSet, color, w.getConditionCode()));
    }
    // Weather Condition
    weatherViews.setTextViewText(R.id.weather_condition, Utils.resolveWeatherCondition(mContext, w.getConditionCode()));
    weatherViews.setViewVisibility(R.id.weather_condition, View.VISIBLE);
    weatherViews.setTextColor(R.id.weather_condition, color);
    // Weather Temps Panel
    double temp = w.getTemperature();
    double todaysLow = w.getTodaysLow();
    double todaysHigh = w.getTodaysHigh();
    int tempUnit = w.getTemperatureUnit();
    if (tempUnit == FAHRENHEIT && useMetric) {
        temp = WeatherUtils.fahrenheitToCelsius(temp);
        todaysLow = WeatherUtils.fahrenheitToCelsius(todaysLow);
        todaysHigh = WeatherUtils.fahrenheitToCelsius(todaysHigh);
        tempUnit = CELSIUS;
    } else if (tempUnit == CELSIUS && !useMetric) {
        temp = WeatherUtils.celsiusToFahrenheit(temp);
        todaysLow = WeatherUtils.celsiusToFahrenheit(todaysLow);
        todaysHigh = WeatherUtils.celsiusToFahrenheit(todaysHigh);
        tempUnit = FAHRENHEIT;
    }
    weatherViews.setTextViewText(R.id.weather_temp, WeatherUtils.formatTemperature(temp, tempUnit));
    weatherViews.setViewVisibility(R.id.weather_temps_panel, View.VISIBLE);
    weatherViews.setTextColor(R.id.weather_temp, color);
    if (!smallWidget) {
        // Display the full weather information panel items
        // Load the preferences
        boolean showLocation = Preferences.showWeatherLocation(this);
        boolean showTimestamp = Preferences.showWeatherTimestamp(this);
        // City
        weatherViews.setTextViewText(R.id.weather_city, w.getCity());
        weatherViews.setViewVisibility(R.id.weather_city, showLocation ? View.VISIBLE : View.GONE);
        weatherViews.setTextColor(R.id.weather_city, color);
        // Weather Update Time
        if (showTimestamp) {
            Date updateTime = new Date(w.getTimestamp());
            StringBuilder sb = new StringBuilder();
            sb.append(DateFormat.format("E", updateTime));
            sb.append(" ");
            sb.append(DateFormat.getTimeFormat(this).format(updateTime));
            weatherViews.setTextViewText(R.id.update_time, sb.toString());
            weatherViews.setViewVisibility(R.id.update_time, View.VISIBLE);
            weatherViews.setTextColor(R.id.update_time, timestampColor);
        } else {
            weatherViews.setViewVisibility(R.id.update_time, View.GONE);
        }
        // Weather Temps Panel additional items
        boolean invertLowhigh = Preferences.invertLowHighTemperature(this);
        final String low = WeatherUtils.formatTemperature(todaysLow, tempUnit);
        final String high = WeatherUtils.formatTemperature(todaysHigh, tempUnit);
        weatherViews.setTextViewText(R.id.weather_low_high, invertLowhigh ? high + " | " + low : low + " | " + high);
        weatherViews.setTextColor(R.id.weather_low_high, color);
    }
    // Register an onClickListener on Weather
    setWeatherClickListener(weatherViews, false);
}
#end_block

#method_before
private void setNoWeatherData(RemoteViews weatherViews, boolean smallWidget) {
    int color = Preferences.weatherFontColor(this);
    boolean firstRun = Preferences.isFirstWeatherUpdate(this);
    // Hide the normal weather stuff
    final CMWeatherManager weatherManager = CMWeatherManager.getInstance(mContext);
    final String activeProviderLabel = weatherManager.getActiveWeatherServiceProviderLabel();
    String noData = getString(R.string.weather_cannot_reach_provider, activeProviderLabel);
    weatherViews.setViewVisibility(R.id.weather_image, View.INVISIBLE);
    if (!smallWidget) {
        weatherViews.setViewVisibility(R.id.weather_city, View.GONE);
        weatherViews.setViewVisibility(R.id.update_time, View.GONE);
        weatherViews.setViewVisibility(R.id.weather_temps_panel, View.GONE);
        weatherViews.setViewVisibility(R.id.weather_condition, View.GONE);
        // Set up the no data and refresh indicators
        weatherViews.setTextViewText(R.id.weather_no_data, noData);
        weatherViews.setTextViewText(R.id.weather_refresh, getString(R.string.weather_tap_to_refresh));
        weatherViews.setTextColor(R.id.weather_no_data, color);
        weatherViews.setTextColor(R.id.weather_refresh, color);
        // For a better OOBE, dont show the no_data message if this is the first run
        weatherViews.setViewVisibility(R.id.weather_no_data, firstRun ? View.GONE : View.VISIBLE);
        weatherViews.setViewVisibility(R.id.weather_refresh, firstRun ? View.GONE : View.VISIBLE);
    } else {
        weatherViews.setTextViewText(R.id.weather_temp, firstRun ? null : noData);
        weatherViews.setTextViewText(R.id.weather_condition, firstRun ? null : getString(R.string.weather_tap_to_refresh));
        weatherViews.setTextColor(R.id.weather_temp, color);
        weatherViews.setTextColor(R.id.weather_condition, color);
    }
    // Register an onClickListener on Weather with the default (Refresh) action
    if (!firstRun) {
        setWeatherClickListener(weatherViews, true);
    }
}
#method_after
private void setNoWeatherData(RemoteViews weatherViews, boolean smallWidget) {
    int color = Preferences.weatherFontColor(this);
    boolean firstRun = Preferences.isFirstWeatherUpdate(this);
    // Hide the normal weather stuff
    final CMWeatherManager weatherManager = CMWeatherManager.getInstance(mContext);
    final String activeProviderLabel = weatherManager.getActiveWeatherServiceProviderLabel();
    String noData;
    if (activeProviderLabel != null) {
        noData = getString(R.string.weather_cannot_reach_provider, activeProviderLabel);
    } else {
        noData = getString(R.string.weather_source_title) + " " + getString(R.string.weather_source_not_selected);
    }
    weatherViews.setViewVisibility(R.id.weather_image, View.INVISIBLE);
    if (!smallWidget) {
        weatherViews.setViewVisibility(R.id.weather_city, View.GONE);
        weatherViews.setViewVisibility(R.id.update_time, View.GONE);
        weatherViews.setViewVisibility(R.id.weather_temps_panel, View.GONE);
        weatherViews.setViewVisibility(R.id.weather_condition, View.GONE);
        // Set up the no data and refresh indicators
        weatherViews.setTextViewText(R.id.weather_no_data, noData);
        if (activeProviderLabel != null) {
            weatherViews.setTextViewText(R.id.weather_refresh, getString(R.string.weather_tap_to_refresh));
        } else {
            weatherViews.setTextViewText(R.id.weather_refresh, getString(R.string.weather_tap_to_select_source));
        }
        weatherViews.setTextColor(R.id.weather_no_data, color);
        weatherViews.setTextColor(R.id.weather_refresh, color);
        // For a better OOBE, dont show the no_data message if this is the first run
        weatherViews.setViewVisibility(R.id.weather_no_data, firstRun ? View.GONE : View.VISIBLE);
        weatherViews.setViewVisibility(R.id.weather_refresh, firstRun ? View.GONE : View.VISIBLE);
    } else {
        weatherViews.setTextViewText(R.id.weather_temp, firstRun ? null : noData);
        weatherViews.setTextViewText(R.id.weather_condition, firstRun ? null : getString(R.string.weather_tap_to_refresh));
        weatherViews.setTextColor(R.id.weather_temp, color);
        weatherViews.setTextColor(R.id.weather_condition, color);
    }
    // Register an onClickListener on Weather with the default (Refresh) action
    if (!firstRun) {
        if (activeProviderLabel != null) {
            setWeatherClickListener(weatherViews, true);
        } else {
            setWeatherClickListener(weatherViews);
        }
    }
}
#end_block

#method_before
private void setWeatherClickListener(RemoteViews weatherViews, boolean forceRefresh) {
    // Register an onClickListener on the Weather panel, default action is show forecast
    PendingIntent pi = null;
    if (forceRefresh) {
        pi = WeatherUpdateService.getUpdateIntent(this, true);
    }
    if (pi == null) {
        Intent i = new Intent(this, ClockWidgetProvider.class);
        i.setAction(Constants.ACTION_SHOW_FORECAST);
        pi = PendingIntent.getBroadcast(this, 0, i, PendingIntent.FLAG_UPDATE_CURRENT);
    }
    weatherViews.setOnClickPendingIntent(R.id.weather_panel, pi);
}
#method_after
private void setWeatherClickListener(RemoteViews weatherViews) {
    PendingIntent pi = PendingIntent.getActivity(mContext, 0, new Intent("cyanogenmod.intent.action.MANAGE_WEATHER_PROVIDER_SERVICES"), PendingIntent.FLAG_UPDATE_CURRENT);
    weatherViews.setOnClickPendingIntent(R.id.weather_panel, pi);
}
#end_block

#method_before
public static String resolveWindDirection(Context context, float windDirection) {
    int resId;
    if (windDirection < 0)
        resId = R.string.unknown;
    else if (windDirection < 23)
        resId = R.string.weather_N;
    else if (windDirection < 68)
        resId = R.string.weather_NE;
    else if (windDirection < 113)
        resId = R.string.weather_E;
    else if (windDirection < 158)
        resId = R.string.weather_SE;
    else if (windDirection < 203)
        resId = R.string.weather_S;
    else if (windDirection < 248)
        resId = R.string.weather_SW;
    else if (windDirection < 293)
        resId = R.string.weather_W;
    else if (windDirection < 338)
        resId = R.string.weather_NW;
    else
        resId = R.string.weather_N;
    return context.getString(resId);
}
#method_after
public static String resolveWindDirection(Context context, double windDirection) {
    int resId;
    if (windDirection < 0) {
        resId = R.string.unknown;
    } else if (windDirection < DIRECTION_NORTH) {
        resId = R.string.weather_N;
    } else if (windDirection < DIRECTION_NORTH_EAST) {
        resId = R.string.weather_NE;
    } else if (windDirection < DIRECTION_EAST) {
        resId = R.string.weather_E;
    } else if (windDirection < DIRECTION_SOUTH_EAST) {
        resId = R.string.weather_SE;
    } else if (windDirection < DIRECTION_SOUTH) {
        resId = R.string.weather_S;
    } else if (windDirection < DIRECTION_SOUTH_WEST) {
        resId = R.string.weather_SW;
    } else if (windDirection < DIRECTION_WEST) {
        resId = R.string.weather_W;
    } else if (windDirection < DIRECTION_NORTH_WEST) {
        resId = R.string.weather_NW;
    } else {
        resId = R.string.weather_N;
    }
    return context.getString(resId);
}
#end_block

#method_before
public static String resolveWeatherCondition(Context context, int conditionCode) {
    final Resources res = context.getResources();
    final int resId = res.getIdentifier("weather_" + conditionCode, "string", context.getPackageName());
    if (resId != 0) {
        return res.getString(resId);
    }
    return "";
}
#method_after
public static String resolveWeatherCondition(Context context, int conditionCode) {
    final Resources res = context.getResources();
    final int resId = res.getIdentifier("weather_" + Utils.addOffsetToConditionCodeFromWeatherContract(conditionCode), "string", context.getPackageName());
    if (resId != 0) {
        return res.getString(resId);
    }
    return "";
}
#end_block

#method_before
@SuppressLint("SetJavaScriptEnabled")
public static View buildFullPanel(Context context, int resourceId, WeatherInfo w) {
    // Load some basic settings
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    int color = Preferences.weatherFontColor(context);
    boolean invertLowHigh = Preferences.invertLowHighTemperature(context);
    View view = inflater.inflate(resourceId, null);
    // Set the weather source
    TextView weatherSource = (TextView) view.findViewById(R.id.weather_source);
    final CMWeatherManager cmWeatherManager = CMWeatherManager.getInstance(context);
    String activeWeatherLabel = cmWeatherManager.getActiveWeatherServiceProviderLabel();
    weatherSource.setText(activeWeatherLabel != null ? activeWeatherLabel : "");
    // Set the current conditions
    // Weather Image
    ImageView weatherImage = (ImageView) view.findViewById(R.id.weather_image);
    String iconsSet = Preferences.getWeatherIconSet(context);
    weatherImage.setImageBitmap(IconUtils.getWeatherIconBitmap(context, iconsSet, color, w.getConditionCode(), IconUtils.getNextHigherDensity(context)));
    // Weather Condition
    TextView weatherCondition = (TextView) view.findViewById(R.id.weather_condition);
    weatherCondition.setText(Utils.resolveWeatherCondition(context, w.getConditionCode()));
    // Weather Temps
    TextView weatherTemp = (TextView) view.findViewById(R.id.weather_temp);
    weatherTemp.setText(WeatherUtils.formatTemperature(w.getTemperature(), w.getTemperatureUnit()));
    // City
    TextView city = (TextView) view.findViewById(R.id.weather_city);
    city.setText(w.getCity());
    // Weather Update Time
    Date lastUpdate = new Date(w.getTimestamp());
    StringBuilder sb = new StringBuilder();
    sb.append(DateFormat.format("E", lastUpdate));
    sb.append(" ");
    sb.append(DateFormat.getTimeFormat(context).format(lastUpdate));
    TextView updateTime = (TextView) view.findViewById(R.id.update_time);
    updateTime.setText(sb.toString());
    updateTime.setVisibility(Preferences.showWeatherTimestamp(context) ? View.VISIBLE : View.GONE);
    // Weather Temps Panel additional items
    // All temperatures are reported with the same unit, so it's safe to use the temperature
    // unit from the weather info object
    final String low = WeatherUtils.formatTemperature(w.getTodaysLow(), w.getTemperatureUnit());
    final String high = WeatherUtils.formatTemperature(w.getTodaysHigh(), w.getTemperatureUnit());
    TextView weatherLowHigh = (TextView) view.findViewById(R.id.weather_low_high);
    weatherLowHigh.setText(invertLowHigh ? high + " | " + low : low + " | " + high);
    // Get things ready
    LinearLayout forecastView = (LinearLayout) view.findViewById(R.id.forecast_view);
    final View progressIndicator = view.findViewById(R.id.progress_indicator);
    // Build the forecast panel
    if (buildSmallPanel(context, forecastView, w)) {
        // Success, hide the progress container
        progressIndicator.setVisibility(View.GONE);
    }
    return view;
}
#method_after
@SuppressLint("SetJavaScriptEnabled")
public static View buildFullPanel(Context context, int resourceId, WeatherInfo w) {
    // Load some basic settings
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    int color = Preferences.weatherFontColor(context);
    boolean invertLowHigh = Preferences.invertLowHighTemperature(context);
    final boolean useMetric = Preferences.useMetricUnits(context);
    // Make any conversion needed in case the data was not provided in the desired unit
    double temp = w.getTemperature();
    double todaysLow = w.getTodaysLow();
    double todaysHigh = w.getTodaysHigh();
    int tempUnit = w.getTemperatureUnit();
    if (tempUnit == FAHRENHEIT && useMetric) {
        temp = WeatherUtils.fahrenheitToCelsius(temp);
        todaysLow = WeatherUtils.fahrenheitToCelsius(todaysLow);
        todaysHigh = WeatherUtils.fahrenheitToCelsius(todaysHigh);
        tempUnit = CELSIUS;
    } else if (tempUnit == CELSIUS && !useMetric) {
        temp = WeatherUtils.celsiusToFahrenheit(temp);
        todaysLow = WeatherUtils.celsiusToFahrenheit(todaysLow);
        todaysHigh = WeatherUtils.celsiusToFahrenheit(todaysHigh);
        tempUnit = FAHRENHEIT;
    }
    double windSpeed = w.getWindSpeed();
    int windSpeedUnit = w.getWindSpeedUnit();
    if (windSpeedUnit == MPH && useMetric) {
        windSpeedUnit = KPH;
        windSpeed = Utils.milesToKilometers(windSpeed);
    } else if (windSpeedUnit == KPH && !useMetric) {
        windSpeedUnit = MPH;
        windSpeed = Utils.kilometersToMiles(windSpeed);
    }
    View view = inflater.inflate(resourceId, null);
    // Set the weather source
    TextView weatherSource = (TextView) view.findViewById(R.id.weather_source);
    final CMWeatherManager cmWeatherManager = CMWeatherManager.getInstance(context);
    String activeWeatherLabel = cmWeatherManager.getActiveWeatherServiceProviderLabel();
    weatherSource.setText(activeWeatherLabel != null ? activeWeatherLabel : "");
    // Set the current conditions
    // Weather Image
    ImageView weatherImage = (ImageView) view.findViewById(R.id.weather_image);
    String iconsSet = Preferences.getWeatherIconSet(context);
    weatherImage.setImageBitmap(IconUtils.getWeatherIconBitmap(context, iconsSet, color, w.getConditionCode(), IconUtils.getNextHigherDensity(context)));
    // Weather Condition
    TextView weatherCondition = (TextView) view.findViewById(R.id.weather_condition);
    weatherCondition.setText(Utils.resolveWeatherCondition(context, w.getConditionCode()));
    // Weather Temps
    TextView weatherTemp = (TextView) view.findViewById(R.id.weather_temp);
    weatherTemp.setText(WeatherUtils.formatTemperature(temp, tempUnit));
    // Humidity and Wind
    TextView weatherHumWind = (TextView) view.findViewById(R.id.weather_hum_wind);
    weatherHumWind.setText(Utils.formatHumidity(w.getHumidity()) + ", " + Utils.formatWindSpeed(context, windSpeed, windSpeedUnit) + " " + Utils.resolveWindDirection(context, w.getWindDirection()));
    // City
    TextView city = (TextView) view.findViewById(R.id.weather_city);
    city.setText(w.getCity());
    // Weather Update Time
    Date lastUpdate = new Date(w.getTimestamp());
    StringBuilder sb = new StringBuilder();
    sb.append(DateFormat.format("E", lastUpdate));
    sb.append(" ");
    sb.append(DateFormat.getTimeFormat(context).format(lastUpdate));
    TextView updateTime = (TextView) view.findViewById(R.id.update_time);
    updateTime.setText(sb.toString());
    updateTime.setVisibility(Preferences.showWeatherTimestamp(context) ? View.VISIBLE : View.GONE);
    // Weather Temps Panel additional items
    final String low = WeatherUtils.formatTemperature(todaysLow, tempUnit);
    final String high = WeatherUtils.formatTemperature(todaysHigh, tempUnit);
    TextView weatherLowHigh = (TextView) view.findViewById(R.id.weather_low_high);
    weatherLowHigh.setText(invertLowHigh ? high + " | " + low : low + " | " + high);
    // Get things ready
    LinearLayout forecastView = (LinearLayout) view.findViewById(R.id.forecast_view);
    final View progressIndicator = view.findViewById(R.id.progress_indicator);
    // Build the forecast panel
    if (buildSmallPanel(context, forecastView, w)) {
        // Success, hide the progress container
        progressIndicator.setVisibility(View.GONE);
    } else {
    // TODO: Display a text notifying the user that the forecast data is not available
    // rather than keeping the indicator spinning forever
    }
    return view;
}
#end_block

#method_before
public static boolean buildSmallPanel(Context context, LinearLayout smallPanel, WeatherInfo w) {
    if (smallPanel == null) {
        Log.d(TAG, "Invalid view passed");
        return false;
    }
    // Get things ready
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    int color = Preferences.weatherFontColor(context);
    boolean invertLowHigh = Preferences.invertLowHighTemperature(context);
    List<DayForecast> forecasts = w.getForecasts();
    if (forecasts == null || forecasts.size() <= 1) {
        smallPanel.setVisibility(View.GONE);
        return false;
    }
    TimeZone MyTimezone = TimeZone.getDefault();
    Calendar calendar = new GregorianCalendar(MyTimezone);
    // Iterate through the forecasts
    for (DayForecast d : forecasts) {
        // Load the views
        View forecastItem = inflater.inflate(R.layout.forecast_item, null);
        // The day of the week
        TextView day = (TextView) forecastItem.findViewById(R.id.forecast_day);
        day.setText(calendar.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.SHORT, Locale.getDefault()));
        calendar.roll(Calendar.DAY_OF_WEEK, true);
        // Weather Image
        ImageView image = (ImageView) forecastItem.findViewById(R.id.weather_image);
        String iconsSet = Preferences.getWeatherIconSet(context);
        final int resId = IconUtils.getWeatherIconResource(context, iconsSet, w.getConditionCode());
        if (resId != 0) {
            image.setImageResource(resId);
        } else {
            image.setImageBitmap(IconUtils.getWeatherIconBitmap(context, iconsSet, color, d.getConditionCode()));
        }
        // Temperatures
        String dayLow = WeatherUtils.formatTemperature(d.getLow(), w.getTemperatureUnit());
        String dayHigh = WeatherUtils.formatTemperature(d.getHigh(), w.getTemperatureUnit());
        TextView temps = (TextView) forecastItem.findViewById(R.id.weather_temps);
        temps.setText(invertLowHigh ? dayHigh + " " + dayLow : dayLow + " " + dayHigh);
        // Add the view
        smallPanel.addView(forecastItem, new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1));
    }
    return true;
}
#method_after
public static boolean buildSmallPanel(Context context, LinearLayout smallPanel, WeatherInfo w) {
    if (smallPanel == null) {
        Log.d(TAG, "Invalid view passed");
        return false;
    }
    // Get things ready
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    int color = Preferences.weatherFontColor(context);
    boolean invertLowHigh = Preferences.invertLowHighTemperature(context);
    final boolean useMetric = Preferences.useMetricUnits(context);
    List<DayForecast> forecasts = w.getForecasts();
    if (forecasts == null || forecasts.size() <= 1) {
        smallPanel.setVisibility(View.GONE);
        return false;
    }
    TimeZone MyTimezone = TimeZone.getDefault();
    Calendar calendar = new GregorianCalendar(MyTimezone);
    int weatherTempUnit = w.getTemperatureUnit();
    // Iterate through the forecasts
    for (DayForecast d : forecasts) {
        // Load the views
        View forecastItem = inflater.inflate(R.layout.forecast_item, null);
        // The day of the week
        TextView day = (TextView) forecastItem.findViewById(R.id.forecast_day);
        day.setText(calendar.getDisplayName(Calendar.DAY_OF_WEEK, Calendar.SHORT, Locale.getDefault()));
        calendar.roll(Calendar.DAY_OF_WEEK, true);
        // Weather Image
        ImageView image = (ImageView) forecastItem.findViewById(R.id.weather_image);
        String iconsSet = Preferences.getWeatherIconSet(context);
        final int resId = IconUtils.getWeatherIconResource(context, iconsSet, d.getConditionCode());
        if (resId != 0) {
            image.setImageResource(resId);
        } else {
            image.setImageBitmap(IconUtils.getWeatherIconBitmap(context, iconsSet, color, d.getConditionCode()));
        }
        // Temperatures
        double lowTemp = d.getLow();
        double highTemp = d.getHigh();
        int tempUnit = weatherTempUnit;
        if (weatherTempUnit == FAHRENHEIT && useMetric) {
            lowTemp = WeatherUtils.fahrenheitToCelsius(lowTemp);
            highTemp = WeatherUtils.fahrenheitToCelsius(highTemp);
            tempUnit = CELSIUS;
        } else if (weatherTempUnit == CELSIUS && !useMetric) {
            lowTemp = WeatherUtils.celsiusToFahrenheit(lowTemp);
            highTemp = WeatherUtils.celsiusToFahrenheit(highTemp);
            tempUnit = FAHRENHEIT;
        }
        String dayLow = WeatherUtils.formatTemperature(lowTemp, tempUnit);
        String dayHigh = WeatherUtils.formatTemperature(highTemp, tempUnit);
        TextView temps = (TextView) forecastItem.findViewById(R.id.weather_temps);
        temps.setText(invertLowHigh ? dayHigh + " " + dayLow : dayLow + " " + dayHigh);
        // Add the view
        smallPanel.addView(forecastItem, new LinearLayout.LayoutParams(0, LinearLayout.LayoutParams.WRAP_CONTENT, 1));
    }
    return true;
}
#end_block

#method_before
@Override
public void setEnabled(boolean isEnabled, boolean isVisible) {
    View view = getView();
    if (view.getVisibility() != View.VISIBLE) {
        if (isVisible) {
            view.setVisibility(View.VISIBLE);
        }
    } else if (!isVisible) {
        view.setVisibility(View.INVISIBLE);
    }
    // The main end-call button spanning across the screen.
    mEndCallButton.setEnabled(isEnabled);
    // The smaller buttons laid out horizontally just below the end-call button.
    mMuteButton.setEnabled(isEnabled);
    mAudioButton.setEnabled(isEnabled);
    mHoldButton.setEnabled(isEnabled);
    mShowDialpadButton.setEnabled(isEnabled);
    mMergeButton.setEnabled(isEnabled);
    mAddCallButton.setEnabled(isEnabled);
    mSwapButton.setEnabled(isEnabled);
    mBlacklistButton.setEnabled(isEnabled);
}
#method_after
@Override
public void setEnabled(boolean isEnabled, boolean isVisible) {
    getView().setVisibility(isVisible ? View.VISIBLE : View.INVISIBLE);
    // The main end-call button spanning across the screen.
    mEndCallButton.setEnabled(isEnabled);
    // The smaller buttons laid out horizontally just below the end-call button.
    mMuteButton.setEnabled(isEnabled);
    mAudioButton.setEnabled(isEnabled);
    mHoldButton.setEnabled(isEnabled);
    mShowDialpadButton.setEnabled(isEnabled);
    mMergeButton.setEnabled(isEnabled);
    mAddCallButton.setEnabled(isEnabled);
    mSwapButton.setEnabled(isEnabled);
    mBlacklistButton.setEnabled(isEnabled);
}
#end_block

#method_before
@Override
public void onClick(View v) {
    // toggle recording depending on button state
    final CallRecorder recorder = CallRecorder.getInstance(getContext());
    if (recorder.isRecording()) {
        recorder.finishRecording();
    } else {
        Call call = CallList.getInstance().getActiveCall();
        // can't start recording with no active call
        if (call != null) {
            recorder.startRecording(call.getNumber(), call.getCreateTime());
        }
    }
    updateDrawable();
}
#method_after
@Override
public void onClick(View v) {
    // toggle recording depending on button state
    final CallRecorder recorder = CallRecorder.getInstance();
    if (recorder.isRecording()) {
        recorder.finishRecording();
    } else {
        Call call = CallList.getInstance().getActiveCall();
        // can't start recording with no active call
        if (call != null) {
            recorder.startRecording(call.getNumber(), call.getCreateTime());
        }
    }
    updateDrawable();
}
#end_block

#method_before
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    CallRecorder.getInstance(getContext()).addRecordingProgressListener(this);
}
#method_after
@Override
protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    CallRecorder.getInstance().addRecordingProgressListener(this);
}
#end_block

#method_before
@Override
protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    CallRecorder.getInstance(getContext()).removeRecordingProgressListener(this);
}
#method_after
@Override
protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    CallRecorder.getInstance().removeRecordingProgressListener(this);
}
#end_block

#method_before
private void updateDrawable() {
    boolean recording = CallRecorder.getInstance(getContext()).isRecording();
    setImageResource(recording ? R.drawable.ic_record_stop_holo_dark : R.drawable.ic_record_holo_dark);
}
#method_after
private void updateDrawable() {
    boolean recording = CallRecorder.getInstance().isRecording();
    setImageResource(recording ? R.drawable.ic_record_stop_holo_dark : R.drawable.ic_record_holo_dark);
}
#end_block

#method_before
@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mPhoneNumber = (TextView) view.findViewById(R.id.phoneNumber);
    mPrimaryName = (TextView) view.findViewById(R.id.name);
    mNumberLabel = (TextView) view.findViewById(R.id.label);
    mSecondaryCallInfo = (ViewStub) view.findViewById(R.id.secondary_call_info);
    mPhoto = (ImageView) view.findViewById(R.id.photo);
    mCallStateLabel = (TextView) view.findViewById(R.id.callStateLabel);
    mCallTypeLabel = (TextView) view.findViewById(R.id.callTypeLabel);
    mElapsedTime = (TextView) view.findViewById(R.id.elapsedTime);
    mProviderInfo = view.findViewById(R.id.providerInfo);
    mProviderLabel = (TextView) view.findViewById(R.id.providerLabel);
    mProviderNumber = (TextView) view.findViewById(R.id.providerAddress);
    mSubscriptionId = (TextView) view.findViewById(R.id.subId);
    mSupplementaryInfoContainer = (ViewGroup) view.findViewById(R.id.supplementary_info_container);
    mVideoCallPanel = (VideoCallPanel) view.findViewById(R.id.videoCallPanel);
    mCallRecordingTimer = (TextView) view.findViewById(R.id.callRecordingTimer);
    CallRecorder recorder = CallRecorder.getInstance(getActivity());
    recorder.addRecordingProgressListener(mRecordingProgressListener);
    ViewGroup photoContainer = (ViewGroup) view.findViewById(R.id.photo_container);
    LayoutTransition transition = photoContainer.getLayoutTransition();
    transition.enableTransitionType(LayoutTransition.CHANGING);
    transition.setAnimateParentHierarchy(false);
    transition.setDuration(200);
}
#method_after
@Override
public void onViewCreated(View view, Bundle savedInstanceState) {
    super.onViewCreated(view, savedInstanceState);
    mPhoneNumber = (TextView) view.findViewById(R.id.phoneNumber);
    mPrimaryName = (TextView) view.findViewById(R.id.name);
    mNumberLabel = (TextView) view.findViewById(R.id.label);
    mSecondaryCallInfo = (ViewStub) view.findViewById(R.id.secondary_call_info);
    mPhoto = (ImageView) view.findViewById(R.id.photo);
    mCallStateLabel = (TextView) view.findViewById(R.id.callStateLabel);
    mCallTypeLabel = (TextView) view.findViewById(R.id.callTypeLabel);
    mElapsedTime = (TextView) view.findViewById(R.id.elapsedTime);
    mProviderInfo = view.findViewById(R.id.providerInfo);
    mProviderLabel = (TextView) view.findViewById(R.id.providerLabel);
    mProviderNumber = (TextView) view.findViewById(R.id.providerAddress);
    mSubscriptionId = (TextView) view.findViewById(R.id.subId);
    mSupplementaryInfoContainer = (ViewGroup) view.findViewById(R.id.supplementary_info_container);
    mVideoCallPanel = (VideoCallPanel) view.findViewById(R.id.videoCallPanel);
    mCallRecordingTimer = (TextView) view.findViewById(R.id.callRecordingTimer);
    CallRecorder recorder = CallRecorder.getInstance();
    recorder.addRecordingProgressListener(mRecordingProgressListener);
    ViewGroup photoContainer = (ViewGroup) view.findViewById(R.id.photo_container);
    LayoutTransition transition = photoContainer.getLayoutTransition();
    transition.enableTransitionType(LayoutTransition.CHANGING);
    transition.setAnimateParentHierarchy(false);
    transition.setDuration(200);
}
#end_block

#method_before
@Override
public void onDestroy() {
    super.onDestroy();
    if (mVideoCallPanel != null) {
        mVideoCallPanel.onDestroy();
        mVideoCallPanel = null;
    }
    CallRecorder recorder = CallRecorder.getInstance(getActivity());
    recorder.removeRecordingProgressListener(mRecordingProgressListener);
}
#method_after
@Override
public void onDestroy() {
    super.onDestroy();
    if (mVideoCallPanel != null) {
        mVideoCallPanel.onDestroy();
        mVideoCallPanel = null;
    }
    CallRecorder recorder = CallRecorder.getInstance();
    recorder.removeRecordingProgressListener(mRecordingProgressListener);
}
#end_block

#method_before
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    final View parent = inflater.inflate(R.layout.call_button_fragment, container, false);
    mExtraRowButton = parent.findViewById(R.id.extraButtonRow);
    mManageConferenceButton = parent.findViewById(R.id.manageConferenceButton);
    mManageConferenceButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            getPresenter().manageConferenceButtonClicked();
        }
    });
    mGenericMergeButton = parent.findViewById(R.id.cdmaMergeButton);
    mGenericMergeButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            getPresenter().mergeClicked();
        }
    });
    mEndCallButton = parent.findViewById(R.id.endButton);
    mEndCallButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            getPresenter().endCallClicked();
        }
    });
    // make the hit target smaller for the end button so that is creates a deadzone
    // along the inside perimeter of the button.
    mEndCallButton.setOnTouchListener(new SmallerHitTargetTouchListener());
    mMuteButton = (ImageButton) parent.findViewById(R.id.muteButton);
    mMuteButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            final ImageButton button = (ImageButton) v;
            getPresenter().muteClicked(!button.isSelected());
        }
    });
    mAudioButton = (ImageButton) parent.findViewById(R.id.audioButton);
    mAudioButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            onAudioButtonClicked();
        }
    });
    mHoldButton = (ImageButton) parent.findViewById(R.id.holdButton);
    mHoldButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            final ImageButton button = (ImageButton) v;
            getPresenter().holdClicked(!button.isSelected());
        }
    });
    mShowDialpadButton = (ToggleButton) parent.findViewById(R.id.dialpadButton);
    mShowDialpadButton.setOnClickListener(this);
    mAddCallButton = (ImageButton) parent.findViewById(R.id.addButton);
    mAddCallButton.setOnClickListener(this);
    mMergeButton = (ImageButton) parent.findViewById(R.id.mergeButton);
    mMergeButton.setOnClickListener(this);
    mSwapButton = (ImageButton) parent.findViewById(R.id.swapButton);
    mSwapButton.setOnClickListener(this);
    mAddParticipantButton = (ImageButton) parent.findViewById(R.id.addParticipant);
    mAddParticipantButton.setOnClickListener(this);
    // "Add to black list" button
    mBlacklistButton = (ImageButton) parent.findViewById(R.id.addBlacklistButton);
    if (BlacklistUtils.isBlacklistEnabled(getActivity())) {
        mBlacklistButton.setVisibility(View.VISIBLE);
        mBlacklistButton.setOnClickListener(this);
    } else {
        mBlacklistButton.setVisibility(View.GONE);
    }
    mModifyCallButton = (ImageButton) parent.findViewById(R.id.modifyCallButton);
    mModifyCallButton.setOnClickListener(this);
    mRecordButton = (CallRecordingButton) parent.findViewById(R.id.recordButton);
    if (CallRecorder.isEnabled()) {
        mRecordButton.setVisibility(View.VISIBLE);
        mRecordButton.setEnabled(false);
        mRecordButton.setOnClickListener(mRecordButton);
    }
    return parent;
}
#method_after
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    final View parent = inflater.inflate(R.layout.call_button_fragment, container, false);
    mExtraRowButton = parent.findViewById(R.id.extraButtonRow);
    mManageConferenceButton = parent.findViewById(R.id.manageConferenceButton);
    mManageConferenceButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            getPresenter().manageConferenceButtonClicked();
        }
    });
    mGenericMergeButton = parent.findViewById(R.id.cdmaMergeButton);
    mGenericMergeButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            getPresenter().mergeClicked();
        }
    });
    mEndCallButton = parent.findViewById(R.id.endButton);
    mEndCallButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            getPresenter().endCallClicked();
        }
    });
    // make the hit target smaller for the end button so that is creates a deadzone
    // along the inside perimeter of the button.
    mEndCallButton.setOnTouchListener(new SmallerHitTargetTouchListener());
    mMuteButton = (ImageButton) parent.findViewById(R.id.muteButton);
    mMuteButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            final ImageButton button = (ImageButton) v;
            getPresenter().muteClicked(!button.isSelected());
        }
    });
    mAudioButton = (ImageButton) parent.findViewById(R.id.audioButton);
    mAudioButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            onAudioButtonClicked();
        }
    });
    mHoldButton = (ImageButton) parent.findViewById(R.id.holdButton);
    mHoldButton.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            final ImageButton button = (ImageButton) v;
            getPresenter().holdClicked(!button.isSelected());
        }
    });
    mShowDialpadButton = (ToggleButton) parent.findViewById(R.id.dialpadButton);
    mShowDialpadButton.setOnClickListener(this);
    mAddCallButton = (ImageButton) parent.findViewById(R.id.addButton);
    mAddCallButton.setOnClickListener(this);
    mMergeButton = (ImageButton) parent.findViewById(R.id.mergeButton);
    mMergeButton.setOnClickListener(this);
    mSwapButton = (ImageButton) parent.findViewById(R.id.swapButton);
    mSwapButton.setOnClickListener(this);
    mAddParticipantButton = (ImageButton) parent.findViewById(R.id.addParticipant);
    mAddParticipantButton.setOnClickListener(this);
    // "Add to black list" button
    mBlacklistButton = (ImageButton) parent.findViewById(R.id.addBlacklistButton);
    if (BlacklistUtils.isBlacklistEnabled(getActivity())) {
        mBlacklistButton.setVisibility(View.VISIBLE);
        mBlacklistButton.setOnClickListener(this);
    } else {
        mBlacklistButton.setVisibility(View.GONE);
    }
    mModifyCallButton = (ImageButton) parent.findViewById(R.id.modifyCallButton);
    mModifyCallButton.setOnClickListener(this);
    mRecordButton = (CallRecordingButton) parent.findViewById(R.id.recordButton);
    mRecordButton.setOnClickListener(mRecordButton);
    return parent;
}
#end_block

#method_before
private void updateUi(InCallState state, Call call) {
    final CallButtonUi ui = getUi();
    if (ui == null) {
        return;
    }
    final boolean isEnabled = state.isConnectingOrConnected() && !state.isIncoming() && call != null;
    final boolean isVisible;
    if (state.isIncoming()) {
        isVisible = false;
    } else if (mShowButtonsIfIdle || state.isConnectingOrConnected()) {
        isVisible = true;
    } else {
        // DISCONNECTING, NO_CALLS
        // Keep UI visible in case it was visible before, don't cause
        // unneccessary layout changes
        isVisible = mStateBeforeDisconnect != null && !mStateBeforeDisconnect.isIncoming() && mStateBeforeDisconnect.isConnectingOrConnected();
    }
    ui.setEnabled(isEnabled, isVisible);
    Log.d(this, "Updating call UI for call: ", call);
    if (isEnabled) {
        Log.v(this, "Show hold ", call.can(Capabilities.SUPPORT_HOLD));
        Log.v(this, "Enable hold", call.can(Capabilities.HOLD));
        Log.v(this, "Show merge ", call.can(Capabilities.MERGE_CALLS));
        Log.v(this, "Show swap ", call.can(Capabilities.SWAP_CALLS));
        Log.v(this, "Show add call ", call.can(Capabilities.ADD_CALL));
        Log.v(this, "Show mute ", call.can(Capabilities.MUTE));
        Log.v(this, "Show modify call ", call.can(Capabilities.MODIFY_CALL));
        final boolean canMerge = call.can(Capabilities.MERGE_CALLS);
        final boolean canAdd = call.can(Capabilities.ADD_CALL);
        final boolean isGenericConference = call.can(Capabilities.GENERIC_CONFERENCE);
        final boolean canModifyCall = call.can(Capabilities.MODIFY_CALL);
        final boolean showMerge = !isGenericConference && canMerge;
        if (showMerge) {
            ui.showMerge(true);
            ui.showAddCall(false);
        } else {
            ui.showMerge(false);
            ui.showAddCall(true);
            ui.enableAddCall(canAdd);
        }
        final boolean canHold = call.can(Capabilities.HOLD);
        final boolean canSwap = call.can(Capabilities.SWAP_CALLS);
        final boolean supportHold = call.can(Capabilities.SUPPORT_HOLD);
        if (canHold) {
            ui.showHold(true);
            ui.setHold(call.getState() == Call.State.ONHOLD);
            ui.enableHold(true);
            ui.showSwap(false);
        } else if (canSwap) {
            ui.showHold(false);
            ui.showSwap(true);
        } else {
            if (supportHold) {
                ui.showHold(true);
                ui.enableHold(false);
                ui.setHold(call.getState() == Call.State.ONHOLD);
                ui.showSwap(false);
            } else {
                ui.showHold(false);
                ui.showSwap(false);
            }
        }
        ui.enableAddParticipant(call.can(Capabilities.ADD_PARTICIPANT));
        ui.enableMute(call.can(Capabilities.MUTE));
        ui.enableModifyCall(canModifyCall);
        ui.showModifyCall(canModifyCall);
        // Finally, update the "extra button row": It's displayed above the
        // "End" button, but only if necessary.  Also, it's never displayed
        // while the dialpad is visible (since it would overlap.)
        // 
        // The row contains two buttons:
        // 
        // - "Manage conference" (used only on GSM devices)
        // - "Merge" button (used only on CDMA devices)
        mShowGenericMerge = isGenericConference && canMerge;
        mShowManageConference = (call.isConferenceCall() && !isGenericConference);
        updateExtraButtonRow();
        ui.enableRecording(CallList.getInstance().getActiveCall() != null);
    }
}
#method_after
private void updateUi(InCallState state, Call call) {
    final CallButtonUi ui = getUi();
    if (ui == null) {
        return;
    }
    final boolean isEnabled = state.isConnectingOrConnected() && !state.isIncoming() && call != null;
    final boolean isVisible;
    if (state.isIncoming()) {
        isVisible = false;
    } else if (mShowButtonsIfIdle || state.isConnectingOrConnected()) {
        isVisible = true;
    } else {
        // DISCONNECTING, NO_CALLS
        // Keep UI visible in case it was visible before, don't cause
        // unneccessary layout changes
        isVisible = mStateBeforeDisconnect != null && !mStateBeforeDisconnect.isIncoming() && mStateBeforeDisconnect.isConnectingOrConnected();
    }
    ui.setEnabled(isEnabled, isVisible);
    Log.d(this, "Updating call UI for call: ", call);
    if (isVisible) {
        Log.v(this, "Show hold ", call.can(Capabilities.SUPPORT_HOLD));
        Log.v(this, "Enable hold", call.can(Capabilities.HOLD));
        Log.v(this, "Show merge ", call.can(Capabilities.MERGE_CALLS));
        Log.v(this, "Show swap ", call.can(Capabilities.SWAP_CALLS));
        Log.v(this, "Show add call ", call.can(Capabilities.ADD_CALL));
        Log.v(this, "Show mute ", call.can(Capabilities.MUTE));
        Log.v(this, "Show modify call ", call.can(Capabilities.MODIFY_CALL));
        final boolean canMerge = call.can(Capabilities.MERGE_CALLS);
        final boolean canAdd = call.can(Capabilities.ADD_CALL);
        final boolean isGenericConference = call.can(Capabilities.GENERIC_CONFERENCE);
        final boolean canModifyCall = call.can(Capabilities.MODIFY_CALL);
        final boolean showMerge = !isGenericConference && canMerge;
        if (showMerge) {
            ui.showMerge(true);
            ui.showAddCall(false);
        } else {
            ui.showMerge(false);
            ui.showAddCall(true);
            ui.enableAddCall(canAdd);
        }
        final boolean canHold = call.can(Capabilities.HOLD);
        final boolean canSwap = call.can(Capabilities.SWAP_CALLS);
        final boolean supportHold = call.can(Capabilities.SUPPORT_HOLD);
        if (canHold) {
            ui.showHold(true);
            ui.setHold(call.getState() == Call.State.ONHOLD);
            ui.enableHold(true);
            ui.showSwap(false);
        } else if (canSwap) {
            ui.showHold(false);
            ui.showSwap(true);
        } else {
            if (supportHold) {
                ui.showHold(true);
                ui.enableHold(false);
                ui.setHold(call.getState() == Call.State.ONHOLD);
                ui.showSwap(false);
            } else {
                ui.showHold(false);
                ui.showSwap(false);
            }
        }
        ui.enableAddParticipant(call.can(Capabilities.ADD_PARTICIPANT));
        ui.enableMute(call.can(Capabilities.MUTE));
        ui.enableModifyCall(canModifyCall);
        ui.showModifyCall(canModifyCall);
        // Finally, update the "extra button row": It's displayed above the
        // "End" button, but only if necessary.  Also, it's never displayed
        // while the dialpad is visible (since it would overlap.)
        // 
        // The row contains two buttons:
        // 
        // - "Manage conference" (used only on GSM devices)
        // - "Merge" button (used only on CDMA devices)
        mShowGenericMerge = isGenericConference && canMerge;
        mShowManageConference = (call.isConferenceCall() && !isGenericConference);
        updateExtraButtonRow();
        boolean canRecord = CallRecorder.getInstance().isEnabled() && CallList.getInstance().getActiveCall() != null;
        ui.showRecording(canRecord);
    }
}
#end_block

#method_before
private boolean isDeviceProvisionedInSettingsDb(Context context) {
    return CMSettings.Secure.getInt(context.getContentResolver(), CMSettings.Secure.CM_SETUP_WIZARD_COMPLETED, 0) != 0;
}
#method_after
private boolean isDeviceProvisionedInSettingsDb(Context context) {
    return (CMSettings.Secure.getInt(context.getContentResolver(), CMSettings.Secure.CM_SETUP_WIZARD_COMPLETED, 0) != 0) && (Settings.Global.getInt(context.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) != 0);
}
#end_block

#method_before
@Override
public void onStateChange(InCallState oldState, InCallState newState, CallList callList) {
    CallButtonUi ui = getUi();
    if (newState == InCallState.OUTGOING) {
        mCall = callList.getOutgoingCall();
    } else if (newState == InCallState.INCALL) {
        mCall = callList.getActiveOrBackgroundCall();
        // the dialpad too.)
        if (ui != null) {
            if (oldState == InCallState.OUTGOING && mCall != null) {
                if (CallerInfoUtils.isVoiceMailNumber(ui.getContext(), mCall)) {
                    ui.displayDialpad(true, /* show */
                    true);
                }
            }
        }
    } else if (newState == InCallState.INCOMING) {
        if (ui != null) {
            ui.displayDialpad(false, /* show */
            true);
        }
        mCall = callList.getIncomingCall();
    } else {
        mCall = null;
    }
    updateUi(newState, mCall);
}
#method_after
@Override
public void onStateChange(InCallState oldState, InCallState newState, CallList callList) {
    CallButtonUi ui = getUi();
    if (newState == InCallState.OUTGOING) {
        mCall = callList.getOutgoingCall();
    } else if (newState == InCallState.INCALL) {
        mCall = callList.getActiveOrBackgroundCall();
        // the dialpad too.)
        if (ui != null) {
            if (oldState == InCallState.OUTGOING && mCall != null) {
                if (CallerInfoUtils.isVoiceMailNumber(ui.getContext(), mCall)) {
                    ui.displayDialpad(true, /* show */
                    true);
                }
            }
        }
    } else if (newState == InCallState.INCOMING) {
        if (ui != null) {
            ui.displayDialpad(false, /* show */
            true);
        }
        mCall = callList.getIncomingCall();
    } else {
        mCall = null;
    }
    if (mCall != null && mPrimaryContactInfo == null) {
        startContactInfoSearch(mCall, true, newState == InCallState.INCOMING);
        getPreferredLinks();
    }
    updateUi(newState, mCall);
}
#end_block

#method_before
private void updateButtonsState(Call call) {
    Log.v(this, "updateButtonsState");
    final CallButtonUi ui = getUi();
    final boolean isVideo = CallUtils.isVideoCall(call);
    // Common functionality (audio, hold, etc).
    // Show either HOLD or SWAP, but not both. If neither HOLD or SWAP is available:
    // (1) If the device normally can hold, show HOLD in a disabled state.
    // (2) If the device doesn't have the concept of hold/swap, remove the button.
    final boolean showSwap = call.can(android.telecom.Call.Details.CAPABILITY_SWAP_CONFERENCE);
    final boolean showHold = !showSwap && call.can(android.telecom.Call.Details.CAPABILITY_SUPPORT_HOLD) && call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
    final boolean isCallOnHold = call.getState() == Call.State.ONHOLD;
    final boolean useExt = QtiCallUtils.useExt(ui.getContext());
    final boolean showAddCall = TelecomAdapter.getInstance().canAddCall();
    final boolean showMerge = call.can(android.telecom.Call.Details.CAPABILITY_MERGE_CONFERENCE);
    final int callState = call.getState();
    List<InCallPluginInfo> contactInCallPlugins = getContactInCallPluginInfoList();
    final boolean showUpgradeToVideo = (!isVideo || useExt) && (QtiCallUtils.hasVideoCapabilities(call) || QtiCallUtils.hasVoiceCapabilities(call) || (contactInCallPlugins != null && !contactInCallPlugins.isEmpty())) && (callState == Call.State.ACTIVE || callState == Call.State.ONHOLD);
    final boolean showNote = callState == Call.State.ACTIVE || callState == Call.State.ONHOLD || callState == Call.State.DIALING;
    final boolean showMute = call.can(android.telecom.Call.Details.CAPABILITY_MUTE);
    final boolean showAddParticipant = call.can(android.telecom.Call.Details.CAPABILITY_ADD_PARTICIPANT);
    final CallRecorder recorder = CallRecorder.getInstance();
    boolean showCallRecordOption = recorder.isEnabled() && !isVideo && call.getState() == Call.State.ACTIVE;
    final boolean showTransferCall = call.can(android.telecom.Call.Details.CAPABILITY_SUPPORTS_TRANSFER);
    ui.showButton(BUTTON_AUDIO, true);
    ui.showButton(BUTTON_SWAP, showSwap);
    ui.showButton(BUTTON_HOLD, showHold);
    ui.showButton(BUTTON_TAKE_NOTE, showNote);
    ui.setHold(isCallOnHold);
    ui.showButton(BUTTON_MUTE, showMute);
    ui.showButton(BUTTON_ADD_CALL, showAddCall);
    ui.showButton(BUTTON_UPGRADE_TO_VIDEO, showUpgradeToVideo);
    ui.showButton(BUTTON_SWITCH_CAMERA, isVideo);
    ui.showButton(BUTTON_PAUSE_VIDEO, isVideo && !useExt);
    ui.showButton(BUTTON_DIALPAD, !isVideo || useExt);
    ui.showButton(BUTTON_MERGE, showMerge);
    ui.showButton(BUTTON_RECORD_CALL, showCallRecordOption);
    ui.showButton(BUTTON_TRANSFER_CALL, showTransferCall);
    ui.enableAddParticipant(showAddParticipant);
    ui.updateButtonStates();
}
#method_after
private void updateButtonsState(Call call) {
    Log.v(this, "updateButtonsState");
    final CallButtonUi ui = getUi();
    final boolean isVideo = CallUtils.isVideoCall(call);
    // Common functionality (audio, hold, etc).
    // Show either HOLD or SWAP, but not both. If neither HOLD or SWAP is available:
    // (1) If the device normally can hold, show HOLD in a disabled state.
    // (2) If the device doesn't have the concept of hold/swap, remove the button.
    final boolean showSwap = call.can(android.telecom.Call.Details.CAPABILITY_SWAP_CONFERENCE);
    final boolean showHold = !showSwap && call.can(android.telecom.Call.Details.CAPABILITY_SUPPORT_HOLD) && call.can(android.telecom.Call.Details.CAPABILITY_HOLD);
    final boolean isCallOnHold = call.getState() == Call.State.ONHOLD;
    final boolean useExt = QtiCallUtils.useExt(ui.getContext());
    final boolean showAddCall = TelecomAdapter.getInstance().canAddCall();
    final boolean showMerge = call.can(android.telecom.Call.Details.CAPABILITY_MERGE_CONFERENCE);
    final int callState = call.getState();
    List<InCallPluginInfo> contactInCallPlugins = getContactInCallPluginInfoList();
    final boolean showUpgradeToVideo = (!isVideo || useExt) && (QtiCallUtils.hasVideoCapabilities(call) || QtiCallUtils.hasVoiceCapabilities(call) || (contactInCallPlugins != null && !contactInCallPlugins.isEmpty())) && (callState == Call.State.ACTIVE || callState == Call.State.ONHOLD) && isDeviceProvisionedInSettingsDb(ui.getContext());
    final boolean showNote = DeepLinkIntegrationManager.getInstance().ambientIsAvailable(getUi().getContext()) && (callState == Call.State.ACTIVE || callState == Call.State.ONHOLD) && mNoteDeepLink != null && isDeviceProvisionedInSettingsDb(ui.getContext());
    final boolean showMute = call.can(android.telecom.Call.Details.CAPABILITY_MUTE);
    final boolean showAddParticipant = call.can(android.telecom.Call.Details.CAPABILITY_ADD_PARTICIPANT);
    final CallRecorder recorder = CallRecorder.getInstance();
    boolean showCallRecordOption = recorder.isEnabled() && !isVideo && call.getState() == Call.State.ACTIVE;
    final boolean showTransferCall = call.can(android.telecom.Call.Details.CAPABILITY_SUPPORTS_TRANSFER);
    ui.showButton(BUTTON_AUDIO, true);
    ui.showButton(BUTTON_SWAP, showSwap);
    ui.showButton(BUTTON_HOLD, showHold);
    ui.showButton(BUTTON_TAKE_NOTE, showNote);
    ui.setHold(isCallOnHold);
    ui.showButton(BUTTON_MUTE, showMute);
    ui.showButton(BUTTON_ADD_CALL, showAddCall);
    ui.showButton(BUTTON_UPGRADE_TO_VIDEO, showUpgradeToVideo);
    if (showUpgradeToVideo) {
        ui.modifyChangeToVideoButton();
    }
    ui.showButton(BUTTON_SWITCH_CAMERA, isVideo);
    ui.showButton(BUTTON_PAUSE_VIDEO, isVideo && !useExt);
    ui.showButton(BUTTON_DIALPAD, !isVideo || useExt);
    ui.showButton(BUTTON_MERGE, showMerge);
    ui.showButton(BUTTON_RECORD_CALL, showCallRecordOption);
    ui.showButton(BUTTON_TRANSFER_CALL, showTransferCall);
    ui.enableAddParticipant(showAddParticipant);
    ui.updateButtonStates();
}
#end_block

#method_before
@Override
public void onContactInfoComplete(String callId, ContactInfoCache.ContactCacheEntry entry) {
    if (DEBUG)
        Log.i(this, "onContactInfoComplete");
    contactUpdated();
}
#method_after
@Override
public void onContactInfoComplete(String callId, ContactInfoCache.ContactCacheEntry entry) {
    if (DEBUG)
        Log.i(this, "onContactInfoComplete");
    mPrimaryContactInfo = entry;
    contactUpdated();
}
#end_block

#method_before
public void takeNote() {
    if (mCall != null && mNoteDeepLink != null) {
        CallDeepLinkContent content = new CallDeepLinkContent(mNoteDeepLink);
        content.setName(mCall.getCnapName() == null ? "Unknown" : mCall.getCnapName());
        content.setNumber(mCall.getNumber());
        content.setUri(DeepLinkIntegrationManager.generateCallUri(mCall.getNumber(), mCall.getTelecommCall().getDetails().getCreateTimeMillis()));
        getUi().getContext().startActivity(content.build());
    }
}
#method_after
public void takeNote() {
    if (mCall != null && mNoteDeepLink != null) {
        Context ctx = getUi().getContext();
        android.telecom.Call.Details details = mCall.getTelecommCall().getDetails();
        CallDeepLinkContent content = new CallDeepLinkContent(mNoteDeepLink);
        content.setName(TextUtils.isEmpty(mPrimaryContactInfo.name) ? ctx.getString(R.string.deeplink_unknown_caller) : mPrimaryContactInfo.name);
        content.setNumber(mCall.getNumber());
        content.setUri(DeepLinkIntegrationManager.generateCallUri(mCall.getNumber(), details.getCreateTimeMillis()));
        DeepLinkIntegrationManager.getInstance().sendContentSentEvent(ctx, mNoteDeepLink, new ComponentName(ctx, CallButtonPresenter.class));
        ctx.startActivity(content.build());
    }
}
#end_block

#method_before
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    final View parent = inflater.inflate(R.layout.call_button_fragment, container, false);
    mAudioButton = (CompoundButton) parent.findViewById(R.id.audioButton);
    mAudioButton.setOnClickListener(this);
    mMuteButton = (CompoundButton) parent.findViewById(R.id.muteButton);
    mMuteButton.setOnClickListener(this);
    mShowDialpadButton = (CompoundButton) parent.findViewById(R.id.dialpadButton);
    mShowDialpadButton.setOnClickListener(this);
    mHoldButton = (CompoundButton) parent.findViewById(R.id.holdButton);
    mHoldButton.setOnClickListener(this);
    mSwapButton = (ImageButton) parent.findViewById(R.id.swapButton);
    mSwapButton.setOnClickListener(this);
    mChangeToVideoButton = (ImageButton) parent.findViewById(R.id.changeToVideoButton);
    mChangeToVideoButton.setOnClickListener(this);
    mSwitchCameraButton = (CompoundButton) parent.findViewById(R.id.switchCameraButton);
    mSwitchCameraButton.setOnClickListener(this);
    mAddCallButton = (ImageButton) parent.findViewById(R.id.addButton);
    mAddCallButton.setOnClickListener(this);
    mMergeButton = (ImageButton) parent.findViewById(R.id.mergeButton);
    mMergeButton.setOnClickListener(this);
    mPauseVideoButton = (CompoundButton) parent.findViewById(R.id.pauseVideoButton);
    mPauseVideoButton.setOnClickListener(this);
    mCallRecordButton = (CompoundButton) parent.findViewById(R.id.callRecordButton);
    mCallRecordButton.setOnClickListener(this);
    mAddParticipantButton = (ImageButton) parent.findViewById(R.id.addParticipant);
    mAddParticipantButton.setOnClickListener(this);
    mTransferCallButton = (ImageButton) parent.findViewById(R.id.transferCall);
    mTransferCallButton.setOnClickListener(this);
    mOverflowButton = (ImageButton) parent.findViewById(R.id.overflowButton);
    mOverflowButton.setOnClickListener(this);
    mManageVideoCallConferenceButton = (ImageButton) parent.findViewById(R.id.manageVideoCallConferenceButton);
    mManageVideoCallConferenceButton.setOnClickListener(this);
    mTakeNoteButton = (ImageButton) parent.findViewById(R.id.takeNoteButton);
    getPresenter().getPrefferedLinks();
    return parent;
}
#method_after
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    final View parent = inflater.inflate(R.layout.call_button_fragment, container, false);
    mAudioButton = (CompoundButton) parent.findViewById(R.id.audioButton);
    mAudioButton.setOnClickListener(this);
    mMuteButton = (CompoundButton) parent.findViewById(R.id.muteButton);
    mMuteButton.setOnClickListener(this);
    mShowDialpadButton = (CompoundButton) parent.findViewById(R.id.dialpadButton);
    mShowDialpadButton.setOnClickListener(this);
    mHoldButton = (CompoundButton) parent.findViewById(R.id.holdButton);
    mHoldButton.setOnClickListener(this);
    mSwapButton = (ImageButton) parent.findViewById(R.id.swapButton);
    mSwapButton.setOnClickListener(this);
    mChangeToVideoButton = (ImageButton) parent.findViewById(R.id.changeToVideoButton);
    mChangeToVideoButton.setOnClickListener(this);
    mSwitchCameraButton = (CompoundButton) parent.findViewById(R.id.switchCameraButton);
    mSwitchCameraButton.setOnClickListener(this);
    mAddCallButton = (ImageButton) parent.findViewById(R.id.addButton);
    mAddCallButton.setOnClickListener(this);
    mMergeButton = (ImageButton) parent.findViewById(R.id.mergeButton);
    mMergeButton.setOnClickListener(this);
    mPauseVideoButton = (CompoundButton) parent.findViewById(R.id.pauseVideoButton);
    mPauseVideoButton.setOnClickListener(this);
    mCallRecordButton = (CompoundButton) parent.findViewById(R.id.callRecordButton);
    mCallRecordButton.setOnClickListener(this);
    mAddParticipantButton = (ImageButton) parent.findViewById(R.id.addParticipant);
    mAddParticipantButton.setOnClickListener(this);
    mTransferCallButton = (ImageButton) parent.findViewById(R.id.transferCall);
    mTransferCallButton.setOnClickListener(this);
    mOverflowButton = (ImageButton) parent.findViewById(R.id.overflowButton);
    mOverflowButton.setOnClickListener(this);
    mManageVideoCallConferenceButton = (ImageButton) parent.findViewById(R.id.manageVideoCallConferenceButton);
    mManageVideoCallConferenceButton.setOnClickListener(this);
    mTakeNoteButton = (ImageButton) parent.findViewById(R.id.takeNoteButton);
    mTakeNoteButton.setOnClickListener(this);
    return parent;
}
#end_block

#method_before
@Override
public void displayVideoCallOptions() {
    CallButtonPresenter.CallButtonUi ui = getUi();
    if (ui == null) {
        Log.e(this, "Cannot display VideoCallOptions as ui is null");
        return;
    }
    Context context = getContext();
    final ArrayList<Drawable> icons = new ArrayList<Drawable>();
    final ArrayList<String> items = new ArrayList<String>();
    final ArrayList<Integer> itemToCallType = new ArrayList<Integer>();
    final Resources res = ui.getContext().getResources();
    // Prepare the string array and mapping.
    List<InCallPluginInfo> contactInCallPlugins = getPresenter().getContactInCallPluginInfoList();
    if (contactInCallPlugins != null && !contactInCallPlugins.isEmpty()) {
        int i = 0;
        for (InCallPluginInfo info : contactInCallPlugins) {
            items.add(info.getPluginTitle());
            icons.add(info.getPluginColorIcon());
            itemToCallType.add(i++);
        }
    }
    boolean canVideoCall = getPresenter().canVideoCall();
    if (canVideoCall) {
        // First item, if available is VT IMS call
        items.add(res.getString(R.string.modify_call_option_vt));
        Drawable icon = res.getDrawable(R.drawable.ic_toolbar_video);
        icon.setTint(res.getColor(R.color.vidoecall_handoff_default_video_call_color));
        icons.add(icon);
        itemToCallType.add(-1);
    }
    ListAdapter adapter = new ListItemWithImageArrayAdapter(context.getApplicationContext(), R.layout.videocall_handoff_item, items, icons);
    DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int item) {
            final int selCallType = itemToCallType.get(item);
            if (selCallType < 0) {
                // VT Call selected
                getPresenter().changeToVideoClicked();
            } else {
                // InCall Plugin selected
                getPresenter().handoverCallToVoIPPlugin(selCallType);
            }
            dialog.dismiss();
        }
    };
    AlertDialog.Builder builder = new AlertDialog.Builder(getUi().getContext());
    builder.setTitle(R.string.video_call_option_title);
    builder.setAdapter(adapter, listener);
    final AlertDialog alert;
    alert = builder.create();
    alert.show();
}
#method_after
@Override
public void displayVideoCallOptions() {
    CallButtonPresenter.CallButtonUi ui = getUi();
    if (ui == null) {
        Log.e(this, "Cannot display VideoCallOptions as ui is null");
        return;
    }
    Context context = getContext();
    final ArrayList<Drawable> icons = new ArrayList<Drawable>();
    final ArrayList<String> items = new ArrayList<String>();
    final ArrayList<Integer> itemToCallType = new ArrayList<Integer>();
    final Resources res = ui.getContext().getResources();
    // Prepare the string array and mapping.
    List<InCallPluginInfo> contactInCallPlugins = getPresenter().getContactInCallPluginInfoList();
    if (contactInCallPlugins != null && !contactInCallPlugins.isEmpty()) {
        int i = 0;
        for (InCallPluginInfo info : contactInCallPlugins) {
            items.add(info.getPluginTitle());
            icons.add(info.getPluginBrandIcon());
            itemToCallType.add(i++);
        }
    }
    boolean canVideoCall = getPresenter().canVideoCall();
    if (canVideoCall) {
        // First item, if available is VT IMS call
        items.add(res.getString(R.string.modify_call_option_vt));
        Drawable icon = res.getDrawable(R.drawable.ic_toolbar_video);
        icon.setTint(res.getColor(R.color.vidoecall_handoff_default_video_call_color));
        icons.add(icon);
        itemToCallType.add(-1);
    }
    ListAdapter adapter = new ListItemWithImageArrayAdapter(context.getApplicationContext(), R.layout.videocall_handoff_item, items, icons);
    DialogInterface.OnClickListener listener = new DialogInterface.OnClickListener() {

        public void onClick(DialogInterface dialog, int item) {
            final int selCallType = itemToCallType.get(item);
            if (selCallType < 0) {
                // VT Call selected
                getPresenter().changeToVideoClicked();
            } else {
                // InCall Plugin selected
                getPresenter().handoverCallToVoIPPlugin(selCallType);
            }
            dialog.dismiss();
        }
    };
    AlertDialog.Builder builder = new AlertDialog.Builder(getUi().getContext());
    builder.setTitle(R.string.video_call_option_title);
    builder.setAdapter(adapter, listener);
    final AlertDialog alert;
    alert = builder.create();
    alert.show();
}
#end_block

#method_before
@Override
public void setDeepLinkNoteIcon(Drawable d) {
    if (d == null) {
        mTakeNoteButton.setVisibility(View.GONE);
    } else {
        mTakeNoteButton.setImageDrawable(d);
        mTakeNoteButton.setOnClickListener(CallButtonFragment.this);
    }
}
#method_after
@Override
public void setDeepLinkNoteIcon(Drawable d) {
    if (d == null) {
        mTakeNoteButton.setVisibility(View.GONE);
    } else {
        mTakeNoteButton.setImageDrawable(d);
    }
}
#end_block

#method_before
public boolean setValue(String value) {
    if (mDataType != TYPE_ASCII && mDataType != TYPE_UNDEFINED) {
        return false;
    }
    byte[] buf = value.getBytes(US_ASCII);
    byte[] finalBuf = buf;
    if (mDataType == TYPE_ASCII) {
        if (buf.length > 0) {
            if (buf[buf.length - 1] != 0) {
                finalBuf = Arrays.copyOf(buf, buf.length + 1);
                // add 1 to the count to pass the check
                if (mComponentCountActual == buf.length)
                    mComponentCountActual++;
            }
        } else if (mComponentCountActual == 1) {
            finalBuf = new byte[] { 0 };
        }
    }
    int count = finalBuf.length;
    if (checkBadComponentCount(count)) {
        return false;
    }
    mComponentCountActual = count;
    mValue = finalBuf;
    return true;
}
#method_after
public boolean setValue(String value) {
    if (mDataType != TYPE_ASCII && mDataType != TYPE_UNDEFINED) {
        return false;
    }
    byte[] buf = value.getBytes(US_ASCII);
    byte[] finalBuf = buf;
    if (mDataType == TYPE_ASCII) {
        if (buf.length > 0) {
            if (buf[buf.length - 1] != 0) {
                finalBuf = Arrays.copyOf(buf, buf.length + 1);
                // termination character
                if (mComponentCountActual == buf.length) {
                    mComponentCountActual++;
                }
            }
        } else if (mComponentCountActual == 1) {
            finalBuf = new byte[] { 0 };
        }
    }
    int count = finalBuf.length;
    if (checkBadComponentCount(count)) {
        return false;
    }
    mComponentCountActual = count;
    mValue = finalBuf;
    return true;
}
#end_block

#method_before
private String exifDateToFormatedDate(String exifDt) {
    SimpleDateFormat format = new SimpleDateFormat("yyyy:MM:dd HH:mm:ss");
    Date date;
    try {
        date = format.parse(exifDt);
    } catch (ParseException e) {
        return exifDt;
    }
    DateFormat formater = DateFormat.getDateTimeInstance();
    return formater.format(date);
}
#method_after
private String exifDateToFormatedDate(String exifDt) {
    try {
        Date date = ExifInterface.DATETIME_FORMAT.parse(exifDt);
        return DateFormat.getDateTimeInstance().format(date);
    } catch (ParseException e) {
        return exifDt;
    }
}
#end_block

#method_before
private void startPatchOrRender() {
    ArrayList<AudioPatch> patches = new ArrayList<AudioPatch>();
    mAudioManager.listAudioPatches(patches);
    if (mAudioPatch == null) {
        if (isPatchMixerToEarphone(patches)) {
            int status;
            stopAudioTrack();
            stopRender();
            status = createAudioPatch();
            if (status != AudioManager.SUCCESS) {
                Log.d(TAG, "startPatchOrRender: fallback as createAudioPatch failed");
                startRender();
            }
        } else {
            if (!isRendering()) {
                startRender();
            }
        }
    }
}
#method_after
private void startPatchOrRender() {
    ArrayList<AudioPatch> patches = new ArrayList<AudioPatch>();
    mAudioManager.listAudioPatches(patches);
    if (mAudioPatch == null) {
        if (isPatchMixerToEarphone(patches)) {
            int status;
            stopAudioTrack();
            stopRender();
            status = createAudioPatch();
            if (status != AudioManager.SUCCESS) {
                Log.d(TAG, "startPatchOrRender: fallback as createAudioPatch failed");
                startRender();
            }
        } else {
            startRender();
        }
    }
}
#end_block

#method_before
private void init() {
    Log.i(TAG, "Starting AudioRecorder with format=" + mInputFormat + ". Saving to: " + mFilePath);
    calculateInputRate();
    mRequestedFormat = new MediaFormat();
    mRequestedFormat.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm");
    mRequestedFormat.setInteger(MediaFormat.KEY_BIT_RATE, 128000);
    mRequestedFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, mInputFormat.getChannelCount());
    mRequestedFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, mInputFormat.getSampleRate());
    mRequestedFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC);
    try {
        mCodec = MediaCodec.createEncoderByType("audio/mp4a-latm");
    } catch (IOException ex) {
        onError("failed creating encoder", ex);
        return;
    }
    mCodec.setCallback(new AudioRecorderCodecCallback(), new Handler(getLooper()));
    mCodec.configure(mRequestedFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
    mCodec.start();
    try {
        mMuxer = new MediaMuxer(mFilePath.getAbsolutePath(), MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);
    } catch (IOException ex) {
        onError("failed creating muxer", ex);
        return;
    }
    mOutFormat = mCodec.getOutputFormat();
    mMuxerTrack = mMuxer.addTrack(mOutFormat);
    mMuxer.start();
}
#method_after
private void init() {
    Log.i(TAG, "Starting AudioRecorder with format=" + mInputFormat + ". Saving to: " + mFilePath);
    calculateInputRate();
    mRequestedFormat = new MediaFormat();
    mRequestedFormat.setString(MediaFormat.KEY_MIME, "audio/mp4a-latm");
    mRequestedFormat.setInteger(MediaFormat.KEY_BIT_RATE, 128000);
    mRequestedFormat.setInteger(MediaFormat.KEY_CHANNEL_COUNT, mInputFormat.getChannelCount());
    mRequestedFormat.setInteger(MediaFormat.KEY_SAMPLE_RATE, mInputFormat.getSampleRate());
    mRequestedFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectHE);
    try {
        mCodec = MediaCodec.createEncoderByType("audio/mp4a-latm");
    } catch (IOException e) {
        onError("failed creating encoder", e);
        return;
    }
    mCodec.setCallback(new AudioRecorderCodecCallback(), new Handler(getLooper()));
    mCodec.configure(mRequestedFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE);
    mCodec.start();
    try {
        mMuxer = new MediaMuxer(mFilePath.getAbsolutePath(), MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4);
    } catch (IOException e) {
        onError("failed creating muxer", e);
        return;
    }
    mOutFormat = mCodec.getOutputFormat();
    mMuxerTrack = mMuxer.addTrack(mOutFormat);
    mMuxer.start();
}
#end_block

#method_before
private void processInputBuffer() {
    Sample s = mQueue.peekFirst();
    if (s == null) {
        // input available?
        if (mFinalSem != null) {
            // input queue is exhausted and stopRecording() is waiting for
            // encoding to finish. signal end-of-stream on the input.
            Log.d(TAG, "Input EOS");
            mCodec.queueInputBuffer(mInputBufferIndex, 0, 0, getPresentationTimestampUs(mInputBufferPosition), MediaCodec.BUFFER_FLAG_END_OF_STREAM);
        }
        return;
    }
    ByteBuffer b = mCodec.getInputBuffer(mInputBufferIndex);
    assert b != null;
    int sz = Math.min(b.capacity(), s.bytes.length - s.offset);
    long ts = getPresentationTimestampUs(mInputBufferPosition);
    if (TRACE)
        Log.v(TAG, String.format("processInputBuffer (len=%d) ts=%.3f", sz, ts * 1e-6));
    b.put(s.bytes, s.offset, sz);
    mCodec.queueInputBuffer(mInputBufferIndex, 0, sz, ts, 0);
    mInputBufferPosition += sz;
    s.offset += sz;
    // done with this sample?
    if (s.offset >= s.bytes.length) {
        mQueue.pop();
    }
    // done with this buffer
    mInputBufferIndex = -1;
}
#method_after
private void processInputBuffer() {
    Sample s = mQueue.peekFirst();
    if (s == null) {
        // input available?
        if (mFinalSem != null) {
            Log.d(TAG, "Input EOS");
            mCodec.queueInputBuffer(mInputBufferIndex, 0, 0, getPresentationTimestampUs(mInputBufferPosition), MediaCodec.BUFFER_FLAG_END_OF_STREAM);
        }
        return;
    }
    ByteBuffer b = mCodec.getInputBuffer(mInputBufferIndex);
    assert b != null;
    int sz = Math.min(b.capacity(), s.bytes.length - s.offset);
    long ts = getPresentationTimestampUs(mInputBufferPosition);
    if (TRACE)
        Log.v(TAG, String.format("processInputBuffer (len=%d) ts=%.3f", sz, ts * 1e-6));
    b.put(s.bytes, s.offset, sz);
    mCodec.queueInputBuffer(mInputBufferIndex, 0, sz, ts, 0);
    mInputBufferPosition += sz;
    s.offset += sz;
    // done with this sample?
    if (s.offset >= s.bytes.length) {
        mQueue.pop();
    }
    // done with this buffer
    mInputBufferIndex = -1;
}
#end_block

#method_before
@Override
public void sendSyncOptions(Double protocolVersion, Serializer s, boolean initialSync) throws IOException {
    if (initialSync)
        return;
    mFetchRequestList.clear();
    // Find partially loaded messages; this should typically be a rare occurrence
    Cursor c = mContext.getContentResolver().query(Message.CONTENT_URI, FETCH_REQUEST_PROJECTION, MessageColumns.FLAG_LOADED + "=" + Message.FLAG_LOADED_PARTIAL + " AND " + MessageColumns.MAILBOX_KEY + "=?", new String[] { Long.toString(mMailbox.mId) }, null);
    try {
        // Put all of these messages into a list; we'll need both id and server id
        while (c.moveToNext()) {
            mFetchRequestList.add(new FetchRequest(c.getLong(FETCH_REQUEST_RECORD_ID), c.getString(FETCH_REQUEST_SERVER_ID)));
        }
    } finally {
        c.close();
    }
    // requests
    if (mFetchRequestList.isEmpty()) {
        // Permanently delete if in trash mailbox
        // In Exchange 2003, deletes-as-moves tag = true; no tag = false
        // In Exchange 2007 and up, deletes-as-moves tag is "0" (false) or "1" (true)
        boolean isTrashMailbox = mMailbox.mType == Mailbox.TYPE_TRASH;
        if (protocolVersion < Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            if (!isTrashMailbox) {
                s.tag(Tags.SYNC_DELETES_AS_MOVES);
            }
        } else {
            s.data(Tags.SYNC_DELETES_AS_MOVES, isTrashMailbox ? "0" : "1");
        }
        s.tag(Tags.SYNC_GET_CHANGES);
        s.data(Tags.SYNC_WINDOW_SIZE, EMAIL_WINDOW_SIZE);
        s.start(Tags.SYNC_OPTIONS);
        // Set the lookback appropriately (EAS calls this a "filter")
        s.data(Tags.SYNC_FILTER_TYPE, getEmailFilter());
        // Set the truncation amount for all classes
        if (protocolVersion >= Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            s.start(Tags.BASE_BODY_PREFERENCE);
            // HTML for email
            s.data(Tags.BASE_TYPE, Eas.BODY_PREFERENCE_HTML);
            String sizeTruncation = Integer.toString(mAccount.getSyncSize());
            if (!ENTIRE_EMAIL_SYNC_SIZE.equals(sizeTruncation)) {
                s.data(Tags.BASE_TRUNCATION_SIZE, sizeTruncation);
            } else {
                s.data(Tags.BASE_TRUNCATION_SIZE, Eas.EAS12_TRUNCATION_SIZE);
            }
            s.end();
        } else {
            // Use MIME data for EAS 2.5
            s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_MIME);
            s.data(Tags.SYNC_MIME_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        }
        s.end();
    } else {
        s.start(Tags.SYNC_OPTIONS);
        // Ask for plain text, rather than MIME data.  This guarantees that we'll get a usable
        // text body
        s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_TEXT);
        s.data(Tags.SYNC_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        s.end();
    }
}
#method_after
@Override
public void sendSyncOptions(Double protocolVersion, Serializer s, boolean initialSync) throws IOException {
    if (initialSync)
        return;
    mFetchRequestList.clear();
    // Find partially loaded messages; this should typically be a rare occurrence
    Cursor c = mContext.getContentResolver().query(Message.CONTENT_URI, FETCH_REQUEST_PROJECTION, MessageColumns.FLAG_LOADED + "=" + Message.FLAG_LOADED_PARTIAL + " AND " + MessageColumns.MAILBOX_KEY + "=?", new String[] { Long.toString(mMailbox.mId) }, null);
    try {
        // Put all of these messages into a list; we'll need both id and server id
        while (c.moveToNext()) {
            mFetchRequestList.add(new FetchRequest(c.getLong(FETCH_REQUEST_RECORD_ID), c.getString(FETCH_REQUEST_SERVER_ID)));
        }
    } finally {
        c.close();
    }
    // requests
    if (mFetchRequestList.isEmpty()) {
        // Permanently delete if in trash mailbox
        // In Exchange 2003, deletes-as-moves tag = true; no tag = false
        // In Exchange 2007 and up, deletes-as-moves tag is "0" (false) or "1" (true)
        boolean isTrashMailbox = mMailbox.mType == Mailbox.TYPE_TRASH;
        if (protocolVersion < Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            if (!isTrashMailbox) {
                s.tag(Tags.SYNC_DELETES_AS_MOVES);
            }
        } else {
            s.data(Tags.SYNC_DELETES_AS_MOVES, isTrashMailbox ? "0" : "1");
        }
        s.tag(Tags.SYNC_GET_CHANGES);
        s.data(Tags.SYNC_WINDOW_SIZE, EMAIL_WINDOW_SIZE);
        s.start(Tags.SYNC_OPTIONS);
        // Set the lookback appropriately (EAS calls this a "filter")
        s.data(Tags.SYNC_FILTER_TYPE, getEmailFilter());
        // Set the truncation amount for all classes
        if (protocolVersion >= Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            s.start(Tags.BASE_BODY_PREFERENCE);
            // HTML for email
            s.data(Tags.BASE_TYPE, Eas.BODY_PREFERENCE_HTML);
            String sizeTruncation = mAccount.getSyncSize() == SyncSize.SYNC_SIZE_ENTIRE_MAIL ? Eas.EAS12_TRUNCATION_SIZE : Integer.toString(mAccount.getSyncSize());
            s.data(Tags.BASE_TRUNCATION_SIZE, sizeTruncation);
            s.end();
        } else {
            // Use MIME data for EAS 2.5
            s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_MIME);
            s.data(Tags.SYNC_MIME_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        }
        s.end();
    } else {
        s.start(Tags.SYNC_OPTIONS);
        // Ask for plain text, rather than MIME data.  This guarantees that we'll get a usable
        // text body
        s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_TEXT);
        s.data(Tags.SYNC_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        s.end();
    }
}
#end_block

#method_before
@Override
public void setSyncOptions(final Context context, final Serializer s, final double protocolVersion, final Account account, final Mailbox mailbox, final boolean isInitialSync, final int numWindows) throws IOException {
    if (isInitialSync) {
        // No special options to set for initial mailbox sync.
        return;
    }
    // Check for messages that aren't fully loaded.
    final ArrayList<String> messagesToFetch = addToFetchRequestList(context, mailbox);
    // requests
    if (messagesToFetch.isEmpty()) {
        // Permanently delete if in trash mailbox
        // In Exchange 2003, deletes-as-moves tag = true; no tag = false
        // In Exchange 2007 and up, deletes-as-moves tag is "0" (false) or "1" (true)
        final boolean isTrashMailbox = mailbox.mType == Mailbox.TYPE_TRASH;
        if (protocolVersion < Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            if (!isTrashMailbox) {
                s.tag(Tags.SYNC_DELETES_AS_MOVES);
            }
        } else {
            s.data(Tags.SYNC_DELETES_AS_MOVES, isTrashMailbox ? "0" : "1");
        }
        s.tag(Tags.SYNC_GET_CHANGES);
        final int windowSize = numWindows * EMAIL_WINDOW_SIZE;
        if (windowSize > MAX_WINDOW_SIZE + EMAIL_WINDOW_SIZE) {
            throw new IOException("Max window size reached and still no data");
        }
        s.data(Tags.SYNC_WINDOW_SIZE, String.valueOf(windowSize < MAX_WINDOW_SIZE ? windowSize : MAX_WINDOW_SIZE));
        s.start(Tags.SYNC_OPTIONS);
        // Set the lookback appropriately (EAS calls this a "filter")
        s.data(Tags.SYNC_FILTER_TYPE, getEmailFilter(account, mailbox));
        // Set the truncation amount for all classes
        if (protocolVersion >= Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            s.start(Tags.BASE_BODY_PREFERENCE);
            // HTML for email
            s.data(Tags.BASE_TYPE, Eas.BODY_PREFERENCE_HTML);
            String sizeTruncation = Integer.toString(account.getSyncSize());
            if (!ENTIRE_EMAIL_SYNC_SIZE.equals(sizeTruncation)) {
                s.data(Tags.BASE_TRUNCATION_SIZE, sizeTruncation);
            } else {
                s.data(Tags.BASE_TRUNCATION_SIZE, Eas.EAS12_TRUNCATION_SIZE);
            }
            s.end();
        } else {
            // Use MIME data for EAS 2.5
            s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_MIME);
            s.data(Tags.SYNC_MIME_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        }
        s.end();
    } else {
        // If we have any messages that are not fully loaded, ask for plain text rather than
        // MIME, to guarantee we'll get usable text body. This also means we should NOT ask for
        // new messages -- we only want data for the message explicitly fetched.
        s.start(Tags.SYNC_OPTIONS);
        s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_TEXT);
        s.data(Tags.SYNC_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        s.end();
        // Add FETCH commands for messages that need a body (i.e. we didn't find it during our
        // earlier sync; this happens only in EAS 2.5 where the body couldn't be found after
        // parsing the message's MIME data).
        s.start(Tags.SYNC_COMMANDS);
        for (final String serverId : messagesToFetch) {
            s.start(Tags.SYNC_FETCH).data(Tags.SYNC_SERVER_ID, serverId).end();
        }
        s.end();
    }
}
#method_after
@Override
public void setSyncOptions(final Context context, final Serializer s, final double protocolVersion, final Account account, final Mailbox mailbox, final boolean isInitialSync, final int numWindows) throws IOException {
    if (isInitialSync) {
        // No special options to set for initial mailbox sync.
        return;
    }
    // Check for messages that aren't fully loaded.
    final ArrayList<String> messagesToFetch = addToFetchRequestList(context, mailbox);
    // requests
    if (messagesToFetch.isEmpty()) {
        // Permanently delete if in trash mailbox
        // In Exchange 2003, deletes-as-moves tag = true; no tag = false
        // In Exchange 2007 and up, deletes-as-moves tag is "0" (false) or "1" (true)
        final boolean isTrashMailbox = mailbox.mType == Mailbox.TYPE_TRASH;
        if (protocolVersion < Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            if (!isTrashMailbox) {
                s.tag(Tags.SYNC_DELETES_AS_MOVES);
            }
        } else {
            s.data(Tags.SYNC_DELETES_AS_MOVES, isTrashMailbox ? "0" : "1");
        }
        s.tag(Tags.SYNC_GET_CHANGES);
        final int windowSize = numWindows * EMAIL_WINDOW_SIZE;
        if (windowSize > MAX_WINDOW_SIZE + EMAIL_WINDOW_SIZE) {
            throw new IOException("Max window size reached and still no data");
        }
        s.data(Tags.SYNC_WINDOW_SIZE, String.valueOf(windowSize < MAX_WINDOW_SIZE ? windowSize : MAX_WINDOW_SIZE));
        s.start(Tags.SYNC_OPTIONS);
        // Set the lookback appropriately (EAS calls this a "filter")
        s.data(Tags.SYNC_FILTER_TYPE, getEmailFilter(account, mailbox));
        // Set the truncation amount for all classes
        if (protocolVersion >= Eas.SUPPORTED_PROTOCOL_EX2007_DOUBLE) {
            s.start(Tags.BASE_BODY_PREFERENCE);
            // HTML for email
            s.data(Tags.BASE_TYPE, Eas.BODY_PREFERENCE_HTML);
            String sizeTruncation = account.getSyncSize() == SyncSize.SYNC_SIZE_ENTIRE_MAIL ? Eas.EAS12_TRUNCATION_SIZE : Integer.toString(account.getSyncSize());
            s.data(Tags.BASE_TRUNCATION_SIZE, sizeTruncation);
            s.end();
        } else {
            // Use MIME data for EAS 2.5
            s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_MIME);
            s.data(Tags.SYNC_MIME_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        }
        s.end();
    } else {
        // If we have any messages that are not fully loaded, ask for plain text rather than
        // MIME, to guarantee we'll get usable text body. This also means we should NOT ask for
        // new messages -- we only want data for the message explicitly fetched.
        s.start(Tags.SYNC_OPTIONS);
        s.data(Tags.SYNC_MIME_SUPPORT, Eas.MIME_BODY_PREFERENCE_TEXT);
        s.data(Tags.SYNC_TRUNCATION, Eas.EAS2_5_TRUNCATION_SIZE);
        s.end();
        // Add FETCH commands for messages that need a body (i.e. we didn't find it during our
        // earlier sync; this happens only in EAS 2.5 where the body couldn't be found after
        // parsing the message's MIME data).
        s.start(Tags.SYNC_COMMANDS);
        for (final String serverId : messagesToFetch) {
            s.start(Tags.SYNC_FETCH).data(Tags.SYNC_SERVER_ID, serverId).end();
        }
        s.end();
    }
}
#end_block

#method_before
private void setUpMediaSession() {
    mSession = new MediaSession(this, "Eleven");
    mSession.setCallback(new MediaSession.Callback() {

        @Override
        public void onPause() {
            pause();
            mPausedByTransientLossOfFocus = false;
        }

        @Override
        public void onPlay() {
            play();
        }

        @Override
        public void onSeekTo(long pos) {
            seek(pos);
        }

        @Override
        public void onSkipToNext() {
            gotoNext(true);
        }

        @Override
        public void onSkipToPrevious() {
            prev(false);
        }

        @Override
        public void onStop() {
            pause();
            mPausedByTransientLossOfFocus = false;
            seek(0);
            releaseServiceUiAndStop();
        }
    });
    PendingIntent pi = PendingIntent.getBroadcast(this, 0, new Intent(this, MediaButtonIntentReceiver.class), PendingIntent.FLAG_UPDATE_CURRENT);
    mSession.setMediaButtonReceiver(pi);
    mSession.setFlags(MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS);
    mSession.setFlags(MediaSession.FLAG_HANDLES_MEDIA_BUTTONS);
}
#method_after
private void setUpMediaSession() {
    mSession = new MediaSession(this, "Eleven");
    mSession.setCallback(new MediaSession.Callback() {

        @Override
        public void onPause() {
            pause();
            mPausedByTransientLossOfFocus = false;
        }

        @Override
        public void onPlay() {
            play();
        }

        @Override
        public void onSeekTo(long pos) {
            seek(pos);
        }

        @Override
        public void onSkipToNext() {
            gotoNext(true);
        }

        @Override
        public void onSkipToPrevious() {
            prev(false);
        }

        @Override
        public void onStop() {
            pause();
            mPausedByTransientLossOfFocus = false;
            seek(0);
            releaseServiceUiAndStop();
        }
    });
    PendingIntent pi = PendingIntent.getBroadcast(this, 0, new Intent(this, MediaButtonIntentReceiver.class), PendingIntent.FLAG_UPDATE_CURRENT);
    mSession.setMediaButtonReceiver(pi);
    mSession.setFlags(MediaSession.FLAG_HANDLES_TRANSPORT_CONTROLS | MediaSession.FLAG_HANDLES_MEDIA_BUTTONS);
}
#end_block

#method_before
public static void initializeNanpSettings(Context context) {
    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    if (manager != null) {
        sUserSimCountryCode = manager.getSimCountryIso();
    }
    final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
    if (sUserSimCountryCode != null) {
        /**
         * Updates shared preferences with the latest country obtained from getSimCountryIso.
         */
        prefs.edit().putString(PREF_USER_SIM_COUNTRY_CODE, sUserSimCountryCode).apply();
    } else {
        /**
         * Uses previously stored country code if loading fails.
         */
        sUserSimCountryCode = prefs.getString(PREF_USER_SIM_COUNTRY_CODE, PREF_USER_SIM_COUNTRY_CODE_DEFAULT);
    }
    /**
     * Queries the NANP country list to find out whether user is in a NANP region.
     */
    sUserInNanpRegion = isCountryNanp(sUserSimCountryCode);
    sNanpInitialized = true;
}
#method_after
public static void initializeNanpSettings(Context context) {
    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    if (manager != null) {
        sUserSimCountryCode = manager.getSimCountryIso();
    }
    final SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(context);
    if (sUserSimCountryCode != null) {
        /**
         * Updates shared preferences with the latest country obtained from getSimCountryIso.
         */
        prefs.edit().putString(PREF_USER_SIM_COUNTRY_CODE, sUserSimCountryCode).apply();
    } else {
        /**
         * Uses previously stored country code if loading fails.
         */
        sUserSimCountryCode = prefs.getString(PREF_USER_SIM_COUNTRY_CODE, PREF_USER_SIM_COUNTRY_CODE_DEFAULT);
    }
    /**
     * Queries the NANP country list to find out whether user is in a NANP region.
     */
    sUserInNanpRegion = isCountryNanp(sUserSimCountryCode);
    /**
     * Sets a layout for SmartDial depending on current UI language.
     */
    String locale = context.getResources().getConfiguration().locale.getCountry();
    if (locale.equals("RU")) {
        mMap = new RussianSmartDialMap();
    } else {
        mMap = new LatinSmartDialMap();
    }
    sNanpInitialized = true;
}
#end_block

#method_before
private void setupKeypad(View fragmentView) {
    final int[] buttonIds = new int[] { R.id.zero, R.id.one, R.id.two, R.id.three, R.id.four, R.id.five, R.id.six, R.id.seven, R.id.eight, R.id.nine, R.id.star, R.id.pound };
    final int[] numberIds = new int[] { R.string.dialpad_0_number, R.string.dialpad_1_number, R.string.dialpad_2_number, R.string.dialpad_3_number, R.string.dialpad_4_number, R.string.dialpad_5_number, R.string.dialpad_6_number, R.string.dialpad_7_number, R.string.dialpad_8_number, R.string.dialpad_9_number, R.string.dialpad_star_number, R.string.dialpad_pound_number };
    final int[] letterIds = new int[] { R.string.dialpad_0_letters, R.string.dialpad_1_letters, R.string.dialpad_2_letters, R.string.dialpad_3_letters, R.string.dialpad_4_letters, R.string.dialpad_5_letters, R.string.dialpad_6_letters, R.string.dialpad_7_letters, R.string.dialpad_8_letters, R.string.dialpad_9_letters, R.string.dialpad_star_letters, R.string.dialpad_pound_letters };
    final int[] letter2Ids = new int[] { R.string.dialpad_0_2_letters, R.string.dialpad_1_2_letters, R.string.dialpad_2_2_letters, R.string.dialpad_3_2_letters, R.string.dialpad_4_2_letters, R.string.dialpad_5_2_letters, R.string.dialpad_6_2_letters, R.string.dialpad_7_2_letters, R.string.dialpad_8_2_letters, R.string.dialpad_9_2_letters, R.string.dialpad_star_2_letters, R.string.dialpad_pound_2_letters };
    final Resources resources = getResources();
    DialpadKeyButton dialpadKey;
    TextView numberView;
    TextView lettersView;
    TextView letters2View;
    for (int i = 0; i < buttonIds.length; i++) {
        dialpadKey = (DialpadKeyButton) fragmentView.findViewById(buttonIds[i]);
        dialpadKey.setLayoutParams(new TableRow.LayoutParams(TableRow.LayoutParams.MATCH_PARENT, TableRow.LayoutParams.MATCH_PARENT));
        dialpadKey.setOnPressedListener(this);
        numberView = (TextView) dialpadKey.findViewById(R.id.dialpad_key_number);
        lettersView = (TextView) dialpadKey.findViewById(R.id.dialpad_key_letters);
        letters2View = (TextView) dialpadKey.findViewById(R.id.dialpad_key2_letters);
        final String numberString = resources.getString(numberIds[i]);
        numberView.setText(numberString);
        dialpadKey.setContentDescription(numberString);
        if (lettersView != null) {
            lettersView.setText(resources.getString(letterIds[i]));
            if (buttonIds[i] == R.id.zero) {
                lettersView.setTextSize(TypedValue.COMPLEX_UNIT_PX, resources.getDimension(R.dimen.dialpad_key_plus_size));
            }
        }
        if (letters2View != null) {
            letters2View.setText(resources.getString(letter2Ids[i]));
            if (buttonIds[i] == R.id.zero) {
                letters2View.setVisibility(View.GONE);
            }
        }
    }
    // Long-pressing one button will initiate Voicemail.
    fragmentView.findViewById(R.id.one).setOnLongClickListener(this);
    // Long-pressing zero button will enter '+' instead.
    fragmentView.findViewById(R.id.zero).setOnLongClickListener(this);
}
#method_after
private void setupKeypad(View fragmentView) {
    final int[] buttonIds = new int[] { R.id.zero, R.id.one, R.id.two, R.id.three, R.id.four, R.id.five, R.id.six, R.id.seven, R.id.eight, R.id.nine, R.id.star, R.id.pound };
    final int[] numberIds = new int[] { R.string.dialpad_0_number, R.string.dialpad_1_number, R.string.dialpad_2_number, R.string.dialpad_3_number, R.string.dialpad_4_number, R.string.dialpad_5_number, R.string.dialpad_6_number, R.string.dialpad_7_number, R.string.dialpad_8_number, R.string.dialpad_9_number, R.string.dialpad_star_number, R.string.dialpad_pound_number };
    final int[] letterIds = new int[] { R.string.dialpad_0_letters, R.string.dialpad_1_letters, R.string.dialpad_2_letters, R.string.dialpad_3_letters, R.string.dialpad_4_letters, R.string.dialpad_5_letters, R.string.dialpad_6_letters, R.string.dialpad_7_letters, R.string.dialpad_8_letters, R.string.dialpad_9_letters, R.string.dialpad_star_letters, R.string.dialpad_pound_letters };
    final int[] letter2Ids = new int[] { R.string.dialpad_0_2_letters, R.string.dialpad_1_2_letters, R.string.dialpad_2_2_letters, R.string.dialpad_3_2_letters, R.string.dialpad_4_2_letters, R.string.dialpad_5_2_letters, R.string.dialpad_6_2_letters, R.string.dialpad_7_2_letters, R.string.dialpad_8_2_letters, R.string.dialpad_9_2_letters, R.string.dialpad_star_2_letters, R.string.dialpad_pound_2_letters };
    final Resources resources = getResources();
    DialpadKeyButton dialpadKey;
    TextView numberView;
    TextView lettersView;
    TextView letters2View;
    for (int i = 0; i < buttonIds.length; i++) {
        dialpadKey = (DialpadKeyButton) fragmentView.findViewById(buttonIds[i]);
        dialpadKey.setLayoutParams(new TableRow.LayoutParams(TableRow.LayoutParams.MATCH_PARENT, TableRow.LayoutParams.MATCH_PARENT));
        dialpadKey.setOnPressedListener(this);
        numberView = (TextView) dialpadKey.findViewById(R.id.dialpad_key_number);
        lettersView = (TextView) dialpadKey.findViewById(R.id.dialpad_key_letters);
        letters2View = (TextView) dialpadKey.findViewById(R.id.dialpad_key2_letters);
        final String numberString = resources.getString(numberIds[i]);
        numberView.setText(numberString);
        dialpadKey.setContentDescription(numberString);
        if (lettersView != null) {
            lettersView.setText(resources.getString(letterIds[i]));
            if (buttonIds[i] == R.id.zero) {
                lettersView.setTextSize(TypedValue.COMPLEX_UNIT_PX, resources.getDimension(R.dimen.dialpad_key_plus_size));
            }
        }
        if (letters2View != null) {
            letters2View.setText(resources.getString(letter2Ids[i]));
            if (buttonIds[i] == R.id.zero) {
                letters2View.setTextSize(TypedValue.COMPLEX_UNIT_PX, resources.getDimension(R.dimen.dialpad_key_plus_size) / 2);
            }
        }
    }
    // Long-pressing one button will initiate Voicemail.
    fragmentView.findViewById(R.id.one).setOnLongClickListener(this);
    // Long-pressing zero button will enter '+' instead.
    fragmentView.findViewById(R.id.zero).setOnLongClickListener(this);
}
#end_block

#method_before
public static PhoneCallDetailsViews fromView(View view) {
    return new PhoneCallDetailsViews(view.findViewById(R.id.nameWrapper), (ImageView) view.findViewById(R.id.contactHasNotesIcon), (TextView) view.findViewById(R.id.name), view.findViewById(R.id.call_type), (CallTypeIconsView) view.findViewById(R.id.call_type_icons), (TextView) view.findViewById(R.id.call_location_and_date), (TextView) view.findViewById(R.id.voicemail_transcription), (TextView) view.findViewById(R.id.call_account_label));
}
#method_after
public static PhoneCallDetailsViews fromView(View view) {
    return new PhoneCallDetailsViews(view.findViewById(R.id.nameWrapper), (ImageView) view.findViewById(R.id.hasNotes), (TextView) view.findViewById(R.id.name), view.findViewById(R.id.call_type), (CallTypeIconsView) view.findViewById(R.id.call_type_icons), (TextView) view.findViewById(R.id.call_location_and_date), (TextView) view.findViewById(R.id.voicemail_transcription), (TextView) view.findViewById(R.id.call_account_label));
}
#end_block

#method_before
public static PhoneCallDetailsViews createForTest(Context context) {
    return new PhoneCallDetailsViews(new View(context), new android.widget.ImageView(context), new TextView(context), new View(context), new CallTypeIconsView(context), new TextView(context), new TextView(context), new TextView(context));
}
#method_after
public static PhoneCallDetailsViews createForTest(Context context) {
    return new PhoneCallDetailsViews(new View(context), new ImageView(context), new TextView(context), new View(context), new CallTypeIconsView(context), new TextView(context), new TextView(context), new TextView(context));
}
#end_block

#method_before
private void bindActionButtons() {
    boolean canPlaceCallToNumber = PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation);
    CallMethodInfo cmi = null;
    if (inCallComponentName != null) {
        cmi = CallMethodHelper.getCallMethod(inCallComponentName);
    }
    if (!TextUtils.isEmpty(voicemailUri) && canPlaceCallToNumber) {
        callButtonView.setTag(R.id.incall_provider_action_type, null);
        callButtonView.setTag(IntentProvider.getReturnCallIntentProvider(number, OriginCodes.CALL_LOG_ACTION_ONE));
        ((TextView) callButtonView.findViewById(R.id.call_action_text)).setText(TextUtils.expandTemplate(mContext.getString(R.string.call_log_action_call), nameOrNumber));
        callButtonView.setVisibility(View.VISIBLE);
    } else {
        callButtonView.setVisibility(View.GONE);
    }
    if (mDeepLink != null) {
        ImageView icon = (ImageView) viewNoteButton.findViewById(com.android.dialer.R.id.view_note_action_icon);
        icon.setImageDrawable(mDeepLink.getDrawableIcon(mContext));
    } else {
        viewNoteButton.setVisibility(android.view.View.GONE);
    }
    // If one of the calls had video capabilities, show the video call button.
    if (mTelecomCallLogCache.isVideoEnabled() && canPlaceCallToNumber && phoneCallDetailsViews.callTypeIcons.isVideoShown() || (cmi != null && !PhoneNumberUtils.isGlobalPhoneNumber(number))) {
        if (cmi != null && cmi.mIsInCallProvider) {
            ((TextView) videoCallButtonView.findViewById(R.id.video_call_action_text)).setText(mContext.getString(R.string.provider_video_call, cmi.mName));
            videoCallButtonView.setTag(R.id.incall_provider_action_type, INCALL_ACTION_TYPE_VIDEO);
            videoCallButtonView.setVisibility(View.VISIBLE);
        } else {
            videoCallButtonView.setTag(R.id.incall_provider_action_type, null);
            videoCallButtonView.setTag(IntentProvider.getReturnVideoCallIntentProvider(number, OriginCodes.CALL_LOG_ACTION_TWO));
            videoCallButtonView.setVisibility(View.VISIBLE);
        }
    } else {
        videoCallButtonView.setVisibility(View.GONE);
    }
    // For voicemail calls, show the voicemail playback layout; hide otherwise.
    if (callType == Calls.VOICEMAIL_TYPE && mVoicemailPlaybackPresenter != null) {
        voicemailPlaybackView.setVisibility(View.VISIBLE);
        Uri uri = Uri.parse(voicemailUri);
        mVoicemailPlaybackPresenter.setPlaybackView(voicemailPlaybackView, uri, mVoicemailPrimaryActionButtonClicked);
        mVoicemailPrimaryActionButtonClicked = false;
        CallLogAsyncTaskUtil.markVoicemailAsRead(mContext, uri);
    } else {
        voicemailPlaybackView.setVisibility(View.GONE);
    }
    detailsButtonView.setVisibility(View.VISIBLE);
    detailsButtonView.setTag(IntentProvider.getCallDetailIntentProvider(rowId, callIds, null));
    if (info != null && UriUtils.isEncodedContactUri(info.lookupUri)) {
        createNewContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(info.lookupUri, info.name, info.number, info.type, true));
        createNewContactButtonView.setVisibility(View.VISIBLE);
        addToExistingContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(info.lookupUri, info.name, info.number, info.type, false));
        addToExistingContactButtonView.setVisibility(View.VISIBLE);
    } else {
        createNewContactButtonView.setVisibility(View.GONE);
        addToExistingContactButtonView.setVisibility(View.GONE);
    }
    if (cmi != null && cmi.mIsInCallProvider && !PhoneNumberUtils.isGlobalPhoneNumber(number)) {
        sendMessageView.setVisibility(View.GONE);
    } else {
        sendMessageView.setVisibility(View.VISIBLE);
        sendMessageView.setTag(IntentProvider.getSendSmsIntentProvider(number));
    }
    mCallLogListItemHelper.setActionContentDescriptions(this);
    boolean supportsCallSubject = mTelecomCallLogCache.doesAccountSupportCallSubject(accountHandle);
    boolean isVoicemailNumber = mTelecomCallLogCache.isVoicemailNumber(accountHandle, number);
    callWithNoteButtonView.setVisibility(supportsCallSubject && !isVoicemailNumber ? View.VISIBLE : View.GONE);
    // Remove block caller item if blacklist is disabled
    if (mContactInfoHelper.canBlacklistCalls() && (cmi == null || !cmi.mIsInCallProvider)) {
        mBlockContactPresenter.setControlView(blockCallerButtonView, number);
        blockCallerButtonView.setVisibility(View.VISIBLE);
    } else {
        mBlockContactPresenter.disable();
        blockCallerButtonView.setVisibility(View.GONE);
    }
}
#method_after
private void bindActionButtons() {
    boolean canPlaceCallToNumber = PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation);
    CallMethodInfo cmi = null;
    if (inCallComponentName != null) {
        cmi = DialerDataSubscription.get(mContext).getPluginIfExists(inCallComponentName);
    }
    if (!TextUtils.isEmpty(voicemailUri) && canPlaceCallToNumber) {
        callButtonView.setTag(R.id.incall_provider_action_type, null);
        callButtonView.setTag(IntentProvider.getReturnCallIntentProvider(number, OriginCodes.CALL_LOG_ACTION_ONE));
        ((TextView) callButtonView.findViewById(R.id.call_action_text)).setText(TextUtils.expandTemplate(mContext.getString(R.string.call_log_action_call), nameOrNumber));
        callButtonView.setVisibility(View.VISIBLE);
    } else {
        callButtonView.setVisibility(View.GONE);
    }
    if (mDeepLink != null) {
        ImageView icon = (ImageView) viewNoteButton.findViewById(R.id.view_note_action_icon);
        icon.setImageDrawable(mDeepLink.getDrawableIcon(mContext));
    } else {
        viewNoteButton.setVisibility(View.GONE);
    }
    // If one of the calls had video capabilities, show the video call button.
    if (mTelecomCallLogCache.isVideoEnabled() && canPlaceCallToNumber && phoneCallDetailsViews.callTypeIcons.isVideoShown() || (cmi != null && !PhoneNumberUtils.isGlobalPhoneNumber(number))) {
        if (cmi != null && cmi.mIsInCallProvider) {
            ((TextView) videoCallButtonView.findViewById(R.id.video_call_action_text)).setText(mContext.getString(R.string.provider_video_call, cmi.mName));
            videoCallButtonView.setTag(R.id.incall_provider_action_type, INCALL_ACTION_TYPE_VIDEO);
            videoCallButtonView.setVisibility(View.VISIBLE);
        } else {
            videoCallButtonView.setTag(R.id.incall_provider_action_type, null);
            videoCallButtonView.setTag(IntentProvider.getReturnVideoCallIntentProvider(number, OriginCodes.CALL_LOG_ACTION_TWO));
            videoCallButtonView.setVisibility(View.VISIBLE);
        }
    } else {
        videoCallButtonView.setVisibility(View.GONE);
    }
    // For voicemail calls, show the voicemail playback layout; hide otherwise.
    if (callType == Calls.VOICEMAIL_TYPE && mVoicemailPlaybackPresenter != null) {
        voicemailPlaybackView.setVisibility(View.VISIBLE);
        Uri uri = Uri.parse(voicemailUri);
        mVoicemailPlaybackPresenter.setPlaybackView(voicemailPlaybackView, uri, mVoicemailPrimaryActionButtonClicked);
        mVoicemailPrimaryActionButtonClicked = false;
        CallLogAsyncTaskUtil.markVoicemailAsRead(mContext, uri);
    } else {
        voicemailPlaybackView.setVisibility(View.GONE);
    }
    detailsButtonView.setVisibility(View.VISIBLE);
    detailsButtonView.setTag(IntentProvider.getCallDetailIntentProvider(rowId, callIds, null));
    if (info != null && UriUtils.isEncodedContactUri(info.lookupUri)) {
        createNewContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(info.lookupUri, info.name, info.number, info.type, true));
        createNewContactButtonView.setVisibility(View.VISIBLE);
        addToExistingContactButtonView.setTag(IntentProvider.getAddContactIntentProvider(info.lookupUri, info.name, info.number, info.type, false));
        addToExistingContactButtonView.setVisibility(View.VISIBLE);
    } else {
        createNewContactButtonView.setVisibility(View.GONE);
        addToExistingContactButtonView.setVisibility(View.GONE);
    }
    if (cmi != null && cmi.mIsInCallProvider && !PhoneNumberUtils.isGlobalPhoneNumber(number)) {
        sendMessageView.setVisibility(View.GONE);
    } else {
        sendMessageView.setVisibility(View.VISIBLE);
        sendMessageView.setTag(IntentProvider.getSendSmsIntentProvider(number));
    }
    mCallLogListItemHelper.setActionContentDescriptions(this);
    boolean supportsCallSubject = mTelecomCallLogCache.doesAccountSupportCallSubject(accountHandle);
    boolean isVoicemailNumber = mTelecomCallLogCache.isVoicemailNumber(accountHandle, number);
    callWithNoteButtonView.setVisibility(supportsCallSubject && !isVoicemailNumber ? View.VISIBLE : View.GONE);
    // Remove block caller item if blacklist is disabled
    if (mBlockContactPresenter.canBlock() && (cmi == null || !cmi.mIsInCallProvider)) {
        mBlockContactPresenter.setControlView(blockCallerButtonView, number);
        blockCallerButtonView.setVisibility(View.VISIBLE);
    } else {
        mBlockContactPresenter.disable();
        blockCallerButtonView.setVisibility(View.GONE);
    }
}
#end_block

#method_before
public void setAttributionImage(ComponentName cn) {
    if (cn == null) {
        dialerQuickContact.setAttributionBadge(null);
    } else {
        CallMethodInfo cmi = CallMethodHelper.getCallMethod(cn);
        if (cmi == null) {
            dialerQuickContact.setAttributionBadge(null);
            Log.v(TAG, "Call Method was Null for: " + cn.toShortString());
        } else {
            dialerQuickContact.setAttributionBadge(cmi.mBadgeIcon);
        }
    }
}
#method_after
public void setAttributionImage(ComponentName cn) {
    if (cn == null) {
        dialerQuickContact.setAttributionBadge(null);
    } else {
        CallMethodInfo cmi = DialerDataSubscription.get(mContext).getPluginIfExists(cn);
        if (cmi == null) {
            dialerQuickContact.setAttributionBadge(null);
            Log.v(TAG, "Call Method was Null for: " + cn.toShortString());
        } else {
            dialerQuickContact.setAttributionBadge(cmi.mBadgeIcon);
        }
    }
}
#end_block

#method_before
@Override
public void onClick(View view) {
    if (view.getId() == R.id.primary_action_button && !TextUtils.isEmpty(voicemailUri)) {
        mVoicemailPrimaryActionButtonClicked = true;
        mExpandCollapseListener.onClick(primaryActionView);
    } else if (view.getId() == R.id.call_with_note_action) {
        CallSubjectDialog.start((Activity) mContext, info.photoId, info.photoUri, info.lookupUri, (String) nameOrNumber, /* top line of contact view in call subject dialog */
        isBusiness, number, /* callable number used for ACTION_CALL intent */
        TextUtils.isEmpty(info.name) ? null : displayNumber, /* second line of contact
                                                                           view in dialog. */
        numberType, /* phone number type (e.g. mobile) in second line of contact view */
        accountHandle);
    } else if (view.getId() == R.id.view_note_action) {
        mContext.startActivity(mDeepLink.createViewIntent());
    } else {
        final String inCallAction = (String) view.getTag(R.id.incall_provider_action_type);
        if (inCallComponentName != null && !TextUtils.isEmpty(inCallAction)) {
            CallMethodInfo cmi = CallMethodHelper.getCallMethod(inCallComponentName);
            if (cmi != null) {
                switch(inCallAction) {
                    case INCALL_ACTION_TYPE_VIDEO:
                        cmi.placeCall(OriginCodes.CALL_LOG_ACTION_TWO, number, mContext, true);
                        break;
                    case INCALL_ACTION_TYPE_MESSAGING:
                        // TODO: implement way to start incall message thread
                        break;
                    case INCALL_ACTION_TYPE_PHONE:
                        cmi.placeCall(OriginCodes.CALL_LOG_ACTION_ONE, number, mContext);
                        break;
                    default:
                        // Unsupported thing, we shouldn't get here
                        break;
                }
            }
        } else {
            final IntentProvider intentProvider = (IntentProvider) view.getTag();
            if (intentProvider != null) {
                final Intent intent = intentProvider.getIntent(mContext);
                // See IntentProvider.getCallDetailIntentProvider() for why this may be null.
                if (intent != null) {
                    DialerUtils.startActivityWithErrorToast(mContext, intent, OriginCodes.CALL_LOG_CALL);
                }
            }
        }
    }
}
#method_after
@Override
public void onClick(View view) {
    if (view.getId() == R.id.primary_action_button && !TextUtils.isEmpty(voicemailUri)) {
        mVoicemailPrimaryActionButtonClicked = true;
        mExpandCollapseListener.onClick(primaryActionView);
    } else if (view.getId() == R.id.call_with_note_action) {
        CallSubjectDialog.start((Activity) mContext, info.photoId, info.photoUri, info.lookupUri, (String) nameOrNumber, /* top line of contact view in call subject dialog */
        isBusiness, number, /* callable number used for ACTION_CALL intent */
        TextUtils.isEmpty(info.name) ? null : displayNumber, /* second line of contact
                                                                           view in dialog. */
        numberType, /* phone number type (e.g. mobile) in second line of contact view */
        accountHandle);
    } else if (view.getId() == R.id.view_note_action) {
        sendOpeningExisitingEvent();
        mContext.startActivity(mDeepLink.createViewIntent());
    } else {
        final String inCallAction = (String) view.getTag(R.id.incall_provider_action_type);
        if (inCallComponentName != null && !TextUtils.isEmpty(inCallAction)) {
            CallMethodInfo cmi = DialerDataSubscription.get(mContext).getPluginIfExists(inCallComponentName);
            if (cmi != null) {
                switch(inCallAction) {
                    case INCALL_ACTION_TYPE_VIDEO:
                        cmi.placeCall(OriginCodes.CALL_LOG_ACTION_TWO, number, mContext, true);
                        break;
                    case INCALL_ACTION_TYPE_MESSAGING:
                        // TODO: implement way to start incall message thread
                        break;
                    case INCALL_ACTION_TYPE_PHONE:
                        cmi.placeCall(OriginCodes.CALL_LOG_ACTION_ONE, number, mContext);
                        break;
                    default:
                        // Unsupported thing, we shouldn't get here
                        break;
                }
            }
        } else {
            final IntentProvider intentProvider = (IntentProvider) view.getTag();
            if (intentProvider != null) {
                final Intent intent = intentProvider.getIntent(mContext);
                // See IntentProvider.getCallDetailIntentProvider() for why this may be null.
                if (intent != null) {
                    DialerUtils.startActivityWithErrorToast(mContext, intent, OriginCodes.CALL_LOG_CALL);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    Trace.beginSection(TAG + " onCreate");
    super.onCreate();
    Trace.beginSection(TAG + " ExtensionsFactory initialization");
    ExtensionsFactory.init(getApplicationContext());
    Trace.endSection();
    Trace.beginSection(TAG + " Analytics initialization");
    AnalyticsUtil.initialize(this);
    Trace.endSection();
    CallMethodHelper.init(this);
    MetricsHelper.init(this);
    WifiCallStatusNudgeListener.init(this);
    InCallMetricsHelper.init(this);
    Trace.endSection();
    DeepLinkIntegrationManager.getInstance().setUp(this);
}
#method_after
@Override
public void onCreate() {
    Trace.beginSection(TAG + " onCreate");
    super.onCreate();
    Trace.beginSection(TAG + " ExtensionsFactory initialization");
    ExtensionsFactory.init(getApplicationContext());
    Trace.endSection();
    Trace.beginSection(TAG + " Analytics initialization");
    AnalyticsUtil.initialize(this);
    Trace.endSection();
    DialerDataSubscription.init(this);
    MetricsHelper.init(this);
    WifiCallStatusNudgeListener.init(this);
    InCallMetricsHelper.init(this);
    DeepLinkIntegrationManager.getInstance().setUp(this);
    Trace.endSection();
}
#end_block

#method_before
public void setPhoneCallDetails(PhoneCallDetailsViews views, PhoneCallDetails details) {
    // Display up to a given number of icons.
    views.callTypeIcons.clear();
    int count = details.callTypes.length;
    boolean isVoicemail = false;
    for (int index = 0; index < count && index < MAX_CALL_TYPE_ICONS; ++index) {
        views.callTypeIcons.add(details.callTypes[index]);
        if (index == 0) {
            isVoicemail = details.callTypes[index] == Calls.VOICEMAIL_TYPE;
        }
    }
    // Show the video icon if the call had video enabled.
    views.callTypeIcons.setShowVideo((details.features & Calls.FEATURES_VIDEO) == Calls.FEATURES_VIDEO);
    views.callTypeIcons.requestLayout();
    views.callTypeIcons.setVisibility(View.VISIBLE);
    // Show the total call count only if there are more than the maximum number of icons.
    final Integer callCount;
    if (count > MAX_CALL_TYPE_ICONS) {
        callCount = count;
    } else {
        callCount = null;
    }
    CharSequence callLocationAndDate = getCallLocationAndDate(details);
    // Set the call count, location and date.
    setCallCountAndDate(views, callCount, callLocationAndDate);
    // Set the account label if it exists.
    String accountLabel = mTelecomCallLogCache.getAccountLabel(details.accountHandle);
    if (accountLabel != null) {
        views.callAccountLabel.setVisibility(View.VISIBLE);
        views.callAccountLabel.setText(accountLabel);
        int color = PhoneAccountUtils.getAccountColor(mContext, details.accountHandle);
        if (color == PhoneAccount.NO_HIGHLIGHT_COLOR) {
            int defaultColor = R.color.dialtacts_secondary_text_color;
            views.callAccountLabel.setTextColor(mContext.getResources().getColor(defaultColor));
        } else {
            views.callAccountLabel.setTextColor(color);
        }
    } else {
        views.callAccountLabel.setVisibility(View.GONE);
    }
    final CharSequence nameText;
    final CharSequence displayNumber = details.displayNumber;
    if (TextUtils.isEmpty(details.name)) {
        nameText = displayNumber;
        // We have a real phone number as "nameView" so make it always LTR
        views.nameView.setTextDirection(View.TEXT_DIRECTION_LTR);
    } else {
        nameText = details.name;
    }
    views.nameWrapper.setVisibility(android.view.View.VISIBLE);
    views.nameView.setText(nameText);
    views.nameView.setVisibility(android.view.View.VISIBLE);
    if (views.noteIconView.getDrawable() == null) {
        views.noteIconView.setVisibility(android.view.View.GONE);
    }
    if (isVoicemail && !TextUtils.isEmpty(details.transcription)) {
        views.voicemailTranscriptionView.setText(details.transcription);
        views.voicemailTranscriptionView.setVisibility(View.VISIBLE);
    } else {
        views.voicemailTranscriptionView.setText(null);
        views.voicemailTranscriptionView.setVisibility(View.GONE);
    }
    // Bold if not read
    Typeface typeface = details.isRead ? Typeface.SANS_SERIF : Typeface.DEFAULT_BOLD;
    views.nameView.setTypeface(typeface);
    views.voicemailTranscriptionView.setTypeface(typeface);
    views.callLocationAndDate.setTypeface(typeface);
}
#method_after
public void setPhoneCallDetails(PhoneCallDetailsViews views, PhoneCallDetails details) {
    // Display up to a given number of icons.
    views.callTypeIcons.clear();
    int count = details.callTypes.length;
    boolean isVoicemail = false;
    for (int index = 0; index < count && index < MAX_CALL_TYPE_ICONS; ++index) {
        views.callTypeIcons.add(details.callTypes[index]);
        if (index == 0) {
            isVoicemail = details.callTypes[index] == Calls.VOICEMAIL_TYPE;
        }
    }
    // Show the video icon if the call had video enabled.
    views.callTypeIcons.setShowVideo((details.features & Calls.FEATURES_VIDEO) == Calls.FEATURES_VIDEO);
    views.callTypeIcons.requestLayout();
    views.callTypeIcons.setVisibility(View.VISIBLE);
    // Show the total call count only if there are more than the maximum number of icons.
    final Integer callCount;
    if (count > MAX_CALL_TYPE_ICONS) {
        callCount = count;
    } else {
        callCount = null;
    }
    CharSequence callLocationAndDate = getCallLocationAndDate(details);
    // Set the call count, location and date.
    setCallCountAndDate(views, callCount, callLocationAndDate);
    // Set the account label if it exists.
    String accountLabel = mTelecomCallLogCache.getAccountLabel(details.accountHandle);
    if (accountLabel != null) {
        views.callAccountLabel.setVisibility(View.VISIBLE);
        views.callAccountLabel.setText(accountLabel);
        int color = PhoneAccountUtils.getAccountColor(mContext, details.accountHandle);
        if (color == PhoneAccount.NO_HIGHLIGHT_COLOR) {
            int defaultColor = R.color.dialtacts_secondary_text_color;
            views.callAccountLabel.setTextColor(mContext.getResources().getColor(defaultColor));
        } else {
            views.callAccountLabel.setTextColor(color);
        }
    } else {
        views.callAccountLabel.setVisibility(View.GONE);
    }
    final CharSequence nameText;
    final CharSequence displayNumber = details.displayNumber;
    if (TextUtils.isEmpty(details.name)) {
        nameText = displayNumber;
        // We have a real phone number as "nameView" so make it always LTR
        views.nameView.setTextDirection(View.TEXT_DIRECTION_LTR);
    } else {
        nameText = details.name;
    }
    views.nameView.setText(nameText);
    if (views.noteIconView.getDrawable() == null) {
        views.noteIconView.setVisibility(View.GONE);
    }
    if (isVoicemail && !TextUtils.isEmpty(details.transcription)) {
        views.voicemailTranscriptionView.setText(details.transcription);
        views.voicemailTranscriptionView.setVisibility(View.VISIBLE);
    } else {
        views.voicemailTranscriptionView.setText(null);
        views.voicemailTranscriptionView.setVisibility(View.GONE);
    }
    // Bold if not read
    Typeface typeface = details.isRead ? Typeface.SANS_SERIF : Typeface.DEFAULT_BOLD;
    views.nameView.setTypeface(typeface);
    views.voicemailTranscriptionView.setTypeface(typeface);
    views.callLocationAndDate.setTypeface(typeface);
}
#end_block

#method_before
public void stopProcessing() {
    mDone = true;
}
#method_after
public void stopProcessing() {
    mDone = true;
    interrupt();
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        // Check if thread is finished, and if so return immediately.
        if (mDone)
            return;
        // Obtain next request, if any is available.
        // Keep synchronized section small.
        DeepLinkRequest req = null;
        synchronized (mRequests) {
            if (!mRequests.isEmpty()) {
                req = mRequests.removeFirst();
            }
        }
        if (req != null) {
            // Process the request.
            queryDeepLinks(req);
        } else {
            // interrupted).
            try {
                synchronized (mRequests) {
                    mRequests.wait(1000);
                }
            } catch (InterruptedException ie) {
            // Ignore, and attempt to continue processing requests.
            }
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        // Check if thread is finished, and if so return immediately.
        if (mDone)
            return;
        // Obtain next request, if any is available.
        // Keep synchronized section small.
        DeepLinkRequest req = null;
        synchronized (mRequests) {
            if (!mRequests.isEmpty()) {
                req = mRequests.removeFirst();
            }
        }
        if (req != null) {
            // Process the request.
            queryDeepLinks(req);
        } else {
            // only update the UI when there are no more requests
            if (needRedraw) {
                needRedraw = false;
                mHandler.sendEmptyMessage(REDRAW);
            }
            // interrupted).
            try {
                synchronized (mRequests) {
                    mRequests.wait(PROCESSING_THREAD_THROTTLE_LIMIT);
                }
            } catch (InterruptedException ie) {
            // Ignore, and attempt to continue processing requests.
            }
        }
    }
}
#end_block

#method_before
public DeepLink getValue(String number, long[] times) {
    long mostRecentCall = Long.MIN_VALUE;
    DeepLink toReturn = null;
    List<Uri> urisToRequest = new ArrayList<Uri>();
    boolean immediate = false;
    // for all calls
    for (Long callTime : times) {
        // generate the URI
        Uri uri = DeepLinkIntegrationManager.generateCallUri(number, callTime);
        String uriString = uri.toString();
        // hit the cache, do we have a link for this call?
        ExpirableCache.CachedValue<DeepLink> cachedInfo = mCache.getCachedValue(uriString);
        // if so is that a null object?
        DeepLink info = cachedInfo == null ? null : cachedInfo.getValue();
        if (cachedInfo == null) {
            // if its null we need to add a uri to our requests
            mCache.put(uriString, DeepLinkRequest.EMPTY);
            urisToRequest.add(uri);
            // if we get any uris that haven't been handled we need to immediately do this query
            immediate = true;
        } else if (cachedInfo.isExpired()) {
            urisToRequest.add(uri);
        }
        if (info != null && info != DeepLinkRequest.EMPTY && callTime > mostRecentCall) {
            mostRecentCall = callTime;
            toReturn = info;
        }
    }
    // issue new requests for any uri's we haven't handled previously
    if (urisToRequest.size() > 0) {
        enqueueRequest(urisToRequest, immediate);
    }
    return toReturn;
}
#method_after
public DeepLink getValue(String number, long[] times) {
    long mostRecentCall = Long.MIN_VALUE;
    DeepLink toReturn = null;
    List<Uri> urisToRequest = new ArrayList<Uri>();
    boolean immediate = false;
    // for all calls
    for (long callTime : times) {
        // generate the URI
        Uri uri = DeepLinkIntegrationManager.generateCallUri(number, callTime);
        String uriString = uri.toString();
        // hit the cache, do we have a link for this call?
        ExpirableCache.CachedValue<DeepLink> cachedInfo = mCache.getCachedValue(uriString);
        // if so is that a null object?
        DeepLink info = cachedInfo == null ? null : cachedInfo.getValue();
        if (cachedInfo == null) {
            // if its null we need to add a uri to our requests
            mCache.put(uriString, DeepLinkRequest.EMPTY);
            urisToRequest.add(uri);
            // if we get any uris that haven't been handled we need to immediately do this query
            immediate = true;
        } else if (cachedInfo.isExpired()) {
            urisToRequest.add(uri);
        }
        if (info != null && info != DeepLinkRequest.EMPTY && callTime > mostRecentCall) {
            mostRecentCall = callTime;
            toReturn = info;
        }
    }
    // issue new requests for any uri's we haven't handled previously
    if (urisToRequest.size() > 0) {
        enqueueRequest(urisToRequest, immediate);
    }
    return toReturn;
}
#end_block

#method_before
private synchronized void startRequestProcessing() {
    // unit testing
    if (mRequestProcessingDisabled)
        return;
    // If a thread is already started, don't start another.
    if (mDeepLinkQueryThread != null) {
        return;
    }
    mDeepLinkQueryThread = new QueryThread();
    mDeepLinkQueryThread.setPriority(Thread.MIN_PRIORITY);
    mDeepLinkQueryThread.start();
}
#method_after
private synchronized void startRequestProcessing() {
    if (mRequestProcessingDisabled)
        return;
    // If a thread is already started, don't start another.
    if (mDeepLinkQueryThread != null) {
        return;
    }
    mDeepLinkQueryThread = new QueryThread();
    mDeepLinkQueryThread.setPriority(Thread.MIN_PRIORITY);
    mDeepLinkQueryThread.start();
}
#end_block

#method_before
private synchronized void stopRequestProcessing() {
    // Remove any pending requests to start the processing thread.
    mHandler.removeMessages(START_THREAD);
    if (mDeepLinkQueryThread != null) {
        // Stop the thread; we are finished with it.
        mDeepLinkQueryThread.stopProcessing();
        mDeepLinkQueryThread.interrupt();
        mDeepLinkQueryThread = null;
    }
}
#method_after
private synchronized void stopRequestProcessing() {
    // Remove any pending requests to start the processing thread.
    mHandler.removeMessages(START_THREAD);
    if (mDeepLinkQueryThread != null) {
        // Stop the thread; we are finished with it.
        mDeepLinkQueryThread.stopProcessing();
        mDeepLinkQueryThread = null;
        mRequests.clear();
        mPendingRequests.clear();
    }
}
#end_block

#method_before
private void queryDeepLinks(DeepLinkRequest request) {
    for (Uri uri : request.getUris()) {
        DeepLinkIntegrationManager.getInstance().getPreferredLinksFor(mDeepLinkCallback, DeepLinkContentType.CALL, uri);
    }
}
#method_after
private void queryDeepLinks(DeepLinkRequest request) {
    synchronized (mPendingRequests) {
        mPendingRequests.put(request.getUris().get(0), DeepLinkIntegrationManager.getInstance().getPreferredLinksForList(mDeepLinkCallback, DeepLinkContentType.CALL, request.getUris()));
    }
}
#end_block

#method_before
/**
 * Binds the view holder for the call log list item view.
 *
 * @param viewHolder The call log list item view holder.
 * @param position The position of the list item.
 */
private void bindCallLogListViewHolder(ViewHolder viewHolder, int position) {
    Cursor c = (Cursor) getItem(position);
    if (c == null) {
        return;
    }
    final int count = getGroupSize(position);
    final String number = c.getString(CallLogQuery.NUMBER);
    final int numberPresentation = c.getInt(CallLogQuery.NUMBER_PRESENTATION);
    final PhoneAccountHandle accountHandle = PhoneAccountUtils.getAccount(c.getString(CallLogQuery.ACCOUNT_COMPONENT_NAME), c.getString(CallLogQuery.ACCOUNT_ID));
    final String countryIso = c.getString(CallLogQuery.COUNTRY_ISO);
    final ContactInfo cachedContactInfo = mContactInfoHelper.getContactInfo(c);
    final boolean isVoicemailNumber = mTelecomCallLogCache.isVoicemailNumber(accountHandle, number);
    // Note: Binding of the action buttons is done as required in configureActionViews when the
    // user expands the actions ViewStub.
    ContactInfo info = ContactInfo.EMPTY;
    if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation) && !isVoicemailNumber) {
        // Lookup contacts with this number
        info = mContactInfoCache.getValue(number, countryIso, cachedContactInfo);
    }
    CharSequence formattedNumber = info.formattedNumber == null ? null : PhoneNumberUtils.createTtsSpannable(info.formattedNumber);
    final PhoneCallDetails details = new PhoneCallDetails(mContext, number, numberPresentation, formattedNumber, isVoicemailNumber);
    details.accountHandle = accountHandle;
    details.callTypes = getCallTypes(c, count);
    details.countryIso = countryIso;
    details.date = c.getLong(CallLogQuery.DATE);
    details.duration = c.getLong(CallLogQuery.DURATION);
    details.features = getCallFeatures(c, count);
    details.geocode = c.getString(CallLogQuery.GEOCODED_LOCATION);
    details.transcription = c.getString(CallLogQuery.TRANSCRIPTION);
    if (details.callTypes[0] == CallLog.Calls.VOICEMAIL_TYPE) {
        details.isRead = c.getInt(CallLogQuery.IS_READ) == 1;
    }
    if (!c.isNull(CallLogQuery.DATA_USAGE)) {
        details.dataUsage = c.getLong(CallLogQuery.DATA_USAGE);
    }
    if (!TextUtils.isEmpty(info.name)) {
        details.contactUri = info.lookupUri;
        details.name = info.name;
        details.numberType = info.type;
        details.numberLabel = info.label;
        details.photoUri = info.photoUri;
        details.sourceType = info.sourceType;
        details.objectId = info.objectId;
    }
    final CallLogListItemViewHolder views = (CallLogListItemViewHolder) viewHolder;
    final DeepLinkAssistant deepLinkAssistant = new com.android.dialer.calllog.DeepLinkAssistant(views, mContext);
    views.info = info;
    views.rowId = c.getLong(CallLogQuery.ID);
    // Store values used when the actions ViewStub is inflated on expansion.
    views.number = number;
    views.displayNumber = details.displayNumber;
    views.numberPresentation = numberPresentation;
    views.callType = c.getInt(CallLogQuery.CALL_TYPE);
    views.accountHandle = accountHandle;
    views.voicemailUri = c.getString(CallLogQuery.VOICEMAIL_URI);
    // Stash away the Ids of the calls so that we can support deleting a row in the call log.
    views.callIds = getCallIds(c, count);
    views.isBusiness = mContactInfoHelper.isBusiness(info.sourceType);
    views.numberType = (String) Phone.getTypeLabel(mContext.getResources(), details.numberType, details.numberLabel);
    // Default case: an item in the call log.
    DeepLink dl = mDeepLinkCache.getValue(number, getCallTimes(c, count));
    if (dl != null && dl != DeepLinkRequest.EMPTY) {
        views.mDeepLink = dl;
        views.phoneCallDetailsViews.noteIconView.setVisibility(View.VISIBLE);
        views.phoneCallDetailsViews.noteIconView.setImageDrawable(dl.getDrawableIcon(mContext));
    } else {
        views.mDeepLink = null;
        views.phoneCallDetailsViews.noteIconView.setVisibility(View.GONE);
    }
    String component = c.getString(CallLogQuery.PLUGIN_PACKAGE_NAME);
    if (!TextUtils.isEmpty(component)) {
        views.inCallComponentName = ComponentName.unflattenFromString(component);
    } else {
        views.inCallComponentName = null;
    }
    // Default case: an item in the call log.
    views.primaryActionView.setVisibility(View.VISIBLE);
    views.callTimes = getCallTimes(c, count);
    deepLinkAssistant.prepareUi(number);
    // Check if the day group has changed and display a header if necessary.
    int currentGroup = getDayGroupForCall(views.rowId);
    int previousGroup = getPreviousDayGroup(c);
    if (currentGroup != previousGroup) {
        views.dayGroupHeader.setVisibility(View.VISIBLE);
        views.dayGroupHeader.setText(getGroupDescription(currentGroup));
    } else {
        views.dayGroupHeader.setVisibility(View.GONE);
    }
    mCallLogListItemHelper.setPhoneCallDetails(views, details);
    if (mCurrentlyExpandedRowId == views.rowId) {
        // In case ViewHolders were added/removed, update the expanded position if the rowIds
        // match so that we can restore the correct expanded state on rebind.
        mCurrentlyExpandedPosition = position;
    }
    views.showActions(mCurrentlyExpandedPosition == position);
    String nameForDefaultImage = null;
    if (TextUtils.isEmpty(info.name)) {
        nameForDefaultImage = details.displayNumber;
    } else {
        nameForDefaultImage = info.name;
    }
    views.setPhoto(info.photoId, info.photoUri, info.lookupUri, nameForDefaultImage, isVoicemailNumber, views.isBusiness);
    views.setAttributionImage(views.inCallComponentName);
    mCallLogListItemHelper.setPhoneCallDetails(views, details);
    mCallLogListItemHelper.setLookupInfoDetails(views, info);
}
#method_after
/**
 * Binds the view holder for the call log list item view.
 *
 * @param viewHolder The call log list item view holder.
 * @param position The position of the list item.
 */
private void bindCallLogListViewHolder(ViewHolder viewHolder, int position) {
    Cursor c = (Cursor) getItem(position);
    if (c == null) {
        return;
    }
    int count = getGroupSize(position);
    final String number = c.getString(CallLogQuery.NUMBER);
    final int numberPresentation = c.getInt(CallLogQuery.NUMBER_PRESENTATION);
    final PhoneAccountHandle accountHandle = PhoneAccountUtils.getAccount(c.getString(CallLogQuery.ACCOUNT_COMPONENT_NAME), c.getString(CallLogQuery.ACCOUNT_ID));
    final String countryIso = c.getString(CallLogQuery.COUNTRY_ISO);
    final ContactInfo cachedContactInfo = mContactInfoHelper.getContactInfo(c);
    final boolean isVoicemailNumber = mTelecomCallLogCache.isVoicemailNumber(accountHandle, number);
    // Note: Binding of the action buttons is done as required in configureActionViews when the
    // user expands the actions ViewStub.
    ContactInfo info = ContactInfo.EMPTY;
    if (PhoneNumberUtil.canPlaceCallsTo(number, numberPresentation) && !isVoicemailNumber) {
        // Lookup contacts with this number
        info = mContactInfoCache.getValue(number, countryIso, cachedContactInfo);
    }
    CharSequence formattedNumber = info.formattedNumber == null ? null : PhoneNumberUtils.createTtsSpannable(info.formattedNumber);
    final PhoneCallDetails details = new PhoneCallDetails(mContext, number, numberPresentation, formattedNumber, isVoicemailNumber);
    details.accountHandle = accountHandle;
    details.callTypes = getCallTypes(c, count);
    details.countryIso = countryIso;
    details.date = c.getLong(CallLogQuery.DATE);
    details.duration = c.getLong(CallLogQuery.DURATION);
    details.features = getCallFeatures(c, count);
    details.geocode = c.getString(CallLogQuery.GEOCODED_LOCATION);
    details.transcription = c.getString(CallLogQuery.TRANSCRIPTION);
    if (details.callTypes[0] == CallLog.Calls.VOICEMAIL_TYPE) {
        details.isRead = c.getInt(CallLogQuery.IS_READ) == 1;
    }
    if (!c.isNull(CallLogQuery.DATA_USAGE)) {
        details.dataUsage = c.getLong(CallLogQuery.DATA_USAGE);
    }
    if (!TextUtils.isEmpty(info.name)) {
        details.contactUri = info.lookupUri;
        details.name = info.name;
        details.numberType = info.type;
        details.numberLabel = info.label;
        details.photoUri = info.photoUri;
        details.sourceType = info.sourceType;
        details.objectId = info.objectId;
    }
    CallLogListItemViewHolder views = (CallLogListItemViewHolder) viewHolder;
    views.info = info;
    views.rowId = c.getLong(CallLogQuery.ID);
    // Store values used when the actions ViewStub is inflated on expansion.
    views.number = number;
    views.displayNumber = details.displayNumber;
    views.numberPresentation = numberPresentation;
    views.callType = c.getInt(CallLogQuery.CALL_TYPE);
    views.accountHandle = accountHandle;
    views.voicemailUri = c.getString(CallLogQuery.VOICEMAIL_URI);
    // Stash away the Ids of the calls so that we can support deleting a row in the call log.
    views.callIds = getCallIds(c, count);
    views.isBusiness = mContactInfoHelper.isBusiness(info.sourceType);
    views.numberType = (String) Phone.getTypeLabel(mContext.getResources(), details.numberType, details.numberLabel);
    String component = c.getString(CallLogQuery.PLUGIN_PACKAGE_NAME);
    if (!TextUtils.isEmpty(component)) {
        views.inCallComponentName = ComponentName.unflattenFromString(component);
    } else {
        views.inCallComponentName = null;
    }
    views.callTimes = getCallTimes(c, count);
    DeepLink dl = mDeepLinkCache.getValue(number, views.callTimes);
    if (dl != null && dl != DeepLinkRequest.EMPTY) {
        views.mDeepLink = dl;
        views.phoneCallDetailsViews.noteIconView.setVisibility(View.VISIBLE);
        views.phoneCallDetailsViews.noteIconView.setImageDrawable(dl.getDrawableIcon(mContext));
    } else {
        views.mDeepLink = null;
        views.phoneCallDetailsViews.noteIconView.setVisibility(View.GONE);
    }
    views.mDeepLinkPresenter.prepareUi(number);
    // Check if the day group has changed and display a header if necessary.
    int currentGroup = getDayGroupForCall(views.rowId);
    int previousGroup = getPreviousDayGroup(c);
    if (currentGroup != previousGroup) {
        views.dayGroupHeader.setVisibility(View.VISIBLE);
        views.dayGroupHeader.setText(getGroupDescription(currentGroup));
    } else {
        views.dayGroupHeader.setVisibility(View.GONE);
    }
    mCallLogListItemHelper.setPhoneCallDetails(views, details);
    if (mCurrentlyExpandedRowId == views.rowId) {
        // In case ViewHolders were added/removed, update the expanded position if the rowIds
        // match so that we can restore the correct expanded state on rebind.
        mCurrentlyExpandedPosition = position;
    }
    views.showActions(mCurrentlyExpandedPosition == position);
    String nameForDefaultImage = null;
    if (TextUtils.isEmpty(info.name)) {
        nameForDefaultImage = details.displayNumber;
    } else {
        nameForDefaultImage = info.name;
    }
    views.setPhoto(info.photoId, info.photoUri, info.lookupUri, nameForDefaultImage, isVoicemailNumber, views.isBusiness);
    views.setAttributionImage(views.inCallComponentName);
    mCallLogListItemHelper.setPhoneCallDetails(views, details);
    mCallLogListItemHelper.setLookupInfoDetails(views, info);
}
#end_block

#method_before
private void updateViews() {
    if (mDeepLink != null && mDeepLink != DeepLinkRequest.EMPTY) {
        if (mViews.viewNoteButton != null) {
            ImageView icon = (ImageView) mViews.viewNoteButton.findViewById(R.id.view_note_action_icon);
            icon.setImageDrawable(mDeepLink.getDrawableIcon(mContext));
            mViews.viewNoteButton.setVisibility(View.VISIBLE);
        }
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.VISIBLE);
        mViews.phoneCallDetailsViews.noteIconView.setImageDrawable(mDeepLink.getDrawableIcon(mContext));
    } else {
        mDeepLink = null;
        if (mViews.viewNoteButton != null) {
            mViews.viewNoteButton.setVisibility(View.GONE);
        }
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.GONE);
    }
}
#method_after
private void updateViews() {
    if (mDeepLink != null && mDeepLink != DeepLinkRequest.EMPTY) {
        if (canUpdateImageIconViews()) {
            mViews.viewNoteActionIcon.setImageDrawable(mDeepLink.getDrawableIcon(mContext));
            mViews.viewNoteButton.setVisibility(View.VISIBLE);
        }
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.VISIBLE);
        mViews.phoneCallDetailsViews.noteIconView.setImageDrawable(mDeepLink.getDrawableIcon(mContext));
    } else {
        if (canUpdateImageIconViews()) {
            mViews.viewNoteButton.setVisibility(View.GONE);
            mViews.viewNoteActionIcon.setImageDrawable(null);
        }
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.GONE);
    }
}
#end_block

#method_before
public void inflateActionViewStub() {
    ViewStub stub = (ViewStub) rootView.findViewById(R.id.call_log_entry_actions_stub);
    if (stub != null) {
        actionsView = (ViewGroup) stub.inflate();
        voicemailPlaybackView = (VoicemailPlaybackLayout) actionsView.findViewById(R.id.voicemail_playback_layout);
        callButtonView = actionsView.findViewById(R.id.call_action);
        callButtonView.setOnClickListener(this);
        videoCallButtonView = actionsView.findViewById(R.id.video_call_action);
        videoCallButtonView.setOnClickListener(this);
        createNewContactButtonView = actionsView.findViewById(R.id.create_new_contact_action);
        createNewContactButtonView.setOnClickListener(this);
        viewNoteButton = actionsView.findViewById(R.id.view_note_action);
        viewNoteButton.setOnClickListener(this);
        addToExistingContactButtonView = actionsView.findViewById(R.id.add_to_existing_contact_action);
        addToExistingContactButtonView.setOnClickListener(this);
        sendMessageView = actionsView.findViewById(R.id.send_message_action);
        sendMessageView.setOnClickListener(this);
        detailsButtonView = actionsView.findViewById(R.id.details_action);
        detailsButtonView.setOnClickListener(this);
        callWithNoteButtonView = actionsView.findViewById(R.id.call_with_note_action);
        callWithNoteButtonView.setOnClickListener(this);
        blockCallerButtonView = actionsView.findViewById(R.id.block_caller_action);
    }
    bindActionButtons();
}
#method_after
public void inflateActionViewStub() {
    ViewStub stub = (ViewStub) rootView.findViewById(R.id.call_log_entry_actions_stub);
    if (stub != null) {
        actionsView = (ViewGroup) stub.inflate();
        voicemailPlaybackView = (VoicemailPlaybackLayout) actionsView.findViewById(R.id.voicemail_playback_layout);
        callButtonView = actionsView.findViewById(R.id.call_action);
        callButtonView.setOnClickListener(this);
        videoCallButtonView = actionsView.findViewById(R.id.video_call_action);
        videoCallButtonView.setOnClickListener(this);
        createNewContactButtonView = actionsView.findViewById(R.id.create_new_contact_action);
        createNewContactButtonView.setOnClickListener(this);
        viewNoteButton = actionsView.findViewById(R.id.view_note_action);
        viewNoteActionIcon = (ImageView) actionsView.findViewById(R.id.view_note_action_icon);
        viewNoteButton.setOnClickListener(this);
        addToExistingContactButtonView = actionsView.findViewById(R.id.add_to_existing_contact_action);
        addToExistingContactButtonView.setOnClickListener(this);
        sendMessageView = actionsView.findViewById(R.id.send_message_action);
        sendMessageView.setOnClickListener(this);
        detailsButtonView = actionsView.findViewById(R.id.details_action);
        detailsButtonView.setOnClickListener(this);
        callWithNoteButtonView = actionsView.findViewById(R.id.call_with_note_action);
        callWithNoteButtonView.setOnClickListener(this);
        blockCallerButtonView = actionsView.findViewById(R.id.block_caller_action);
    }
    bindActionButtons();
}
#end_block

#method_before
private boolean linkExistsInCache(DeepLink link) {
    DeepLink oldLink = mCache.getPossiblyExpired(link.getUri().toString());
    return link.equals(oldLink);
}
#method_after
private boolean linkExistsInCache(DeepLink link) {
    ExpirableCache.CachedValue<DeepLink> oldLink = mCache.getCachedValue(link.getUri().toString());
    return oldLink != null && !oldLink.isExpired() && link.equals(oldLink.getValue());
}
#end_block

#method_before
@Override
public boolean onCallsFetched(Cursor cursor) {
    if (getActivity() == null || getActivity().isFinishing()) {
        // Return false; we did not take ownership of the cursor
        return false;
    }
    if (cursor != null) {
        while (cursor.moveToNext()) {
            mAdapter.buildCache(cursor);
        }
    }
    mAdapter.setLoading(false);
    mAdapter.changeCursor(cursor);
    // This will update the state of the "Clear call log" menu item.
    getActivity().invalidateOptionsMenu();
    boolean showListView = cursor != null && cursor.getCount() > 0;
    mRecyclerView.setVisibility(showListView ? View.VISIBLE : View.GONE);
    mEmptyListView.setVisibility(!showListView ? View.VISIBLE : View.GONE);
    if (mScrollToTop) {
        // near the top, and animate from there.
        if (mLayoutManager.findFirstVisibleItemPosition() > 5) {
            // TODO: Jump to near the top, then begin smooth scroll.
            mRecyclerView.smoothScrollToPosition(0);
        }
        // Workaround for framework issue: the smooth-scroll doesn't
        // occur if setSelection() is called immediately before.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                if (getActivity() == null || getActivity().isFinishing()) {
                    return;
                }
                mRecyclerView.smoothScrollToPosition(0);
            }
        });
        mScrollToTop = false;
    }
    mCallLogFetched = true;
    destroyEmptyLoaderIfAllDataFetched();
    return true;
}
#method_after
@Override
public boolean onCallsFetched(Cursor cursor) {
    if (getActivity() == null || getActivity().isFinishing()) {
        // Return false; we did not take ownership of the cursor
        return false;
    }
    mAdapter.mDeepLinkCache.buildCache();
    mAdapter.setLoading(false);
    mAdapter.changeCursor(cursor);
    // This will update the state of the "Clear call log" menu item.
    getActivity().invalidateOptionsMenu();
    boolean showListView = cursor != null && cursor.getCount() > 0;
    mRecyclerView.setVisibility(showListView ? View.VISIBLE : View.GONE);
    mEmptyListView.setVisibility(!showListView ? View.VISIBLE : View.GONE);
    if (mScrollToTop) {
        // near the top, and animate from there.
        if (mLayoutManager.findFirstVisibleItemPosition() > 5) {
            // TODO: Jump to near the top, then begin smooth scroll.
            mRecyclerView.smoothScrollToPosition(0);
        }
        // Workaround for framework issue: the smooth-scroll doesn't
        // occur if setSelection() is called immediately before.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                if (getActivity() == null || getActivity().isFinishing()) {
                    return;
                }
                mRecyclerView.smoothScrollToPosition(0);
            }
        });
        mScrollToTop = false;
    }
    mCallLogFetched = true;
    destroyEmptyLoaderIfAllDataFetched();
    return true;
}
#end_block

#method_before
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedState) {
    View view = inflater.inflate(R.layout.call_log_fragment, container, false);
    mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);
    mRecyclerView.setHasFixedSize(true);
    mLayoutManager = new LinearLayoutManager(getActivity());
    mRecyclerView.setLayoutManager(mLayoutManager);
    mEmptyListView = (EmptyContentView) view.findViewById(R.id.empty_list_view);
    mEmptyListView.setImage(R.drawable.empty_call_log);
    mEmptyListView.setActionClickedListener(this);
    String currentCountryIso = GeoUtil.getCurrentCountryIso(getActivity());
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setRecyclerListener(new RecyclerView.RecyclerListener() {

        @Override
        public void onViewRecycled(RecyclerView.ViewHolder holder) {
            if (holder instanceof CallLogListItemViewHolder) {
                final CallLogListItemViewHolder views = (CallLogListItemViewHolder) holder;
                mAdapter.mDeepLinkCache.clearPendingQueries(views.number, views.callTimes);
            }
        }
    });
    areDeepLinksEnabled();
    fetchCalls();
    return view;
}
#method_after
@Override
public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedState) {
    View view = inflater.inflate(R.layout.call_log_fragment, container, false);
    mRecyclerView = (RecyclerView) view.findViewById(R.id.recycler_view);
    mRecyclerView.setHasFixedSize(true);
    mLayoutManager = new LinearLayoutManager(getActivity());
    mRecyclerView.setLayoutManager(mLayoutManager);
    mEmptyListView = (EmptyContentView) view.findViewById(R.id.empty_list_view);
    mEmptyListView.setImage(R.drawable.empty_call_log);
    mEmptyListView.setActionClickedListener(this);
    String currentCountryIso = GeoUtil.getCurrentCountryIso(getActivity());
    mRecyclerView.setAdapter(mAdapter);
    mRecyclerView.setRecyclerListener(new RecyclerView.RecyclerListener() {

        @Override
        public void onViewRecycled(RecyclerView.ViewHolder holder) {
            if (holder instanceof CallLogListItemViewHolder) {
                final CallLogListItemViewHolder views = (CallLogListItemViewHolder) holder;
                mAdapter.mDeepLinkCache.clearPendingQueries(views.number, views.callTimes);
            }
        }
    });
    fetchCalls();
    return view;
}
#end_block

#method_before
@Override
public void onPause() {
    if (mVoicemailPlaybackPresenter != null) {
        mVoicemailPlaybackPresenter.onPause();
    }
    mAdapter.pauseCache();
    DialerDataSubscription.get(getActivity()).unsubscribe(AMBIENT_SUBSCRIPTION_ID);
    super.onPause();
}
#method_after
@Override
public void onPause() {
    if (mVoicemailPlaybackPresenter != null) {
        mVoicemailPlaybackPresenter.onPause();
    }
    mAdapter.pauseCache();
    DeepLinkIntegrationManager.getInstance().completeEnabledRequest(mDeepLinkEnabledCallback);
    DialerDataSubscription.get(getActivity()).unsubscribe(AMBIENT_SUBSCRIPTION_ID);
    super.onPause();
}
#end_block

#method_before
private void refreshData() {
    // Prevent unnecessary refresh.
    if (mRefreshDataRequired) {
        // Mark all entries in the contact info cache as out of date, so they will be looked up
        // again once being shown.
        mAdapter.invalidateCache();
        mAdapter.setLoading(true);
        fetchCalls();
        mCallLogQueryHandler.fetchVoicemailStatus();
        updateOnTransition(true);
        mRefreshDataRequired = false;
    } else {
        // Refresh the display of the existing data to update the timestamp text descriptions.
        mAdapter.notifyDataSetChanged();
    }
}
#method_after
private void refreshData() {
    if (!isAdded() || getActivity() == null) {
        // Fragment is not attached to the activity nothing to do
        return;
    }
    // Prevent unnecessary refresh.
    if (mRefreshDataRequired) {
        // Mark all entries in the contact info cache as out of date, so they will be looked up
        // again once being shown.
        mAdapter.invalidateCache();
        mAdapter.setLoading(true);
        fetchCalls();
        mCallLogQueryHandler.fetchVoicemailStatus();
        updateOnTransition(true);
        mRefreshDataRequired = false;
    } else {
        // Refresh the display of the existing data to update the timestamp text descriptions.
        mAdapter.notifyDataSetChanged();
    }
}
#end_block

#method_before
private void updateOnTransition(boolean onEntry) {
    // This might be called before onCreate() and thus we need to check null explicitly.
    if (mKeyguardManager != null && !mKeyguardManager.inKeyguardRestrictedInputMode()) {
        // On either of the transitions we update the missed call and voicemail notifications.
        // While exiting we additionally consume all missed calls (by marking them as read).
        mCallLogQueryHandler.markNewCallsAsOld();
        if (!onEntry) {
            mCallLogQueryHandler.markMissedCallsAsRead();
        }
        CallLogNotificationsHelper.removeMissedCallNotifications(getActivity());
        CallLogNotificationsHelper.updateVoicemailNotifications(getActivity());
    }
}
#method_after
private void updateOnTransition(boolean onEntry) {
    // This might be called before onCreate() and thus we need to check null explicitly.
    if (mKeyguardManager != null && !mKeyguardManager.inKeyguardRestrictedInputMode()) {
        // On either of the transitions we update the missed call and voicemail notifications.
        // While exiting we additionally consume all missed calls (by marking them as read).
        mCallLogQueryHandler.markNewCallsAsOld();
        if (!onEntry) {
            mCallLogQueryHandler.markMissedCallsAsRead();
        }
        Activity activity = getActivity();
        if (activity == null) {
            return;
        }
        CallLogNotificationsHelper.removeMissedCallNotifications(activity);
        CallLogNotificationsHelper.updateVoicemailNotifications(activity);
    }
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        // Check if thread is finished, and if so return immediately.
        if (mDone)
            return;
        // Obtain next request, if any is available.
        // Keep synchronized section small.
        DeepLinkRequest req = null;
        int pendingSize = mPendingRequests.size();
        synchronized (mRequests) {
            if (!mRequests.isEmpty() && pendingSize < DONT_OVERLOAD_AMBIENT) {
                req = mRequests.removeFirst();
            }
        }
        if (req != null) {
            // Process the request.
            queryDeepLinks(req);
        } else if (needRedraw) {
            needRedraw = false;
            mHandler.sendEmptyMessage(REDRAW);
        } else if (mPendingRequests.size() < DONT_OVERLOAD_AMBIENT) {
            // interrupted).
            try {
                synchronized (mRequests) {
                    if (mRequests.isEmpty()) {
                        mRequests.wait(PROCESSING_THREAD_THROTTLE_LIMIT);
                    }
                }
            } catch (InterruptedException ie) {
            // Ignore, and attempt to continue processing requests.
            }
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        // Check if thread is finished, and if so return immediately.
        if (mDone)
            return;
        // Obtain next request, if any is available.
        // Keep synchronized section small.
        DeepLinkRequest req = null;
        int pendingSize = mPendingRequests.size();
        synchronized (mRequests) {
            if (!mRequests.isEmpty() && pendingSize < MAX_REQUEST_COUNT) {
                req = mRequests.removeFirst();
            }
        }
        if (req != null) {
            // Process the request.
            queryDeepLinks(req);
        } else if (needRedraw) {
            needRedraw = false;
            mHandler.sendEmptyMessage(REDRAW);
        } else {
            // interrupted).
            try {
                synchronized (mRequests) {
                    if (mRequests.isEmpty()) {
                        mRequests.wait(PROCESSING_THREAD_THROTTLE_LIMIT);
                    }
                }
            } catch (InterruptedException ie) {
            // Ignore, and attempt to continue processing requests.
            }
        }
    }
}
#end_block

#method_before
public DeepLink getValue(String number, long[] times) {
    long mostRecentCall = Long.MIN_VALUE;
    DeepLink toReturn = null;
    List<Uri> urisToRequest = new ArrayList<Uri>();
    boolean immediate = false;
    // for all calls
    for (long callTime : times) {
        // generate the URI
        Uri uri = DeepLinkIntegrationManager.generateCallUri(number, callTime);
        String uriString = uri.toString();
        // hit the cache, do we have a link for this call?
        ExpirableCache.CachedValue<DeepLink> cachedInfo = mCache.getCachedValue(uriString);
        // if so is that a null object?
        DeepLink info = cachedInfo == null ? null : cachedInfo.getValue();
        if (cachedInfo == null) {
            // if its null we need to add a uri to our requests
            mCache.put(uriString, DeepLinkRequest.EMPTY);
            urisToRequest.add(uri);
            // if we get any uris that haven't been handled we need to immediately do this query
            immediate = true;
        } else if (cachedInfo.isExpired()) {
            urisToRequest.add(uri);
        }
        if (info != null && info != DeepLinkRequest.EMPTY && callTime > mostRecentCall) {
            mostRecentCall = callTime;
            toReturn = info;
        }
    }
    // issue new requests for any uri's we haven't handleg previously
    if (urisToRequest.size() > 0) {
        enqueueRequest(urisToRequest, immediate);
    }
    return toReturn;
}
#method_after
public DeepLink getValue(String number, long[] times) {
    long mostRecentCall = Long.MIN_VALUE;
    DeepLink toReturn = null;
    List<Uri> urisToRequest = new ArrayList<Uri>();
    boolean immediate = false;
    // for all calls
    for (long callTime : times) {
        // generate the URI
        Uri uri = DeepLinkIntegrationManager.generateCallUri(number, callTime);
        String uriString = uri.toString();
        // hit the cache, do we have a link for this call?
        ExpirableCache.CachedValue<DeepLink> cachedInfo = mCache.getCachedValue(uriString);
        // if so is that a null object?
        DeepLink info = cachedInfo == null ? null : cachedInfo.getValue();
        if (cachedInfo == null) {
            // if its null we need to add a uri to our requests
            urisToRequest.add(uri);
            // if we get any uris that haven't been handled we need to immediately do this query
            immediate = true;
        } else if (cachedInfo.isExpired()) {
            urisToRequest.add(uri);
        }
        if (info != null && info != DeepLinkRequest.EMPTY && callTime > mostRecentCall) {
            mostRecentCall = callTime;
            toReturn = info;
        }
    }
    // issue new requests for any uri's we haven't handled previously
    if (urisToRequest.size() > 0) {
        enqueueRequest(urisToRequest, immediate);
    }
    return toReturn;
}
#end_block

#method_before
protected void enqueueRequest(List<Uri> uris, boolean immediate) {
    DeepLinkRequest request = new DeepLinkRequest(uris);
    synchronized (mRequests) {
        if (!mRequests.contains(request)) {
            mRequests.add(request);
            mRequests.notifyAll();
        }
    }
    if (immediate) {
        startRequestProcessing();
    }
}
#method_after
protected void enqueueRequest(List<Uri> uris, boolean immediate) {
    DeepLinkRequest request = new DeepLinkRequest(uris);
    synchronized (mRequests) {
        if (!mRequests.contains(request)) {
            mRequests.addFirst(request);
            mRequests.notifyAll();
        }
    }
    if (immediate) {
        startRequestProcessing();
    }
}
#end_block

#method_before
private void handleDeepLinkResults(List<DeepLink> results) {
    for (DeepLink link : results) {
        if (shouldPlaceLinkInCache(link)) {
            mCache.put(link.getUri().toString(), link);
            if (mDeepLinkQueryThread != null) {
                mDeepLinkQueryThread.needRedraw = true;
            }
        }
    }
}
#method_after
private void handleDeepLinkResults(List<DeepLink> results) {
    if (results == null) {
        return;
    }
    for (DeepLink link : results) {
        if (shouldPlaceLinkInCache(link)) {
            mCache.put(link.getUri().toString(), link);
            if (mDeepLinkQueryThread != null) {
                mDeepLinkQueryThread.needRedraw = true;
            }
        }
    }
}
#end_block

#method_before
private void queryDeepLinks(DeepLinkRequest request) {
    final Uri uri = request.getUris().get(0);
    synchronized (mPendingRequests) {
        mPendingRequests.put(uri, DeepLinkIntegrationManager.getInstance().getPreferredLinksForList(new ResultCallback<DeepLink.DeepLinkResultList>() {

            @Override
            public void onResult(DeepLink.DeepLinkResultList result) {
                List<DeepLink> results = result.getResults();
                if (results == null || results.size() == 0) {
                    return;
                }
                mPendingRequests.remove(uri);
                handleDeepLinkResults(result.getResults());
            }
        }, DeepLinkContentType.CALL, request.getUris()));
    }
}
#method_after
private void queryDeepLinks(DeepLinkRequest request) {
    final DeepLinkIntegrationManager dlim = DeepLinkIntegrationManager.getInstance();
    final Uri uri = request.getUris().get(0);
    final PendingResult<DeepLink.DeepLinkResultList> pendingRequest = dlim.getPreferredLinksForList(new ResultCallback<DeepLink.DeepLinkResultList>() {

        @Override
        public void onResult(DeepLink.DeepLinkResultList result) {
            mPendingRequests.remove(uri);
            handleDeepLinkResults(result.getResults());
        }
    }, DeepLinkContentType.CALL, request.getUris());
    if (pendingRequest != null) {
        synchronized (mPendingRequests) {
            mPendingRequests.put(uri, pendingRequest);
        }
    }
}
#end_block

#method_before
public void clearPendingQueries(String number, long[] calltimes) {
    synchronized (mPendingRequests) {
        Uri uri = DeepLinkIntegrationManager.generateCallUri(number, calltimes[0]);
        if (mPendingRequests.containsKey(uri)) {
            PendingResult<DeepLink.DeepLinkResultList> request = mPendingRequests.remove(uri);
            if (request != null) {
                request.cancel();
            }
        }
    }
}
#method_after
public void clearPendingQueries(String number, long[] calltimes) {
    synchronized (mPendingRequests) {
        Uri uri = DeepLinkIntegrationManager.generateCallUri(number, calltimes[0]);
        PendingResult<DeepLink.DeepLinkResultList> request = mPendingRequests.remove(uri);
        if (request != null) {
            request.cancel();
        }
    }
}
#end_block

#method_before
public void clearCache() {
    mCache.clearCache();
}
#method_after
public void clearCache() {
    mCache.clearCache();
    mDrawableCache.clear();
}
#end_block

#method_before
private ViewHolder createCallLogEntryViewHolder(ViewGroup parent) {
    LayoutInflater inflater = LayoutInflater.from(mContext);
    View view = inflater.inflate(R.layout.call_log_list_item, parent, false);
    CallLogListItemViewHolder viewHolder = CallLogListItemViewHolder.create(view, mContext, mExpandCollapseListener, mTelecomCallLogCache, mCallLogListItemHelper, mVoicemailPlaybackPresenter, mBlockContactPresenter, mContactInfoHelper);
    viewHolder.callLogEntryView.setTag(viewHolder);
    viewHolder.callLogEntryView.setAccessibilityDelegate(mAccessibilityDelegate);
    viewHolder.primaryActionView.setOnCreateContextMenuListener(mOnCreateContextMenuListener);
    viewHolder.primaryActionView.setTag(viewHolder);
    return viewHolder;
}
#method_after
private ViewHolder createCallLogEntryViewHolder(ViewGroup parent) {
    LayoutInflater inflater = LayoutInflater.from(mContext);
    View view = inflater.inflate(R.layout.call_log_list_item, parent, false);
    CallLogListItemViewHolder viewHolder = CallLogListItemViewHolder.create(view, mContext, mExpandCollapseListener, mTelecomCallLogCache, mCallLogListItemHelper, mVoicemailPlaybackPresenter, mBlockContactPresenter, mContactInfoHelper, mDeepLinkCache);
    viewHolder.callLogEntryView.setTag(viewHolder);
    viewHolder.callLogEntryView.setAccessibilityDelegate(mAccessibilityDelegate);
    viewHolder.primaryActionView.setOnCreateContextMenuListener(mOnCreateContextMenuListener);
    viewHolder.primaryActionView.setTag(viewHolder);
    return viewHolder;
}
#end_block

#method_before
private void updateViews() {
    if (mDeepLink != null && mDeepLink != DeepLinkRequest.EMPTY) {
        Drawable icon = getDrawableIcon(mDeepLink);
        if (canUpdateImageIconViews()) {
            mViews.viewNoteActionIcon.setImageDrawable(getFromIconCache(mDeepLink.getPackageName() + TINT_KEY));
            mViews.viewNoteButton.setVisibility(View.VISIBLE);
        }
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.VISIBLE);
        mViews.phoneCallDetailsViews.noteIconView.setImageDrawable(icon);
    } else {
        if (canUpdateImageIconViews()) {
            mViews.viewNoteButton.setVisibility(View.GONE);
            mViews.viewNoteActionIcon.setImageDrawable(null);
        }
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.GONE);
    }
}
#method_after
private void updateViews() {
    if (hasValidLink()) {
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.VISIBLE);
        mViews.phoneCallDetailsViews.noteIconView.setImageDrawable(getLinkIcon());
    } else {
        mViews.phoneCallDetailsViews.noteIconView.setVisibility(View.GONE);
    }
    bindActionButton();
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    mTelephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    // Register the broadcast receiver
    final IntentFilter filter = new IntentFilter(ALARM_SNOOZE_ACTION);
    filter.addAction(ALARM_DISMISS_ACTION);
    registerReceiver(mActionsReceiver, filter);
    mIsRegistered = true;
    // set up for flip and shake actions
    mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    String s;
    s = prefs.getString(SettingsActivity.KEY_FLIP_ACTION, null);
    mFlipAction = (s != null) ? Integer.parseInt(s) : R.integer.config_defaultActionFlip;
    s = prefs.getString(SettingsActivity.KEY_SHAKE_ACTION, null);
    mShakeAction = (s != null) ? Integer.parseInt(s) : R.integer.config_defaultActionShake;
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    mTelephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    // Register the broadcast receiver
    final IntentFilter filter = new IntentFilter(ALARM_SNOOZE_ACTION);
    filter.addAction(ALARM_DISMISS_ACTION);
    registerReceiver(mActionsReceiver, filter);
    mIsRegistered = true;
    // set up for flip and shake actions
    mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    String action = prefs.getString(SettingsActivity.KEY_FLIP_ACTION, null);
    mFlipAction = (action != null) ? Integer.parseInt(action) : getResources().getInteger(R.integer.config_defaultActionFlip);
    action = prefs.getString(SettingsActivity.KEY_SHAKE_ACTION, null);
    mShakeAction = (action != null) ? Integer.parseInt(action) : getResources().getInteger(R.integer.config_defaultActionShake);
}
#end_block

#method_before
private void attachListeners() {
    if (mFlipAction != ALARM_NO_ACTION) {
        mSensorManager.registerListener(mFlipListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL, // batch every 300 milliseconds
        300 * 1000);
    }
    if (mShakeAction != ALARM_NO_ACTION) {
        mSensorManager.registerListener(mShakeListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_GAME, // batch every 50 milliseconds
        50 * 1000);
    }
}
#method_after
private void attachListeners() {
    if (mFlipAction != ALARM_NO_ACTION) {
        mFlipListener.reset();
        mSensorManager.registerListener(mFlipListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL, // batch every 300 milliseconds
        300 * 1000);
    }
    if (mShakeAction != ALARM_NO_ACTION) {
        mSensorManager.registerListener(mShakeListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_GAME, // batch every 50 milliseconds
        50 * 1000);
    }
}
#end_block

#method_before
private void refresh() {
    final ListPreference autoSilencePref = (ListPreference) findPreference(KEY_AUTO_SILENCE);
    String delay = autoSilencePref.getValue();
    updateAutoSnoozeSummary(autoSilencePref, delay);
    autoSilencePref.setOnPreferenceChangeListener(this);
    final ListPreference clockStylePref = (ListPreference) findPreference(KEY_CLOCK_STYLE);
    clockStylePref.setSummary(clockStylePref.getEntry());
    clockStylePref.setOnPreferenceChangeListener(this);
    final Preference autoHomeClockPref = findPreference(KEY_AUTO_HOME_CLOCK);
    final boolean autoHomeClockEnabled = ((SwitchPreference) autoHomeClockPref).isChecked();
    autoHomeClockPref.setOnPreferenceChangeListener(this);
    final ListPreference homeTimezonePref = (ListPreference) findPreference(KEY_HOME_TZ);
    homeTimezonePref.setEnabled(autoHomeClockEnabled);
    homeTimezonePref.setSummary(homeTimezonePref.getEntry());
    homeTimezonePref.setOnPreferenceChangeListener(this);
    final ListPreference volumeButtonsPref = (ListPreference) findPreference(KEY_VOLUME_BUTTONS);
    updateActionSummary(volumeButtonsPref, volumeButtonsPref.getValue(), R.string.volume_buttons_summary);
    volumeButtonsPref.setOnPreferenceChangeListener(this);
    SensorManager sensorManager = (SensorManager) getActivity().getSystemService(Context.SENSOR_SERVICE);
    final ListPreference flipActionPref = (ListPreference) findPreference(KEY_FLIP_ACTION);
    if (flipActionPref != null) {
        List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER);
        if (sensorList.size() < 1) {
            // This will be true if no accelerometer sensor
            // Turn it off
            flipActionPref.setValue("0");
            PreferenceCategory category = (PreferenceCategory) findPreference(KEY_ALARM_SETTINGS);
            if (category != null) {
                category.removePreference(flipActionPref);
            }
        } else {
            updateActionSummary(flipActionPref, flipActionPref.getValue(), R.string.flip_action_summary);
            flipActionPref.setOnPreferenceChangeListener(this);
        }
    }
    final ListPreference shakeActionPref = (ListPreference) findPreference(KEY_SHAKE_ACTION);
    if (shakeActionPref != null) {
        List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER);
        if (sensorList.size() < 1) {
            // This will be true if no accelerometer sensor
            // Turn it off
            shakeActionPref.setValue("0");
            PreferenceCategory category = (PreferenceCategory) findPreference(KEY_ALARM_SETTINGS);
            if (category != null) {
                category.removePreference(shakeActionPref);
            }
        } else {
            updateActionSummary(shakeActionPref, shakeActionPref.getValue(), R.string.shake_action_summary);
            shakeActionPref.setOnPreferenceChangeListener(this);
        }
    }
    final Preference volumePref = findPreference(KEY_ALARM_VOLUME);
    volumePref.setOnPreferenceClickListener(this);
    final SnoozeLengthDialog snoozePref = (SnoozeLengthDialog) findPreference(KEY_ALARM_SNOOZE);
    snoozePref.setSummary();
    final SwitchPreference showAlarmIconPref = (SwitchPreference) findPreference(KEY_SHOW_ALARM_ICON);
    showAlarmIconPref.setOnPreferenceChangeListener(this);
}
#method_after
private void refresh() {
    final ListPreference autoSilencePref = (ListPreference) findPreference(KEY_AUTO_SILENCE);
    String delay = autoSilencePref.getValue();
    updateAutoSnoozeSummary(autoSilencePref, delay);
    autoSilencePref.setOnPreferenceChangeListener(this);
    final ListPreference clockStylePref = (ListPreference) findPreference(KEY_CLOCK_STYLE);
    clockStylePref.setSummary(clockStylePref.getEntry());
    clockStylePref.setOnPreferenceChangeListener(this);
    final Preference autoHomeClockPref = findPreference(KEY_AUTO_HOME_CLOCK);
    final boolean autoHomeClockEnabled = ((SwitchPreference) autoHomeClockPref).isChecked();
    autoHomeClockPref.setOnPreferenceChangeListener(this);
    final ListPreference homeTimezonePref = (ListPreference) findPreference(KEY_HOME_TZ);
    homeTimezonePref.setEnabled(autoHomeClockEnabled);
    homeTimezonePref.setSummary(homeTimezonePref.getEntry());
    homeTimezonePref.setOnPreferenceChangeListener(this);
    final ListPreference volumeButtonsPref = (ListPreference) findPreference(KEY_VOLUME_BUTTONS);
    updateActionSummary(volumeButtonsPref, volumeButtonsPref.getValue(), R.string.volume_buttons_summary);
    volumeButtonsPref.setOnPreferenceChangeListener(this);
    SensorManager sensorManager = (SensorManager) getActivity().getSystemService(Context.SENSOR_SERVICE);
    final ListPreference flipActionPref = (ListPreference) findPreference(KEY_FLIP_ACTION);
    if (flipActionPref != null) {
        if (sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) == null) {
            // Turn it off
            flipActionPref.setValue("0");
            PreferenceCategory category = (PreferenceCategory) findPreference(KEY_ALARM_SETTINGS);
            if (category != null) {
                category.removePreference(flipActionPref);
            }
        } else {
            updateActionSummary(flipActionPref, flipActionPref.getValue(), R.string.flip_action_summary);
            flipActionPref.setOnPreferenceChangeListener(this);
        }
    }
    final ListPreference shakeActionPref = (ListPreference) findPreference(KEY_SHAKE_ACTION);
    if (shakeActionPref != null) {
        List<Sensor> sensorList = sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER);
        if (sensorList.size() < 1) {
            // This will be true if no accelerometer sensor
            // Turn it off
            shakeActionPref.setValue("0");
            PreferenceCategory category = (PreferenceCategory) findPreference(KEY_ALARM_SETTINGS);
            if (category != null) {
                category.removePreference(shakeActionPref);
            }
        } else {
            updateActionSummary(shakeActionPref, shakeActionPref.getValue(), R.string.shake_action_summary);
            shakeActionPref.setOnPreferenceChangeListener(this);
        }
    }
    final Preference volumePref = findPreference(KEY_ALARM_VOLUME);
    volumePref.setOnPreferenceClickListener(this);
    final SnoozeLengthDialog snoozePref = (SnoozeLengthDialog) findPreference(KEY_ALARM_SNOOZE);
    snoozePref.setSummary();
    final SwitchPreference showAlarmIconPref = (SwitchPreference) findPreference(KEY_SHOW_ALARM_ICON);
    showAlarmIconPref.setOnPreferenceChangeListener(this);
}
#end_block

#method_before
public static BlockRequest createFrom(Context context, String phoneNumber) {
    if (TextUtils.isEmpty(phoneNumber) || !PhoneNumberHelper.isValidNumber(context, phoneNumber, "")) {
        return EMPTY;
    }
    BlockRequest blockRequest = new BlockRequest();
    blockRequest.phoneNumbers = new ArrayList<String>();
    blockRequest.phoneNumbers.add(PhoneNumberHelper.formatPhoneNumber(context, phoneNumber));
    return blockRequest;
}
#method_after
public static BlockRequest createFrom(Context context, String phoneNumber) {
    if (TextUtils.isEmpty(phoneNumber) || !PhoneNumberHelper.isValidNumber(context, phoneNumber, null)) {
        return EMPTY;
    }
    BlockRequest blockRequest = new BlockRequest();
    blockRequest.phoneNumbers = new ArrayList<String>();
    blockRequest.phoneNumbers.add(PhoneNumberHelper.formatPhoneNumber(context, phoneNumber));
    return blockRequest;
}
#end_block

#method_before
@Override
public void computeScroll() {
    if (autoScrolling)
        return;
    super.computeScroll();
}
#method_after
@Override
public void computeScroll() {
    if (autoScrolling) {
        return;
    }
    super.computeScroll();
}
#end_block

#method_before
@Override
public void scrollTo(int x, int y) {
    if (autoScrolling)
        return;
    super.scrollTo(x, y);
}
#method_after
@Override
public void scrollTo(int x, int y) {
    if (autoScrolling) {
        return;
    }
    super.scrollTo(x, y);
}
#end_block

#method_before
public static String replaceAllWithNumbers(String input) {
    String result = "";
    goingForward: for (int i = 0; i < input.length(); i++) {
        // Start reading character by character forwards
        String goingForward = input.substring(i);
        for (int j = 0; j < goingForward.length(); j++) {
            // And, in each loop, character by character backwards
            String goingBackward = goingForward.substring(0, goingForward.length() - j);
            // Attempt to parse words as numbers (ie: three)
            try {
                long value = SpellContext.parse(goingBackward);
                result += value;
                // This worked. Add the length of goingBackward to
                // the init loop.
                i += goingBackward.length() - 1;
                continue goingForward;
            } catch (SpellException e) {
            }
        }
        result += input.charAt(i);
    }
    return result;
}
#method_after
public static String replaceAllWithNumbers(String input) {
    String result = "";
    goingForward: for (int i = 0; i < input.length(); i++) {
        // Start reading character by character forwards
        String goingForward = input.substring(i);
        for (int j = 0; j < goingForward.length(); j++) {
            // And, in each loop, character by character backwards
            String goingBackward = goingForward.substring(0, goingForward.length() - j);
            // Attempt to parse words as numbers (ie: three)
            try {
                long value = SpellContext.parse(goingBackward);
                result += value;
                // This worked. Add the length of goingBackward to the init loop
                i += goingBackward.length() - 1;
                continue goingForward;
            } catch (SpellException e) {
            // Do nothing here
            }
        }
        result += input.charAt(i);
    }
    return result;
}
#end_block

#method_before
public static long parseBelow1000(String text) throws SpellException {
    long value = 0;
    String[] words = text.replaceAll(" and ", " ").split("\\s");
    for (String word : words) {
        if (!myBelowThousandWordList.contains(word)) {
            throw new SpellException("Unknown token : " + word);
        }
        long subval = getValueOf(word);
        if (subval == 100) {
            if (value == 0)
                value = 100;
            else
                value *= 100;
        } else
            value += subval;
    }
    return value;
}
#method_after
public static long parseBelow1000(String text) throws SpellException {
    long value = 0;
    String[] words = text.replaceAll(" and ", " ").split("\\s");
    for (String word : words) {
        if (!myBelowThousandWordList.contains(word)) {
            throw new SpellException("Unknown token : " + word);
        }
        long subval = getValueOf(word);
        if (subval == 100) {
            if (value == 0) {
                value = 100;
            } else {
                value *= 100;
            }
        } else {
            value += subval;
        }
    }
    return value;
}
#end_block

#method_before
public static long parse(String text) throws SpellException {
    text = text.toLowerCase(Locale.US).replaceAll("[,]", " ").replaceAll(" and ", " ");
    long totalValue = 0;
    boolean processed = false;
    for (int n = 0; n < mySuffixWords.length; n++) {
        int index = text.indexOf(mySuffixWords[n]);
        if (index >= 0) {
            String text1 = text.substring(0, index).trim();
            String text2 = text.substring(index + mySuffixWords[n].length()).trim();
            if (text1.equals(""))
                text1 = "one";
            if (text2.equals(""))
                text2 = "zero";
            totalValue = parseBelow1000(text1) * mySuffixValues[n] + parse(text2);
            processed = true;
            break;
        }
    }
    if (processed)
        return totalValue;
    else
        return parseBelow1000(text);
}
#method_after
public static long parse(String text) throws SpellException {
    text = text.toLowerCase(Locale.US).replaceAll("[,]", " ").replaceAll(" and ", " ");
    long totalValue = 0;
    boolean processed = false;
    for (int n = 0; n < mySuffixWords.length; n++) {
        int index = text.indexOf(mySuffixWords[n]);
        if (index >= 0) {
            String text1 = text.substring(0, index).trim();
            String text2 = text.substring(index + mySuffixWords[n].length()).trim();
            if (text1.equals("")) {
                text1 = "one";
            }
            if (text2.equals("")) {
                text2 = "zero";
            }
            totalValue = parseBelow1000(text1) * mySuffixValues[n] + parse(text2);
            processed = true;
            break;
        }
    }
    if (processed) {
        return totalValue;
    } else {
        return parseBelow1000(text);
    }
}
#end_block

#method_before
private static char[] opSplit(String str) {
    StringBuilder buffer = new StringBuilder();
    char c, prev;
    prev = str.charAt(0);
    for (int i = 0; i < str.length(); i++) {
        c = str.charAt(i);
        if (c == '^' || c == Logic.MUL || c == Logic.DIV || c == '+')
            buffer.append(c);
        else if (c == '-' && (Character.isDigit(prev) || prev == ']') && (prev != 'e'))
            buffer.append(c);
        prev = c;
    }
    return buffer.toString().toCharArray();
}
#method_after
private static char[] opSplit(String str) {
    StringBuilder buffer = new StringBuilder();
    char c, prev;
    prev = str.charAt(0);
    for (int i = 0; i < str.length(); i++) {
        c = str.charAt(i);
        if (c == '^' || c == Logic.MUL || c == Logic.DIV || c == '+') {
            buffer.append(c);
        } else if (c == '-' && (Character.isDigit(prev) || prev == ']') && (prev != 'e')) {
            buffer.append(c);
        }
        prev = c;
    }
    return buffer.toString().toCharArray();
}
#end_block

#method_before
private static int[] lookAfield(Object[] field, int orig) {
    int left, right;
    // Start with the original position (of the operator)
    // Left operand is at the same index as its operator
    // But if it's null, look farther left
    int pos = orig;
    while (field[pos] == null) // 
    pos--;
    left = pos;
    // Right operand is one greater than the operator index
    pos = orig + 1;
    while (field[pos] == null) // Look to the right if null
    pos++;
    // Found it
    right = pos;
    // Return the indices to allow later
    return new int[] { left, right };
// sub-in of null
}
#method_after
private static int[] lookAfield(Object[] field, int orig) {
    int left, right;
    // Start with the original position (of the operator).
    // Left operand is at the same index as its operator.
    // But if it's null, look farther left.
    int pos = orig;
    while (field[pos] == null) {
        pos--;
    }
    left = pos;
    // Right operand is one greater than the operator index
    pos = orig + 1;
    while (field[pos] == null) {
        // Look to the right if null
        pos++;
    }
    // Found it
    right = pos;
    // Return the indices to allow later
    return new int[] { left, right };
}
#end_block

#method_before
private static String fact(int n) {
    long m = n;
    for (int i = n - 1; i > 1; i--) m *= i;
    return Long.toString(m);
}
#method_after
private static String fact(int n) {
    long m = n;
    for (int i = n - 1; i > 1; i--) {
        m *= i;
    }
    return Long.toString(m);
}
#end_block

#method_before
private static String numToString(double arg) {
    // Cut off very small arguments
    if (Math.abs(arg) < 1.0E-10)
        return "0";
    String temp = Double.toString(arg).replace('E', 'e');
    if (temp.endsWith(".0"))
        temp = temp.substring(0, temp.length() - 2);
    return temp;
}
#method_after
private static String numToString(double arg) {
    // Cut off very small arguments
    if (Math.abs(arg) < 1.0E-10) {
        return "0";
    }
    String temp = Double.toString(arg).replace('E', 'e');
    if (temp.endsWith(".0")) {
        temp = temp.substring(0, temp.length() - 2);
    }
    return temp;
}
#end_block

#method_before
private static String printMatrix(SimpleMatrix mat) {
    StringBuilder buffer = new StringBuilder("[");
    int m = mat.numRows();
    int n = mat.numCols();
    for (int i = 0; i < m; i++) {
        buffer.append('[');
        for (int j = 0; j < n; j++) {
            buffer.append(numToString(mat.get(i, j)));
            if (j != n - 1)
                buffer.append(',');
        }
        buffer.append(']');
    }
    buffer.append(']');
    return buffer.toString();
}
#method_after
private static String printMatrix(SimpleMatrix mat) {
    StringBuilder buffer = new StringBuilder("[");
    int m = mat.numRows();
    int n = mat.numCols();
    for (int i = 0; i < m; i++) {
        buffer.append('[');
        for (int j = 0; j < n; j++) {
            buffer.append(numToString(mat.get(i, j)));
            if (j != n - 1) {
                buffer.append(',');
            }
        }
        buffer.append(']');
    }
    buffer.append(']');
    return buffer.toString();
}
#end_block

#method_before
double gatherScalar(String text) throws SyntaxException {
    if (!Character.isDigit(text.charAt(1)))
        throw new SyntaxException();
    return Double.parseDouble(text.substring(1));
}
#method_after
double gatherScalar(String text) throws SyntaxException {
    if (!Character.isDigit(text.charAt(1))) {
        throw new SyntaxException();
    }
    return Double.parseDouble(text.substring(1));
}
#end_block

#method_before
// The following have a lot of repeated boilerplate code.
// Condensing it down would require language features/properties
// that Java does not have.
// In short, Java is not F#.
private String calculate(String input) throws SyntaxException {
    // I never realized negative numbers could be so difficult.
    input = input.replace(Logic.MINUS, '-');
    // All remaining instances of U+2212 will be on negative numbers.
    // They will be counted as whole tokens.
    // Instantiate matrices first.
    Matcher m = Pattern.compile("\\[\\[.+?\\]\\]").matcher(input);
    while (m.find()) {
        SimpleMatrix temp = parseMatrix(m.group());
        input = input.replace(m.group(), printMatrix(temp));
    }
    // Get percentage.
    input = input.replaceAll("(?<=\\d)%(?!\\d)", "\u00d70.01");
    // Might as well get factorial too.
    m = Pattern.compile("(?<!\\.)([0-9]+)\\!").matcher(input);
    while (m.find()) {
        int temp = Integer.parseInt(m.group(1));
        input = input.replace(m.group(), fact(temp));
    }
    int open = 0;
    for (int i = 0; i < input.length(); i++) {
        if (input.charAt(i) == '(')
            open++;
        else if (input.charAt(i) == ')')
            open--;
    }
    if (// Auto-balance if possible
    open == 1)
        // Auto-balance if possible
        input = input.concat(")");
    else // Unbalanced
    if (open != 0)
        throw new SyntaxException();
    Pattern pat = Pattern.compile("\\(([^\\(\\)]+?)\\)");
    while (input.contains("(")) {
        Matcher mch = pat.matcher(input);
        while (mch.find()) {
            input = input.replace(mch.group(), calculate(mch.group(1)));
        }
    }
    // Process transpositions.
    Matcher match = Pattern.compile("(\\[.+\\])\\^T").matcher(input);
    while (match.find()) {
        SimpleMatrix temp = parseMatrix(match.group(1)).transpose();
        input = input.replace(match.group(), printMatrix(temp));
    }
    // Process inverses
    match = Pattern.compile("(\\[.+\\])\uFEFF\\^-1").matcher(input);
    while (match.find()) {
        SimpleMatrix temp = parseMatrix(match.group(1)).pseudoInverse();
        input = input.replace(match.group(), printMatrix(temp));
    }
    // Handle functions.
    match = Pattern.compile("(\u221a|cbrt|log|ln|asin|acos|atan|sind|cosd|tand|asind|acosd|atand|sin|cos|tan|det)(\u2212?\\d+(?:\\.\\d+)?|\\[\\[.+\\]\\])").matcher(input);
    while (match.find()) {
        String res = applyFunc(match.group(1), match.group(2));
        input = input.replace(match.group(), res);
    }
    // Functions might generate NaN. Return error if so.
    if (input.contains("NaN"))
        return mLogic.mErrorString;
    // Substitute e
    // input = input.replaceAll("(?<!\\d)e", "2.7182818284590452353");
    input = input.replaceAll("(?<!\\d)(e)(?!\\d)", "2.7182818284590452353");
    // Sub pi
    input = input.replace("\u03c0", "3.1415926535897932384626");
    // Split into seperate arrays of operators and operands.
    // Operator 0 applies to operands 0 and 1, and so on
    String[] parts = input.split("\u00d7|\\+|(?<=\\d|\\])(?<=\\d|\\])-|\u00f7|\\^");
    char[] ops = opSplit(input);
    // This never changes, so no need to keep calling it
    int N = ops.length;
    // Since we've already made substitutions and parsed parentheses
    if (N == 0)
        return input;
    // Fill in the pieces.
    // Store everything as Object, and cast out later
    Object[] pieces = new Object[parts.length];
    for (int i = 0; i < parts.length; i++) {
        if (parts[i].startsWith("[["))
            pieces[i] = parseMatrix(parts[i]);
        else
            pieces[i] = Double.parseDouble(parts[i].replace('\u2212', '-'));
    }
    // Go from right to left to make ^ chains right-associative.
    for (int i = N - 1; i >= 0; i--) {
        int[] landr = null;
        if (ops[i] == '^') {
            landr = lookAfield(pieces, i);
            int l = landr[0];
            int r = landr[1];
            Object res = applyPow(pieces[l], pieces[r]);
            // This is arbitrary (I think)
            pieces[l] = res;
            // I could also have put the result in right
            pieces[r] = null;
        // and null in left
        }
    }
    // For the purposes of this app, it's no big deal.
    for (int i = 0; i < N; i++) {
        int[] landr = null;
        if (ops[i] == Logic.MUL || ops[i] == Logic.DIV) {
            landr = lookAfield(pieces, i);
            int l = landr[0];
            int r = landr[1];
            Object res = null;
            if (ops[i] == Logic.MUL)
                res = applyMult(pieces[l], pieces[r]);
            else
                res = applyDiv(pieces[l], pieces[r]);
            // else res = applyMod(pieces[l], pieces[r]);
            pieces[l] = res;
            pieces[r] = null;
        }
    }
    for (int i = 0; i < N; i++) {
        int[] landr = null;
        if (ops[i] == '+' || ops[i] == '-') {
            landr = lookAfield(pieces, i);
            int l = landr[0];
            int r = landr[1];
            Object res = null;
            if (ops[i] == '+')
                res = applyPlus(pieces[l], pieces[r]);
            else
                res = applySub(pieces[l], pieces[r]);
            pieces[l] = res;
            pieces[r] = null;
        }
    }
    for (Object piece : pieces) if (piece != null) {
        if (piece instanceof Double)
            return numToString((Double) piece);
        else if (piece instanceof SimpleMatrix)
            return printMatrix((SimpleMatrix) piece);
        else
            // Neither matrix nor double
            throw new SyntaxException();
    // should never happen
    }
    // Getting here should be impossible
    throw new RuntimeException();
}
#method_after
// The following have a lot of repeated boilerplate code.
// Condensing it down would require language features/properties
private String calculate(String input) throws SyntaxException {
    // I never realized negative numbers could be so difficult.
    // All remaining instances of U+2212 will be on negative numbers.
    // They will be counted as whole tokens.
    input = input.replace(Logic.MINUS, '-');
    // Instantiate matrices first
    Matcher m = Pattern.compile("\\[\\[.+?\\]\\]").matcher(input);
    while (m.find()) {
        SimpleMatrix temp = parseMatrix(m.group());
        input = input.replace(m.group(), printMatrix(temp));
    }
    // Get percentage
    input = input.replaceAll("(?<=\\d)%(?!\\d)", "\u00d70.01");
    // Might as well get factorial too
    m = Pattern.compile("(?<!\\.)([0-9]+)\\!").matcher(input);
    while (m.find()) {
        int temp = Integer.parseInt(m.group(1));
        input = input.replace(m.group(), fact(temp));
    }
    int open = 0;
    for (int i = 0; i < input.length(); i++) {
        if (input.charAt(i) == '(') {
            open++;
        } else if (input.charAt(i) == ')') {
            open--;
        }
    }
    if (open == 1) {
        // Auto-balance if possible
        input = input.concat(")");
    } else if (open != 0) {
        // Unbalanced
        throw new SyntaxException();
    }
    Pattern pat = Pattern.compile("\\(([^\\(\\)]+?)\\)");
    while (input.contains("(")) {
        Matcher mch = pat.matcher(input);
        while (mch.find()) {
            input = input.replace(mch.group(), calculate(mch.group(1)));
        }
    }
    // Process transpositions
    Matcher match = Pattern.compile("(\\[.+\\])\\^T").matcher(input);
    while (match.find()) {
        SimpleMatrix temp = parseMatrix(match.group(1)).transpose();
        input = input.replace(match.group(), printMatrix(temp));
    }
    // Process inverses
    match = Pattern.compile("(\\[.+\\])\uFEFF\\^-1").matcher(input);
    while (match.find()) {
        SimpleMatrix temp = parseMatrix(match.group(1)).pseudoInverse();
        input = input.replace(match.group(), printMatrix(temp));
    }
    // Handle functions
    match = Pattern.compile("(\u221a|cbrt|log|ln|asin|acos|atan|sind|cosd|tand|asind|acosd|atand|sin|cos|tan|det)(\u2212?\\d+(?:\\.\\d+)?|\\[\\[.+\\]\\])").matcher(input);
    while (match.find()) {
        String res = applyFunc(match.group(1), match.group(2));
        input = input.replace(match.group(), res);
    }
    // Functions might generate NaN. Return error if so.
    if (input.contains("NaN")) {
        return mLogic.mErrorString;
    }
    // Substitute e
    input = input.replaceAll("(?<!\\d)(e)(?!\\d)", "2.7182818284590452353");
    // Sub pi
    input = input.replace("\u03c0", "3.1415926535897932384626");
    // Split into seperate arrays of operators and operands.
    // Operator 0 applies to operands 0 and 1, and so on.
    String[] parts = input.split("\u00d7|\\+|(?<=\\d|\\])(?<=\\d|\\])-|\u00f7|\\^");
    char[] ops = opSplit(input);
    // This never changes, so no need to keep calling it
    int N = ops.length;
    // Since we've already made substitutions and parsed parentheses.
    if (N == 0) {
        return input;
    }
    // Fill in the pieces.
    // Store everything as Object, and cast out later.
    Object[] pieces = new Object[parts.length];
    for (int i = 0; i < parts.length; i++) {
        if (parts[i].startsWith("[[")) {
            pieces[i] = parseMatrix(parts[i]);
        } else {
            pieces[i] = Double.parseDouble(parts[i].replace('\u2212', '-'));
        }
    }
    // Go from right to left to make ^ chains right-associative.
    for (int i = N - 1; i >= 0; i--) {
        int[] landr = null;
        if (ops[i] == '^') {
            landr = lookAfield(pieces, i);
            int l = landr[0];
            int r = landr[1];
            Object res = applyPow(pieces[l], pieces[r]);
            // This is arbitrary (I think)
            pieces[l] = res;
            // I could also have put the result in right and null in left
            pieces[r] = null;
        }
    }
    // For the purposes of this app, it's no big deal.
    for (int i = 0; i < N; i++) {
        int[] landr = null;
        if (ops[i] == Logic.MUL || ops[i] == Logic.DIV) {
            landr = lookAfield(pieces, i);
            int l = landr[0];
            int r = landr[1];
            Object res = null;
            if (ops[i] == Logic.MUL) {
                res = applyMult(pieces[l], pieces[r]);
            } else {
                res = applyDiv(pieces[l], pieces[r]);
            }
            pieces[l] = res;
            pieces[r] = null;
        }
    }
    for (int i = 0; i < N; i++) {
        int[] landr = null;
        if (ops[i] == '+' || ops[i] == '-') {
            landr = lookAfield(pieces, i);
            int l = landr[0];
            int r = landr[1];
            Object res = null;
            if (ops[i] == '+') {
                res = applyPlus(pieces[l], pieces[r]);
            } else {
                res = applySub(pieces[l], pieces[r]);
            }
            pieces[l] = res;
            pieces[r] = null;
        }
    }
    for (Object piece : pieces) {
        if (piece != null) {
            if (piece instanceof Double) {
                return numToString((Double) piece);
            } else if (piece instanceof SimpleMatrix) {
                return printMatrix((SimpleMatrix) piece);
            } else {
                // Neither matrix or double, should never happen
                throw new SyntaxException();
            }
        }
    }
    // Getting here should be impossible
    throw new RuntimeException();
}
#end_block

#method_before
// end main
String evaluateMatrices(AdvancedDisplay display) throws SyntaxException {
    String text = display.getText();
    text = mLogic.convertToDecimal(text);
    String result = "";
    try {
        result = calculate(mLogic.localize(text));
        // Back to fancy minus
        result = result.replace('-', Logic.MINUS);
    } catch (Exception e) {
        result = mLogic.mErrorString;
    }
    result = mLogic.relocalize(result);
    return mLogic.getBaseModule().updateTextToNewMode(result, Mode.DECIMAL, mLogic.getBaseModule().getMode());
}
#method_after
String evaluateMatrices(AdvancedDisplay display) throws SyntaxException {
    String text = display.getText();
    text = mLogic.convertToDecimal(text);
    String result = "";
    try {
        result = calculate(mLogic.localize(text));
        // Back to fancy minus
        result = result.replace('-', Logic.MINUS);
    } catch (Exception e) {
        result = mLogic.mErrorString;
    }
    result = mLogic.relocalize(result);
    return mLogic.getBaseModule().updateTextToNewMode(result, Mode.DECIMAL, mLogic.getBaseModule().getMode());
}
#end_block

#method_before
private String applyFunc(String func, String arg) throws SyntaxException {
    arg = arg.replace(Logic.MINUS, '-');
    double DEG = Math.PI / 180.0;
    if (// sqrt
    func.equals("\u221a")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix matrix = parseMatrix(arg);
            int m = matrix.numRows();
            int n = matrix.numCols();
            if (m != n)
                throw new SyntaxException();
            SimpleEVD<SimpleMatrix> decomp = new SimpleEVD<SimpleMatrix>(matrix.getMatrix());
            double[] evals = new double[m];
            for (int i1 = 0; i1 < m; i1++) {
                evals[i1] = Math.sqrt(decomp.getEigenvalue(i1).getMagnitude());
            }
            SimpleMatrix D = SimpleMatrix.diag(evals);
            SimpleMatrix V = new SimpleMatrix(m, n);
            for (int k = 0; k < m; k++) {
                SimpleMatrix col = decomp.getEigenVector(k);
                for (int l = 0; l < n; l++) {
                    V.set(k, l, col.get(l, 0));
                }
            }
            SimpleMatrix temp = V.mult(D);
            temp = temp.mult(V.invert());
            return printMatrix(temp);
        } else
            return numToString(Math.sqrt(Double.parseDouble(arg)));
    } else if (func.equals("cbrt")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix matrix = parseMatrix(arg);
            int m = matrix.numRows();
            int n = matrix.numCols();
            if (m != n)
                throw new SyntaxException();
            SimpleEVD<SimpleMatrix> decomp = new SimpleEVD<SimpleMatrix>(matrix.getMatrix());
            double[] evals = new double[m];
            for (int i1 = 0; i1 < m; i1++) {
                evals[i1] = Math.cbrt(decomp.getEigenvalue(i1).getMagnitude());
            }
            SimpleMatrix D = SimpleMatrix.diag(evals);
            SimpleMatrix V = new SimpleMatrix(m, n);
            for (int k = 0; k < m; k++) {
                SimpleMatrix col = decomp.getEigenVector(k);
                for (int l = 0; l < n; l++) {
                    V.set(k, l, col.get(l, 0));
                }
            }
            SimpleMatrix temp = V.mult(D);
            temp = temp.mult(V.invert());
            return printMatrix(temp);
        } else
            return numToString(Math.cbrt(Double.parseDouble(arg)));
    } else if (func.equals("sin")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.sin(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.sin(Double.parseDouble(arg)));
    } else if (func.equals("cos")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.cos(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.cos(Double.parseDouble(arg)));
    } else if (func.equals("tan")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.tan(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.tan(Double.parseDouble(arg)));
    } else if (func.equals("sind")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.sin(m.get(i, j) * DEG));
            return printMatrix(m);
        } else
            return numToString(Math.sin(Double.parseDouble(arg) * DEG));
    } else if (func.equals("cosd")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.cos(m.get(i, j) * DEG));
            return printMatrix(m);
        } else
            return numToString(Math.cos(Double.parseDouble(arg) * DEG));
    } else if (func.equals("tand")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.tan(m.get(i, j) * DEG));
            return printMatrix(m);
        } else
            return numToString(Math.tan(Double.parseDouble(arg) * DEG));
    } else if (func.equals("asind")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.asin(m.get(i, j) / DEG));
            return printMatrix(m);
        } else
            return numToString(Math.asin(Double.parseDouble(arg)) / DEG);
    } else if (func.equals("acosd")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.acos(m.get(i, j)) / DEG);
            return printMatrix(m);
        } else
            return numToString(Math.acos(Double.parseDouble(arg)) / DEG);
    } else if (func.equals("atand")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.atan(m.get(i, j)) / DEG);
            return printMatrix(m);
        } else
            return numToString(Math.atan(Double.parseDouble(arg)) / DEG);
    } else if (func.equals("log")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.log10(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.log10(Double.parseDouble(arg)));
    } else if (func.equals("ln")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.log(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.log(Double.parseDouble(arg)));
    } else if (func.equals("asin")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.asin(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.asin(Double.parseDouble(arg)));
    } else if (func.equals("acos")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.acos(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.acos(Double.parseDouble(arg)));
    } else if (func.equals("atan")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) for (int j = 0; j < m.numCols(); j++) m.set(i, j, Math.atan(m.get(i, j)));
            return printMatrix(m);
        } else
            return numToString(Math.atan(Double.parseDouble(arg)));
    } else if (func.equals("det")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            if (m.numCols() != m.numRows())
                throw new SyntaxException();
            double d = m.determinant();
            return numToString(d);
        } else
            // Determinant of a scalar is equivalent to det. of
            return arg;
    // 1x1 matrix, which is the matrix' one element
    } else
        throw new SyntaxException();
}
#method_after
private String applyFunc(String func, String arg) throws SyntaxException {
    arg = arg.replace(Logic.MINUS, '-');
    double DEG = Math.PI / 180.0;
    if (func.equals("\u221a")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix matrix = parseMatrix(arg);
            int m = matrix.numRows();
            int n = matrix.numCols();
            if (m != n) {
                throw new SyntaxException();
            }
            SimpleEVD<SimpleMatrix> decomp = new SimpleEVD<SimpleMatrix>(matrix.getMatrix());
            double[] evals = new double[m];
            for (int i1 = 0; i1 < m; i1++) {
                evals[i1] = Math.sqrt(decomp.getEigenvalue(i1).getMagnitude());
            }
            SimpleMatrix D = SimpleMatrix.diag(evals);
            SimpleMatrix V = new SimpleMatrix(m, n);
            for (int k = 0; k < m; k++) {
                SimpleMatrix col = decomp.getEigenVector(k);
                for (int l = 0; l < n; l++) {
                    V.set(k, l, col.get(l, 0));
                }
            }
            SimpleMatrix temp = V.mult(D);
            temp = temp.mult(V.invert());
            return printMatrix(temp);
        } else {
            return numToString(Math.sqrt(Double.parseDouble(arg)));
        }
    } else if (func.equals("cbrt")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix matrix = parseMatrix(arg);
            int m = matrix.numRows();
            int n = matrix.numCols();
            if (m != n) {
                throw new SyntaxException();
            }
            SimpleEVD<SimpleMatrix> decomp = new SimpleEVD<SimpleMatrix>(matrix.getMatrix());
            double[] evals = new double[m];
            for (int i1 = 0; i1 < m; i1++) {
                evals[i1] = Math.cbrt(decomp.getEigenvalue(i1).getMagnitude());
            }
            SimpleMatrix D = SimpleMatrix.diag(evals);
            SimpleMatrix V = new SimpleMatrix(m, n);
            for (int k = 0; k < m; k++) {
                SimpleMatrix col = decomp.getEigenVector(k);
                for (int l = 0; l < n; l++) {
                    V.set(k, l, col.get(l, 0));
                }
            }
            SimpleMatrix temp = V.mult(D);
            temp = temp.mult(V.invert());
            return printMatrix(temp);
        } else {
            return numToString(Math.cbrt(Double.parseDouble(arg)));
        }
    } else if (func.equals("sin")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.sin(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.sin(Double.parseDouble(arg)));
        }
    } else if (func.equals("cos")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.cos(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.cos(Double.parseDouble(arg)));
        }
    } else if (func.equals("tan")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.tan(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.tan(Double.parseDouble(arg)));
        }
    } else if (func.equals("sind")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.sin(m.get(i, j) * DEG));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.sin(Double.parseDouble(arg) * DEG));
        }
    } else if (func.equals("cosd")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.cos(m.get(i, j) * DEG));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.cos(Double.parseDouble(arg) * DEG));
        }
    } else if (func.equals("tand")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.tan(m.get(i, j) * DEG));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.tan(Double.parseDouble(arg) * DEG));
        }
    } else if (func.equals("asind")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.asin(m.get(i, j) / DEG));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.asin(Double.parseDouble(arg)) / DEG);
        }
    } else if (func.equals("acosd")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.acos(m.get(i, j)) / DEG);
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.acos(Double.parseDouble(arg)) / DEG);
        }
    } else if (func.equals("atand")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.atan(m.get(i, j)) / DEG);
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.atan(Double.parseDouble(arg)) / DEG);
        }
    } else if (func.equals("log")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.log10(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.log10(Double.parseDouble(arg)));
        }
    } else if (func.equals("ln")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.log(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.log(Double.parseDouble(arg)));
        }
    } else if (func.equals("asin")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.asin(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.asin(Double.parseDouble(arg)));
        }
    } else if (func.equals("acos")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.acos(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.acos(Double.parseDouble(arg)));
        }
    } else if (func.equals("atan")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            for (int i = 0; i < m.numRows(); i++) {
                for (int j = 0; j < m.numCols(); j++) {
                    m.set(i, j, Math.atan(m.get(i, j)));
                }
            }
            return printMatrix(m);
        } else {
            return numToString(Math.atan(Double.parseDouble(arg)));
        }
    } else if (func.equals("det")) {
        if (arg.startsWith("[[")) {
            SimpleMatrix m = parseMatrix(arg);
            if (m.numCols() != m.numRows()) {
                throw new SyntaxException();
            }
            double d = m.determinant();
            return numToString(d);
        } else {
            // of 1x1 matrix, which is the matrix' one element.
            return arg;
        }
    } else {
        throw new SyntaxException();
    }
}
#end_block

#method_before
private Object applyPow(Object l, Object r) throws SyntaxException {
    if (l instanceof SimpleMatrix && r instanceof SimpleMatrix)
        throw new SyntaxException();
    else if (l instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) l;
        int m = a.numRows();
        int n = a.numCols();
        if (m != n)
            throw new SyntaxException();
        double b = (Double) r;
        if (b > Math.floor(b)) {
            SimpleSVD<SimpleMatrix> decomp = new SimpleSVD<SimpleMatrix>(a.getMatrix(), false);
            SimpleMatrix S = decomp.getW();
            for (int i1 = 0; i1 < m; i1++) {
                for (int j = 0; j < n; j++) {
                    double arg = S.get(i1, j);
                    S.set(i1, j, Math.pow(arg, b));
                }
            }
            SimpleMatrix matrix = decomp.getU().mult(S);
            matrix = matrix.mult(decomp.getV().transpose());
            return matrix;
        } else {
            long equiv = Math.round(b);
            for (long e = 1; e < equiv; e++) a = a.mult(a);
            return a;
        }
    } else if (r instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) r;
        int m = a.numRows();
        int n = a.numCols();
        if (m != n)
            throw new SyntaxException();
        double b = (Double) l;
        if (b > Math.floor(b)) {
            SimpleSVD<SimpleMatrix> decomp = new SimpleSVD<SimpleMatrix>(a.getMatrix(), false);
            SimpleMatrix S = decomp.getW();
            for (int i1 = 0; i1 < m; i1++) {
                for (int j = 0; j < n; j++) {
                    double arg = S.get(i1, j);
                    S.set(i1, j, Math.pow(arg, b));
                }
            }
            SimpleMatrix matrix = decomp.getU().mult(S);
            matrix = matrix.mult(decomp.getV().transpose());
            return matrix;
        } else {
            long equiv = Math.round(b);
            for (long e = 1; e < equiv; e++) a = a.mult(a);
            return a;
        }
    } else {
        double a = (Double) l;
        double b = (Double) r;
        return Math.pow(a, b);
    }
}
#method_after
private Object applyPow(Object l, Object r) throws SyntaxException {
    if (l instanceof SimpleMatrix && r instanceof SimpleMatrix) {
        throw new SyntaxException();
    } else if (l instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) l;
        int m = a.numRows();
        int n = a.numCols();
        if (m != n) {
            throw new SyntaxException();
        }
        double b = (Double) r;
        if (b > Math.floor(b)) {
            SimpleSVD<SimpleMatrix> decomp = new SimpleSVD<SimpleMatrix>(a.getMatrix(), false);
            SimpleMatrix S = decomp.getW();
            for (int i1 = 0; i1 < m; i1++) {
                for (int j = 0; j < n; j++) {
                    double arg = S.get(i1, j);
                    S.set(i1, j, Math.pow(arg, b));
                }
            }
            SimpleMatrix matrix = decomp.getU().mult(S);
            matrix = matrix.mult(decomp.getV().transpose());
            return matrix;
        } else {
            long equiv = Math.round(b);
            for (long e = 1; e < equiv; e++) {
                a = a.mult(a);
            }
            return a;
        }
    } else if (r instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) r;
        int m = a.numRows();
        int n = a.numCols();
        if (m != n) {
            throw new SyntaxException();
        }
        double b = (Double) l;
        if (b > Math.floor(b)) {
            SimpleSVD<SimpleMatrix> decomp = new SimpleSVD<SimpleMatrix>(a.getMatrix(), false);
            SimpleMatrix S = decomp.getW();
            for (int i1 = 0; i1 < m; i1++) {
                for (int j = 0; j < n; j++) {
                    double arg = S.get(i1, j);
                    S.set(i1, j, Math.pow(arg, b));
                }
            }
            SimpleMatrix matrix = decomp.getU().mult(S);
            matrix = matrix.mult(decomp.getV().transpose());
            return matrix;
        } else {
            long equiv = Math.round(b);
            for (long e = 1; e < equiv; e++) {
                a = a.mult(a);
            }
            return a;
        }
    } else {
        double a = (Double) l;
        double b = (Double) r;
        return Math.pow(a, b);
    }
}
#end_block

#method_before
// private Object applyMod(Object object, Object object2) throws
// SyntaxException {
// if(object instanceof Double && object2 instanceof Double) {
// double arg1 = (Double) object;
// double arg2 = (Double) object2;
// return arg1 % arg2;
// }
// else throw new SyntaxException();
// }
private Object applyPlus(Object l, Object r) throws SyntaxException {
    if (l instanceof SimpleMatrix && r instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) l;
        SimpleMatrix b = (SimpleMatrix) r;
        return a.plus(b);
    } else if (l instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) l;
        double b = (Double) r;
        return addScalar(a, b);
    } else if (r instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) r;
        double b = (Double) l;
        return addScalar(a, b);
    } else {
        double a = (Double) l;
        double b = (Double) r;
        return a + b;
    }
}
#method_after
private Object applyPlus(Object l, Object r) throws SyntaxException {
    if (l instanceof SimpleMatrix && r instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) l;
        SimpleMatrix b = (SimpleMatrix) r;
        return a.plus(b);
    } else if (l instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) l;
        double b = (Double) r;
        return addScalar(a, b);
    } else if (r instanceof SimpleMatrix) {
        SimpleMatrix a = (SimpleMatrix) r;
        double b = (Double) l;
        return addScalar(a, b);
    } else {
        double a = (Double) l;
        double b = (Double) r;
        return a + b;
    }
}
#end_block

#method_before
private SimpleMatrix parseMatrix(String text) throws SyntaxException {
    // Count rows & cols
    String interior = text.substring(2, text.length() - 2);
    String[] rows = interior.split("\\]\\[");
    SimpleMatrix temp = new SimpleMatrix(rows.length, rows[0].split(",").length);
    for (int i = 0; i < rows.length; i++) {
        String[] cols = rows[i].split(",");
        if (cols.length == 0)
            throw new SyntaxException();
        for (int j = 0; j < cols.length; j++) {
            if (cols[j].isEmpty())
                throw new SyntaxException();
            temp.set(i, j, Double.parseDouble(calculate(cols[j])));
        }
    }
    return temp;
}
#method_after
private SimpleMatrix parseMatrix(String text) throws SyntaxException {
    // Count rows & cols
    String interior = text.substring(2, text.length() - 2);
    String[] rows = interior.split("\\]\\[");
    SimpleMatrix temp = new SimpleMatrix(rows.length, rows[0].split(",").length);
    for (int i = 0; i < rows.length; i++) {
        String[] cols = rows[i].split(",");
        if (cols.length == 0) {
            throw new SyntaxException();
        }
        for (int j = 0; j < cols.length; j++) {
            if (cols[j].isEmpty()) {
                throw new SyntaxException();
            }
            temp.set(i, j, Double.parseDouble(calculate(cols[j])));
        }
    }
    return temp;
}
#end_block

#method_before
@Override
public void startUpdate(View container) {
}
#method_after
@Override
public void startUpdate(View container) {
// Do nothing here
}
#end_block

#method_before
@Override
public void finishUpdate(View container) {
}
#method_after
@Override
public void finishUpdate(View container) {
// Do nothing here
}
#end_block

#method_before
@Override
public void restoreState(Parcelable state, ClassLoader loader) {
}
#method_after
@Override
public void restoreState(Parcelable state, ClassLoader loader) {
// Do nothing here
}
#end_block

#method_before
protected void applyBannedResourcesByPage(Logic logic, View page, Mode baseMode) {
    // Enable
    for (Mode key : logic.getBaseModule().mBannedResources.keySet()) {
        if (baseMode.compareTo(key) != 0) {
            List<Integer> resources = logic.getBaseModule().mBannedResources.get(key);
            for (Integer resource : resources) {
                final int resId = resource.intValue();
                View v = page.findViewById(resId);
                if (v != null)
                    v.setEnabled(true);
            }
        }
    }
    // Disable
    List<Integer> resources = logic.getBaseModule().mBannedResources.get(baseMode);
    for (Integer resource : resources) {
        final int resId = resource.intValue();
        View v = page.findViewById(resId);
        if (v != null)
            v.setEnabled(false);
    }
}
#method_after
protected void applyBannedResourcesByPage(Logic logic, View page, Mode baseMode) {
    // Enable
    for (Mode key : logic.getBaseModule().mBannedResources.keySet()) {
        if (baseMode.compareTo(key) != 0) {
            List<Integer> resources = logic.getBaseModule().mBannedResources.get(key);
            for (Integer resource : resources) {
                final int resId = resource.intValue();
                View v = page.findViewById(resId);
                if (v != null) {
                    v.setEnabled(true);
                }
            }
        }
    }
    // Disable
    List<Integer> resources = logic.getBaseModule().mBannedResources.get(baseMode);
    for (Integer resource : resources) {
        final int resId = resource.intValue();
        View v = page.findViewById(resId);
        if (v != null) {
            v.setEnabled(false);
        }
    }
}
#end_block

#method_before
@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    if (mThemes.isEmpty())
        setListShown(false);
    // Load from server (and update ui when finished)
    mTask = new ThemesStoreTask(getActivity()) {

        @Override
        protected void onPostExecute(List<App> result) {
            super.onPostExecute(result);
            if (result == null)
                return;
            mThemes.clear();
            for (App a : result) {
                mThemes.add(a);
            }
            ((StoreAdapter) getListAdapter()).notifyDataSetChanged();
            setListShown(true);
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
            setListShown(true);
        }
    };
    mTask.executeAsync();
}
#method_after
@Override
public void onActivityCreated(Bundle savedInstanceState) {
    super.onActivityCreated(savedInstanceState);
    if (mThemes.isEmpty()) {
        setViewShown(false);
    }
    // Load from server (and update ui when finished)
    mTask = new ThemesStoreTask(getActivity()) {

        @Override
        protected void onPostExecute(List<App> result) {
            super.onPostExecute(result);
            if (result == null) {
                return;
            }
            mThemes.clear();
            for (App a : result) {
                mThemes.add(a);
            }
            if (!isDetached()) {
                ((StoreAdapter) getListAdapter()).notifyDataSetChanged();
                setViewShown(true);
            }
        }

        @Override
        protected void onCancelled() {
            super.onCancelled();
            try {
                setViewShown(true);
            } catch (IllegalStateException e) {
                e.printStackTrace();
            }
        }
    };
    mTask.executeAsync();
}
#end_block

#method_before
public void onListItemClick(GridView g, View v, int position, long id) {
    Intent intent = new Intent(Intent.ACTION_VIEW);
    intent.setData(Uri.parse("market://details?id=" + mThemes.get(position).getPackageName()));
    startActivity(intent);
}
#method_after
public void onListItemClick(int position) {
    if (App.doesPackageExists(getContext(), mThemes.get(position).getPackageName())) {
        String appName = mThemes.get(position).getPackageName();
        // Update theme
        CalculatorSettings.setTheme(getContext(), appName);
        Theme.setPackageName(appName);
        // Create a new intent to relaunch the store
        Intent intent = new Intent(getActivity(), getActivity().getClass());
        // Preserve the list offsets
        int itemPosition = mGridView.getFirstVisiblePosition();
        View child = mGridView.getChildAt(0);
        int itemOffset = child != null ? child.getTop() : 0;
        intent.putExtra(EXTRA_LIST_POSITION, itemPosition);
        intent.putExtra(EXTRA_LIST_VIEW_OFFSET, itemOffset);
        // Go
        startActivity(intent);
        getActivity().finish();
        // Set a smooth fade transition
        getActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
    } else {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse("market://details?id=" + mThemes.get(position).getPackageName()));
        startActivity(intent);
    }
}
#end_block

#method_before
@Override
public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
    onListItemClick(mGridView, mGridView.getChildAt(position), position, mGridView.getChildAt(position).getId());
}
#method_after
@Override
public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
    onListItemClick(position);
}
#end_block

#method_before
@Override
public void onClick(View view) {
    vibrate();
    View v;
    EditText active;
    int id = view.getId();
    switch(id) {
        case R.id.del:
            mHandler.onDelete();
            break;
        case R.id.clear:
            mHandler.onClear();
            break;
        case R.id.equal:
            if (mHandler.getText().contains(mX) || mHandler.getText().contains(mY)) {
                if (!mHandler.getText().contains("=")) {
                    mHandler.insert("=");
                    returnToBasic();
                }
                break;
            }
            mHandler.onEnter();
            break;
        case R.id.hex:
            mHandler.setText(mHandler.getBaseModule().setMode(Mode.HEXADECIMAL));
            applyAllBannedResources(mHandler.getBaseModule(), Mode.HEXADECIMAL);
            break;
        case R.id.bin:
            mHandler.setText(mHandler.getBaseModule().setMode(Mode.BINARY));
            applyAllBannedResources(mHandler.getBaseModule(), Mode.BINARY);
            break;
        case R.id.dec:
            mHandler.setText(mHandler.getBaseModule().setMode(Mode.DECIMAL));
            applyAllBannedResources(mHandler.getBaseModule(), Mode.DECIMAL);
            break;
        case R.id.matrix:
            mHandler.insert(MatrixView.getPattern(mContext));
            returnToBasic();
            break;
        case R.id.matrix_inverse:
            mHandler.insert(MatrixInverseView.PATTERN);
            returnToBasic();
            break;
        case R.id.matrix_transpose:
            mHandler.insert(MatrixTransposeView.PATTERN);
            returnToBasic();
            break;
        case R.id.plus_row:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText)
                ((MatrixEditText) v).getMatrixView().addRow();
            break;
        case R.id.minus_row:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText)
                ((MatrixEditText) v).getMatrixView().removeRow();
            break;
        case R.id.plus_col:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText)
                ((MatrixEditText) v).getMatrixView().addColumn();
            break;
        case R.id.minus_col:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText)
                ((MatrixEditText) v).getMatrixView().removeColumn();
            break;
        case R.id.next:
            if (mHandler.getText().equals(mErrorString))
                mHandler.setText("");
            active = mHandler.mDisplay.getActiveEditText();
            if (active.getSelectionStart() == active.getText().length()) {
                v = mHandler.mDisplay.getActiveEditText().focusSearch(View.FOCUS_FORWARD);
                if (v != null)
                    v.requestFocus();
                active = mHandler.mDisplay.getActiveEditText();
                active.setSelection(0);
            } else {
                active.setSelection(active.getSelectionStart() + 1);
            }
            break;
        case R.id.parentheses:
            if (mHandler.getText().equals(mErrorString))
                mHandler.setText("");
            if (mHandler.getText().contains("=")) {
                String[] equation = mHandler.getText().split("=");
                if (equation.length > 1) {
                    mHandler.setText(equation[0] + "=(" + equation[1] + ")");
                } else {
                    mHandler.setText(equation[0] + "=()");
                }
            } else {
                mHandler.setText("(" + mHandler.getText() + ")");
            }
            returnToBasic();
            break;
        case R.id.mod:
            if (mHandler.getText().equals(mErrorString))
                mHandler.setText("");
            if (mHandler.getText().contains("=")) {
                String[] equation = mHandler.getText().split("=");
                if (equation.length > 1) {
                    mHandler.setText(equation[0] + "=" + mModString + "(" + equation[1] + ",");
                } else {
                    mHandler.insert(mModString + "(");
                }
            } else {
                if (mHandler.getText().length() > 0) {
                    mHandler.setText(mModString + "(" + mHandler.getText() + ",");
                } else {
                    mHandler.insert(mModString + "(");
                }
            }
            returnToBasic();
            break;
        case R.id.easter:
            Toast.makeText(mContext, R.string.easter_egg, Toast.LENGTH_SHORT).show();
            break;
        case R.id.zoomIn:
            mGraphDisplay.zoomIn();
            break;
        case R.id.zoomOut:
            mGraphDisplay.zoomOut();
            break;
        case R.id.zoomReset:
            mGraphDisplay.zoomReset();
            break;
        default:
            if (view instanceof Button) {
                String text = ((Button) view).getText().toString();
                if (text.equals(mDX) || text.equals(mDY)) {
                // Do nothing
                } else if (text.length() >= 2) {
                    // Add paren after sin, cos, ln, etc. from buttons
                    text += "(";
                }
                mHandler.insert(text);
                returnToBasic();
            }
    }
}
#method_after
@Override
public void onClick(View view) {
    vibrate();
    View v;
    EditText active;
    int id = view.getId();
    switch(id) {
        case R.id.del:
            mHandler.onDelete();
            break;
        case R.id.clear:
            mHandler.onClear();
            break;
        case R.id.equal:
            if (mHandler.getText().contains(mX) || mHandler.getText().contains(mY)) {
                if (!mHandler.getText().contains("=")) {
                    mHandler.insert("=");
                    returnToBasic();
                }
                break;
            }
            mHandler.onEnter();
            break;
        case R.id.hex:
            mHandler.setText(mHandler.getBaseModule().setMode(Mode.HEXADECIMAL));
            applyAllBannedResources(mHandler.getBaseModule(), Mode.HEXADECIMAL);
            break;
        case R.id.bin:
            mHandler.setText(mHandler.getBaseModule().setMode(Mode.BINARY));
            applyAllBannedResources(mHandler.getBaseModule(), Mode.BINARY);
            break;
        case R.id.dec:
            mHandler.setText(mHandler.getBaseModule().setMode(Mode.DECIMAL));
            applyAllBannedResources(mHandler.getBaseModule(), Mode.DECIMAL);
            break;
        case R.id.matrix:
            mHandler.insert(MatrixView.getPattern(mContext));
            returnToBasic();
            break;
        case R.id.matrix_inverse:
            mHandler.insert(MatrixInverseView.PATTERN);
            returnToBasic();
            break;
        case R.id.matrix_transpose:
            mHandler.insert(MatrixTransposeView.PATTERN);
            returnToBasic();
            break;
        case R.id.plus_row:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText) {
                ((MatrixEditText) v).getMatrixView().addRow();
            }
            break;
        case R.id.minus_row:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText) {
                ((MatrixEditText) v).getMatrixView().removeRow();
            }
            break;
        case R.id.plus_col:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText) {
                ((MatrixEditText) v).getMatrixView().addColumn();
            }
            break;
        case R.id.minus_col:
            v = mHandler.mDisplay.getActiveEditText();
            if (v instanceof MatrixEditText) {
                ((MatrixEditText) v).getMatrixView().removeColumn();
            }
            break;
        case R.id.next:
            if (mHandler.getText().equals(mErrorString)) {
                mHandler.setText("");
            }
            active = mHandler.mDisplay.getActiveEditText();
            if (active.getSelectionStart() == active.getText().length()) {
                v = mHandler.mDisplay.getActiveEditText().focusSearch(View.FOCUS_FORWARD);
                if (v != null) {
                    v.requestFocus();
                }
                active = mHandler.mDisplay.getActiveEditText();
                active.setSelection(0);
            } else {
                active.setSelection(active.getSelectionStart() + 1);
            }
            break;
        case R.id.parentheses:
            if (mHandler.getText().equals(mErrorString)) {
                mHandler.setText("");
            }
            if (mHandler.getText().contains("=")) {
                String[] equation = mHandler.getText().split("=");
                if (equation.length > 1) {
                    mHandler.setText(equation[0] + "=(" + equation[1] + ")");
                } else {
                    mHandler.setText(equation[0] + "=()");
                }
            } else {
                mHandler.setText("(" + mHandler.getText() + ")");
            }
            returnToBasic();
            break;
        case R.id.mod:
            if (mHandler.getText().equals(mErrorString)) {
                mHandler.setText("");
            }
            if (mHandler.getText().contains("=")) {
                String[] equation = mHandler.getText().split("=");
                if (equation.length > 1) {
                    mHandler.setText(equation[0] + "=" + mModString + "(" + equation[1] + ",");
                } else {
                    mHandler.insert(mModString + "(");
                }
            } else {
                if (mHandler.getText().length() > 0) {
                    mHandler.setText(mModString + "(" + mHandler.getText() + ",");
                } else {
                    mHandler.insert(mModString + "(");
                }
            }
            returnToBasic();
            break;
        case R.id.easter:
            Toast.makeText(mContext, R.string.easter_egg, Toast.LENGTH_SHORT).show();
            break;
        case R.id.zoomIn:
            mGraphDisplay.zoomIn();
            break;
        case R.id.zoomOut:
            mGraphDisplay.zoomOut();
            break;
        case R.id.zoomReset:
            mGraphDisplay.zoomReset();
            break;
        default:
            if (view instanceof Button) {
                String text = ((Button) view).getText().toString();
                if (text.length() >= 2) {
                    // Add paren after sin, cos, ln, etc. from buttons
                    text += "(";
                }
                mHandler.insert(text);
                returnToBasic();
            }
    }
}
#end_block

#method_before
private void vibrate() {
    if (CalculatorSettings.vibrateOnPress(mContext)) {
        Vibrator vi = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
        if (!vi.hasVibrator())
            return;
        vi.vibrate(100);
    }
}
#method_after
private void vibrate() {
    if (CalculatorSettings.vibrateOnPress(mContext)) {
        Vibrator vi = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
        if (!vi.hasVibrator()) {
            return;
        }
        vi.vibrate(CalculatorSettings.getVibrationStrength());
    }
}
#end_block

#method_before
private void applyBannedResources(BaseModule base, Mode baseMode, boolean enabled) {
    List<Integer> resources = base.mBannedResources.get(baseMode);
    ViewPager pager = mPager != null ? mPager : mSmallPager;
    for (Integer resource : resources) {
        final int resId = resource.intValue();
        // There are multiple views with the same id,
        // but the id is unique per page
        // Find ids on every page
        Iterable<View> iterator = ((CalculatorPageAdapter) pager.getAdapter()).getViewIterator();
        for (View child : iterator) {
            if (child != null) {
                View v = child.findViewById(resId);
                if (v != null) {
                    v.setEnabled(enabled);
                }
            }
        }
        // A special check when mLargePager exists
        if (mLargePager != null) {
            iterator = ((CalculatorPageAdapter) mLargePager.getAdapter()).getViewIterator();
            for (View child : iterator) {
                if (child != null) {
                    View v = child.findViewById(resId);
                    if (v != null) {
                        v.setEnabled(enabled);
                    }
                }
            }
        }
    }
    // Update the buttons on the hex page(s)
    Iterable<View> iterator = ((CalculatorPageAdapter) pager.getAdapter()).getViewIterator();
    for (View child : iterator) {
        if (child != null) {
            updateBaseButtons(baseMode, child);
        }
    }
}
#method_after
private void applyBannedResources(BaseModule base, Mode baseMode, boolean enabled) {
    List<Integer> resources = base.mBannedResources.get(baseMode);
    ViewPager pager = mPager != null ? mPager : mSmallPager;
    for (Integer resource : resources) {
        final int resId = resource.intValue();
        // There are multiple views with the same id, but the id
        // is unique per page. Find ids on every page.
        Iterable<View> iterator = ((CalculatorPageAdapter) pager.getAdapter()).getViewIterator();
        for (View child : iterator) {
            if (child != null) {
                View v = child.findViewById(resId);
                if (v != null) {
                    v.setEnabled(enabled);
                }
            }
        }
        // A special check when mLargePager exists
        if (mLargePager != null) {
            iterator = ((CalculatorPageAdapter) mLargePager.getAdapter()).getViewIterator();
            for (View child : iterator) {
                if (child != null) {
                    View v = child.findViewById(resId);
                    if (v != null) {
                        v.setEnabled(enabled);
                    }
                }
            }
        }
    }
    // Update the buttons on the hex page(s)
    Iterable<View> iterator = ((CalculatorPageAdapter) pager.getAdapter()).getViewIterator();
    for (View child : iterator) {
        if (child != null) {
            updateBaseButtons(baseMode, child);
        }
    }
}
#end_block

#method_before
@Override
public boolean onLongClick(View view) {
    switch(view.getId()) {
        case R.id.del:
            mHandler.onClear();
            return true;
        case R.id.next:
            // Handle back
            EditText active = mHandler.mDisplay.getActiveEditText();
            if (active.getSelectionStart() == 0) {
                View v = mHandler.mDisplay.getActiveEditText().focusSearch(View.FOCUS_BACKWARD);
                if (v != null)
                    v.requestFocus();
                active = mHandler.mDisplay.getActiveEditText();
                active.setSelection(active.getText().length());
            } else {
                active.setSelection(active.getSelectionStart() - 1);
            }
            return true;
    }
    if (view.getTag() != null) {
        String text = (String) view.getTag();
        if (!text.isEmpty()) {
            Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();
            return true;
        }
    }
    if (view instanceof TextView && ((TextView) view).getHint() != null) {
        String text = ((TextView) view).getHint().toString();
        if (text.length() >= 2) {
            // Add paren after sin, cos, ln, etc. from buttons
            text += "(";
        }
        mHandler.insert(text);
        returnToBasic();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onLongClick(View view) {
    switch(view.getId()) {
        case R.id.del:
            mHandler.onClear();
            return true;
        case R.id.next:
            // Handle back
            EditText active = mHandler.mDisplay.getActiveEditText();
            if (active.getSelectionStart() == 0) {
                View v = mHandler.mDisplay.getActiveEditText().focusSearch(View.FOCUS_BACKWARD);
                if (v != null) {
                    v.requestFocus();
                }
                active = mHandler.mDisplay.getActiveEditText();
                active.setSelection(active.getText().length());
            } else {
                active.setSelection(active.getSelectionStart() - 1);
            }
            return true;
    }
    if (view.getTag() != null) {
        String text = (String) view.getTag();
        if (!text.isEmpty()) {
            Toast.makeText(mContext, text, Toast.LENGTH_SHORT).show();
            return true;
        }
    }
    if (view instanceof TextView && ((TextView) view).getHint() != null) {
        String text = ((TextView) view).getHint().toString();
        if (text.length() >= 2) {
            // Add paren after sin, cos, ln, etc. from buttons
            text += "(";
        }
        mHandler.insert(text);
        returnToBasic();
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean onKey(View view, int keyCode, KeyEvent keyEvent) {
    int action = keyEvent.getAction();
    // Work-around for spurious key event from IME, bug #1639445
    if (action == KeyEvent.ACTION_MULTIPLE && keyCode == KeyEvent.KEYCODE_UNKNOWN) {
        // eat it
        return true;
    }
    if (keyEvent.getUnicodeChar() == '=') {
        if (action == KeyEvent.ACTION_UP) {
            mHandler.onEnter();
        }
        return true;
    }
    if (keyCode != KeyEvent.KEYCODE_DPAD_CENTER && keyCode != KeyEvent.KEYCODE_DPAD_UP && keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_ENTER) {
        if (keyEvent.isPrintingKey() && action == KeyEvent.ACTION_UP) {
            // Tell the handler that text was updated.
            mHandler.onTextChanged();
        }
        return false;
    }
    if (action == KeyEvent.ACTION_UP) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_DPAD_CENTER:
                mHandler.onEnter();
                break;
            case KeyEvent.KEYCODE_DPAD_UP:
                mHandler.onUp();
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                mHandler.onDown();
                break;
        }
    }
    return true;
}
#method_after
@Override
public boolean onKey(View view, int keyCode, KeyEvent keyEvent) {
    int action = keyEvent.getAction();
    // Work-around for spurious key event from IME, bug #1639445
    if (action == KeyEvent.ACTION_MULTIPLE && keyCode == KeyEvent.KEYCODE_UNKNOWN) {
        // eat it
        return true;
    }
    if (keyEvent.getUnicodeChar() == '=') {
        if (action == KeyEvent.ACTION_UP) {
            mHandler.onEnter();
        }
        return true;
    }
    if (keyCode != KeyEvent.KEYCODE_DPAD_CENTER && keyCode != KeyEvent.KEYCODE_DPAD_UP && keyCode != KeyEvent.KEYCODE_DPAD_DOWN && keyCode != KeyEvent.KEYCODE_ENTER) {
        if (keyEvent.isPrintingKey() && action == KeyEvent.ACTION_UP) {
            // Tell the handler that text was updated.
            mHandler.onTextChanged();
        }
        return false;
    }
    /**
     * We should act on KeyEvent.ACTION_DOWN, but strangely sometimes the DOWN event isn't
     * received, only the UP. So the workaround is to act on UP... http://b/issue?id=1022478
     */
    if (action == KeyEvent.ACTION_UP) {
        switch(keyCode) {
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_DPAD_CENTER:
                mHandler.onEnter();
                break;
            case KeyEvent.KEYCODE_DPAD_UP:
                mHandler.onUp();
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                mHandler.onDown();
                break;
        }
    }
    return true;
}
#end_block

#method_before
public void setGraphDisplay(GraphicalView display) {
    mGraphDisplay = display;
}
#method_after
public void setGraphDisplay(GraphView display) {
    mGraphDisplay = display;
}
#end_block

#method_before
public void scrollToMiddle() {
    if (CalculatorSettings.useInfiniteScrolling(getContext())) {
        List<Page> pages = ((CalculatorPageAdapter) getAdapter()).getPages();
        int halfwayDownTheInfiniteList = (MAX_SIZE_CONSTANT / pages.size()) / 2 * pages.size() + Page.getOrder(pages, new Page(getContext(), NormalPanel.BASIC));
        setCurrentItem(halfwayDownTheInfiniteList);
    }
}
#method_after
public void scrollToMiddle() {
    if (CalculatorSettings.useInfiniteScrolling(getContext())) {
        List<Page> pages = ((CalculatorPageAdapter) getAdapter()).getPages();
        if (pages.size() != 0) {
            int halfwayDownTheInfiniteList = (MAX_SIZE_CONSTANT / pages.size()) / 2 * pages.size() + Page.getOrder(pages, new Page(getContext(), NormalPanel.BASIC));
            setCurrentItem(halfwayDownTheInfiniteList);
        }
    }
}
#end_block

#method_before
public void save() {
    try {
        OutputStream os = new BufferedOutputStream(mContext.openFileOutput(FILE_NAME, 0), 8192);
        DataOutputStream out = new DataOutputStream(os);
        out.writeInt(LAST_VERSION);
        out.writeInt(mDeleteMode);
        out.writeInt(mMode.quickSerializable);
        mHistory.write(out);
        out.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
public void save() {
    try {
        OutputStream os = new BufferedOutputStream(mContext.openFileOutput(FILE_NAME, 0), 8192);
        DataOutputStream out = new DataOutputStream(os);
        out.writeInt(LAST_VERSION);
        out.writeInt(mDeleteMode);
        out.writeInt(mMode == null ? Mode.DECIMAL.getQuickSerializable() : mMode.getQuickSerializable());
        mHistory.write(out);
        out.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#end_block

#method_before
@Override
protected List<App> doInBackground(String... params) {
    // Grab data from server
    String result = "[]";
    try {
        URL url = new URL(THEME_URL);
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
        InputStream in = urlConnection.getInputStream();
        InputStreamReader isr = new InputStreamReader(in);
        StringBuilder builder = new StringBuilder();
        int data = isr.read();
        while (data != -1) {
            char current = (char) data;
            data = isr.read();
            builder.append(current);
        }
        result = builder.toString();
    } catch (Exception e) {
        e.printStackTrace();
    }
    List<App> apps = null;
    try {
        // Parse result using gson
        App[] array = new Gson().fromJson(result, App[].class);
        apps = Arrays.asList(array);
        // Update database
        ThemesDataSource dataSource = new ThemesDataSource(mContext);
        dataSource.open();
        dataSource.deleteApps();
        dataSource.createApps(apps);
    } catch (Exception e) {
        // May have returned a 500 DB may be closed or context may be null
        e.printStackTrace();
        cancel(true);
    }
    return apps;
}
#method_after
@Override
protected List<App> doInBackground(String... params) {
    // Grab data from server
    String result = "[]";
    try {
        URL url = new URL(THEME_URL);
        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
        InputStream in = urlConnection.getInputStream();
        InputStreamReader isr = new InputStreamReader(in);
        StringBuilder builder = new StringBuilder();
        int data = isr.read();
        while (data != -1) {
            char current = (char) data;
            data = isr.read();
            builder.append(current);
        }
        result = builder.toString();
    } catch (Exception e) {
        e.printStackTrace();
    }
    List<App> apps = null;
    try {
        // Parse result using gson
        App[] array = new Gson().fromJson(result, App[].class);
        apps = Arrays.asList(array);
        // Update database
        if (apps.size() > 0) {
            ThemesDataSource dataSource = new ThemesDataSource(mContext);
            dataSource.open();
            dataSource.deleteApps();
            dataSource.createApps(apps);
            dataSource.close();
        }
    } catch (Exception e) {
        // May have returned a 500, DB may be closed, or context may be null
        e.printStackTrace();
        cancel(true);
    }
    return apps;
}
#end_block

#method_before
@Override
public void remove() {
}
#method_after
@Override
public void remove() {
// Do nothing here
}
#end_block

#method_before
private static String strip(String input) {
    if (input.endsWith(".0"))
        return input.substring(0, input.length() - 2);
    return input;
}
#method_after
private static String strip(String input) {
    if (input.endsWith(".0")) {
        return input.substring(0, input.length() - 2);
    }
    return input;
}
#end_block

#method_before
public static boolean load(final MutableString text, final AdvancedDisplay parent, final int pos) {
    if (!MatrixView.verify(parent.getContext(), text))
        return false;
    String matrix = MatrixView.parseMatrix(text.getText());
    text.setText(text.substring(matrix.length()));
    int rows = MatrixView.countOccurrences(matrix, '[') - 1;
    int columns = MatrixView.countOccurrences(matrix, getSeparator(parent.getContext()).charAt(0)) / rows + 1;
    MatrixView mv = new MatrixView(parent);
    for (int i = 0; i < rows; i++) {
        mv.addRow();
    }
    for (int i = 0; i < columns; i++) {
        mv.addColumn();
    }
    String[] data = matrix.split(Pattern.quote(getSeparator(parent.getContext())) + "|\\]\\[");
    for (int order = 0, row = 0; row < rows; row++) {
        TableRow tr = (TableRow) mv.getChildAt(row);
        for (int column = 0; column < columns; column++) {
            EditText input = (EditText) tr.getChildAt(column);
            input.setText(data[order].replaceAll("[\\[\\]]", ""));
            order++;
        }
    }
    AdvancedDisplay.LayoutParams params = new AdvancedDisplay.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    params.gravity = Gravity.CENTER_VERTICAL;
    mv.setLayoutParams(params);
    parent.addView(mv, pos);
    return true;
}
#method_after
public static boolean load(final MutableString text, final AdvancedDisplay parent, final int pos) {
    if (!MatrixView.verify(parent.getContext(), text)) {
        return false;
    }
    String matrix = MatrixView.parseMatrix(text.getText());
    text.setText(text.substring(matrix.length()));
    int rows = MatrixView.countOccurrences(matrix, '[') - 1;
    int columns = MatrixView.countOccurrences(matrix, getSeparator(parent.getContext()).charAt(0)) / rows + 1;
    MatrixView mv = new MatrixView(parent);
    for (int i = 0; i < rows; i++) {
        mv.addRow();
    }
    for (int i = 0; i < columns; i++) {
        mv.addColumn();
    }
    String[] data = matrix.split(Pattern.quote(getSeparator(parent.getContext())) + "|\\]\\[");
    for (int order = 0, row = 0; row < rows; row++) {
        TableRow tr = (TableRow) mv.getChildAt(row);
        for (int column = 0; column < columns; column++) {
            EditText input = (EditText) tr.getChildAt(column);
            input.setText(data[order].replaceAll("[\\[\\]]", ""));
            order++;
        }
    }
    AdvancedDisplay.LayoutParams params = new AdvancedDisplay.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    params.gravity = Gravity.CENTER_VERTICAL;
    mv.setLayoutParams(params);
    parent.addView(mv, pos);
    return true;
}
#end_block

#method_before
private static String parseMatrix(String text) {
    int bracket_open = 0;
    int bracket_closed = 0;
    for (int i = 0; i < text.length(); i++) {
        if (text.charAt(i) == '[') {
            bracket_open++;
        } else if (text.charAt(i) == ']') {
            bracket_closed++;
        }
        if (bracket_open == bracket_closed)
            return text.substring(0, i + 1);
    }
    return "";
}
#method_after
private static String parseMatrix(String text) {
    int bracket_open = 0;
    int bracket_closed = 0;
    for (int i = 0; i < text.length(); i++) {
        if (text.charAt(i) == '[') {
            bracket_open++;
        } else if (text.charAt(i) == ']') {
            bracket_closed++;
        }
        if (bracket_open == bracket_closed) {
            return text.substring(0, i + 1);
        }
    }
    return "";
}
#end_block

#method_before
private void setup() {
    mSeparator = getSeparator(getContext());
    setBackgroundResource(R.drawable.matrix_background);
    setFocusable(true);
    mLogic = mParent.mLogic;
}
#method_after
private void setup() {
    mSeparator = getSeparator(getContext());
    setBackground(Theme.get(R.drawable.matrix_background));
    setFocusable(true);
    mLogic = mParent.mLogic;
}
#end_block

#method_before
public void removeRow() {
    mRows--;
    removeViewAt(getChildCount() - 1);
    if (mRows == 0 || mColumns == 0)
        mParent.removeView(this);
}
#method_after
public void removeRow() {
    mRows--;
    removeViewAt(getChildCount() - 1);
    if (mRows == 0 || mColumns == 0) {
        mParent.removeView(this);
    }
}
#end_block

#method_before
public void removeColumn() {
    mColumns--;
    for (int i = 0; i < mRows; i++) {
        TableRow tr = (TableRow) getChildAt(i);
        tr.removeViewAt(tr.getChildCount() - 1);
    }
    if (mRows == 0 || mColumns == 0)
        mParent.removeView(this);
}
#method_after
public void removeColumn() {
    mColumns--;
    for (int i = 0; i < mRows; i++) {
        TableRow tr = (TableRow) getChildAt(i);
        tr.removeViewAt(tr.getChildCount() - 1);
    }
    if (mRows == 0 || mColumns == 0) {
        mParent.removeView(this);
    }
}
#end_block

#method_before
private double[][] getData() throws SyntaxException {
    double[][] data = new double[mRows][mColumns];
    for (int row = 0; row < mRows; row++) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = 0; column < mColumns; column++) {
            String input = ((EditText) tr.getChildAt(column)).getText().toString();
            if (input.isEmpty())
                throw new SyntaxException();
            try {
                data[row][column] = Double.valueOf(stringify(mLogic.evaluate(input)));
            } catch (Exception e) {
                e.printStackTrace();
                data[row][column] = Double.NaN;
            }
        }
    }
    return data;
}
#method_after
private double[][] getData() throws SyntaxException {
    double[][] data = new double[mRows][mColumns];
    for (int row = 0; row < mRows; row++) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = 0; column < mColumns; column++) {
            String input = ((EditText) tr.getChildAt(column)).getText().toString();
            if (input.isEmpty()) {
                throw new SyntaxException();
            }
            try {
                data[row][column] = Double.valueOf(stringify(mLogic.evaluate(input)));
            } catch (Exception e) {
                e.printStackTrace();
                data[row][column] = Double.NaN;
            }
        }
    }
    return data;
}
#end_block

#method_before
private String stringify(String input) {
    if (input.isEmpty())
        return "";
    else {
        input = mLogic.convertToDecimal(input);
        if (input.charAt(0) == '\u2212') {
            if (input.length() == 1)
                input = "";
            else
                input = "-" + input.substring(1);
        }
        if (input.startsWith(".")) {
            input = "0" + input;
        } else if (input.startsWith("-.")) {
            input = "-0" + input.substring(1);
        }
        return input;
    }
}
#method_after
private String stringify(String input) {
    if (input.isEmpty()) {
        return "";
    } else {
        input = mLogic.convertToDecimal(input);
        if (input.charAt(0) == '\u2212') {
            if (input.length() == 1) {
                input = "";
            } else {
                input = "-" + input.substring(1);
            }
        }
        if (input.startsWith(".")) {
            input = "0" + input;
        } else if (input.startsWith("-.")) {
            input = "-0" + input.substring(1);
        }
        return input;
    }
}
#end_block

#method_before
boolean isEmpty() {
    boolean empty = true;
    for (int row = 0; row < mRows; row++) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = 0; column < mColumns; column++) {
            String input = ((EditText) tr.getChildAt(column)).getText().toString();
            if (!input.isEmpty())
                empty = false;
        }
    }
    return empty;
}
#method_after
boolean isEmpty() {
    boolean empty = true;
    for (int row = 0; row < mRows; row++) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = 0; column < mColumns; column++) {
            String input = ((EditText) tr.getChildAt(column)).getText().toString();
            if (!input.isEmpty()) {
                empty = false;
            }
        }
    }
    return empty;
}
#end_block

#method_before
View nextView(View currentView) {
    boolean foundCurrentView = false;
    for (int row = 0; row < mRows; row++) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = 0; column < mColumns; column++) {
            if (foundCurrentView)
                return tr.getChildAt(column);
            else if (currentView == tr.getChildAt(column))
                foundCurrentView = true;
        }
    }
    return mParent.getChildAt(mParent.getChildIndex(this) + 1);
}
#method_after
View nextView(View currentView) {
    boolean foundCurrentView = false;
    for (int row = 0; row < mRows; row++) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = 0; column < mColumns; column++) {
            if (foundCurrentView) {
                return tr.getChildAt(column);
            } else if (currentView == tr.getChildAt(column)) {
                foundCurrentView = true;
            }
        }
    }
    return mParent.getChildAt(mParent.getChildIndex(this) + 1);
}
#end_block

#method_before
View previousView(View currentView) {
    boolean foundCurrentView = false;
    for (int row = mRows - 1; row >= 0; row--) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = mColumns - 1; column >= 0; column--) {
            if (foundCurrentView)
                return tr.getChildAt(column);
            else if (currentView == tr.getChildAt(column))
                foundCurrentView = true;
        }
    }
    return mParent.getChildAt(mParent.getChildIndex(this) - 1);
}
#method_after
View previousView(View currentView) {
    boolean foundCurrentView = false;
    for (int row = mRows - 1; row >= 0; row--) {
        TableRow tr = (TableRow) getChildAt(row);
        for (int column = mColumns - 1; column >= 0; column--) {
            if (foundCurrentView) {
                return tr.getChildAt(column);
            } else if (currentView == tr.getChildAt(column)) {
                foundCurrentView = true;
            }
        }
    }
    return mParent.getChildAt(mParent.getChildIndex(this) - 1);
}
#end_block

#method_before
public static List<Page> getAllPages(Context context) {
    ArrayList<Page> list = new ArrayList<Page>();
    for (Panel p : NormalPanel.values()) {
        Page page = new Page(context, p);
        list.add(page);
    }
    // TODO Readd when extensions are added
    // List<App> extensions = Extension.getApps(context);
    // for(App a : extensions) {
    // Page page = new Page(a);
    // list.add(page);
    // }
    Collections.sort(list, new PageSort(context));
    return list;
}
#method_after
public static List<Page> getAllPages(Context context) {
    ArrayList<Page> list = new ArrayList<Page>();
    for (Panel p : NormalPanel.values()) {
        Page page = new Page(context, p);
        list.add(page);
    }
    /* TODO: Readd when extensions are added
        List<App> extensions = Extension.getApps(context);
        for (App a : extensions) {
            Page page = new Page(a);
            list.add(page);
        } */
    Collections.sort(list, new PageSort(context));
    return list;
}
#end_block

#method_before
public static List<Page> getPages(Context context) {
    ArrayList<Page> list = new ArrayList<Page>();
    for (Panel p : NormalPanel.values()) {
        Page page = new Page(context, p);
        if (CalculatorSettings.isPageEnabled(context, page)) {
            list.add(page);
        }
    }
    // TODO Readd when extensions are added
    // List<App> extensions = Extension.getApps(context);
    // for(App a : extensions) {
    // Page page = new Page(a);
    // if(CalculatorSettings.isPageEnabled(context, page)) {
    // list.add(page);
    // }
    // }
    Collections.sort(list, new PageSort(context));
    while (list.size() != 0 && list.size() < 4 && CalculatorSettings.useInfiniteScrolling(context)) {
        // Double the records to avoid using the same view twice
        int size = list.size();
        for (int i = 0; i < size; i++) {
            list.add(new Page(list.get(i)));
        }
    }
    return list;
}
#method_after
public static List<Page> getPages(Context context) {
    ArrayList<Page> list = new ArrayList<Page>();
    for (Panel p : NormalPanel.values()) {
        Page page = new Page(context, p);
        if (CalculatorSettings.isPageEnabled(context, page)) {
            list.add(page);
        }
    }
    /* TODO: Readd when extensions are added
        List<App> extensions = Extension.getApps(context);
        for (App a : extensions) {
            Page page = new Page(a);
            if (CalculatorSettings.isPageEnabled(context, page)) {
                list.add(page);
            }
        } */
    Collections.sort(list, new PageSort(context));
    while (list.size() != 0 && list.size() < 4 && CalculatorSettings.useInfiniteScrolling(context)) {
        // Double the records to avoid using the same view twice
        int size = list.size();
        for (int i = 0; i < size; i++) {
            list.add(new Page(list.get(i)));
        }
    }
    return list;
}
#end_block

#method_before
public static List<Page> getLargePages(Context context) {
    ArrayList<Page> list = new ArrayList<Page>();
    for (Panel p : LargePanel.values()) {
        Page page = new Page(context, p);
        if (CalculatorSettings.isPageEnabled(context, page)) {
            list.add(page);
        }
    }
    // TODO Readd when extensions are added
    // List<App> extensions = Extension.getApps(context);
    // for(App a : extensions) {
    // Page page = new Page(a);
    // if(CalculatorSettings.isPageEnabled(context, page)) {
    // list.add(page);
    // }
    // }
    Collections.sort(list, new PageSort(context));
    while (list.size() != 0 && list.size() < 4 && CalculatorSettings.useInfiniteScrolling(context)) {
        // Double the records to avoid using the same view twice
        int size = list.size();
        for (int i = 0; i < size; i++) {
            list.add(new Page(list.get(i)));
        }
    }
    return list;
}
#method_after
public static List<Page> getLargePages(Context context) {
    ArrayList<Page> list = new ArrayList<Page>();
    for (Panel p : LargePanel.values()) {
        Page page = new Page(context, p);
        if (CalculatorSettings.isPageEnabled(context, page)) {
            list.add(page);
        }
    }
    /* TODO Readd when extensions are added
        List<App> extensions = Extension.getApps(context);
        for (App a : extensions) {
            Page page = new Page(a);
            if (CalculatorSettings.isPageEnabled(context, page)) {
                list.add(page);
            }
        } */
    Collections.sort(list, new PageSort(context));
    while (list.size() != 0 && list.size() < 4 && CalculatorSettings.useInfiniteScrolling(context)) {
        // Double the records to avoid using the same view twice
        int size = list.size();
        for (int i = 0; i < size; i++) {
            list.add(new Page(list.get(i)));
        }
    }
    return list;
}
#end_block

#method_before
public static Page getPage(List<Page> pages, String name) {
    for (Page p : pages) {
        if (p.getName().equals(name))
            return p;
    }
    return null;
}
#method_after
public static Page getPage(List<Page> pages, String name) {
    for (Page p : pages) {
        if (p.getName().equals(name)) {
            return p;
        }
    }
    return null;
}
#end_block

#method_before
public static int getOrder(List<Page> pages, Page page) {
    for (int i = 0; i < pages.size(); i++) {
        Page p = pages.get(i);
        if (p.equals(page))
            return i;
    }
    return -1;
}
#method_after
public static int getOrder(List<Page> pages, Page page) {
    for (int i = 0; i < pages.size(); i++) {
        Page p = pages.get(i);
        if (p.equals(page)) {
            return i;
        }
    }
    return -1;
}
#end_block

#method_before
public static List<Page> removeDuplicates(List<Page> pages) {
    ArrayList<Page> clean = new ArrayList<Page>();
    for (Page p : pages) {
        if (clean.contains(p))
            continue;
        clean.add(p);
    }
    return clean;
}
#method_after
public static List<Page> removeDuplicates(List<Page> pages) {
    ArrayList<Page> clean = new ArrayList<Page>();
    for (Page p : pages) {
        if (clean.contains(p)) {
            continue;
        }
        clean.add(p);
    }
    return clean;
}
#end_block

#method_before
public View getView(Context context, EventListener listener, Graph graph, Logic logic) {
    if (mPanel != null) {
        if (mView == null) {
            mView = mPanel.getView(context);
            mView.addOnAttachStateChangeListener(new OnAttachStateChangeListener() {

                @Override
                public void onViewDetachedFromWindow(View v) {
                    mView = null;
                }

                @Override
                public void onViewAttachedToWindow(View v) {
                }
            });
        }
        if (logic != null)
            mPanel.refresh(context, mView, listener, graph, logic);
    } else
        mView = null;
    return mView;
}
#method_after
public View getView(Context context, EventListener listener, Graph graph, Logic logic) {
    if (mPanel != null) {
        if (mView == null) {
            mView = mPanel.getView(context);
            mView.addOnAttachStateChangeListener(new OnAttachStateChangeListener() {

                @Override
                public void onViewDetachedFromWindow(View v) {
                    mView = null;
                }

                @Override
                public void onViewAttachedToWindow(View v) {
                // Do nothing here
                }
            });
        }
        if (logic != null) {
            mPanel.refresh(context, mView, listener, graph, logic);
        }
    } else {
        mView = null;
    }
    return mView;
}
#end_block

#method_before
public void setLogic(Logic logic) {
    NumberKeyListener calculatorKeyListener = new NumberKeyListener() {

        @Override
        public int getInputType() {
            return EditorInfo.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        }

        @Override
        protected char[] getAcceptedChars() {
            return ACCEPTED_CHARS;
        }

        @Override
        public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {
            /*
                 * the EditText should still accept letters (eg. 'sin') coming from the on-screen touch buttons, so don't filter anything.
                 */
            return null;
        }

        @Override
        public boolean onKeyDown(View view, Editable content, int keyCode, KeyEvent event) {
            if (keyCode == KeyEvent.KEYCODE_DEL) {
                int selectionHandle = getSelectionStart();
                if (selectionHandle == 0) {
                    // Remove the view in front
                    AdvancedDisplay editor = getAdvancedDisplay();
                    int index = editor.getChildIndex(getActiveEditText());
                    if (index > 0) {
                        editor.removeView(editor.getChildAt(index - 1));
                    }
                } else {
                    // Check and remove keywords
                    String textBeforeInsertionHandle = getActiveEditText().getText().toString().substring(0, selectionHandle);
                    String textAfterInsertionHandle = getActiveEditText().getText().toString().substring(selectionHandle, getActiveEditText().getText().toString().length());
                    for (String s : mKeywords) {
                        if (textBeforeInsertionHandle.endsWith(s)) {
                            int deletionLength = s.length();
                            String text = textBeforeInsertionHandle.substring(0, textBeforeInsertionHandle.length() - deletionLength) + textAfterInsertionHandle;
                            getActiveEditText().setText(text);
                            setSelection(selectionHandle - deletionLength);
                            return true;
                        }
                    }
                }
            }
            return super.onKeyDown(view, content, keyCode, event);
        }
    };
    Editable.Factory factory = new CalculatorEditable.Factory(logic);
    for (int i = 0; i < 2; ++i) {
        AdvancedDisplay text = ((ScrollableDisplay) getChildAt(i)).getView();
        text.setLogic(logic);
        text.setEditableFactory(factory);
        text.setKeyListener(calculatorKeyListener);
        text.setLayoutParams(new ScrollableDisplay.LayoutParams(ScrollableDisplay.LayoutParams.WRAP_CONTENT, ScrollableDisplay.LayoutParams.WRAP_CONTENT, Gravity.RIGHT | Gravity.CENTER_VERTICAL));
    }
}
#method_after
public void setLogic(Logic logic) {
    NumberKeyListener calculatorKeyListener = new NumberKeyListener() {

        @Override
        public int getInputType() {
            return EditorInfo.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        }

        @Override
        protected char[] getAcceptedChars() {
            return ACCEPTED_CHARS;
        }

        @Override
        public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {
            // the on-screen touch buttons, so don't filter anything
            return null;
        }

        @Override
        public boolean onKeyDown(View view, Editable content, int keyCode, KeyEvent event) {
            if (keyCode == KeyEvent.KEYCODE_DEL) {
                int selectionHandle = getSelectionStart();
                if (selectionHandle == 0) {
                    // Remove the view in front
                    AdvancedDisplay editor = getAdvancedDisplay();
                    int index = editor.getChildIndex(getActiveEditText());
                    if (index > 0) {
                        editor.removeView(editor.getChildAt(index - 1));
                    }
                } else {
                    // Check and remove keywords
                    String textBeforeInsertionHandle = getActiveEditText().getText().toString().substring(0, selectionHandle);
                    String textAfterInsertionHandle = getActiveEditText().getText().toString().substring(selectionHandle, getActiveEditText().getText().toString().length());
                    for (String s : mKeywords) {
                        if (textBeforeInsertionHandle.endsWith(s)) {
                            int deletionLength = s.length();
                            String text = textBeforeInsertionHandle.substring(0, textBeforeInsertionHandle.length() - deletionLength) + textAfterInsertionHandle;
                            getActiveEditText().setText(text);
                            setSelection(selectionHandle - deletionLength);
                            return true;
                        }
                    }
                }
            }
            return super.onKeyDown(view, content, keyCode, event);
        }
    };
    Editable.Factory factory = new CalculatorEditable.Factory(logic);
    for (int i = 0; i < 2; ++i) {
        AdvancedDisplay text = ((ScrollableDisplay) getChildAt(i)).getView();
        text.setLogic(logic);
        text.setEditableFactory(factory);
        text.setKeyListener(calculatorKeyListener);
        text.setLayoutParams(new ScrollableDisplay.LayoutParams(ScrollableDisplay.LayoutParams.WRAP_CONTENT, ScrollableDisplay.LayoutParams.WRAP_CONTENT, Gravity.RIGHT | Gravity.CENTER_VERTICAL));
    }
}
#end_block

#method_before
public void setText(CharSequence text, Scroll dir) {
    if (getText().length() == 0) {
        dir = Scroll.NONE;
    }
    if (dir == Scroll.UP) {
        setInAnimation(inAnimUp);
        setOutAnimation(outAnimUp);
    } else if (dir == Scroll.DOWN) {
        setInAnimation(inAnimDown);
        setOutAnimation(outAnimDown);
    } else {
        // Scroll.NONE
        setInAnimation(null);
        setOutAnimation(null);
    }
    AdvancedDisplay editor = ((ScrollableDisplay) getNextView()).getView();
    editor.setText(text.toString());
    showNext();
    getAdvancedDisplay().getLastView().requestFocus();
}
#method_after
public void setText(CharSequence text, Scroll dir) {
    if (getText().length() == 0) {
        dir = Scroll.NONE;
    }
    if (dir == Scroll.UP) {
        setInAnimation(inAnimUp);
        setOutAnimation(outAnimUp);
    } else if (dir == Scroll.DOWN) {
        setInAnimation(inAnimDown);
        setOutAnimation(outAnimDown);
    } else if (dir == Scroll.NONE) {
        setInAnimation(null);
        setOutAnimation(null);
    }
    AdvancedDisplay editor = ((ScrollableDisplay) getNextView()).getView();
    editor.setText(text.toString());
    showNext();
    getAdvancedDisplay().getLastView().requestFocus();
}
#end_block

#method_before
public int getSelectionStart() {
    if (getActiveEditText() == null)
        return 0;
    return getActiveEditText().getSelectionStart();
}
#method_after
public int getSelectionStart() {
    if (getActiveEditText() == null) {
        return 0;
    }
    return getActiveEditText().getSelectionStart();
}
#end_block

#method_before
public void onCreate(Bundle state) {
    super.onCreate(state);
    if (Intent.ACTION_CREATE_SHORTCUT.equals(getIntent().getAction())) {
        // create shortcut if requested
        Intent.ShortcutIconResource icon = Intent.ShortcutIconResource.fromContext(this, R.drawable.ic_launcher_floating);
        Intent intent = new Intent();
        Intent launchIntent = new Intent(this, FloatingCalculatorOpenShortCutActivity.class);
        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, launchIntent);
        intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, icon);
        setResult(RESULT_OK, intent);
        finish();
    }
}
#method_after
public void onCreate(Bundle state) {
    super.onCreate(state);
    if (Intent.ACTION_CREATE_SHORTCUT.equals(getIntent().getAction())) {
        // Create shortcut if requested
        Intent.ShortcutIconResource icon = Intent.ShortcutIconResource.fromContext(this, R.drawable.ic_launcher_floating);
        Intent intent = new Intent();
        Intent launchIntent = new Intent(this, FloatingCalculatorOpenShortCutActivity.class);
        intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, launchIntent);
        intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, getString(R.string.app_name));
        intent.putExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE, icon);
        setResult(RESULT_OK, intent);
        finish();
    }
}
#end_block

#method_before
@Override
protected void onPause() {
    super.onPause();
    if (FloatingCalculator.ACTIVE_CALCULATOR != null)
        FloatingCalculator.ACTIVE_CALCULATOR.closeCalculator();
    ACTIVE_ACTIVITY = null;
}
#method_after
@Override
protected void onPause() {
    super.onPause();
    if (FloatingCalculator.ACTIVE_CALCULATOR != null) {
        FloatingCalculator.ACTIVE_CALCULATOR.closeCalculator();
    }
    ACTIVE_ACTIVITY = null;
}
#end_block

#method_before
public View getViewAt(int position) {
    if (mViews[position] != null)
        return mViews[position];
    switch(position) {
        case 0:
            mViews[position] = View.inflate(mContext, R.layout.floating_calculator_history, null);
            ListView historyView = (ListView) mViews[position].findViewById(R.id.history);
            setUpHistory(historyView);
            break;
        case 1:
            mViews[position] = View.inflate(mContext, R.layout.floating_calculator_basic, null);
            break;
        case 2:
            mViews[position] = View.inflate(mContext, R.layout.floating_calculator_advanced, null);
            break;
    }
    applyListener(mViews[position]);
    return mViews[position];
}
#method_after
public View getViewAt(int position) {
    if (mViews[position] != null) {
        return mViews[position];
    }
    switch(position) {
        case 0:
            mViews[position] = View.inflate(mContext, R.layout.floating_calculator_history, null);
            ListView historyView = (ListView) mViews[position].findViewById(R.id.history);
            setUpHistory(historyView);
            break;
        case 1:
            mViews[position] = View.inflate(mContext, R.layout.floating_calculator_basic, null);
            break;
        case 2:
            mViews[position] = View.inflate(mContext, R.layout.floating_calculator_advanced, null);
            break;
    }
    applyListener(mViews[position]);
    return mViews[position];
}
#end_block

#method_before
@Override
public void startUpdate(View container) {
}
#method_after
@Override
public void startUpdate(View container) {
// Do nothing here
}
#end_block

#method_before
@Override
public void destroyItem(View container, int position, Object object) {
    if (mViews[position] != null)
        mViews[position] = null;
    ((ViewGroup) container).removeView((View) object);
}
#method_after
@Override
public void destroyItem(View container, int position, Object object) {
    if (mViews[position] != null) {
        mViews[position] = null;
    }
    ((ViewGroup) container).removeView((View) object);
}
#end_block

#method_before
@Override
public void finishUpdate(View container) {
}
#method_after
@Override
public void finishUpdate(View container) {
// Do nothing here
}
#end_block

#method_before
@Override
public void restoreState(Parcelable state, ClassLoader loader) {
}
#method_after
@Override
public void restoreState(Parcelable state, ClassLoader loader) {
// Do nothing here
}
#end_block

#method_before
private void setUpHistory(ListView historyView) {
    FloatingHistoryAdapter.OnHistoryItemClickListener listener = new FloatingHistoryAdapter.OnHistoryItemClickListener() {

        @Override
        public void onHistoryItemClick(HistoryEntry entry) {
            int deleteMode = mLogic.getDeleteMode();
            if (mDisplay.getText().isEmpty())
                deleteMode = Logic.DELETE_MODE_CLEAR;
            mDisplay.insert(entry.getEdited());
            mLogic.setDeleteMode(deleteMode);
        }
    };
    FloatingHistoryAdapter historyAdapter = new FloatingHistoryAdapter(mContext, mHistory);
    historyAdapter.setOnHistoryItemClickListener(listener);
    mHistory.setObserver(historyAdapter);
    historyView.setAdapter(historyAdapter);
    historyView.setStackFromBottom(true);
    historyView.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);
}
#method_after
private void setUpHistory(ListView historyView) {
    FloatingHistoryAdapter.OnHistoryItemClickListener listener = new FloatingHistoryAdapter.OnHistoryItemClickListener() {

        @Override
        public void onHistoryItemClick(HistoryEntry entry) {
            int deleteMode = mLogic.getDeleteMode();
            if (mDisplay.getText().isEmpty()) {
                deleteMode = Logic.DELETE_MODE_CLEAR;
            }
            mDisplay.insert(entry.getEdited());
            mLogic.setDeleteMode(deleteMode);
        }
    };
    FloatingHistoryAdapter historyAdapter = new FloatingHistoryAdapter(mContext, mHistory);
    historyAdapter.setOnHistoryItemClickListener(listener);
    mHistory.setObserver(historyAdapter);
    historyView.setAdapter(historyAdapter);
    historyView.setStackFromBottom(true);
    historyView.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);
}
#end_block

#method_before
void updateGraph(final Graph g) {
    if (g == null)
        return;
    final String eq = mLogic.getText();
    if (eq.isEmpty()) {
        XYSeries series = new XYSeries("");
        try {
            clearGraph(g);
            g.getDataset().addSeries(series);
        } catch (NullPointerException e) {
            e.printStackTrace();
        }
        if (mLogic.mGraphDisplay != null)
            mLogic.mGraphDisplay.repaint();
        return;
    }
    if (Logic.isOperator(eq.charAt(eq.length() - 1)) || mLogic.displayContainsMatrices() || eq.endsWith("("))
        return;
    new GraphTask(g, mLogic).execute(eq);
}
#method_after
void updateGraph(Graph graph) {
    final String equation = mLogic.getText();
    boolean panelDisabled = !CalculatorSettings.isPageEnabled(mLogic.getContext(), Page.NormalPanel.GRAPH);
    boolean endsWithOperator = equation.length() != 0 && (Logic.isOperator(equation.charAt(equation.length() - 1)) || equation.endsWith("("));
    boolean containsMatrices = mLogic.displayContainsMatrices();
    if (panelDisabled || endsWithOperator || containsMatrices) {
        return;
    }
    if (mGraphTask != null) {
        mGraphTask.cancel(true);
    }
    mGraphTask = new GraphTask(graph, mLogic);
    mGraphTask.execute(equation);
}
#end_block

#method_before
@Override
protected GraphicalView doInBackground(String... eq) {
    final String[] equation = eq[0].split("=");
    if (equation.length != 2)
        return null;
    // Translate into decimal
    equation[0] = mLogic.convertToDecimal(mLogic.localize(equation[0]));
    equation[1] = mLogic.convertToDecimal(mLogic.localize(equation[1]));
    final double minY = mGraph.getRenderer().getYAxisMin();
    final double maxY = mGraph.getRenderer().getYAxisMax();
    final double minX = mGraph.getRenderer().getXAxisMin();
    final double maxX = mGraph.getRenderer().getXAxisMax();
    try {
        final List<XYSeries> series = new ArrayList<XYSeries>();
        series.add(new XYSeries(""));
        double lastX = (maxX - minX) / 2 + minX;
        double lastY = (maxY - minY) / 2 + minY;
        if (equation[0].equals(mLogic.mY) && !equation[1].contains(mLogic.mY)) {
            for (double x = minX; x <= maxX; x += (0.00125 * (maxX - minX))) {
                if (graphChanged(mGraph, eq[0], minX, maxX, minY, maxY))
                    return null;
                try {
                    mLogic.mSymbols.define(mLogic.mX, x);
                    double y = mLogic.mSymbols.eval(equation[1]);
                    if (pointIsNaN(lastY, y, maxY, minY)) {
                        series.get(0).add(x, MathHelper.NULL_VALUE);
                    } else {
                        series.get(0).add(x, y);
                    }
                    lastY = y;
                } catch (SyntaxException e) {
                    e.printStackTrace();
                }
            }
        } else if (equation[0].equals(mLogic.mX) && !equation[1].contains(mLogic.mX)) {
            for (double y = minY; y <= maxY; y += (0.00125 * (maxY - minY))) {
                if (graphChanged(mGraph, eq[0], minX, maxX, minY, maxY))
                    return null;
                try {
                    mLogic.mSymbols.define(mLogic.mY, y);
                    double x = mLogic.mSymbols.eval(equation[1]);
                    if (pointIsNaN(lastX, x, maxX, minX)) {
                        series.get(0).add(MathHelper.NULL_VALUE, y);
                    } else {
                        series.get(0).add(x, y);
                    }
                    lastX = x;
                } catch (SyntaxException e) {
                    e.printStackTrace();
                }
            }
        } else if (equation[1].equals(mLogic.mY) && !equation[0].contains(mLogic.mY)) {
            for (double x = minX; x <= maxX; x += (0.00125 * (maxX - minX))) {
                if (graphChanged(mGraph, eq[0], minX, maxX, minY, maxY))
                    return null;
                try {
                    mLogic.mSymbols.define(mLogic.mX, x);
                    double y = mLogic.mSymbols.eval(equation[0]);
                    if (pointIsNaN(lastY, y, maxY, minY)) {
                        series.get(0).add(x, MathHelper.NULL_VALUE);
                    } else {
                        series.get(0).add(x, y);
                    }
                    lastY = y;
                } catch (SyntaxException e) {
                    e.printStackTrace();
                }
            }
        } else if (equation[1].equals(mLogic.mX) && !equation[0].contains(mLogic.mX)) {
            for (double y = minY; y <= maxY; y += (0.00125 * (maxY - minY))) {
                if (graphChanged(mGraph, eq[0], minX, maxX, minY, maxY))
                    return null;
                try {
                    mLogic.mSymbols.define(mLogic.mY, y);
                    double x = mLogic.mSymbols.eval(equation[0]);
                    if (pointIsNaN(lastX, x, maxX, minX)) {
                        series.get(0).add(MathHelper.NULL_VALUE, y);
                    } else {
                        series.get(0).add(x, y);
                    }
                    lastX = x;
                } catch (SyntaxException e) {
                    e.printStackTrace();
                }
            }
        } else {
            for (double x = minX; x <= maxX; x += (0.01 * (maxX - minX))) {
                List<Double> values = new ArrayList<Double>();
                for (double y = maxY; y >= minY; y -= (0.01 * (maxY - minY))) {
                    if (graphChanged(mGraph, eq[0], minX, maxX, minY, maxY))
                        return null;
                    try {
                        mLogic.mSymbols.define(mLogic.mX, x);
                        mLogic.mSymbols.define(mLogic.mY, y);
                        Double leftSide = mLogic.mSymbols.eval(equation[0]);
                        Double rightSide = mLogic.mSymbols.eval(equation[1]);
                        // out
                        if (leftSide < 0 && rightSide < 0) {
                            if (leftSide * 0.97 >= rightSide && leftSide * 1.03 <= rightSide) {
                                values.add(y);
                            }
                        } else {
                            if (leftSide * 0.97 <= rightSide && leftSide * 1.03 >= rightSide) {
                                values.add(y);
                            }
                        }
                    } catch (SyntaxException e) {
                        e.printStackTrace();
                    }
                }
                int color = mGraph.getRenderer().getSeriesRendererAt(0).getColor();
                while (values.size() > series.size()) {
                    series.add(new XYSeries(""));
                    Graph.addSeriesRenderer(color, mGraph.getRenderer());
                }
                for (int i = 0; i < values.size(); i++) {
                    // TODO find closest value to previous one
                    series.get(i).add(x, values.get(i));
                }
            // // TODO needs a lot of work. very broken
            // for(Double d : values) {
            // // find closest value to previous one per
            // // series
            // XYSeries closestSeries = series.get(0);
            // for(XYSeries s : series) {
            // if(tolerance(closestSeries.getY(closestSeries.getItemCount()
            // - 1), d) > tolerance(s.getY(s.getItemCount() -
            // 1), d)) {
            // closestSeries = s;
            // }
            // }
            // closestSeries.add(x, d);
            // }
            }
        }
        clearGraph(mGraph);
        for (XYSeries s : series) {
            mGraph.getDataset().addSeries(s);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return mLogic.mGraphDisplay;
}
#method_after
@Override
protected GraphView doInBackground(String... eq) {
    final String[] equation = eq[0].split("=");
    if (mLogic == null || mGraph == null) {
        cancel(true);
        return null;
    }
    if (equation.length != 2) {
        mGraph.setData(new LinkedList<GraphView.Point>());
        return mLogic.mGraphView;
    }
    // Translate into decimal
    equation[0] = mLogic.convertToDecimal(mLogic.localize(equation[0]));
    equation[1] = mLogic.convertToDecimal(mLogic.localize(equation[1]));
    final double minY = mLogic.mGraphView.getYAxisMin();
    final double maxY = mLogic.mGraphView.getYAxisMax();
    final double minX = mLogic.mGraphView.getXAxisMin();
    final double maxX = mLogic.mGraphView.getXAxisMax();
    final LinkedList<GraphView.Point> series = new LinkedList<GraphView.Point>();
    if (equation[0].equals(mLogic.mY) && !equation[1].contains(mLogic.mY)) {
        for (double x = minX; x <= maxX; x += 0.01 * mLogic.mGraphView.getZoomLevel()) {
            if (graphChanged(eq[0], minX, maxX, minY, maxY)) {
                return null;
            }
            try {
                mLogic.mSymbols.define(mLogic.mX, x);
                double y = mLogic.mSymbols.eval(equation[1]);
                series.add(new GraphView.Point(x, y));
            } catch (SyntaxException e) {
            // Do nothing here
            }
        }
        mGraph.setData(series, false);
        return mLogic.mGraphView;
    } else if (equation[0].equals(mLogic.mX) && !equation[1].contains(mLogic.mX)) {
        for (double y = minY; y <= maxY; y += 0.01 * mLogic.mGraphView.getZoomLevel()) {
            if (graphChanged(eq[0], minX, maxX, minY, maxY)) {
                return null;
            }
            try {
                mLogic.mSymbols.define(mLogic.mY, y);
                double x = mLogic.mSymbols.eval(equation[1]);
                series.add(new GraphView.Point(x, y));
            } catch (SyntaxException e) {
            // Do nothing here
            }
        }
        mGraph.setData(series, false);
        return mLogic.mGraphView;
    } else if (equation[1].equals(mLogic.mY) && !equation[0].contains(mLogic.mY)) {
        for (double x = minX; x <= maxX; x += 0.01 * mLogic.mGraphView.getZoomLevel()) {
            if (graphChanged(eq[0], minX, maxX, minY, maxY)) {
                return null;
            }
            try {
                mLogic.mSymbols.define(mLogic.mX, x);
                double y = mLogic.mSymbols.eval(equation[0]);
                series.add(new GraphView.Point(x, y));
            } catch (SyntaxException e) {
            // Do nothing here
            }
        }
        mGraph.setData(series, false);
        return mLogic.mGraphView;
    } else if (equation[1].equals(mLogic.mX) && !equation[0].contains(mLogic.mX)) {
        for (double y = minY; y <= maxY; y += 0.01 * mLogic.mGraphView.getZoomLevel()) {
            if (graphChanged(eq[0], minX, maxX, minY, maxY)) {
                return null;
            }
            try {
                mLogic.mSymbols.define(mLogic.mY, y);
                double x = mLogic.mSymbols.eval(equation[0]);
                series.add(new GraphView.Point(x, y));
            } catch (SyntaxException e) {
            // Do nothing here
            }
        }
        mGraph.setData(series, false);
        return mLogic.mGraphView;
    } else {
        for (double x = minX; x <= maxX; x += 0.2 * mLogic.mGraphView.getZoomLevel()) {
            List<Double> values = new ArrayList<Double>();
            for (double y = maxY; y >= minY; y -= 0.2 * mLogic.mGraphView.getZoomLevel()) {
                if (graphChanged(eq[0], minX, maxX, minY, maxY)) {
                    return null;
                }
                try {
                    mLogic.mSymbols.define(mLogic.mX, x);
                    mLogic.mSymbols.define(mLogic.mY, y);
                    Double leftSide = mLogic.mSymbols.eval(equation[0]);
                    Double rightSide = mLogic.mSymbols.eval(equation[1]);
                    // TODO: Increase scale of graph as zooming out
                    if (leftSide < 0 && rightSide < 0) {
                        if (leftSide * 0.98 >= rightSide && leftSide * 1.02 <= rightSide) {
                            values.add(y);
                        }
                    } else {
                        if (leftSide * 0.98 <= rightSide && leftSide * 1.02 >= rightSide) {
                            values.add(y);
                        }
                    }
                } catch (SyntaxException e) {
                    e.printStackTrace();
                }
            }
            for (int i = 0; i < values.size(); i++) {
                series.add(new GraphView.Point(x, values.get(i)));
            }
        }
    }
    mGraph.setData(series);
    return mLogic.mGraphView;
}
#end_block

#method_before
boolean graphChanged(Graph graph, String equation, double minX, double maxX, double minY, double maxY) {
    return !equation.equals(mLogic.getText()) || minY != graph.getRenderer().getYAxisMin() || maxY != graph.getRenderer().getYAxisMax() || minX != graph.getRenderer().getXAxisMin() || maxX != graph.getRenderer().getXAxisMax();
}
#method_after
boolean graphChanged(String equation, double minX, double maxX, double minY, double maxY) {
    return isCancelled() || !equation.equals(mLogic.getText()) || minY != mLogic.mGraphView.getYAxisMin() || maxY != mLogic.mGraphView.getYAxisMax() || minX != mLogic.mGraphView.getXAxisMin() || maxX != mLogic.mGraphView.getXAxisMax();
}
#end_block

#method_before
@Override
protected void onPostExecute(GraphicalView result) {
    super.onPostExecute(result);
    if (result != null) {
        result.repaint();
    }
}
#method_after
@Override
protected void onPostExecute(GraphView result) {
    super.onPostExecute(result);
    if (result != null) {
        result.invalidate();
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, 0);
    String value = getValue(context, appWidgetId);
    if (value.equals(context.getResources().getString(R.string.error)))
        value = "";
    mClearText = intent.getBooleanExtra(SHOW_CLEAR, false);
    if (intent.getAction().equals(DIGIT_0)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "0";
    } else if (intent.getAction().equals(DIGIT_1)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "1";
    } else if (intent.getAction().equals(DIGIT_2)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "2";
    } else if (intent.getAction().equals(DIGIT_3)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "3";
    } else if (intent.getAction().equals(DIGIT_4)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "4";
    } else if (intent.getAction().equals(DIGIT_5)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "5";
    } else if (intent.getAction().equals(DIGIT_6)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "6";
    } else if (intent.getAction().equals(DIGIT_7)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "7";
    } else if (intent.getAction().equals(DIGIT_8)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "8";
    } else if (intent.getAction().equals(DIGIT_9)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "9";
    } else if (intent.getAction().equals(DOT)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += context.getResources().getString(R.string.dot);
    } else if (intent.getAction().equals(DIV)) {
        value += context.getResources().getString(R.string.div);
    } else if (intent.getAction().equals(MUL)) {
        value += context.getResources().getString(R.string.mul);
    } else if (intent.getAction().equals(MINUS)) {
        value += context.getResources().getString(R.string.minus);
    } else if (intent.getAction().equals(PLUS)) {
        value += context.getResources().getString(R.string.plus);
    } else if (intent.getAction().equals(EQUALS)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        } else {
            mClearText = true;
        }
        final String input = value;
        if (input.isEmpty())
            return;
        final Logic logic = new Logic(context);
        logic.setLineLength(7);
        try {
            value = logic.evaluate(input);
        } catch (SyntaxException e) {
            value = context.getResources().getString(R.string.error);
        }
        // Try to save it to history
        if (!value.equals(context.getResources().getString(R.string.error))) {
            final Persist persist = new Persist(context);
            persist.load();
            if (persist.getMode() == null)
                persist.setMode(Mode.DECIMAL);
            final History history = persist.mHistory;
            history.enter(input, value);
            persist.save();
        }
    } else if (intent.getAction().equals(CLR)) {
        value = "";
    } else if (intent.getAction().equals(DEL)) {
        if (value.length() > 0)
            value = value.substring(0, value.length() - 1);
    }
    setValue(context, appWidgetId, value);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    int[] appWidgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(context, CalculatorWidget.class));
    for (int appWidgetID : appWidgetIds) {
        updateAppWidget(context, appWidgetManager, appWidgetID);
    }
    super.onReceive(context, intent);
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    int appWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, 0);
    String value = getValue(context, appWidgetId);
    if (value.equals(context.getResources().getString(R.string.error))) {
        value = "";
    }
    mClearText = intent.getBooleanExtra(SHOW_CLEAR, false);
    if (intent.getAction().equals(DIGIT_0)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "0";
    } else if (intent.getAction().equals(DIGIT_1)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "1";
    } else if (intent.getAction().equals(DIGIT_2)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "2";
    } else if (intent.getAction().equals(DIGIT_3)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "3";
    } else if (intent.getAction().equals(DIGIT_4)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "4";
    } else if (intent.getAction().equals(DIGIT_5)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "5";
    } else if (intent.getAction().equals(DIGIT_6)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "6";
    } else if (intent.getAction().equals(DIGIT_7)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "7";
    } else if (intent.getAction().equals(DIGIT_8)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "8";
    } else if (intent.getAction().equals(DIGIT_9)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += "9";
    } else if (intent.getAction().equals(DOT)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        }
        value += context.getResources().getString(R.string.dot);
    } else if (intent.getAction().equals(DIV)) {
        value += context.getResources().getString(R.string.div);
    } else if (intent.getAction().equals(MUL)) {
        value += context.getResources().getString(R.string.mul);
    } else if (intent.getAction().equals(MINUS)) {
        value += context.getResources().getString(R.string.minus);
    } else if (intent.getAction().equals(PLUS)) {
        value += context.getResources().getString(R.string.plus);
    } else if (intent.getAction().equals(EQUALS)) {
        if (mClearText) {
            value = "";
            mClearText = false;
        } else {
            mClearText = true;
        }
        final String input = value;
        if (input.isEmpty()) {
            return;
        }
        final Logic logic = new Logic(context);
        logic.setLineLength(7);
        try {
            value = logic.evaluate(input);
        } catch (SyntaxException e) {
            value = context.getResources().getString(R.string.error);
        }
        // Try to save it to history
        if (!value.equals(context.getResources().getString(R.string.error))) {
            final Persist persist = new Persist(context);
            persist.load();
            if (persist.getMode() == null) {
                persist.setMode(Mode.DECIMAL);
            }
            final History history = persist.mHistory;
            history.enter(input, value);
            persist.save();
        }
    } else if (intent.getAction().equals(CLR)) {
        value = "";
    } else if (intent.getAction().equals(DEL)) {
        if (value.length() > 0) {
            value = value.substring(0, value.length() - 1);
        }
    }
    setValue(context, appWidgetId, value);
    AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
    int[] appWidgetIds = appWidgetManager.getAppWidgetIds(new ComponentName(context, CalculatorWidget.class));
    for (int appWidgetID : appWidgetIds) {
        updateAppWidget(context, appWidgetManager, appWidgetID);
    }
    super.onReceive(context, intent);
}
#end_block

#method_before
private void updateAppWidget(Context context, AppWidgetManager appWidgetManager, int appWidgetId) {
    RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);
    String value = getValue(context, appWidgetId);
    if (CalculatorSettings.digitGrouping(context)) {
        final Logic logic = new Logic(context, null);
        BaseModule bm = logic.getBaseModule();
        value = bm.groupSentence(value, value.length());
        value = value.replace(String.valueOf(BaseModule.SELECTION_HANDLE), "");
    }
    int displayId = android.os.Build.VERSION.SDK_INT > android.os.Build.VERSION_CODES.JELLY_BEAN_MR1 ? R.id.display_long_clickable : R.id.display;
    remoteViews.setViewVisibility(displayId, View.VISIBLE);
    remoteViews.setTextViewText(displayId, value);
    remoteViews.setTextViewText(R.id.display, value);
    setOnClickListeners(context, appWidgetId, remoteViews);
    try {
        appWidgetManager.updateAppWidget(appWidgetId, remoteViews);
    } catch (Exception e) {
    }
}
#method_after
private void updateAppWidget(Context context, AppWidgetManager appWidgetManager, int appWidgetId) {
    RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.widget);
    String value = getValue(context, appWidgetId);
    if (CalculatorSettings.digitGrouping(context)) {
        final Logic logic = new Logic(context, null);
        BaseModule bm = logic.getBaseModule();
        value = bm.groupSentence(value, value.length());
        value = value.replace(String.valueOf(BaseModule.SELECTION_HANDLE), "");
    }
    int displayId = android.os.Build.VERSION.SDK_INT > android.os.Build.VERSION_CODES.JELLY_BEAN_MR1 ? R.id.display_long_clickable : R.id.display;
    remoteViews.setViewVisibility(R.id.background, CalculatorSettings.showWidgetBackground(context) ? View.VISIBLE : View.GONE);
    remoteViews.setViewVisibility(displayId, View.VISIBLE);
    remoteViews.setTextViewText(displayId, value);
    remoteViews.setTextViewText(R.id.display, value);
    setOnClickListeners(context, appWidgetId, remoteViews);
    try {
        appWidgetManager.updateAppWidget(appWidgetId, remoteViews);
    } catch (Exception e) {
    // Do nothing here
    }
}
#end_block

#method_before
private void setOnClickListeners(Context context, int appWidgetId, RemoteViews remoteViews) {
    final Intent intent = new Intent(context, CalculatorWidget.class);
    intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
    intent.putExtra(SHOW_CLEAR, mClearText);
    // The pending intent request code must be unique
    // Not just for these 17 buttons, but for each widget as well
    // Painful T_T Right?
    // So take the id and shift it over 5 bits (enough to store our 17
    // values)
    int shiftedAppWidgetId = appWidgetId << 5;
    // And add our button values (0-16)
    intent.setAction(DIGIT_0);
    remoteViews.setOnClickPendingIntent(R.id.digit0, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 0, intent, 0));
    intent.setAction(DIGIT_1);
    remoteViews.setOnClickPendingIntent(R.id.digit1, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 1, intent, 0));
    intent.setAction(DIGIT_2);
    remoteViews.setOnClickPendingIntent(R.id.digit2, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 2, intent, 0));
    intent.setAction(DIGIT_3);
    remoteViews.setOnClickPendingIntent(R.id.digit3, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 3, intent, 0));
    intent.setAction(DIGIT_4);
    remoteViews.setOnClickPendingIntent(R.id.digit4, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 4, intent, 0));
    intent.setAction(DIGIT_5);
    remoteViews.setOnClickPendingIntent(R.id.digit5, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 5, intent, 0));
    intent.setAction(DIGIT_6);
    remoteViews.setOnClickPendingIntent(R.id.digit6, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 6, intent, 0));
    intent.setAction(DIGIT_7);
    remoteViews.setOnClickPendingIntent(R.id.digit7, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 7, intent, 0));
    intent.setAction(DIGIT_8);
    remoteViews.setOnClickPendingIntent(R.id.digit8, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 8, intent, 0));
    intent.setAction(DIGIT_9);
    remoteViews.setOnClickPendingIntent(R.id.digit9, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 9, intent, 0));
    intent.setAction(DOT);
    remoteViews.setOnClickPendingIntent(R.id.dot, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 10, intent, 0));
    intent.setAction(DIV);
    remoteViews.setOnClickPendingIntent(R.id.div, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 11, intent, 0));
    intent.setAction(MUL);
    remoteViews.setOnClickPendingIntent(R.id.mul, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 12, intent, 0));
    intent.setAction(MINUS);
    remoteViews.setOnClickPendingIntent(R.id.minus, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 13, intent, 0));
    intent.setAction(PLUS);
    remoteViews.setOnClickPendingIntent(R.id.plus, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 14, intent, 0));
    intent.setAction(EQUALS);
    remoteViews.setOnClickPendingIntent(R.id.equal, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 15, intent, 0));
    intent.setAction(mClearText ? CLR : DEL);
    remoteViews.setOnClickPendingIntent(R.id.delete, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 17, intent, 0));
}
#method_after
private void setOnClickListeners(Context context, int appWidgetId, RemoteViews remoteViews) {
    final Intent intent = new Intent(context, CalculatorWidget.class);
    intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId);
    intent.putExtra(SHOW_CLEAR, mClearText);
    // The pending intent request code must be unique.
    // Not just for these 17 buttons, but for each widget as well.
    // So take the id and shift it over 5 bits (enough to store our 17 values).
    int shiftedAppWidgetId = appWidgetId << 5;
    // And add our button values (0-16)
    intent.setAction(DIGIT_0);
    remoteViews.setOnClickPendingIntent(R.id.digit0, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 0, intent, 0));
    intent.setAction(DIGIT_1);
    remoteViews.setOnClickPendingIntent(R.id.digit1, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 1, intent, 0));
    intent.setAction(DIGIT_2);
    remoteViews.setOnClickPendingIntent(R.id.digit2, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 2, intent, 0));
    intent.setAction(DIGIT_3);
    remoteViews.setOnClickPendingIntent(R.id.digit3, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 3, intent, 0));
    intent.setAction(DIGIT_4);
    remoteViews.setOnClickPendingIntent(R.id.digit4, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 4, intent, 0));
    intent.setAction(DIGIT_5);
    remoteViews.setOnClickPendingIntent(R.id.digit5, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 5, intent, 0));
    intent.setAction(DIGIT_6);
    remoteViews.setOnClickPendingIntent(R.id.digit6, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 6, intent, 0));
    intent.setAction(DIGIT_7);
    remoteViews.setOnClickPendingIntent(R.id.digit7, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 7, intent, 0));
    intent.setAction(DIGIT_8);
    remoteViews.setOnClickPendingIntent(R.id.digit8, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 8, intent, 0));
    intent.setAction(DIGIT_9);
    remoteViews.setOnClickPendingIntent(R.id.digit9, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 9, intent, 0));
    intent.setAction(DOT);
    remoteViews.setOnClickPendingIntent(R.id.dot, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 10, intent, 0));
    intent.setAction(DIV);
    remoteViews.setOnClickPendingIntent(R.id.div, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 11, intent, 0));
    intent.setAction(MUL);
    remoteViews.setOnClickPendingIntent(R.id.mul, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 12, intent, 0));
    intent.setAction(MINUS);
    remoteViews.setOnClickPendingIntent(R.id.minus, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 13, intent, 0));
    intent.setAction(PLUS);
    remoteViews.setOnClickPendingIntent(R.id.plus, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 14, intent, 0));
    intent.setAction(EQUALS);
    remoteViews.setOnClickPendingIntent(R.id.equal, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 15, intent, 0));
    intent.setAction(mClearText ? CLR : DEL);
    remoteViews.setOnClickPendingIntent(R.id.delete, PendingIntent.getBroadcast(context, shiftedAppWidgetId + 17, intent, 0));
}
#end_block

#method_before
@Override
public void setDefaultFont() {
}
#method_after
@Override
public void setDefaultFont() {
// Do nothing here
}
#end_block

#method_before
@Override
public void setFont(String font) {
}
#method_after
@Override
public void setFont(String font) {
// Do nothing here
}
#end_block

#method_before
@Override
protected void updateView(final HistoryEntry entry, HistoryLine view) {
    TextView expr = (TextView) view.findViewById(R.id.historyExpr);
    TextView result = (TextView) view.findViewById(R.id.historyResult);
    expr.setText(formatText(entry.getBase()));
    result.setText(entry.getEdited());
    view.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mListener != null)
                mListener.onHistoryItemClick(entry);
        // copyContent(entry.getEdited());
        }
    });
}
#method_after
@Override
protected void updateView(final HistoryEntry entry, HistoryLine view) {
    TextView expr = (TextView) view.findViewById(R.id.historyExpr);
    TextView result = (TextView) view.findViewById(R.id.historyResult);
    expr.setText(formatText(entry.getBase()));
    result.setText(entry.getEdited());
    view.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mListener != null) {
                mListener.onHistoryItemClick(entry);
            }
        }
    });
}
#end_block

#method_before
@Override
public void onAnimationCancel(Animator animation) {
}
#method_after
@Override
public void onAnimationCancel(Animator animation) {
// Do nothing here
}
#end_block

#method_before
@Override
public void onAnimationRepeat(Animator animation) {
}
#method_after
@Override
public void onAnimationRepeat(Animator animation) {
// Do nothing here
}
#end_block

#method_before
@Override
public void onAnimationStart(Animator animation) {
}
#method_after
@Override
public void onAnimationStart(Animator animation) {
// Do nothing here
}
#end_block

#method_before
@Override
public void remove() {
}
#method_after
@Override
public void remove() {
// Do nothing here
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mCardScrollView = new CardScrollView(this);
    ExampleCardScrollAdapter adapter = new ExampleCardScrollAdapter();
    mCardScrollView.setAdapter(adapter);
    mCardScrollView.setOnItemClickListener(new OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> av, View v, int position, long id) {
            mCards.clear();
            mCardScrollView.getAdapter().notifyDataSetChanged();
            displaySpeechRecognizer();
        }
    });
    mCardScrollView.activate();
    setContentView(mCardScrollView);
    if (savedInstanceState == null)
        displaySpeechRecognizer();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mCardScrollView = new CardScrollView(this);
    ExampleCardScrollAdapter adapter = new ExampleCardScrollAdapter();
    mCardScrollView.setAdapter(adapter);
    mCardScrollView.setOnItemClickListener(new OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> av, View v, int position, long id) {
            mCards.clear();
            mCardScrollView.getAdapter().notifyDataSetChanged();
            displaySpeechRecognizer();
        }
    });
    mCardScrollView.activate();
    setContentView(mCardScrollView);
    if (savedInstanceState == null) {
        displaySpeechRecognizer();
    }
}
#end_block

#method_before
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    return mCards.get(position).toView();
}
#method_after
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    return mCards.get(position).getView();
}
#end_block

#method_before
public static synchronized StoreHelper getHelper(Context context) {
    if (instance == null)
        instance = new StoreHelper(context);
    return instance;
}
#method_after
public static synchronized StoreHelper getHelper(Context context) {
    if (instance == null) {
        instance = new StoreHelper(context);
    }
    return instance;
}
#end_block

#method_before
@SuppressLint("NewApi")
@SuppressWarnings("deprecation")
@Override
public void onCreate(Bundle state) {
    super.onCreate(state);
    // Disable IME for this application
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM, WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
    Theme.buildResourceMap(com.android.calculator2.R.class);
    Theme.setPackageName(CalculatorSettings.getTheme(getContext()));
    int customTheme = Theme.getTheme(getContext());
    if (customTheme != 0) {
        super.setTheme(customTheme);
    }
    setContentView(R.layout.main);
    mPager = (CalculatorViewPager) findViewById(R.id.panelswitch);
    mSmallPager = (CalculatorViewPager) findViewById(R.id.smallPanelswitch);
    mLargePager = (CalculatorViewPager) findViewById(R.id.largePanelswitch);
    if (mClearButton == null) {
        mClearButton = findViewById(R.id.clear);
        mClearButton.setOnClickListener(mListener);
        mClearButton.setOnLongClickListener(mListener);
    }
    if (mBackspaceButton == null) {
        mBackspaceButton = findViewById(R.id.del);
        mBackspaceButton.setOnClickListener(mListener);
        mBackspaceButton.setOnLongClickListener(mListener);
    }
    mDetails = (TextView) findViewById(R.id.details);
    mDisplay = (CalculatorDisplay) findViewById(R.id.display);
    mLogic = new Logic(this, mDisplay);
    mLogic.setListener(this);
    mLogic.getBaseModule().setOnBaseChangeListener(new OnBaseChangeListener() {

        @Override
        public void onBaseChange(Mode newBase) {
            updateDetails();
        }
    });
    mLogic.setLineLength(mDisplay.getMaxDigits());
    mHistorySlider = (Slider) findViewById(R.id.pulldown);
    mHistorySlider.setBarHeight(getResources().getDimensionPixelSize(R.dimen.history_bar_height));
    mHistorySlider.setSlideDirection(Direction.DOWN);
    if (CalculatorSettings.clickToOpenHistory(this)) {
        mHistorySlider.enableClick(true);
        mHistorySlider.enableTouch(false);
    }
    mHistorySlider.setBarBackground(Theme.getDrawable(getContext(), R.drawable.btn_slider));
    mHistorySlider.enableVibration(CalculatorSettings.vibrateOnPress(getContext()));
    Drawable sliderBackground = Theme.getDrawable(getContext(), "slider_background");
    if (sliderBackground == null)
        sliderBackground = Theme.getDrawable(getContext(), R.drawable.background);
    if (android.os.Build.VERSION.SDK_INT < 16) {
        mHistorySlider.setBackgroundDrawable(sliderBackground);
    } else {
        mHistorySlider.setBackground(sliderBackground);
    }
    mHistoryView = (ListView) mHistorySlider.findViewById(R.id.history);
    mGraph = new Graph(mLogic);
    if (mPager != null) {
        CalculatorPageAdapter adapter = new PageAdapter(getContext(), mListener, mGraph, mLogic);
        mPages = adapter.getPages();
        mPager.setAdapter(adapter);
        mPager.scrollToMiddle();
        if (state != null) {
            mPager.setCurrentItem(state.getInt(STATE_CURRENT_VIEW, mPager.getCurrentItem()));
        } else {
            Page basic = new Page(getContext(), NormalPanel.BASIC);
            if (CalculatorSettings.isPageEnabled(getContext(), basic)) {
                scrollToPage(basic);
            }
        }
        mPager.setOnPageChangeListener(this);
        runCling(false);
        mListener.setHandler(this, mLogic, mPager);
    } else if (mSmallPager != null && mLargePager != null) {
        // Expanded UI
        CalculatorPageAdapter smallAdapter = new SmallPageAdapter(getContext(), mLogic);
        CalculatorPageAdapter largeAdapter = new LargePageAdapter(getContext(), mListener, mGraph, mLogic);
        mPages = new ArrayList<Page>(smallAdapter.getPages());
        mPages.addAll(largeAdapter.getPages());
        mSmallPager.setAdapter(smallAdapter);
        mLargePager.setAdapter(largeAdapter);
        mSmallPager.scrollToMiddle();
        mLargePager.scrollToMiddle();
        if (state != null) {
            mSmallPager.setCurrentItem(state.getInt(STATE_CURRENT_VIEW, mSmallPager.getCurrentItem()));
            mLargePager.setCurrentItem(state.getInt(STATE_CURRENT_VIEW, mLargePager.getCurrentItem()));
        } else {
            Page basic = new Page(getContext(), LargePanel.BASIC);
            Page advanced = new Page(getContext(), SmallPanel.ADVANCED);
            if (CalculatorSettings.isPageEnabled(getContext(), basic)) {
                scrollToPage(basic);
            }
            if (CalculatorSettings.isPageEnabled(getContext(), advanced)) {
                scrollToPage(advanced);
            }
        }
        mPages = Page.removeDuplicates(mPages);
        mSmallPager.setOnPageChangeListener(this);
        mLargePager.setOnPageChangeListener(this);
        runCling(false);
        mListener.setHandler(this, mLogic, mSmallPager, mLargePager);
    }
    mDisplay.setOnKeyListener(mListener);
    createFakeMenu();
    updateDeleteMode();
    mHistorySlider.bringToFront();
    updateDetails();
}
#method_after
@SuppressLint("NewApi")
@SuppressWarnings("deprecation")
@Override
public void onCreate(Bundle state) {
    super.onCreate(state);
    // Disable IME for this application
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM, WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);
    Theme.buildResourceMap(com.android.calculator2.R.class);
    Theme.setPackageName(CalculatorSettings.getTheme(getContext()));
    int customTheme = Theme.getTheme(getContext());
    if (customTheme != 0) {
        super.setTheme(customTheme);
    }
    setContentView(R.layout.main);
    mPager = (CalculatorViewPager) findViewById(R.id.panelswitch);
    mSmallPager = (CalculatorViewPager) findViewById(R.id.smallPanelswitch);
    mLargePager = (CalculatorViewPager) findViewById(R.id.largePanelswitch);
    if (mClearButton == null) {
        mClearButton = findViewById(R.id.clear);
        mClearButton.setOnClickListener(mListener);
        mClearButton.setOnLongClickListener(mListener);
    }
    if (mBackspaceButton == null) {
        mBackspaceButton = findViewById(R.id.del);
        mBackspaceButton.setOnClickListener(mListener);
        mBackspaceButton.setOnLongClickListener(mListener);
    }
    mDetails = (TextView) findViewById(R.id.details);
    mDisplay = (CalculatorDisplay) findViewById(R.id.display);
    mLogic = new Logic(this, mDisplay);
    mLogic.setListener(this);
    mLogic.getBaseModule().setOnBaseChangeListener(new OnBaseChangeListener() {

        @Override
        public void onBaseChange(Mode newBase) {
            updateDetails();
        }
    });
    mLogic.setLineLength(mDisplay.getMaxDigits());
    mHistorySlider = (Slider) findViewById(R.id.pulldown);
    mHistorySlider.setBarHeight(getResources().getDimensionPixelSize(R.dimen.history_bar_height));
    mHistorySlider.setSlideDirection(Direction.DOWN);
    if (CalculatorSettings.clickToOpenHistory(this)) {
        mHistorySlider.enableClick(true);
        mHistorySlider.enableTouch(false);
    }
    mHistorySlider.setBarBackground(Theme.getDrawable(getContext(), R.drawable.btn_slider));
    mHistorySlider.enableVibration(CalculatorSettings.vibrateOnPress(getContext()), CalculatorSettings.getVibrationStrength());
    Drawable sliderBackground = Theme.getDrawable(getContext(), "slider_background");
    if (sliderBackground == null) {
        sliderBackground = Theme.getDrawable(getContext(), R.drawable.background);
    }
    if (android.os.Build.VERSION.SDK_INT < 16) {
        mHistorySlider.setBackgroundDrawable(sliderBackground);
    } else {
        mHistorySlider.setBackground(sliderBackground);
    }
    mHistoryView = (ListView) mHistorySlider.findViewById(R.id.history);
    mGraph = new Graph(mLogic);
    if (mPager != null) {
        CalculatorPageAdapter adapter = new PageAdapter(getContext(), mListener, mGraph, mLogic);
        mPages = adapter.getPages();
        mPager.setAdapter(adapter);
        mPager.scrollToMiddle();
        if (state != null) {
            mPager.setCurrentItem(state.getInt(STATE_CURRENT_VIEW, mPager.getCurrentItem()));
        } else {
            Page basic = new Page(getContext(), NormalPanel.BASIC);
            if (CalculatorSettings.isPageEnabled(getContext(), basic)) {
                scrollToPage(basic);
            }
        }
        mPages = Page.removeDuplicates(mPages);
        mPager.setOnPageChangeListener(this);
        runCling(false);
        mListener.setHandler(this, mLogic, mPager);
    } else if (mSmallPager != null && mLargePager != null) {
        // Expanded UI
        CalculatorPageAdapter smallAdapter = new SmallPageAdapter(getContext(), mLogic);
        CalculatorPageAdapter largeAdapter = new LargePageAdapter(getContext(), mListener, mGraph, mLogic);
        mPages = new ArrayList<Page>(smallAdapter.getPages());
        mPages.addAll(largeAdapter.getPages());
        mSmallPager.setAdapter(smallAdapter);
        mLargePager.setAdapter(largeAdapter);
        mSmallPager.scrollToMiddle();
        mLargePager.scrollToMiddle();
        if (state != null) {
            mSmallPager.setCurrentItem(state.getInt(STATE_CURRENT_VIEW, mSmallPager.getCurrentItem()));
            mLargePager.setCurrentItem(state.getInt(STATE_CURRENT_VIEW, mLargePager.getCurrentItem()));
        } else {
            Page basic = new Page(getContext(), LargePanel.BASIC);
            Page advanced = new Page(getContext(), SmallPanel.ADVANCED);
            if (CalculatorSettings.isPageEnabled(getContext(), basic)) {
                scrollToPage(basic);
            }
            if (CalculatorSettings.isPageEnabled(getContext(), advanced)) {
                scrollToPage(advanced);
            }
        }
        mPages = Page.removeDuplicates(mPages);
        mSmallPager.setOnPageChangeListener(this);
        mLargePager.setOnPageChangeListener(this);
        runCling(false);
        mListener.setHandler(this, mLogic, mSmallPager, mLargePager);
    }
    mDisplay.setOnKeyListener(mListener);
    createFakeMenu();
    updateDeleteMode();
    mHistorySlider.bringToFront();
    updateDetails();
}
#end_block

#method_before
@Override
public void onResume() {
    super.onResume();
    // Kill floating calc (if exists)
    Intent serviceIntent = new Intent(getContext(), FloatingCalculator.class);
    stopService(serviceIntent);
    // Load new history
    mPersist = new Persist(this);
    mPersist.load();
    if (mPersist.getMode() != null)
        mLogic.getBaseModule().setMode(mPersist.getMode());
    mLogic.setDeleteMode(mPersist.getDeleteMode());
    mHistory = mPersist.mHistory;
    mLogic.setHistory(mHistory);
    mLogic.resumeWithHistory();
    mHistoryAdapter = new HistoryAdapter(this, mHistory);
    mHistory.setObserver(mHistoryAdapter);
    setUpHistory();
}
#method_after
@Override
public void onResume() {
    super.onResume();
    // Kill floating calc (if exists)
    Intent serviceIntent = new Intent(getContext(), FloatingCalculator.class);
    stopService(serviceIntent);
    // Load new history
    mPersist = new Persist(this);
    mPersist.load();
    if (mPersist.getMode() != null) {
        mLogic.getBaseModule().setMode(mPersist.getMode());
    }
    mLogic.setDeleteMode(mPersist.getDeleteMode());
    mHistory = mPersist.mHistory;
    mLogic.setHistory(mHistory);
    mLogic.resumeWithHistory();
    mHistoryAdapter = new HistoryAdapter(this, mHistory);
    mHistory.setObserver(mHistoryAdapter);
    setUpHistory();
}
#end_block

#method_before
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    super.onPrepareOptionsMenu(menu);
    Page page = mPager == null ? Page.getCurrentPage(mLargePager) : Page.getCurrentPage(mPager);
    Page smallPage = mPager == null ? Page.getCurrentPage(mSmallPager) : null;
    for (int i = 0; i < menu.size(); i++) {
        MenuItem m = menu.getItem(i);
        boolean equalToLargePage = page != null && m.getTitle().toString().equals(page.getName());
        boolean equalToSmallPage = smallPage != null && m.getTitle().toString().equals(smallPage.getName());
        m.setVisible(!equalToLargePage && !equalToSmallPage);
    }
    MenuItem clearHistory = menu.findItem(R.id.clear_history);
    clearHistory.setVisible(mHistorySlider.isSliderOpen());
    MenuItem showHistory = menu.findItem(R.id.show_history);
    showHistory.setVisible(!mHistorySlider.isSliderOpen());
    MenuItem hideHistory = menu.findItem(R.id.hide_history);
    hideHistory.setVisible(mHistorySlider.isSliderOpen());
    MenuItem lock = menu.findItem(R.id.lock);
    if (lock != null && page != null) {
        lock.setVisible(page.isGraph() && getPagingEnabled());
    }
    MenuItem unlock = menu.findItem(R.id.unlock);
    if (unlock != null && page != null) {
        unlock.setVisible(page.isGraph() && !getPagingEnabled());
    }
    MenuItem store = menu.findItem(R.id.store);
    if (store != null) {
        store.setVisible(App.doesPackageExists(getContext(), "com.android.vending"));
    }
    return true;
}
#method_after
@Override
public boolean onPrepareOptionsMenu(Menu menu) {
    super.onPrepareOptionsMenu(menu);
    Page page = mPager == null ? Page.getCurrentPage(mLargePager) : Page.getCurrentPage(mPager);
    Page smallPage = mPager == null ? Page.getCurrentPage(mSmallPager) : null;
    for (int i = 0; i < menu.size(); i++) {
        MenuItem m = menu.getItem(i);
        boolean equalToLargePage = page != null && m.getTitle().toString().equals(page.getName());
        boolean equalToSmallPage = smallPage != null && m.getTitle().toString().equals(smallPage.getName());
        m.setVisible(!mHistorySlider.isSliderOpen() && !equalToLargePage && !equalToSmallPage);
    }
    MenuItem clearHistory = menu.findItem(R.id.clear_history);
    clearHistory.setVisible(mHistorySlider.isSliderOpen());
    MenuItem showHistory = menu.findItem(R.id.show_history);
    showHistory.setVisible(!mHistorySlider.isSliderOpen());
    MenuItem hideHistory = menu.findItem(R.id.hide_history);
    hideHistory.setVisible(mHistorySlider.isSliderOpen());
    MenuItem lock = menu.findItem(R.id.lock);
    if (lock != null) {
        lock.setVisible(!mHistorySlider.isSliderOpen() && page != null && page.isGraph() && getPagingEnabled());
    }
    MenuItem unlock = menu.findItem(R.id.unlock);
    if (unlock != null) {
        unlock.setVisible(!mHistorySlider.isSliderOpen() && page != null && page.isGraph() && !getPagingEnabled());
    }
    MenuItem store = menu.findItem(R.id.store);
    if (store != null) {
        store.setVisible(!mHistorySlider.isSliderOpen() && App.doesPackageExists(getContext(), "com.android.vending"));
        store.setVisible(false);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean onKeyDown(int keyCode, KeyEvent keyEvent) {
    if (keyCode == KeyEvent.KEYCODE_BACK && mHistorySlider.isSliderOpen() && !clingActive) {
        mHistorySlider.animateSliderClosed();
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_BACK && mPager != null && !Page.getCurrentPage(mPager).isBasic() && CalculatorSettings.isPageEnabled(getContext(), new Page(getContext(), NormalPanel.BASIC)) && !clingActive) {
        // Infinite scrolling makes this tricky
        scrollToPage(new Page(getContext(), NormalPanel.BASIC));
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_BACK && mSmallPager != null && mLargePager != null && !clingActive) {
        boolean scrolled = false;
        if (CalculatorSettings.isPageEnabled(getContext(), SmallPanel.ADVANCED)) {
            if (!Page.getCurrentPage(mSmallPager).isAdvanced()) {
                scrollToPage(new Page(getContext(), SmallPanel.ADVANCED));
                scrolled = true;
            }
        }
        if (CalculatorSettings.isPageEnabled(getContext(), LargePanel.BASIC)) {
            if (!Page.getCurrentPage(mLargePager).isBasic()) {
                scrollToPage(new Page(getContext(), LargePanel.BASIC));
                scrolled = true;
            }
        }
        if (!scrolled)
            finish();
        return true;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        finish();
        return true;
    }
    return super.onKeyDown(keyCode, keyEvent);
}
#method_after
@Override
public boolean onKeyDown(int keyCode, KeyEvent keyEvent) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (!clingActive) {
            if (mHistorySlider.isSliderOpen()) {
                mHistorySlider.animateSliderClosed();
                return true;
            } else if (mPager != null && Page.getCurrentPage(mPager) != null && !Page.getCurrentPage(mPager).isBasic() && CalculatorSettings.isPageEnabled(getContext(), NormalPanel.BASIC)) {
                // Infinite scrolling makes this tricky
                scrollToPage(new Page(getContext(), NormalPanel.BASIC));
                return true;
            } else if (mSmallPager != null && mLargePager != null) {
                boolean scrolled = false;
                if (CalculatorSettings.isPageEnabled(getContext(), SmallPanel.ADVANCED)) {
                    if (!Page.getCurrentPage(mSmallPager).isAdvanced()) {
                        scrollToPage(new Page(getContext(), SmallPanel.ADVANCED));
                        scrolled = true;
                    }
                }
                if (CalculatorSettings.isPageEnabled(getContext(), LargePanel.BASIC)) {
                    if (!Page.getCurrentPage(mLargePager).isBasic()) {
                        scrollToPage(new Page(getContext(), LargePanel.BASIC));
                        scrolled = true;
                    }
                }
                if (!scrolled) {
                    finish();
                }
                return true;
            }
        }
        finish();
        return true;
    }
    return super.onKeyDown(keyCode, keyEvent);
}
#end_block

#method_before
private void setUpHistory() {
    registerForContextMenu(mHistoryView);
    mHistoryView.setAdapter(mHistoryAdapter);
    mHistoryView.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);
    mHistoryView.setStackFromBottom(true);
    mHistoryView.setFocusable(false);
    mHistoryView.setOnItemClickListener(new OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            int deleteMode = mLogic.getDeleteMode();
            if (mDisplay.getText().isEmpty())
                deleteMode = Logic.DELETE_MODE_CLEAR;
            mDisplay.insert(((HistoryLine) view).getHistoryEntry().getEdited());
            mLogic.setDeleteMode(deleteMode);
        }
    });
}
#method_after
private void setUpHistory() {
    registerForContextMenu(mHistoryView);
    mHistoryView.setAdapter(mHistoryAdapter);
    mHistoryView.setTranscriptMode(ListView.TRANSCRIPT_MODE_ALWAYS_SCROLL);
    mHistoryView.setStackFromBottom(true);
    mHistoryView.setFocusable(false);
    mHistoryView.setOnItemClickListener(new OnItemClickListener() {

        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
            int deleteMode = mLogic.getDeleteMode();
            if (mDisplay.getText().isEmpty()) {
                deleteMode = Logic.DELETE_MODE_CLEAR;
            }
            mDisplay.insert(((HistoryLine) view).getHistoryEntry().getEdited());
            mLogic.setDeleteMode(deleteMode);
        }
    });
}
#end_block

#method_before
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
    AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
    View history = mHistoryAdapter.getView(info.position, null, null);
    if (history instanceof HistoryLine)
        ((HistoryLine) history).onCreateContextMenu(menu);
}
#method_after
@Override
public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
    AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
    View history = mHistoryAdapter.getView(info.position, null, null);
    if (history instanceof HistoryLine) {
        ((HistoryLine) history).onCreateContextMenu(menu);
    }
}
#end_block

#method_before
private boolean isClingsEnabled() {
    // disable clings when running in a test harness
    if (ActivityManager.isRunningInTestHarness())
        return false;
    return true;
}
#method_after
private boolean isClingsEnabled() {
    // Disable clings when running in a test harness
    if (ActivityManager.isRunningInTestHarness()) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void runCling(boolean animate) {
    Page largePage = mPager == null ? Page.getCurrentPage(mLargePager) : Page.getCurrentPage(mPager);
    Page smallPage = mPager == null ? Page.getCurrentPage(mSmallPager) : null;
    if (largePage != null)
        largePage.showTutorial(this, animate);
    if (smallPage != null)
        smallPage.showTutorial(this, animate);
}
#method_after
private void runCling(boolean animate) {
    Page largePage = mPager == null ? Page.getCurrentPage(mLargePager) : Page.getCurrentPage(mPager);
    Page smallPage = mPager == null ? Page.getCurrentPage(mSmallPager) : null;
    if (largePage != null) {
        largePage.showTutorial(this, animate);
    }
    if (smallPage != null) {
        smallPage.showTutorial(this, animate);
    }
}
#end_block

#method_before
private boolean getPagingEnabled() {
    if (mPager != null)
        return mPager.getPagingEnabled();
    if (mSmallPager != null)
        return mSmallPager.getPagingEnabled();
    if (mLargePager != null)
        return mLargePager.getPagingEnabled();
    return true;
}
#method_after
private boolean getPagingEnabled() {
    if (mPager != null) {
        return mPager.getPagingEnabled();
    }
    if (mSmallPager != null) {
        return mSmallPager.getPagingEnabled();
    }
    if (mLargePager != null) {
        return mLargePager.getPagingEnabled();
    }
    return true;
}
#end_block

#method_before
private void setPagingEnabled(boolean enabled) {
    if (mPager != null)
        mPager.setPagingEnabled(enabled);
    if (mSmallPager != null)
        mSmallPager.setPagingEnabled(enabled);
    if (mLargePager != null)
        mLargePager.setPagingEnabled(enabled);
}
#method_after
private void setPagingEnabled(boolean enabled) {
    if (mPager != null) {
        mPager.setPagingEnabled(enabled);
    }
    if (mSmallPager != null) {
        mSmallPager.setPagingEnabled(enabled);
    }
    if (mLargePager != null) {
        mLargePager.setPagingEnabled(enabled);
    }
}
#end_block

#method_before
@Override
public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
}
#method_after
@Override
public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
// Do nothing here
}
#end_block

#method_before
@Override
public void onPageSelected(int position) {
}
#method_after
@Override
public void onPageSelected(int position) {
// Do nothing here
}
#end_block

#method_before
protected void scrollToPage(Page p) {
    CalculatorViewPager pager = mPager;
    int order = Page.getOrder(mPages, p);
    int pagesSize = mPages.size();
    if (pager == null) {
        pager = p.isSmall() ? mSmallPager : mLargePager;
        order = Page.getOrder(((CalculatorPageAdapter) pager.getAdapter()).getPages(), p);
        pagesSize = ((CalculatorPageAdapter) pager.getAdapter()).getPages().size();
    }
    if (CalculatorSettings.useInfiniteScrolling(getContext())) {
        int offset = 0;
        while ((pager.getCurrentItem() + offset) % pagesSize != order && (pager.getCurrentItem() - offset) % pagesSize != order) {
            offset++;
        }
        if ((pager.getCurrentItem() + offset) % pagesSize == order) {
            pager.setCurrentItem(pager.getCurrentItem() + offset);
        } else {
            pager.setCurrentItem(pager.getCurrentItem() - offset);
        }
    } else {
        pager.setCurrentItem(order);
    }
}
#method_after
public void scrollToPage(Page p) {
    CalculatorViewPager pager = mPager;
    int order = Page.getOrder(mPages, p);
    int pagesSize = mPages.size();
    if (pager == null) {
        pager = p.isSmall() ? mSmallPager : mLargePager;
        order = Page.getOrder(((CalculatorPageAdapter) pager.getAdapter()).getPages(), p);
        pagesSize = ((CalculatorPageAdapter) pager.getAdapter()).getPages().size();
    }
    if (CalculatorSettings.useInfiniteScrolling(getContext())) {
        int offset = 0;
        while ((pager.getCurrentItem() + offset) % pagesSize != order && (pager.getCurrentItem() - offset) % pagesSize != order) {
            offset++;
        }
        if ((pager.getCurrentItem() + offset) % pagesSize == order) {
            pager.setCurrentItem(pager.getCurrentItem() + offset);
        } else {
            pager.setCurrentItem(pager.getCurrentItem() - offset);
        }
    } else {
        pager.setCurrentItem(order);
    }
}
#end_block

#method_before
private void updateDetails() {
    if (mDetails != null && CalculatorSettings.showDetails(getContext())) {
        String text = "";
        String units = CalculatorSettings.useRadians(getContext()) ? getString(R.string.radians) : getString(R.string.degrees);
        String base = "";
        if (CalculatorSettings.isPageEnabled(getContext(), NormalPanel.HEX)) {
            switch(mLogic.getBaseModule().getMode()) {
                case HEXADECIMAL:
                    base = getString(R.string.hex).toUpperCase(Locale.getDefault());
                    break;
                case BINARY:
                    base = getString(R.string.bin).toUpperCase(Locale.getDefault());
                    break;
                case DECIMAL:
                    base = getString(R.string.dec).toUpperCase(Locale.getDefault());
                    break;
            }
        }
        if (!base.isEmpty())
            text += base + " | ";
        text += units;
        mDetails.setMovementMethod(LinkMovementMethod.getInstance());
        mDetails.setText(text, BufferType.SPANNABLE);
        Spannable spans = (Spannable) mDetails.getText();
        ClickableSpan clickSpan = getClickableSpan(units);
        spans.setSpan(clickSpan, text.indexOf(units), text.indexOf(units) + units.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
}
#method_after
private void updateDetails() {
    if (mDetails != null && CalculatorSettings.showDetails(getContext())) {
        String text = "";
        String units = CalculatorSettings.useRadians(getContext()) ? getString(R.string.radians) : getString(R.string.degrees);
        String base = "";
        if (CalculatorSettings.isPageEnabled(getContext(), NormalPanel.HEX)) {
            switch(mLogic.getBaseModule().getMode()) {
                case HEXADECIMAL:
                    base = getString(R.string.hex).toUpperCase(Locale.getDefault());
                    break;
                case BINARY:
                    base = getString(R.string.bin).toUpperCase(Locale.getDefault());
                    break;
                case DECIMAL:
                    base = getString(R.string.dec).toUpperCase(Locale.getDefault());
                    break;
            }
        }
        if (!base.isEmpty()) {
            text += base + " | ";
        }
        text += units;
        mDetails.setMovementMethod(LinkMovementMethod.getInstance());
        mDetails.setText(text, BufferType.SPANNABLE);
        Spannable spans = (Spannable) mDetails.getText();
        ClickableSpan clickSpan = getClickableSpan(units);
        spans.setSpan(clickSpan, text.indexOf(units), text.indexOf(units) + units.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
    }
}
#end_block

#method_before
private ClickableSpan getClickableSpan(final String word) {
    return new ClickableSpan() {

        @Override
        public void onClick(View widget) {
            CalculatorSettings.setRadiansEnabled(getContext(), !CalculatorSettings.useRadians(getContext()));
            updateDetails();
        }

        public void updateDrawState(TextPaint ds) {
        }
    };
}
#method_after
private ClickableSpan getClickableSpan(final String word) {
    return new ClickableSpan() {

        @Override
        public void onClick(View widget) {
            CalculatorSettings.setRadiansEnabled(getContext(), !CalculatorSettings.useRadians(getContext()));
            updateDetails();
        }

        public void updateDrawState(TextPaint ds) {
        // Do nothing here
        }
    };
}
#end_block

#method_before
private void init(Calculator calc, AttributeSet attrs) {
    CLICK_FEEDBACK_COLOR = Theme.getColor(getContext(), R.color.magic_flame);
    mFeedbackPaint = new Paint();
    mFeedbackPaint.setStyle(Style.STROKE);
    mFeedbackPaint.setStrokeWidth(2);
    mAnimStart = -1;
}
#method_after
private void init() {
    CLICK_FEEDBACK_COLOR = Theme.getColor(getContext(), R.color.magic_flame);
    mFeedbackPaint = new Paint();
    mFeedbackPaint.setStyle(Style.STROKE);
    mFeedbackPaint.setStrokeWidth(2);
    mAnimStart = -1;
}
#end_block

#method_before
private void layoutText() {
    Paint paint = getPaint();
    if (mTextSize != 0f)
        paint.setTextSize(mTextSize);
    float textWidth = paint.measureText(getText().toString());
    float width = getWidth() - getPaddingLeft() - getPaddingRight();
    float textSize = getTextSize();
    if (textWidth > width) {
        paint.setTextSize(textSize * width / textWidth);
        mTextX = getPaddingLeft();
        mTextSize = textSize;
    } else {
        mTextX = (getWidth() - textWidth) / 2;
    }
    mTextY = (getHeight() - paint.ascent() - paint.descent()) / 2;
    if (mHintPaint != null)
        mHintPaint.setTextSize(paint.getTextSize() * getContext().getResources().getInteger(R.integer.button_hint_text_size_percent) / 100f);
}
#method_after
private void layoutText() {
    Paint paint = getPaint();
    if (mTextSize != 0f) {
        paint.setTextSize(mTextSize);
    }
    float textWidth = paint.measureText(getText().toString());
    float width = getWidth() - getPaddingLeft() - getPaddingRight();
    float textSize = getTextSize();
    if (textWidth > width) {
        paint.setTextSize(textSize * width / textWidth);
        mTextX = getPaddingLeft();
        mTextSize = textSize;
    } else {
        mTextX = (getWidth() - textWidth) / 2;
    }
    mTextY = (getHeight() - paint.ascent() - paint.descent()) / 2;
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    if (changed)
        layoutText();
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    super.onLayout(changed, left, top, right, bottom);
    if (changed) {
        layoutText();
    }
}
#end_block

#method_before
private void drawMagicFlame(int duration, Canvas canvas) {
    int alpha = 255 - 255 * duration / CLICK_FEEDBACK_DURATION;
    int color = CLICK_FEEDBACK_COLOR | (alpha << 24);
    mFeedbackPaint.setColor(color);
    canvas.drawRect(1, 1, getWidth() - 1, getHeight() - 1, mFeedbackPaint);
}
#method_after
private void drawMagicFlame(int duration, Canvas canvas) {
    if (CLICK_FEEDBACK_COLOR >= 0x00000000 && CLICK_FEEDBACK_COLOR <= 0x00FFFFFF) {
        // Feedback has been set as transparent
        return;
    }
    int alpha = 255 - 255 * duration / CLICK_FEEDBACK_DURATION;
    int color = CLICK_FEEDBACK_COLOR | (alpha << 24);
    mFeedbackPaint.setColor(color);
    canvas.drawRect(1, 1, getWidth() - 1, getHeight() - 1, mFeedbackPaint);
}
#end_block

#method_before
@Override
protected void onDraw(Canvas canvas) {
    if (mAnimStart != -1) {
        int animDuration = (int) (System.currentTimeMillis() - mAnimStart);
        if (animDuration >= CLICK_FEEDBACK_DURATION) {
            mAnimStart = -1;
        } else {
            drawMagicFlame(animDuration, canvas);
            postInvalidateDelayed(CLICK_FEEDBACK_INTERVAL);
        }
    } else if (isPressed()) {
        drawMagicFlame(0, canvas);
    }
    mHintPaint.setColor(Theme.getColor(getContext(), R.color.button_hint_text));
    CharSequence hint = getHint();
    if (hint != null) {
        int offsetX = getContext().getResources().getDimensionPixelSize(R.dimen.button_hint_offset_x);
        int offsetY = (int) ((mTextY + getContext().getResources().getDimensionPixelSize(R.dimen.button_hint_offset_y) - mHintPaint.getTextSize()) / 2) - getPaddingTop();
        float textWidth = mHintPaint.measureText(hint.toString());
        float width = getWidth() - getPaddingLeft() - getPaddingRight() - mTextX - offsetX;
        float textSize = mHintPaint.getTextSize();
        if (textWidth > width) {
            mHintPaint.setTextSize(textSize * width / textWidth);
        }
        canvas.drawText(getHint(), 0, getHint().length(), mTextX + offsetX, mTextY - offsetY, mHintPaint);
    }
    getPaint().setColor(getCurrentTextColor());
    CharSequence text = getText();
    canvas.drawText(text, 0, text.length(), mTextX, mTextY, getPaint());
}
#method_after
@Override
protected void onDraw(Canvas canvas) {
    if (mAnimStart != -1) {
        int animDuration = (int) (System.currentTimeMillis() - mAnimStart);
        if (animDuration >= CLICK_FEEDBACK_DURATION) {
            mAnimStart = -1;
        } else {
            drawMagicFlame(animDuration, canvas);
            postInvalidateDelayed(CLICK_FEEDBACK_INTERVAL);
        }
    } else if (isPressed()) {
        drawMagicFlame(0, canvas);
    }
    mHintPaint.setColor(Theme.getColor(getContext(), R.color.button_hint_text));
    CharSequence hint = getHint();
    if (hint != null) {
        mHintPaint.setTextSize(getPaint().getTextSize() * getContext().getResources().getInteger(R.integer.button_hint_text_size_percent) / 100f);
        int offsetX = getContext().getResources().getDimensionPixelSize(R.dimen.button_hint_offset_x);
        int offsetY = (int) ((mTextY + getContext().getResources().getDimensionPixelSize(R.dimen.button_hint_offset_y) - mHintPaint.getTextSize()) / 2) - getPaddingTop();
        float textWidth = mHintPaint.measureText(hint.toString());
        float width = getWidth() - getPaddingLeft() - getPaddingRight() - mTextX - offsetX;
        float textSize = mHintPaint.getTextSize();
        if (textWidth > width) {
            mHintPaint.setTextSize(textSize * width / textWidth);
        }
        canvas.drawText(getHint(), 0, getHint().length(), mTextX + offsetX, mTextY - offsetY, mHintPaint);
    }
    getPaint().setColor(getCurrentTextColor());
    CharSequence text = getText();
    canvas.drawText(text, 0, text.length(), mTextX, mTextY, getPaint());
}
#end_block

#method_before
static boolean isOperator(char c) {
    // plus minus times div
    return "+\u2212\u00d7\u00f7/*".indexOf(c) != -1;
}
#method_after
static boolean isOperator(char c) {
    // Plus minus times div
    return "+\u2212\u00d7\u00f7/*^".indexOf(c) != -1;
}
#end_block

#method_before
static boolean isPostFunction(char c) {
    // exponent, factorial, percent
    return "^!%".indexOf(c) != -1;
}
#method_after
static boolean isPostFunction(char c) {
    // Exponent, factorial, percent
    return "^!%".indexOf(c) != -1;
}
#end_block

#method_before
public void setGraphDisplay(GraphicalView graphDisplay) {
    mGraphDisplay = graphDisplay;
}
#method_after
public void setGraphDisplay(GraphView graphView) {
    mGraphView = graphView;
}
#end_block

#method_before
public void setDeleteMode(int mode) {
    if (mDeleteMode != mode) {
        mDeleteMode = mode;
        if (mListener != null)
            mListener.onDeleteModeChange();
    }
}
#method_after
public void setDeleteMode(int mode) {
    if (mDeleteMode != mode) {
        mDeleteMode = mode;
        if (mListener != null) {
            mListener.onDeleteModeChange();
        }
    }
}
#end_block

#method_before
void setText(String text) {
    clear(false);
    mDisplay.insert(text);
    if (text.equals(mErrorString))
        setDeleteMode(DELETE_MODE_CLEAR);
}
#method_after
void setText(String text) {
    clear(false);
    mDisplay.insert(text);
    if (text.equals(mErrorString)) {
        setDeleteMode(DELETE_MODE_CLEAR);
    }
}
#end_block

#method_before
void insert(String delta) {
    if (!acceptInsert(delta)) {
        clear(true);
    }
    mDisplay.insert(delta);
    setDeleteMode(DELETE_MODE_BACKSPACE);
    mGraphModule.updateGraphCatchErrors(mGraph);
}
#method_after
void insert(String delta) {
    if (!acceptInsert(delta)) {
        clear(true);
    }
    mDisplay.insert(delta);
    setDeleteMode(DELETE_MODE_BACKSPACE);
    mGraphModule.updateGraph(mGraph);
}
#end_block

#method_before
void onDelete() {
    if (getText().equals(mResult) || mIsError) {
        clear(false);
    } else {
        mDisplay.dispatchKeyEvent(new KeyEvent(0, KeyEvent.KEYCODE_DEL));
        mResult = "";
    }
    mGraphModule.updateGraphCatchErrors(mGraph);
}
#method_after
void onDelete() {
    if (getText().equals(mResult) || mIsError) {
        clear(false);
    } else {
        mDisplay.dispatchKeyEvent(new KeyEvent(0, KeyEvent.KEYCODE_DEL));
        mResult = "";
    }
    mGraphModule.updateGraph(mGraph);
}
#end_block

#method_before
void onClear() {
    clear(mDeleteMode == DELETE_MODE_CLEAR);
    mGraphModule.updateGraphCatchErrors(mGraph);
}
#method_after
void onClear() {
    clear(mDeleteMode == DELETE_MODE_CLEAR);
    mGraphModule.updateGraph(mGraph);
}
#end_block

#method_before
boolean displayContainsMatrices() {
    boolean containsMatrices = false;
    for (int i = 0; i < mDisplay.getAdvancedDisplay().getChildCount(); i++) {
        if (mDisplay.getAdvancedDisplay().getChildAt(i) instanceof MatrixView)
            containsMatrices = true;
        if (mDisplay.getAdvancedDisplay().getChildAt(i) instanceof MatrixInverseView)
            containsMatrices = true;
        if (mDisplay.getAdvancedDisplay().getChildAt(i) instanceof MatrixTransposeView)
            containsMatrices = true;
    }
    return containsMatrices;
}
#method_after
boolean displayContainsMatrices() {
    boolean containsMatrices = false;
    for (int i = 0; i < mDisplay.getAdvancedDisplay().getChildCount(); i++) {
        if (mDisplay.getAdvancedDisplay().getChildAt(i) instanceof MatrixView) {
            containsMatrices = true;
        }
        if (mDisplay.getAdvancedDisplay().getChildAt(i) instanceof MatrixInverseView) {
            containsMatrices = true;
        }
        if (mDisplay.getAdvancedDisplay().getChildAt(i) instanceof MatrixTransposeView) {
            containsMatrices = true;
        }
    }
    return containsMatrices;
}
#end_block

#method_before
public String evaluate(String input) throws SyntaxException {
    if (input.trim().isEmpty()) {
        return "";
    }
    // Drop final infix operators (they can only result in error)
    int size = input.length();
    while (size > 0 && isOperator(input.charAt(size - 1))) {
        input = input.substring(0, size - 1);
        --size;
    }
    input = localize(input);
    // Convert to decimal
    String decimalInput = convertToDecimal(input);
    Complex value = mSymbols.evalComplex(decimalInput);
    String real = "";
    for (int precision = mLineLength; precision > 6; precision--) {
        real = tryFormattingWithPrecision(value.re, precision);
        if (real.length() <= mLineLength) {
            break;
        }
    }
    String imaginary = "";
    for (int precision = mLineLength; precision > 6; precision--) {
        imaginary = tryFormattingWithPrecision(value.im, precision);
        if (imaginary.length() <= mLineLength) {
            break;
        }
    }
    real = mBaseModule.updateTextToNewMode(real, Mode.DECIMAL, mBaseModule.getMode()).replace('-', MINUS).replace(INFINITY, INFINITY_UNICODE);
    imaginary = mBaseModule.updateTextToNewMode(imaginary, Mode.DECIMAL, mBaseModule.getMode()).replace('-', MINUS).replace(INFINITY, INFINITY_UNICODE);
    String result = "";
    if (value.re != 0 && value.im > 0)
        result = real + "+" + imaginary + "i";
    else if (// Implicit -
    value.re != 0 && value.im < 0)
        // Implicit -
        result = real + imaginary + "i";
    else if (value.re != 0 && value.im == 0)
        result = real;
    else if (value.re == 0 && value.im != 0)
        result = imaginary + "i";
    else if (value.re == 0 && value.im == 0)
        result = "0";
    result = relocalize(result);
    return result;
}
#method_after
public String evaluate(String input) throws SyntaxException {
    if (input.trim().isEmpty()) {
        return "";
    }
    // Drop final infix operators (they can only result in error)
    int size = input.length();
    while (size > 0 && isOperator(input.charAt(size - 1))) {
        input = input.substring(0, size - 1);
        --size;
    }
    input = localize(input);
    // Convert to decimal
    String decimalInput = convertToDecimal(input);
    Complex value = mSymbols.evalComplex(decimalInput);
    String real = "";
    for (int precision = mLineLength; precision > 6; precision--) {
        real = tryFormattingWithPrecision(value.re, precision);
        if (real.length() <= mLineLength) {
            break;
        }
    }
    String imaginary = "";
    for (int precision = mLineLength; precision > 6; precision--) {
        imaginary = tryFormattingWithPrecision(value.im, precision);
        if (imaginary.length() <= mLineLength) {
            break;
        }
    }
    real = mBaseModule.updateTextToNewMode(real, Mode.DECIMAL, mBaseModule.getMode()).replace('-', MINUS).replace(INFINITY, INFINITY_UNICODE);
    imaginary = mBaseModule.updateTextToNewMode(imaginary, Mode.DECIMAL, mBaseModule.getMode()).replace('-', MINUS).replace(INFINITY, INFINITY_UNICODE);
    String result = "";
    if (value.re != 0 && value.im == 1) {
        result = real + "+" + "i";
    } else if (value.re != 0 && value.im > 0) {
        result = real + "+" + imaginary + "i";
    } else if (value.re != 0 && value.im == -1) {
        result = real + "-" + "i";
    } else if (value.re != 0 && value.im < 0) {
        // Implicit
        result = real + imaginary + "i";
    } else if (value.re != 0 && value.im == 0) {
        result = real;
    } else if (value.re == 0 && value.im == 1) {
        result = "i";
    } else if (value.re == 0 && value.im == -1) {
        result = "-i";
    }
    result = relocalize(result);
    return result;
}
#end_block

#method_before
String localize(String input) {
    // Delocalize functions (e.g. Spanish localizes "sin" as "sen"). Order
    // matters for arc functions
    input = input.replace(mArcsinString, "asin");
    input = input.replace(mArccosString, "acos");
    input = input.replace(mArctanString, "atan");
    input = input.replace(mSinString, "sin");
    input = input.replace(mCosString, "cos");
    input = input.replace(mTanString, "tan");
    if (!CalculatorSettings.useRadians(mContext)) {
        input = input.replace("sin", "sind");
        input = input.replace("cos", "cosd");
        input = input.replace("tan", "tand");
    }
    input = input.replace(mLogString, "log");
    input = input.replace(mLnString, "ln");
    input = input.replace(mDetString, "det");
    input = input.replace(mCbrtString, "cbrt");
    input = input.replace(mDecimalPoint, ".");
    input = input.replace(mMatrixSeparator, ",");
    return input;
}
#method_after
String localize(String input) {
    // Delocalize functions (e.g. Spanish localizes "sin" as "sen").
    // Order matters for arc functions
    input = input.replace(mArcsinString, "asin");
    input = input.replace(mArccosString, "acos");
    input = input.replace(mArctanString, "atan");
    input = input.replace(mSinString, "sin");
    input = input.replace(mCosString, "cos");
    input = input.replace(mTanString, "tan");
    if (!CalculatorSettings.useRadians(mContext)) {
        input = input.replace("sin", "sind");
        input = input.replace("cos", "cosd");
        input = input.replace("tan", "tand");
    }
    input = input.replace(mLogString, "log");
    input = input.replace(mLnString, "ln");
    input = input.replace(mDetString, "det");
    input = input.replace(mCbrtString, "cbrt");
    input = input.replace(mDecimalPoint, ".");
    input = input.replace(mMatrixSeparator, ",");
    return input;
}
#end_block

#method_before
String tryFormattingWithPrecision(double value, int precision) {
    // The standard scientific formatter is basically what we need. We will
    // start with what it produces and then massage it a bit.
    String result = String.format(Locale.US, "%" + mLineLength + "." + precision + "g", value);
    if (result.equals(NAN)) {
        // treat NaN as Error
        return mErrorString;
    }
    String mantissa = result;
    String exponent = null;
    int e = result.indexOf('e');
    if (e != -1) {
        mantissa = result.substring(0, e);
        // Strip "+" and unnecessary 0's from the exponent
        exponent = result.substring(e + 1);
        if (exponent.startsWith("+")) {
            exponent = exponent.substring(1);
        }
        exponent = String.valueOf(Integer.parseInt(exponent));
    }
    int period = mantissa.indexOf('.');
    if (period == -1) {
        period = mantissa.indexOf(',');
    }
    if (period != -1) {
        // Strip trailing 0's
        while (mantissa.length() > 0 && mantissa.endsWith("0")) {
            mantissa = mantissa.substring(0, mantissa.length() - 1);
        }
        if (mantissa.length() == period + 1) {
            mantissa = mantissa.substring(0, mantissa.length() - 1);
        }
    }
    if (exponent != null) {
        result = mantissa + 'e' + exponent;
    } else {
        result = mantissa;
    }
    return result;
}
#method_after
String tryFormattingWithPrecision(double value, int precision) {
    // The standard scientific formatter is basically what we need.
    // We will start with what it produces and then massage it a bit.
    String result = String.format(Locale.US, "%" + mLineLength + "." + precision + "g", value);
    // Treat NaN as Error
    if (result.equals(NAN)) {
        return mErrorString;
    }
    String mantissa = result;
    String exponent = null;
    int e = result.indexOf('e');
    if (e != -1) {
        mantissa = result.substring(0, e);
        // Strip "+" and unnecessary 0's from the exponent
        exponent = result.substring(e + 1);
        if (exponent.startsWith("+")) {
            exponent = exponent.substring(1);
        }
        exponent = String.valueOf(Integer.parseInt(exponent));
    }
    int period = mantissa.indexOf('.');
    if (period == -1) {
        period = mantissa.indexOf(',');
    }
    if (period != -1) {
        // Strip trailing 0's
        while (mantissa.length() > 0 && mantissa.endsWith("0")) {
            mantissa = mantissa.substring(0, mantissa.length() - 1);
        }
        if (mantissa.length() == period + 1) {
            mantissa = mantissa.substring(0, mantissa.length() - 1);
        }
    }
    if (exponent != null) {
        result = mantissa + 'e' + exponent;
    } else {
        result = mantissa;
    }
    return result;
}
#end_block

#method_before
private void updateIconPosition(int x, int y) {
    mCurrentPosX = x;
    mCurrentPosY = y;
    View v = mDraggableIconImage;
    v.setTranslationX(0);
    if (x < 0) {
        v.setTranslationX(x);
        x = 0;
    }
    if (x > getScreenWidth() - FLOATING_WINDOW_ICON_SIZE) {
        v.setTranslationX(x - getScreenWidth() + FLOATING_WINDOW_ICON_SIZE);
        x = getScreenWidth() - FLOATING_WINDOW_ICON_SIZE;
    }
    v.setTranslationY(0);
    if (y < 0) {
        v.setTranslationY(y);
        y = 0;
    }
    if (y > getScreenHeight() - FLOATING_WINDOW_ICON_SIZE) {
        v.setTranslationY(y - getScreenHeight() + FLOATING_WINDOW_ICON_SIZE);
        y = getScreenHeight() - FLOATING_WINDOW_ICON_SIZE;
    }
    mParams.x = x;
    mParams.y = y;
    if (!mIsDestroyed)
        mWindowManager.updateViewLayout(mDraggableIcon, mParams);
}
#method_after
private void updateIconPosition(int x, int y) {
    mCurrentPosX = x;
    mCurrentPosY = y;
    View v = mDraggableIconImage;
    v.setTranslationX(0);
    if (x < 0) {
        v.setTranslationX(x);
        x = 0;
    }
    if (x > getScreenWidth() - FLOATING_WINDOW_ICON_SIZE) {
        v.setTranslationX(x - getScreenWidth() + FLOATING_WINDOW_ICON_SIZE);
        x = getScreenWidth() - FLOATING_WINDOW_ICON_SIZE;
    }
    v.setTranslationY(0);
    if (y < 0) {
        v.setTranslationY(y);
        y = 0;
    }
    if (y > getScreenHeight() - FLOATING_WINDOW_ICON_SIZE) {
        v.setTranslationY(y - getScreenHeight() + FLOATING_WINDOW_ICON_SIZE);
        y = getScreenHeight() - FLOATING_WINDOW_ICON_SIZE;
    }
    mParams.x = x;
    mParams.y = y;
    if (!mIsDestroyed) {
        mWindowManager.updateViewLayout(mDraggableIcon, mParams);
    }
}
#end_block

#method_before
private void vibrate() {
    if (mDontVibrate)
        return;
    Vibrator vi = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    if (!vi.hasVibrator())
        return;
    vi.vibrate(25);
}
#method_after
private void vibrate() {
    if (mDontVibrate) {
        return;
    }
    Vibrator vi = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    if (!vi.hasVibrator()) {
        return;
    }
    vi.vibrate(25);
}
#end_block

#method_before
private void close(boolean animate) {
    if (mIsBeingDestroyed)
        return;
    mIsBeingDestroyed = true;
    if (animate) {
        animateToDeleteBoxCenter(new OnAnimationFinishedListener() {

            @Override
            public void onAnimationFinished() {
                hideDeleteBox();
                mDeleteIconHolder.animate().scaleX(0.3f).scaleY(0.3f);
                mDraggableIconImage.animate().scaleX(0.3f).scaleY(0.3f).translationY(CLOSE_ANIMATION_DISTANCE).setDuration(mDeleteIconHolder.animate().getDuration()).setListener(new AnimationFinishedListener() {

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        stopSelf();
                    }
                });
            }
        });
    } else {
        stopSelf();
    }
}
#method_after
private void close(boolean animate) {
    if (mIsBeingDestroyed) {
        return;
    }
    mIsBeingDestroyed = true;
    if (animate) {
        animateToDeleteBoxCenter(new OnAnimationFinishedListener() {

            @Override
            public void onAnimationFinished() {
                hideDeleteBox();
                mDeleteIconHolder.animate().scaleX(0.3f).scaleY(0.3f);
                mDraggableIconImage.animate().scaleX(0.3f).scaleY(0.3f).translationY(CLOSE_ANIMATION_DISTANCE).setDuration(mDeleteIconHolder.animate().getDuration()).setListener(new AnimationFinishedListener() {

                    @Override
                    public void onAnimationEnd(Animator animation) {
                        stopSelf();
                    }
                });
            }
        });
    } else {
        stopSelf();
    }
}
#end_block

#method_before
private void animateToDeleteBoxCenter(final OnAnimationFinishedListener l) {
    if (mIsAnimationLocked)
        return;
    mIsInDeleteMode = true;
    if (mAnimationTask != null)
        mAnimationTask.cancel();
    mAnimationTask = new AnimationTask(getScreenWidth() / 2 - mDraggableIcon.getWidth() / 2, getScreenHeight() - DELETE_BOX_HEIGHT / 2 - mDraggableIcon.getHeight() / 2);
    mAnimationTask.setDuration(150);
    mAnimationTask.setAnimationFinishedListener(l);
    mAnimationTask.run();
    vibrate();
    mDeleteIcon.animate().scaleX(1.4f).scaleY(1.4f).setDuration(100);
}
#method_after
private void animateToDeleteBoxCenter(final OnAnimationFinishedListener l) {
    if (mIsAnimationLocked) {
        return;
    }
    mIsInDeleteMode = true;
    if (mAnimationTask != null) {
        mAnimationTask.cancel();
    }
    mAnimationTask = new AnimationTask(getScreenWidth() / 2 - mDraggableIcon.getWidth() / 2, getScreenHeight() - DELETE_BOX_HEIGHT / 2 - mDraggableIcon.getHeight() / 2);
    mAnimationTask.setDuration(150);
    mAnimationTask.setAnimationFinishedListener(l);
    mAnimationTask.run();
    vibrate();
    mDeleteIcon.animate().scaleX(1.4f).scaleY(1.4f).setDuration(100);
}
#end_block

#method_before
@Override
public void onCreate() {
    super.onCreate();
    // Set up theme engine (the display uses it, but most of it should be turned off. this is just in case)
    Theme.buildResourceMap(com.android.calculator2.R.class);
    Theme.setPackageName(CalculatorSettings.getTheme(getContext()));
    // Set up a static callback for the FloatingCalculatorActivity
    ACTIVE_CALCULATOR = this;
    // Load margins, distances, etc
    MARGIN_VERTICAL = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 5, getResources().getDisplayMetrics());
    MARGIN_HORIZONTAL = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, -10, getResources().getDisplayMetrics());
    MARGIN_CALCULATOR = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics());
    CLOSE_ANIMATION_DISTANCE = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 200, getResources().getDisplayMetrics());
    CLOSE_OFFSET = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
    DRAG_DELTA = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
    STARTING_POINT_Y = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, getResources().getDisplayMetrics());
    DELETE_BOX_WIDTH = (int) getResources().getDimension(R.dimen.floating_window_delete_box_width);
    DELETE_BOX_HEIGHT = (int) getResources().getDimension(R.dimen.floating_window_delete_box_height);
    FLOATING_WINDOW_ICON_SIZE = (int) getResources().getDimension(R.dimen.floating_window_icon);
    mDraggableIcon = new FloatingView(this);
    mDraggableIcon.setOnTouchListener(this);
    View.inflate(getContext(), R.layout.floating_calculator_icon, mDraggableIcon);
    mDraggableIconImage = mDraggableIcon.findViewById(R.id.icon);
    mParams = addView(mDraggableIcon, 0, 0);
    updateIconPosition(MARGIN_HORIZONTAL, STARTING_POINT_Y);
    // Actionbar changes heights based on orientation
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent myIntent) {
            int x = mParams.x == 0 ? 0 + MARGIN_HORIZONTAL : getScreenWidth() - FLOATING_WINDOW_ICON_SIZE - MARGIN_HORIZONTAL;
            int y = mCurrentPosY;
            if (y <= 0)
                y = MARGIN_VERTICAL;
            if (y >= getScreenHeight() - mDraggableIcon.getHeight())
                y = getScreenHeight() - mDraggableIcon.getHeight() - MARGIN_VERTICAL;
            updateIconPosition(x, y);
        }
    };
    registerReceiver(mBroadcastReceiver, filter);
}
#method_after
@Override
public void onCreate() {
    super.onCreate();
    // Set up theme engine (the display uses it, but most of it should
    // be turned off. This is just in case)
    Theme.buildResourceMap(com.android.calculator2.R.class);
    Theme.setPackageName(CalculatorSettings.getTheme(getContext()));
    // Set up a static callback for the FloatingCalculatorActivity
    ACTIVE_CALCULATOR = this;
    // Load margins, distances, etc.
    MARGIN_VERTICAL = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 5, getResources().getDisplayMetrics());
    MARGIN_HORIZONTAL = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, -10, getResources().getDisplayMetrics());
    MARGIN_CALCULATOR = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, getResources().getDisplayMetrics());
    CLOSE_ANIMATION_DISTANCE = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 200, getResources().getDisplayMetrics());
    CLOSE_OFFSET = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
    DRAG_DELTA = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
    STARTING_POINT_Y = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, getResources().getDisplayMetrics());
    DELETE_BOX_WIDTH = (int) getResources().getDimension(R.dimen.floating_window_delete_box_width);
    DELETE_BOX_HEIGHT = (int) getResources().getDimension(R.dimen.floating_window_delete_box_height);
    FLOATING_WINDOW_ICON_SIZE = (int) getResources().getDimension(R.dimen.floating_window_icon);
    mDraggableIcon = new FloatingView(this);
    mDraggableIcon.setOnTouchListener(this);
    View.inflate(getContext(), R.layout.floating_calculator_icon, mDraggableIcon);
    mDraggableIconImage = mDraggableIcon.findViewById(R.id.icon);
    mParams = addView(mDraggableIcon, 0, 0);
    updateIconPosition(MARGIN_HORIZONTAL, STARTING_POINT_Y);
    // Actionbar changes heights based on orientation
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CONFIGURATION_CHANGED);
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent myIntent) {
            int x = mParams.x == 0 ? 0 + MARGIN_HORIZONTAL : getScreenWidth() - FLOATING_WINDOW_ICON_SIZE - MARGIN_HORIZONTAL;
            int y = mCurrentPosY;
            if (y <= 0) {
                y = MARGIN_VERTICAL;
            }
            if (y >= getScreenHeight() - mDraggableIcon.getHeight()) {
                y = getScreenHeight() - mDraggableIcon.getHeight() - MARGIN_VERTICAL;
            }
            updateIconPosition(x, y);
        }
    };
    registerReceiver(mBroadcastReceiver, filter);
}
#end_block

#method_before
@Override
public boolean onTouch(View v, MotionEvent event) {
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mPrevDragX = mOrigX = event.getRawX();
            mPrevDragY = mOrigY = event.getRawY();
            mDragged = false;
            mDeltaXArray = new LinkedList<Float>();
            mDeltaYArray = new LinkedList<Float>();
            mCurrentX = mParams.x;
            mCurrentY = mParams.y;
            mDraggableIconImage.setScaleX(0.92f);
            mDraggableIconImage.setScaleY(0.92f);
            // Cancel any currently running animations
            if (mAnimationTask != null) {
                mAnimationTask.cancel();
            }
            break;
        case MotionEvent.ACTION_UP:
            mIsAnimationLocked = false;
            if (mAnimationTask != null)
                mAnimationTask.cancel();
            if (!mDragged) {
                if (!mIsCalcOpen) {
                    openCalculator();
                } else {
                    closeCalculator();
                }
            } else {
                // Animate the icon
                mAnimationTask = new AnimationTask();
                mAnimationTask.run();
            }
            if (mIsInDeleteMode) {
                close(true);
            } else {
                hideDeleteBox();
                mDraggableIconImage.setScaleX(1f);
                mDraggableIconImage.setScaleY(1f);
            }
            break;
        case MotionEvent.ACTION_MOVE:
            mCurrentX = (int) (event.getRawX() - mDraggableIcon.getWidth() / 2);
            mCurrentY = (int) (event.getRawY() - mDraggableIcon.getHeight());
            if (isDeleteMode(mCurrentX, mCurrentY)) {
                if (!mIsInDeleteMode)
                    animateToDeleteBoxCenter(new OnAnimationFinishedListener() {

                        @Override
                        public void onAnimationFinished() {
                            mDontVibrate = true;
                        }
                    });
            } else if (isDeleteMode() && !mIsAnimationLocked) {
                mDontVibrate = false;
                mIsInDeleteMode = false;
                if (mAnimationTask != null)
                    mAnimationTask.cancel();
                mAnimationTask = new AnimationTask(mCurrentX, mCurrentY);
                mAnimationTask.setDuration(50);
                mAnimationTask.setInterpolator(new LinearInterpolator());
                mAnimationTask.setAnimationFinishedListener(new OnAnimationFinishedListener() {

                    @Override
                    public void onAnimationFinished() {
                        mIsAnimationLocked = false;
                    }
                });
                mAnimationTask.run();
                mIsAnimationLocked = true;
                mDeleteIcon.animate().scaleX(1f).scaleY(1f).setDuration(100);
            } else {
                if (mIsInDeleteMode) {
                    mDeleteIcon.animate().scaleX(1f).scaleY(1f).setDuration(100);
                    mIsInDeleteMode = false;
                }
                if (!mIsAnimationLocked && mDragged) {
                    if (mAnimationTask != null)
                        mAnimationTask.cancel();
                    updateIconPosition(mCurrentX, mCurrentY);
                }
            }
            float deltaX = event.getRawX() - mPrevDragX;
            float deltaY = event.getRawY() - mPrevDragY;
            mDeltaXArray.add(deltaX);
            mDeltaYArray.add(deltaY);
            mPrevDragX = event.getRawX();
            mPrevDragY = event.getRawY();
            deltaX = event.getRawX() - mOrigX;
            deltaY = event.getRawY() - mOrigY;
            mDragged = mDragged || Math.abs(deltaX) > DRAG_DELTA || Math.abs(deltaY) > DRAG_DELTA;
            if (mDragged) {
                closeCalculator(false);
                showDeleteBox();
            }
            break;
    }
    return true;
}
#method_after
@Override
public boolean onTouch(View v, MotionEvent event) {
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mPrevDragX = mOrigX = event.getRawX();
            mPrevDragY = mOrigY = event.getRawY();
            mDragged = false;
            mDeltaXArray = new LinkedList<Float>();
            mDeltaYArray = new LinkedList<Float>();
            mCurrentX = mParams.x;
            mCurrentY = mParams.y;
            mDraggableIconImage.setScaleX(0.92f);
            mDraggableIconImage.setScaleY(0.92f);
            // Cancel any currently running animations
            if (mAnimationTask != null) {
                mAnimationTask.cancel();
            }
            break;
        case MotionEvent.ACTION_UP:
            mIsAnimationLocked = false;
            if (mAnimationTask != null) {
                mAnimationTask.cancel();
            }
            if (!mDragged) {
                if (!mIsCalcOpen) {
                    openCalculator();
                } else {
                    closeCalculator();
                }
            } else {
                // Animate the icon
                mAnimationTask = new AnimationTask();
                mAnimationTask.run();
            }
            if (mIsInDeleteMode) {
                close(true);
            } else {
                hideDeleteBox();
                mDraggableIconImage.setScaleX(1f);
                mDraggableIconImage.setScaleY(1f);
            }
            break;
        case MotionEvent.ACTION_MOVE:
            mCurrentX = (int) (event.getRawX() - mDraggableIcon.getWidth() / 2);
            mCurrentY = (int) (event.getRawY() - mDraggableIcon.getHeight());
            if (isDeleteMode(mCurrentX, mCurrentY)) {
                if (!mIsInDeleteMode)
                    animateToDeleteBoxCenter(new OnAnimationFinishedListener() {

                        @Override
                        public void onAnimationFinished() {
                            mDontVibrate = true;
                        }
                    });
            } else if (isDeleteMode() && !mIsAnimationLocked) {
                mDontVibrate = false;
                mIsInDeleteMode = false;
                if (mAnimationTask != null) {
                    mAnimationTask.cancel();
                }
                mAnimationTask = new AnimationTask(mCurrentX, mCurrentY);
                mAnimationTask.setDuration(50);
                mAnimationTask.setInterpolator(new LinearInterpolator());
                mAnimationTask.setAnimationFinishedListener(new OnAnimationFinishedListener() {

                    @Override
                    public void onAnimationFinished() {
                        mIsAnimationLocked = false;
                    }
                });
                mAnimationTask.run();
                mIsAnimationLocked = true;
                mDeleteIcon.animate().scaleX(1f).scaleY(1f).setDuration(100);
            } else {
                if (mIsInDeleteMode) {
                    mDeleteIcon.animate().scaleX(1f).scaleY(1f).setDuration(100);
                    mIsInDeleteMode = false;
                }
                if (!mIsAnimationLocked && mDragged) {
                    if (mAnimationTask != null) {
                        mAnimationTask.cancel();
                    }
                    updateIconPosition(mCurrentX, mCurrentY);
                }
            }
            float deltaX = event.getRawX() - mPrevDragX;
            float deltaY = event.getRawY() - mPrevDragY;
            mDeltaXArray.add(deltaX);
            mDeltaYArray.add(deltaY);
            mPrevDragX = event.getRawX();
            mPrevDragY = event.getRawY();
            deltaX = event.getRawX() - mOrigX;
            deltaY = event.getRawY() - mOrigY;
            mDragged = mDragged || Math.abs(deltaX) > DRAG_DELTA || Math.abs(deltaY) > DRAG_DELTA;
            if (mDragged) {
                closeCalculator(false);
                showDeleteBox();
            }
            break;
    }
    return true;
}
#end_block

#method_before
public void openCalculator() {
    if (!mIsCalcOpen) {
        if (mIsAnimationLocked)
            return;
        mIsCalcOpen = true;
        mPrevX = mCurrentPosX;
        mPrevY = mCurrentPosY;
        mAnimationTask = new AnimationTask(getOpenX(), getOpenY());
        mAnimationTask.setAnimationFinishedListener(new OnAnimationFinishedListener() {

            @Override
            public void onAnimationFinished() {
                showCalculator();
            }
        });
        mAnimationTask.run();
        Intent intent = new Intent(getContext(), FloatingCalculatorActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivity(intent);
    }
}
#method_after
public void openCalculator() {
    if (!mIsCalcOpen) {
        if (mIsAnimationLocked) {
            return;
        }
        mIsCalcOpen = true;
        mPrevX = mCurrentPosX;
        mPrevY = mCurrentPosY;
        mAnimationTask = new AnimationTask(getOpenX(), getOpenY());
        mAnimationTask.setAnimationFinishedListener(new OnAnimationFinishedListener() {

            @Override
            public void onAnimationFinished() {
                showCalculator();
            }
        });
        mAnimationTask.run();
        Intent intent = new Intent(getContext(), FloatingCalculatorActivity.class);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivity(intent);
    }
}
#end_block

#method_before
public void closeCalculator(boolean returnToOrigin) {
    if (mIsCalcOpen) {
        mIsCalcOpen = false;
        if (returnToOrigin) {
            if (mIsAnimationLocked)
                return;
            mAnimationTask = new AnimationTask(mPrevX, mPrevY);
            mAnimationTask.run();
        }
        if (FloatingCalculatorActivity.ACTIVE_ACTIVITY != null)
            FloatingCalculatorActivity.ACTIVE_ACTIVITY.finish();
        hideCalculator();
    }
}
#method_after
public void closeCalculator(boolean returnToOrigin) {
    if (mIsCalcOpen) {
        mIsCalcOpen = false;
        if (returnToOrigin) {
            if (mIsAnimationLocked) {
                return;
            }
            mAnimationTask = new AnimationTask(mPrevX, mPrevY);
            mAnimationTask.run();
        }
        if (FloatingCalculatorActivity.ACTIVE_ACTIVITY != null) {
            FloatingCalculatorActivity.ACTIVE_ACTIVITY.finish();
        }
        hideCalculator();
    }
}
#end_block

#method_before
public void showCalculator() {
    if (mCalcView == null) {
        View child = View.inflate(getContext(), R.layout.floating_calculator, null);
        mCalcView = new FloatingView(getContext());
        mCalcView.addView(child);
        mCalcParams = addView(mCalcView, 0, 0);
        mPager = (CalculatorViewPager) mCalcView.findViewById(R.id.panelswitch);
        mPersist = new Persist(this);
        mPersist.load();
        mHistory = mPersist.mHistory;
        mDisplay = (CalculatorDisplay) mCalcView.findViewById(R.id.display);
        mDisplay.setEditTextLayout(R.layout.view_calculator_edit_text_floating);
        mDisplay.setOnLongClickListener(new View.OnLongClickListener() {

            @Override
            public boolean onLongClick(View v) {
                copyContent(mDisplay.getText());
                return true;
            }
        });
        mLogic = new Logic(this, mDisplay);
        mLogic.setHistory(mHistory);
        mLogic.setDeleteMode(mPersist.getDeleteMode());
        mLogic.setLineLength(mDisplay.getMaxDigits());
        mLogic.resumeWithHistory();
        mListener = new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                if (v instanceof Button) {
                    if (((Button) v).getText().toString().equals("=")) {
                        mLogic.onEnter();
                    } else if (v.getId() == R.id.parentheses) {
                        if (mLogic.isError())
                            mLogic.setText("");
                        mLogic.setText("(" + mLogic.getText() + ")");
                    } else if (((Button) v).getText().toString().length() >= 2) {
                        mLogic.insert(((Button) v).getText().toString() + "(");
                    } else {
                        mLogic.insert(((Button) v).getText().toString());
                    }
                } else if (v instanceof ImageButton) {
                    mLogic.onDelete();
                }
            }
        };
        final ImageButton del = (ImageButton) mCalcView.findViewById(R.id.delete);
        del.setOnClickListener(mListener);
        del.setOnLongClickListener(new View.OnLongClickListener() {

            @Override
            public boolean onLongClick(View v) {
                mLogic.onClear();
                return true;
            }
        });
        FloatingCalculatorPageAdapter adapter = new FloatingCalculatorPageAdapter(getContext(), mListener, mHistory, mLogic, mDisplay);
        mPager.setAdapter(adapter);
        mPager.setCurrentItem(1);
    } else {
        mCalcView.setVisibility(View.VISIBLE);
    }
    // Adjust calc location
    int screenWidth = getScreenWidth();
    int calcWidth = 4 * (int) getResources().getDimension(R.dimen.floating_window_button_height);
    mCalcParams.x = screenWidth - calcWidth - MARGIN_CALCULATOR;
    mCalcParams.y = (int) (STARTING_POINT_Y * 1.1) + mDraggableIcon.getHeight();
    if (!mIsDestroyed)
        mWindowManager.updateViewLayout(mCalcView, mCalcParams);
    // Animate calc in
    View child = mCalcView.getChildAt(0);
    child.setAlpha(0);
    child.animate().setDuration(150).alpha(1).setListener(null);
}
#method_after
public void showCalculator() {
    if (mCalcView == null) {
        View child = View.inflate(getContext(), R.layout.floating_calculator, null);
        mCalcView = new FloatingView(getContext());
        mCalcView.addView(child);
        mCalcParams = addView(mCalcView, 0, 0);
        mPager = (CalculatorViewPager) mCalcView.findViewById(R.id.panelswitch);
        mPersist = new Persist(this);
        mPersist.load();
        mHistory = mPersist.mHistory;
        mDisplay = (CalculatorDisplay) mCalcView.findViewById(R.id.display);
        mDisplay.setEditTextLayout(R.layout.view_calculator_edit_text_floating);
        mDisplay.setOnLongClickListener(new View.OnLongClickListener() {

            @Override
            public boolean onLongClick(View v) {
                copyContent(mDisplay.getText());
                return true;
            }
        });
        mLogic = new Logic(this, mDisplay);
        mLogic.setHistory(mHistory);
        mLogic.setDeleteMode(mPersist.getDeleteMode());
        mLogic.setLineLength(mDisplay.getMaxDigits());
        mLogic.resumeWithHistory();
        mListener = new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                if (v instanceof Button) {
                    if (((Button) v).getText().toString().equals("=")) {
                        mLogic.onEnter();
                    } else if (v.getId() == R.id.parentheses) {
                        if (mLogic.isError()) {
                            mLogic.setText("");
                        }
                        mLogic.setText("(" + mLogic.getText() + ")");
                    } else if (((Button) v).getText().toString().length() >= 2) {
                        mLogic.insert(((Button) v).getText().toString() + "(");
                    } else {
                        mLogic.insert(((Button) v).getText().toString());
                    }
                } else if (v instanceof ImageButton) {
                    mLogic.onDelete();
                }
            }
        };
        final ImageButton del = (ImageButton) mCalcView.findViewById(R.id.delete);
        del.setOnClickListener(mListener);
        del.setOnLongClickListener(new View.OnLongClickListener() {

            @Override
            public boolean onLongClick(View v) {
                mLogic.onClear();
                return true;
            }
        });
        FloatingCalculatorPageAdapter adapter = new FloatingCalculatorPageAdapter(getContext(), mListener, mHistory, mLogic, mDisplay);
        mPager.setAdapter(adapter);
        mPager.setCurrentItem(1);
    } else {
        mCalcView.setVisibility(View.VISIBLE);
    }
    // Adjust calc location
    int screenWidth = getScreenWidth();
    int calcWidth = 4 * (int) getResources().getDimension(R.dimen.floating_window_button_height);
    mCalcParams.x = screenWidth - calcWidth - MARGIN_CALCULATOR;
    mCalcParams.y = (int) (STARTING_POINT_Y * 1.1) + mDraggableIcon.getHeight();
    if (!mIsDestroyed) {
        mWindowManager.updateViewLayout(mCalcView, mCalcParams);
    }
    // Animate calc in
    View child = mCalcView.getChildAt(0);
    child.setAlpha(0);
    child.animate().setDuration(150).alpha(1).setListener(null);
}
#end_block

#method_before
private float calculateVelocityX() {
    int depreciation = mDeltaXArray.size() + 1;
    float sum = 0;
    for (Float f : mDeltaXArray) {
        depreciation--;
        if (depreciation > 5)
            continue;
        sum += f / depreciation;
    }
    return sum;
}
#method_after
private float calculateVelocityX() {
    int depreciation = mDeltaXArray.size() + 1;
    float sum = 0;
    for (Float f : mDeltaXArray) {
        depreciation--;
        if (depreciation > 5) {
            continue;
        }
        sum += f / depreciation;
    }
    return sum;
}
#end_block

#method_before
private float calculateVelocityY() {
    int depreciation = mDeltaYArray.size() + 1;
    float sum = 0;
    for (Float f : mDeltaYArray) {
        depreciation--;
        if (depreciation > 5)
            continue;
        sum += f / depreciation;
    }
    return sum;
}
#method_after
private float calculateVelocityY() {
    int depreciation = mDeltaYArray.size() + 1;
    float sum = 0;
    for (Float f : mDeltaYArray) {
        depreciation--;
        if (depreciation > 5) {
            continue;
        }
        sum += f / depreciation;
    }
    return sum;
}
#end_block

#method_before
private void setup(int x, int y) {
    if (mIsAnimationLocked)
        throw new RuntimeException("Returning to user's finger. Avoid animations while mIsAnimationLocked flag is set.");
    mDestX = x;
    mDestY = y;
    mSteps = (int) (((float) mDuration) / 1000 * ANIMATION_FRAME_RATE);
    mCurrentStep = 1;
    mDistX = mParams.x - mDestX;
    mOrigX = mParams.x;
    mDistY = mParams.y - mDestY;
    mOrigY = mParams.y;
}
#method_after
private void setup(int x, int y) {
    if (mIsAnimationLocked) {
        throw new RuntimeException("Returning to user's finger. Avoid animations while mIsAnimationLocked flag is set.");
    }
    mDestX = x;
    mDestY = y;
    mSteps = (int) (((float) mDuration) / 1000 * ANIMATION_FRAME_RATE);
    mCurrentStep = 1;
    mDistX = mParams.x - mDestX;
    mOrigX = mParams.x;
    mDistY = mParams.y - mDestY;
    mOrigY = mParams.y;
}
#end_block

#method_before
public long getRemainingDuration() {
    long elapsedTime = System.currentTimeMillis() - mStartTime;
    long remainingDuration = mDuration - elapsedTime;
    if (remainingDuration < 0)
        remainingDuration = 0;
    return remainingDuration;
}
#method_after
public long getRemainingDuration() {
    long elapsedTime = System.currentTimeMillis() - mStartTime;
    long remainingDuration = mDuration - elapsedTime;
    if (remainingDuration < 0) {
        remainingDuration = 0;
    }
    return remainingDuration;
}
#end_block

#method_before
private int calculateY() {
    float velocityY = calculateVelocityY();
    mInterpolator = new OvershootInterpolator(mTension);
    int screenHeight = getScreenHeight();
    int destY = mParams.y + (int) (velocityY * 3);
    if (destY <= 0)
        destY = MARGIN_VERTICAL;
    if (destY >= screenHeight - mDraggableIcon.getHeight())
        destY = screenHeight - mDraggableIcon.getHeight() - MARGIN_VERTICAL;
    return destY;
}
#method_after
private int calculateY() {
    float velocityY = calculateVelocityY();
    mInterpolator = new OvershootInterpolator(mTension);
    int screenHeight = getScreenHeight();
    int destY = mParams.y + (int) (velocityY * 3);
    if (destY <= 0) {
        destY = MARGIN_VERTICAL;
    }
    if (destY >= screenHeight - mDraggableIcon.getHeight()) {
        destY = screenHeight - mDraggableIcon.getHeight() - MARGIN_VERTICAL;
    }
    return destY;
}
#end_block

#method_before
public void updateAdapter(List<T> data) {
    // Cache can be null
    if (data == null)
        return;
    List<T> adapterList = getList();
    adapterList.clear();
    for (T t : data) {
        adapterList.add(t);
    }
    notifyDataSetChanged();
}
#method_after
public void updateAdapter(List<T> data) {
    // Cache can be null
    if (data == null) {
        return;
    }
    List<T> adapterList = getList();
    adapterList.clear();
    for (T t : data) {
        adapterList.add(t);
    }
    notifyDataSetChanged();
}
#end_block

#method_before
public void updateDropdownView(View convertView, T object) {
}
#method_after
public void updateDropdownView(View convertView, T object) {
// Do nothing here
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    int customTheme = Theme.getSettingsTheme(this);
    if (customTheme != 0) {
        super.setTheme(customTheme);
    }
    if (savedInstanceState == null) {
        mFragment = new PreferencesFragment();
        mFragment.setArguments(getIntent().getExtras());
        getFragmentManager().beginTransaction().add(android.R.id.content, mFragment).commit();
    }
    ActionBar mActionBar = getActionBar();
    if (mActionBar != null) {
        mActionBar.setDisplayHomeAsUpEnabled(true);
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    int customTheme = Theme.getSettingsTheme(this);
    if (customTheme != 0) {
        super.setTheme(customTheme);
    }
    setContentView(R.layout.activity_preferences);
    if (savedInstanceState == null) {
        mFragment = new PreferencesFragment();
        mFragment.setArguments(getIntent().getExtras());
        getFragmentManager().beginTransaction().add(R.id.content_view, mFragment).commit();
    }
    ActionBar mActionBar = getActionBar();
    if (mActionBar != null) {
        mActionBar.setDisplayHomeAsUpEnabled(true);
    }
}
#end_block

#method_before
@Override
public boolean onKeyDown(int keyCode, KeyEvent keyEvent) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getFragmentManager().findFragmentById(android.R.id.content) != mFragment) {
            try {
                getFragmentManager().popBackStack();
                return true;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        startActivity(new Intent(this, Calculator.class));
        finish();
        return true;
    }
    return super.onKeyDown(keyCode, keyEvent);
}
#method_after
@Override
public boolean onKeyDown(int keyCode, KeyEvent keyEvent) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getFragmentManager().findFragmentById(R.id.content_view) != mFragment) {
            try {
                getFragmentManager().popBackStack();
                return true;
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        startActivity(new Intent(this, Calculator.class));
        finish();
        return true;
    }
    return super.onKeyDown(keyCode, keyEvent);
}
#end_block

#method_before
@Override
public void removeView(View view) {
    int index = getChildIndex(view);
    if (index == -1)
        return;
    super.removeViewAt(index);
    // Combine the 2 EditTexts on either side
    CalculatorEditText leftSide = (CalculatorEditText) getChildAt(index - 1);
    CalculatorEditText rightSide = (CalculatorEditText) getChildAt(index);
    int cursor = leftSide.getText().length();
    leftSide.setText(leftSide.getText().toString() + rightSide.getText().toString());
    // Remove the second EditText
    super.removeViewAt(index);
    leftSide.requestFocus();
    leftSide.setSelection(cursor);
}
#method_after
@Override
public void removeView(View view) {
    int index = getChildIndex(view);
    if (index == -1) {
        return;
    }
    super.removeViewAt(index);
    // Combine the 2 EditTexts on either side
    CalculatorEditText leftSide = (CalculatorEditText) getChildAt(index - 1);
    CalculatorEditText rightSide = (CalculatorEditText) getChildAt(index);
    int cursor = leftSide.getText().length();
    leftSide.setText(leftSide.getText().toString() + rightSide.getText().toString());
    // Remove the second EditText
    super.removeViewAt(index);
    leftSide.requestFocus();
    leftSide.setSelection(cursor);
}
#end_block

#method_before
public int getChildIndex(View view) {
    for (int i = 0; i < getChildCount(); i++) {
        if (getChildAt(i) == view)
            return i;
    }
    return -1;
}
#method_after
public int getChildIndex(View view) {
    for (int i = 0; i < getChildCount(); i++) {
        if (getChildAt(i) == view) {
            return i;
        }
    }
    return -1;
}
#end_block

#method_before
public void setText(String text) {
    clear();
    CalculatorEditText.load(this);
    getLastView().requestFocus();
    final MutableString ms = new MutableString(text);
    while (!ms.isEmpty()) {
        if (MatrixView.load(ms, this))
            continue;
        if (MatrixTransposeView.load(ms, this))
            continue;
        if (MatrixInverseView.load(ms, this))
            continue;
        // Append the next character to the trailing EditText
        ((CalculatorEditText) getLastView()).setText(((CalculatorEditText) getLastView()).getText() + ms.substring(0, 1));
        ((CalculatorEditText) getLastView()).setSelection(((CalculatorEditText) getLastView()).length());
        ms.setText(ms.substring(1, ms.length()));
    }
    getLastView().requestFocus();
}
#method_after
public void setText(String text) {
    clear();
    CalculatorEditText.load(this);
    getLastView().requestFocus();
    final MutableString ms = new MutableString(text);
    while (!ms.isEmpty()) {
        if (MatrixView.load(ms, this) || MatrixTransposeView.load(ms, this) || MatrixInverseView.load(ms, this)) {
            continue;
        }
        // Append the next character to the trailing EditText
        ((CalculatorEditText) getLastView()).setText(((CalculatorEditText) getLastView()).getText() + ms.substring(0, 1));
        ((CalculatorEditText) getLastView()).setSelection(((CalculatorEditText) getLastView()).length());
        ms.setText(ms.substring(1, ms.length()));
    }
    getLastView().requestFocus();
}
#end_block

#method_before
View nextView(View currentView) {
    boolean foundCurrentView = false;
    for (int i = 0; i < getChildCount(); i++) {
        if (foundCurrentView)
            return getChildAt(i);
        else if (currentView == getChildAt(i))
            foundCurrentView = true;
    }
    return getChildAt(0);
}
#method_after
View nextView(View currentView) {
    boolean foundCurrentView = false;
    for (int i = 0; i < getChildCount(); i++) {
        if (foundCurrentView) {
            return getChildAt(i);
        } else if (currentView == getChildAt(i)) {
            foundCurrentView = true;
        }
    }
    return getChildAt(0);
}
#end_block

#method_before
View previousView(View currentView) {
    boolean foundCurrentView = false;
    for (int i = getChildCount() - 1; i >= 0; i--) {
        if (foundCurrentView)
            return getChildAt(i);
        else if (currentView == getChildAt(i))
            foundCurrentView = true;
    }
    return getChildAt(getChildCount() - 1);
}
#method_after
View previousView(View currentView) {
    boolean foundCurrentView = false;
    for (int i = getChildCount() - 1; i >= 0; i--) {
        if (foundCurrentView) {
            return getChildAt(i);
        } else if (currentView == getChildAt(i)) {
            foundCurrentView = true;
        }
    }
    return getChildAt(getChildCount() - 1);
}
#end_block

#method_before
public void insert(String delta) {
    if (mActiveEditText == null) {
        // don't allow leading operators
        if (Logic.isOperator(delta) && !delta.equals(String.valueOf(Logic.MINUS))) {
            return;
        }
        setText(delta);
    } else {
        if (CalculatorEditText.class.isInstance(getActiveEditText())) {
            // Logic to insert, split text if there's another view, etc
            final MutableString text = new MutableString(delta);
            while (!text.isEmpty()) {
                int cursor = getActiveEditText().getSelectionStart();
                final int index = getChildIndex(getActiveEditText());
                if (MatrixView.load(text, this, index + 1))
                    splitText(cursor, index, text);
                else if (MatrixTransposeView.load(text, this, index + 1)) {
                    splitText(cursor, index, text);
                    getChildAt(index + 2).requestFocus();
                    ((CalculatorEditText) getChildAt(index + 2)).setSelection(0);
                } else if (MatrixInverseView.load(text, this, index + 1)) {
                    splitText(cursor, index, text);
                    getChildAt(index + 2).requestFocus();
                    ((CalculatorEditText) getChildAt(index + 2)).setSelection(0);
                } else {
                    // don't allow leading operators
                    if (cursor == 0 && getActiveEditText() == getChildAt(0) && Logic.isOperator(delta) && !delta.equals(String.valueOf(Logic.MINUS))) {
                        return;
                    }
                    getActiveEditText().getText().insert(cursor, text.subSequence(0, 1));
                    text.setText(text.substring(1, text.length()));
                }
            }
        } else {
            int cursor = getActiveEditText().getSelectionStart();
            getActiveEditText().getText().insert(cursor, delta);
        }
    }
}
#method_after
public void insert(String delta) {
    if (mActiveEditText == null) {
        // Don't allow leading operators
        if (Logic.isOperator(delta) && !delta.equals(String.valueOf(Logic.MINUS))) {
            return;
        }
        setText(delta);
    } else {
        if (CalculatorEditText.class.isInstance(getActiveEditText())) {
            // Logic to insert, split text if there's another view, etc.
            final MutableString text = new MutableString(delta);
            while (!text.isEmpty()) {
                int cursor = getActiveEditText().getSelectionStart();
                final int index = getChildIndex(getActiveEditText());
                if (MatrixView.load(text, this, index + 1)) {
                    splitText(cursor, index, text);
                } else if (MatrixTransposeView.load(text, this, index + 1)) {
                    splitText(cursor, index, text);
                    getChildAt(index + 2).requestFocus();
                    ((CalculatorEditText) getChildAt(index + 2)).setSelection(0);
                } else if (MatrixInverseView.load(text, this, index + 1)) {
                    splitText(cursor, index, text);
                    getChildAt(index + 2).requestFocus();
                    ((CalculatorEditText) getChildAt(index + 2)).setSelection(0);
                } else {
                    // Don't allow leading operators
                    if (cursor == 0 && getActiveEditText() == getChildAt(0) && Logic.isOperator(delta) && !delta.equals(String.valueOf(Logic.MINUS))) {
                        return;
                    }
                    getActiveEditText().getText().insert(cursor, text.subSequence(0, 1));
                    text.setText(text.substring(1, text.length()));
                }
            }
        } else {
            int cursor = getActiveEditText().getSelectionStart();
            getActiveEditText().getText().insert(cursor, delta);
        }
    }
}
#end_block

#method_before
public View getLastView() {
    if (getChildCount() == 0)
        return null;
    return getChildAt(getChildCount() - 1);
}
#method_after
public View getLastView() {
    if (getChildCount() == 0) {
        return null;
    }
    return getChildAt(getChildCount() - 1);
}
#end_block

#method_before
@Override
protected void onPause() {
    super.onPause();
    if (FloatingCalculator.ACTIVE_CALCULATOR != null)
        FloatingCalculator.ACTIVE_CALCULATOR.closeCalculator();
    ACTIVE_ACTIVITY = null;
}
#method_after
@Override
protected void onPause() {
    super.onPause();
    if (FloatingCalculator.ACTIVE_CALCULATOR != null) {
        FloatingCalculator.ACTIVE_CALCULATOR.closeCalculator();
    }
    ACTIVE_ACTIVITY = null;
}
#end_block

#method_before
@Override
public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
}
#method_after
@Override
public void onUpgrade(SQLiteDatabase database, int oldVersion, int newVersion) {
// Do nothing here
}
#end_block

#method_before
private void setup() {
    mBackgroundPaint = new Paint();
    mBackgroundPaint.setColor(Color.WHITE);
    mBackgroundPaint.setStyle(Style.FILL);
    mTextPaint = new Paint();
    mTextPaint.setColor(Color.BLACK);
    mTextPaint.setTextSize(48);
    mAxisPaint = new Paint();
    mAxisPaint.setColor(Color.DKGRAY);
    mAxisPaint.setStyle(Style.STROKE);
    mAxisPaint.setStrokeWidth(2);
    mGraphPaint = new Paint();
    mGraphPaint.setColor(Color.CYAN);
    mGraphPaint.setStyle(Style.STROKE);
    mGraphPaint.setStrokeWidth(6);
    zoomReset();
    mData = new LinkedList<Point>();
    mData.add(new Point(0, 0));
    mData.add(new Point(1, 1));
    mData.add(new Point(2, 2));
    mData.add(new Point(2, 3));
    mData.add(new Point(3, 0));
    mData.add(new Point(7, 5));
}
#method_after
private void setup() {
    mBackgroundPaint = new Paint();
    mBackgroundPaint.setColor(Color.WHITE);
    mBackgroundPaint.setStyle(Style.FILL);
    mTextPaintSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, 16, getResources().getDisplayMetrics());
    mTextPaint = new Paint();
    mTextPaint.setColor(Color.BLACK);
    mTextPaint.setTextSize(mTextPaintSize);
    mAxisPaint = new Paint();
    mAxisPaint.setColor(Color.DKGRAY);
    mAxisPaint.setStyle(Style.STROKE);
    mAxisPaint.setStrokeWidth(2);
    mGraphPaint = new Paint();
    mGraphPaint.setColor(Color.CYAN);
    mGraphPaint.setStyle(Style.STROKE);
    mGraphPaint.setStrokeWidth(3);
    zoomReset();
    mData = new LinkedList<Point>();
}
#end_block

#method_before
@Override
protected void onSizeChanged(int xNew, int yNew, int xOld, int yOld) {
    super.onSizeChanged(xNew, yNew, xOld, yOld);
    // Center the offsets
    int i = 0;
    while (i * mLineMargin < xOld) {
        i++;
    }
    i--;
    mOffsetX += i / 2;
    i = 0;
    while (i * mLineMargin < yOld) {
        i++;
    }
    i--;
    mOffsetY += i / 2;
    while (i * mLineMargin < xNew) {
        i++;
    }
    i--;
    mOffsetX -= i / 2;
    i = 0;
    while (i * mLineMargin < yNew) {
        i++;
    }
    i--;
    mOffsetY -= i / 2;
}
#method_after
@Override
protected void onSizeChanged(int xNew, int yNew, int xOld, int yOld) {
    super.onSizeChanged(xNew, yNew, xOld, yOld);
    mLineMargin = mMinLineMargin = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 25, getResources().getDisplayMetrics());
    // Center the offsets
    mOffsetX += (xOld / mLineMargin) / 2;
    mOffsetY += (yOld / mLineMargin) / 2;
    mOffsetX -= (xNew / mLineMargin) / 2;
    mOffsetY -= (yNew / mLineMargin) / 2;
}
#end_block

#method_before
@Override
public void draw(Canvas canvas) {
    super.draw(canvas);
    canvas.drawPaint(mBackgroundPaint);
    // Draw the grid lines
    Rect bounds = new Rect();
    int previousLine = 0;
    for (int i = 1, j = mOffsetX; i * mLineMargin < getWidth(); i++, j++) {
        // Draw vertical lines
        int x = i * mLineMargin + mDragRemainderX;
        if (x < mLineMargin || x - previousLine < mMinLineMargin)
            continue;
        previousLine = x;
        if (j == 0)
            mAxisPaint.setStrokeWidth(6);
        else
            mAxisPaint.setStrokeWidth(2);
        canvas.drawLine(x, mLineMargin, x, getHeight(), mAxisPaint);
        // Draw label on left
        String text = mFormat.format(j * mZoomLevel);
        mTextPaint.getTextBounds(text, 0, text.length(), bounds);
        int textWidth = bounds.right - bounds.left;
        canvas.drawText(text, x - textWidth / 2, mLineMargin / 2 + mTextPaint.getTextSize() / 2, mTextPaint);
    }
    previousLine = 0;
    for (int i = 1, j = mOffsetY; i * mLineMargin < getHeight(); i++, j++) {
        // Draw horizontal lines
        int y = i * mLineMargin + mDragRemainderY;
        if (y < mLineMargin || y - previousLine < mMinLineMargin)
            continue;
        previousLine = y;
        if (j == 0)
            mAxisPaint.setStrokeWidth(6);
        else
            mAxisPaint.setStrokeWidth(2);
        canvas.drawLine(mLineMargin, y, getWidth(), y, mAxisPaint);
        // Draw label on left
        String text = mFormat.format(-j * mZoomLevel);
        mTextPaint.getTextBounds(text, 0, text.length(), bounds);
        int textHeight = bounds.bottom - bounds.top;
        int textWidth = bounds.right - bounds.left;
        canvas.drawText(text, mLineMargin / 2 - textWidth / 2, y + textHeight / 2, mTextPaint);
    }
    LinkedList<Point> data = new LinkedList<Point>(mData);
    Point prev = data.remove();
    for (Point p : data) {
        int prevX = getRawX(prev);
        int prevY = getRawY(prev);
        int pX = getRawX(p);
        int pY = getRawY(p);
        prev = p;
        if (prevX == -1 || prevY == -1 || pX == -1 || pY == -1)
            continue;
        canvas.drawLine(prevX, prevY, pX, pY, mGraphPaint);
    }
}
#method_after
@Override
public void draw(Canvas canvas) {
    super.draw(canvas);
    canvas.drawPaint(mBackgroundPaint);
    // Draw the grid lines
    Rect bounds = new Rect();
    int previousLine = 0;
    for (int i = 1, j = mOffsetX; i * mLineMargin < getWidth(); i++, j++) {
        // Draw vertical lines
        int x = i * mLineMargin + mDragRemainderX;
        if (x < mLineMargin || x - previousLine < mMinLineMargin) {
            continue;
        }
        previousLine = x;
        if (j == 0) {
            mAxisPaint.setStrokeWidth(6);
        } else {
            mAxisPaint.setStrokeWidth(2);
        }
        canvas.drawLine(x, mLineMargin, x, getHeight(), mAxisPaint);
        // Draw label on left
        String text = mFormat.format(j * mZoomLevel);
        int textLength = ((text.startsWith("-") ? text.length() - 1 : text.length()) + 1) / 2;
        mTextPaint.setTextSize(mTextPaintSize / textLength);
        mTextPaint.getTextBounds(text, 0, text.length(), bounds);
        int textWidth = bounds.right - bounds.left;
        canvas.drawText(text, x - textWidth / 2, mLineMargin / 2 + mTextPaint.getTextSize() / 2, mTextPaint);
    }
    previousLine = 0;
    for (int i = 1, j = mOffsetY; i * mLineMargin < getHeight(); i++, j++) {
        // Draw horizontal lines
        int y = i * mLineMargin + mDragRemainderY;
        if (y < mLineMargin || y - previousLine < mMinLineMargin) {
            continue;
        }
        previousLine = y;
        if (j == 0) {
            mAxisPaint.setStrokeWidth(6);
        } else {
            mAxisPaint.setStrokeWidth(2);
        }
        canvas.drawLine(mLineMargin, y, getWidth(), y, mAxisPaint);
        // Draw label on left
        String text = mFormat.format(-j * mZoomLevel);
        int textLength = ((text.startsWith("-") ? text.length() - 1 : text.length()) + 1) / 2;
        mTextPaint.setTextSize(mTextPaintSize / textLength);
        mTextPaint.getTextBounds(text, 0, text.length(), bounds);
        int textHeight = bounds.bottom - bounds.top;
        int textWidth = bounds.right - bounds.left;
        canvas.drawText(text, mLineMargin / 2 - textWidth / 2, y + textHeight / 2, mTextPaint);
    }
    // Restrict drawing the graph to the grid
    canvas.clipRect(mLineMargin, mLineMargin, getWidth(), getHeight());
    // Create a path to draw smooth arcs
    LinkedList<Point> data = new LinkedList<Point>(mData);
    if (data.size() != 0) {
        drawWithStraightLines(data, canvas);
    }
}
#end_block

#method_before
private int getRawX(Point p) {
    for (int i = 1, j = mOffsetX; i * mLineMargin < getWidth(); i++, j++) {
        if (p.getX() >= j * mZoomLevel && p.getX() < j * mZoomLevel + 1 * mZoomLevel) {
            // Point is close
            int decimal = (int) (mLineMargin * (p.getX() - j * mZoomLevel));
            int pos = i * mLineMargin + mDragRemainderX + decimal;
            if (pos < mLineMargin)
                return -1;
            else
                return pos;
        }
    }
    return -1;
}
#method_after
private int getRawX(Point p) {
    if (p == null || Double.isNaN(p.getX()) || Double.isInfinite(p.getX())) {
        return -1;
    }
    // The left line is at pos
    float leftLine = mLineMargin + mDragRemainderX;
    // And equals
    float val = mOffsetX * mZoomLevel;
    // And changes at a rate of
    float slope = mLineMargin / mZoomLevel;
    // Put it all together
    int pos = (int) (slope * (p.getX() - val) + leftLine);
    return pos;
}
#end_block

#method_before
private int getRawY(Point p) {
    for (int i = 1, j = -mOffsetY; i * mLineMargin < getHeight(); i++, j--) {
        if (p.getY() >= j * mZoomLevel && p.getY() < j * mZoomLevel + 1 * mZoomLevel) {
            // Point is close
            int decimal = (int) (mLineMargin * (p.getY() - j * mZoomLevel));
            int pos = i * mLineMargin + mDragRemainderY + decimal;
            if (pos < mLineMargin)
                return -1;
            else
                return pos;
        }
    }
    return -1;
}
#method_after
private int getRawY(Point p) {
    if (p == null || Double.isNaN(p.getY()) || Double.isInfinite(p.getY())) {
        return -1;
    }
    // The top line is at pos
    float topLine = mLineMargin + mDragRemainderY;
    // And equals
    float val = -mOffsetY * mZoomLevel;
    // And changes at a rate of
    float slope = mLineMargin / mZoomLevel;
    // Put it all together
    int pos = (int) (-slope * (p.getY() - val) + topLine);
    return pos;
}
#end_block

#method_before
@Override
public boolean onTouchEvent(MotionEvent event) {
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mStartX = event.getX();
            mStartY = event.getY();
            mDragOffsetX = 0;
            mDragOffsetY = 0;
            break;
        case MotionEvent.ACTION_UP:
            break;
        case MotionEvent.ACTION_MOVE:
            mOffsetX += mDragOffsetX;
            mOffsetY += mDragOffsetY;
            mDragOffsetX = (int) (event.getX() - mStartX) / mLineMargin;
            mDragOffsetY = (int) (event.getY() - mStartY) / mLineMargin;
            mDragRemainderX = (int) (event.getX() - mStartX) % mLineMargin;
            mDragRemainderY = (int) (event.getY() - mStartY) % mLineMargin;
            mOffsetX -= mDragOffsetX;
            mOffsetY -= mDragOffsetY;
            break;
    }
    invalidate();
    return true;
}
#method_after
@Override
public boolean onTouchEvent(MotionEvent event) {
    // Update mode if pointer count changes
    if (mPointers != event.getPointerCount()) {
        setMode(event);
    }
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            setMode(event);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mMode == DRAG) {
                mOffsetX += mDragOffsetX;
                mOffsetY += mDragOffsetY;
                mDragOffsetX = (int) (event.getX() - mStartX) / mLineMargin;
                mDragOffsetY = (int) (event.getY() - mStartY) / mLineMargin;
                mDragRemainderX = (int) (event.getX() - mStartX) % mLineMargin;
                mDragRemainderY = (int) (event.getY() - mStartY) % mLineMargin;
                mOffsetX -= mDragOffsetX;
                mOffsetY -= mDragOffsetY;
                if (mPanListener != null) {
                    mPanListener.panApplied();
                }
            } else if (mMode == ZOOM) {
                double distance = getDistance(new Point(event.getX(0), event.getY(0)), new Point(event.getX(1), event.getY(1)));
                double delta = mZoomInitDistance - distance;
                float zoom = (float) (delta / mZoomInitDistance);
                setZoomLevel(mZoomInitLevel + zoom);
            }
            break;
    }
    invalidate();
    return true;
}
#end_block

#method_before
public void zoomIn() {
    mZoomLevel /= 2;
    invalidate();
}
#method_after
public void zoomIn() {
    setZoomLevel(mZoomLevel / 2);
}
#end_block

#method_before
public void zoomOut() {
    mZoomLevel *= 2;
    invalidate();
}
#method_after
public void zoomOut() {
    setZoomLevel(mZoomLevel * 2);
}
#end_block

#method_before
public void zoomReset() {
    mZoomLevel = 1;
    mLineMargin = 70;
    mMinLineMargin = 70;
    int i = 0;
    while (i * mLineMargin < getWidth()) {
        i++;
    }
    i--;
    mOffsetX = -i / 2;
    i = 0;
    while (i * mLineMargin < getHeight()) {
        i++;
    }
    i--;
    mOffsetY = -i / 2;
    invalidate();
}
#method_after
public void zoomReset() {
    setZoomLevel(1);
    mDragRemainderX = mDragRemainderY = mOffsetX = mOffsetY = 0;
    onSizeChanged(getWidth(), getHeight(), 0, 0);
    invalidate();
    if (mPanListener != null) {
        mPanListener.panApplied();
    }
    if (mZoomListener != null) {
        mZoomListener.zoomApplied(mZoomLevel);
    }
}
#end_block

#method_before
public float getX() {
    return mX;
}
#method_after
public float getX() {
    return (float) mX;
}
#end_block

#method_before
public float getY() {
    return mY;
}
#method_after
public float getY() {
    return (float) mY;
}
#end_block

#method_before
public static Drawable flipDrawable(Context context, Drawable original) {
    Bitmap orig = drawableToBitmap(original);
    // Create a matrix to be used to transform the bitmap
    Matrix mirrorMatrix = new Matrix();
    // Set the matrix to mirror the image in the x direction
    mirrorMatrix.preScale(-1.0f, 1.0f);
    // Create a flipped sprite using the transform matrix and the original
    // sprite
    Bitmap fSprite = Bitmap.createBitmap(orig, 0, 0, orig.getWidth(), orig.getHeight(), mirrorMatrix, false);
    return bitmapToDrawable(context, fSprite);
}
#method_after
public static Drawable flipDrawable(Context context, Drawable original) {
    Bitmap orig = drawableToBitmap(original);
    // Create a matrix to be used to transform the bitmap
    Matrix mirrorMatrix = new Matrix();
    // Set the matrix to mirror the image in the x direction
    mirrorMatrix.preScale(-1.0f, 1.0f);
    // Create a flipped sprite using the transform matrix and the original sprite
    Bitmap fSprite = Bitmap.createBitmap(orig, 0, 0, orig.getWidth(), orig.getHeight(), mirrorMatrix, false);
    return bitmapToDrawable(context, fSprite);
}
#end_block

#method_before
@Override
public void remove() {
}
#method_after
@Override
public void remove() {
// Do nothing here
}
#end_block

#method_before
public static boolean load(final MutableString text, final AdvancedDisplay parent, final int pos) {
    if (!text.startsWith(PATTERN))
        return false;
    text.setText(text.substring(PATTERN.length()));
    MatrixInverseView mv = new MatrixInverseView(parent);
    parent.addView(mv, pos);
    return true;
}
#method_after
public static boolean load(final MutableString text, final AdvancedDisplay parent, final int pos) {
    if (!text.startsWith(PATTERN)) {
        return false;
    }
    text.setText(text.substring(PATTERN.length()));
    MatrixInverseView mv = new MatrixInverseView(parent);
    parent.addView(mv, pos);
    return true;
}
#end_block

#method_before
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Update theme (as needed)
    Theme.buildResourceMap(com.android.calculator2.R.class);
    Theme.setPackageName(CalculatorSettings.getTheme(getContext()));
    int customTheme = Theme.getTheme(this);
    if (customTheme != 0) {
        super.setTheme(customTheme);
    }
    setContentView(R.layout.activity_store);
    SectionsPagerAdapter pagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager());
    // Set up the ViewPager with the sections adapter.
    ViewPager viewPager = (ViewPager) findViewById(R.id.pager);
    viewPager.setAdapter(pagerAdapter);
    // Bind the title indicator to the adapter
    TabPageIndicator titleIndicator = (TabPageIndicator) findViewById(R.id.titles);
    titleIndicator.setViewPager(viewPager);
    // Theme the indicator
    ViewGroup tabs = (ViewGroup) titleIndicator.getChildAt(0);
    tabs.getLayoutParams().height = getTabHeight();
    for (int i = 0; i < tabs.getChildCount(); i++) {
        TextView tab = (TextView) tabs.getChildAt(i);
        tab.setTextColor(Theme.getColor(getContext(), R.color.store_tab_text));
        Typeface tf = Theme.getFont(getContext());
        if (tf != null)
            tab.setTypeface(tf);
        setBackground(tab, Theme.get(R.drawable.custom_tab_indicator));
    }
    ActionBar mActionBar = getActionBar();
    if (mActionBar != null) {
        mActionBar.setDisplayHomeAsUpEnabled(true);
    }
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Update theme (as needed)
    Theme.buildResourceMap(com.android.calculator2.R.class);
    Theme.setPackageName(CalculatorSettings.getTheme(getContext()));
    int customTheme = Theme.getSettingsTheme(this);
    if (customTheme != 0) {
        super.setTheme(customTheme);
    }
    setContentView(R.layout.activity_store);
    SectionsPagerAdapter pagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager());
    // Set up the ViewPager with the sections adapter
    ViewPager viewPager = (ViewPager) findViewById(R.id.pager);
    viewPager.setAdapter(pagerAdapter);
    ActionBar mActionBar = getActionBar();
    if (mActionBar != null) {
        mActionBar.setDisplayHomeAsUpEnabled(true);
    }
}
#end_block

#method_before
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (item.getItemId() == android.R.id.home) {
        startActivity(new Intent(this, Calculator.class));
        finish();
        return true;
    }
    return super.onOptionsItemSelected(item);
}
#method_after
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (item.getItemId() == android.R.id.home) {
        startActivity(new Intent(this, Calculator.class));
        finish();
        return true;
    } else if (item.getItemId() == R.id.info) {
        startActivity(new Intent(this, StoreInfoActivity.class));
        return true;
    }
    return super.onOptionsItemSelected(item);
}
#end_block

#method_before
@Override
public Fragment getItem(int position) {
    switch(position) {
        case 0:
            return new ThemesFragment();
        default:
            return null;
    }
}
#method_after
@Override
public Fragment getItem(int position) {
    switch(position) {
        case 0:
            Fragment fragment = new ThemesFragment();
            fragment.setArguments(getIntent().getExtras());
            return fragment;
        default:
            return null;
    }
}
#end_block

#method_before
@Override
public CharSequence getPageTitle(int position) {
    Locale l = Locale.getDefault();
    switch(position) {
        case 0:
            return getString(R.string.store_tab_themes).toUpperCase(l);
    }
    return null;
}
#method_after
@Override
public CharSequence getPageTitle(int position) {
    Locale l = Locale.getDefault();
    if (position == 0) {
        return getString(R.string.store_tab_themes).toUpperCase(l);
    }
    return null;
}
#end_block

#method_before
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    if (mDragListener != null || mDropListener != null) {
        switch(ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                int x = (int) ev.getX();
                int y = (int) ev.getY();
                int itemnum = pointToPosition(x, y);
                if (itemnum == AdapterView.INVALID_POSITION) {
                    break;
                }
                View item = getChildAt(itemnum - getFirstVisiblePosition());
                mDragPointX = x - item.getLeft();
                mDragPointY = y - item.getTop();
                mXOffset = ((int) ev.getRawX()) - x;
                mYOffset = ((int) ev.getRawY()) - y;
                // TODO delete this but make sure clicks still work
                if (x < getWidth() / 2) {
                    item.setDrawingCacheEnabled(true);
                    // Create a copy of the drawing cache so that it does not
                    // get recycled
                    // by the framework when the list tries to clean up memory
                    Bitmap bitmap = Bitmap.createBitmap(item.getDrawingCache());
                    startDragging(bitmap, x, y);
                    mDragPos = itemnum;
                    mSrcDragPos = mDragPos;
                    mHeight = getHeight();
                    int touchSlop = mTouchSlop;
                    mUpperBound = Math.min(y - touchSlop, mHeight / 3);
                    mLowerBound = Math.max(y + touchSlop, mHeight * 2 / 3);
                    return false;
                }
                stopDragging();
                break;
        }
    }
    return super.onInterceptTouchEvent(ev);
}
#method_after
@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    if (mDragListener != null || mDropListener != null) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            int x = (int) ev.getX();
            int y = (int) ev.getY();
            int itemnum = pointToPosition(x, y);
            if (itemnum != AdapterView.INVALID_POSITION) {
                View item = getChildAt(itemnum - getFirstVisiblePosition());
                mDragPointX = x - item.getLeft();
                mDragPointY = y - item.getTop();
                mXOffset = ((int) ev.getRawX()) - x;
                mYOffset = ((int) ev.getRawY()) - y;
                // TODO: Delete this but make sure clicks still work
                if (x < getWidth() / 2) {
                    item.setDrawingCacheEnabled(true);
                    // Create a copy of the drawing cache so that it does not get recycled
                    // by the framework when the list tries to clean up memory
                    Bitmap bitmap = Bitmap.createBitmap(item.getDrawingCache());
                    startDragging(bitmap, x, y);
                    mDragPos = itemnum;
                    mSrcDragPos = mDragPos;
                    mHeight = getHeight();
                    int touchSlop = mTouchSlop;
                    mUpperBound = Math.min(y - touchSlop, mHeight / 3);
                    mLowerBound = Math.max(y + touchSlop, mHeight * 2 / 3);
                    return false;
                }
                stopDragging();
            }
        }
    }
    return super.onInterceptTouchEvent(ev);
}
#end_block

#method_before
private int myPointToPosition(int x, int y) {
    if (y < 0) {
        // when dragging off the top of the screen, calculate position
        // by going back from a visible item
        int pos = myPointToPosition(x, y + mItemHeightNormal);
        if (pos > 0) {
            return pos - 1;
        }
    }
    Rect frame = mTempRect;
    final int count = getChildCount();
    for (int i = count - 1; i >= 0; i--) {
        final View child = getChildAt(i);
        child.getHitRect(frame);
        if (frame.contains(x, y)) {
            return getFirstVisiblePosition() + i;
        }
    }
    return INVALID_POSITION;
}
#method_after
private int myPointToPosition(int x, int y) {
    if (y < 0) {
        // When dragging off the top of the screen, calculate position
        // by going back from a visible item
        int pos = myPointToPosition(x, y + mItemHeightNormal);
        if (pos > 0) {
            return pos - 1;
        }
    }
    Rect frame = mTempRect;
    final int count = getChildCount();
    for (int i = count - 1; i >= 0; i--) {
        final View child = getChildAt(i);
        child.getHitRect(frame);
        if (frame.contains(x, y)) {
            return getFirstVisiblePosition() + i;
        }
    }
    return INVALID_POSITION;
}
#end_block

#method_before
private int getItemForPosition(int y) {
    int adjustedy = y - mDragPointY - mItemHeightHalf;
    int pos = myPointToPosition(0, adjustedy);
    if (pos >= 0) {
        if (pos <= mSrcDragPos) {
            pos += 1;
        }
    } else if (adjustedy < 0) {
        // this shouldn't happen anymore now that myPointToPosition deals
        // with this situation
        pos = 0;
    }
    return pos;
}
#method_after
private int getItemForPosition(int y) {
    int adjustedy = y - mDragPointY - mItemHeightHalf;
    int pos = myPointToPosition(0, adjustedy);
    if (pos >= 0) {
        if (pos <= mSrcDragPos) {
            pos += 1;
        }
    } else if (adjustedy < 0) {
        // This shouldn't happen anymore now that myPointToPosition
        // deals with this situation
        pos = 0;
    }
    return pos;
}
#end_block

#method_before
private void unExpandViews(boolean deletion) {
    for (int i = 0; ; i++) {
        View v = getChildAt(i);
        if (v == null) {
            if (deletion) {
                // HACK force update of mItemCount
                int position = getFirstVisiblePosition();
                int y = getChildAt(0).getTop();
                setAdapter(getAdapter());
                setSelectionFromTop(position, y);
            // end hack
            }
            try {
                // force children to be recreated where
                layoutChildren();
                // needed
                v = getChildAt(i);
            } catch (IllegalStateException ex) {
            // layoutChildren throws this sometimes, presumably because
            // we're
            // in the process of being torn down but are still getting
            // touch
            // events
            }
            if (v == null) {
                return;
            }
        }
        ViewGroup.LayoutParams params = v.getLayoutParams();
        params.height = mItemHeightNormal;
        v.setLayoutParams(params);
        v.setVisibility(View.VISIBLE);
    }
}
#method_after
private void unExpandViews(boolean deletion) {
    for (int i = 0; ; i++) {
        View v = getChildAt(i);
        if (v == null) {
            if (deletion) {
                // HACK force update of mItemCount
                int position = getFirstVisiblePosition();
                int y = getChildAt(0).getTop();
                setAdapter(getAdapter());
                setSelectionFromTop(position, y);
            }
            try {
                // Force children to be recreated where
                layoutChildren();
                v = getChildAt(i);
            } catch (IllegalStateException ex) {
            // layoutChildren throws this sometimes, presumably because we're
            // in the process of being torn down but are still getting touch events
            }
            if (v == null) {
                return;
            }
        }
        ViewGroup.LayoutParams params = v.getLayoutParams();
        params.height = mItemHeightNormal;
        v.setLayoutParams(params);
        v.setVisibility(View.VISIBLE);
    }
}
#end_block

#method_before
private void doExpansion() {
    int childnum = mDragPos - getFirstVisiblePosition();
    if (mDragPos > mSrcDragPos) {
        childnum++;
    }
    int numheaders = getHeaderViewsCount();
    View first = getChildAt(mSrcDragPos - getFirstVisiblePosition());
    for (int i = 0; ; i++) {
        View vv = getChildAt(i);
        if (vv == null) {
            break;
        }
        int height = mItemHeightNormal;
        int visibility = View.VISIBLE;
        if (mDragPos < numheaders && i == numheaders) {
            // instead
            if (vv.equals(first)) {
                visibility = View.INVISIBLE;
            } else {
                height = mItemHeightExpanded;
            }
        } else if (vv.equals(first)) {
            // processing the item that is being dragged
            if (mDragPos == mSrcDragPos || getPositionForView(vv) == getCount() - 1) {
                // hovering over the original location
                visibility = View.INVISIBLE;
            } else {
                // not hovering over it
                // Ideally the item would be completely gone, but neither
                // setting its size to 0 nor settings visibility to GONE
                // has the desired effect.
                height = 1;
            }
        } else if (i == childnum) {
            if (mDragPos >= numheaders && mDragPos < getCount() - 1) {
                height = mItemHeightExpanded;
            }
        }
        ViewGroup.LayoutParams params = vv.getLayoutParams();
        params.height = height;
        vv.setLayoutParams(params);
        vv.setVisibility(visibility);
    }
}
#method_after
private void doExpansion() {
    int childnum = mDragPos - getFirstVisiblePosition();
    if (mDragPos > mSrcDragPos) {
        childnum++;
    }
    int numheaders = getHeaderViewsCount();
    View first = getChildAt(mSrcDragPos - getFirstVisiblePosition());
    for (int i = 0; ; i++) {
        View vv = getChildAt(i);
        if (vv == null) {
            break;
        }
        int height = mItemHeightNormal;
        int visibility = View.VISIBLE;
        if (mDragPos < numheaders && i == numheaders) {
            // item below instead
            if (vv.equals(first)) {
                visibility = View.INVISIBLE;
            } else {
                height = mItemHeightExpanded;
            }
        } else if (vv.equals(first)) {
            // Processing the item that is being dragged
            if (mDragPos == mSrcDragPos || getPositionForView(vv) == getCount() - 1) {
                // Hovering over the original location
                visibility = View.INVISIBLE;
            } else {
                // Not hovering over it.
                // Ideally the item would be completely gone, but neither
                // setting its size to 0 nor settings visibility to GONE
                // has the desired effect.
                height = 1;
            }
        } else if (i == childnum) {
            if (mDragPos >= numheaders && mDragPos < getCount() - 1) {
                height = mItemHeightExpanded;
            }
        }
        ViewGroup.LayoutParams params = vv.getLayoutParams();
        params.height = height;
        vv.setLayoutParams(params);
        vv.setVisibility(visibility);
    }
}
#end_block

#method_before
@Override
public boolean onTouchEvent(MotionEvent ev) {
    if (mGestureDetector != null) {
        mGestureDetector.onTouchEvent(ev);
    }
    if ((mDragListener != null || mDropListener != null) && mDragView != null) {
        int action = ev.getAction();
        switch(action) {
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                Rect r = mTempRect;
                mDragView.getDrawingRect(r);
                stopDragging();
                if (mDropListener != null && mDragPos >= 0 && mDragPos < getCount()) {
                    mDropListener.drop(mSrcDragPos, mDragPos);
                }
                unExpandViews(false);
                break;
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_MOVE:
                int x = (int) ev.getX();
                int y = (int) ev.getY();
                dragView(x, y);
                int itemnum = getItemForPosition(y);
                if (itemnum >= 0) {
                    if (action == MotionEvent.ACTION_DOWN || itemnum != mDragPos) {
                        if (mDragListener != null) {
                            mDragListener.drag(mDragPos, itemnum);
                        }
                        mDragPos = itemnum;
                        doExpansion();
                    }
                    int speed = 0;
                    adjustScrollBounds(y);
                    if (y > mLowerBound) {
                        // scroll the list up a bit
                        if (getLastVisiblePosition() < getCount() - 1) {
                            speed = y > (mHeight + mLowerBound) / 2 ? 16 : 4;
                        } else {
                            speed = 1;
                        }
                    } else if (y < mUpperBound) {
                        // scroll the list down a bit
                        speed = y < mUpperBound / 2 ? -16 : -4;
                        if (getFirstVisiblePosition() == 0 && getChildAt(0).getTop() >= getPaddingTop()) {
                            // if we're already at the top, don't try to scroll,
                            // because
                            // it causes the framework to do some extra drawing
                            // that messes
                            // up our animation
                            speed = 0;
                        }
                    }
                    if (speed != 0) {
                        smoothScrollBy(speed, 30);
                    }
                }
                break;
        }
        return true;
    }
    return super.onTouchEvent(ev);
}
#method_after
@Override
public boolean onTouchEvent(MotionEvent ev) {
    if (mGestureDetector != null) {
        mGestureDetector.onTouchEvent(ev);
    }
    if ((mDragListener != null || mDropListener != null) && mDragView != null) {
        int action = ev.getAction();
        switch(action) {
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                Rect r = mTempRect;
                mDragView.getDrawingRect(r);
                stopDragging();
                if (mDropListener != null && mDragPos >= 0 && mDragPos < getCount()) {
                    mDropListener.drop(mSrcDragPos, mDragPos);
                }
                unExpandViews(false);
                break;
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_MOVE:
                int x = (int) ev.getX();
                int y = (int) ev.getY();
                dragView(x, y);
                int itemnum = getItemForPosition(y);
                if (itemnum >= 0) {
                    if (action == MotionEvent.ACTION_DOWN || itemnum != mDragPos) {
                        if (mDragListener != null) {
                            mDragListener.drag(mDragPos, itemnum);
                        }
                        mDragPos = itemnum;
                        doExpansion();
                    }
                    int speed = 0;
                    adjustScrollBounds(y);
                    if (y > mLowerBound) {
                        // Scroll the list up a bit
                        if (getLastVisiblePosition() < getCount() - 1) {
                            speed = y > (mHeight + mLowerBound) / 2 ? 16 : 4;
                        } else {
                            speed = 1;
                        }
                    } else if (y < mUpperBound) {
                        // Scroll the list down a bit
                        speed = y < mUpperBound / 2 ? -16 : -4;
                        if (getFirstVisiblePosition() == 0 && getChildAt(0).getTop() >= getPaddingTop()) {
                            // If we're already at the top, don't try to scroll, because
                            // it causes the framework to do some extra drawing that
                            // messes up our animation
                            speed = 0;
                        }
                    }
                    if (speed != 0) {
                        smoothScrollBy(speed, 30);
                    }
                }
                break;
        }
        return true;
    }
    return super.onTouchEvent(ev);
}
#end_block

#method_before
private SpannableStringBuilder internalReplace(int start, int end, String delta) {
    if (!mLogic.acceptInsert(delta)) {
        mLogic.cleared();
        start = 0;
        end = length();
    }
    for (int i = ORIGINALS.length - 1; i >= 0; --i) {
        delta = delta.replace(ORIGINALS[i], REPLACEMENTS[i]);
    }
    int length = delta.length();
    if (length == 1) {
        char text = delta.charAt(0);
        // don't allow two dots in the same number
        if (text == '.') {
            int p = start - 1;
            while (p >= 0 && Character.isDigit(charAt(p))) {
                --p;
            }
            if (p >= 0 && charAt(p) == '.') {
                return super.replace(start, end, "");
            }
        }
        char prevChar = start > 0 ? charAt(start - 1) : '\0';
        // don't allow 2 successive minuses
        if (text == Logic.MINUS && prevChar == Logic.MINUS) {
            return super.replace(start, end, "");
        }
        // don't allow multiple successive operators
        if (Logic.isOperator(text)) {
            while (Logic.isOperator(prevChar) && (text != Logic.MINUS || prevChar == '+')) {
                --start;
                prevChar = start > 0 ? charAt(start - 1) : '\0';
            }
        }
    }
    return super.replace(start, end, delta);
}
#method_after
private SpannableStringBuilder internalReplace(int start, int end, String delta) {
    if (!mLogic.acceptInsert(delta)) {
        mLogic.cleared();
        start = 0;
        end = length();
    }
    for (int i = ORIGINALS.length - 1; i >= 0; --i) {
        delta = delta.replace(ORIGINALS[i], REPLACEMENTS[i]);
    }
    int length = delta.length();
    if (length == 1) {
        char text = delta.charAt(0);
        // Don't allow two dots in the same number
        if (text == '.') {
            int p = start - 1;
            while (p >= 0 && Character.isDigit(charAt(p))) {
                --p;
            }
            if (p >= 0 && charAt(p) == '.') {
                return super.replace(start, end, "");
            }
        }
        char prevChar = start > 0 ? charAt(start - 1) : '\0';
        // Don't allow 2 successive minuses
        if (text == Logic.MINUS && prevChar == Logic.MINUS) {
            return super.replace(start, end, "");
        }
        // Don't allow multiple successive operators
        if (Logic.isOperator(text)) {
            while (Logic.isOperator(prevChar) && (text != Logic.MINUS || prevChar == '+')) {
                --start;
                prevChar = start > 0 ? charAt(start - 1) : '\0';
            }
        }
    }
    return super.replace(start, end, delta);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.layout.preferences);
    // Update theme (as needed)
    boolean useLightTheme = Theme.isLightTheme(getContext());
    Preference panels = findPreference("panels");
    if (panels != null) {
        panels.setIcon(useLightTheme ? R.drawable.settings_panels_icon_grey : R.drawable.settings_panels_icon_white);
        panels.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                PageOrderFragment fragment = new PageOrderFragment();
                getFragmentManager().beginTransaction().replace(android.R.id.content, fragment).addToBackStack(null).commit();
                return true;
            }
        });
    }
    Preference actions = findPreference("actions");
    if (actions != null) {
        actions.setIcon(useLightTheme ? R.drawable.settings_actions_icon_grey : R.drawable.settings_actions_icon_white);
        actions.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                ActionsPreferencesFragment fragment = new ActionsPreferencesFragment();
                getFragmentManager().beginTransaction().replace(android.R.id.content, fragment).addToBackStack(null).commit();
                return true;
            }
        });
    }
    Preference units = findPreference("units");
    if (units != null) {
        units.setIcon(useLightTheme ? R.drawable.settings_units_icon_grey : R.drawable.settings_units_icon_white);
        units.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                UnitsPreferencesFragment fragment = new UnitsPreferencesFragment();
                getFragmentManager().beginTransaction().replace(android.R.id.content, fragment).addToBackStack(null).commit();
                return true;
            }
        });
    }
    ThemeListPreference theme = (ThemeListPreference) findPreference("SELECTED_THEME");
    if (theme != null) {
        theme.setIcon(useLightTheme ? R.drawable.settings_theme_icon_grey : R.drawable.settings_theme_icon_white);
        theme.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                String appName = newValue.toString();
                // Update theme
                Theme.setPackageName(appName);
                // Swap app icons - Removed because of poor support
                // Intent appIconIntent = new Intent();
                // appIconIntent.setAction(getActivity().getPackageName() + ".APP_ICON");
                // appIconIntent.putExtra("app_name", appName);
                // getActivity().sendBroadcast(appIconIntent);
                // boolean hasAppIcon = Theme.getString(getActivity(), "calc") != null;
                // String packageName = getActivity().getPackageName();
                // int state = !hasAppIcon || packageName.equals(appName) ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED;
                // getActivity().getPackageManager().setComponentEnabledSetting(new ComponentName(packageName, packageName + ".Calculator"), state, PackageManager.DONT_KILL_APP);
                // Create a new intent to relaunch the settings
                Intent intent = new Intent(getActivity(), Preferences.class);
                // Preserve the list offsets
                int itemPosition = getListView().getFirstVisiblePosition();
                View child = getListView().getChildAt(0);
                int itemOffset = child != null ? child.getTop() : 0;
                intent.putExtra(EXTRA_LIST_POSITION, itemPosition);
                intent.putExtra(EXTRA_LIST_VIEW_OFFSET, itemOffset);
                // Go
                startActivity(intent);
                getActivity().finish();
                // Set a smooth fade transition
                getActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
                return true;
            }
        });
    }
    Preference about = findPreference("ABOUT");
    if (about != null) {
        about.setIcon(useLightTheme ? R.drawable.settings_about_icon_grey : R.drawable.settings_about_icon_white);
        String versionName = "";
        try {
            versionName = getActivity().getPackageManager().getPackageInfo(getActivity().getPackageName(), 0).versionName;
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }
        about.setTitle(about.getTitle() + " v" + versionName);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.layout.preferences);
    // Update theme (as needed)
    boolean useLightTheme = Theme.isLightTheme(getContext());
    Preference panels = findPreference("panels");
    if (panels != null) {
        panels.setIcon(useLightTheme ? R.drawable.settings_panels_icon_grey : R.drawable.settings_panels_icon_white);
        panels.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                PageOrderFragment fragment = new PageOrderFragment();
                getFragmentManager().beginTransaction().replace(R.id.content_view, fragment).addToBackStack(null).commit();
                return true;
            }
        });
    }
    Preference actions = findPreference("actions");
    if (actions != null) {
        actions.setIcon(useLightTheme ? R.drawable.settings_actions_icon_grey : R.drawable.settings_actions_icon_white);
        actions.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                ActionsPreferencesFragment fragment = new ActionsPreferencesFragment();
                getFragmentManager().beginTransaction().replace(R.id.content_view, fragment).addToBackStack(null).commit();
                return true;
            }
        });
    }
    Preference units = findPreference("units");
    if (units != null) {
        units.setIcon(useLightTheme ? R.drawable.settings_units_icon_grey : R.drawable.settings_units_icon_white);
        units.setOnPreferenceClickListener(new OnPreferenceClickListener() {

            @Override
            public boolean onPreferenceClick(Preference preference) {
                UnitsPreferencesFragment fragment = new UnitsPreferencesFragment();
                getFragmentManager().beginTransaction().replace(R.id.content_view, fragment).addToBackStack(null).commit();
                return true;
            }
        });
    }
    ThemeListPreference theme = (ThemeListPreference) findPreference("SELECTED_THEME");
    if (theme != null) {
        theme.setIcon(useLightTheme ? R.drawable.settings_theme_icon_grey : R.drawable.settings_theme_icon_white);
        theme.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                String appName = newValue.toString();
                // Update theme
                Theme.setPackageName(appName);
                // Create a new intent to relaunch the settings
                Intent intent = new Intent(getActivity(), Preferences.class);
                // Preserve the list offsets
                int itemPosition = getListView().getFirstVisiblePosition();
                View child = getListView().getChildAt(0);
                int itemOffset = child != null ? child.getTop() : 0;
                intent.putExtra(EXTRA_LIST_POSITION, itemPosition);
                intent.putExtra(EXTRA_LIST_VIEW_OFFSET, itemOffset);
                // Go
                startActivity(intent);
                getActivity().finish();
                // Set a smooth fade transition
                getActivity().overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
                return true;
            }
        });
        getPreferenceScreen().removePreference(theme);
    }
    Preference about = findPreference("ABOUT");
    if (about != null) {
        about.setIcon(useLightTheme ? R.drawable.settings_about_icon_grey : R.drawable.settings_about_icon_white);
        String versionName = "";
        try {
            versionName = getActivity().getPackageManager().getPackageInfo(getActivity().getPackageName(), 0).versionName;
        } catch (NameNotFoundException e) {
            e.printStackTrace();
        }
        about.setTitle(about.getTitle() + " v" + versionName);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.layout.preferences_actions);
    Preference floatingCalc = findPreference("FLOATING_CALCULATOR");
    if (floatingCalc != null) {
        floatingCalc.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                Intent startServiceIntent = new Intent(getActivity(), FloatingCalculator.class);
                if ((Boolean) newValue) {
                    // Start Floating Calc service if not up yet
                    getActivity().startService(startServiceIntent);
                } else {
                    // Stop Floating Calc service if up
                    getActivity().stopService(startServiceIntent);
                }
                return true;
            }
        });
    }
    Preference vibrateOnPress = findPreference("VIBRATE_ON_PRESS");
    if (vibrateOnPress != null) {
        Vibrator vi = (Vibrator) getActivity().getSystemService(Context.VIBRATOR_SERVICE);
        if (!vi.hasVibrator())
            removePreference(vibrateOnPress);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.layout.preferences_actions);
    Preference floatingCalc = findPreference("FLOATING_CALCULATOR");
    if (floatingCalc != null) {
        floatingCalc.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                Intent startServiceIntent = new Intent(getActivity(), FloatingCalculator.class);
                if ((Boolean) newValue) {
                    // Start Floating Calc service if not up yet
                    getActivity().startService(startServiceIntent);
                } else {
                    // Stop Floating Calc service if up
                    getActivity().stopService(startServiceIntent);
                }
                return true;
            }
        });
    }
    Preference widgetBg = findPreference("SHOW_WIDGET_BACKGROUND");
    if (widgetBg != null) {
        widgetBg.setOnPreferenceChangeListener(new OnPreferenceChangeListener() {

            @Override
            public boolean onPreferenceChange(Preference preference, Object newValue) {
                PreferenceManager.getDefaultSharedPreferences(getActivity()).edit().putBoolean("SHOW_WIDGET_BACKGROUND", (Boolean) newValue).commit();
                final Intent intent = new Intent(getActivity(), CalculatorWidget.class);
                intent.setAction("refresh");
                getActivity().sendBroadcast(intent);
                return true;
            }
        });
    }
    Preference vibrateOnPress = findPreference("VIBRATE_ON_PRESS");
    if (vibrateOnPress != null) {
        Vibrator vi = (Vibrator) getActivity().getSystemService(Context.VIBRATOR_SERVICE);
        if (!vi.hasVibrator()) {
            removePreference(vibrateOnPress);
        }
    }
}
#end_block

#method_before
public String appendParenthesis(String input) {
    final StringBuilder formattedInput = new StringBuilder(input);
    int unclosedParen = 0;
    for (int i = 0; i < formattedInput.length(); i++) {
        if (formattedInput.charAt(i) == LEFT_PAREN)
            unclosedParen++;
        else if (formattedInput.charAt(i) == RIGHT_PAREN)
            unclosedParen--;
    }
    for (int i = 0; i < unclosedParen; i++) {
        formattedInput.append(RIGHT_PAREN);
    }
    return formattedInput.toString();
}
#method_after
public String appendParenthesis(String input) {
    final StringBuilder formattedInput = new StringBuilder(input);
    int unclosedParen = 0;
    for (int i = 0; i < formattedInput.length(); i++) {
        if (formattedInput.charAt(i) == LEFT_PAREN) {
            unclosedParen++;
        } else if (formattedInput.charAt(i) == RIGHT_PAREN) {
            unclosedParen--;
        }
    }
    for (int i = 0; i < unclosedParen; i++) {
        formattedInput.append(RIGHT_PAREN);
    }
    return formattedInput.toString();
}
#end_block

#method_before
public String insertSupscripts(String input) {
    final StringBuilder formattedInput = new StringBuilder();
    int sub_open = 0;
    int sub_closed = 0;
    int paren_open = 0;
    int paren_closed = 0;
    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        if (c == POWER) {
            formattedInput.append("<sup>");
            if (sub_open == 0)
                formattedInput.append("<small>");
            sub_open++;
            if (i + 1 == input.length()) {
                formattedInput.append(c);
                if (sub_closed == 0)
                    formattedInput.append("</small>");
                formattedInput.append("</sup>");
                sub_closed++;
            } else {
                formattedInput.append(PLACEHOLDER);
            }
            continue;
        }
        if (sub_open > sub_closed) {
            if (paren_open == paren_closed) {
                // Decide when to break the <sup> started by ^
                if (// 2^3+1
                c == PLUS || // 2^3-1
                (c == MINUS && input.charAt(i - 1) != POWER) || // 2^3*1
                c == MUL || // 2^3/1
                c == DIV || // X^3=1
                c == EQUAL || // 2^3(1)
                (c == LEFT_PAREN && (Character.isDigit(input.charAt(i - 1)) || input.charAt(i - 1) == RIGHT_PAREN)) || // 2^(3-1)(0)
                (// 2^(3)1
                Character.isDigit(c) && input.charAt(i - 1) == RIGHT_PAREN) || (!Character.isDigit(c) && Character.isDigit(input.charAt(i - 1))) && c != '.') {
                    // 2^3log(1)
                    while (sub_open > sub_closed) {
                        if (sub_closed == 0)
                            formattedInput.append("</small>");
                        formattedInput.append("</sup>");
                        sub_closed++;
                    }
                    sub_open = 0;
                    sub_closed = 0;
                    paren_open = 0;
                    paren_closed = 0;
                    if (c == LEFT_PAREN) {
                        paren_open--;
                    } else if (c == RIGHT_PAREN) {
                        paren_closed--;
                    }
                }
            }
            if (c == LEFT_PAREN) {
                paren_open++;
            } else if (c == RIGHT_PAREN) {
                paren_closed++;
            }
        }
        formattedInput.append(c);
    }
    while (sub_open > sub_closed) {
        if (sub_closed == 0)
            formattedInput.append("</small>");
        formattedInput.append("</sup>");
        sub_closed++;
    }
    return formattedInput.toString();
}
#method_after
public String insertSupscripts(String input) {
    final StringBuilder formattedInput = new StringBuilder();
    int subOpen = 0;
    int subClosed = 0;
    int parenOpen = 0;
    int parenClosed = 0;
    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        if (c == POWER) {
            formattedInput.append("<sup>");
            if (subOpen == 0) {
                formattedInput.append("<small>");
            }
            subOpen++;
            if (i + 1 == input.length()) {
                formattedInput.append(c);
                if (subClosed == 0) {
                    formattedInput.append("</small>");
                }
                formattedInput.append("</sup>");
                subClosed++;
            } else {
                formattedInput.append(PLACEHOLDER);
            }
            continue;
        }
        if (subOpen > subClosed) {
            if (parenOpen == parenClosed) {
                // Decide when to break the <sup> started by ^
                if (// 2^3+1
                c == PLUS || // 2^3-1
                (c == MINUS && input.charAt(i - 1) != POWER) || // 2^3*1
                c == MUL || // 2^3/1
                c == DIV || // X^3=1
                c == EQUAL || (c == LEFT_PAREN && (Character.isDigit(input.charAt(i - 1)) || // 2^3(1) or 2^(3-1)(0)
                input.charAt(i - 1) == RIGHT_PAREN)) || (Character.isDigit(c) && input.charAt(i - 1) == // 2^(3)1
                RIGHT_PAREN) || (!Character.isDigit(c) && Character.isDigit(input.charAt(i - 1))) && c != '.') {
                    // 2^3log(1)
                    while (subOpen > subClosed) {
                        if (subClosed == 0) {
                            formattedInput.append("</small>");
                        }
                        formattedInput.append("</sup>");
                        subClosed++;
                    }
                    subOpen = 0;
                    subClosed = 0;
                    parenOpen = 0;
                    parenClosed = 0;
                    if (c == LEFT_PAREN) {
                        parenOpen--;
                    } else if (c == RIGHT_PAREN) {
                        parenClosed--;
                    }
                }
            }
            if (c == LEFT_PAREN) {
                parenOpen++;
            } else if (c == RIGHT_PAREN) {
                parenClosed++;
            }
        }
        formattedInput.append(c);
    }
    while (subOpen > subClosed) {
        if (subClosed == 0) {
            formattedInput.append("</small>");
        }
        formattedInput.append("</sup>");
        subClosed++;
    }
    return formattedInput.toString();
}
#end_block

#method_before
public static boolean load(final MutableString text, final AdvancedDisplay parent, final int pos) {
    if (!text.startsWith(PATTERN))
        return false;
    text.setText(text.substring(PATTERN.length()));
    MatrixTransposeView mv = new MatrixTransposeView(parent);
    parent.addView(mv, pos);
    return true;
}
#method_after
public static boolean load(final MutableString text, final AdvancedDisplay parent, final int pos) {
    if (!text.startsWith(PATTERN)) {
        return false;
    }
    text.setText(text.substring(PATTERN.length()));
    MatrixTransposeView mv = new MatrixTransposeView(parent);
    parent.addView(mv, pos);
    return true;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
public static void buildResourceMap(Class r) {
    RES_MAP = new SparseArray<Theme.Res>();
    try {
        Class color = Class.forName(r.getName() + "$color");
        for (Field f : color.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(COLOR, f.getName()));
        }
        Class drawable = Class.forName(r.getName() + "$drawable");
        for (Field f : drawable.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(DRAWABLE, f.getName()));
        }
        Class raw = Class.forName(r.getName() + "$raw");
        for (Field f : raw.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(RAW, f.getName()));
        }
        Class bool = Class.forName(r.getName() + "$bool");
        for (Field f : bool.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(BOOLEAN, f.getName()));
        }
    } catch (IllegalArgumentException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    }
}
#method_after
@SuppressWarnings("rawtypes")
public static void buildResourceMap(Class r) {
    RES_MAP = new SparseArray<Theme.Res>();
    try {
        Log.d("Theme", "Building resource map");
        Class color = Class.forName(r.getName() + "$color");
        for (Field f : color.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(COLOR, f.getName()));
        }
        Log.d("Theme", "color loaded");
        Class drawable = Class.forName(r.getName() + "$drawable");
        for (Field f : drawable.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(DRAWABLE, f.getName()));
        }
        Log.d("Theme", "drawable loaded");
        Class bool = Class.forName(r.getName() + "$bool");
        for (Field f : bool.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(BOOLEAN, f.getName()));
        }
        Log.d("Theme", "bool loaded");
        Class raw = Class.forName(r.getName() + "$raw");
        for (Field f : raw.getFields()) {
            RES_MAP.put(f.getInt(null), new Res(RAW, f.getName()));
        }
        Log.d("Theme", "raw loaded");
    } catch (IllegalArgumentException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (ClassNotFoundException e) {
    // Do nothing here
    }
}
#end_block

#method_before
public static Context getThemeContext(Context context) {
    try {
        return context.createPackageContext(getPackageName(), Context.CONTEXT_INCLUDE_CODE + Context.CONTEXT_IGNORE_SECURITY);
    } catch (NameNotFoundException e) {
        e.printStackTrace();
    }
    return null;
}
#method_after
public static Context getThemeContext(Context context) {
    try {
        return context.createPackageContext(getPackageName(), context.CONTEXT_INCLUDE_CODE + Context.CONTEXT_IGNORE_SECURITY);
    } catch (NameNotFoundException e) {
        e.printStackTrace();
    }
    return null;
}
#end_block

#method_before
public static String getString(Context context, String name) {
    int id = getId(context, STRING, name);
    if (id == 0)
        return null;
    return getResources(context).getString(id);
}
#method_after
public static String getString(Context context, String name) {
    int id = getId(context, STRING, name);
    if (id == 0) {
        return null;
    }
    return getResources(context).getString(id);
}
#end_block

#method_before
public static Boolean getBoolean(Context context, String name) {
    int id = getId(context, BOOLEAN, name);
    if (id == 0)
        return null;
    return getResources(context).getBoolean(id);
}
#method_after
public static Boolean getBoolean(Context context, String name) {
    int id = getId(context, BOOLEAN, name);
    if (id == 0) {
        return null;
    }
    return getResources(context).getBoolean(id);
}
#end_block

#method_before
public static Drawable getDrawable(Context context, String name) {
    if (DRAWABLE_MAP.get(getKey(context) + "_" + name) != null) {
        return DRAWABLE_MAP.get(getKey(context) + "_" + name).getConstantState().newDrawable();
    }
    int id = getId(context, DRAWABLE, name);
    if (id == 0) {
        id = context.getResources().getIdentifier(name, DRAWABLE, context.getPackageName());
        if (id != 0) {
            DRAWABLE_MAP.put(getKey(context) + "_" + name, context.getResources().getDrawable(id));
            return DRAWABLE_MAP.get(getKey(context) + "_" + name);
        } else
            return null;
    }
    DRAWABLE_MAP.put(getKey(context) + "_" + name, getResources(context).getDrawable(id));
    return DRAWABLE_MAP.get(getKey(context) + "_" + name);
}
#method_after
public static Drawable getDrawable(Context context, String name) {
    if (DRAWABLE_MAP.get(getKey(context) + "_" + name) != null) {
        return DRAWABLE_MAP.get(getKey(context) + "_" + name).getConstantState().newDrawable();
    }
    int id = getId(context, DRAWABLE, name);
    if (id == 0) {
        id = context.getResources().getIdentifier(name, DRAWABLE, context.getPackageName());
        if (id != 0) {
            DRAWABLE_MAP.put(getKey(context) + "_" + name, context.getResources().getDrawable(id));
            return DRAWABLE_MAP.get(getKey(context) + "_" + name);
        } else {
            return null;
        }
    }
    DRAWABLE_MAP.put(getKey(context) + "_" + name, getResources(context).getDrawable(id));
    return DRAWABLE_MAP.get(getKey(context) + "_" + name);
}
#end_block

#method_before
public static int getTheme(Context context) {
    int id = getId(context, "string", "app_theme");
    if (id == 0)
        return 0;
    String fieldName = getResources(context).getString(id).replace(".", "_");
    try {
        Field field = android.R.style.class.getField(fieldName);
        return field.getInt(null);
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
    return 0;
}
#method_after
public static int getTheme(Context context) {
    int id = getId(context, "string", "app_theme");
    if (id == 0) {
        return 0;
    }
    String fieldName = getResources(context).getString(id).replace(".", "_");
    try {
        Field field = android.R.style.class.getField(fieldName);
        return field.getInt(null);
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
    return 0;
}
#end_block

#method_before
public static int getSettingsTheme(Context context) {
    int id = getId(context, "string", "app_settings_theme");
    if (id == 0)
        return 0;
    String fieldName = getResources(context).getString(id).replace(".", "_");
    try {
        Field field = android.R.style.class.getField(fieldName);
        return field.getInt(null);
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
    return 0;
}
#method_after
public static int getSettingsTheme(Context context) {
    int id = getId(context, "string", "app_settings_theme");
    if (id == 0) {
        return 0;
    }
    String fieldName = getResources(context).getString(id).replace(".", "_");
    try {
        Field field = android.R.style.class.getField(fieldName);
        return field.getInt(null);
    } catch (RuntimeException e) {
        e.printStackTrace();
    } catch (NoSuchFieldException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    }
    return 0;
}
#end_block

#method_before
public static Typeface getFont(Context context, String name) {
    String key = getKey(context) + "_" + name;
    if (TYPEFACE_MAP.containsKey(key)) {
        return TYPEFACE_MAP.get(key);
    }
    AssetManager am = getResources(context).getAssets();
    String[] extensions = { ".ttf", ".otf" };
    for (String s : extensions) {
        try {
            am.open(name + s);
            // Try/catch for broken fonts
            Typeface t = Typeface.createFromAsset(am, name + s);
            TYPEFACE_MAP.put(key, t);
            return TYPEFACE_MAP.get(key);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    am = context.getResources().getAssets();
    for (String s : extensions) {
        try {
            am.open(name + s);
            // Try/catch for broken fonts
            Typeface t = Typeface.createFromAsset(am, name + s);
            TYPEFACE_MAP.put(key, t);
            return TYPEFACE_MAP.get(key);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    TYPEFACE_MAP.put(key, null);
    return TYPEFACE_MAP.get(key);
}
#method_after
public static Typeface getFont(Context context, String name) {
    String key = getKey(context) + "_" + name;
    if (TYPEFACE_MAP.containsKey(key)) {
        return TYPEFACE_MAP.get(key);
    }
    String[] extensions = { ".ttf", ".otf" };
    for (String s : extensions) {
        try {
            // Use cursor loader to grab font
            String url = getPackageName() + ".FileProvider/" + name + s;
            Uri uri = Uri.parse("content://" + url);
            ContentResolver cr = context.getContentResolver();
            AssetFileDescriptor a = cr.openAssetFileDescriptor(uri, null);
            FileInputStream in = new FileInputStream(a.getFileDescriptor());
            in.skip(a.getStartOffset());
            File file = new File(context.getCacheDir(), name + s);
            file.createNewFile();
            FileOutputStream fOutput = new FileOutputStream(file);
            byte[] dataBuffer = new byte[1024];
            int readLength = 0;
            while ((readLength = in.read(dataBuffer)) != -1) {
                fOutput.write(dataBuffer, 0, readLength);
            }
            in.close();
            fOutput.close();
            // Try/catch for broken fonts
            Typeface t = Typeface.createFromFile(file);
            TYPEFACE_MAP.put(key, t);
            return TYPEFACE_MAP.get(key);
        } catch (Exception e) {
        // Do nothing here
        }
    }
    TYPEFACE_MAP.put(key, null);
    return TYPEFACE_MAP.get(key);
}
#end_block

#method_before
public static boolean isPageEnabled(Context context, Panel panel) {
    Page page = new Page(context, panel);
    return PreferenceManager.getDefaultSharedPreferences(context).getBoolean(page.getKey(), page.getDefaultValue());
}
#method_after
public static boolean isPageEnabled(Context context, Panel panel) {
    return isPageEnabled(context, new Page(context, panel));
}
#end_block

#method_before
private void cacheBitmap(Context context, Bitmap bitmap, String url) {
    if (url != null && !"".equals(url)) {
        Log.d(TAG, "Saving bitmap to memory.");
        if (bitmap != null)
            LOADED_BITMAPS.put(url, bitmap);
        File cache = getCacheFile(context, url);
        Log.d(TAG, "Got cache file at " + cache);
        if (!cache.isDirectory()) {
            Log.d(TAG, "Saving bitmap to disk now.");
            cache.delete();
            try {
                FileOutputStream fos = new FileOutputStream(cache);
                bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
                fos.close();
                Log.d(TAG, "Bitmap saved to disk.");
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (NullPointerException e) {
                e.printStackTrace();
            }
        }
    }
}
#method_after
private void cacheBitmap(Context context, Bitmap bitmap, String url) {
    if (url != null && !"".equals(url)) {
        Log.d(TAG, "Saving bitmap to memory.");
        if (bitmap != null) {
            LOADED_BITMAPS.put(url, bitmap);
        }
        File cache = getCacheFile(context, url);
        Log.d(TAG, "Got cache file at " + cache);
        if (!cache.isDirectory()) {
            Log.d(TAG, "Saving bitmap to disk now.");
            cache.delete();
            try {
                FileOutputStream fos = new FileOutputStream(cache);
                bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
                fos.close();
                Log.d(TAG, "Bitmap saved to disk.");
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } catch (NullPointerException e) {
                e.printStackTrace();
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onPostExecute(Bitmap result) {
    super.onPostExecute(result);
    if (result != null)
        mImageView.setImageBitmap(result);
}
#method_after
@Override
protected void onPostExecute(Bitmap result) {
    super.onPostExecute(result);
    if (result != null) {
        mImageView.setImageBitmap(result);
    }
}
#end_block

#method_before
@Override
public boolean onKeyDown(View view, Editable content, int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_DEL) {
        if (mParent.isEmpty())
            mDisplay.removeView(mParent);
    }
    return super.onKeyDown(view, content, keyCode, event);
}
#method_after
@Override
public boolean onKeyDown(View view, Editable content, int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_DEL) {
        if (mParent.isEmpty()) {
            mDisplay.removeView(mParent);
        }
    }
    return super.onKeyDown(view, content, keyCode, event);
}
#end_block

#method_before
@Override
public boolean onCreateActionMode(ActionMode mode, Menu menu) {
    // Prevents the selection action mode on double tap.
    return false;
}
#method_after
@Override
public boolean onCreateActionMode(ActionMode mode, Menu menu) {
    // Prevents the selection action mode on double tap
    return false;
}
#end_block

#method_before
@Override
public void onDestroyActionMode(ActionMode mode) {
}
#method_after
@Override
public void onDestroyActionMode(ActionMode mode) {
// Do nothing here
}
#end_block

#method_before
@Override
protected void onPause() {
    super.onPause();
    if (mTextToSpeech != null)
        mTextToSpeech.shutdown();
}
#method_after
@Override
protected void onPause() {
    super.onPause();
    if (mTextToSpeech != null) {
        mTextToSpeech.shutdown();
    }
}
#end_block

#method_before
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    return mCards.get(position).toView();
}
#method_after
@Override
public View getView(int position, View convertView, ViewGroup parent) {
    return mCards.get(position).getView();
}
#end_block

#method_before
public String setMode(Mode mode) {
    String text = updateTextToNewMode(mLogic.getText(), this.mMode, mode);
    this.mMode = mode;
    if (mBaseChangeListener != null)
        mBaseChangeListener.onBaseChange(mMode);
    return text;
}
#method_after
public String setMode(Mode mode) {
    String text = updateTextToNewMode(mLogic.getText(), this.mMode, mode);
    this.mMode = mode;
    if (mBaseChangeListener != null) {
        mBaseChangeListener.onBaseChange(mMode);
    }
    return text;
}
#end_block

#method_before
String updateTextToNewMode(final String originalText, final Mode mode1, final Mode mode2) {
    if (mode1.equals(mode2) || originalText.equals(mLogic.mErrorString) || originalText.isEmpty())
        return originalText;
    String[] operations = originalText.split(REGEX_NUMBER);
    String[] numbers = originalText.split(REGEX_NOT_NUMBER);
    String[] translatedNumbers = new String[numbers.length];
    for (int i = 0; i < numbers.length; i++) {
        if (!numbers[i].isEmpty()) {
            switch(mode1) {
                case BINARY:
                    switch(mode2) {
                        case BINARY:
                            break;
                        case DECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 2, 10);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                        case HEXADECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 2, 16);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                    }
                    break;
                case DECIMAL:
                    switch(mode2) {
                        case BINARY:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 10, 2);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                        case DECIMAL:
                            break;
                        case HEXADECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 10, 16);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                    }
                    break;
                case HEXADECIMAL:
                    switch(mode2) {
                        case BINARY:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 16, 2);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                        case DECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 16, 10);
                            } catch (NumberFormatException e) {
                                e.printStackTrace();
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                e.printStackTrace();
                                return mLogic.mErrorString;
                            }
                            break;
                        case HEXADECIMAL:
                            break;
                    }
                    break;
            }
        }
    }
    String text = "";
    Object[] o = removeWhitespace(operations);
    Object[] n = removeWhitespace(translatedNumbers);
    if (originalText.substring(0, 1).matches(REGEX_NUMBER)) {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += n[i];
            text += o[i];
        }
    } else {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += o[i];
            text += n[i];
        }
    }
    if (o.length > n.length) {
        text += o[o.length - 1];
    } else if (n.length > o.length) {
        text += n[n.length - 1];
    }
    return text;
}
#method_after
String updateTextToNewMode(final String originalText, final Mode mode1, final Mode mode2) {
    if (mode1.equals(mode2) || originalText.equals(mLogic.mErrorString) || originalText.isEmpty()) {
        return originalText;
    }
    String[] operations = originalText.split(REGEX_NUMBER);
    String[] numbers = originalText.split(REGEX_NOT_NUMBER);
    String[] translatedNumbers = new String[numbers.length];
    for (int i = 0; i < numbers.length; i++) {
        if (!numbers[i].isEmpty()) {
            switch(mode1) {
                case BINARY:
                    switch(mode2) {
                        case DECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 2, 10);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                        case HEXADECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 2, 16);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                    }
                    break;
                case DECIMAL:
                    switch(mode2) {
                        case BINARY:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 10, 2);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                        case HEXADECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 10, 16);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                    }
                    break;
                case HEXADECIMAL:
                    switch(mode2) {
                        case BINARY:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 16, 2);
                            } catch (NumberFormatException e) {
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                return mLogic.mErrorString;
                            }
                            break;
                        case DECIMAL:
                            try {
                                translatedNumbers[i] = newBase(numbers[i], 16, 10);
                            } catch (NumberFormatException e) {
                                e.printStackTrace();
                                return mLogic.mErrorString;
                            } catch (SyntaxException e) {
                                e.printStackTrace();
                                return mLogic.mErrorString;
                            }
                            break;
                    }
                    break;
            }
        }
    }
    String text = "";
    Object[] o = removeWhitespace(operations);
    Object[] n = removeWhitespace(translatedNumbers);
    if (originalText.substring(0, 1).matches(REGEX_NUMBER)) {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += n[i];
            text += o[i];
        }
    } else {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += o[i];
            text += n[i];
        }
    }
    if (o.length > n.length) {
        text += o[o.length - 1];
    } else if (n.length > o.length) {
        text += n[n.length - 1];
    }
    return text;
}
#end_block

#method_before
private Object[] removeWhitespace(String[] strings) {
    ArrayList<String> formatted = new ArrayList<String>(strings.length);
    for (String s : strings) {
        if (s != null && !s.isEmpty())
            formatted.add(s);
    }
    return formatted.toArray();
}
#method_after
private Object[] removeWhitespace(String[] strings) {
    ArrayList<String> formatted = new ArrayList<String>(strings.length);
    for (String s : strings) {
        if (s != null && !s.isEmpty()) {
            formatted.add(s);
        }
    }
    return formatted.toArray();
}
#end_block

#method_before
private String newBase(String originalNumber, int originalBase, int base) throws SyntaxException {
    String[] split = originalNumber.split(Pattern.quote(mLogic.mDecimalPoint));
    if (split.length == 0) {
        split = new String[1];
        split[0] = "0";
    }
    if (split[0].isEmpty()) {
        split[0] = "0";
    }
    if (originalBase != 10) {
        split[0] = Long.toString(Long.parseLong(split[0], originalBase));
    }
    String wholeNumber = "";
    switch(base) {
        case 2:
            wholeNumber = Long.toBinaryString(Long.parseLong(split[0]));
            break;
        case 10:
            wholeNumber = split[0];
            break;
        case 16:
            wholeNumber = Long.toHexString(Long.parseLong(split[0]));
            break;
    }
    if (split.length == 1)
        return wholeNumber.toUpperCase(Locale.US);
    // Catch overflow (it's a decimal, it can be (slightly) rounded
    if (split[1].length() > 13) {
        split[1] = split[1].substring(0, 13);
    }
    double decimal = 0;
    if (originalBase != 10) {
        String decimalFraction = Long.toString(Long.parseLong(split[1], originalBase)) + "/" + originalBase + "^" + split[1].length();
        decimal = mLogic.mSymbols.eval(decimalFraction);
    } else {
        decimal = Double.parseDouble("0." + split[1]);
    }
    if (decimal == 0)
        return wholeNumber.toUpperCase(Locale.US);
    String decimalNumber = "";
    for (int i = 0, id = 0; decimal != 0 && i <= PRECISION; i++) {
        decimal *= base;
        id = (int) Math.floor(decimal);
        decimal -= id;
        decimalNumber += Integer.toHexString(id);
    }
    return (wholeNumber + mLogic.mDecimalPoint + decimalNumber).toUpperCase(Locale.US);
}
#method_after
private String newBase(String originalNumber, int originalBase, int base) throws SyntaxException {
    String[] split = originalNumber.split(Pattern.quote(mLogic.mDecimalPoint));
    if (split.length == 0) {
        split = new String[1];
        split[0] = "0";
    }
    if (split[0].isEmpty()) {
        split[0] = "0";
    }
    if (originalBase != 10) {
        split[0] = Long.toString(Long.parseLong(split[0], originalBase));
    }
    String wholeNumber = "";
    switch(base) {
        case 2:
            wholeNumber = Long.toBinaryString(Long.parseLong(split[0]));
            break;
        case 10:
            wholeNumber = split[0];
            break;
        case 16:
            wholeNumber = Long.toHexString(Long.parseLong(split[0]));
            break;
    }
    if (split.length == 1) {
        return wholeNumber.toUpperCase(Locale.US);
    }
    // Catch overflow (it's a decimal, it can be (slightly) rounded
    if (split[1].length() > 13) {
        split[1] = split[1].substring(0, 13);
    }
    double decimal = 0;
    if (originalBase != 10) {
        String decimalFraction = Long.toString(Long.parseLong(split[1], originalBase)) + "/" + originalBase + "^" + split[1].length();
        decimal = mLogic.mSymbols.eval(decimalFraction);
    } else {
        decimal = Double.parseDouble("0." + split[1]);
    }
    if (decimal == 0) {
        return wholeNumber.toUpperCase(Locale.US);
    }
    String decimalNumber = "";
    for (int i = 0, id = 0; decimal != 0 && i <= PRECISION; i++) {
        decimal *= base;
        id = (int) Math.floor(decimal);
        decimal -= id;
        decimalNumber += Integer.toHexString(id);
    }
    return (wholeNumber + mLogic.mDecimalPoint + decimalNumber).toUpperCase(Locale.US);
}
#end_block

#method_before
public String groupSentence(String originalText, int selectionHandle) {
    if (originalText.equals(mLogic.mErrorString) || originalText.isEmpty())
        return originalText;
    originalText = originalText.substring(0, selectionHandle) + SELECTION_HANDLE + originalText.substring(selectionHandle);
    String[] operations = originalText.split(REGEX_NUMBER);
    String[] numbers = originalText.split(REGEX_NOT_NUMBER);
    String[] translatedNumbers = new String[numbers.length];
    for (int i = 0; i < numbers.length; i++) {
        if (!numbers[i].isEmpty()) {
            translatedNumbers[i] = groupDigits(numbers[i], mMode);
        }
    }
    String text = "";
    Object[] o = removeWhitespace(operations);
    Object[] n = removeWhitespace(translatedNumbers);
    if (originalText.substring(0, 1).matches(REGEX_NUMBER)) {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += n[i];
            text += o[i];
        }
    } else {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += o[i];
            text += n[i];
        }
    }
    if (o.length > n.length) {
        text += o[o.length - 1];
    } else if (n.length > o.length) {
        text += n[n.length - 1];
    }
    return text;
}
#method_after
public String groupSentence(String originalText, int selectionHandle) {
    if (originalText.equals(mLogic.mErrorString) || originalText.isEmpty()) {
        return originalText;
    }
    originalText = originalText.substring(0, selectionHandle) + SELECTION_HANDLE + originalText.substring(selectionHandle);
    String[] operations = originalText.split(REGEX_NUMBER);
    String[] numbers = originalText.split(REGEX_NOT_NUMBER);
    String[] translatedNumbers = new String[numbers.length];
    for (int i = 0; i < numbers.length; i++) {
        if (!numbers[i].isEmpty()) {
            translatedNumbers[i] = groupDigits(numbers[i], mMode);
        }
    }
    String text = "";
    Object[] o = removeWhitespace(operations);
    Object[] n = removeWhitespace(translatedNumbers);
    if (originalText.substring(0, 1).matches(REGEX_NUMBER)) {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += n[i];
            text += o[i];
        }
    } else {
        for (int i = 0; i < o.length && i < n.length; i++) {
            text += o[i];
            text += n[i];
        }
    }
    if (o.length > n.length) {
        text += o[o.length - 1];
    } else if (n.length > o.length) {
        text += n[n.length - 1];
    }
    return text;
}
#end_block

#method_before
public static String load(String text, final AdvancedDisplay parent, final int pos) {
    final CalculatorEditText et = (CalculatorEditText) View.inflate(parent.getContext(), parent.getEditTextLayout(), null);
    et.mDisplay = parent;
    et.setText(text);
    et.setSelection(0);
    et.setLongClickable(false);
    if (parent.mKeyListener != null)
        et.setKeyListener(parent.mKeyListener);
    if (parent.mFactory != null)
        et.setEditableFactory(parent.mFactory);
    et.setFont("display_font");
    et.setEnabled(parent.isEnabled());
    AdvancedDisplay.LayoutParams params = new AdvancedDisplay.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    params.gravity = Gravity.CENTER_VERTICAL;
    et.setLayoutParams(params);
    parent.addView(et, pos);
    return "";
}
#method_after
public static String load(String text, final AdvancedDisplay parent, final int pos) {
    final CalculatorEditText et = (CalculatorEditText) View.inflate(parent.getContext(), parent.getEditTextLayout(), null);
    et.mDisplay = parent;
    et.setText(text);
    et.setSelection(0);
    et.setLongClickable(false);
    if (parent.mKeyListener != null) {
        et.setKeyListener(parent.mKeyListener);
    }
    if (parent.mFactory != null) {
        et.setEditableFactory(parent.mFactory);
    }
    et.setFont("display_font");
    et.setEnabled(parent.isEnabled());
    AdvancedDisplay.LayoutParams params = new AdvancedDisplay.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    params.gravity = Gravity.CENTER_VERTICAL;
    et.setLayoutParams(params);
    parent.addView(et, pos);
    return "";
}
#end_block

#method_before
private void setUp() {
    final Resources r = getContext().getResources();
    mDecSeparator = r.getString(R.string.dec_separator);
    mBinSeparator = r.getString(R.string.bin_separator);
    mHexSeparator = r.getString(R.string.hex_separator);
    // Hide the keyboard
    setCustomSelectionActionModeCallback(new NoTextSelectionMode());
    InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
    imm.showSoftInput(this, InputMethodManager.SHOW_IMPLICIT);
    // Display ^ , and other visual cues
    mEquationFormatter = new EquationFormatter();
    addTextChangedListener(new TextWatcher() {

        boolean updating = false;

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
        }

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        }

        @Override
        public void afterTextChanged(Editable s) {
            if (updating)
                return;
            mInput = s.toString().replace(EquationFormatter.PLACEHOLDER, EquationFormatter.POWER).replace(mDecSeparator, "").replace(mBinSeparator, "").replace(mHexSeparator, "");
            updating = true;
            // Get the selection handle, since we're setting text and
            // that'll overwrite it
            mSelectionHandle = getSelectionStart();
            // Adjust the handle by removing any comas or spacing to the
            // left
            String cs = s.subSequence(0, mSelectionHandle).toString();
            mSelectionHandle -= countOccurrences(cs, mDecSeparator.charAt(0));
            if (!mBinSeparator.equals(mDecSeparator)) {
                mSelectionHandle -= countOccurrences(cs, mBinSeparator.charAt(0));
            }
            if (!mHexSeparator.equals(mBinSeparator) && !mHexSeparator.equals(mDecSeparator)) {
                mSelectionHandle -= countOccurrences(cs, mHexSeparator.charAt(0));
            }
            setText(formatText(mInput));
            setSelection(Math.min(mSelectionHandle, getText().length()));
            updating = false;
        }
    });
    setOnFocusChangeListener(new OnFocusChangeListener() {

        @Override
        public void onFocusChange(View v, boolean hasFocus) {
            if (hasFocus && mDisplay != null)
                mDisplay.mActiveEditText = CalculatorEditText.this;
        }
    });
    // Listen for the enter button on physical keyboards
    setOnEditorActionListener(new EditText.OnEditorActionListener() {

        @Override
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            mDisplay.mLogic.onEnter();
            return true;
        }
    });
}
#method_after
private void setUp() {
    final Resources r = getContext().getResources();
    mDecSeparator = r.getString(R.string.dec_separator);
    mBinSeparator = r.getString(R.string.bin_separator);
    mHexSeparator = r.getString(R.string.hex_separator);
    // Hide the keyboard
    setCustomSelectionActionModeCallback(new NoTextSelectionMode());
    InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
    imm.showSoftInput(this, InputMethodManager.SHOW_IMPLICIT);
    // Display ^ , and other visual cues
    mEquationFormatter = new EquationFormatter();
    addTextChangedListener(new TextWatcher() {

        boolean updating = false;

        @Override
        public void onTextChanged(CharSequence s, int start, int before, int count) {
        // Do nothing here
        }

        @Override
        public void beforeTextChanged(CharSequence s, int start, int count, int after) {
        // Do nothing here
        }

        @Override
        public void afterTextChanged(Editable s) {
            if (updating) {
                return;
            }
            mInput = s.toString().replace(EquationFormatter.PLACEHOLDER, EquationFormatter.POWER).replace(mDecSeparator, "").replace(mBinSeparator, "").replace(mHexSeparator, "");
            updating = true;
            // Get the selection handle, since we're setting text and that'll overwrite it
            mSelectionHandle = getSelectionStart();
            // Adjust the handle by removing any comas or spacing to the left
            String cs = s.subSequence(0, mSelectionHandle).toString();
            mSelectionHandle -= countOccurrences(cs, mDecSeparator.charAt(0));
            if (!mBinSeparator.equals(mDecSeparator)) {
                mSelectionHandle -= countOccurrences(cs, mBinSeparator.charAt(0));
            }
            if (!mHexSeparator.equals(mBinSeparator) && !mHexSeparator.equals(mDecSeparator)) {
                mSelectionHandle -= countOccurrences(cs, mHexSeparator.charAt(0));
            }
            setText(formatText(mInput));
            setSelection(Math.min(mSelectionHandle, getText().length()));
            updating = false;
        }
    });
    setOnFocusChangeListener(new OnFocusChangeListener() {

        @Override
        public void onFocusChange(View v, boolean hasFocus) {
            if (hasFocus && mDisplay != null) {
                mDisplay.mActiveEditText = CalculatorEditText.this;
            }
        }
    });
    // Listen for the enter button on physical keyboards
    setOnEditorActionListener(new EditText.OnEditorActionListener() {

        @Override
        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
            mDisplay.mLogic.onEnter();
            return true;
        }
    });
}
#end_block

#method_before
@Override
public View focusSearch(int direction) {
    View v;
    switch(direction) {
        case View.FOCUS_FORWARD:
            v = mDisplay.nextView(this);
            while (!v.isFocusable()) v = mDisplay.nextView(v);
            return v;
        case View.FOCUS_BACKWARD:
            v = mDisplay.previousView(this);
            while (!v.isFocusable()) v = mDisplay.previousView(v);
            if (MatrixView.class.isAssignableFrom(v.getClass())) {
                v = ((ViewGroup) v).getChildAt(((ViewGroup) v).getChildCount() - 1);
                v = ((ViewGroup) v).getChildAt(((ViewGroup) v).getChildCount() - 1);
            }
            return v;
    }
    return super.focusSearch(direction);
}
#method_after
@Override
public View focusSearch(int direction) {
    View v;
    switch(direction) {
        case View.FOCUS_FORWARD:
            v = mDisplay.nextView(this);
            while (!v.isFocusable()) {
                v = mDisplay.nextView(v);
            }
            return v;
        case View.FOCUS_BACKWARD:
            v = mDisplay.previousView(this);
            while (!v.isFocusable()) {
                v = mDisplay.previousView(v);
            }
            if (MatrixView.class.isAssignableFrom(v.getClass())) {
                v = ((ViewGroup) v).getChildAt(((ViewGroup) v).getChildCount() - 1);
                v = ((ViewGroup) v).getChildAt(((ViewGroup) v).getChildCount() - 1);
            }
            return v;
    }
    return super.focusSearch(direction);
}
#end_block

#method_before
@Override
public void onDestroyActionMode(ActionMode mode) {
}
#method_after
@Override
public void onDestroyActionMode(ActionMode mode) {
// Do nothing here
}
#end_block

#method_before
public static RequestQueue getQueue() {
    return mRequestQueue;
}
#method_after
public RequestQueue getQueue() {
    return mRequestQueue;
}
#end_block

#method_before
@Override
protected void onHandleIntent(Intent intent) {
    mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
    UpdateInfo ui = intent.getParcelableExtra(EXTRA_UPDATE_INFO);
    try {
        getIncremental(ui);
    } catch (IOException e) {
        downloadFullZip(ui);
    }
}
#method_after
@Override
protected void onHandleIntent(Intent intent) {
    mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
    mInfo = intent.getParcelableExtra(EXTRA_UPDATE_INFO);
    if (mInfo == null) {
        Log.e(TAG, "Intent UpdateInfo extras were null");
        return;
    }
    try {
        getIncremental();
    } catch (IOException e) {
        downloadFullZip();
    }
}
#end_block

#method_before
private void getIncremental(UpdateInfo ui) throws IOException {
    String sourceIncremental = Utils.getIncremental();
    Log.d(TAG, "Looking for incremental ota for source=" + sourceIncremental + ", target=" + ui.getIncremental());
    UpdatesJsonObjectRequest request = buildRequest(sourceIncremental, ui);
    UpdateApplication.getQueue().add(request);
}
#method_after
private void getIncremental() throws IOException {
    String sourceIncremental = Utils.getIncremental();
    Log.d(TAG, "Looking for incremental ota for source=" + sourceIncremental + ", target=" + mInfo.getIncremental());
    UpdatesJsonObjectRequest request = buildRequest(sourceIncremental);
    ((UpdateApplication) getApplicationContext()).getQueue().add(request);
}
#end_block

#method_before
private UpdatesJsonObjectRequest buildRequest(String sourceIncremental, final UpdateInfo ui) {
    URI requestUri = URI.create(getServerUri() + "/v1/build/get_delta");
    UpdatesJsonObjectRequest request;
    // Set request body
    try {
        request = new UpdatesJsonObjectRequest(requestUri.toASCIIString(), Utils.getUserAgentString(this), buildRequestBody(sourceIncremental, ui), new Response.Listener<JSONObject>() {

            @Override
            public void onResponse(JSONObject response) {
                VolleyLog.v("Response:%n %s", response);
                if (TextUtils.isEmpty(response.toString())) {
                    downloadFullZip(ui);
                    return;
                }
                UpdateInfo incrementalUpdateInfo = parseJSON(response.toString(), ui);
                if (incrementalUpdateInfo == null) {
                    downloadFullZip(ui);
                    return;
                } else {
                    downloadIncremental(incrementalUpdateInfo, ui.getFileName());
                    return;
                }
            }
        }, new Response.ErrorListener() {

            @Override
            public void onErrorResponse(VolleyError error) {
                VolleyLog.e("Error: ", error.getMessage());
            }
        });
        // Add request headers
        String userAgent = Utils.getUserAgentString(this);
        if (userAgent != null) {
            request.addHeader("User-Agent", userAgent);
        }
        request.addHeader("Content-Type", "application/json");
    } catch (JSONException e) {
        Log.e(TAG, "JSONException", e);
        return null;
    }
    return request;
}
#method_after
private UpdatesJsonObjectRequest buildRequest(String sourceIncremental) {
    URI requestUri = URI.create(getServerUri() + "/v1/build/get_delta");
    UpdatesJsonObjectRequest request;
    // Set request body
    try {
        request = new UpdatesJsonObjectRequest(requestUri.toASCIIString(), Utils.getUserAgentString(this), buildRequestBody(sourceIncremental), this, this);
    } catch (JSONException e) {
        Log.e(TAG, "JSONException", e);
        return null;
    }
    return request;
}
#end_block

#method_before
private JSONObject buildRequestBody(String sourceIncremental, UpdateInfo ui) throws JSONException {
    JSONObject body = new JSONObject();
    body.put("source_incremental", sourceIncremental);
    body.put("target_incremental", ui.getIncremental());
    return body;
}
#method_after
private JSONObject buildRequestBody(String sourceIncremental) throws JSONException {
    JSONObject body = new JSONObject();
    body.put("source_incremental", sourceIncremental);
    body.put("target_incremental", mInfo.getIncremental());
    return body;
}
#end_block

#method_before
private UpdateInfo parseJSON(String json, UpdateInfo ui) {
    try {
        JSONObject obj = new JSONObject(json);
        if (obj.has("errors")) {
            return null;
        }
        return new UpdateInfo.Builder().setFileName(obj.getString("filename")).setDownloadUrl(obj.getString("download_url")).setMD5Sum(obj.getString("md5sum")).setApiLevel(ui.getApiLevel()).setBuildDate(obj.getLong("date_created_unix")).setType(UpdateInfo.Type.INCREMENTAL).setIncremental(obj.getString("incremental")).build();
    } catch (JSONException e) {
        Log.e(TAG, "JSONException", e);
        return null;
    }
}
#method_after
private UpdateInfo parseJSON(String json) {
    try {
        JSONObject obj = new JSONObject(json);
        return jsonToInfo(obj);
    } catch (JSONException e) {
        Log.e(TAG, "JSONException", e);
        return null;
    }
}
#end_block

#method_before
private void downloadIncremental(UpdateInfo ui, String originalName) {
    Log.v(TAG, "Downloading incremental zip: " + ui.getDownloadUrl());
    // If directory doesn't exist, create it
    File directory = Utils.makeUpdateFolder();
    if (!directory.exists()) {
        directory.mkdirs();
        Log.d(TAG, "UpdateFolder created");
    }
    // Build the name of the file to download, adding .partial at the end.  It will get
    // stripped off when the download completes
    String sourceIncremental = Utils.getIncremental();
    String targetIncremental = ui.getIncremental();
    String fileName = "incremental-" + sourceIncremental + "-" + targetIncremental + ".zip";
    String fullFilePath = "file://" + directory.getAbsolutePath() + "/" + fileName + ".partial";
    long downloadId = enqueueDownload(ui.getDownloadUrl(), fullFilePath);
    // Store in shared preferences
    mPrefs.edit().putLong(Constants.DOWNLOAD_ID, downloadId).putString(Constants.DOWNLOAD_MD5, ui.getMD5Sum()).putString(Constants.DOWNLOAD_INCREMENTAL_FOR, originalName).apply();
    Utils.cancelNotification(this);
    Intent intent = new Intent(DownloadReceiver.ACTION_DOWNLOAD_STARTED);
    intent.putExtra(DownloadManager.EXTRA_DOWNLOAD_ID, downloadId);
    sendBroadcast(intent);
}
#method_after
private void downloadIncremental(String originalName) {
    Log.v(TAG, "Downloading incremental zip: " + mInfo.getDownloadUrl());
    // If directory doesn't exist, create it
    File directory = Utils.makeUpdateFolder();
    if (!directory.exists()) {
        directory.mkdirs();
        Log.d(TAG, "UpdateFolder created");
    }
    // Build the name of the file to download, adding .partial at the end.  It will get
    // stripped off when the download completes
    String sourceIncremental = Utils.getIncremental();
    String targetIncremental = mInfo.getIncremental();
    String fileName = "incremental-" + sourceIncremental + "-" + targetIncremental + ".zip";
    String fullFilePath = "file://" + directory.getAbsolutePath() + "/" + fileName + ".partial";
    long downloadId = enqueueDownload(mInfo.getDownloadUrl(), fullFilePath);
    // Store in shared preferences
    mPrefs.edit().putLong(Constants.DOWNLOAD_ID, downloadId).putString(Constants.DOWNLOAD_MD5, mInfo.getMD5Sum()).putString(Constants.DOWNLOAD_INCREMENTAL_FOR, originalName).apply();
    Utils.cancelNotification(this);
    Intent intent = new Intent(DownloadReceiver.ACTION_DOWNLOAD_STARTED);
    intent.putExtra(DownloadManager.EXTRA_DOWNLOAD_ID, downloadId);
    sendBroadcast(intent);
}
#end_block

#method_before
private void downloadFullZip(UpdateInfo ui) {
    Log.v(TAG, "Downloading full zip");
    // If directory doesn't exist, create it
    File directory = Utils.makeUpdateFolder();
    if (!directory.exists()) {
        directory.mkdirs();
        Log.d(TAG, "UpdateFolder created");
    }
    // Build the name of the file to download, adding .partial at the end.  It will get
    // stripped off when the download completes
    String fullFilePath = "file://" + directory.getAbsolutePath() + "/" + ui.getFileName() + ".partial";
    long downloadId = enqueueDownload(ui.getDownloadUrl(), fullFilePath);
    // Store in shared preferences
    mPrefs.edit().putLong(Constants.DOWNLOAD_ID, downloadId).putString(Constants.DOWNLOAD_MD5, ui.getMD5Sum()).apply();
    Utils.cancelNotification(this);
    Intent intent = new Intent(DownloadReceiver.ACTION_DOWNLOAD_STARTED);
    intent.putExtra(DownloadManager.EXTRA_DOWNLOAD_ID, downloadId);
    sendBroadcast(intent);
}
#method_after
private void downloadFullZip() {
    Log.v(TAG, "Downloading full zip");
    // If directory doesn't exist, create it
    File directory = Utils.makeUpdateFolder();
    if (!directory.exists()) {
        directory.mkdirs();
        Log.d(TAG, "UpdateFolder created");
    }
    // Build the name of the file to download, adding .partial at the end.  It will get
    // stripped off when the download completes
    String fullFilePath = "file://" + directory.getAbsolutePath() + "/" + mInfo.getFileName() + ".partial";
    long downloadId = enqueueDownload(mInfo.getDownloadUrl(), fullFilePath);
    // Store in shared preferences
    mPrefs.edit().putLong(Constants.DOWNLOAD_ID, downloadId).putString(Constants.DOWNLOAD_MD5, mInfo.getMD5Sum()).apply();
    Utils.cancelNotification(this);
    Intent intent = new Intent(DownloadReceiver.ACTION_DOWNLOAD_STARTED);
    intent.putExtra(DownloadManager.EXTRA_DOWNLOAD_ID, downloadId);
    sendBroadcast(intent);
}
#end_block

#method_before
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (TextUtils.equals(intent.getAction(), ACTION_CANCEL_CHECK)) {
        UpdateApplication.getQueue().cancelAll(null);
        return START_NOT_STICKY;
    }
    return super.onStartCommand(intent, flags, startId);
}
#method_after
@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (TextUtils.equals(intent.getAction(), ACTION_CANCEL_CHECK)) {
        ((UpdateApplication) getApplicationContext()).getQueue().cancelAll(TAG);
        return START_NOT_STICKY;
    }
    return super.onStartCommand(intent, flags, startId);
}
#end_block

#method_before
private void getAvailableUpdates() {
    // Get the type of update we should check for
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    int updateType = prefs.getInt(Constants.UPDATE_TYPE_PREF, 0);
    // Get the actual ROM Update Server URL
    URI updateServerUri = getServerURI();
    UpdatesJsonObjectRequest request;
    try {
        request = new UpdatesJsonObjectRequest(updateServerUri.toASCIIString(), Utils.getUserAgentString(this), buildUpdateRequest(updateType), this, this);
    } catch (JSONException e) {
        Log.e(TAG, "Could not build request", e);
        return;
    }
    UpdateApplication.getQueue().add(request);
}
#method_after
private void getAvailableUpdates() {
    // Get the type of update we should check for
    SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);
    int updateType = prefs.getInt(Constants.UPDATE_TYPE_PREF, 0);
    // Get the actual ROM Update Server URL
    URI updateServerUri = getServerURI();
    UpdatesJsonObjectRequest request;
    try {
        request = new UpdatesJsonObjectRequest(updateServerUri.toASCIIString(), Utils.getUserAgentString(this), buildUpdateRequest(updateType), this, this);
        // Set the tag for the request, reuse logging tag
        request.setTag(TAG);
    } catch (JSONException e) {
        Log.e(TAG, "Could not build request", e);
        return;
    }
    ((UpdateApplication) getApplicationContext()).getQueue().add(request);
}
#end_block

#method_before
private void fetchChangeLog(final UpdateInfo info, String url) {
    Log.d(TAG, "Getting change log for " + info + ", url " + url);
    ChangeLogRequest request = new ChangeLogRequest(Request.Method.GET, url, Utils.getUserAgentString(this), new Response.Listener<String>() {

        @Override
        public void onResponse(String response) {
            VolleyLog.v("Response:%n %s", response);
            parseChangeLogFromResponse(info, response);
        }
    }, new Response.ErrorListener() {

        @Override
        public void onErrorResponse(VolleyError error) {
            VolleyLog.e("Error: ", error.getMessage());
        }
    });
    UpdateApplication.getQueue().add(request);
}
#method_after
private void fetchChangeLog(final UpdateInfo info, String url) {
    Log.d(TAG, "Getting change log for " + info + ", url " + url);
    final Response.Listener<String> successListener = new Response.Listener<String>() {

        @Override
        public void onResponse(String response) {
            VolleyLog.v("Response:%n %s", response);
            parseChangeLogFromResponse(info, response);
        }
    };
    ChangeLogRequest request = new ChangeLogRequest(Request.Method.GET, url, Utils.getUserAgentString(this), successListener, this);
    request.setTag(TAG);
    ((UpdateApplication) getApplicationContext()).getQueue().add(request);
}
#end_block

#method_before
private void deleteZipUpdate() {
    if (mDeleteFileName.isEmpty()) {
        Log.e(TAG, "deleteZipUpdate: File name not specified");
        return;
    }
    File zipFileToDelete = new File(mUpdateFolder, mDeleteFileName);
    if (zipFileToDelete.exists()) {
        zipFileToDelete.delete();
    } else {
        Log.d(TAG, "Update to delete not found");
        return;
    }
    String message = getString(R.string.delete_single_update_success_message, mDeleteFileName);
    Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
}
#method_after
private void deleteZipUpdate() {
    if (mUpdateFolder.exists() && mUpdateFolder.isDirectory()) {
        File zipFileToDelete = new File(mUpdateFolder, mDeleteFileName);
        if (zipFileToDelete.exists()) {
            zipFileToDelete.delete();
        } else {
            Log.d(TAG, "Update to delete not found");
            return;
        }
        String message = getString(R.string.delete_single_update_success_message, mDeleteFileName);
        Toast.makeText(this, message, Toast.LENGTH_SHORT).show();
    } else if (!mUpdateFolder.exists()) {
        Toast.makeText(this, R.string.delete_updates_noFolder_message, Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(this, R.string.delete_updates_failure_message, Toast.LENGTH_SHORT).show();
    }
    // Update the list
    requestUpdateLayout();
}
#end_block

#method_before
@Override
public void onDeleteUpdate(UpdatePreference pref) {
    if (mUpdateFolder.exists() && mUpdateFolder.isDirectory()) {
        mDeleteFileName = pref.getKey();
        mPermissionsReqType = PERMISSIONS_REQUEST_FOR_DELETE_ZIP;
        requestStoragePermission(pref.getContext());
    } else if (!mUpdateFolder.exists()) {
        Toast.makeText(this, R.string.delete_updates_noFolder_message, Toast.LENGTH_SHORT).show();
    } else {
        Toast.makeText(this, R.string.delete_updates_failure_message, Toast.LENGTH_SHORT).show();
    }
    // Update the list
    requestUpdateLayout();
}
#method_after
@Override
public void onDeleteUpdate(UpdatePreference pref) {
    mDeleteFileName = pref.getKey();
    if (mDeleteFileName.isEmpty()) {
        Log.e(TAG, "deleteZipUpdate: File name not specified");
        return;
    }
    mPermissionsReqType = PERMISSIONS_REQUEST_FOR_DELETE_ZIP;
    requestStoragePermission(pref.getContext());
}
#end_block

#method_before
private boolean deleteOldUpdates() {
    boolean success;
    // mUpdateFolder: Foldername with fullpath of SDCARD
    if (mUpdateFolder.exists() && mUpdateFolder.isDirectory()) {
        deleteDir(mUpdateFolder);
        mUpdateFolder.mkdir();
        success = true;
        Toast.makeText(this, R.string.delete_updates_success_message, Toast.LENGTH_SHORT).show();
    } else if (!mUpdateFolder.exists()) {
        success = false;
        Toast.makeText(this, R.string.delete_updates_noFolder_message, Toast.LENGTH_SHORT).show();
    } else {
        success = false;
        Toast.makeText(this, R.string.delete_updates_failure_message, Toast.LENGTH_SHORT).show();
    }
    requestUpdateLayout();
    return success;
}
#method_after
private boolean deleteOldUpdates() {
    boolean success;
    // when .exists() is called.
    if (mUpdateFolder == null) {
        mUpdateFolder = Utils.makeUpdateFolder();
    }
    if (mUpdateFolder.exists() && mUpdateFolder.isDirectory()) {
        deleteDir(mUpdateFolder);
        mUpdateFolder.mkdir();
        success = true;
        Toast.makeText(this, R.string.delete_updates_success_message, Toast.LENGTH_SHORT).show();
    } else if (!mUpdateFolder.exists()) {
        success = false;
        Toast.makeText(this, R.string.delete_updates_noFolder_message, Toast.LENGTH_SHORT).show();
    } else {
        success = false;
        Toast.makeText(this, R.string.delete_updates_failure_message, Toast.LENGTH_SHORT).show();
    }
    requestUpdateLayout();
    return success;
}
#end_block

#method_before
@Override
public void setShowContent(Context context, boolean showContent) {
    mShowContent = showContent;
    if (mShowContent) {
        // Add any providers we wish to include, if we should show content
        initProvidersIfNeeded(context);
        if (mHomeLayout != null) {
            loadCardsFromProviders(context);
        }
    } else {
        for (ICardProvider cardProvider : mCardProviders) {
            cardProvider.onHide(context);
        }
        mCardProviders.clear();
        if (mHomeLayout != null) {
            removeAllCards(context);
            // Make sure that the Undo Bar is hidden if no content is to be shown.
            View undoLayout = mHomeLayout.findViewById(R.id.list_card_undobar);
            undoLayout.setVisibility(View.GONE);
        }
    }
}
#method_after
@Override
public void setShowContent(Context context, boolean showContent) {
    mShowContent = showContent;
    if (mShowContent) {
        // Add any providers we wish to include, if we should show content
        initProvidersIfNeeded(context);
        if (mHomeLayout != null) {
            loadCardsFromProviders(context);
        }
    } else {
        for (ICardProvider cardProvider : mCardProviders) {
            cardProvider.onHide(context);
        }
        mCardProviders.clear();
        if (mHomeLayout != null) {
            removeAllCards(context);
            // Make sure that the Undo Bar is hidden if no content is to be shown.
            hideUndoBar();
        }
    }
}
#end_block

#method_before
@Override
public void onShow(Context context) {
    if (mHomeLayout != null) {
        mHomeLayout.setAlpha(1.0f);
        if (mShowContent) {
            for (ICardProvider cardProvider : mCardProviders) {
                cardProvider.onShow();
                cardProvider.requestRefresh();
            }
        } else {
            // Make sure that the Undo Bar is hidden if no content is to be shown.
            View undoLayout = mHomeLayout.findViewById(R.id.list_card_undobar);
            undoLayout.setVisibility(View.GONE);
        }
    }
}
#method_after
@Override
public void onShow(Context context) {
    if (mHomeLayout != null) {
        mHomeLayout.setAlpha(1.0f);
        if (mShowContent) {
            for (ICardProvider cardProvider : mCardProviders) {
                cardProvider.onShow();
                cardProvider.requestRefresh();
            }
        } else {
            hideUndoBar();
        }
    }
}
#end_block

#method_before
@Override
public void onCheckHistory() {
// Need to show HomeUp Button
// Need to show HomeUp Button
// boolean enabled = this.mHistory != null && this.mHistory.size() > 0;
}
#method_after
@Override
public void onCheckHistory() {
}
#end_block

#method_before
void applyTheme() {
    int orientation = getResources().getConfiguration().orientation;
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, false);
    // imitate a closed drawer while layout is rebuilt to avoid NullPointerException
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawer);
    if (drawerOpen) {
        mDrawerToggle.onDrawerClosed(mDrawer);
    }
    // - Layout
    View v = findViewById(R.id.navigation_layout);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "background_drawable");
    // - ActionBar
    // $NON-NLS-1$
    theme.setTitlebarDrawable(this, getActionBar(), "titlebar_drawable");
    // - StatusBar
    v = findViewById(R.id.navigation_statusbar);
    if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "titlebar_drawable");
    } else {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "statusbar_drawable");
    }
    v = findViewById(R.id.ab_overflow);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_overflow_drawable");
    v = findViewById(R.id.ab_actions);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_actions_drawable");
    v = findViewById(R.id.ab_search);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_search_drawable");
    // - Expanders
    v = findViewById(R.id.ab_configuration);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_open_drawable");
    v = findViewById(R.id.ab_close);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_close_drawable");
    v = findViewById(R.id.ab_sort_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_sort_mode_drawable");
    v = findViewById(R.id.ab_layout_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_layout_mode_drawable");
    v = findViewById(R.id.ab_view_options);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_view_options_drawable");
    // - SelectionBar
    v = findViewById(R.id.navigation_selectionbar);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "selectionbar_drawable");
    v = findViewById(R.id.ab_selection_done);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_selection_done_drawable");
    v = findViewById(R.id.navigation_status_selection_label);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    // - Navigation drawer
    theme.setBackgroundColor(this, mDrawer, "drawer_color");
    v = findViewById(R.id.bookmarks_header);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.history_header);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.history_empty);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    mDrawerToggle.setDrawerImageResource(theme.getResourceId(this, "drawer_icon"));
    // - NavigationView
    int cc = this.mNavigationViews.length;
    for (int i = 0; i < cc; i++) {
        getNavigationView(i).applyTheme();
    }
    // if drawer was open, imitate reopening
    if (drawerOpen) {
        mDrawerToggle.onDrawerOpened(mDrawer);
    }
}
#method_after
void applyTheme() {
    int orientation = getResources().getConfiguration().orientation;
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, false);
    // imitate a closed drawer while layout is rebuilt to avoid NullPointerException
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawer);
    if (drawerOpen) {
        mDrawerToggle.onDrawerClosed(mDrawer);
    }
    // - Layout
    View v = findViewById(R.id.navigation_layout);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "background_drawable");
    // - ActionBar
    // $NON-NLS-1$
    theme.setTitlebarDrawable(this, getActionBar(), "titlebar_drawable");
    // - StatusBar
    v = findViewById(R.id.navigation_statusbar);
    if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "titlebar_drawable");
    } else {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "statusbar_drawable");
    }
    v = findViewById(R.id.ab_overflow);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_overflow_drawable");
    v = findViewById(R.id.ab_actions);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_actions_drawable");
    v = findViewById(R.id.ab_search);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_search_drawable");
    // - Expanders
    v = findViewById(R.id.ab_configuration);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_open_drawable");
    v = findViewById(R.id.ab_close);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_close_drawable");
    v = findViewById(R.id.ab_sort_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_sort_mode_drawable");
    v = findViewById(R.id.ab_layout_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_layout_mode_drawable");
    v = findViewById(R.id.ab_view_options);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_view_options_drawable");
    // - SelectionBar
    v = findViewById(R.id.navigation_selectionbar);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "selectionbar_drawable");
    v = findViewById(R.id.ab_selection_done);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_selection_done_drawable");
    v = findViewById(R.id.navigation_status_selection_label);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    // - Navigation drawer
    theme.setBackgroundColor(this, mDrawer, "drawer_color");
    v = findViewById(R.id.bookmarks_header);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.history_header);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.history_empty);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    mDrawerToggle.setDrawerImageResource(theme.getResourceId(this, "drawer_icon"));
    for (int i = 0; i < mDrawerHistory.getChildCount(); i++) {
        View item = mDrawerHistory.getChildAt(i);
        v = item.findViewById(R.id.history_item_name);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
        v = item.findViewById(R.id.history_item_directory);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
        v = item.findViewById(R.id.history_item_position);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
    }
    // - NavigationView
    int cc = this.mNavigationViews.length;
    for (int i = 0; i < cc; i++) {
        getNavigationView(i).applyTheme();
    }
    // if drawer was open, imitate reopening
    if (drawerOpen) {
        mDrawerToggle.onDrawerOpened(mDrawer);
    }
}
#end_block

#method_before
@Override
protected void onResume() {
    super.onResume();
    // Check restrictions
    if (!FileManagerApplication.checkRestrictSecondaryUsersAccess(this, mChRooted)) {
        return;
    }
    // Check that the current dir is mounted (for virtual filesystems)
    String curDir = mNavigationViews[mCurrentNavigationView].getCurrentDir();
    if (curDir != null) {
        VirtualMountPointConsole vc = VirtualMountPointConsole.getVirtualConsoleForPath(mNavigationViews[mCurrentNavigationView].getCurrentDir());
        if (vc != null && !vc.isMounted()) {
            onRequestBookmarksRefresh();
            removeUnmountedHistory();
            Intent intent = new Intent();
            intent.putExtra(EXTRA_ADD_TO_HISTORY, false);
            initNavigation(NavigationActivity.this.mCurrentNavigationView, false, intent);
        }
    }
}
#method_after
@Override
protected void onResume() {
    super.onResume();
    // Check restrictions
    if (!FileManagerApplication.checkRestrictSecondaryUsersAccess(this, mChRooted)) {
        return;
    }
    // Check that the current dir is mounted (for virtual filesystems)
    String curDir = mNavigationViews[mCurrentNavigationView].getCurrentDir();
    if (curDir != null) {
        VirtualMountPointConsole vc = VirtualMountPointConsole.getVirtualConsoleForPath(mNavigationViews[mCurrentNavigationView].getCurrentDir());
        if (vc != null && !vc.isMounted()) {
            onRequestBookmarksRefresh();
            removeUnmountedHistory();
            removeUnmountedSelection();
            Intent intent = new Intent();
            intent.putExtra(EXTRA_ADD_TO_HISTORY, false);
            initNavigation(NavigationActivity.this.mCurrentNavigationView, false, intent);
        }
    }
}
#end_block

#method_before
private void initStatusActionBar() {
    // Performs a width calculation of buttons. Buttons exceeds the width
    // of the action bar should be hidden
    // This application not use android ActionBar because the application
    // make uses of the title and bottom areas, and wants to force to show
    // the overflow button (without care of physical buttons)
    this.mActionBar = (ViewGroup) findViewById(R.id.navigation_actionbar);
    this.mActionBar.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

        @Override
        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            // Get the width of the action bar
            int w = v.getMeasuredWidth();
            // Wake through children calculation his dimensions
            int bw = (int) getResources().getDimension(R.dimen.default_buttom_width);
            int cw = 0;
            final ViewGroup abView = ((ViewGroup) v);
            int cc = abView.getChildCount();
            for (int i = 0; i < cc; i++) {
                View child = abView.getChildAt(i);
                child.setVisibility(cw + bw > w ? View.INVISIBLE : View.VISIBLE);
                cw += bw;
            }
        }
    });
    // Have overflow menu?
    View overflow = findViewById(R.id.ab_overflow);
    boolean showOptionsMenu = AndroidHelper.showOptionsMenu(getApplicationContext());
    overflow.setVisibility(showOptionsMenu ? View.VISIBLE : View.GONE);
    this.mOptionsAnchorView = showOptionsMenu ? overflow : this.mActionBar;
    // Show the status bar
    View statusBar = findViewById(R.id.navigation_statusbar_portrait_holder);
    statusBar.setVisibility(View.VISIBLE);
}
#method_after
private void initStatusActionBar() {
    // Performs a width calculation of buttons. Buttons exceeds the width
    // of the action bar should be hidden
    // This application not use android ActionBar because the application
    // make uses of the title and bottom areas, and wants to force to show
    // the overflow button (without care of physical buttons)
    this.mActionBar = (ViewGroup) findViewById(R.id.navigation_actionbar);
    this.mActionBar.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

        @Override
        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            // Get the width of the action bar
            int w = v.getMeasuredWidth();
            // Wake through children calculation his dimensions
            int bw = (int) getResources().getDimension(R.dimen.default_buttom_width);
            int cw = 0;
            final ViewGroup abView = ((ViewGroup) v);
            int cc = abView.getChildCount();
            for (int i = 0; i < cc; i++) {
                View child = abView.getChildAt(i);
                child.setVisibility(cw + bw > w ? View.INVISIBLE : View.VISIBLE);
                cw += bw;
            }
        }
    });
    // Have overflow menu? Actually no. There is only a search action, so just hide
    // the overflow
    View overflow = findViewById(R.id.ab_overflow);
    overflow.setVisibility(View.GONE);
    // Show the status bar
    View statusBar = findViewById(R.id.navigation_statusbar_portrait_holder);
    statusBar.setVisibility(View.VISIBLE);
}
#end_block

#method_before
private void initDrawer() {
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawer = (ScrollView) findViewById(R.id.drawer);
    mDrawerBookmarks = (LinearLayout) findViewById(R.id.bookmarks_list);
    mDrawerHistory = (LinearLayout) findViewById(R.id.history_list);
    mDrawerHistoryEmpty = (TextView) findViewById(R.id.history_empty);
    mBookmarksLayout = findViewById(R.id.drawer_bookmarks);
    mHistoryLayout = findViewById(R.id.drawer_history);
    mBookmarksTab = (TextView) findViewById(R.id.drawer_bookmarks_tab);
    mHistoryTab = (TextView) findViewById(R.id.drawer_history_tab);
    mBookmarksTab.setOnClickListener(mOnClickDrawerTabListener);
    mHistoryTab.setOnClickListener(mOnClickDrawerTabListener);
    // Restore the last tab pressed
    Integer lastTab = Preferences.getSharedPreferences().getInt(FileManagerSettings.USER_PREF_LAST_DRAWER_TAB.getId(), (Integer) FileManagerSettings.USER_PREF_LAST_DRAWER_TAB.getDefaultValue());
    mOnClickDrawerTabListener.onClick(lastTab == 0 ? mBookmarksTab : mHistoryTab);
    // Set the navigation drawer "hamburger" icon
    mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, R.drawable.ic_holo_light_navigation_drawer, R.string.drawer_open, R.string.drawer_close) {

        /**
         * Called when a drawer has settled in a completely closed state.
         */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM | ActionBar.DISPLAY_SHOW_HOME);
            getActionBar().setDisplayHomeAsUpEnabled(true);
            getActionBar().setHomeButtonEnabled(true);
            // creates call to onPrepareOptionsMenu()
            invalidateOptionsMenu();
        }

        /**
         * Called when a drawer has settled in a completely open state.
         */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_TITLE | ActionBar.DISPLAY_SHOW_HOME);
            getActionBar().setDisplayHomeAsUpEnabled(true);
            getActionBar().setHomeButtonEnabled(true);
            // change ActionBar title text color
            Theme theme = ThemeManager.getCurrentTheme(NavigationActivity.this);
            // get ActionBar title TextView id
            int titleId = Resources.getSystem().getIdentifier("action_bar_title", "id", "android");
            TextView v = (TextView) findViewById(titleId);
            // $NON-NLS-1$
            theme.setTextColor(NavigationActivity.this, v, "text_color");
            // creates call to onPrepareOptionsMenu()
            invalidateOptionsMenu();
        }
    };
    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);
    getActionBar().setDisplayHomeAsUpEnabled(true);
    getActionBar().setHomeButtonEnabled(true);
}
#method_after
private void initDrawer() {
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mDrawer = (ViewGroup) findViewById(R.id.drawer);
    mDrawerBookmarks = (LinearLayout) findViewById(R.id.bookmarks_list);
    mDrawerHistory = (LinearLayout) findViewById(R.id.history_list);
    mDrawerHistoryEmpty = (TextView) findViewById(R.id.history_empty);
    mBookmarksLayout = findViewById(R.id.drawer_bookmarks);
    mHistoryLayout = findViewById(R.id.drawer_history);
    mBookmarksTab = (TextView) findViewById(R.id.drawer_bookmarks_tab);
    mHistoryTab = (TextView) findViewById(R.id.drawer_history_tab);
    mBookmarksTab.setOnClickListener(mOnClickDrawerTabListener);
    mHistoryTab.setOnClickListener(mOnClickDrawerTabListener);
    mSettings = (ButtonItem) findViewById(R.id.ab_settings);
    mSettings.setOnClickListener(mOnClickDrawerActionBarListener);
    mClearHistory = (ButtonItem) findViewById(R.id.ab_clear_history);
    mClearHistory.setOnClickListener(mOnClickDrawerActionBarListener);
    // Restore the last tab pressed
    Integer lastTab = Preferences.getSharedPreferences().getInt(FileManagerSettings.USER_PREF_LAST_DRAWER_TAB.getId(), (Integer) FileManagerSettings.USER_PREF_LAST_DRAWER_TAB.getDefaultValue());
    mOnClickDrawerTabListener.onClick(lastTab == 0 ? mBookmarksTab : mHistoryTab);
    // Set the navigation drawer "hamburger" icon
    mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout, R.drawable.ic_holo_light_navigation_drawer, R.string.drawer_open, R.string.drawer_close) {

        /**
         * Called when a drawer has settled in a completely closed state.
         */
        public void onDrawerClosed(View view) {
            super.onDrawerClosed(view);
            getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_CUSTOM | ActionBar.DISPLAY_SHOW_HOME);
            getActionBar().setDisplayHomeAsUpEnabled(true);
            getActionBar().setHomeButtonEnabled(true);
        }

        /**
         * Called when a drawer has settled in a completely open state.
         */
        public void onDrawerOpened(View drawerView) {
            super.onDrawerOpened(drawerView);
            getActionBar().setDisplayOptions(ActionBar.DISPLAY_SHOW_TITLE | ActionBar.DISPLAY_SHOW_HOME);
            getActionBar().setDisplayHomeAsUpEnabled(true);
            getActionBar().setHomeButtonEnabled(true);
            // change ActionBar title text color
            Theme theme = ThemeManager.getCurrentTheme(NavigationActivity.this);
            // get ActionBar title TextView id
            int titleId = Resources.getSystem().getIdentifier("action_bar_title", "id", "android");
            TextView v = (TextView) findViewById(titleId);
            // $NON-NLS-1$
            theme.setTextColor(NavigationActivity.this, v, "text_color");
        }
    };
    // Set the drawer toggle as the DrawerListener
    mDrawerLayout.setDrawerListener(mDrawerToggle);
    getActionBar().setDisplayHomeAsUpEnabled(true);
    getActionBar().setHomeButtonEnabled(true);
}
#end_block

#method_before
private void addHistoryToDrawer(int index, HistoryNavigable navigable) {
    // hide empty message
    mDrawerHistoryEmpty.setVisibility(View.GONE);
    Theme theme = ThemeManager.getCurrentTheme(this);
    IconHolder iconholder = new IconHolder(this, false);
    // inflate single bookmark layout item and fill it
    LinearLayout view = (LinearLayout) getLayoutInflater().inflate(R.layout.history_item, null);
    ImageView iconView = (ImageView) view.findViewById(R.id.history_item_icon);
    TextView name = (TextView) view.findViewById(R.id.history_item_name);
    TextView directory = (TextView) view.findViewById(R.id.history_item_directory);
    TextView position = (TextView) view.findViewById(R.id.history_item_position);
    // if (history.getItem() instanceof NavigationViewInfoParcelable)
    // $NON-NLS-1$
    Drawable icon = iconholder.getDrawable("ic_fso_folder_drawable");
    if (navigable instanceof SearchInfoParcelable) {
        // $NON-NLS-1$
        icon = iconholder.getDrawable("ic_history_search_drawable");
    }
    iconView.setImageDrawable(icon);
    String title = navigable.getTitle();
    if (title == null || title.trim().length() == 0) {
        title = getString(R.string.root_directory_name);
    }
    name.setText(title);
    directory.setText(navigable.getDescription());
    position.setText(String.format("#%d", index + 1));
    theme.setTextColor(this, name, "text_color");
    theme.setTextColor(this, directory, "text_color");
    theme.setTextColor(this, position, "text_color");
    // handle item click
    view.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            final int index = mDrawerHistory.indexOfChild(v);
            final int count = mDrawerHistory.getChildCount();
            final History history = mHistory.get(count - index - 1);
            navigateToHistory(history);
            mDrawerLayout.closeDrawer(mDrawer);
        }
    });
    // add as first child
    mDrawerHistory.addView(view, 0);
}
#method_after
private void addHistoryToDrawer(int index, HistoryNavigable navigable) {
    // hide empty message
    mDrawerHistoryEmpty.setVisibility(View.GONE);
    Theme theme = ThemeManager.getCurrentTheme(this);
    IconHolder iconholder = new IconHolder(this, false);
    // inflate single bookmark layout item and fill it
    LinearLayout view = (LinearLayout) getLayoutInflater().inflate(R.layout.history_item, null);
    ImageView iconView = (ImageView) view.findViewById(R.id.history_item_icon);
    TextView name = (TextView) view.findViewById(R.id.history_item_name);
    TextView directory = (TextView) view.findViewById(R.id.history_item_directory);
    // $NON-NLS-1$
    Drawable icon = iconholder.getDrawable("ic_fso_folder_drawable");
    if (navigable instanceof SearchInfoParcelable) {
        // $NON-NLS-1$
        icon = iconholder.getDrawable("ic_history_search_drawable");
    }
    iconView.setImageDrawable(icon);
    String title = navigable.getTitle();
    if (title == null || title.trim().length() == 0) {
        title = getString(R.string.root_directory_name);
    }
    name.setText(title);
    directory.setText(navigable.getDescription());
    theme.setTextColor(this, name, "text_color");
    theme.setTextColor(this, directory, "text_color");
    // handle item click
    view.setOnClickListener(new OnClickListener() {

        @Override
        public void onClick(View v) {
            final int index = mDrawerHistory.indexOfChild(v);
            final int count = mDrawerHistory.getChildCount();
            final History history = mHistory.get(count - index - 1);
            navigateToHistory(history);
            mDrawerLayout.closeDrawer(mDrawer);
        }
    });
    // add as first child
    mDrawerHistory.addView(view, 0);
    // Show clear button if history tab is selected
    mClearHistory.setVisibility(mHistoryTab.getVisibility());
}
#end_block

#method_before
private void updateHistoryPositions() {
    int cc = this.mHistory.size() - 1;
    for (int i = 0; i <= cc; i++) {
        History history = this.mHistory.get(i);
        history.setPosition(i + 1);
        View v = mDrawerHistory.getChildAt(mDrawerHistory.getChildCount() - i - 1);
        TextView position = (TextView) v.findViewById(R.id.history_item_position);
        position.setText(String.format("#%d", i + 1));
    }
}
#method_after
private void updateHistoryPositions() {
    int cc = this.mHistory.size() - 1;
    for (int i = 0; i <= cc; i++) {
        History history = this.mHistory.get(i);
        history.setPosition(i + 1);
    }
}
#end_block

#method_before
private void onLayoutChanged() {
    Theme theme = ThemeManager.getCurrentTheme(this);
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawer);
    // Apply only when the orientation was changed
    int orientation = getResources().getConfiguration().orientation;
    if (this.mOrientation == orientation)
        return;
    this.mOrientation = orientation;
    // imitate a closed drawer while layout is rebuilt to avoid NullPointerException
    if (drawerOpen) {
        mDrawerToggle.onDrawerClosed(mDrawer);
    }
    if (this.mOrientation == Configuration.ORIENTATION_LANDSCAPE) {
        // Landscape mode
        ViewGroup statusBar = (ViewGroup) findViewById(R.id.navigation_statusbar);
        if (statusBar.getParent() != null) {
            ViewGroup parent = (ViewGroup) statusBar.getParent();
            parent.removeView(statusBar);
        }
        // Calculate the action button size (all the buttons must fit in the title bar)
        int bw = (int) getResources().getDimension(R.dimen.default_buttom_width);
        int abw = this.mActionBar.getChildCount() * bw;
        int rbw = 0;
        int cc = statusBar.getChildCount();
        for (int i = 0; i < cc; i++) {
            View child = statusBar.getChildAt(i);
            if (child instanceof ButtonItem) {
                rbw += bw;
            }
        }
        int w = abw + rbw;
        boolean showOptionsMenu = AndroidHelper.showOptionsMenu(getApplicationContext());
        if (!showOptionsMenu) {
            w -= bw;
        }
        // Add to the new location
        ViewGroup newParent = (ViewGroup) findViewById(R.id.navigation_title_landscape_holder);
        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(w, ViewGroup.LayoutParams.MATCH_PARENT);
        statusBar.setLayoutParams(params);
        newParent.addView(statusBar);
        // Apply theme
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, statusBar, "titlebar_drawable");
        // Hide holder
        View holder = findViewById(R.id.navigation_statusbar_portrait_holder);
        holder.setVisibility(View.GONE);
    } else {
        // Portrait mode
        ViewGroup statusBar = (ViewGroup) findViewById(R.id.navigation_statusbar);
        if (statusBar.getParent() != null) {
            ViewGroup parent = (ViewGroup) statusBar.getParent();
            parent.removeView(statusBar);
        }
        // Add to the new location
        ViewGroup newParent = (ViewGroup) findViewById(R.id.navigation_statusbar_portrait_holder);
        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
        statusBar.setLayoutParams(params);
        newParent.addView(statusBar);
        // Apply theme
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, statusBar, "statusbar_drawable");
        // Show holder
        newParent.setVisibility(View.VISIBLE);
    }
    // if drawer was open, imitate reopening
    if (drawerOpen) {
        mDrawerToggle.onDrawerOpened(mDrawer);
    }
}
#method_after
private void onLayoutChanged() {
    Theme theme = ThemeManager.getCurrentTheme(this);
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawer);
    // Apply only when the orientation was changed
    int orientation = getResources().getConfiguration().orientation;
    if (this.mOrientation == orientation)
        return;
    this.mOrientation = orientation;
    // imitate a closed drawer while layout is rebuilt to avoid NullPointerException
    if (drawerOpen) {
        mDrawerToggle.onDrawerClosed(mDrawer);
    }
    if (this.mOrientation == Configuration.ORIENTATION_LANDSCAPE) {
        // Landscape mode
        ViewGroup statusBar = (ViewGroup) findViewById(R.id.navigation_statusbar);
        if (statusBar.getParent() != null) {
            ViewGroup parent = (ViewGroup) statusBar.getParent();
            parent.removeView(statusBar);
        }
        // Calculate the action button size (all the buttons must fit in the title bar)
        int bw = (int) getResources().getDimension(R.dimen.default_buttom_width);
        int abw = this.mActionBar.getChildCount() * bw;
        int rbw = 0;
        int cc = statusBar.getChildCount();
        for (int i = 0; i < cc; i++) {
            View child = statusBar.getChildAt(i);
            if (child instanceof ButtonItem) {
                rbw += bw;
            }
        }
        // Currently there isn't overflow menu
        int w = abw + rbw - bw;
        // Add to the new location
        ViewGroup newParent = (ViewGroup) findViewById(R.id.navigation_title_landscape_holder);
        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(w, ViewGroup.LayoutParams.MATCH_PARENT);
        statusBar.setLayoutParams(params);
        newParent.addView(statusBar);
        // Apply theme
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, statusBar, "titlebar_drawable");
        // Hide holder
        View holder = findViewById(R.id.navigation_statusbar_portrait_holder);
        holder.setVisibility(View.GONE);
    } else {
        // Portrait mode
        ViewGroup statusBar = (ViewGroup) findViewById(R.id.navigation_statusbar);
        if (statusBar.getParent() != null) {
            ViewGroup parent = (ViewGroup) statusBar.getParent();
            parent.removeView(statusBar);
        }
        // Add to the new location
        ViewGroup newParent = (ViewGroup) findViewById(R.id.navigation_statusbar_portrait_holder);
        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
        statusBar.setLayoutParams(params);
        newParent.addView(statusBar);
        // Apply theme
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, statusBar, "statusbar_drawable");
        // Show holder
        newParent.setVisibility(View.VISIBLE);
    }
    // if drawer was open, imitate reopening
    if (drawerOpen) {
        mDrawerToggle.onDrawerOpened(mDrawer);
    }
}
#end_block

#method_before
private void removeUnmountedHistory() {
    int cc = this.mHistory.size() - 1;
    for (int i = cc; i >= 0; i--) {
        History history = this.mHistory.get(i);
        if (history.getItem() instanceof NavigationViewInfoParcelable) {
            NavigationViewInfoParcelable navigableInfo = ((NavigationViewInfoParcelable) history.getItem());
            VirtualMountPointConsole vc = VirtualMountPointConsole.getVirtualConsoleForPath(navigableInfo.getCurrentDir());
            if (vc != null && !vc.isMounted()) {
                this.mHistory.remove(i);
                mDrawerHistory.removeViewAt(mDrawerHistory.getChildCount() - i - 1);
            }
        }
    }
    mDrawerHistoryEmpty.setVisibility(mDrawerHistory.getChildCount() == 0 ? View.VISIBLE : View.GONE);
    updateHistoryPositions();
}
#method_after
private void removeUnmountedHistory() {
    int cc = mHistory.size() - 1;
    for (int i = cc; i >= 0; i--) {
        History history = mHistory.get(i);
        if (history.getItem() instanceof NavigationViewInfoParcelable) {
            NavigationViewInfoParcelable navigableInfo = ((NavigationViewInfoParcelable) history.getItem());
            VirtualMountPointConsole vc = VirtualMountPointConsole.getVirtualConsoleForPath(navigableInfo.getCurrentDir());
            if (vc != null && !vc.isMounted()) {
                mHistory.remove(i);
                mDrawerHistory.removeViewAt(mDrawerHistory.getChildCount() - i - 1);
            }
        }
    }
    mDrawerHistoryEmpty.setVisibility(mDrawerHistory.getChildCount() == 0 ? View.VISIBLE : View.GONE);
    updateHistoryPositions();
}
#end_block

#method_before
void applyTheme() {
    int orientation = getResources().getConfiguration().orientation;
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, false);
    applyTabTheme();
    // imitate a closed drawer while layout is rebuilt to avoid NullPointerException
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawer);
    if (drawerOpen) {
        mDrawerToggle.onDrawerClosed(mDrawer);
    }
    // - Layout
    View v = findViewById(R.id.navigation_layout);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "background_drawable");
    // - ActionBar
    // $NON-NLS-1$
    theme.setTitlebarDrawable(this, getActionBar(), "titlebar_drawable");
    // - StatusBar
    v = findViewById(R.id.navigation_statusbar);
    if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "titlebar_drawable");
    } else {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "statusbar_drawable");
    }
    v = findViewById(R.id.ab_overflow);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_overflow_drawable");
    v = findViewById(R.id.ab_actions);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_actions_drawable");
    v = findViewById(R.id.ab_search);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_search_drawable");
    // - Expanders
    v = findViewById(R.id.ab_configuration);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_open_drawable");
    v = findViewById(R.id.ab_close);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_close_drawable");
    v = findViewById(R.id.ab_sort_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_sort_mode_drawable");
    v = findViewById(R.id.ab_layout_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_layout_mode_drawable");
    v = findViewById(R.id.ab_view_options);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_view_options_drawable");
    // - SelectionBar
    v = findViewById(R.id.navigation_selectionbar);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "selectionbar_drawable");
    v = findViewById(R.id.ab_selection_done);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_selection_done_drawable");
    v = findViewById(R.id.navigation_status_selection_label);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    // - Navigation drawer
    v = findViewById(R.id.history_empty);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    mDrawerToggle.setDrawerImageResource(theme.getResourceId(this, "drawer_icon"));
    for (int i = 0; i < mDrawerHistory.getChildCount(); i++) {
        View item = mDrawerHistory.getChildAt(i);
        v = item.findViewById(R.id.history_item_name);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
        v = item.findViewById(R.id.history_item_directory);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
        v = item.findViewById(R.id.history_item_position);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
    }
    // - NavigationView
    int cc = this.mNavigationViews.length;
    for (int i = 0; i < cc; i++) {
        getNavigationView(i).applyTheme();
    }
    // if drawer was open, imitate reopening
    if (drawerOpen) {
        mDrawerToggle.onDrawerOpened(mDrawer);
    }
}
#method_after
void applyTheme() {
    int orientation = getResources().getConfiguration().orientation;
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, false);
    applyTabTheme();
    // imitate a closed drawer while layout is rebuilt to avoid NullPointerException
    boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawer);
    if (drawerOpen) {
        mDrawerToggle.onDrawerClosed(mDrawer);
    }
    // - Layout
    View v = findViewById(R.id.navigation_layout);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "background_drawable");
    // - ActionBar
    // $NON-NLS-1$
    theme.setTitlebarDrawable(this, getActionBar(), "titlebar_drawable");
    // - StatusBar
    v = findViewById(R.id.navigation_statusbar);
    if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "titlebar_drawable");
    } else {
        // $NON-NLS-1$
        theme.setBackgroundDrawable(this, v, "statusbar_drawable");
    }
    v = findViewById(R.id.ab_overflow);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_overflow_drawable");
    v = findViewById(R.id.ab_actions);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_actions_drawable");
    v = findViewById(R.id.ab_search);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_search_drawable");
    // - Expanders
    v = findViewById(R.id.ab_configuration);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_open_drawable");
    v = findViewById(R.id.ab_close);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "expander_close_drawable");
    v = findViewById(R.id.ab_sort_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_sort_mode_drawable");
    v = findViewById(R.id.ab_layout_mode);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_layout_mode_drawable");
    v = findViewById(R.id.ab_view_options);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_view_options_drawable");
    // - SelectionBar
    v = findViewById(R.id.navigation_selectionbar);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "selectionbar_drawable");
    v = findViewById(R.id.ab_selection_done);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ImageView) v, "ab_selection_done_drawable");
    v = findViewById(R.id.navigation_status_selection_label);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    // - Navigation drawer
    v = findViewById(R.id.history_empty);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    mDrawerToggle.setDrawerImageResource(theme.getResourceId(this, "drawer_icon"));
    for (int i = 0; i < mDrawerHistory.getChildCount(); i++) {
        View item = mDrawerHistory.getChildAt(i);
        v = item.findViewById(R.id.history_item_name);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
        v = item.findViewById(R.id.history_item_directory);
        // $NON-NLS-1$
        theme.setTextColor(this, (TextView) v, "text_color");
    }
    // - NavigationView
    int cc = this.mNavigationViews.length;
    for (int i = 0; i < cc; i++) {
        getNavigationView(i).applyTheme();
    }
    // if drawer was open, imitate reopening
    if (drawerOpen) {
        mDrawerToggle.onDrawerOpened(mDrawer);
    }
}
#end_block

#method_before
private void applyTabTheme() {
    // Apply the theme
    Theme theme = ThemeManager.getCurrentTheme(this);
    View v = findViewById(R.id.drawer);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "background_drawable");
    v = findViewById(R.id.drawer_bookmarks_tab);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.drawer_history_tab);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
}
#method_after
private void applyTabTheme() {
    // Apply the theme
    Theme theme = ThemeManager.getCurrentTheme(this);
    View v = findViewById(R.id.drawer);
    // $NON-NLS-1$
    theme.setBackgroundDrawable(this, v, "background_drawable");
    v = findViewById(R.id.drawer_bookmarks_tab);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.drawer_history_tab);
    // $NON-NLS-1$
    theme.setTextColor(this, (TextView) v, "text_color");
    v = findViewById(R.id.ab_settings);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ButtonItem) v, "ab_settings_drawable");
    v = findViewById(R.id.ab_clear_history);
    // $NON-NLS-1$
    theme.setImageDrawable(this, (ButtonItem) v, "ab_delete_drawable");
}
#end_block

#method_before
@Override
@SuppressWarnings("deprecation")
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Check with java.io.File instead of TFile because TFile#exists() will
    // check for password key, which is currently locked
    mNewStorage = !SecureConsole.getSecureStorageRoot().getFile().exists();
    mResetPassword = sResetInProgress;
    mDropStorage = sDropInProgress;
    // Set the theme before setContentView
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, true);
    // Load the dialog's custom layout
    ViewGroup v = (ViewGroup) LayoutInflater.from(this).inflate(R.layout.unlock_dialog_message, null);
    mMessage = (TextView) v.findViewById(R.id.unlock_dialog_message);
    mOldKey = (EditText) v.findViewById(R.id.unlock_old_password);
    mOldKey.addTextChangedListener(this);
    mKey = (EditText) v.findViewById(R.id.unlock_password);
    mKey.addTextChangedListener(this);
    mRepeatKey = (EditText) v.findViewById(R.id.unlock_repeat);
    mRepeatKey.addTextChangedListener(this);
    View oldPasswordLayout = v.findViewById(R.id.unlock_old_password_layout);
    View repeatLayout = v.findViewById(R.id.unlock_repeat_layout);
    mValidationMsg = (TextView) v.findViewById(R.id.unlock_validation_msg);
    // Load resources
    int messageResourceId = R.string.secure_storage_unlock_key_prompt_msg;
    int positiveButtonLabelResourceId = R.string.secure_storage_unlock_button;
    String title = getString(R.string.secure_storage_unlock_title);
    if (mNewStorage) {
        positiveButtonLabelResourceId = R.string.secure_storage_create_button;
        title = getString(R.string.secure_storage_create_title);
        messageResourceId = R.string.secure_storage_unlock_key_new_msg;
    } else if (mResetPassword) {
        positiveButtonLabelResourceId = R.string.secure_storage_reset_button;
        title = getString(R.string.secure_storage_reset_title);
        messageResourceId = R.string.secure_storage_unlock_key_reset_msg;
        TextView passwordLabel = (TextView) v.findViewById(R.id.unlock_password_title);
        passwordLabel.setText(R.string.secure_storage_unlock_new_key_title);
    } else if (mDropStorage) {
        positiveButtonLabelResourceId = R.string.secure_storage_drop_button;
        title = getString(R.string.secure_storage_drop_title);
        messageResourceId = R.string.secure_storage_unlock_key_drop_msg;
    }
    // Set the message according to the storage creation status
    mMessage.setText(messageResourceId);
    repeatLayout.setVisibility(mNewStorage || mResetPassword ? View.VISIBLE : View.GONE);
    oldPasswordLayout.setVisibility(mResetPassword ? View.VISIBLE : View.GONE);
    // Set validation msg
    mValidationMsg.setText(getString(R.string.secure_storage_unlock_validation_length, MIN_PASSWORD_LENGTH));
    mValidationMsg.setVisibility(View.VISIBLE);
    // Create the dialog
    mDialog = DialogHelper.createTwoButtonsDialog(this, positiveButtonLabelResourceId, R.string.cancel, theme.getResourceId(this, "ic_secure_drawable"), title, v, this);
    mDialog.setOnDismissListener(new OnDismissListener() {

        @Override
        public void onDismiss(DialogInterface dialog) {
            mDialog.dismiss();
            finish();
        }
    });
    mDialog.setOnCancelListener(new OnCancelListener() {

        @Override
        public void onCancel(DialogInterface dialog) {
            sUnlockKeyTemp = null;
            mDialog.cancel();
            finish();
        }
    });
    mDialog.setCanceledOnTouchOutside(false);
    // Apply the theme to the custom view of the dialog
    applyTheme(this, v);
}
#method_after
@Override
@SuppressWarnings("deprecation")
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Check with java.io.File instead of TFile because TFile#exists() will
    // check for password key, which is currently locked
    mNewStorage = !SecureConsole.getSecureStorageRoot().getFile().exists();
    mResetPassword = sResetInProgress;
    mDeleteStorage = sDeleteInProgress;
    // Set the theme before setContentView
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, true);
    // Load the dialog's custom layout
    ViewGroup v = (ViewGroup) LayoutInflater.from(this).inflate(R.layout.unlock_dialog_message, null);
    mMessage = (TextView) v.findViewById(R.id.unlock_dialog_message);
    mOldKey = (EditText) v.findViewById(R.id.unlock_old_password);
    mOldKey.addTextChangedListener(this);
    mKey = (EditText) v.findViewById(R.id.unlock_password);
    mKey.addTextChangedListener(this);
    mRepeatKey = (EditText) v.findViewById(R.id.unlock_repeat);
    mRepeatKey.addTextChangedListener(this);
    View oldPasswordLayout = v.findViewById(R.id.unlock_old_password_layout);
    View repeatLayout = v.findViewById(R.id.unlock_repeat_layout);
    mValidationMsg = (TextView) v.findViewById(R.id.unlock_validation_msg);
    // Load resources
    int messageResourceId = R.string.secure_storage_unlock_key_prompt_msg;
    int positiveButtonLabelResourceId = R.string.secure_storage_unlock_button;
    String title = getString(R.string.secure_storage_unlock_title);
    if (mNewStorage) {
        positiveButtonLabelResourceId = R.string.secure_storage_create_button;
        title = getString(R.string.secure_storage_create_title);
        messageResourceId = R.string.secure_storage_unlock_key_new_msg;
    } else if (mResetPassword) {
        positiveButtonLabelResourceId = R.string.secure_storage_reset_button;
        title = getString(R.string.secure_storage_reset_title);
        messageResourceId = R.string.secure_storage_unlock_key_reset_msg;
        TextView passwordLabel = (TextView) v.findViewById(R.id.unlock_password_title);
        passwordLabel.setText(R.string.secure_storage_unlock_new_key_title);
    } else if (mDeleteStorage) {
        positiveButtonLabelResourceId = R.string.secure_storage_delete_button;
        title = getString(R.string.secure_storage_delete_title);
        messageResourceId = R.string.secure_storage_unlock_key_delete_msg;
    }
    // Set the message according to the storage creation status
    mMessage.setText(messageResourceId);
    repeatLayout.setVisibility(mNewStorage || mResetPassword ? View.VISIBLE : View.GONE);
    oldPasswordLayout.setVisibility(mResetPassword ? View.VISIBLE : View.GONE);
    // Set validation msg
    mValidationMsg.setText(getString(R.string.secure_storage_unlock_validation_length, MIN_PASSWORD_LENGTH));
    mValidationMsg.setVisibility(View.VISIBLE);
    // Create the dialog
    mDialog = DialogHelper.createTwoButtonsDialog(this, positiveButtonLabelResourceId, R.string.cancel, theme.getResourceId(this, "ic_secure_drawable"), title, v, this);
    mDialog.setOnDismissListener(new OnDismissListener() {

        @Override
        public void onDismiss(DialogInterface dialog) {
            mDialog.dismiss();
            finish();
        }
    });
    mDialog.setOnCancelListener(new OnCancelListener() {

        @Override
        public void onCancel(DialogInterface dialog) {
            sUnlockKeyTemp = null;
            mDialog.cancel();
            finish();
        }
    });
    mDialog.setCanceledOnTouchOutside(false);
    // Apply the theme to the custom view of the dialog
    applyTheme(this, v);
}
#end_block

#method_before
void umount() {
    // Discard current keys
    sResetInProgress = false;
    sDropInProgress = false;
    sOldUnlockKey = null;
    sUnlockKey = null;
}
#method_after
void umount() {
    // Discard current keys
    sResetInProgress = false;
    sDeleteInProgress = false;
    sOldUnlockKey = null;
    sUnlockKey = null;
}
#end_block

#method_before
void reset() {
    // Discard current keys
    sResetInProgress = true;
    sDropInProgress = false;
    sOldUnlockKey = null;
    sUnlockKey = null;
}
#method_after
void reset() {
    // Discard current keys
    sResetInProgress = true;
    sDeleteInProgress = false;
    sOldUnlockKey = null;
    sUnlockKey = null;
}
#end_block

#method_before
private static synchronized AesCipherParameters getOrPromptForKey(boolean read) throws UnknownKeyException {
    // Check if we have a cached key
    if (read && sResetInProgress && sOldUnlockKey != null) {
        return sOldUnlockKey;
    }
    if (sUnlockKey != null) {
        return sUnlockKey;
    }
    // Need to prompt the user for the secure storage key, so we open a overlay activity
    // to show the prompt dialog
    Handler handler = new Handler(Looper.getMainLooper()) {

        @Override
        public void handleMessage(Message inputMessage) {
            Context ctx = FileManagerApplication.getInstance();
            Intent intent = new Intent(ctx, SecureStorageKeyPromptActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            ctx.startActivity(intent);
        }
    };
    handler.sendEmptyMessage(MSG_REQUEST_UNLOCK_DIALOG);
    // Wait for the response
    synchronized (WAIT_SYNC) {
        try {
            WAIT_SYNC.wait();
        } catch (InterruptedException ex) {
            throw new KeyPromptingInterruptedException(ex);
        }
    }
    // Request for authentication is done. We need to exit from drop status
    sDropInProgress = false;
    // Check if the user cancelled the dialog
    if (sUnlockKeyTemp == null) {
        throw new KeyPromptingCancelledException();
    }
    // Move temporary params to real params
    sUnlockKey = sUnlockKeyTemp;
    sOldUnlockKey = sOldUnlockKeyTemp;
    AesCipherParameters key = sUnlockKey;
    if (sResetInProgress && read) {
        key = sOldUnlockKey;
    }
    return key;
}
#method_after
private static synchronized AesCipherParameters getOrPromptForKey(boolean read) throws UnknownKeyException {
    // Check if we have a cached key
    if (read && sResetInProgress && sOldUnlockKey != null) {
        return sOldUnlockKey;
    }
    if (sUnlockKey != null) {
        return sUnlockKey;
    }
    // Need to prompt the user for the secure storage key, so we open a overlay activity
    // to show the prompt dialog
    Handler handler = new Handler(Looper.getMainLooper()) {

        @Override
        public void handleMessage(Message inputMessage) {
            Context ctx = FileManagerApplication.getInstance();
            Intent intent = new Intent(ctx, SecureStorageKeyPromptActivity.class);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            ctx.startActivity(intent);
        }
    };
    handler.sendEmptyMessage(MSG_REQUEST_UNLOCK_DIALOG);
    // Wait for the response
    synchronized (WAIT_SYNC) {
        try {
            WAIT_SYNC.wait();
        } catch (InterruptedException ex) {
            throw new KeyPromptingInterruptedException(ex);
        }
    }
    // Request for authentication is done. We need to exit from delete status
    sDeleteInProgress = false;
    // Check if the user cancelled the dialog
    if (sUnlockKeyTemp == null) {
        throw new KeyPromptingCancelledException();
    }
    // Move temporary params to real params
    sUnlockKey = sUnlockKeyTemp;
    sOldUnlockKey = sOldUnlockKeyTemp;
    AesCipherParameters key = sUnlockKey;
    if (sResetInProgress && read) {
        key = sOldUnlockKey;
    }
    return key;
}
#end_block

#method_before
@Override
public void onAsyncEnd(boolean cancelled) {
/**
 * NON BLOCK*
 */
}
#method_after
@Override
public void onAsyncEnd(boolean cancelled) {
    if (!cancelled && StringHelper.isBinaryData(mByteBuffer.toByteArray())) {
        EditorActivity.this.mBinary = true;
        EditorActivity.this.mReadOnly = true;
    }
}
#end_block

#method_before
@Override
public void onPartialResult(Object result) {
    try {
        if (result == null)
            return;
        byte[] partial = (byte[]) result;
        // is read-only
        if (!EditorActivity.this.mReadOnly) {
            for (int i = 0; i < partial.length - 1; i++) {
                if (!StringHelper.isPrintableCharacter((char) partial[i])) {
                    EditorActivity.this.mBinary = true;
                    EditorActivity.this.mReadOnly = true;
                    break;
                }
            }
        }
        this.mByteBuffer.write(partial, 0, partial.length);
        this.mSize += partial.length;
        if (this.mListener != null && this.mReadFso != null) {
            int progress = 0;
            if (this.mReadFso.getSize() != 0) {
                progress = (int) ((this.mSize * 100) / this.mReadFso.getSize());
            }
            this.mListener.onProgress(progress);
        }
    } catch (Exception e) {
        this.mCause = e;
    }
}
#method_after
@Override
public void onPartialResult(Object result) {
    try {
        if (result == null)
            return;
        byte[] partial = (byte[]) result;
        this.mByteBuffer.write(partial, 0, partial.length);
        this.mSize += partial.length;
        if (this.mListener != null && this.mReadFso != null) {
            int progress = 0;
            if (this.mReadFso.getSize() != 0) {
                progress = (int) ((this.mSize * 100) / this.mReadFso.getSize());
            }
            this.mListener.onProgress(progress);
        }
    } catch (Exception e) {
        this.mCause = e;
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle state) {
    if (DEBUG) {
        // $NON-NLS-1$
        Log.d(TAG, "EditorActivity.onCreate");
    }
    this.mHandler = new Handler();
    // Load typeface for hex editor
    mHexTypeface = Typeface.createFromAsset(getAssets(), "fonts/Courier-Prime.ttf");
    // Register the broadcast receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(FileManagerSettings.INTENT_THEME_CHANGED);
    filter.addAction(FileManagerSettings.INTENT_SETTING_CHANGED);
    registerReceiver(this.mNotificationReceiver, filter);
    // Generate a random separator
    this.mHexLineSeparator = UUID.randomUUID().toString() + UUID.randomUUID().toString();
    // Set the theme before setContentView
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, false);
    // Set the main layout of the activity
    setContentView(R.layout.editor);
    // Get the limit vars
    this.mBufferSize = getResources().getInteger(R.integer.buffer_size);
    long availMem = AndroidHelper.getAvailableMemory(this);
    this.mMaxFileSize = Math.min(availMem, getResources().getInteger(R.integer.editor_max_file_size));
    // Initialize
    initTitleActionBar();
    initLayout();
    // Apply the theme
    applyTheme();
    // Initialize the console
    initializeConsole();
    // Read the file
    readFile();
    // Save state
    super.onCreate(state);
}
#method_after
@Override
protected void onCreate(Bundle state) {
    if (DEBUG) {
        // $NON-NLS-1$
        Log.d(TAG, "EditorActivity.onCreate");
    }
    this.mHandler = new Handler();
    // Load typeface for hex editor
    mHexTypeface = Typeface.createFromAsset(getAssets(), "fonts/Courier-Prime.ttf");
    // Save hexdump user preference
    mHexDump = Preferences.getSharedPreferences().getBoolean(FileManagerSettings.SETTINGS_EDITOR_HEXDUMP.getId(), ((Boolean) FileManagerSettings.SETTINGS_EDITOR_HEXDUMP.getDefaultValue()).booleanValue());
    // Register the broadcast receiver
    IntentFilter filter = new IntentFilter();
    filter.addAction(FileManagerSettings.INTENT_THEME_CHANGED);
    filter.addAction(FileManagerSettings.INTENT_SETTING_CHANGED);
    registerReceiver(this.mNotificationReceiver, filter);
    // Generate a random separator
    this.mHexLineSeparator = UUID.randomUUID().toString() + UUID.randomUUID().toString();
    // Set the theme before setContentView
    Theme theme = ThemeManager.getCurrentTheme(this);
    theme.setBaseTheme(this, false);
    // Set the main layout of the activity
    setContentView(R.layout.editor);
    // Get the limit vars
    this.mBufferSize = getResources().getInteger(R.integer.buffer_size);
    long availMem = AndroidHelper.getAvailableMemory(this);
    this.mMaxFileSize = Math.min(availMem, getResources().getInteger(R.integer.editor_max_file_size));
    // Initialize
    initTitleActionBar();
    initLayout();
    // Apply the theme
    applyTheme();
    // Initialize the console
    initializeConsole();
    // Read the file
    readFile();
    // Save state
    super.onCreate(state);
}
#end_block

#method_before
void asyncRead() {
    // Do the load of the file
    AsyncTask<FileSystemObject, Integer, Boolean> mReadTask = new AsyncTask<FileSystemObject, Integer, Boolean>() {

        private Exception mCause;

        private AsyncReader mReader;

        private boolean changeToBinaryMode;

        private boolean changeToDisplaying;

        @Override
        protected void onPreExecute() {
            // Show the progress
            this.changeToBinaryMode = false;
            this.changeToDisplaying = false;
            doProgress(true, 0);
        }

        @Override
        protected Boolean doInBackground(FileSystemObject... params) {
            final EditorActivity activity = EditorActivity.this;
            // Only one argument (the file to open)
            FileSystemObject fso = params[0];
            this.mCause = null;
            // Read the file in an async listener
            try {
                while (true) {
                    // Configure the reader
                    this.mReader = new AsyncReader();
                    this.mReader.mReadFso = fso;
                    this.mReader.mListener = new OnProgressListener() {

                        @Override
                        @SuppressWarnings("synthetic-access")
                        public void onProgress(int progress) {
                            publishProgress(Integer.valueOf(progress));
                        }
                    };
                    // Execute the command (read the file)
                    CommandHelper.read(activity, fso.getFullPath(), this.mReader, null);
                    // Wait for
                    synchronized (this.mReader.mSync) {
                        this.mReader.mSync.wait();
                    }
                    // 100%
                    publishProgress(new Integer(100));
                    // Check if the read was successfully
                    if (this.mReader.mCause != null) {
                        this.mCause = this.mReader.mCause;
                        return Boolean.FALSE;
                    }
                    break;
                }
                // Now we have the byte array with all the data. is a binary file?
                // Then dump them byte array to hex dump string (only if users settings
                // to dump file)
                boolean hexDump = Preferences.getSharedPreferences().getBoolean(FileManagerSettings.SETTINGS_EDITOR_HEXDUMP.getId(), ((Boolean) FileManagerSettings.SETTINGS_EDITOR_HEXDUMP.getDefaultValue()).booleanValue());
                if (activity.mBinary && hexDump) {
                    // we do not use the Hexdump helper class, because we need to show the
                    // progress of the dump process
                    final String data = toHexPrintableString(toHexDump(this.mReader.mByteBuffer.toByteArray()));
                    this.mReader.mBinaryBuffer = new ArrayList<String>();
                    BufferedReader reader = new BufferedReader(new StringReader(data));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        this.mReader.mBinaryBuffer.add(line);
                    }
                    // $NON-NLS-1$
                    Log.i(TAG, "Bytes read: " + data.length());
                } else {
                    final String data = new String(this.mReader.mByteBuffer.toByteArray());
                    this.mReader.mBuffer = new SpannableStringBuilder(data);
                    // $NON-NLS-1$
                    Log.i(TAG, "Bytes read: " + data.getBytes().length);
                }
                this.mReader.mByteBuffer = null;
                // 100%
                this.changeToDisplaying = true;
                publishProgress(new Integer(0));
            } catch (Exception e) {
                this.mCause = e;
                return Boolean.FALSE;
            }
            return Boolean.TRUE;
        }

        @Override
        protected void onProgressUpdate(Integer... values) {
            // Do progress
            doProgress(true, values[0].intValue());
        }

        @Override
        protected void onPostExecute(Boolean result) {
            final EditorActivity activity = EditorActivity.this;
            // Is error?
            if (!result.booleanValue()) {
                if (this.mCause != null) {
                    ExceptionUtil.translateException(activity, this.mCause);
                    activity.mEditor.setEnabled(false);
                }
            } else {
                // Now we have the buffer, set the text of the editor
                if (activity.mBinary) {
                    HexDumpAdapter adapter = new HexDumpAdapter(EditorActivity.this, this.mReader.mBinaryBuffer);
                    mBinaryEditor.setAdapter(adapter);
                    // Cleanup
                    this.mReader.mBinaryBuffer = null;
                } else {
                    activity.mEditor.setText(this.mReader.mBuffer, BufferType.EDITABLE);
                    // Highlight editor text syntax
                    if (activity.mSyntaxHighlight && activity.mSyntaxHighlightProcessor != null) {
                        try {
                            activity.mSyntaxHighlightProcessor.process(activity.mEditor.getText());
                        } catch (Exception ex) {
                            // An error in a syntax library, should not break down app.
                            // $NON-NLS-1$
                            Log.e(TAG, "Syntax highlight failed.", ex);
                        }
                    }
                    // Cleanup
                    this.mReader.mBuffer = null;
                }
                setDirty(false);
                activity.mEditor.setEnabled(!activity.mReadOnly);
                // Notify read-only mode
                if (activity.mReadOnly) {
                    DialogHelper.showToast(activity, R.string.editor_read_only_mode, Toast.LENGTH_SHORT);
                }
            }
            doProgress(false, 0);
        }

        @Override
        protected void onCancelled() {
            // Hide the progress
            doProgress(false, 0);
        }

        /**
         * Method that update the progress status
         *
         * @param visible If the progress bar need to be hidden
         * @param progress The progress
         */
        private void doProgress(boolean visible, int progress) {
            final EditorActivity activity = EditorActivity.this;
            // Show the progress bar
            activity.mProgressBar.setProgress(progress);
            activity.mProgress.setVisibility(visible ? View.VISIBLE : View.GONE);
            if (this.changeToBinaryMode) {
                mWordWrapView.setVisibility(View.GONE);
                mNoWordWrapView.setVisibility(View.GONE);
                mBinaryEditor.setVisibility(View.VISIBLE);
                // Show hex dumping text
                activity.mProgressBarMsg.setText(R.string.dumping_message);
                this.changeToBinaryMode = false;
            } else if (this.changeToDisplaying) {
                activity.mProgressBarMsg.setText(R.string.displaying_message);
                this.changeToDisplaying = false;
            }
        }

        /**
         * Create a hex dump of the data while show progress to user
         *
         * @param data The data to hex dump
         * @return StringBuilder The hex dump buffer
         */
        private String toHexDump(byte[] data) {
            // Change to binary mode
            this.changeToBinaryMode = true;
            // Start progress
            publishProgress(Integer.valueOf(0));
            // Calculate max dir size
            int length = data.length;
            // Bytes per line
            final int DISPLAY_SIZE = 16;
            ByteArrayInputStream bais = new ByteArrayInputStream(data);
            byte[] line = new byte[DISPLAY_SIZE];
            int read = 0;
            int offset = 0;
            StringBuilder sb = new StringBuilder();
            while ((read = bais.read(line, 0, DISPLAY_SIZE)) != -1) {
                // offset   dump(16)   data\n
                String linedata = new String(line, 0, read);
                sb.append(HexDump.toHexString(offset));
                // $NON-NLS-1$
                sb.append(" ");
                String hexDump = HexDump.toHexString(line, 0, read);
                if (hexDump.length() != (DISPLAY_SIZE * 2)) {
                    char[] array = new char[(DISPLAY_SIZE * 2) - hexDump.length()];
                    Arrays.fill(array, ' ');
                    hexDump += new String(array);
                }
                sb.append(hexDump);
                // $NON-NLS-1$
                sb.append(" ");
                sb.append(linedata);
                sb.append(EditorActivity.this.mHexLineSeparator);
                offset += DISPLAY_SIZE;
                if (offset % 5 == 0) {
                    publishProgress(Integer.valueOf((offset * 100) / length));
                }
            }
            // End of the dump process
            publishProgress(Integer.valueOf(100));
            return sb.toString();
        }

        /**
         * Method that converts to a visual printable hex string
         *
         * @param string The string to check
         */
        private String toHexPrintableString(String string) {
            // Remove characters without visual representation
            // $NON-NLS-1$
            final String REPLACED_SYMBOL = ".";
            // $NON-NLS-1$
            final String NEWLINE = System.getProperty("line.separator");
            // $NON-NLS-1$
            String printable = string.replaceAll("\\p{Cntrl}", REPLACED_SYMBOL);
            // $NON-NLS-1$
            printable = printable.replaceAll("[^\\p{Print}]", REPLACED_SYMBOL);
            // $NON-NLS-1$
            printable = printable.replaceAll("\\p{C}", REPLACED_SYMBOL);
            printable = printable.replaceAll(EditorActivity.this.mHexLineSeparator, NEWLINE);
            return printable;
        }
    };
    mReadTask.execute(this.mFso);
}
#method_after
void asyncRead() {
    // Do the load of the file
    AsyncTask<FileSystemObject, Integer, Boolean> mReadTask = new AsyncTask<FileSystemObject, Integer, Boolean>() {

        private Exception mCause;

        private AsyncReader mReader;

        private boolean changeToBinaryMode;

        private boolean changeToDisplaying;

        @Override
        protected void onPreExecute() {
            // Show the progress
            this.changeToBinaryMode = false;
            this.changeToDisplaying = false;
            doProgress(true, 0);
        }

        @Override
        protected Boolean doInBackground(FileSystemObject... params) {
            final EditorActivity activity = EditorActivity.this;
            // Only one argument (the file to open)
            FileSystemObject fso = params[0];
            this.mCause = null;
            // Read the file in an async listener
            try {
                while (true) {
                    // Configure the reader
                    this.mReader = new AsyncReader();
                    this.mReader.mReadFso = fso;
                    this.mReader.mListener = new OnProgressListener() {

                        @Override
                        @SuppressWarnings("synthetic-access")
                        public void onProgress(int progress) {
                            publishProgress(Integer.valueOf(progress));
                        }
                    };
                    // Execute the command (read the file)
                    CommandHelper.read(activity, fso.getFullPath(), this.mReader, null);
                    // Wait for
                    synchronized (this.mReader.mSync) {
                        this.mReader.mSync.wait();
                    }
                    // 100%
                    publishProgress(new Integer(100));
                    // Check if the read was successfully
                    if (this.mReader.mCause != null) {
                        this.mCause = this.mReader.mCause;
                        return Boolean.FALSE;
                    }
                    break;
                }
                // to dump file)
                if (activity.mBinary && mHexDump) {
                    // we do not use the Hexdump helper class, because we need to show the
                    // progress of the dump process
                    final String data = toHexPrintableString(toHexDump(this.mReader.mByteBuffer.toByteArray()));
                    this.mReader.mBinaryBuffer = new ArrayList<String>();
                    BufferedReader reader = new BufferedReader(new StringReader(data));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        this.mReader.mBinaryBuffer.add(line);
                    }
                    // $NON-NLS-1$
                    Log.i(TAG, "Bytes read: " + data.length());
                } else {
                    final String data = new String(this.mReader.mByteBuffer.toByteArray());
                    this.mReader.mBuffer = new SpannableStringBuilder(data);
                    // $NON-NLS-1$
                    Log.i(TAG, "Bytes read: " + data.getBytes().length);
                }
                this.mReader.mByteBuffer = null;
                // 100%
                this.changeToDisplaying = true;
                publishProgress(new Integer(0));
            } catch (Exception e) {
                this.mCause = e;
                return Boolean.FALSE;
            }
            return Boolean.TRUE;
        }

        @Override
        protected void onProgressUpdate(Integer... values) {
            // Do progress
            doProgress(true, values[0].intValue());
        }

        @Override
        protected void onPostExecute(Boolean result) {
            final EditorActivity activity = EditorActivity.this;
            // Is error?
            if (!result.booleanValue()) {
                if (this.mCause != null) {
                    ExceptionUtil.translateException(activity, this.mCause);
                    activity.mEditor.setEnabled(false);
                }
            } else {
                // Now we have the buffer, set the text of the editor
                if (activity.mBinary && mHexDump) {
                    HexDumpAdapter adapter = new HexDumpAdapter(EditorActivity.this, this.mReader.mBinaryBuffer);
                    mBinaryEditor.setAdapter(adapter);
                    // Cleanup
                    this.mReader.mBinaryBuffer = null;
                } else {
                    activity.mEditor.setText(this.mReader.mBuffer, BufferType.EDITABLE);
                    // Highlight editor text syntax
                    if (activity.mSyntaxHighlight && activity.mSyntaxHighlightProcessor != null) {
                        try {
                            activity.mSyntaxHighlightProcessor.process(activity.mEditor.getText());
                        } catch (Exception ex) {
                            // An error in a syntax library, should not break down app.
                            // $NON-NLS-1$
                            Log.e(TAG, "Syntax highlight failed.", ex);
                        }
                    }
                    // Cleanup
                    this.mReader.mBuffer = null;
                }
                setDirty(false);
                activity.mEditor.setEnabled(!activity.mReadOnly);
                // Notify read-only mode
                if (activity.mReadOnly) {
                    DialogHelper.showToast(activity, R.string.editor_read_only_mode, Toast.LENGTH_SHORT);
                }
            }
            doProgress(false, 0);
        }

        @Override
        protected void onCancelled() {
            // Hide the progress
            doProgress(false, 0);
        }

        /**
         * Method that update the progress status
         *
         * @param visible If the progress bar need to be hidden
         * @param progress The progress
         */
        private void doProgress(boolean visible, int progress) {
            final EditorActivity activity = EditorActivity.this;
            // Show the progress bar
            activity.mProgressBar.setProgress(progress);
            activity.mProgress.setVisibility(visible ? View.VISIBLE : View.GONE);
            if (this.changeToBinaryMode) {
                mWordWrapView.setVisibility(View.GONE);
                mNoWordWrapView.setVisibility(View.GONE);
                mBinaryEditor.setVisibility(View.VISIBLE);
                // Show hex dumping text
                activity.mProgressBarMsg.setText(R.string.dumping_message);
                this.changeToBinaryMode = false;
            } else if (this.changeToDisplaying) {
                activity.mProgressBarMsg.setText(R.string.displaying_message);
                this.changeToDisplaying = false;
            }
        }

        /**
         * Create a hex dump of the data while show progress to user
         *
         * @param data The data to hex dump
         * @return StringBuilder The hex dump buffer
         */
        private String toHexDump(byte[] data) {
            // Change to binary mode
            this.changeToBinaryMode = true;
            // Start progress
            publishProgress(Integer.valueOf(0));
            // Calculate max dir size
            int length = data.length;
            // Bytes per line
            final int DISPLAY_SIZE = 16;
            ByteArrayInputStream bais = new ByteArrayInputStream(data);
            byte[] line = new byte[DISPLAY_SIZE];
            int read = 0;
            int offset = 0;
            StringBuilder sb = new StringBuilder();
            while ((read = bais.read(line, 0, DISPLAY_SIZE)) != -1) {
                // offset   dump(16)   data\n
                String linedata = new String(line, 0, read);
                sb.append(HexDump.toHexString(offset));
                // $NON-NLS-1$
                sb.append(" ");
                String hexDump = HexDump.toHexString(line, 0, read);
                if (hexDump.length() != (DISPLAY_SIZE * 2)) {
                    char[] array = new char[(DISPLAY_SIZE * 2) - hexDump.length()];
                    Arrays.fill(array, ' ');
                    hexDump += new String(array);
                }
                sb.append(hexDump);
                // $NON-NLS-1$
                sb.append(" ");
                sb.append(linedata);
                sb.append(EditorActivity.this.mHexLineSeparator);
                offset += DISPLAY_SIZE;
                if (offset % 5 == 0) {
                    publishProgress(Integer.valueOf((offset * 100) / length));
                }
            }
            // End of the dump process
            publishProgress(Integer.valueOf(100));
            return sb.toString();
        }

        /**
         * Method that converts to a visual printable hex string
         *
         * @param string The string to check
         */
        private String toHexPrintableString(String string) {
            // Remove characters without visual representation
            // $NON-NLS-1$
            final String REPLACED_SYMBOL = ".";
            // $NON-NLS-1$
            final String NEWLINE = System.getProperty("line.separator");
            // $NON-NLS-1$
            String printable = string.replaceAll("\\p{Cntrl}", REPLACED_SYMBOL);
            // $NON-NLS-1$
            printable = printable.replaceAll("[^\\p{Print}]", REPLACED_SYMBOL);
            // $NON-NLS-1$
            printable = printable.replaceAll("\\p{C}", REPLACED_SYMBOL);
            printable = printable.replaceAll(EditorActivity.this.mHexLineSeparator, NEWLINE);
            return printable;
        }
    };
    mReadTask.execute(this.mFso);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Change the preference manager
    getPreferenceManager().setSharedPreferencesName(Preferences.SETTINGS_FILENAME);
    getPreferenceManager().setSharedPreferencesMode(Context.MODE_PRIVATE);
    // Add the preferences
    addPreferencesFromResource(R.xml.preferences_storage);
    // Reset password
    mResetPassword = findPreference(KEY_RESET_PASSWORD);
    mResetPassword.setOnPreferenceClickListener(mOnClickListener);
    // Drop storage
    mDropStorage = findPreference(KEY_DROP_STORAGE);
    mDropStorage.setOnPreferenceClickListener(mOnClickListener);
    // Delayed sync
    this.mDelayedSync = (CheckBoxPreference) findPreference(FileManagerSettings.SETTINGS_SECURE_STORAGE_DELAYED_SYNC.getId());
    this.mDelayedSync.setOnPreferenceChangeListener(this.mOnChangeListener);
    // Update the preferences
    updatePreferences();
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // Change the preference manager
    getPreferenceManager().setSharedPreferencesName(Preferences.SETTINGS_FILENAME);
    getPreferenceManager().setSharedPreferencesMode(Context.MODE_PRIVATE);
    // Add the preferences
    addPreferencesFromResource(R.xml.preferences_storage);
    // Reset password
    mResetPassword = findPreference(KEY_RESET_PASSWORD);
    mResetPassword.setOnPreferenceClickListener(mOnClickListener);
    // Delete storage
    mDeleteStorage = findPreference(KEY_DELETE_STORAGE);
    mDeleteStorage.setOnPreferenceClickListener(mOnClickListener);
    // Delayed sync
    this.mDelayedSync = (CheckBoxPreference) findPreference(FileManagerSettings.SETTINGS_SECURE_STORAGE_DELAYED_SYNC.getId());
    this.mDelayedSync.setOnPreferenceChangeListener(this.mOnChangeListener);
    // Update the preferences
    updatePreferences();
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private void updatePreferences() {
    boolean secureStorageExists = SecureConsole.getSecureStorageRoot().getFile().exists();
    if (mResetPassword != null) {
        mResetPassword.setEnabled(secureStorageExists);
    }
    if (mDropStorage != null) {
        mDropStorage.setEnabled(secureStorageExists);
    }
}
#method_after
@SuppressWarnings("deprecation")
private void updatePreferences() {
    boolean secureStorageExists = SecureConsole.getSecureStorageRoot().getFile().exists();
    if (mResetPassword != null) {
        mResetPassword.setEnabled(secureStorageExists);
    }
    if (mDeleteStorage != null) {
        mDeleteStorage.setEnabled(secureStorageExists);
    }
}
#end_block

#method_before
private void configureMenu(Menu menu) {
    // Selection
    List<FileSystemObject> selection = null;
    if (this.mOnSelectionListener != null) {
        selection = this.mOnSelectionListener.onRequestSelectedFiles();
    }
    // - Check actions that needs a valid reference
    if (!this.mGlobal && this.mFso != null) {
        // - Select/Deselect -> Only one of them
        if (this.mOnSelectionListener != null) {
            boolean selected = SelectionHelper.isFileSystemObjectSelected(this.mOnSelectionListener.onRequestSelectedFiles(), this.mFso);
            menu.removeItem(selected ? R.id.mnu_actions_select : R.id.mnu_actions_deselect);
        } else {
            // Remove both menus
            menu.removeItem(R.id.mnu_actions_select);
            menu.removeItem(R.id.mnu_actions_deselect);
            // Not allowed because we need a list of the current files (only from navigation
            // activity)
            menu.removeItem(R.id.mnu_actions_rename);
            menu.removeItem(R.id.mnu_actions_create_copy);
        }
        // - Open/Open with -> Only when the fso is not a folder and is not a system file
        if (FileHelper.isDirectory(this.mFso) || FileHelper.isSystemFile(this.mFso)) {
            menu.removeItem(R.id.mnu_actions_open);
            menu.removeItem(R.id.mnu_actions_open_with);
            menu.removeItem(R.id.mnu_actions_send);
        }
        // Create link (not allow in storage volume)
        if (StorageHelper.isPathInStorageVolume(this.mFso.getFullPath())) {
            menu.removeItem(R.id.mnu_actions_create_link);
        }
        // Execute only if mime/type category is EXEC
        MimeTypeCategory category = MimeTypeHelper.getCategory(this.mContext, this.mFso);
        if (category.compareTo(MimeTypeCategory.EXEC) != 0) {
            menu.removeItem(R.id.mnu_actions_execute);
        }
        // - Checksum (only supported for files)
        if (FileHelper.isDirectory(this.mFso) || this.mFso instanceof Symlink) {
            menu.removeItem(R.id.mnu_actions_compute_checksum);
        }
        // - Print (only for text and image categories)
        if (!PrintActionPolicy.isPrintedAllowed(mContext, mFso)) {
            menu.removeItem(R.id.mnu_actions_print);
        }
    }
    // - Add to bookmarks -> Only directories
    if (this.mFso != null && FileHelper.isRootDirectory(this.mFso)) {
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks);
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks_current_folder);
    }
    // - Paste/Move only when have a selection
    if (this.mGlobal) {
        if (selection == null || selection.size() == 0 || (this.mFso != null && !FileHelper.isDirectory(this.mFso))) {
            // Remove paste/move actions
            menu.removeItem(R.id.mnu_actions_paste_selection);
            menu.removeItem(R.id.mnu_actions_move_selection);
            menu.removeItem(R.id.mnu_actions_delete_selection);
        }
    }
    // - Create link
    if (this.mGlobal && (selection == null || selection.size() == 0 || selection.size() > 1)) {
        // Only when one item is selected
        menu.removeItem(R.id.mnu_actions_create_link_global);
    } else if (this.mGlobal && selection != null) {
        // Create link (not allow in sdcard, secure or remote storage volumes)
        FileSystemObject fso = selection.get(0);
        if (StorageHelper.isPathInStorageVolume(fso.getFullPath()) || fso.isSecure() || fso.isRemote()) {
            menu.removeItem(R.id.mnu_actions_create_link_global);
        }
    } else if (!this.mGlobal) {
        // Create link (not allow in sdcard, secure or remote storage volumes)
        if (StorageHelper.isPathInStorageVolume(this.mFso.getFullPath()) || mFso.isSecure() || mFso.isRemote()) {
            menu.removeItem(R.id.mnu_actions_create_link);
        }
    }
    // - Compress/Uncompress (only when selection is available)
    if (this.mOnSelectionListener != null) {
        // Compress
        if (this.mGlobal) {
            if (selection == null || selection.size() == 0) {
                menu.removeItem(R.id.mnu_actions_compress_selection);
            } else {
                for (FileSystemObject fso : selection) {
                    // Ignore for system, secure or remote files
                    if (fso instanceof SystemFile || fso.isSecure() || fso.isRemote()) {
                        menu.removeItem(R.id.mnu_actions_compress_selection);
                        break;
                    }
                }
            }
        } else {
            // Ignore for system, secure or remote files
            if (this.mFso instanceof SystemFile || mFso.isSecure() || mFso.isRemote()) {
                menu.removeItem(R.id.mnu_actions_compress);
            }
        }
        // Uncompress (Only supported files)
        if (!this.mGlobal && !FileHelper.isSupportedUncompressedFile(this.mFso)) {
            menu.removeItem(R.id.mnu_actions_extract);
        }
        // Send multiple (only regular files)
        if (this.mGlobal) {
            if (selection == null || selection.size() == 0) {
                menu.removeItem(R.id.mnu_actions_send_selection);
            } else {
                boolean areAllFiles = true;
                int cc = selection.size();
                for (int i = 0; i < cc; i++) {
                    FileSystemObject fso = selection.get(i);
                    if (FileHelper.isDirectory(fso)) {
                        areAllFiles = false;
                        break;
                    }
                }
                if (!areAllFiles) {
                    menu.removeItem(R.id.mnu_actions_send_selection);
                }
            }
        }
    }
    // Shotcuts and Bookmarks (not available in virtual filesystems)
    if (!mGlobal && (mFso.isSecure() || mFso.isRemote())) {
        menu.removeItem(R.id.mnu_actions_add_shortcut);
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks);
    } else if (mGlobal) {
        if (selection == null || selection.size() > 0) {
            for (FileSystemObject fso : selection) {
                if (fso.isSecure() || fso.isRemote()) {
                    menu.removeItem(R.id.mnu_actions_add_shortcut_current_folder);
                    menu.removeItem(R.id.mnu_actions_add_to_bookmarks_current_folder);
                    break;
                }
            }
        }
    }
    // Set as home
    if (!mGlobal && !FileHelper.isDirectory(mFso)) {
        menu.removeItem(R.id.mnu_actions_set_as_home);
    } else if (mGlobal && (selection != null && selection.size() > 0)) {
        menu.removeItem(R.id.mnu_actions_global_set_as_home);
    }
    // Not allowed in search
    if (this.mSearch) {
        menu.removeItem(R.id.mnu_actions_extract);
        menu.removeItem(R.id.mnu_actions_compress);
        menu.removeItem(R.id.mnu_actions_create_link);
    } else {
        // Not allowed if not in search
        menu.removeItem(R.id.mnu_actions_open_parent_folder);
    }
    // Remove unsafe operations over virtual directories
    List<Directory> virtualDirs = VirtualMountPointConsole.getVirtualMountableDirectories();
    if (!mGlobal && FileHelper.isDirectory(mFso) && virtualDirs.contains(mFso)) {
        menu.removeItem(R.id.mnu_actions_delete);
        menu.removeItem(R.id.mnu_actions_create_copy);
        menu.removeItem(R.id.mnu_actions_rename);
    } else if (mGlobal) {
        if (selection == null || selection.size() > 0) {
            for (FileSystemObject fso : selection) {
                if (FileHelper.isDirectory(fso) && virtualDirs.contains(fso)) {
                    menu.removeItem(R.id.mnu_actions_delete_selection);
                    break;
                }
            }
        }
    }
    // unprivileged mode)
    if (this.mChRooted) {
        menu.removeItem(R.id.mnu_actions_create_link);
        menu.removeItem(R.id.mnu_actions_create_link_global);
        menu.removeItem(R.id.mnu_actions_execute);
        // NOTE: This actions are not implemented in chrooted environments. The reason is
        // that the main target of this application is CyanogenMod (a rooted environment).
        // Adding this actions requires the use of commons-compress, an external Apache
        // library that will add more size to the ending apk.
        // For now, will maintain without implementation. Maybe, in the future.
        menu.removeItem(R.id.mnu_actions_compress);
        menu.removeItem(R.id.mnu_actions_compress_selection);
        menu.removeItem(R.id.mnu_actions_extract);
    }
}
#method_after
private void configureMenu(Menu menu) {
    // Selection
    List<FileSystemObject> selection = null;
    if (this.mOnSelectionListener != null) {
        selection = this.mOnSelectionListener.onRequestSelectedFiles();
    }
    // - Check actions that needs a valid reference
    if (!this.mGlobal && this.mFso != null) {
        // - Select/Deselect -> Only one of them
        if (this.mOnSelectionListener != null) {
            boolean selected = SelectionHelper.isFileSystemObjectSelected(this.mOnSelectionListener.onRequestSelectedFiles(), this.mFso);
            menu.removeItem(selected ? R.id.mnu_actions_select : R.id.mnu_actions_deselect);
        } else {
            // Remove both menus
            menu.removeItem(R.id.mnu_actions_select);
            menu.removeItem(R.id.mnu_actions_deselect);
            // Not allowed because we need a list of the current files (only from navigation
            // activity)
            menu.removeItem(R.id.mnu_actions_rename);
            menu.removeItem(R.id.mnu_actions_create_copy);
        }
        // - Open/Open with -> Only when the fso is not a folder and is not a system file
        if (FileHelper.isDirectory(this.mFso) || FileHelper.isSystemFile(this.mFso)) {
            menu.removeItem(R.id.mnu_actions_open);
            menu.removeItem(R.id.mnu_actions_open_with);
            menu.removeItem(R.id.mnu_actions_send);
        }
        // Create link (not allow in storage volume)
        if (StorageHelper.isPathInStorageVolume(this.mFso.getFullPath())) {
            menu.removeItem(R.id.mnu_actions_create_link);
        }
        // Execute only if mime/type category is EXEC
        MimeTypeCategory category = MimeTypeHelper.getCategory(this.mContext, this.mFso);
        if (category.compareTo(MimeTypeCategory.EXEC) != 0) {
            menu.removeItem(R.id.mnu_actions_execute);
        }
        // - Checksum (only supported for files)
        if (FileHelper.isDirectory(this.mFso) || this.mFso instanceof Symlink) {
            menu.removeItem(R.id.mnu_actions_compute_checksum);
        }
        // - Print (only for text and image categories)
        if (!PrintActionPolicy.isPrintedAllowed(mContext, mFso)) {
            menu.removeItem(R.id.mnu_actions_print);
        }
    }
    // - Add to bookmarks -> Only directories
    if (this.mFso != null && FileHelper.isRootDirectory(this.mFso)) {
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks);
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks_current_folder);
    }
    // - Paste/Move only when have a selection
    if (this.mGlobal) {
        if (selection == null || selection.size() == 0 || (this.mFso != null && !FileHelper.isDirectory(this.mFso))) {
            // Remove paste/move actions
            menu.removeItem(R.id.mnu_actions_paste_selection);
            menu.removeItem(R.id.mnu_actions_move_selection);
            menu.removeItem(R.id.mnu_actions_delete_selection);
        }
    }
    // - Create link
    if (this.mGlobal && (selection == null || selection.size() == 0 || selection.size() > 1)) {
        // Only when one item is selected
        menu.removeItem(R.id.mnu_actions_create_link_global);
    } else if (this.mGlobal && selection != null) {
        // Create link (not allow in sdcard, secure or remote storage volumes)
        FileSystemObject fso = selection.get(0);
        if (StorageHelper.isPathInStorageVolume(fso.getFullPath()) || fso.isSecure() || fso.isRemote()) {
            menu.removeItem(R.id.mnu_actions_create_link_global);
        }
    } else if (!this.mGlobal) {
        // Create link (not allow in sdcard, secure or remote storage volumes)
        if (StorageHelper.isPathInStorageVolume(this.mFso.getFullPath()) || mFso.isSecure() || mFso.isRemote()) {
            menu.removeItem(R.id.mnu_actions_create_link);
        }
    }
    // - Compress/Uncompress (only when selection is available)
    if (this.mOnSelectionListener != null) {
        // Compress
        if (this.mGlobal) {
            if (selection == null || selection.size() == 0) {
                menu.removeItem(R.id.mnu_actions_compress_selection);
            } else {
                for (FileSystemObject fso : selection) {
                    // Ignore for system, secure or remote files
                    if (fso instanceof SystemFile || fso.isSecure() || fso.isRemote()) {
                        menu.removeItem(R.id.mnu_actions_compress_selection);
                        break;
                    }
                }
            }
        } else {
            // Ignore for system, secure or remote files
            if (this.mFso instanceof SystemFile || mFso.isSecure() || mFso.isRemote()) {
                menu.removeItem(R.id.mnu_actions_compress);
            }
        }
        // Uncompress (Only supported files)
        if (!this.mGlobal && !FileHelper.isSupportedUncompressedFile(this.mFso)) {
            menu.removeItem(R.id.mnu_actions_extract);
        }
        // Send multiple (only regular files)
        if (this.mGlobal) {
            if (selection == null || selection.size() == 0) {
                menu.removeItem(R.id.mnu_actions_send_selection);
            } else {
                boolean areAllFiles = true;
                int cc = selection.size();
                for (int i = 0; i < cc; i++) {
                    FileSystemObject fso = selection.get(i);
                    if (FileHelper.isDirectory(fso)) {
                        areAllFiles = false;
                        break;
                    }
                }
                if (!areAllFiles) {
                    menu.removeItem(R.id.mnu_actions_send_selection);
                }
            }
        }
    }
    // Shotcuts and Bookmarks (not available in virtual filesystems)
    if (!mGlobal && (mFso.isSecure() || mFso.isRemote())) {
        menu.removeItem(R.id.mnu_actions_add_shortcut);
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks);
    } else if (mGlobal) {
        if (selection != null && selection.size() > 0) {
            for (FileSystemObject fso : selection) {
                if (fso.isSecure() || fso.isRemote()) {
                    menu.removeItem(R.id.mnu_actions_add_shortcut_current_folder);
                    menu.removeItem(R.id.mnu_actions_add_to_bookmarks_current_folder);
                    break;
                }
            }
        }
    }
    // Set as home
    if (!mGlobal && !FileHelper.isDirectory(mFso)) {
        menu.removeItem(R.id.mnu_actions_set_as_home);
    } else if (mGlobal && (selection != null && selection.size() > 0)) {
        menu.removeItem(R.id.mnu_actions_global_set_as_home);
    }
    // Not allowed in search
    if (this.mSearch) {
        menu.removeItem(R.id.mnu_actions_extract);
        menu.removeItem(R.id.mnu_actions_compress);
        menu.removeItem(R.id.mnu_actions_create_link);
    } else {
        // Not allowed if not in search
        menu.removeItem(R.id.mnu_actions_open_parent_folder);
    }
    // Remove unsafe operations over virtual mountpoint directories
    List<Directory> virtualDirs = VirtualMountPointConsole.getVirtualMountableDirectories();
    if (!mGlobal && FileHelper.isDirectory(mFso) && virtualDirs.contains(mFso)) {
        menu.removeItem(R.id.mnu_actions_delete);
        menu.removeItem(R.id.mnu_actions_rename);
        menu.removeItem(R.id.mnu_actions_compress);
        menu.removeItem(R.id.mnu_actions_create_copy);
        menu.removeItem(R.id.mnu_actions_create_link);
        menu.removeItem(R.id.mnu_actions_add_shortcut);
        menu.removeItem(R.id.mnu_actions_add_to_bookmarks);
    } else if (mGlobal) {
        if (selection != null && selection.size() > 0) {
            for (FileSystemObject fso : selection) {
                if (FileHelper.isDirectory(fso) && virtualDirs.contains(fso)) {
                    menu.removeItem(R.id.mnu_actions_paste_selection);
                    menu.removeItem(R.id.mnu_actions_move_selection);
                    menu.removeItem(R.id.mnu_actions_delete_selection);
                    menu.removeItem(R.id.mnu_actions_compress_selection);
                    menu.removeItem(R.id.mnu_actions_create_link_global);
                    menu.removeItem(R.id.mnu_actions_send_selection);
                    menu.removeItem(R.id.mnu_actions_create_link_global);
                    menu.removeItem(R.id.mnu_actions_create_link_global);
                    menu.removeItem(R.id.mnu_actions_create_link_global);
                    menu.removeItem(R.id.mnu_actions_add_shortcut_current_folder);
                    menu.removeItem(R.id.mnu_actions_add_to_bookmarks_current_folder);
                    break;
                }
            }
        }
    }
    // unprivileged mode)
    if (this.mChRooted) {
        menu.removeItem(R.id.mnu_actions_create_link);
        menu.removeItem(R.id.mnu_actions_create_link_global);
        menu.removeItem(R.id.mnu_actions_execute);
        // NOTE: This actions are not implemented in chrooted environments. The reason is
        // that the main target of this application is CyanogenMod (a rooted environment).
        // Adding this actions requires the use of commons-compress, an external Apache
        // library that will add more size to the ending apk.
        // For now, will maintain without implementation. Maybe, in the future.
        menu.removeItem(R.id.mnu_actions_compress);
        menu.removeItem(R.id.mnu_actions_compress_selection);
        menu.removeItem(R.id.mnu_actions_extract);
    }
}
#end_block

#method_before
@Override
protected void onCreate(Bundle state) {
    // Save state
    super.onCreate(state);
    // Set the main layout of the activity
    setContentView(R.layout.navigation);
    mProvidersMap = new HashMap<Integer, StorageProviderInfo>();
    mStorageBookmarks = new HashMap<Integer, Bookmark>();
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    mNavigationDrawer = (NavigationView) findViewById(R.id.navigation_view);
    mNavigationDrawer.setNavigationItemSelectedListener(this);
    ColorStateList colorStateList = new ColorStateList(color_states, colors);
    // TODO: Figure out why the following doesn't work correctly...
    mNavigationDrawer.setItemTextColor(colorStateList);
    mNavigationDrawer.setItemIconTintList(colorStateList);
    loadNavigationDrawerItems();
    MIME_TYPE_LOCALIZED_NAMES = MimeTypeCategory.getFriendlyLocalizedNames(this);
    showWelcomeMsg();
    setCurrentFragment(FragmentType.HOME);
    // Initialize nfc adapter
    NfcAdapter mNfcAdapter = NfcAdapter.getDefaultAdapter(this);
    if (mNfcAdapter != null) {
        mNfcAdapter.setBeamPushUrisCallback(new NfcAdapter.CreateBeamUrisCallback() {

            @Override
            public android.net.Uri[] createBeamUris(android.nfc.NfcEvent event) {
                if (currentFragment instanceof NavigationFragment) {
                    List<FileSystemObject> selectedFiles = ((NavigationFragment) currentFragment).getCurrentNavigationView().getSelectedFiles();
                    if (selectedFiles.size() > 0) {
                        List<android.net.Uri> fileUri = new ArrayList<Uri>();
                        for (FileSystemObject f : selectedFiles) {
                            // Beam ignores folders and system files
                            if (!FileHelper.isDirectory(f) && !FileHelper.isSystemFile(f)) {
                                fileUri.add(Uri.fromFile(new File(f.getFullPath())));
                            }
                        }
                        if (fileUri.size() > 0) {
                            return fileUri.toArray(new android.net.Uri[fileUri.size()]);
                        }
                    }
                }
                return null;
            }
        }, this);
    }
}
#method_after
@Override
protected void onCreate(Bundle state) {
    // Save state
    super.onCreate(state);
    // Set the main layout of the activity
    setContentView(R.layout.navigation);
    mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
    NavigationView navigationDrawer = (NavigationView) findViewById(R.id.navigation_view);
    navigationDrawer.setNavigationItemSelectedListener(this);
    mNavigationDrawerController = new NavigationDrawerController(this, navigationDrawer);
    mNavigationDrawerController.loadNavigationDrawerItems();
    MIME_TYPE_LOCALIZED_NAMES = MimeTypeCategory.getFriendlyLocalizedNames(this);
    showWelcomeMsg();
    setCurrentFragment(FragmentType.HOME);
    // Initialize nfc adapter
    NfcAdapter mNfcAdapter = NfcAdapter.getDefaultAdapter(this);
    if (mNfcAdapter != null) {
        mNfcAdapter.setBeamPushUrisCallback(new NfcAdapter.CreateBeamUrisCallback() {

            @Override
            public android.net.Uri[] createBeamUris(android.nfc.NfcEvent event) {
                if (currentFragment instanceof NavigationFragment) {
                    List<FileSystemObject> selectedFiles = ((NavigationFragment) currentFragment).getCurrentNavigationView().getSelectedFiles();
                    if (selectedFiles.size() > 0) {
                        List<android.net.Uri> fileUri = new ArrayList<Uri>();
                        for (FileSystemObject f : selectedFiles) {
                            // Beam ignores folders and system files
                            if (!FileHelper.isDirectory(f) && !FileHelper.isSystemFile(f)) {
                                fileUri.add(Uri.fromFile(new File(f.getFullPath())));
                            }
                        }
                        if (fileUri.size() > 0) {
                            return fileUri.toArray(new android.net.Uri[fileUri.size()]);
                        }
                    }
                }
                return null;
            }
        }, this);
    }
}
#end_block

#method_before
@Override
public boolean onNavigationItemSelected(MenuItem menuItem) {
    menuItem.setChecked(false);
    int id = menuItem.getItemId();
    switch(id) {
        case R.id.navigation_item_home:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_home");
            setCurrentFragment(FragmentType.HOME);
            break;
        case R.id.navigation_item_favorites:
            // TODO: Implement this path
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_favorites");
            break;
        case R.id.navigation_item_internal:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_favorites");
            getIntent().putExtra(EXTRA_NAVIGATE_TO, StorageHelper.getLocalStoragePath(this));
            setCurrentFragment(FragmentType.NAVIGATION);
            break;
        case R.id.navigation_item_root_d:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_root_d");
            getIntent().putExtra(EXTRA_NAVIGATE_TO, FileHelper.ROOT_DIRECTORY);
            setCurrentFragment(FragmentType.NAVIGATION);
            break;
        case R.id.navigation_item_protected:
            // TODO: Implement this path
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_protected");
            break;
        case R.id.navigation_item_manage:
            // TODO: Implement this path
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_manage");
            break;
        case R.id.navigation_item_settings:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_settings");
            openSettings();
            break;
        default:
            if (DEBUG)
                Log.d(TAG, String.format("onNavigationItemSelected::default (%d)", id));
            String path = null;
            // Check for item id in storage bookmarks
            Bookmark bookmark = mStorageBookmarks.get(id);
            if (bookmark != null) {
                path = bookmark.getPath();
            } else {
                // Check for item id in remote roots
                StorageProviderInfo providerInfo = mProvidersMap.get(id);
                if (providerInfo != null) {
                    path = StorageApiConsole.constructStorageApiFilePathFromProvider(providerInfo.getRootDocumentId(), StorageApiConsole.getHashCodeFromProvider(providerInfo));
                }
            }
            if (!TextUtils.isEmpty(path)) {
                // Check for item id in remote roots
                getIntent().putExtra(EXTRA_NAVIGATE_TO, path);
                setCurrentFragment(FragmentType.NAVIGATION);
            } else {
                return false;
            }
            break;
    }
    mDrawerLayout.closeDrawers();
    return true;
}
#method_after
@Override
public boolean onNavigationItemSelected(MenuItem menuItem) {
    menuItem.setChecked(false);
    int id = menuItem.getItemId();
    switch(id) {
        case R.id.navigation_item_home:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_home");
            setCurrentFragment(FragmentType.HOME);
            break;
        case R.id.navigation_item_favorites:
            // TODO: Implement this path
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_favorites");
            break;
        case R.id.navigation_item_internal:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_favorites");
            getIntent().putExtra(EXTRA_NAVIGATE_TO, StorageHelper.getLocalStoragePath(this));
            setCurrentFragment(FragmentType.NAVIGATION);
            break;
        case R.id.navigation_item_root_d:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_root_d");
            getIntent().putExtra(EXTRA_NAVIGATE_TO, FileHelper.ROOT_DIRECTORY);
            setCurrentFragment(FragmentType.NAVIGATION);
            break;
        case R.id.navigation_item_protected:
            // TODO: Implement this path
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_protected");
            break;
        case R.id.navigation_item_manage:
            // TODO: Implement this path
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_manage");
            break;
        case R.id.navigation_item_settings:
            if (DEBUG)
                Log.d(TAG, "onNavigationItemSelected::navigation_item_settings");
            openSettings();
            break;
        default:
            if (DEBUG)
                Log.d(TAG, String.format("onNavigationItemSelected::default (%d)", id));
            String path = null;
            // Check for item id in storage bookmarks
            Bookmark bookmark = mNavigationDrawerController.getBookmarkFromMenuItem(id);
            if (bookmark != null) {
                path = bookmark.getPath();
            } else {
                // Check for item id in remote roots
                StorageProviderInfo providerInfo = mNavigationDrawerController.getProviderInfoFromMenuItem(id);
                if (providerInfo != null) {
                    path = StorageApiConsole.constructStorageApiFilePathFromProvider(providerInfo.getRootDocumentId(), StorageApiConsole.getHashCodeFromProvider(providerInfo));
                }
            }
            if (!TextUtils.isEmpty(path)) {
                // Check for item id in remote roots
                getIntent().putExtra(EXTRA_NAVIGATE_TO, path);
                setCurrentFragment(FragmentType.NAVIGATION);
            } else {
                return false;
            }
            break;
    }
    mDrawerLayout.closeDrawers();
    return true;
}
#end_block

#method_before
@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == INTENT_REQUEST_SETTINGS) {
        // reset bookmarks list to default as the user could changed the
        // root mode which changes the system bookmarks
        loadNavigationDrawerItems();
        return;
    }
}
#method_after
@Override
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    if (requestCode == INTENT_REQUEST_SETTINGS) {
        // reset bookmarks list to default as the user could changed the
        // root mode which changes the system bookmarks
        mNavigationDrawerController.loadNavigationDrawerItems();
        return;
    }
}
#end_block

#method_before
public static WriteExecutable write(Context context, String parent, String name, AsyncResultListener asyncResultListener, Console console) throws FileNotFoundException, IOException, ConsoleAllocException, NoSuchFileOrDirectory, InsufficientPermissionsException, CommandNotFoundException, OperationTimeoutException, ExecutionException, InvalidCommandDefinitionException, ReadOnlyFilesystemException, CancelledOperationException {
    Console c = ensureConsoleForFile(context, console, parent);
    // Create a wrapper listener, for unmount the filesystem if necessary
    UnmountAsyncResultListener wrapperListener = new UnmountAsyncResultListener();
    wrapperListener.mCtx = context;
    wrapperListener.mConsole = c;
    wrapperListener.mRef = asyncResultListener;
    // Prior to write to disk the data, ensure that can write to the disk using
    // createFile method
    // - Create
    CreateFileExecutable executable1 = c.getExecutableFactory().newCreator().createCreateFileExecutable(parent, name);
    boolean unmount = writableExecute(context, executable1, c, true);
    String path = executable1.getResult();
    if (!TextUtils.isEmpty(path)) {
        // Configure the rest of attributes of the wrapper listener
        wrapperListener.mUnmount = unmount;
        wrapperListener.mMountPoint = executable1.getDstWritableMountPoint();
        // - Write
        WriteExecutable executable2 = c.getExecutableFactory().newCreator().createWriteExecutable(path, wrapperListener);
        execute(context, executable2, c);
        return executable2;
    }
    // $NON-NLS-1$
    throw new ExecutionException(String.format("Fail to create file %s", parent));
}
#method_after
public static WriteExecutable write(Context context, String parent, String name, AsyncResultListener asyncResultListener, Console console) throws FileNotFoundException, IOException, ConsoleAllocException, NoSuchFileOrDirectory, InsufficientPermissionsException, CommandNotFoundException, OperationTimeoutException, ExecutionException, InvalidCommandDefinitionException, ReadOnlyFilesystemException, CancelledOperationException {
    Console c = ensureConsoleForFile(context, console, parent);
    // Create a wrapper listener, for unmount the filesystem if necessary
    UnmountAsyncResultListener wrapperListener = new UnmountAsyncResultListener();
    wrapperListener.mCtx = context;
    wrapperListener.mConsole = c;
    wrapperListener.mRef = asyncResultListener;
    // Prior to write to disk the data, ensure that can write to the disk using
    // createFile method
    // - Create
    CreateFileExecutable executable1 = c.getExecutableFactory().newCreator().createCreateFileExecutable(parent, name);
    boolean unmount = writableExecute(context, executable1, c, true);
    String path = executable1.getResult();
    if (!TextUtils.isEmpty(path)) {
        // Configure the rest of attributes of the wrapper listener
        wrapperListener.mUnmount = unmount;
        wrapperListener.mMountPoint = executable1.getDstWritableMountPoint();
        // - Write
        WriteExecutable executable2 = c.getExecutableFactory().newCreator().createWriteExecutable(path, wrapperListener);
        execute(context, executable2, c);
        return executable2;
    }
    // $NON-NLS-1$
    throw new ExecutionException(String.format("Fail to create file %s in %s", name, parent));
}
#end_block

#method_before
@Test
public void testClickNextOnWelcomePage() {
    onView(withText("Welcome to")).check(matches(isDisplayed()));
    onView(withId(R.id.prevButton)).check(matches(withEffectiveVisibility(Visibility.INVISIBLE)));
    onView(withId(R.id.nextButton)).perform(click());
}
#method_after
@Test
public void testClickNextOnWelcomePage() {
    goThroughWelcomePages();
    onView(withId(R.id.prevButton)).perform(click());
    // Third page, to go back to the second page
    onView(withId(R.id.nextButton)).check(matches(isDisplayed()));
    onView(withId(R.id.pagination)).check(matches(isDisplayed()));
    onView(withId(R.id.prevButton)).perform(click());
    // Second page, to go back to the first page
    onView(withId(R.id.titleMessageOne)).check(matches(withText(R.string.second_title)));
    onView(withId(R.id.bottomMessageOne)).check(matches(withText(R.string.first_message)));
    onView(withId(R.id.nextButton)).check(matches(isDisplayed()));
    onView(withId(R.id.pagination)).check(matches(isDisplayed()));
    onView(withId(R.id.prevButton)).perform(click());
    goThroughWelcomePages();
    onView(withId(R.id.nextButton)).perform(click());
}
#end_block

#method_before
private static Intent getFsoSendIntent(final Context ctx, final List<FileSystemObject> fsos) {
    Intent intent = new Intent();
    intent.setAction(fsos.size() > 1 ? Intent.ACTION_SEND_MULTIPLE : Intent.ACTION_SEND);
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Create an array list of the uris to send
    ArrayList<Uri> uris = new ArrayList<Uri>();
    int cc = fsos.size();
    String lastMimeType = null;
    boolean sameMimeType = true;
    for (int i = 0; i < cc; i++) {
        FileSystemObject fso = fsos.get(i);
        // Folders are not allowed
        if (FileHelper.isDirectory(fso))
            continue;
        // Check if we can use a unique mime/type
        String mimeType = MimeTypeHelper.getMimeType(ctx, fso);
        if (mimeType == null) {
            sameMimeType = false;
        }
        if (sameMimeType && (mimeType != null && lastMimeType != null && mimeType.compareTo(lastMimeType) != 0)) {
            sameMimeType = false;
        }
        lastMimeType = mimeType;
        // Add the uri
        uris.add(getUriFromFile(ctx, fso));
    }
    if (lastMimeType != null) {
        if (sameMimeType) {
            intent.setType(lastMimeType);
        } else {
            intent.setType(MimeTypeHelper.ALL_MIME_TYPES);
        }
    }
    if (uris.size() > 1) {
        intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);
    } else if (uris.size() > 0) {
        intent.putExtra(Intent.EXTRA_STREAM, uris.get(0));
    }
    return intent;
}
#method_after
private static Intent getFsoSendIntent(final Context ctx, final List<FileSystemObject> fsos) {
    Intent intent = new Intent();
    intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Create an array list of the uris to send
    ArrayList<Uri> uris = new ArrayList<Uri>();
    int cc = fsos.size();
    String lastMimeType = null;
    boolean sameMimeType = true;
    for (int i = 0; i < cc; i++) {
        FileSystemObject fso = fsos.get(i);
        // Folders are not allowed
        if (FileHelper.isDirectory(fso))
            continue;
        // Check if we can use a unique mime/type
        String mimeType = MimeTypeHelper.getMimeType(ctx, fso);
        if (mimeType == null) {
            sameMimeType = false;
        }
        if (sameMimeType && (mimeType != null && lastMimeType != null && mimeType.compareTo(lastMimeType) != 0)) {
            sameMimeType = false;
        }
        lastMimeType = mimeType;
        // Add the uri
        uris.add(getUriFromFile(ctx, fso));
    }
    if (lastMimeType != null) {
        if (sameMimeType) {
            intent.setType(lastMimeType);
        } else {
            intent.setType(MimeTypeHelper.ALL_MIME_TYPES);
        }
    }
    if (uris.size() == 1) {
        intent.setAction(Intent.ACTION_SEND);
        intent.putExtra(Intent.EXTRA_STREAM, uris.get(0));
    } else {
        intent.setAction(Intent.ACTION_SEND_MULTIPLE);
        intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);
    }
    return intent;
}
#end_block

#method_before
@Override
public void onReceive(final Context context, final Intent intent) {
    final String intentAction = intent.getAction();
    if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intentAction)) {
        final Intent i = new Intent(context, MusicPlaybackService.class);
        i.setAction(MusicPlaybackService.SERVICECMD);
        i.putExtra(MusicPlaybackService.CMDNAME, MusicPlaybackService.CMDPAUSE);
        context.startService(i);
    } else if (Intent.ACTION_MEDIA_BUTTON.equals(intentAction)) {
        final KeyEvent event = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
        if (event == null) {
            return;
        }
        final int keycode = event.getKeyCode();
        final int action = event.getAction();
        final long eventtime = event.getEventTime();
        String command = null;
        switch(keycode) {
            case KeyEvent.KEYCODE_MEDIA_STOP:
                command = MusicPlaybackService.CMDSTOP;
                break;
            case KeyEvent.KEYCODE_HEADSETHOOK:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                command = MusicPlaybackService.CMDTOGGLEPAUSE;
                break;
            case KeyEvent.KEYCODE_MEDIA_NEXT:
                command = MusicPlaybackService.CMDNEXT;
                break;
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
                command = MusicPlaybackService.CMDPREVIOUS;
                break;
            case KeyEvent.KEYCODE_MEDIA_PAUSE:
                command = MusicPlaybackService.CMDPAUSE;
                break;
            case KeyEvent.KEYCODE_MEDIA_PLAY:
                command = MusicPlaybackService.CMDPLAY;
                break;
        }
        if (command != null) {
            if (action == KeyEvent.ACTION_DOWN) {
                if (mDown) {
                    if ((MusicPlaybackService.CMDTOGGLEPAUSE.equals(command) || MusicPlaybackService.CMDPLAY.equals(command)) && mLastClickTime != 0 && eventtime - mLastClickTime > LONG_PRESS_DELAY) {
                        mHandler.sendMessage(mHandler.obtainMessage(MSG_LONGPRESS_TIMEOUT, context));
                    }
                } else if (event.getRepeatCount() == 0) {
                    // Only consider the first event in a sequence, not the
                    // repeat events,
                    // so that we don't trigger in cases where the first
                    // event went to
                    // a different app (e.g. when the user ends a phone call
                    // by
                    // long pressing the headset button)
                    // The service may or may not be running, but we need to
                    // send it
                    // a command.
                    final Intent i = new Intent(context, MusicPlaybackService.class);
                    i.setAction(MusicPlaybackService.SERVICECMD);
                    if (keycode == KeyEvent.KEYCODE_HEADSETHOOK && eventtime - mLastClickTime < DOUBLE_CLICK && eventtime - mLastLastClickTime >= 2 * DOUBLE_CLICK) {
                        // handles double click.
                        i.putExtra(MusicPlaybackService.CMDNAME, MusicPlaybackService.CMDNEXT);
                        context.startService(i);
                        mLastLastClickTime = mLastClickTime;
                        mLastClickTime = eventtime;
                    } else if (keycode == KeyEvent.KEYCODE_HEADSETHOOK && eventtime - mLastClickTime < DOUBLE_CLICK && eventtime - mLastLastClickTime < 2 * DOUBLE_CLICK) {
                        // handle triple click
                        i.putExtra(MusicPlaybackService.CMDNAME, MusicPlaybackService.CMDPREVIOUS);
                        context.startService(i);
                        // Second time because we just went forward once so the previous is
                        // an undo action.
                        i.putExtra(MusicPlaybackService.CMDNAME, MusicPlaybackService.CMDPREVIOUS);
                        context.startService(i);
                        mLastClickTime = 0;
                        mLastLastClickTime = 0;
                    } else {
                        i.putExtra(MusicPlaybackService.CMDNAME, command);
                        context.startService(i);
                        mLastLastClickTime = mLastClickTime;
                        mLastClickTime = eventtime;
                    }
                    mLaunched = false;
                    mDown = true;
                }
            } else {
                mHandler.removeMessages(MSG_LONGPRESS_TIMEOUT);
                mDown = false;
            }
            if (isOrderedBroadcast()) {
                abortBroadcast();
            }
        }
    }
}
#method_after
@Override
public void onReceive(final Context context, final Intent intent) {
    final String intentAction = intent.getAction();
    if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intentAction)) {
        final Intent i = new Intent(context, MusicPlaybackService.class);
        i.setAction(MusicPlaybackService.SERVICECMD);
        i.putExtra(MusicPlaybackService.CMDNAME, MusicPlaybackService.CMDPAUSE);
        context.startService(i);
    } else if (Intent.ACTION_MEDIA_BUTTON.equals(intentAction)) {
        final KeyEvent event = (KeyEvent) intent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
        if (event == null) {
            return;
        }
        final int keycode = event.getKeyCode();
        final int action = event.getAction();
        final long eventtime = event.getEventTime();
        String command = null;
        switch(keycode) {
            case KeyEvent.KEYCODE_MEDIA_STOP:
                command = MusicPlaybackService.CMDSTOP;
                break;
            case KeyEvent.KEYCODE_HEADSETHOOK:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                command = MusicPlaybackService.CMDTOGGLEPAUSE;
                break;
            case KeyEvent.KEYCODE_MEDIA_NEXT:
                command = MusicPlaybackService.CMDNEXT;
                break;
            case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
                command = MusicPlaybackService.CMDPREVIOUS;
                break;
            case KeyEvent.KEYCODE_MEDIA_PAUSE:
                command = MusicPlaybackService.CMDPAUSE;
                break;
            case KeyEvent.KEYCODE_MEDIA_PLAY:
                command = MusicPlaybackService.CMDPLAY;
                break;
        }
        if (command != null) {
            if (action == KeyEvent.ACTION_DOWN) {
                if (mDown) {
                    if ((MusicPlaybackService.CMDTOGGLEPAUSE.equals(command) || MusicPlaybackService.CMDPLAY.equals(command)) && mLastClickTime != 0 && eventtime - mLastClickTime > LONG_PRESS_DELAY) {
                        mHandler.sendMessage(mHandler.obtainMessage(MSG_LONGPRESS_TIMEOUT, context));
                    }
                } else if (event.getRepeatCount() == 0) {
                    // a command.
                    if (keycode == KeyEvent.KEYCODE_HEADSETHOOK) {
                        if (eventtime - mLastClickTime >= DOUBLE_CLICK) {
                            mClickCounter = 0;
                        }
                        mClickCounter++;
                        if (DEBUG)
                            Log.v(TAG, "Got headset click, count = " + mClickCounter);
                        mHandler.removeMessages(MSG_HEADSET_DOUBLE_CLICK_TIMEOUT);
                        Message msg = mHandler.obtainMessage(MSG_HEADSET_DOUBLE_CLICK_TIMEOUT, mClickCounter, 0, context);
                        if (mClickCounter < 3) {
                            mHandler.sendMessageDelayed(msg, DOUBLE_CLICK);
                        } else {
                            mHandler.sendMessage(msg);
                            mClickCounter = 0;
                        }
                        mLastClickTime = eventtime;
                    } else {
                        final Intent i = new Intent(context, MusicPlaybackService.class);
                        i.setAction(MusicPlaybackService.SERVICECMD);
                        i.putExtra(MusicPlaybackService.CMDNAME, command);
                        context.startService(i);
                    }
                    mLaunched = false;
                    mDown = true;
                }
            } else {
                mHandler.removeMessages(MSG_LONGPRESS_TIMEOUT);
                mDown = false;
            }
            if (isOrderedBroadcast()) {
                abortBroadcast();
            }
        }
    }
}
#end_block

#method_before
public Result call(final String method, final String apiKey, Map<String, String> params) {
    params = new WeakHashMap<String, String>(params);
    InputStream inputStream = null;
    // no entry in cache, load from web
    if (inputStream == null) {
        // fill parameter map with apiKey and session info
        params.put(PARAM_API_KEY, apiKey);
        try {
            final HttpURLConnection urlConnection = openPostConnection(method, params);
            inputStream = getInputStreamFromConnection(urlConnection);
            if (inputStream == null) {
                lastResult = Result.createHttpErrorResult(urlConnection.getResponseCode(), urlConnection.getResponseMessage());
                return lastResult;
            }
        } catch (final IOException ignored) {
        }
    }
    try {
        final Result result = createResultFromInputStream(inputStream);
        if (result != null)
            lastResult = result;
        return result;
    } catch (final IOException ignored) {
    } catch (final SAXException ignored) {
    }
    return null;
}
#method_after
public Result call(final String method, final String apiKey, Map<String, String> params) {
    params = new WeakHashMap<String, String>(params);
    InputStream inputStream = null;
    // no entry in cache, load from web
    if (inputStream == null) {
        // fill parameter map with apiKey and session info
        params.put(PARAM_API_KEY, apiKey);
        try {
            final HttpURLConnection urlConnection = openPostConnection(method, params);
            inputStream = getInputStreamFromConnection(urlConnection);
            if (inputStream == null) {
                lastResult = Result.createHttpErrorResult(urlConnection.getResponseCode(), urlConnection.getResponseMessage());
                return lastResult;
            }
        } catch (final IOException ioEx) {
            // We will assume that the server is not ready
            Log.e(TAG, "Failed to download data", ioEx);
            lastResult = Result.createHttpErrorResult(HttpStatus.SC_SERVICE_UNAVAILABLE, ioEx.getLocalizedMessage());
            return lastResult;
        }
    }
    try {
        final Result result = createResultFromInputStream(inputStream);
        lastResult = result;
    } catch (final IOException ioEx) {
        Log.e(TAG, "Failed to read document", ioEx);
        lastResult = new Result(ioEx.getLocalizedMessage());
    } catch (final SAXException saxEx) {
        Log.e(TAG, "Failed to parse document", saxEx);
        lastResult = new Result(saxEx.getLocalizedMessage());
    }
    return lastResult;
}
#end_block

#method_before
private Result createResultFromInputStream(final InputStream inputStream) throws SAXException, IOException {
    final Document document = newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream, "UTF-8")));
    // lfm element
    final Element root = document.getDocumentElement();
    final String statusString = root.getAttribute("status");
    final Status status = "ok".equals(statusString) ? Status.OK : Status.FAILED;
    if (status == Status.FAILED) {
        final Element errorElement = (Element) root.getElementsByTagName("error").item(0);
        if (errorElement != null) {
            return null;
        }
        final int errorCode = Integer.parseInt(errorElement.getAttribute("code"));
        final String message = errorElement.getTextContent();
        return Result.createRestErrorResult(errorCode, message);
    } else {
        return Result.createOkResult(document);
    }
}
#method_after
private Result createResultFromInputStream(final InputStream inputStream) throws SAXException, IOException {
    final Document document = newDocumentBuilder().parse(new InputSource(new InputStreamReader(inputStream, "UTF-8")));
    // lfm element
    final Element root = document.getDocumentElement();
    final String statusString = root.getAttribute("status");
    final Status status = "ok".equals(statusString) ? Status.OK : Status.FAILED;
    if (status == Status.FAILED) {
        final Element errorElement = (Element) root.getElementsByTagName("error").item(0);
        final int errorCode = Integer.parseInt(errorElement.getAttribute("code"));
        final String message = errorElement.getTextContent();
        return Result.createRestErrorResult(errorCode, message);
    } else {
        return Result.createOkResult(document);
    }
}
#end_block

#method_before
public static DisplayMode[] getAvailableModes() {
    return DISPLAY_MODES;
}
#method_after
public static DisplayMode[] getAvailableModes() {
    /* node is unreadable */
    if (!FileUtils.isFileReadable(MAX_PATH)) {
        return DISPLAY_MODES;
    }
    int max;
    try {
        max = Integer.parseInt(FileUtils.readOneLine(MAX_PATH));
    } catch (NumberFormatException e) {
        /* max is not an integer */
        return DISPLAY_MODES;
    }
    /* max is invalid */
    return Arrays.copyOfRange(DISPLAY_MODES, 0, max >= 0 ? max : DISPLAY_MODES.length);
}
#end_block

#method_before
public static DisplayMode getCurrentMode() {
    try {
        int curMode = Integer.parseInt(FileUtils.readOneLine(MODE_PATH));
        return DISPLAY_MODES[curMode];
    } catch (NumberFormatException e) {
        return null;
    }
}
#method_after
public static DisplayMode getCurrentMode() {
    try {
        int mode = Integer.parseInt(FileUtils.readOneLine(MODE_PATH));
        return DISPLAY_MODES[mode];
    } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
        return null;
    }
}
#end_block

#method_before
public static DisplayMode getDefaultMode() {
    try {
        int defMode = Integer.parseInt(FileUtils.readOneLine(DEFAULT_PATH));
        return DISPLAY_MODES[defMode];
    } catch (NumberFormatException e) {
        return null;
    }
}
#method_after
public static DisplayMode getDefaultMode() {
    try {
        int mode = Integer.parseInt(FileUtils.readOneLine(DEFAULT_PATH));
        return DISPLAY_MODES[mode];
    } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
        return null;
    }
}
#end_block

#method_before
public static boolean isSupported() {
    return FileUtils.isFileWritable(OUTDOOR_MODE_PATH) && FileUtils.isFileReadable(OUTDOOR_MODE_PATH);
}
#method_after
public static boolean isSupported() {
    return FileUtils.isFileWritable(FILE_SRE) && FileUtils.isFileReadable(FILE_SRE);
}
#end_block

#method_before
public static boolean isEnabled() {
    String line = FileUtils.readOneLine(OUTDOOR_MODE_PATH);
    return "1".equals(line);
}
#method_after
public static boolean isEnabled() {
    return "1".equals(FileUtils.readOneLine(FILE_SRE));
}
#end_block

#method_before
public static boolean setEnabled(boolean status) {
    return FileUtils.writeLine(OUTDOOR_MODE_PATH, status ? "1" : "0");
}
#method_after
public static boolean setEnabled(boolean status) {
    return FileUtils.writeLine(FILE_SRE, status ? "1" : "0");
}
#end_block

#method_before
public static boolean isSupported() {
    return FileUtils.isFileWritable(LEVEL_PATH) && FileUtils.isFileReadable(LEVEL_PATH) && FileUtils.isFileReadable(LEVEL_DEFAULT_PATH) && FileUtils.isFileReadable(LEVEL_MAX_PATH) && FileUtils.isFileReadable(LEVEL_MIN_PATH) && FileUtils.isFileReadable(LEVEL_THRESHOLD_PATH);
}
#method_after
public static boolean isSupported() {
    return FileUtils.isFileWritable(LEVEL_PATH) && FileUtils.isFileReadable(LEVEL_PATH) && FileUtils.isFileReadable(DEFAULT_PATH) && FileUtils.isFileReadable(MAX_PATH) && FileUtils.isFileReadable(MIN_PATH) && FileUtils.isFileReadable(THRESHOLD_PATH);
}
#end_block

#method_before
public static int getMaxIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(LEVEL_MAX_PATH));
}
#method_after
public static int getMaxIntensity() {
    try {
        return Integer.parseInt(FileUtils.readOneLine(MAX_PATH));
    } catch (NumberFormatException e) {
        return -1;
    }
}
#end_block

#method_before
public static int getMinIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(LEVEL_MIN_PATH));
}
#method_after
public static int getMinIntensity() {
    try {
        return Integer.parseInt(FileUtils.readOneLine(MIN_PATH));
    } catch (NumberFormatException e) {
        return -1;
    }
}
#end_block

#method_before
public static int getWarningThreshold() {
    return Integer.parseInt(FileUtils.readOneLine(LEVEL_THRESHOLD_PATH));
}
#method_after
public static int getWarningThreshold() {
    try {
        return Integer.parseInt(FileUtils.readOneLine(THRESHOLD_PATH));
    } catch (NumberFormatException e) {
        return -1;
    }
}
#end_block

#method_before
public static int getCurIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(LEVEL_PATH));
}
#method_after
public static int getCurIntensity() {
    try {
        return Integer.parseInt(FileUtils.readOneLine(LEVEL_PATH));
    } catch (NumberFormatException e) {
        return -1;
    }
}
#end_block

#method_before
public static int getDefaultIntensity() {
    return Integer.parseInt(FileUtils.readOneLine(LEVEL_DEFAULT_PATH));
}
#method_after
public static int getDefaultIntensity() {
    try {
        return Integer.parseInt(FileUtils.readOneLine(DEFAULT_PATH));
    } catch (NumberFormatException e) {
        return -1;
    }
}
#end_block

#method_before
public static boolean isSupported() {
    return getUniqueDeviceIdInternal() != null;
}
#method_after
public static boolean isSupported() {
    return FileUtils.isFileReadable(MMC_TYPE) && FileUtils.isFileReadable(MMC_CID) && getUniqueDeviceIdInternal() != null;
}
#end_block

#method_before
private static String getUniqueDeviceIdInternal() {
    if (sUniqueId != null) {
        return sUniqueId;
    }
    try {
        if (!(new File(MMC_TYPE).exists()) || !(new File(MMC_CID).exists())) {
            return null;
        }
        String sMmcType = FileUtils.readOneLine(MMC_TYPE);
        String sCid = FileUtils.readOneLine(MMC_CID);
        if ("MMC".equals(sMmcType) && sCid != null) {
            sCid = sCid.trim();
            if (sCid.length() == 32) {
                sUniqueId = String.format("%03x00000%32s", TYPE_MMC0_CID, sCid);
                return sUniqueId;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, "Failed to get unique device ID: " + e.getMessage());
        return null;
    }
    return null;
}
#method_after
private static String getUniqueDeviceIdInternal() {
    if (sUniqueId != null) {
        return sUniqueId;
    }
    try {
        String sMmcType = FileUtils.readOneLine(MMC_TYPE);
        String sCid = FileUtils.readOneLine(MMC_CID);
        if ("MMC".equals(sMmcType) && sCid != null) {
            sCid = sCid.trim();
            if (sCid.length() == 32) {
                sUniqueId = String.format("%03x00000%32s", TYPE_MMC0_CID, sCid);
                return sUniqueId;
            }
        }
    } catch (Exception e) {
        Log.e(TAG, "Failed to get unique device ID: " + e.getMessage());
        return null;
    }
    return null;
}
#end_block

#method_before
@Override
public void dispose() {
    if (DBG)
        log("GsmDCT.dispose");
    cleanUpAllConnections(true, null);
    super.dispose();
    // Unregister for all events
    mPhone.mCi.unregisterForAvailable(this);
    mPhone.mCi.unregisterForOffOrNotAvailable(this);
    IccRecords r = mIccRecords.get();
    if (r != null) {
        r.unregisterForRecordsLoaded(this);
    }
    mPhone.mCi.unregisterForDataNetworkStateChanged(this);
    mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
    mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
    mPhone.getServiceStateTracker().unregisterForDataConnectionAttached(this);
    mPhone.getServiceStateTracker().unregisterForDataConnectionDetached(this);
    mPhone.getServiceStateTracker().unregisterForRoamingOn(this);
    mPhone.getServiceStateTracker().unregisterForRoamingOff(this);
    mPhone.getServiceStateTracker().unregisterForPsRestrictedEnabled(this);
    mPhone.getServiceStateTracker().unregisterForPsRestrictedDisabled(this);
    mPhone.getContext().getContentResolver().unregisterContentObserver(mApnObserver);
    mApnContexts.clear();
    mPrioritySortedApnContexts.clear();
    destroyDataConnections();
}
#method_after
@Override
public void dispose() {
    if (DBG)
        log("GsmDCT.dispose");
    cleanUpAllConnections(true, null);
    super.dispose();
    // Unregister for all events
    mPhone.mCi.unregisterForAvailable(this);
    mPhone.mCi.unregisterForOffOrNotAvailable(this);
    IccRecords r = mIccRecords.get();
    if (r != null) {
        r.unregisterForRecordsLoaded(this);
    }
    mPhone.mCi.unregisterForDataNetworkStateChanged(this);
    mPhone.getCallTracker().unregisterForVoiceCallEnded(this);
    mPhone.getCallTracker().unregisterForVoiceCallStarted(this);
    mPhone.getServiceStateTracker().unregisterForDataConnectionAttached(this);
    mPhone.getServiceStateTracker().unregisterForDataConnectionDetached(this);
    mPhone.getServiceStateTracker().unregisterForRoamingOn(this);
    mPhone.getServiceStateTracker().unregisterForRoamingOff(this);
    mPhone.getServiceStateTracker().unregisterForPsRestrictedEnabled(this);
    mPhone.getServiceStateTracker().unregisterForPsRestrictedDisabled(this);
    mPhone.getContext().getContentResolver().unregisterContentObserver(mApnObserver);
    mApnContexts.clear();
    mPrioritySortedApnContexts.clear();
    if (mCdmaSsm != null) {
        mCdmaSsm.dispose(this);
    }
    destroyDataConnections();
}
#end_block

#method_before
@Override
protected boolean isDataAllowed() {
    final boolean internalDataEnabled;
    synchronized (mDataEnabledLock) {
        internalDataEnabled = mInternalDataEnabled;
    }
    boolean attachedState = mAttached.get();
    boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
    IccRecords r = mIccRecords.get();
    boolean recordsLoaded = (r != null) ? r.getRecordsLoaded() : false;
    boolean allowed = (attachedState || mAutoAttachOnCreation) && recordsLoaded && (mPhone.getState() == PhoneConstants.State.IDLE || mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) && internalDataEnabled && (!mPhone.getServiceState().getRoaming() || getDataOnRoamingEnabled()) && !mIsPsRestricted && desiredPowerState;
    if (!allowed && DBG) {
        String reason = "";
        if (!(attachedState || mAutoAttachOnCreation)) {
            reason += " - Attached= " + attachedState;
        }
        if (!recordsLoaded)
            reason += " - SIM not loaded";
        if (mPhone.getState() != PhoneConstants.State.IDLE && !mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) {
            reason += " - PhoneState= " + mPhone.getState();
            reason += " - Concurrent voice and data not allowed";
        }
        if (!internalDataEnabled)
            reason += " - mInternalDataEnabled= false";
        if (mPhone.getServiceState().getRoaming() && !getDataOnRoamingEnabled()) {
            reason += " - Roaming and data roaming not enabled";
        }
        if (mIsPsRestricted)
            reason += " - mIsPsRestricted= true";
        if (!desiredPowerState)
            reason += " - desiredPowerState= false";
        if (DBG)
            log("isDataAllowed: not allowed due to" + reason);
    }
    return allowed;
}
#method_after
@Override
protected boolean isDataAllowed() {
    final boolean internalDataEnabled;
    synchronized (mDataEnabledLock) {
        internalDataEnabled = mInternalDataEnabled;
    }
    boolean attachedState = mAttached.get();
    boolean desiredPowerState = mPhone.getServiceStateTracker().getDesiredPowerState();
    IccRecords r = mIccRecords.get();
    boolean recordsLoaded = (r != null) ? r.getRecordsLoaded() : false;
    boolean subscriptionFromNv = isNvSubscription();
    boolean allowed = (attachedState || mAutoAttachOnCreation) && (subscriptionFromNv || recordsLoaded) && (mPhone.getState() == PhoneConstants.State.IDLE || mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) && internalDataEnabled && (!mPhone.getServiceState().getRoaming() || getDataOnRoamingEnabled()) && !mIsPsRestricted && desiredPowerState;
    if (!allowed && DBG) {
        String reason = "";
        if (!(attachedState || mAutoAttachOnCreation)) {
            reason += " - Attached= " + attachedState;
        }
        if (!(subscriptionFromNv || recordsLoaded)) {
            reason += " - SIM not loaded and not NV subscription";
        }
        if (mPhone.getState() != PhoneConstants.State.IDLE && !mPhone.getServiceStateTracker().isConcurrentVoiceAndDataAllowed()) {
            reason += " - PhoneState= " + mPhone.getState();
            reason += " - Concurrent voice and data not allowed";
        }
        if (!internalDataEnabled)
            reason += " - mInternalDataEnabled= false";
        if (mPhone.getServiceState().getRoaming() && !getDataOnRoamingEnabled()) {
            reason += " - Roaming and data roaming not enabled";
        }
        if (mIsPsRestricted)
            reason += " - mIsPsRestricted= true";
        if (!desiredPowerState)
            reason += " - desiredPowerState= false";
        if (DBG)
            log("isDataAllowed: not allowed due to" + reason);
    }
    return allowed;
}
#end_block

#method_before
@Override
public boolean isConcurrentVoiceAndDataAllowed() {
    return (mSS.getRilVoiceRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
}
#method_after
@Override
public boolean isConcurrentVoiceAndDataAllowed() {
    return (mSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
}
#end_block

#method_before
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    if (!dialCode)
        super.dial(address, clirMode, uusInfo, result);
    else {
        RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
        rr.mParcel.writeString(address);
        rr.mParcel.writeInt(clirMode);
        rr.mParcel.writeInt(0);
        rr.mParcel.writeInt(1);
        rr.mParcel.writeString("");
        if (uusInfo == null) {
            // UUS information is absent
            rr.mParcel.writeInt(0);
        } else {
            // UUS information is present
            rr.mParcel.writeInt(1);
            rr.mParcel.writeInt(uusInfo.getType());
            rr.mParcel.writeInt(uusInfo.getDcs());
            rr.mParcel.writeByteArray(uusInfo.getUserData());
        }
        if (RILJ_LOGD)
            riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
        send(rr);
    }
}
#method_after
@Override
public void dial(String address, int clirMode, UUSInfo uusInfo, Message result) {
    if (!dialCode) {
        super.dial(address, clirMode, uusInfo, result);
        return;
    }
    RILRequest rr = RILRequest.obtain(RIL_REQUEST_DIAL, result);
    rr.mParcel.writeString(address);
    rr.mParcel.writeInt(clirMode);
    rr.mParcel.writeInt(0);
    rr.mParcel.writeInt(1);
    rr.mParcel.writeString("");
    if (uusInfo == null) {
        // UUS information is absent
        rr.mParcel.writeInt(0);
    } else {
        // UUS information is present
        rr.mParcel.writeInt(1);
        rr.mParcel.writeInt(uusInfo.getType());
        rr.mParcel.writeInt(uusInfo.getDcs());
        rr.mParcel.writeByteArray(uusInfo.getUserData());
    }
    if (RILJ_LOGD)
        riljLog(rr.serialString() + "> " + requestToString(rr.mRequest));
    send(rr);
}
#end_block

