879
#method_before
@Test
public void shouldHaveAuthUsername() {
    String usernameConfigKey = "username";
    HealthCheckConfig config = new HealthCheckConfig("[healthcheck \"auth\"]\n" + usernameConfigKey + "=test_user");
    assertThat(config.getUsername("auth")).isEqualTo("test_user");
}
#method_after
@Test
public void shouldHaveAuthUsername() {
    HealthCheckConfig config = new HealthCheckConfig("[healthcheck \"auth\"]\n" + "username=test_user");
    assertThat(config.getUsername("auth")).isEqualTo("test_user");
}
#end_block

#method_before
@Test
public void shouldHaveAuthPassword() {
    String passwordConfigKey = "password";
    HealthCheckConfig config = new HealthCheckConfig("[healthcheck \"auth\"]\n" + passwordConfigKey + "=secret");
    assertThat(config.getPassword("auth")).isEqualTo("secret");
}
#method_after
@Test
public void shouldHaveAuthPassword() {
    HealthCheckConfig config = new HealthCheckConfig("[healthcheck \"auth\"]\n" + "password=secret");
    assertThat(config.getPassword("auth")).isEqualTo("secret");
}
#end_block

#method_before
@UsedAt(UsedAt.Project.PLUGIN_CHECKS)
@SuppressWarnings("unused")
public T getOnlyEntity() {
    checkParsed();
    checkState(entities.size() == 1, "expected exactly one entity");
    return entities.get(0);
}
#method_after
@UsedAt(UsedAt.Project.PLUGIN_CHECKS)
public T getOnlyEntity() {
    checkParsed();
    checkState(entities.size() == 1, "expected exactly one entity");
    return entities.get(0);
}
#end_block

#method_before
@Test
public void combineSingleState() {
    ImmutableMap<CheckState, CombinedCheckState> states = ImmutableMap.<CheckState, CombinedCheckState>builder().put(CheckState.FAILED, CombinedCheckState.FAILED).put(CheckState.NOT_STARTED, CombinedCheckState.IN_PROGRESS).put(CheckState.SCHEDULED, CombinedCheckState.IN_PROGRESS).put(CheckState.RUNNING, CombinedCheckState.IN_PROGRESS).put(CheckState.SUCCESSFUL, CombinedCheckState.SUCCESSFUL).put(CheckState.NOT_RELEVANT, CombinedCheckState.NOT_RELEVANT).build();
    assertThat(states.keySet()).containsExactlyElementsIn(CheckState.values());
    for (Map.Entry<CheckState, CombinedCheckState> e : states.entrySet()) {
        assertThat(combine(ImmutableSet.of(e.getKey()))).isEqualTo(e.getValue());
        assertThat(combine(ImmutableSet.of(e.getKey(), e.getKey()))).isEqualTo(e.getValue());
    }
}
#method_after
@Test
public void combineSingleState() {
    ImmutableMap<CheckState, CombinedCheckState> states = ImmutableMap.<CheckState, CombinedCheckState>builder().put(CheckState.FAILED, CombinedCheckState.FAILED).put(CheckState.NOT_STARTED, CombinedCheckState.IN_PROGRESS).put(CheckState.SCHEDULED, CombinedCheckState.IN_PROGRESS).put(CheckState.RUNNING, CombinedCheckState.IN_PROGRESS).put(CheckState.SUCCESSFUL, CombinedCheckState.SUCCESSFUL).put(CheckState.NOT_RELEVANT, CombinedCheckState.NOT_RELEVANT).build();
    assertThat(states.keySet()).containsExactlyElementsIn(CheckState.values());
    for (Map.Entry<CheckState, CombinedCheckState> e : states.entrySet()) {
        assertThat(combine(Collections.nCopies(1, e.getKey()))).isEqualTo(e.getValue());
        assertThat(combine(Collections.nCopies(2, e.getKey()))).isEqualTo(e.getValue());
    }
}
#end_block

#method_before
@Test
public void setMergedChangePrivate() throws Exception {
    PushOneCommit.Result result = createChange();
    approve(result.getChangeId());
    merge(result);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    exception.expect(BadRequestException.class);
    exception.expectMessage("can't set a non-open change to private");
    gApi.changes().id(changeId).setPrivate(true);
}
#method_after
@Test
public void setMergedChangePrivate() throws Exception {
    PushOneCommit.Result result = createChange();
    approve(result.getChangeId());
    merge(result);
    String changeId = result.getChangeId();
    assertThat(gApi.changes().id(changeId).get().isPrivate).isNull();
    exception.expect(BadRequestException.class);
    exception.expectMessage("cannot set a non-open change to private");
    gApi.changes().id(changeId).setPrivate(true);
}
#end_block

#method_before
@Override
public Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Mark private").setTitle("Mark change as private").setVisible(and(!disablePrivateChanges && !change.isPrivate() && change.getStatus() == Change.Status.NEW, canSetPrivate(rsrc)));
}
#method_after
@Override
public Description getDescription(ChangeResource rsrc) {
    Change change = rsrc.getChange();
    return new UiAction.Description().setLabel("Mark private").setTitle("Mark change as private").setVisible(and(!disablePrivateChanges && !change.isPrivate() && change.isNew(), canSetPrivate(rsrc)));
}
#end_block

#method_before
private BooleanCondition canSetPrivate(ChangeResource rsrc) {
    PermissionBackend.WithUser user = permissionBackend.user(rsrc.getUser());
    return or(rsrc.isUserOwner() && rsrc.getChange().getStatus() != Change.Status.MERGED, user.testCond(GlobalPermission.ADMINISTRATE_SERVER));
}
#method_after
private BooleanCondition canSetPrivate(ChangeResource rsrc) {
    PermissionBackend.WithUser user = permissionBackend.user(rsrc.getUser());
    return or(rsrc.isUserOwner() && !rsrc.getChange().isMerged(), user.testCond(GlobalPermission.ADMINISTRATE_SERVER));
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (!Strings.isNullOrEmpty(hdr) && hdr.startsWith(LFS_AUTH_PREFIX)) {
        // therefore let it go through the filter
        return true;
    }
    String username = RemoteUserUtil.getRemoteUser(req, loginHttpHeader);
    if (username == null) {
        rsp.sendError(SC_FORBIDDEN);
        return false;
    }
    if (config.getBoolean("auth", "userNameToLowerCase", false)) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    WebSession ws = session.get();
    ws.setUserAccountId(who.getAccount().getId());
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
    return true;
}
#method_after
private boolean verify(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String username = RemoteUserUtil.getRemoteUser(req, loginHttpHeader);
    if (username == null) {
        if (isLfsOverSshRequest(req)) {
            // therefore let it go through the filter
            return true;
        }
        rsp.sendError(SC_FORBIDDEN);
        return false;
    }
    if (config.getBoolean("auth", "userNameToLowerCase", false)) {
        username = username.toLowerCase(Locale.US);
    }
    final AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    WebSession ws = session.get();
    ws.setUserAccountId(who.getAccount().getId());
    ws.setAccessPathOk(AccessPath.GIT, true);
    ws.setAccessPathOk(AccessPath.REST_API, true);
    return true;
}
#end_block

#method_before
private Optional<String> expressAsProjectsQuery() {
    return projectListFromIndex && !all && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && // TODO: see Issue 10446
    isNullOrEmpty(matchSubstring) && type == FilterType.ALL && showBranch.isEmpty() && !showTree ? Optional.of(stateToQuery()) : Optional.empty();
}
#method_after
private Optional<String> expressAsProjectsQuery() {
    return listProjectsFromIndex && !all && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && // TODO: see Issue 10446
    isNullOrEmpty(matchSubstring) && type == FilterType.ALL && showBranch.isEmpty() && !showTree ? Optional.of(stateToQuery()) : Optional.empty();
}
#end_block

#method_before
@Override
public void init(Project.NameKey project, ReceivePack rp) {
    Optional<Long> maxPackSize = getMaxPackSize(project);
    if (maxPackSize.isPresent()) {
        rp.setMaxPackSizeLimit(maxPackSize.get());
    }
}
#method_after
@Override
public void init(Project.NameKey project, ReceivePack rp) {
    QuotaSection quotaSection = quotaFinder.firstMatching(project);
    if (quotaSection == null) {
        return;
    }
    Long maxRepoSize = quotaSection.getMaxRepoSize();
    Long maxTotalSize = quotaSection.getMaxTotalSize();
    if (maxRepoSize == null && maxTotalSize == null) {
        return;
    }
    try {
        Long maxPackSize1 = null;
        if (maxRepoSize != null) {
            maxPackSize1 = Math.max(0, maxRepoSize - cache.get(project).get());
        }
        Long maxPackSize2 = null;
        if (maxTotalSize != null) {
            long totalSize = 0;
            for (Project.NameKey p : projectCache.all()) {
                if (quotaSection.matches(p)) {
                    totalSize += cache.get(p).get();
                }
            }
            maxPackSize2 = Math.max(0, maxTotalSize - totalSize);
        }
        long maxPackSize = Ordering.<Long>natural().nullsLast().min(maxPackSize1, maxPackSize2);
        rp.setMaxPackSizeLimit(maxPackSize);
    } catch (ExecutionException e) {
        log.warn("Couldn't setMaxPackSizeLimit on receive-pack for " + project.get(), e);
    }
}
#end_block

#method_before
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException, PermissionBackendException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    if (todo.size() <= replConfig.getMaxRefsToLog() || replConfig.getMaxRefsToLog() <= 0) {
        repLog.info("Push to {} references: {}", uri, todo);
    } else {
        repLog.info("Push to {} references (first {} of {} listed): {}", uri, replConfig.getMaxRefsToLog(), todo.size(), todo.subList(0, replConfig.getMaxRefsToLog()));
    }
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#method_after
private PushResult pushVia(Transport tn) throws IOException, NotSupportedException, TransportException, PermissionBackendException {
    tn.applyConfig(config);
    tn.setCredentialsProvider(credentialsProvider);
    List<RemoteRefUpdate> todo = generateUpdates(tn);
    if (todo.isEmpty()) {
        // send back an empty result.
        return new PushResult();
    }
    if (replConfig.getMaxRefsToLog() == 0 || todo.size() <= replConfig.getMaxRefsToLog()) {
        repLog.info("Push to {} references: {}", uri, todo);
    } else {
        repLog.info("Push to {} references (first {} of {} listed): {}", uri, replConfig.getMaxRefsToLog(), todo.size(), todo.subList(0, replConfig.getMaxRefsToLog()));
    }
    return tn.push(NullProgressMonitor.INSTANCE, todo);
}
#end_block

#method_before
@Override
public void onChangeIndexed(String projectName, int id) {
    if (!Context.isForwardedEvent()) {
        try {
            changeChecker.create(projectName + "~" + id).newIndexEvent().map(event -> new IndexChangeTask(projectName, id, event)).ifPresent(task -> {
                if (queuedTasks.add(task)) {
                    executor.execute(task);
                }
            });
        } catch (Exception e) {
            log.warn("Unable to create task to reindex change {}~{}", projectName, id, e);
        }
    }
}
#method_after
@Override
public void onChangeIndexed(String projectName, int id) {
    if (!Context.isForwardedEvent()) {
        String changeId = projectName + "~" + id;
        try {
            changeChecker.create(changeId).newIndexEvent().map(event -> new IndexChangeTask(projectName, id, event)).ifPresent(task -> {
                if (queuedTasks.add(task)) {
                    executor.execute(task);
                }
            });
        } catch (Exception e) {
            log.warn("Unable to create task to reindex change {}", changeId, e);
        }
    }
}
#end_block

#method_before
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    // Convert the results from Prolog Cafe's format to Gerrit's common format.
    // can_submit/1 terminates when an ok(P) record is found. Therefore walk
    // the results backwards, using only that ok(P) record if it exists. This
    // skips partial results that occur early in the output. Later after the loop
    // the out collection is reversed to restore it to the original ordering.
    // 
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#method_after
public List<SubmitRecord> resultsToSubmitRecord(Term submitRule, List<Term> results) {
    List<SubmitRecord> out = new ArrayList<SubmitRecord>(results.size());
    for (int resultIdx = results.size() - 1; 0 <= resultIdx; resultIdx--) {
        Term submitRecord = results.get(resultIdx);
        SubmitRecord rec = new SubmitRecord();
        out.add(rec);
        if (!submitRecord.isStructure() || 1 != submitRecord.arity()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        if ("ok".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.OK;
        } else if ("not_ready".equals(submitRecord.name())) {
            rec.status = SubmitRecord.Status.NOT_READY;
        } else {
            return logInvalidResult(submitRule, submitRecord);
        }
        // Unpack the one argument. This should also be a structure with one
        // argument per label that needs to be reported on to the caller.
        // 
        submitRecord = submitRecord.arg(0);
        if (!submitRecord.isStructure()) {
            return logInvalidResult(submitRule, submitRecord);
        }
        rec.labels = new ArrayList<SubmitRecord.Label>(submitRecord.arity());
        for (Term state : ((StructureTerm) submitRecord).args()) {
            if (!state.isStructure() || 2 != state.arity() || !"label".equals(state.name())) {
                return logInvalidResult(submitRule, submitRecord);
            }
            SubmitRecord.Label lbl = new SubmitRecord.Label();
            rec.labels.add(lbl);
            lbl.label = state.arg(0).name();
            Term status = state.arg(1);
            if ("ok".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.OK;
                appliedBy(lbl, status);
            } else if ("reject".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.REJECT;
                appliedBy(lbl, status);
            } else if ("need".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.NEED;
            } else if ("may".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.MAY;
            } else if ("impossible".equals(status.name())) {
                lbl.status = SubmitRecord.Label.Status.IMPOSSIBLE;
            } else {
                return logInvalidResult(submitRule, submitRecord);
            }
        }
        if (rec.status == SubmitRecord.Status.OK) {
            break;
        }
    }
    Collections.reverse(out);
    return out;
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure {
    PushbackReader inReader = new PushbackReader(new InputStreamReader(in));
    PrintWriter outWriter = new PrintWriter(new OutputStreamWriter(out));
    try {
        PrologEnvironment pcl;
        List<Change> changeList = db.changes().byKey(new Change.Key(changeId)).toList();
        if (changeList.size() == 0)
            throw new UnloggedFailure(1, "Invalid ChangeId");
        Change c = changeList.get(0);
        PatchSet ps = db.patchSets().get(c.currentPatchSetId());
        ChangeControl cc = ccFactory.controlFor(c);
        if (useStdin) {
            pcl = envFactory.create(newMachine());
        } else {
            ProjectState projectState = cc.getProjectControl().getProjectState();
            pcl = projectState.newPrologEnvironment();
        }
        pcl.set(StoredValues.REVIEW_DB, db);
        pcl.set(StoredValues.CHANGE, c);
        pcl.set(StoredValues.PATCH_SET, ps);
        pcl.set(StoredValues.CHANGE_CONTROL, cc);
        if (useStdin) {
            pcl.initialize(PACKAGE_LIST);
            pcl.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("rules.pl"), new JavaObjectTerm(inReader));
        }
        List<Term> results = new ArrayList<Term>();
        Term submitRule = pcl.once("gerrit", "locate_submit_rule", new VariableTerm());
        for (Term[] template : pcl.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
        List<SubmitRecord> res = cc.resultsToSubmitRecord(submitRule, results);
        for (SubmitRecord r : res) {
            outWriter.println("Result: " + r);
        }
    } catch (Exception e) {
        throw new UnloggedFailure("Processing of prolog script failed: " + e);
    }
    try {
        outWriter.flush();
        outWriter.close();
        inReader.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    InputStreamReader inReader = new InputStreamReader(in);
    try {
        PrologEnvironment pcl;
        List<Change> changeList = db.changes().byKey(new Change.Key(changeId)).toList();
        if (changeList.size() != 1)
            throw new UnloggedFailure(1, "Invalid ChangeId");
        Change c = changeList.get(0);
        PatchSet ps = db.patchSets().get(c.currentPatchSetId());
        // Will throw exception if current user can not access this change, and
        // thus will leak information that a change-id is valid even though the
        // user are not allowed to see the change.
        // See http://code.google.com/p/gerrit/issues/detail?id=1586
        ChangeControl cc = ccFactory.controlFor(c);
        ProjectState projectState = cc.getProjectControl().getProjectState();
        if (useStdin) {
            pcl = envFactory.create(newMachine());
        } else {
            pcl = projectState.newPrologEnvironment();
        }
        pcl.set(StoredValues.REVIEW_DB, db);
        pcl.set(StoredValues.CHANGE, c);
        pcl.set(StoredValues.PATCH_SET, ps);
        pcl.set(StoredValues.CHANGE_CONTROL, cc);
        if (useStdin) {
            pcl.initialize(PACKAGE_LIST);
            pcl.execute(Prolog.BUILTIN, "consult_stream", SymbolTerm.intern("stdin"), new JavaObjectTerm(inReader));
        }
        List<Term> results = new ArrayList<Term>();
        Term submitRule = pcl.once("gerrit", "locate_submit_rule", new VariableTerm());
        for (Term[] template : pcl.all("gerrit", "can_submit", submitRule, new VariableTerm())) {
            results.add(template[1]);
        }
        if (!skipSubmitFilters) {
            runSubmitFilters(projectState, results, pcl);
        }
        List<SubmitRecord> res = cc.resultsToSubmitRecord(submitRule, results);
        for (SubmitRecord r : res) {
            if (format.isJson()) {
                SubmitRecordAttribute submitRecord = new SubmitRecordAttribute();
                submitRecord.status = r.status.name();
                List<SubmitLabelAttribute> submitLabels = new LinkedList<SubmitLabelAttribute>();
                for (SubmitRecord.Label l : r.labels) {
                    SubmitLabelAttribute label = new SubmitLabelAttribute();
                    label.label = l.label;
                    label.status = l.status.name();
                    if (l.appliedBy != null) {
                        Account a = accountCache.get(l.appliedBy).getAccount();
                        label.by = new AccountAttribute();
                        label.by.email = a.getPreferredEmail();
                        label.by.name = a.getFullName();
                        label.by.username = a.getUserName();
                    }
                    submitLabels.add(label);
                }
                submitRecord.labels = submitLabels;
                format.newGson().toJson(submitRecord, new TypeToken<SubmitRecordAttribute>() {
                }.getType(), stdout);
                stdout.print('\n');
            } else {
                for (SubmitRecord.Label l : r.labels) {
                    stdout.print(l.label + ": " + l.status);
                    if (l.appliedBy != null) {
                        AccountInfo a = new AccountInfo(accountCache.get(l.appliedBy).getAccount());
                        stdout.print(" by " + a.getNameEmail(anonymousCowardName));
                    }
                    stdout.print('\n');
                }
                stdout.print("\n" + r.status.name() + "\n");
            }
        }
    } catch (Exception e) {
        throw new UnloggedFailure("Processing of prolog script failed: " + e);
    }
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public Project createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
            return projectCache.get(nameKey).getProject();
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
                throw err;
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    install(new AsyncReceiveCommits.Module());
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(AddReviewer.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(RequestCleanup.class).in(RequestScoped.class);
    bind(RequestScopedReviewDbProvider.class);
    bind(IdentifiedUser.RequestFactory.class).in(SINGLETON);
    bind(ApprovalsUtil.class);
    bind(PerRequestProjectControlCache.class).in(RequestScoped.class);
    bind(ChangeControl.Factory.class).in(SINGLETON);
    bind(ProjectControl.Factory.class).in(SINGLETON);
    factory(SubmoduleOp.Factory.class);
    factory(MergeOp.Factory.class);
    // Not really per-request, but dammit, I don't know where else to
    // easily park this stuff.
    // 
    factory(DeleteDraftPatchSet.Factory.class);
    factory(PublishDraft.Factory.class);
    factory(RemoveReviewer.Factory.class);
    factory(SuggestParentCandidates.Factory.class);
    factory(BanCommit.Factory.class);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPoppingUp() || "".equals(sugestParent.getText())) {
                sugestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.createProjectTitle());
    addCreateProjectPanel();
    /* popup */
    projectsPopup = new ProjectListPopup() {

        @Override
        protected void onMovePointerTo(String projectName) {
            // prevent user input from being overwritten by simply poping up
            if (!projectsPopup.isPoppingUp() || "".equals(suggestParent.getText())) {
                suggestParent.setText(projectName);
            }
        }
    };
    projectsPopup.initPopup(Util.C.projects(), PageLinks.ADMIN_PROJECTS);
}
#end_block

#method_before
private void initCreateTxt() {
    project = new NpTextBox();
    project.setVisibleLength(50);
    project.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getCharCode() == KeyCodes.KEY_ENTER) {
                doCreateProject();
            }
        }
    });
}
#method_after
private void initCreateTxt() {
    project = new NpTextBox();
    project.setVisibleLength(50);
    project.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doCreateProject();
            }
        }
    });
}
#end_block

#method_before
private void initParentBox() {
    parent = new HintTextBox();
    sugestParent = new SuggestBox(new ProjectNameSuggestOracle(), parent);
    parent.setVisibleLength(50);
}
#method_after
private void initParentBox() {
    parent = new HintTextBox();
    suggestParent = new SuggestBox(new ProjectNameSuggestOracle(), parent);
    parent.setVisibleLength(50);
}
#end_block

#method_before
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    sugestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#method_after
private void initSuggestedParents() {
    suggestedParentsTab = new ProjectsTable() {

        {
            table.setText(0, 1, Util.C.parentSuggestions());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            final Anchor projectLink = new Anchor(k.name());
            projectLink.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    suggestParent.setText(getRowItem(row).name());
                }
            });
            table.setWidget(row, 1, projectLink);
            table.setText(row, 2, k.description());
            setRowItem(row, k);
        }
    };
    suggestedParentsTab.setVisible(false);
    ProjectMap.parentCandidates(new GerritCallback<ProjectMap>() {

        @Override
        public void onSuccess(ProjectMap list) {
            if (!list.isEmpty()) {
                suggestedParentsTab.setVisible(true);
                suggestedParentsTab.display(list);
                suggestedParentsTab.finishDisplay();
            }
        }
    });
}
#end_block

#method_before
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 3);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, sugestParent);
    grid.setWidget(1, 2, browse);
    fp.add(grid);
}
#method_after
private void addGrid(final VerticalPanel fp) {
    grid = new Grid(2, 3);
    grid.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    grid.setText(0, 0, Util.C.columnProjectName() + ":");
    grid.setWidget(0, 1, project);
    grid.setText(1, 0, Util.C.headingParentProjectName() + ":");
    grid.setWidget(1, 1, suggestParent);
    grid.setWidget(1, 2, browse);
    fp.add(grid);
}
#end_block

#method_before
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = sugestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    ProjectApi.createProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new AsyncCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String nameWithoutSuffix = projectName;
            if (nameWithoutSuffix.endsWith(".git")) {
                // Be nice and drop the trailing ".git" suffix, which we never
                // keep in our database, but clients might mistakenly provide
                // anyway.
                // 
                nameWithoutSuffix = // 
                nameWithoutSuffix.substring(// 
                0, nameWithoutSuffix.length() - 4);
                while (nameWithoutSuffix.endsWith("/")) {
                    nameWithoutSuffix = // 
                    nameWithoutSuffix.substring(0, nameWithoutSuffix.length() - 1);
                }
            }
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(nameWithoutSuffix), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#method_after
private void doCreateProject() {
    final String projectName = project.getText().trim();
    final String parentName = suggestParent.getText().trim();
    if ("".equals(projectName)) {
        project.setFocus(true);
        return;
    }
    enableForm(false);
    ProjectApi.createProject(projectName, parentName, emptyCommit.getValue(), permissionsOnly.getValue(), new AsyncCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String nameWithoutSuffix = ProjectUtil.stripGitSuffix(projectName);
            History.newItem(Dispatcher.toProjectAdmin(new Project.NameKey(nameWithoutSuffix), ProjectScreen.INFO));
        }

        @Override
        public void onFailure(Throwable caught) {
            new ErrorDialog(caught.getMessage()).center();
            enableForm(true);
        }
    });
}
#end_block

#method_before
@Override
public Object apply(ProjectResource resource, Input input) throws PreconditionFailedException {
    throw new PreconditionFailedException("Resource already exists");
}
#method_after
@Override
public Object apply(ProjectResource resource, Input input) throws ResourceConflictException {
    throw new ResourceConflictException("Project \"" + resource.getName() + "\" already exists");
}
#end_block

#method_before
public static void createProject(String projectName, String parent, Boolean createEmptyCcommit, Boolean permissionsOnly, AsyncCallback<VoidResult> asyncCallback) {
    ProjectInput input = ProjectInput.create();
    input.setProjectName(projectName);
    input.setParent(parent);
    input.setPermissionsOnly(permissionsOnly);
    input.setCreateEmptyCcommit(createEmptyCcommit);
    new RestApi("/projects/").id(projectName).ifNoneMatch().put(input, asyncCallback);
}
#method_after
public static void createProject(String projectName, String parent, Boolean createEmptyCcommit, Boolean permissionsOnly, AsyncCallback<VoidResult> asyncCallback) {
    ProjectInput input = ProjectInput.create();
    input.setName(projectName);
    input.setParent(parent);
    input.setPermissionsOnly(permissionsOnly);
    input.setCreateEmptyCommit(createEmptyCcommit);
    new RestApi("/projects/").id(projectName).ifNoneMatch().put(input, asyncCallback);
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource, Input input) throws AuthException, BadRequestException, OrmException, NameAlreadyUsedException, ProjectCreationFailedException {
    if (input == null) {
        input = new Input();
    }
    if (input.projectName == null) {
        throw new BadRequestException("name in not provided");
    } else if (!name.equals(input.projectName)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    if (!Strings.isNullOrEmpty(input.parent)) {
        ProjectControl ctl;
        try {
            ctl = controlFactory.controlFor(new Project.NameKey(input.parent), user.get());
            args.newParent = ctl;
        } catch (NoSuchProjectException e) {
            throw new BadRequestException("Parent project \"" + input.parent + "\" does not exist.");
        }
        if (!ctl.isVisible() && !ctl.isOwner()) {
            throw new BadRequestException("Parent project \"" + input.parent + "\" exist, but out of control.");
        }
    }
    try {
        controlFactory.controlFor(new Project.NameKey(input.projectName), user.get());
        throw new NameAlreadyUsedException(input.projectName);
    } catch (NoSuchProjectException e) {
    }
    args.setProjectName(input.projectName);
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = "";
    args.submitType = SubmitType.MERGE_IF_NECESSARY;
    args.branch = Collections.emptyList();
    final PerformCreateProject createProject = createProjectFactory.create(args);
    createProject.createProject();
    return Response.none();
}
#method_after
@Override
public Object apply(TopLevelResource resource, Input input) throws BadRequestException, UnprocessableEntityException, ProjectCreationFailedException {
    if (input == null) {
        input = new Input();
    }
    if (input.name != null && !name.equals(input.name)) {
        throw new BadRequestException("name must match URL");
    }
    final CreateProjectArgs args = new CreateProjectArgs();
    args.setProjectName(name);
    if (!Strings.isNullOrEmpty(input.parent)) {
        try {
            args.newParent = projectsCollection.get().parse(input.parent).getControl();
        } catch (ResourceNotFoundException e) {
            throw new UnprocessableEntityException(String.format("parent project \"%s\" not found", input.parent));
        }
    }
    args.createEmptyCommit = input.createEmptyCommit;
    args.permissionsOnly = input.permissionsOnly;
    args.projectDescription = Strings.emptyToNull(input.description);
    args.submitType = Objects.firstNonNull(input.submitType, SubmitType.MERGE_IF_NECESSARY);
    args.branch = input.branches;
    if (input.owners != null) {
        List<AccountGroup.UUID> ownerIds = Lists.newArrayListWithCapacity(input.owners.size());
        for (String owner : input.owners) {
            try {
                ownerIds.add(groupsCollection.get().parse(owner).getGroupUUID());
            } catch (ResourceNotFoundException e) {
                throw new UnprocessableEntityException(String.format("group \"%s\" not found", owner));
            }
        }
        args.ownerIds = ownerIds;
    }
    args.contributorAgreements = Objects.firstNonNull(input.useContributorAgreements, InheritableBoolean.INHERIT);
    args.signedOffBy = Objects.firstNonNull(input.useSignedOffBy, InheritableBoolean.INHERIT);
    args.contentMerge = input.submitType == SubmitType.FAST_FORWARD_ONLY ? InheritableBoolean.FALSE : Objects.firstNonNull(input.useContentMerge, InheritableBoolean.INHERIT);
    args.changeIdRequired = Objects.firstNonNull(input.requireChangeId, InheritableBoolean.INHERIT);
    Project p = createProjectFactory.create(args).createProject();
    return Response.created(json.format(p));
}
#end_block

#method_before
@Override
public ProjectResource parse(TopLevelResource parent, IdString id) throws ResourceNotFoundException {
    ProjectControl ctl;
    try {
        ctl = controlFactory.controlFor(new Project.NameKey(id.get()), user.get());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(id);
    }
    if (!ctl.isVisible() && !ctl.isOwner()) {
        throw new ResourceNotFoundException(id);
    }
    return new ProjectResource(ctl);
}
#method_after
@Override
public ProjectResource parse(TopLevelResource parent, IdString id) throws ResourceNotFoundException {
    return parse(id.get());
}
#end_block

#method_before
@Override
public ProjectResource parse(TopLevelResource parent, IdString id) throws ResourceNotFoundException {
    ProjectControl ctl;
    try {
        ctl = controlFactory.controlFor(new Project.NameKey(id.get()), user.get());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(id);
    }
    if (!ctl.isVisible() && !ctl.isOwner()) {
        throw new ResourceNotFoundException(id);
    }
    return new ProjectResource(ctl);
}
#method_after
public ProjectResource parse(String id) throws ResourceNotFoundException {
    ProjectControl ctl;
    try {
        ctl = controlFactory.controlFor(new Project.NameKey(id), user.get());
    } catch (NoSuchProjectException e) {
        throw new ResourceNotFoundException(id);
    }
    if (!ctl.isVisible() && !ctl.isOwner()) {
        throw new ResourceNotFoundException(id);
    }
    return new ProjectResource(ctl);
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(PerformCreateProject.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            DynamicSet.bind(binder(), AuthBackend.class).to(InternalAuthBackend.class);
            break;
    }
    bind(LabelTypes.class).toProvider(LabelTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new EmailModule());
    install(new GitModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    bind(ChangeQueryRewriter.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CommitMessageEditedSender.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(InternalUser.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RebasedPatchSetSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (!(o instanceof Account)) {
        return false;
    }
    return ((Account) o).getId().equals(getId());
}
#method_after
@Override
public boolean equals(Object o) {
    return o instanceof Account && ((Account) o).getId().equals(getId());
}
#end_block

#method_before
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    PatchSet.Id ps = id.getParentKey();
    Change.Id c = ps.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(ps.get()).append("/").append(KeyUtil.encode(id.get()));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    return toPatch(type, diffBase, id.getParentKey(), id.get());
}
#end_block

#method_before
private static String toPatch(String type, PatchSet.Id diffBase, PatchSet.Id revision, String fileName) {
    Change.Id c = revision.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(revision.get()).append("/").append(fileName);
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, PatchSet.Id revision, String fileName) {
    Change.Id c = revision.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(revision.get()).append("/").append(KeyUtil.encode(fileName));
    if (type != null && !type.isEmpty()) {
        p.append(",").append(type);
    }
    return p.toString();
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(pref.isIntralineDifference()).ignoreWhitespace(pref.getIgnoreWhitespace()).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(DisplaySide.A, false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(DisplaySide.B, false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(DisplaySide.A, true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(DisplaySide.B, true)));
    }
    ConfigInfoCache.get(revision.getParentKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    final CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(pref.isIntralineDifference()).ignoreWhitespace(pref.getIgnoreWhitespace()).get(cmGroup.addFinal(new GerritCallback<DiffInfo>() {

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            new ModeInjector().add(getContentType(diff.meta_a())).add(getContentType(diff.meta_b())).inject(modeInjectorCb);
        }
    }));
    if (base != null) {
        CommentApi.comments(base, group.add(getCommentCallback(DisplaySide.A, false)));
    }
    CommentApi.comments(revision, group.add(getCommentCallback(DisplaySide.B, false)));
    if (Gerrit.isSignedIn()) {
        if (base != null) {
            CommentApi.drafts(base, group.add(getCommentCallback(DisplaySide.A, true)));
        }
        CommentApi.drafts(revision, group.add(getCommentCallback(DisplaySide.B, true)));
    }
    ConfigInfoCache.get(changeId, group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide2.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            DiffInfo diffInfo = diff;
            diff = null;
            display(diffInfo);
        }
    }));
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.revisions().copyKeysIntoChildren("name");
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            diffTable.setUpPatchSetNav(list);
        }
    });
}
#end_block

#method_before
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
            updateActiveLine(cm).run();
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'j'", moveCursorDown(cm, 1)).on("'k'", moveCursorDown(cm, -1)).on("'a'", openReplyBox()).on("'u'", upToChange()).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            clearActiveLine(cm);
            clearActiveLine(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("Alt-N", diffChunkNav(cm, false)).on("Alt-P", diffChunkNav(cm, true)));
}
#method_after
private void registerCmEvents(final CodeMirror cm) {
    cm.on("cursorActivity", updateActiveLine(cm));
    cm.on("gutterClick", onGutterClick(cm));
    cm.on("scroll", doScroll(cm));
    scrollTimerA = new Timer() {

        @Override
        public void run() {
            fixScroll(cmA);
        }
    };
    scrollTimerB = new Timer() {

        @Override
        public void run() {
            fixScroll(cmB);
        }
    };
    cm.on("renderLine", resizeLinePadding(getSideFromCm(cm)));
    cm.on("viewportChange", adjustGutters(cm));
    cm.on("focus", new Runnable() {

        @Override
        public void run() {
            lastFocused = cm;
            updateActiveLine(cm).run();
        }
    });
    cm.on("contextmenu", new EventHandler() {

        @Override
        public void handle(CodeMirror instance, NativeEvent event) {
            CodeMirror.setObjectProperty(event, "codemirrorIgnore", true);
            lastFocused.focus();
        }
    });
    cm.addKeyMap(KeyMap.create().on("'a'", upToChange(true)).on("'u'", upToChange(false)).on("'r'", toggleReviewed()).on("'o'", toggleOpenBox(cm)).on("Enter", toggleOpenBox(cm)).on("'c'", insertNewDraft(cm)).on("Alt-U", new Runnable() {

        public void run() {
            cm.getInputField().blur();
            clearActiveLine(cm);
            clearActiveLine(otherCm(cm));
        }
    }).on("[", new Runnable() {

        @Override
        public void run() {
            (header.hasPrev() ? header.prev : header.up).go();
        }
    }).on("]", new Runnable() {

        @Override
        public void run() {
            (header.hasNext() ? header.next : header.up).go();
        }
    }).on("Shift-Alt-/", new Runnable() {

        @Override
        public void run() {
            new ShowHelpCommand().onKeyPress(null);
        }
    }).on("N", maybeNextVimSearch(cm)).on("P", diffChunkNav(cm, true)).on("Shift-O", openClosePublished(cm)).on("Shift-Left", flipCursorSide(cm, true)).on("Shift-Right", flipCursorSide(cm, false)));
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand2(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            openReplyBox().run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    keysNavigation.add(new UpToChangeCommand2(revision, 0, 'u'));
    keysNavigation.add(new NoOpKeyCommand(0, 'j', PatchUtil.C.lineNext()));
    keysNavigation.add(new NoOpKeyCommand(0, 'k', PatchUtil.C.linePrev()));
    keysAction = new KeyCommandSet(Gerrit.C.sectionActions());
    keysAction.add(new NoOpKeyCommand(0, 'o', PatchUtil.C.expandComment()));
    keysAction.add(new KeyCommand(0, 'r', PatchUtil.C.toggleReviewed()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            toggleReviewed().run();
        }
    });
    keysAction.add(new KeyCommand(0, 'a', PatchUtil.C.openReply()) {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            upToChange(true).run();
        }
    });
    keysOpenByEnter = new KeyCommandSet(Gerrit.C.sectionNavigation());
    keysOpenByEnter.add(new NoOpKeyCommand(0, KeyCodes.KEY_ENTER, PatchUtil.C.expandComment()));
    if (Gerrit.isSignedIn()) {
        keysAction.add(new NoOpKeyCommand(0, 'c', PatchUtil.C.commentInsert()));
        keysComment = new KeyCommandSet(PatchUtil.C.commentEditorSet());
        keysComment.add(new NoOpKeyCommand(KeyCommand.M_CTRL, 's', PatchUtil.C.commentSaveDraft()));
        keysComment.add(new NoOpKeyCommand(0, KeyCodes.KEY_ESCAPE, PatchUtil.C.commentCancelEdit()));
    } else {
        keysComment = null;
    }
    removeKeyHandlerRegs();
    handlers.add(GlobalKey.add(this, keysNavigation));
    handlers.add(GlobalKey.add(this, keysAction));
    handlers.add(GlobalKey.add(this, keysOpenByEnter));
    if (keysComment != null) {
        handlers.add(GlobalKey.add(this, keysComment));
    }
}
#end_block

#method_before
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    Collections.sort(diffChunks, getDiffChunkComparator());
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    lineLastPublishedBoxMap = new HashMap<LineHandle, PublishedBox>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
}
#method_after
private void display(DiffInfo diffInfo) {
    cmA = displaySide(diffInfo.meta_a(), diffInfo.text_a(), diffTable.cmA);
    cmB = displaySide(diffInfo.meta_b(), diffInfo.text_b(), diffTable.cmB);
    skips = new ArrayList<SkippedLine>();
    linePaddingOnOtherSideMap = new HashMap<LineHandle, LinePaddingWidgetWrapper>();
    diffChunks = new ArrayList<DiffChunkInfo>();
    render(diffInfo);
    Collections.sort(diffChunks, getDiffChunkComparator());
    lineActiveBoxMap = new HashMap<LineHandle, CommentBox>();
    linePublishedBoxesMap = new HashMap<LineHandle, List<PublishedBox>>();
    linePaddingManagerMap = new HashMap<LineHandle, PaddingManager>();
    if (publishedBase != null || publishedRevision != null) {
        publishedMap = new HashMap<String, PublishedBox>();
    }
    if (publishedBase != null) {
        renderPublished(publishedBase);
    }
    if (publishedRevision != null) {
        renderPublished(publishedRevision);
    }
    if (draftsBase != null) {
        renderDrafts(draftsBase);
    }
    if (draftsRevision != null) {
        renderDrafts(draftsRevision);
    }
    renderSkips();
    registerCmEvents(cmA);
    registerCmEvents(cmB);
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            resizeCodeMirror();
        }
    });
    if (pref.isShowTabs()) {
        diffTable.addStyleName(DiffTable.style.showtabs());
    }
}
#end_block

#method_before
void removeDraft(DraftBox box, int line) {
    LineHandle handle = getCmFromSide(box.getSide()).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (lineLastPublishedBoxMap.containsKey(handle)) {
        lineActiveBoxMap.put(handle, lineLastPublishedBoxMap.get(handle));
    }
}
#method_after
void removeDraft(DraftBox box, int line) {
    LineHandle handle = getCmFromSide(box.getSide()).getLineHandle(line);
    lineActiveBoxMap.remove(handle);
    if (linePublishedBoxesMap.containsKey(handle)) {
        List<PublishedBox> list = linePublishedBoxesMap.get(handle);
        lineActiveBoxMap.put(handle, list.get(list.size() - 1));
    }
}
#end_block

#method_before
private void renderPublished(JsArray<CommentInfo> published) {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = published == publishedBase ? DisplaySide.A : DisplaySide.B;
        }
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        lineLastPublishedBoxMap.put(handle, box);
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#method_after
private void renderPublished(JsArray<CommentInfo> published) {
    List<CommentInfo> sorted = sortComment(published);
    for (CommentInfo info : sorted) {
        DisplaySide side;
        if (info.side() == Side.PARENT) {
            if (base != null) {
                continue;
            }
            side = DisplaySide.A;
        } else {
            side = published == publishedBase ? DisplaySide.A : DisplaySide.B;
        }
        CodeMirror cm = getCmFromSide(side);
        PublishedBox box = new PublishedBox(this, cm, side, commentLinkProcessor, getPatchSetIdFromSide(side), info);
        publishedMap.put(info.id(), box);
        if (!info.has_line()) {
            diffTable.addFileCommentBox(box);
            continue;
        }
        int line = info.line() - 1;
        LineHandle handle = cm.getLineHandle(line);
        if (linePublishedBoxesMap.containsKey(handle)) {
            linePublishedBoxesMap.get(handle).add(box);
        } else {
            List<PublishedBox> list = new ArrayList<PublishedBox>();
            list.add(box);
            linePublishedBoxesMap.put(handle, list);
        }
        lineActiveBoxMap.put(handle, box);
        addCommentBox(info, box);
    }
}
#end_block

#method_before
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            if (!(cm.hasActiveLine() && cm.getLineNumber(cm.getActiveLine()) == line)) {
                cm.setCursor(LineCharacter.create(line));
                updateActiveLine(cm).run();
            }
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    insertNewDraft(cm).run();
                }
            });
        }
    };
}
#method_after
private GutterClickHandler onGutterClick(final CodeMirror cm) {
    return new GutterClickHandler() {

        @Override
        public void handle(CodeMirror instance, int line, String gutter, NativeEvent clickEvent) {
            if (!(cm.hasActiveLine() && cm.getLineNumber(cm.getActiveLine()) == line)) {
                cm.setCursor(LineCharacter.create(line));
            }
            Scheduler.get().scheduleDeferred(new ScheduledCommand() {

                @Override
                public void execute() {
                    insertNewDraft(cm).run();
                }
            });
        }
    };
}
#end_block

#method_before
private Runnable upToChange() {
    return new Runnable() {

        public void run() {
            Gerrit.display(PageLinks.toChange2(revision.getParentKey(), String.valueOf(revision.get())));
        }
    };
}
#method_after
private Runnable upToChange(final boolean openReplyBox) {
    return new Runnable() {

        public void run() {
            String rev = String.valueOf(revision.get());
            Gerrit.display(PageLinks.toChange2(changeId, rev), new ChangeScreen2(changeId, rev, openReplyBox));
        }
    };
}
#end_block

#method_before
private DiffChunkInfo getDiffChunk(DisplaySide side, int line) {
    int res = Collections.binarySearch(diffChunks, // Dummy DiffChunkInfo
    new DiffChunkInfo(side, line, 0, false), getDiffChunkComparator());
    return res >= 0 ? diffChunks.get(res) : null;
}
#method_after
private DiffChunkInfo getDiffChunk(DisplaySide side, int line) {
    int res = Collections.binarySearch(diffChunks, // Dummy DiffChunkInfo
    new DiffChunkInfo(side, line, 0, false), getDiffChunkComparator());
    if (res >= 0) {
        return diffChunks.get(res);
    } else {
        // The line might be within a DiffChunk
        res = -res - 1;
        if (res > 0) {
            DiffChunkInfo info = diffChunks.get(res - 1);
            if (info.side == side && info.start <= line && line <= info.end) {
                return info;
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public IncludedInDetail call() throws OrmException, NoSuchChangeException, IOException, InvalidRevisionException {
    control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(control.getChange().currentPatchSetId());
    final Repository repo = repoManager.openRepository(control.getProject().getNameKey());
    try {
        final RevWalk rw = new RevWalk(repo);
        try {
            rw.setRetainBody(false);
            final RevCommit rev;
            try {
                rev = rw.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            } catch (IncorrectObjectTypeException err) {
                throw new InvalidRevisionException();
            } catch (MissingObjectException err) {
                throw new InvalidRevisionException();
            }
            List<Ref> tags = new ArrayList<Ref>(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
            List<Ref> branches = new ArrayList<Ref>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
            Set<Ref> allRefs = new HashSet<Ref>();
            allRefs.addAll(tags);
            allRefs.addAll(branches);
            List<Ref> allMatchingRefs = includedIn(repo, rw, rev, allRefs);
            detail = new IncludedInDetail();
            detail.setBranches(getMatchingRefNames(allMatchingRefs, branches));
            detail.setTags(getMatchingRefNames(allMatchingRefs, tags));
            return detail;
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#method_after
@Override
public IncludedInDetail call() throws OrmException, NoSuchChangeException, IOException, InvalidRevisionException {
    control = changeControlFactory.validateFor(changeId);
    final PatchSet patch = db.patchSets().get(control.getChange().currentPatchSetId());
    final Repository repo = repoManager.openRepository(control.getProject().getNameKey());
    try {
        final RevWalk rw = new RevWalk(repo);
        try {
            rw.setRetainBody(false);
            final RevCommit rev;
            try {
                rev = rw.parseCommit(ObjectId.fromString(patch.getRevision().get()));
            } catch (IncorrectObjectTypeException err) {
                throw new InvalidRevisionException();
            } catch (MissingObjectException err) {
                throw new InvalidRevisionException();
            }
            return IncludedInResolver.resolve(repo, rw, rev);
        } finally {
            rw.release();
        }
    } finally {
        repo.close();
    }
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
    UiExtensionsApi.topMenu(new GerritCallback<TopMenuExtensionList>() {

        public void onSuccess(TopMenuExtensionList result) {
            topMenuExtensions = Natives.asList(result);
            refreshMenuBar();
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#end_block

#method_before
private static void populateBottomMenu(final RootPanel btmmenu) {
    final Label keyHelp = new Label(C.keyHelp());
    keyHelp.setStyleName(RESOURCES.css().keyhelp());
    btmmenu.add(keyHelp);
    String vs;
    if (GWT.isScript()) {
        final ClientVersion v = GWT.create(ClientVersion.class);
        vs = v.version().getText();
        if (vs.startsWith("v")) {
            vs = vs.substring(1);
        }
    } else {
        vs = "dev";
    }
    FlowPanel poweredBy = new FlowPanel();
    poweredBy.setStyleName(RESOURCES.css().version());
    poweredBy.add(new InlineHTML(M.poweredBy(vs)));
    if (getConfig().getReportBugUrl() != null) {
        poweredBy.add(new InlineLabel(" | "));
        Anchor a = new Anchor(C.reportBug(), getConfig().getReportBugUrl());
        a.setTarget("_blank");
        a.setStyleName("");
        poweredBy.add(a);
    }
    btmmenu.add(poweredBy);
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineLabel(C.keyHelp()));
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    if (getConfig().getReportBugUrl() != null) {
        Anchor a = new Anchor(C.reportBug(), getConfig().getReportBugUrl());
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    final RootPanel gTopMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    final RootPanel gBottomMenu = RootPanel.get("gerrit_btmmenu");
    gTopMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    gTopMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            final String token = view.getToken();
            if (!token.equals(History.getToken())) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(gTopMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(gBottomMenu);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            lastViewToken = History.getToken();
            String token = view.getToken();
            if (!token.equals(lastViewToken)) {
                History.newItem(token, false);
                dispatchHistoryHooks(token);
            }
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus(topMenu);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    applyUserPreferences();
    initHistoryHooks();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(final ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    String token = History.getToken();
    if (token.isEmpty()) {
        token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
    }
    if (signInAnchor != null) {
        signInAnchor.setHref(loginRedirect(token));
    }
    saveDefaultTheme();
    loadPlugins(hpd, token);
}
#end_block

#method_before
private void loadPlugins(HostPageData hpd, final String token) {
    if (hpd.plugins != null) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d = new ErrorDialog(reason);
                    d.setTitle(M.pluginFailed(url));
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#method_after
private void loadPlugins(HostPageData hpd, final String token) {
    ApiGlue.init();
    if (hpd.plugins != null && !hpd.plugins.isEmpty()) {
        for (final String url : hpd.plugins) {
            ScriptInjector.fromUrl(url).setWindow(ScriptInjector.TOP_WINDOW).setCallback(new Callback<Void, Exception>() {

                @Override
                public void onSuccess(Void result) {
                }

                @Override
                public void onFailure(Exception reason) {
                    ErrorDialog d = new ErrorDialog(reason);
                    d.setTitle(M.pluginFailed(url));
                    d.center();
                }
            }).inject();
        }
    }
    CallbackHandle<Void> cb = new CallbackHandle<Void>(new ResultDeserializer<Void>() {

        @Override
        public Void fromResult(JavaScriptObject responseObject) {
            return null;
        }
    }, new AsyncCallback<Void>() {

        @Override
        public void onFailure(Throwable caught) {
        }

        @Override
        public void onSuccess(Void result) {
            display(token);
        }
    });
    cb.install();
    ScriptInjector.fromString(cb.getFunctionName() + "();").setWindow(ScriptInjector.TOP_WINDOW).inject();
}
#end_block

#method_before
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case HTTP:
            case HTTP_LDAP:
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    if (topMenuExtensions != null) {
        for (TopMenuExtension menu : topMenuExtensions) {
            LinkMenuBar bar = new LinkMenuBar();
            for (TopMenuExtensionItem item : Natives.asList(menu.getItems())) {
                addExtensionLink(bar, item.getName(), item.getUrl());
            }
            menuLeft.add(bar, menu.getName());
        }
    }
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    final boolean signedIn = isSignedIn();
    final GerritConfig cfg = getConfig();
    LinkMenuBar m;
    m = new LinkMenuBar();
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        m = new LinkMenuBar();
        addLink(m, C.menuMyChanges(), PageLinks.MINE);
        addLink(m, C.menuMyDrafts(), PageLinks.toChangeQuery("is:draft"));
        addLink(m, C.menuMyDraftComments(), PageLinks.toChangeQuery("has:draft"));
        addLink(m, C.menuMyWatchedChanges(), PageLinks.toChangeQuery("is:watched status:open"));
        addLink(m, C.menuMyStarredChanges(), PageLinks.toChangeQuery("is:starred"));
        menuLeft.add(m, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    diffBar = new LinkMenuBar();
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, CC.patchTableDiffSideBySide(), PatchScreen.Type.SIDE_BY_SIDE);
    addDiffLink(diffBar, CC.patchTableDiffUnified(), PatchScreen.Type.UNIFIED);
    addDiffLink(diffBar, C.menuDiffCommit(), PatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), PatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), PatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), PatchScreen.TopView.FILES);
    projectsBar = new LinkMenuBar() {

        @Override
        public void onScreenLoad(ScreenLoadEvent event) {
            if (event.getScreen() instanceof ProjectScreen) {
                menuLeft.selectTab(menuLeft.getWidgetIndex(this));
            }
        }
    };
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    addProjectLink(projectsBar, C.menuProjectsInfo(), ProjectScreen.INFO);
    addProjectLink(projectsBar, C.menuProjectsBranches(), ProjectScreen.BRANCH);
    addProjectLink(projectsBar, C.menuProjectsAccess(), ProjectScreen.ACCESS);
    addProjectLink(projectsBar, C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    addLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    addLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP);
                }
                if (result.canPerform(ADMINISTRATE_SERVER)) {
                    addLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, ADMINISTRATE_SERVER);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        addDocLink(m, C.menuDocumentationIndex(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(cfg.getAuthType() != AuthType.CLIENT_SSL_CERT_LDAP);
    } else {
        switch(cfg.getAuthType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (cfg.getLoginUrl() != null) {
                    final String signinText = cfg.getLoginText() == null ? C.menuSignIn() : cfg.getLoginText();
                    menuRight.add(anchor(signinText, cfg.getLoginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (cfg.getRegisterUrl() != null) {
                    final String registerText = cfg.getRegisterText() == null ? C.menuRegister() : cfg.getRegisterText();
                    menuRight.add(anchor(registerText, cfg.getRegisterUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                LinkMenuBar bar = new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addExtensionLink(bar, item);
                }
                menuLeft.add(bar, menu.getName());
            }
        }
    });
}
#end_block

#method_before
private static void addExtensionLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, href);
    atag.setTarget("_blank");
    m.add(atag);
}
#method_after
private static void addExtensionLink(final LinkMenuBar m, final TopMenuItem item) {
    final Anchor atag = anchor(item.getName(), item.getUrl());
    atag.setTarget(item.getTarget());
    m.add(atag);
}
#end_block

#method_before
protected void initColumnHeaders() {
    table.setText(0, P_STATE, Util.C.projectState());
    table.getCellFormatter().getElement(0, P_STATE).setTitle(Util.C.projectStateHelp());
    table.setText(0, P_NAME, Util.C.projectName());
    table.setText(0, P_DESCRIPTION, Util.C.projectDescription());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(0, P_STATE, Gerrit.RESOURCES.css().iconHeader());
    fmt.addStyleName(0, P_NAME, Gerrit.RESOURCES.css().dataHeader());
    fmt.addStyleName(0, P_DESCRIPTION, Gerrit.RESOURCES.css().dataHeader());
}
#method_after
protected void initColumnHeaders() {
    table.setText(0, C_STATE, Util.C.projectStateAbbrev());
    table.getCellFormatter().getElement(0, C_STATE).setTitle(Util.C.projectStateHelp());
    table.setText(0, C_NAME, Util.C.projectName());
    table.setText(0, C_DESCRIPTION, Util.C.projectDescription());
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(0, C_STATE, Gerrit.RESOURCES.css().iconHeader());
    fmt.addStyleName(0, C_NAME, Gerrit.RESOURCES.css().dataHeader());
    fmt.addStyleName(0, C_DESCRIPTION, Gerrit.RESOURCES.css().dataHeader());
}
#end_block

#method_before
protected void insert(final int row, final ProjectInfo k) {
    table.insertRow(row);
    applyDataRowStyle(row);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, P_STATE, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, P_NAME, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, P_NAME, Gerrit.RESOURCES.css().projectNameColumn());
    fmt.addStyleName(row, P_DESCRIPTION, Gerrit.RESOURCES.css().dataCell());
    populate(row, k);
}
#method_after
protected void insert(final int row, final ProjectInfo k) {
    table.insertRow(row);
    applyDataRowStyle(row);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    fmt.addStyleName(row, C_STATE, Gerrit.RESOURCES.css().iconCell());
    fmt.addStyleName(row, C_NAME, Gerrit.RESOURCES.css().dataCell());
    fmt.addStyleName(row, C_NAME, Gerrit.RESOURCES.css().projectNameColumn());
    fmt.addStyleName(row, C_DESCRIPTION, Gerrit.RESOURCES.css().dataCell());
    populate(row, k);
}
#end_block

#method_before
protected void populate(final int row, final ProjectInfo k) {
    table.setText(row, P_STATE, k.state());
    table.setText(row, P_NAME, k.name());
    table.setText(row, P_DESCRIPTION, k.description());
    setRowItem(row, k);
}
#method_after
protected void populate(final int row, final ProjectInfo k) {
    table.setText(row, C_STATE, k.state().toString());
    table.setText(row, C_NAME, k.name());
    table.setText(row, C_DESCRIPTION, k.description());
    setRowItem(row, k);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, ProjectsTable.getpGitUrl(), Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, ProjectsTable.getpGitUrl(), Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProject(item.name_key());
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, ProjectsTable.getpGitUrl(), Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            Image state = new Image();
            if ("HIDDEN".equals(k.state())) {
                state.setResource(Gerrit.RESOURCES.redNot());
                state.setTitle("Hidden");
            } else if ("READ_ONLY".equals(k.state())) {
                state = new Image(Gerrit.RESOURCES.readOnly());
                state.setTitle("Read Only");
            } else {
                state = new Image(Gerrit.RESOURCES.active());
                state.setTitle("Active");
            }
            table.setWidget(row, ProjectsTable.getpState(), state);
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new HighlightingInlineHyperlink(k.name(), link(k), subname));
            table.setWidget(row, ProjectsTable.getpName(), fp);
            table.setText(row, ProjectsTable.getpDescription(), k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, ProjectsTable.getpGitUrl(), new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            if (Gerrit.getGitwebLink() != null) {
                table.setText(0, ProjectsTable.C_REPO_BROWSER, Util.C.projectRepoBrowser());
                table.getFlexCellFormatter().addStyleName(0, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataHeader());
            }
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProject(item.name_key());
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            if (Gerrit.getGitwebLink() != null) {
                table.getFlexCellFormatter().addStyleName(row, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataCell());
            }
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            Image state = new Image();
            switch(k.state()) {
                case HIDDEN:
                    state.setResource(Gerrit.RESOURCES.redNot());
                    state.setTitle(Util.toLongString(k.state()));
                    table.setWidget(row, ProjectsTable.C_STATE, state);
                    break;
                case READ_ONLY:
                    state.setResource(Gerrit.RESOURCES.readOnly());
                    state.setTitle(Util.toLongString(k.state()));
                    table.setWidget(row, ProjectsTable.C_STATE, state);
                    break;
                default:
                    // Intentionally left blank, do not show an icon when active.
                    break;
            }
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new HighlightingInlineHyperlink(k.name(), link(k), subname));
            table.setWidget(row, ProjectsTable.C_NAME, fp);
            table.setText(row, ProjectsTable.C_DESCRIPTION, k.description());
            GitwebLink l = Gerrit.getGitwebLink();
            if (l != null) {
                table.setWidget(row, ProjectsTable.C_REPO_BROWSER, new Anchor(l.getLinkName(), false, l.toProject(k.name_key())));
            }
            setRowItem(row, k);
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
}
#end_block

#method_before
public Map<String, ProjectInfo> display(OutputStream displayOutputStream) {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = Iterables.getFirst(e.parents(), null);
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                        info.state = parentState.getProject().getState().toString();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = Iterables.getFirst(e.parents(), null);
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                info.state = Strings.emptyToNull(e.getProject().getState().toString());
                try {
                    if (!showBranch.isEmpty()) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.finish();
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public Map<String, ProjectInfo> display(OutputStream displayOutputStream) {
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        try {
            stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, "UTF-8")));
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException("JVM lacks UTF-8 encoding", e);
        }
    }
    int found = 0;
    Map<String, ProjectInfo> output = Maps.newTreeMap();
    Map<String, String> hiddenNames = Maps.newHashMap();
    Set<String> rejected = new HashSet<String>();
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<Project.NameKey, ProjectNode>();
    try {
        for (final Project.NameKey projectName : scan()) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null) {
                // 
                continue;
            }
            final ProjectControl pctl = e.controlFor(currentUser);
            if (groupUuid != null) {
                try {
                    if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                        break;
                    }
                } catch (NoSuchGroupException ex) {
                    break;
                }
                if (!pctl.getLocalGroups().contains(GroupReference.forGroup(groupCache.get(groupUuid)))) {
                    continue;
                }
            }
            ProjectInfo info = new ProjectInfo();
            if (type == FilterType.PARENT_CANDIDATES) {
                ProjectState parentState = Iterables.getFirst(e.parents(), null);
                if (parentState != null && !output.keySet().contains(parentState.getProject().getName()) && !rejected.contains(parentState.getProject().getName())) {
                    ProjectControl parentCtrl = parentState.controlFor(currentUser);
                    if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                        info.name = parentState.getProject().getName();
                        info.description = Strings.emptyToNull(parentState.getProject().getDescription());
                        info.state = parentState.getProject().getState();
                    } else {
                        rejected.add(parentState.getProject().getName());
                        continue;
                    }
                } else {
                    continue;
                }
            } else {
                final boolean isVisible = pctl.isVisible() || (all && pctl.isOwner());
                if (showTree && !format.isJson()) {
                    treeMap.put(projectName, projectNodeFactory.create(pctl.getProject(), isVisible));
                    continue;
                }
                if (!isVisible && !(showTree && pctl.isOwner())) {
                    // 
                    continue;
                }
                info.name = projectName.get();
                if (showTree && format.isJson()) {
                    ProjectState parent = Iterables.getFirst(e.parents(), null);
                    if (parent != null) {
                        ProjectControl parentCtrl = parent.controlFor(currentUser);
                        if (parentCtrl.isVisible() || parentCtrl.isOwner()) {
                            info.parent = parent.getProject().getName();
                        } else {
                            info.parent = hiddenNames.get(parent.getProject().getName());
                            if (info.parent == null) {
                                info.parent = "?-" + (hiddenNames.size() + 1);
                                hiddenNames.put(parent.getProject().getName(), info.parent);
                            }
                        }
                    }
                }
                if (showDescription) {
                    info.description = Strings.emptyToNull(e.getProject().getDescription());
                }
                info.state = e.getProject().getState();
                try {
                    if (!showBranch.isEmpty()) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                            List<Ref> refs = getBranchRefs(projectName, pctl);
                            if (!hasValidRef(refs)) {
                                continue;
                            }
                            for (int i = 0; i < showBranch.size(); i++) {
                                Ref ref = refs.get(i);
                                if (ref != null && ref.getObjectId() != null) {
                                    if (info.branches == null) {
                                        info.branches = Maps.newLinkedHashMap();
                                    }
                                    info.branches.put(showBranch.get(i), ref.getObjectId().name());
                                }
                            }
                        } finally {
                            git.close();
                        }
                    } else if (!showTree && type != FilterType.ALL) {
                        Repository git = repoManager.openRepository(projectName);
                        try {
                            if (!type.matches(git)) {
                                continue;
                            }
                        } finally {
                            git.close();
                        }
                    }
                } catch (RepositoryNotFoundException err) {
                    // If the Git repository is gone, the project doesn't actually exist anymore.
                    continue;
                } catch (IOException err) {
                    log.warn("Unexpected error reading " + projectName, err);
                    continue;
                }
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.finish();
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
public ProjectInfo format(Project p) {
    ProjectInfo info = new ProjectInfo();
    info.name = p.getName();
    Project.NameKey parentName = p.getParent(allProjects);
    info.parent = parentName != null ? parentName.get() : null;
    info.description = Strings.emptyToNull(p.getDescription());
    info.state = p.getState().toString();
    info.finish();
    return info;
}
#method_after
public ProjectInfo format(Project p) {
    ProjectInfo info = new ProjectInfo();
    info.name = p.getName();
    Project.NameKey parentName = p.getParent(allProjects);
    info.parent = parentName != null ? parentName.get() : null;
    info.description = Strings.emptyToNull(p.getDescription());
    info.state = p.getState();
    info.finish();
    return info;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    changeScreen = new ListBox();
    changeScreen.addItem(Util.M.changeScreenServerDefault(getLabel(Gerrit.getConfig().getChangeScreen())), "");
    changeScreen.addItem(Util.C.changeScreenOldUi(), AccountGeneralPreferences.ChangeScreen.OLD_UI.name());
    changeScreen.addItem(Util.C.changeScreenNewUi(), AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacyCIDInChangeTable = new CheckBox(Util.C.showLegacyCIDInChangeTable());
    final Grid formGrid = new Grid(12, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, legacyCIDInChangeTable);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, Util.C.changeScreenLabel());
        formGrid.setWidget(row, fieldIdx, changeScreen);
        row++;
        formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
        formGrid.setWidget(row, fieldIdx, diffView);
    }
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacyCIDInChangeTable);
    e.listenTo(commentVisibilityStrategy);
    e.listenTo(changeScreen);
    e.listenTo(diffView);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    changeScreen = new ListBox();
    changeScreen.addItem(Util.M.changeScreenServerDefault(getLabel(Gerrit.getConfig().getChangeScreen())), "");
    changeScreen.addItem(Util.C.changeScreenOldUi(), AccountGeneralPreferences.ChangeScreen.OLD_UI.name());
    changeScreen.addItem(Util.C.changeScreenNewUi(), AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    final Grid formGrid = new Grid(13, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, Util.C.changeScreenLabel());
        formGrid.setWidget(row, fieldIdx, changeScreen);
        row++;
        formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
        formGrid.setWidget(row, fieldIdx, diffView);
    }
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(commentVisibilityStrategy);
    e.listenTo(changeScreen);
    e.listenTo(diffView);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacyCIDInChangeTable.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
    changeScreen.setEnabled(on);
    diffView.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
    changeScreen.setEnabled(on);
    diffView.setEnabled(on);
}
#end_block

#method_before
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    reversePatchSetOrder.setValue(p.reversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.showUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacyCIDInChangeTable.setValue(p.legacyCIDInChangeTable());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT, p.commentVisibilityStrategy());
    setListBox(changeScreen, null, p.changeScreen());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#method_after
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    reversePatchSetOrder.setValue(p.reversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.showUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT, p.commentVisibilityStrategy());
    setListBox(changeScreen, null, p.changeScreen());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, CommentVisibilityStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.setChangeScreen(getListBox(changeScreen, null, AccountGeneralPreferences.ChangeScreen.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").post(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            Dispatcher.changeScreen2 = false;
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, CommentVisibilityStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.setChangeScreen(getListBox(changeScreen, null, AccountGeneralPreferences.ChangeScreen.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").post(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            Dispatcher.changeScreen2 = false;
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    reversePatchSetOrder = false;
    showUserInReview = false;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    commentVisibilityStrategy = null;
    diffView = null;
    changeScreen = null;
    sizeBarInChangeTable = true;
    legacyCIDInChangeTable = false;
}
#method_after
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    reversePatchSetOrder = false;
    showUserInReview = false;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    commentVisibilityStrategy = null;
    diffView = null;
    changeScreen = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
}
#end_block

#method_before
public static Preferences create(AccountGeneralPreferences in, List<TopMenuItem> myMenus) {
    Preferences p = createObject().cast();
    if (in == null) {
        in = AccountGeneralPreferences.createDefault();
    }
    p.changesPerPage(in.getMaximumPageSize());
    p.showSiteHeader(in.isShowSiteHeader());
    p.useFlashClipboard(in.isUseFlashClipboard());
    p.downloadScheme(in.getDownloadUrl());
    p.downloadCommand(in.getDownloadCommand());
    p.copySelfOnEmail(in.isCopySelfOnEmails());
    p.dateFormat(in.getDateFormat());
    p.timeFormat(in.getTimeFormat());
    p.reversePatchSetOrder(in.isReversePatchSetOrder());
    p.showUsernameInReviewCategory(in.isShowUsernameInReviewCategory());
    p.relativeDateInChangeTable(in.isRelativeDateInChangeTable());
    p.sizeBarInChangeTable(in.isSizeBarInChangeTable());
    p.legacyCIDInChangeTable(in.isLegacyCIDInChangeTable());
    p.commentVisibilityStrategy(in.getCommentVisibilityStrategy());
    p.diffView(in.getDiffView());
    p.changeScreen(in.getChangeScreen());
    p.setMyMenus(myMenus);
    return p;
}
#method_after
public static Preferences create(AccountGeneralPreferences in, List<TopMenuItem> myMenus) {
    Preferences p = createObject().cast();
    if (in == null) {
        in = AccountGeneralPreferences.createDefault();
    }
    p.changesPerPage(in.getMaximumPageSize());
    p.showSiteHeader(in.isShowSiteHeader());
    p.useFlashClipboard(in.isUseFlashClipboard());
    p.downloadScheme(in.getDownloadUrl());
    p.downloadCommand(in.getDownloadCommand());
    p.copySelfOnEmail(in.isCopySelfOnEmails());
    p.dateFormat(in.getDateFormat());
    p.timeFormat(in.getTimeFormat());
    p.reversePatchSetOrder(in.isReversePatchSetOrder());
    p.showUsernameInReviewCategory(in.isShowUsernameInReviewCategory());
    p.relativeDateInChangeTable(in.isRelativeDateInChangeTable());
    p.sizeBarInChangeTable(in.isSizeBarInChangeTable());
    p.legacycidInChangeTable(in.isLegacycidInChangeTable());
    p.commentVisibilityStrategy(in.getCommentVisibilityStrategy());
    p.diffView(in.getDiffView());
    p.changeScreen(in.getChangeScreen());
    p.setMyMenus(myMenus);
    return p;
}
#end_block

#method_before
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_SUBJECT; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isLegacyCIDInChangeTable()) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    int i = C_SIZE;
    if (useNewFeatures) {
        fmt.addStyleName(row, i++, Gerrit.RESOURCES.css().cSIZE());
    }
    for (; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#method_after
@Override
protected void applyDataRowStyle(final int row) {
    super.applyDataRowStyle(row);
    final CellFormatter fmt = table.getCellFormatter();
    fmt.addStyleName(row, C_STAR, Gerrit.RESOURCES.css().iconCell());
    for (int i = C_ID; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().dataCell());
    }
    fmt.addStyleName(row, C_SUBJECT, Gerrit.RESOURCES.css().cSUBJECT());
    fmt.addStyleName(row, C_STATUS, Gerrit.RESOURCES.css().cSTATUS());
    fmt.addStyleName(row, C_OWNER, Gerrit.RESOURCES.css().cOWNER());
    fmt.addStyleName(row, C_LAST_UPDATE, Gerrit.RESOURCES.css().cLastUpdate());
    if (!Gerrit.isSignedIn() || (!Gerrit.getUserAccount().getGeneralPreferences().isLegacycidInChangeTable())) {
        fmt.addStyleName(row, C_ID, Gerrit.RESOURCES.css().dataCellHidden());
    }
    int i = C_SIZE;
    if (useNewFeatures) {
        fmt.addStyleName(row, i++, Gerrit.RESOURCES.css().cSIZE());
    }
    for (; i < columns; i++) {
        fmt.addStyleName(row, i, Gerrit.RESOURCES.css().cAPPROVAL());
    }
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink("Change " + c.legacy_id().toString(), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable() && useNewFeatures) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key(), c.status()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (useNewFeatures) {
        if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
            table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        } else {
            table.setWidget(row, col, getSizeWidget(c));
            fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        }
        col++;
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable() && useNewFeatures) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (useNewFeatures) {
        if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
            table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        } else {
            table.setWidget(row, col, getSizeWidget(c));
            fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        }
        col++;
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private AuthResult create(final ReviewDb db, final AuthRequest who) throws OrmException, AccountException {
    final Account.Id newId = new Account.Id(db.nextAccountId());
    final Account account = new Account(newId, TimeUtil.nowTs());
    final AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    final boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        db.accountExternalIds().upsert(Collections.singleton(extId));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        final AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        final AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        final AccountGroup.Id adminId = g.getId();
        final AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddGroupMembers(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            final String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            final String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            final String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#method_after
private AuthResult create(final ReviewDb db, final AuthRequest who) throws OrmException, AccountException {
    final Account.Id newId = new Account.Id(db.nextAccountId());
    final Account account = new Account(newId, TimeUtil.nowTs());
    final AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    final boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        db.accountExternalIds().upsert(Collections.singleton(extId));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        final AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        final AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        final AccountGroup.Id adminId = g.getId();
        final AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            final String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            final String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            final String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#end_block

#method_before
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            hooks.doClaSignupHook(account, ca);
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddGroupMembers(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void enterAgreement(final String agreementName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            ContributorAgreement ca = projectCache.getAllProjects().getConfig().getContributorAgreement(agreementName);
            if (ca == null) {
                throw new Failure(new NoSuchEntityException());
            }
            if (ca.getAutoVerify() == null) {
                throw new Failure(new IllegalStateException("cannot enter a non-autoVerify agreement"));
            } else if (ca.getAutoVerify().getUUID() == null) {
                throw new Failure(new NoSuchEntityException());
            }
            AccountGroup group = groupCache.get(ca.getAutoVerify().getUUID());
            if (group == null) {
                throw new Failure(new NoSuchEntityException());
            }
            Account account = user.get().getAccount();
            hooks.doClaSignupHook(account, ca);
            final AccountGroupMember.Key key = new AccountGroupMember.Key(account.getId(), group.getId());
            AccountGroupMember m = db.accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                auditService.dispatchAddAccountsToGroup(account.getId(), Collections.singleton(m));
                db.accountGroupMembers().insert(Collections.singleton(m));
                accountCache.evict(m.getAccountId());
            }
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
@Override
public List<AccountInfo> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<Account.Id, AccountGroupMember> newAccountGroupMembers = Maps.newHashMap();
    List<AccountInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    AccountInfo.Loader loader = infoFactory.create(true);
    for (String nameOrEmail : input.members) {
        Account a = findAccount(nameOrEmail);
        if (!a.isActive()) {
            throw new UnprocessableEntityException(String.format("Account Inactive: %s", nameOrEmail));
        }
        if (!control.canAddMember(a.getId())) {
            throw new AuthException("Cannot add member: " + a.getFullName());
        }
        if (!newAccountGroupMembers.containsKey(a.getId())) {
            AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), internalGroup.getId());
            AccountGroupMember m = db.get().accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                newAccountGroupMembers.put(m.getAccountId(), m);
            }
        }
        result.add(loader.get(a.getId()));
    }
    auditService.dispatchAddGroupMembers(me, newAccountGroupMembers.values());
    db.get().accountGroupMembers().insert(newAccountGroupMembers.values());
    for (AccountGroupMember m : newAccountGroupMembers.values()) {
        accountCache.evict(m.getAccountId());
    }
    loader.fill();
    return result;
}
#method_after
@Override
public List<AccountInfo> apply(GroupResource resource, Input input) throws AuthException, MethodNotAllowedException, UnprocessableEntityException, OrmException {
    AccountGroup internalGroup = resource.toAccountGroup();
    if (internalGroup == null) {
        throw new MethodNotAllowedException();
    }
    input = Input.init(input);
    GroupControl control = resource.getControl();
    Map<Account.Id, AccountGroupMember> newAccountGroupMembers = Maps.newHashMap();
    List<AccountInfo> result = Lists.newLinkedList();
    Account.Id me = ((IdentifiedUser) control.getCurrentUser()).getAccountId();
    AccountInfo.Loader loader = infoFactory.create(true);
    for (String nameOrEmail : input.members) {
        Account a = findAccount(nameOrEmail);
        if (!a.isActive()) {
            throw new UnprocessableEntityException(String.format("Account Inactive: %s", nameOrEmail));
        }
        if (!control.canAddMember(a.getId())) {
            throw new AuthException("Cannot add member: " + a.getFullName());
        }
        if (!newAccountGroupMembers.containsKey(a.getId())) {
            AccountGroupMember.Key key = new AccountGroupMember.Key(a.getId(), internalGroup.getId());
            AccountGroupMember m = db.get().accountGroupMembers().get(key);
            if (m == null) {
                m = new AccountGroupMember(key);
                newAccountGroupMembers.put(m.getAccountId(), m);
            }
        }
        result.add(loader.get(a.getId()));
    }
    auditService.dispatchAddAccountsToGroup(me, newAccountGroupMembers.values());
    db.get().accountGroupMembers().insert(newAccountGroupMembers.values());
    for (AccountGroupMember m : newAccountGroupMembers.values()) {
        accountCache.evict(m.getAccountId());
    }
    loader.fill();
    return result;
}
#end_block

#method_before
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    try {
        db.accountExternalIds().insert(Collections.singleton(extUser));
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    if (key != null) {
        db.accountSshKeys().insert(Collections.singleton(key));
    }
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddGroupMembers(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    sshKeyCache.evict(username);
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountInfo.Loader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#method_after
@Override
public Response<AccountInfo> apply(TopLevelResource rsrc, Input input) throws BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException {
    if (input == null) {
        input = new Input();
    }
    if (input.username != null && !username.equals(input.username)) {
        throw new BadRequestException("username must match URL");
    }
    if (!username.matches(Account.USER_NAME_PATTERN)) {
        throw new BadRequestException("Username '" + username + "'" + " must contain only letters, numbers, _, - or .");
    }
    Set<AccountGroup.Id> groups = parseGroups(input.groups);
    Account.Id id = new Account.Id(db.nextAccountId());
    AccountSshKey key = createSshKey(id, input.sshKey);
    AccountExternalId extUser = new AccountExternalId(id, new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, username));
    if (input.httpPassword != null) {
        extUser.setPassword(input.httpPassword);
    }
    if (db.accountExternalIds().get(extUser.getKey()) != null) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        if (db.accountExternalIds().get(getEmailKey(input.email)) != null) {
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
        if (!EmailValidator.getInstance().isValid(input.email)) {
            throw new BadRequestException("invalid email address");
        }
    }
    try {
        db.accountExternalIds().insert(Collections.singleton(extUser));
    } catch (OrmDuplicateKeyException duplicateKey) {
        throw new ResourceConflictException("username '" + username + "' already exists");
    }
    if (input.email != null) {
        AccountExternalId extMailto = new AccountExternalId(id, getEmailKey(input.email));
        extMailto.setEmailAddress(input.email);
        try {
            db.accountExternalIds().insert(Collections.singleton(extMailto));
        } catch (OrmDuplicateKeyException duplicateKey) {
            try {
                db.accountExternalIds().delete(Collections.singleton(extUser));
            } catch (OrmException cleanupError) {
            }
            throw new UnprocessableEntityException("email '" + input.email + "' already exists");
        }
    }
    Account a = new Account(id, TimeUtil.nowTs());
    a.setFullName(input.name);
    a.setPreferredEmail(input.email);
    db.accounts().insert(Collections.singleton(a));
    if (key != null) {
        db.accountSshKeys().insert(Collections.singleton(key));
    }
    for (AccountGroup.Id groupId : groups) {
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(id, groupId));
        auditService.dispatchAddAccountsToGroup(currentUser.get().getAccountId(), Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    sshKeyCache.evict(username);
    accountCache.evictByUsername(username);
    byEmailCache.evict(input.email);
    AccountInfo.Loader loader = infoLoader.create(true);
    AccountInfo info = loader.get(id);
    loader.fill();
    return Response.created(info);
}
#end_block

#method_before
private void addMembers(final AccountGroup.Id groupId, final Collection<? extends Account.Id> members) throws OrmException {
    List<AccountGroupMember> memberships = new ArrayList<>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
    }
    db.accountGroupMembers().insert(memberships);
    auditService.dispatchAddGroupMembers(currentUser.getAccountId(), memberships);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#method_after
private void addMembers(final AccountGroup.Id groupId, final Collection<? extends Account.Id> members) throws OrmException {
    List<AccountGroupMember> memberships = new ArrayList<>();
    for (Account.Id accountId : members) {
        final AccountGroupMember membership = new AccountGroupMember(new AccountGroupMember.Key(accountId, groupId));
        memberships.add(membership);
    }
    db.accountGroupMembers().insert(memberships);
    auditService.dispatchAddAccountsToGroup(currentUser.getAccountId(), memberships);
    for (Account.Id accountId : members) {
        accountCache.evict(accountId);
    }
}
#end_block

#method_before
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    List<AccountGroupById> includeList = new ArrayList<>();
    List<AccountGroupByIdAud> includesAudit = new ArrayList<>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupById groupInclude = new AccountGroupById(new AccountGroupById.Key(groupId, includeUUID));
        includeList.add(groupInclude);
        final AccountGroupByIdAud audit = new AccountGroupByIdAud(groupInclude, currentUser.getAccountId(), TimeUtil.nowTs());
        includesAudit.add(audit);
    }
    db.accountGroupById().insert(includeList);
    db.accountGroupByIdAud().insert(includesAudit);
    for (AccountGroup.UUID uuid : groups) {
        groupIncludeCache.evictMemberIn(uuid);
    }
}
#method_after
private void addGroups(final AccountGroup.Id groupId, final Collection<? extends AccountGroup.UUID> groups) throws OrmException {
    List<AccountGroupById> includeList = new ArrayList<>();
    for (AccountGroup.UUID includeUUID : groups) {
        final AccountGroupById groupInclude = new AccountGroupById(new AccountGroupById.Key(groupId, includeUUID));
        includeList.add(groupInclude);
    }
    db.accountGroupById().insert(includeList);
    auditService.dispatchAddGroupsToGroup(currentUser.getAccountId(), includeList);
    for (AccountGroup.UUID uuid : groups) {
        groupIncludeCache.evictMemberIn(uuid);
    }
}
#end_block

#method_before
private void writeAudits(final List<AccountGroupMember> toRemove) {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteGroupMembers(me, toRemove);
}
#method_after
private void writeAudits(final List<AccountGroupMember> toRemove) {
    final Account.Id me = ((IdentifiedUser) self.get()).getAccountId();
    auditService.dispatchDeleteAccountsFromGroup(me, toRemove);
}
#end_block

#method_before
public void setCancelVisible(boolean visible) {
    cancelButton.setVisible(visible);
}
#method_after
public void setCancelVisible(boolean visible) {
    cancelButton.setVisible(visible);
    if (!visible) {
        okButton.setFocus(true);
    }
}
#end_block

#method_before
public static void deleteBranches(Project.NameKey name, Set<String> refs, AsyncCallback<VoidResult> cb) {
    CallbackGroup group = new CallbackGroup();
    for (String ref : refs) {
        project(name).view("branches").id(ref).delete(group.add(cb));
        cb = CallbackGroup.emptyCallback();
    }
    group.done();
}
#method_after
public static void deleteBranches(Project.NameKey name, Set<String> refs, AsyncCallback<VoidResult> cb) {
    if (refs.size() == 1) {
        project(name).view("branches").id(refs.iterator().next()).delete(cb);
    } else {
        DeleteBranchesInput d = DeleteBranchesInput.create();
        for (String ref : refs) {
            d.add_branch(ref);
        }
        project(name).view("branches:delete").post(d, cb);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    parseToken();
    prev = new Hyperlink(Util.C.pagedListPrev(), true, "");
    prev.setVisible(false);
    next = new Hyperlink(Util.C.pagedListNext(), true, "");
    next.setVisible(false);
    addPanel = new FlowPanel();
    Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branchTable = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            branchTable.deleteChecked();
        }
    });
    HorizontalPanel buttons = new HorizontalPanel();
    buttons.setSpacing(10);
    buttons.add(delBranch);
    buttons.add(prev);
    buttons.add(next);
    add(branchTable);
    add(buttons);
    add(addPanel);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    parseToken();
    prev = new Hyperlink(Util.C.pagedListPrev(), true, "");
    prev.setVisible(false);
    next = new Hyperlink(Util.C.pagedListNext(), true, "");
    next.setVisible(false);
    addPanel = new FlowPanel();
    final Grid addGrid = new Grid(2, 2);
    addGrid.setStyleName(Gerrit.RESOURCES.css().addBranch());
    final int texBoxLength = 50;
    nameTxtBox = new HintTextBox();
    nameTxtBox.setVisibleLength(texBoxLength);
    nameTxtBox.setHintText(Util.C.defaultBranchName());
    nameTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(0, 0, Util.C.columnBranchName() + ":");
    addGrid.setWidget(0, 1, nameTxtBox);
    irevTxtBox = new HintTextBox();
    irevTxtBox.setVisibleLength(texBoxLength);
    irevTxtBox.setHintText(Util.C.defaultRevisionSpec());
    irevTxtBox.addKeyPressHandler(new KeyPressHandler() {

        @Override
        public void onKeyPress(KeyPressEvent event) {
            if (event.getNativeEvent().getKeyCode() == KeyCodes.KEY_ENTER) {
                doAddNewBranch();
            }
        }
    });
    addGrid.setText(1, 0, Util.C.initialRevision() + ":");
    addGrid.setWidget(1, 1, irevTxtBox);
    addBranch = new Button(Util.C.buttonAddBranch());
    addBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doAddNewBranch();
        }
    });
    addPanel.add(addGrid);
    addPanel.add(addBranch);
    branchTable = new BranchesTable();
    delBranch = new Button(Util.C.buttonDeleteBranch());
    delBranch.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            branchTable.deleteChecked();
        }
    });
    HorizontalPanel buttons = new HorizontalPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().branchTablePrevNextLinks());
    buttons.add(delBranch);
    buttons.add(prev);
    buttons.add(next);
    add(branchTable);
    add(buttons);
    add(addPanel);
}
#end_block

#method_before
private void doAddNewBranch() {
    branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo branch) {
            showAddedBranch(branch);
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            branchTable.insert(branch);
            delBranch.setVisible(branchTable.hasBranchCanDelete());
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#method_after
private void doAddNewBranch() {
    final String branchName = nameTxtBox.getText().trim();
    if ("".equals(branchName)) {
        nameTxtBox.setFocus(true);
        return;
    }
    final String rev = irevTxtBox.getText().trim();
    if ("".equals(rev)) {
        irevTxtBox.setText("HEAD");
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                irevTxtBox.selectAll();
                irevTxtBox.setFocus(true);
            }
        });
        return;
    }
    addBranch.setEnabled(false);
    ProjectApi.createBranch(getProjectKey(), branchName, rev, new GerritCallback<BranchInfo>() {

        @Override
        public void onSuccess(BranchInfo branch) {
            showAddedBranch(branch);
            addBranch.setEnabled(true);
            nameTxtBox.setText("");
            irevTxtBox.setText("");
            branchTable.insert(branch);
            delBranch.setVisible(branchTable.hasBranchCanDelete());
        }

        @Override
        public void onFailure(Throwable caught) {
            addBranch.setEnabled(true);
            selectAllAndFocus(nameTxtBox);
            new ErrorDialog(caught.getMessage()).center();
        }
    });
}
#end_block

#method_before
void showAddedBranch(BranchInfo branch) {
    SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchCreationConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    b.append(branch.ref());
    b.closeElement("p");
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchCreationDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
        // do nothing
        }
    });
    confirmationDialog.setCancelVisible(false);
    confirmationDialog.center();
}
#method_after
void showAddedBranch(BranchInfo branch) {
    SafeHtmlBuilder b = new SafeHtmlBuilder();
    b.openElement("b");
    b.append(Gerrit.C.branchCreationConfirmationMessage());
    b.closeElement("b");
    b.openElement("p");
    b.append(branch.ref());
    b.closeElement("p");
    ConfirmationDialog confirmationDialog = new ConfirmationDialog(Gerrit.C.branchCreationDialogTitle(), b.toSafeHtml(), new ConfirmationCallback() {

        @Override
        public void onOk() {
        // do nothing
        }
    });
    confirmationDialog.center();
    confirmationDialog.setCancelVisible(false);
}
#end_block

#method_before
Set<String> getCheckedRefs() {
    Set<String> refs = new HashSet<>();
    for (int row = 1; row < table.getRowCount(); row++) {
        BranchInfo k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            refs.add(k.ref());
        }
    }
    return refs;
}
#method_after
Set<String> getCheckedRefs() {
    Set<String> refs = new HashSet<>();
    for (int row = 1; row < table.getRowCount(); row++) {
        final BranchInfo k = getRowItem(row);
        if (k != null && table.getWidget(row, 1) instanceof CheckBox && ((CheckBox) table.getWidget(row, 1)).getValue()) {
            refs.add(k.ref());
        }
    }
    return refs;
}
#end_block

#method_before
void setChecked(Set<String> refs) {
    for (int row = 1; row < table.getRowCount(); row++) {
        BranchInfo k = getRowItem(row);
        if (k != null && refs.contains(k.ref()) && table.getWidget(row, 1) instanceof CheckBox) {
            ((CheckBox) table.getWidget(row, 1)).setValue(true);
        }
    }
}
#method_after
void setChecked(Set<String> refs) {
    for (int row = 1; row < table.getRowCount(); row++) {
        final BranchInfo k = getRowItem(row);
        if (k != null && refs.contains(k.ref()) && table.getWidget(row, 1) instanceof CheckBox) {
            ((CheckBox) table.getWidget(row, 1)).setValue(true);
        }
    }
}
#end_block

#method_before
void displaySubset(List<BranchInfo> branches, int fromIndex, int toIndex) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (BranchInfo k : branches.subList(fromIndex, toIndex)) {
        int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k);
    }
}
#method_after
void displaySubset(List<BranchInfo> branches, int fromIndex, int toIndex) {
    canDelete = false;
    while (1 < table.getRowCount()) table.removeRow(table.getRowCount() - 1);
    for (BranchInfo k : branches.subList(fromIndex, toIndex)) {
        final int row = table.getRowCount();
        table.insertRow(row);
        applyDataRowStyle(row);
        populate(row, k);
    }
}
#end_block

#method_before
void insert(BranchInfo info) {
    if (table.getRowCount() < pageSize) {
        Comparator<BranchInfo> c = new Comparator<BranchInfo>() {

            @Override
            public int compare(BranchInfo a, BranchInfo b) {
                return a.ref().compareTo(b.ref());
            }
        };
        int insertPos = getInsertRow(c, info);
        if (insertPos >= 0) {
            table.insertRow(insertPos);
            applyDataRowStyle(insertPos);
            populate(insertPos, info);
        }
    } else {
        next.setVisible(true);
        setupNavigationLink(next, ProjectBranchesScreen.this.start + pageSize);
        return;
    }
}
#method_after
void insert(BranchInfo info) {
    if (table.getRowCount() <= pageSize || pageSize == 0) {
        Comparator<BranchInfo> c = new Comparator<BranchInfo>() {

            @Override
            public int compare(BranchInfo a, BranchInfo b) {
                return a.ref().compareTo(b.ref());
            }
        };
        int insertPos = getInsertRow(c, info);
        if (insertPos >= 0) {
            table.insertRow(insertPos);
            applyDataRowStyle(insertPos);
            populate(insertPos, info);
        }
    } else {
        setupNavigationLink(next, ProjectBranchesScreen.this.start + pageSize);
    }
}
#end_block

#method_before
void populate(int row, BranchInfo k) {
    GitwebLink c = Gerrit.getGitwebLink();
    if (k.canDelete()) {
        CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.revision() != null) {
        if ("HEAD".equals(k.getShortName())) {
            setHeadRevision(row, 3, k.revision());
        } else {
            table.setText(row, 3, k.revision());
        }
    } else {
        table.setText(row, 3, "");
    }
    FlowPanel actionsPanel = new FlowPanel();
    if (c != null) {
        actionsPanel.add(new Anchor(c.getLinkName(), false, c.toBranch(new Branch.NameKey(getProjectKey(), k.ref()))));
    }
    if (k.web_links() != null) {
        for (WebLinkInfo weblink : Natives.asList(k.web_links())) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.target() != null && !weblink.target().isEmpty()) {
                a.setTarget(weblink.target());
            }
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            actionsPanel.add(a);
        }
    }
    if (k.actions() != null) {
        k.actions().copyKeysIntoChildren("id");
        for (ActionInfo a : Natives.asList(k.actions().values())) {
            actionsPanel.add(new ActionButton(getProjectKey(), k, a));
        }
    }
    table.setWidget(row, 4, actionsPanel);
    FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if (RefNames.REFS_CONFIG.equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    fmt.addStyleName(row, 4, dataCellStyle);
    setRowItem(row, k);
}
#method_after
void populate(int row, BranchInfo k) {
    final GitwebLink c = Gerrit.getGitwebLink();
    if (k.canDelete()) {
        CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setText(row, 2, k.getShortName());
    if (k.revision() != null) {
        if ("HEAD".equals(k.getShortName())) {
            setHeadRevision(row, 3, k.revision());
        } else {
            table.setText(row, 3, k.revision());
        }
    } else {
        table.setText(row, 3, "");
    }
    FlowPanel actionsPanel = new FlowPanel();
    if (c != null) {
        actionsPanel.add(new Anchor(c.getLinkName(), false, c.toBranch(new Branch.NameKey(getProjectKey(), k.ref()))));
    }
    if (k.web_links() != null) {
        for (WebLinkInfo webLink : Natives.asList(k.web_links())) {
            actionsPanel.add(webLink.toAnchor());
        }
    }
    if (k.actions() != null) {
        k.actions().copyKeysIntoChildren("id");
        for (ActionInfo a : Natives.asList(k.actions().values())) {
            actionsPanel.add(new ActionButton(getProjectKey(), k, a));
        }
    }
    table.setWidget(row, 4, actionsPanel);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if (RefNames.REFS_CONFIG.equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    fmt.addStyleName(row, 4, dataCellStyle);
    setRowItem(row, k);
}
#end_block

#method_before
void showList(JsArray<BranchInfo> result) {
    if (open && (result.length() != 0)) {
        Gerrit.display(PageLinks.toProjectBranches(getProjectKey()));
        return;
    }
    setToken(getTokenForScreen(qStart));
    ProjectBranchesScreen.this.start = qStart;
    if (result.length() <= pageSize) {
        branchTable.display(Natives.asList(result));
        next.setVisible(false);
    } else {
        branchTable.displaySubset(Natives.asList(result), 0, result.length() - 1);
        setupNavigationLink(next, qStart + pageSize);
    }
    if (qStart > 0) {
        setupNavigationLink(prev, qStart - pageSize);
    } else {
        prev.setVisible(false);
    }
    delBranch.setVisible(branchTable.hasBranchCanDelete());
    Set<String> checkedRefs = branchTable.getCheckedRefs();
    branchTable.setChecked(checkedRefs);
    updateForm();
    if (!isCurrentView()) {
        display();
    }
}
#method_after
void showList(JsArray<BranchInfo> result) {
    setToken(getTokenForScreen(qStart));
    ProjectBranchesScreen.this.start = qStart;
    if (result.length() <= pageSize) {
        branchTable.display(Natives.asList(result));
        next.setVisible(false);
    } else {
        branchTable.displaySubset(Natives.asList(result), 0, result.length() - 1);
        setupNavigationLink(next, qStart + pageSize);
    }
    if (qStart > 0) {
        setupNavigationLink(prev, qStart - pageSize);
    } else {
        prev.setVisible(false);
    }
    delBranch.setVisible(branchTable.hasBranchCanDelete());
    Set<String> checkedRefs = branchTable.getCheckedRefs();
    branchTable.setChecked(checkedRefs);
    updateForm();
    if (!isCurrentView()) {
        display();
    }
}
#end_block

#method_before
private static void codemirror(final String token, final PatchSet.Id baseId, final Patch.Key id, final DisplaySide side, final int line, final boolean edit) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            Gerrit.display(token, edit ? new EditScreen(id, line) : new SideBySide(baseId, id.getParentKey(), id.get(), side, line));
        }
    });
}
#method_after
private static void codemirror(final String token, final PatchSet.Id baseId, final Patch.Key id, final DisplaySide side, final int line, final boolean edit) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            Gerrit.display(token, edit ? new EditScreen(baseId, id, line) : new SideBySide(baseId, id.getParentKey(), id.get(), side, line));
        }
    });
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeCache.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeQueryBuilder.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PerformCreateGroup.Factory.class);
    factory(PerformRenameGroup.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    factory(PerformCreateProject.Factory.class);
    factory(GarbageCollection.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).annotatedWith(ProjectOwnerGroups.class).toProvider(ProjectOwnerGroupsProvider.class).in(SINGLETON);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(WebLinks.class).toProvider(WebLinksProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(MergeabilityChecker.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), ChangeListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
public GarbageCollectionResult run(List<Project.NameKey> projectNames, PrintWriter writer) {
    GarbageCollectionResult result = new GarbageCollectionResult();
    Set<Project.NameKey> projectsToGc = gcQueue.addAll(projectNames);
    for (Project.NameKey projectName : Sets.difference(Sets.newHashSet(projectNames), projectsToGc)) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_ALREADY_SCHEDULED, projectName));
    }
    for (Project.NameKey p : projectsToGc) {
        Repository repo = null;
        try {
            repo = repoManager.openRepository(p);
            logGcConfiguration(p, repo);
            print(writer, "collecting garbage for \"" + p + "\":\n");
            GarbageCollectCommand gc = Git.wrap(repo).gc();
            logGcInfo(p, "before:", gc.getStatistics());
            gc.setProgressMonitor(writer != null ? new TextProgressMonitor(writer) : NullProgressMonitor.INSTANCE);
            Properties statistics = gc.call();
            logGcInfo(p, "after: ", statistics);
            print(writer, "done.\n\n");
            notifyAll(p);
        } catch (RepositoryNotFoundException e) {
            logGcError(writer, p, e);
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, p));
        } catch (Exception e) {
            logGcError(writer, p, e);
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, p));
        } finally {
            if (repo != null) {
                repo.close();
            }
            gcQueue.gcFinished(p);
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(List<Project.NameKey> projectNames, PrintWriter writer) {
    return run(projectNames, gcConfig.isAggressive(), writer);
}
#end_block

#method_before
public GarbageCollectionResult run(List<Project.NameKey> projectNames, PrintWriter writer) {
    GarbageCollectionResult result = new GarbageCollectionResult();
    Set<Project.NameKey> projectsToGc = gcQueue.addAll(projectNames);
    for (Project.NameKey projectName : Sets.difference(Sets.newHashSet(projectNames), projectsToGc)) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_ALREADY_SCHEDULED, projectName));
    }
    for (Project.NameKey p : projectsToGc) {
        Repository repo = null;
        try {
            repo = repoManager.openRepository(p);
            logGcConfiguration(p, repo);
            print(writer, "collecting garbage for \"" + p + "\":\n");
            GarbageCollectCommand gc = Git.wrap(repo).gc();
            logGcInfo(p, "before:", gc.getStatistics());
            gc.setProgressMonitor(writer != null ? new TextProgressMonitor(writer) : NullProgressMonitor.INSTANCE);
            Properties statistics = gc.call();
            logGcInfo(p, "after: ", statistics);
            print(writer, "done.\n\n");
            notifyAll(p);
        } catch (RepositoryNotFoundException e) {
            logGcError(writer, p, e);
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, p));
        } catch (Exception e) {
            logGcError(writer, p, e);
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, p));
        } finally {
            if (repo != null) {
                repo.close();
            }
            gcQueue.gcFinished(p);
        }
    }
    return result;
}
#method_after
public GarbageCollectionResult run(List<Project.NameKey> projectNames, boolean aggressive, PrintWriter writer) {
    GarbageCollectionResult result = new GarbageCollectionResult();
    Set<Project.NameKey> projectsToGc = gcQueue.addAll(projectNames);
    for (Project.NameKey projectName : Sets.difference(Sets.newHashSet(projectNames), projectsToGc)) {
        result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_ALREADY_SCHEDULED, projectName));
    }
    for (Project.NameKey p : projectsToGc) {
        Repository repo = null;
        try {
            repo = repoManager.openRepository(p);
            logGcConfiguration(p, repo, aggressive);
            print(writer, "collecting garbage for \"" + p + "\":\n");
            GarbageCollectCommand gc = Git.wrap(repo).gc();
            gc.setAggressive(aggressive);
            logGcInfo(p, "before:", gc.getStatistics());
            gc.setProgressMonitor(writer != null ? new TextProgressMonitor(writer) : NullProgressMonitor.INSTANCE);
            Properties statistics = gc.call();
            logGcInfo(p, "after: ", statistics);
            print(writer, "done.\n\n");
            fire(p, statistics);
        } catch (RepositoryNotFoundException e) {
            logGcError(writer, p, e);
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.REPOSITORY_NOT_FOUND, p));
        } catch (Exception e) {
            logGcError(writer, p, e);
            result.addError(new GarbageCollectionResult.Error(GarbageCollectionResult.Error.Type.GC_FAILED, p));
        } finally {
            if (repo != null) {
                repo.close();
            }
            gcQueue.gcFinished(p);
        }
    }
    return result;
}
#end_block

#method_before
private static void logGcConfiguration(Project.NameKey projectName, Repository repo) {
    StringBuilder b = new StringBuilder();
    Config cfg = repo.getConfig();
    b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, null));
    for (String subsection : cfg.getSubsections(ConfigConstants.CONFIG_GC_SECTION)) {
        b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, subsection));
    }
    if (b.length() == 0) {
        b.append("no set");
    }
    logGcInfo(projectName, "gc config: " + b.toString());
    logGcInfo(projectName, "pack config: " + (new PackConfig(repo)).toString());
}
#method_after
private static void logGcConfiguration(Project.NameKey projectName, Repository repo, boolean aggressive) {
    StringBuilder b = new StringBuilder();
    Config cfg = repo.getConfig();
    b.append("gc.aggressive=").append(aggressive).append("; ");
    b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, null));
    for (String subsection : cfg.getSubsections(ConfigConstants.CONFIG_GC_SECTION)) {
        b.append(formatConfigValues(cfg, ConfigConstants.CONFIG_GC_SECTION, subsection));
    }
    if (b.length() == 0) {
        b.append("no set");
    }
    logGcInfo(projectName, "gc config: " + b.toString());
    logGcInfo(projectName, "pack config: " + (new PackConfig(repo)).toString());
}
#end_block

#method_before
@Override
public void start() {
    FileBasedConfig cfg;
    try {
        cfg = loadGerritIndexConfig(sitePaths);
    } catch (ConfigInvalidException | IOException e) {
        throw fail(e);
    }
    if (!Files.exists(sitePaths.index_dir)) {
        throw new ProvisionException(RUN_REINDEX);
    } else if (!Files.exists(sitePaths.index_dir)) {
        log.warn("Not a directory: %s", sitePaths.index_dir.toAbsolutePath());
        throw new ProvisionException(RUN_REINDEX);
    }
    TreeMap<Integer, Version> versions = scanVersions(cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version search = null;
    List<Version> write = Lists.newArrayListWithCapacity(2);
    for (Version v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(RUN_REINDEX);
    }
    markNotReady(cfg, versions.values(), write);
    LuceneChangeIndex searchIndex = indexFactory.create(search.schema, null);
    indexes.setSearchIndex(searchIndex);
    for (Version v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(indexFactory.create(v.schema, null));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        reindexer = reindexerFactory.create(latest);
        reindexer.start();
    }
}
#method_after
@Override
public void start() {
    String runReindex = "No index versions ready; run java -jar " + sitePaths.gerrit_war.toAbsolutePath() + " reindex";
    FileBasedConfig cfg;
    try {
        cfg = loadGerritIndexConfig(sitePaths);
    } catch (ConfigInvalidException | IOException e) {
        throw fail(e);
    }
    if (!Files.exists(sitePaths.index_dir)) {
        throw new ProvisionException(runReindex);
    } else if (!Files.exists(sitePaths.index_dir)) {
        log.warn("Not a directory: %s", sitePaths.index_dir.toAbsolutePath());
        throw new ProvisionException(runReindex);
    }
    TreeMap<Integer, Version> versions = scanVersions(cfg);
    // Search from the most recent ready version.
    // Write to the most recent ready version and the most recent version.
    Version search = null;
    List<Version> write = Lists.newArrayListWithCapacity(2);
    for (Version v : versions.descendingMap().values()) {
        if (v.schema == null) {
            continue;
        }
        if (write.isEmpty() && onlineUpgrade) {
            write.add(v);
        }
        if (v.ready) {
            search = v;
            if (!write.contains(v)) {
                write.add(v);
            }
            break;
        }
    }
    if (search == null) {
        throw new ProvisionException(runReindex);
    }
    markNotReady(cfg, versions.values(), write);
    LuceneChangeIndex searchIndex = indexFactory.create(search.schema, null);
    indexes.setSearchIndex(searchIndex);
    for (Version v : write) {
        if (v.schema != null) {
            if (v.version != search.version) {
                indexes.addWriteIndex(indexFactory.create(v.schema, null));
            } else {
                indexes.addWriteIndex(searchIndex);
            }
        }
    }
    int latest = write.get(0).version;
    if (onlineUpgrade && latest != search.version) {
        reindexer = reindexerFactory.create(latest);
        reindexer.start();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(MetricRegistry.class).in(Scopes.SINGLETON);
    bind(DropWizardMetricMaker.class).in(Scopes.SINGLETON);
    bind(MetricMaker.class).to(DropWizardMetricMaker.class);
    install(new ProcMetricModule());
    install(new JGitMetricModule());
}
#method_after
@Override
protected void configure() {
    bind(MetricRegistry.class).in(Scopes.SINGLETON);
    bind(DropWizardMetricMaker.class).in(Scopes.SINGLETON);
    bind(MetricMaker.class).to(DropWizardMetricMaker.class);
    install(new ProcMetricModule());
    install(new JGitMetricModule());
    bind(CacheMetrics.class);
}
#end_block

#method_before
@Override
public synchronized Counter0 newCounter(String name, Description desc) {
    checkCounterDescription(desc);
    define(name, desc);
    return newCounterImpl(name, desc.isRate());
}
#method_after
@Override
public synchronized Counter0 newCounter(String name, Description desc) {
    checkCounterDescription(name, desc);
    define(name, desc);
    return newCounterImpl(name, desc.isRate());
}
#end_block

#method_before
@Override
public synchronized <F1> Counter1<F1> newCounter(String name, Description desc, Field<F1> field1) {
    checkCounterDescription(desc);
    CounterImpl1<F1> m = new CounterImpl1<>(this, name, desc, field1);
    define(name, desc);
    bucketed.put(name, m);
    return m.counter();
}
#method_after
@Override
public synchronized <F1> Counter1<F1> newCounter(String name, Description desc, Field<F1> field1) {
    checkCounterDescription(name, desc);
    CounterImpl1<F1> m = new CounterImpl1<>(this, name, desc, field1);
    define(name, desc);
    bucketed.put(name, m);
    return m.counter();
}
#end_block

#method_before
@Override
public synchronized <F1, F2> Counter2<F1, F2> newCounter(String name, Description desc, Field<F1> field1, Field<F2> field2) {
    checkCounterDescription(desc);
    CounterImplN m = new CounterImplN(this, name, desc, field1, field2);
    define(name, desc);
    bucketed.put(name, m);
    return m.counter2();
}
#method_after
@Override
public synchronized <F1, F2> Counter2<F1, F2> newCounter(String name, Description desc, Field<F1> field1, Field<F2> field2) {
    checkCounterDescription(name, desc);
    CounterImplN m = new CounterImplN(this, name, desc, field1, field2);
    define(name, desc);
    bucketed.put(name, m);
    return m.counter2();
}
#end_block

#method_before
@Override
public synchronized <F1, F2, F3> Counter3<F1, F2, F3> newCounter(String name, Description desc, Field<F1> field1, Field<F2> field2, Field<F3> field3) {
    checkCounterDescription(desc);
    CounterImplN m = new CounterImplN(this, name, desc, field1, field2, field3);
    define(name, desc);
    bucketed.put(name, m);
    return m.counter3();
}
#method_after
@Override
public synchronized <F1, F2, F3> Counter3<F1, F2, F3> newCounter(String name, Description desc, Field<F1> field1, Field<F2> field2, Field<F3> field3) {
    checkCounterDescription(name, desc);
    CounterImplN m = new CounterImplN(this, name, desc, field1, field2, field3);
    define(name, desc);
    bucketed.put(name, m);
    return m.counter3();
}
#end_block

#method_before
private static void checkCounterDescription(Description desc) {
    checkArgument(!desc.isConstant(), "counters must not be constant");
    checkArgument(!desc.isGauge(), "counters must not be gauge");
}
#method_after
private static void checkCounterDescription(String name, Description desc) {
    checkMetricName(name);
    checkArgument(!desc.isConstant(), "counters must not be constant");
    checkArgument(!desc.isGauge(), "counters must not be gauge");
}
#end_block

#method_before
@Override
public synchronized Timer0 newTimer(String name, Description desc) {
    checkTimerDescription(desc);
    define(name, desc);
    return newTimerImpl(name);
}
#method_after
@Override
public synchronized Timer0 newTimer(String name, Description desc) {
    checkTimerDescription(name, desc);
    define(name, desc);
    return newTimerImpl(name);
}
#end_block

#method_before
@Override
public synchronized <F1> Timer1<F1> newTimer(String name, Description desc, Field<F1> field1) {
    checkTimerDescription(desc);
    TimerImpl1<F1> m = new TimerImpl1<>(this, name, desc, field1);
    define(name, desc);
    bucketed.put(name, m);
    return m.timer();
}
#method_after
@Override
public synchronized <F1> Timer1<F1> newTimer(String name, Description desc, Field<F1> field1) {
    checkTimerDescription(name, desc);
    TimerImpl1<F1> m = new TimerImpl1<>(this, name, desc, field1);
    define(name, desc);
    bucketed.put(name, m);
    return m.timer();
}
#end_block

#method_before
@Override
public synchronized <F1, F2> Timer2<F1, F2> newTimer(String name, Description desc, Field<F1> field1, Field<F2> field2) {
    checkTimerDescription(desc);
    TimerImplN m = new TimerImplN(this, name, desc, field1, field2);
    define(name, desc);
    bucketed.put(name, m);
    return m.timer2();
}
#method_after
@Override
public synchronized <F1, F2> Timer2<F1, F2> newTimer(String name, Description desc, Field<F1> field1, Field<F2> field2) {
    checkTimerDescription(name, desc);
    TimerImplN m = new TimerImplN(this, name, desc, field1, field2);
    define(name, desc);
    bucketed.put(name, m);
    return m.timer2();
}
#end_block

#method_before
@Override
public synchronized <F1, F2, F3> Timer3<F1, F2, F3> newTimer(String name, Description desc, Field<F1> field1, Field<F2> field2, Field<F3> field3) {
    checkTimerDescription(desc);
    TimerImplN m = new TimerImplN(this, name, desc, field1, field2, field3);
    define(name, desc);
    bucketed.put(name, m);
    return m.timer3();
}
#method_after
@Override
public synchronized <F1, F2, F3> Timer3<F1, F2, F3> newTimer(String name, Description desc, Field<F1> field1, Field<F2> field2, Field<F3> field3) {
    checkTimerDescription(name, desc);
    TimerImplN m = new TimerImplN(this, name, desc, field1, field2, field3);
    define(name, desc);
    bucketed.put(name, m);
    return m.timer3();
}
#end_block

#method_before
private static void checkTimerDescription(Description desc) {
    checkArgument(!desc.isConstant(), "timer must not be constant");
    checkArgument(!desc.isGauge(), "timer must not be a gauge");
    checkArgument(!desc.isRate(), "timer must not be a rate");
    checkArgument(desc.isCumulative(), "timer must be cumulative");
    checkArgument(desc.getTimeUnit() != null, "timer must have a unit");
}
#method_after
private static void checkTimerDescription(String name, Description desc) {
    checkMetricName(name);
    checkArgument(!desc.isConstant(), "timer must not be constant");
    checkArgument(!desc.isGauge(), "timer must not be a gauge");
    checkArgument(!desc.isRate(), "timer must not be a rate");
    checkArgument(desc.isCumulative(), "timer must be cumulative");
    checkArgument(desc.getTimeUnit() != null, "timer must have a unit");
}
#end_block

#method_before
@Override
public <V> CallbackMetric0<V> newCallbackMetric(String name, Class<V> valueClass, Description desc) {
    define(name, desc);
    return new CallbackMetricImpl0<>(this, registry, name, valueClass);
}
#method_after
@Override
public <V> CallbackMetric0<V> newCallbackMetric(String name, Class<V> valueClass, Description desc) {
    checkMetricName(name);
    define(name, desc);
    return new CallbackMetricImpl0<>(this, registry, name, valueClass);
}
#end_block

#method_before
@Override
public <F1, V> CallbackMetric1<F1, V> newCallbackMetric(String name, Class<V> valueClass, Description desc, Field<F1> field1) {
    CallbackMetricImpl1<F1, V> m = new CallbackMetricImpl1<>(this, registry, name, valueClass, desc, field1);
    define(name, desc);
    bucketed.put(name, m);
    return m.create();
}
#method_after
@Override
public <F1, V> CallbackMetric1<F1, V> newCallbackMetric(String name, Class<V> valueClass, Description desc, Field<F1> field1) {
    checkMetricName(name);
    CallbackMetricImpl1<F1, V> m = new CallbackMetricImpl1<>(this, registry, name, valueClass, desc, field1);
    define(name, desc);
    bucketed.put(name, m);
    return m.create();
}
#end_block

#method_before
@Override
public synchronized RegistrationHandle newTrigger(Set<CallbackMetric<?>> metrics, Runnable trigger) {
    trigger = new CallbackGroup(trigger);
    for (CallbackMetric<?> m : metrics) {
        ((CallbackMetricGlue) m).register(trigger);
    }
    trigger.run();
    final List<CallbackMetric<?>> all = new ArrayList<>(metrics);
    return new RegistrationHandle() {

        @Override
        public void remove() {
            for (CallbackMetric<?> m : all) {
                m.remove();
            }
        }
    };
}
#method_after
@Override
public synchronized RegistrationHandle newTrigger(Set<CallbackMetric<?>> metrics, Runnable trigger) {
    final ImmutableSet<CallbackMetricGlue> all = FluentIterable.from(metrics).transform(new Function<CallbackMetric<?>, CallbackMetricGlue>() {

        @Override
        public CallbackMetricGlue apply(CallbackMetric<?> input) {
            return (CallbackMetricGlue) input;
        }
    }).toSet();
    trigger = new CallbackGroup(trigger, all);
    for (CallbackMetricGlue m : all) {
        m.register(trigger);
    }
    trigger.run();
    return new RegistrationHandle() {

        @Override
        public void remove() {
            for (CallbackMetricGlue m : all) {
                m.remove();
            }
        }
    };
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            TypeLiteral<Cache<AdvertisedObjectsCacheKey, Set<ObjectId>>> cache = new TypeLiteral<Cache<AdvertisedObjectsCacheKey, Set<ObjectId>>>() {
            };
            core(cache, ID_CACHE).memoryLimit(4096).maxAge(10, TimeUnit.MINUTES);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(Resolver.class);
    bind(UploadFactory.class);
    bind(UploadFilter.class);
    bind(ReceiveFactory.class);
    bind(ReceiveFilter.class);
    install(new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, AdvertisedObjectsCacheKey.class, new TypeLiteral<Set<ObjectId>>() {
            }).maximumWeight(4096).expireAfterWrite(10, TimeUnit.MINUTES);
        }
    });
}
#end_block

#method_before
@Override
public Repository open(HttpServletRequest req, String projectName) throws RepositoryNotFoundException, ServiceNotAuthorizedException, ServiceNotEnabledException {
    while (projectName.endsWith("/")) {
        projectName = projectName.substring(0, projectName.length() - 1);
    }
    if (projectName.endsWith(".git")) {
        // Be nice and drop the trailing ".git" suffix, which we never keep
        // in our database, but clients might mistakenly provide anyway.
        // 
        projectName = projectName.substring(0, projectName.length() - 4);
        while (projectName.endsWith("/")) {
            projectName = projectName.substring(0, projectName.length() - 1);
        }
    }
    final ProjectControl pc;
    try {
        pc = projectControlFactory.controlFor(new Project.NameKey(projectName));
    } catch (NoSuchProjectException err) {
        throw new RepositoryNotFoundException(projectName);
    }
    if (!pc.isVisible()) {
        if (pc.getCurrentUser() instanceof AnonymousUser) {
            throw new ServiceNotAuthorizedException();
        } else {
            throw new ServiceNotEnabledException();
        }
    }
    req.setAttribute(ATT_CONTROL, pc);
    return manager.openRepository(pc.getProject().getNameKey());
}
#method_after
@Override
public Repository open(HttpServletRequest req, String projectName) throws RepositoryNotFoundException, ServiceNotAuthorizedException, ServiceNotEnabledException {
    while (projectName.endsWith("/")) {
        projectName = projectName.substring(0, projectName.length() - 1);
    }
    if (projectName.endsWith(".git")) {
        // Be nice and drop the trailing ".git" suffix, which we never keep
        // in our database, but clients might mistakenly provide anyway.
        // 
        projectName = projectName.substring(0, projectName.length() - 4);
        while (projectName.endsWith("/")) {
            projectName = projectName.substring(0, projectName.length() - 1);
        }
    }
    final ProjectControl pc;
    try {
        pc = projectControlFactory.controlFor(new Project.NameKey(projectName));
    } catch (NoSuchProjectException err) {
        throw new RepositoryNotFoundException(projectName);
    }
    if (!pc.isVisible()) {
        if (pc.getCurrentUser() instanceof AnonymousUser) {
            throw new ServiceNotAuthorizedException();
        } else {
            throw new ServiceNotEnabledException();
        }
    }
    req.setAttribute(ATT_CONTROL, pc);
    try {
        return manager.openRepository(pc.getProject().getNameKey());
    } catch (IOException e) {
        throw new RepositoryNotFoundException(pc.getProject().getNameKey().get(), e);
    }
}
#end_block

#method_before
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(packConfig);
    session.get().setAccessPath(AccessPath.GIT);
    return up;
}
#method_after
@Override
public UploadPack create(HttpServletRequest req, Repository repo) {
    UploadPack up = new UploadPack(repo);
    up.setPackConfig(config.getPackConfig());
    up.setTimeout(config.getTimeout());
    session.get().setAccessPath(AccessPath.GIT);
    return up;
}
#end_block

#method_before
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db).getReceiveCommits();
    rc.getReceivePack().setRefLogIdent(user.newRefLogIdent());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rc.getReceivePack();
}
#method_after
@Override
public ReceivePack create(HttpServletRequest req, Repository db) throws ServiceNotAuthorizedException {
    final ProjectControl pc = (ProjectControl) req.getAttribute(ATT_CONTROL);
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        // Anonymous users are not permitted to push.
        throw new ServiceNotAuthorizedException();
    }
    final IdentifiedUser user = (IdentifiedUser) pc.getCurrentUser();
    final ReceiveCommits rc = factory.create(pc, db).getReceiveCommits();
    ReceivePack rp = rc.getReceivePack();
    rp.setRefLogIdent(user.newRefLogIdent());
    rp.setTimeout(config.getTimeout());
    rp.setMaxObjectSizeLimit(config.getMaxObjectSizeLimit());
    req.setAttribute(ATT_RC, rc);
    session.get().setAccessPath(AccessPath.GIT);
    return rp;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.remove(cacheKey);
    } else {
        Set<ObjectId> ids = cache.get(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.remove(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    boolean isGet = "GET".equalsIgnoreCase(((HttpServletRequest) request).getMethod());
    ReceiveCommits rc = (ReceiveCommits) request.getAttribute(ATT_RC);
    ReceivePack rp = rc.getReceivePack();
    ProjectControl pc = (ProjectControl) request.getAttribute(ATT_CONTROL);
    Project.NameKey projectName = pc.getProject().getNameKey();
    if (!pc.canRunReceivePack()) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "receive-pack not permitted on this server");
        return;
    }
    final Capable s = rc.canUpload();
    if (s != Capable.OK) {
        GitSmartHttpTools.sendError((HttpServletRequest) request, (HttpServletResponse) response, HttpServletResponse.SC_FORBIDDEN, "\n" + s.getMessage());
        return;
    }
    if (!rp.isCheckReferencedObjectsAreReachable()) {
        if (isGet) {
            rc.advertiseHistory();
        }
        chain.doFilter(request, response);
        return;
    }
    if (!(pc.getCurrentUser() instanceof IdentifiedUser)) {
        chain.doFilter(request, response);
        return;
    }
    AdvertisedObjectsCacheKey cacheKey = new AdvertisedObjectsCacheKey(((IdentifiedUser) pc.getCurrentUser()).getAccountId(), projectName);
    if (isGet) {
        rc.advertiseHistory();
        cache.invalidate(cacheKey);
    } else {
        Set<ObjectId> ids = cache.getIfPresent(cacheKey);
        if (ids != null) {
            rp.getAdvertisedObjects().addAll(ids);
            cache.invalidate(cacheKey);
        }
    }
    chain.doFilter(request, response);
    if (isGet) {
        cache.put(cacheKey, Collections.unmodifiableSet(new HashSet<ObjectId>(rp.getAdvertisedObjects())));
    }
}
#end_block

#method_before
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            TypeLiteral<Cache<Project.NameKey, ChangeCacheEntryVal>> cache = new TypeLiteral<Cache<Project.NameKey, ChangeCacheEntryVal>>() {
            };
            core(cache, ID_CACHE).memoryLimit(1024).maxAge(120, TimeUnit.MINUTES);
        }
    };
}
#method_after
public static Module module() {
    return new CacheModule() {

        @Override
        protected void configure() {
            cache(ID_CACHE, Project.NameKey.class, new TypeLiteral<List<Change>>() {
            }).maximumWeight(1024).loader(Loader.class);
        }
    };
}
#end_block

#method_before
Set<Change> get(Project.NameKey name, ReviewDb reviewDb, Integer numRefs) throws OrmException {
    ChangeCacheEntryVal cacheEntry = cache.get(name);
    if (cacheEntry == null) {
        synchronized (createLock) {
            cacheEntry = cache.get(name);
            // we need a fresh set of changes.
            if (cacheEntry == null || !numRefs.equals(cacheEntry.getNumRefs())) {
                Set<Change> changes = new HashSet<Change>();
                for (Change c : reviewDb.changes().byProject(name)) {
                    changes.add(c);
                }
                cacheEntry = new ChangeCacheEntryVal(changes, numRefs);
                cache.put(name, cacheEntry);
            }
        }
    }
    return cacheEntry.getChanges();
}
#method_after
List<Change> get(Project.NameKey name) {
    try {
        return cache.get(name);
    } catch (ExecutionException e) {
        log.warn("Cannot fetch changes for " + name, e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(MaterializedGroupMembership.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(ChangeCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    bind(GroupControl.Factory.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    install(new AuditModule());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ChangeCache.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeperately) {
    final Set<Change.Id> visibleChanges = visibleChanges(refs.size());
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeperately)) {
        TagMatcher tags = tagCache.get(projectName).matcher(db, filterTagsSeperately ? filter(db.getAllRefs()).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#method_after
public Map<String, Ref> filter(Map<String, Ref> refs, boolean filterTagsSeperately) {
    if (projectCtl.allRefsAreVisibleExcept(ImmutableSet.of(GitRepositoryManager.REF_CONFIG))) {
        Map<String, Ref> r = Maps.newHashMap(refs);
        r.remove(GitRepositoryManager.REF_CONFIG);
        return r;
    }
    final Set<Change.Id> visibleChanges = visibleChanges();
    final Map<String, Ref> result = new HashMap<String, Ref>();
    final List<Ref> deferredTags = new ArrayList<Ref>();
    for (Ref ref : refs.values()) {
        if (PatchSet.isRef(ref.getName())) {
            // 
            if (visibleChanges.contains(Change.Id.fromRef(ref.getName()))) {
                result.put(ref.getName(), ref);
            }
        } else if (isTag(ref)) {
            // 
            if (ref.getObjectId() != null) {
                deferredTags.add(ref);
            }
        } else if (projectCtl.controlForRef(ref.getLeaf().getName()).isVisible()) {
            // Use the leaf to lookup the control data. If the reference is
            // symbolic we want the control around the final target. If its
            // not symbolic then getLeaf() is a no-op returning ref itself.
            // 
            result.put(ref.getName(), ref);
        }
    }
    // 
    if (!deferredTags.isEmpty() && (!result.isEmpty() || filterTagsSeperately)) {
        TagMatcher tags = tagCache.get(projectName).matcher(tagCache, db, filterTagsSeperately ? filter(refs).values() : result.values());
        for (Ref tag : deferredTags) {
            if (tags.isReachable(tag)) {
                result.put(tag.getName(), tag);
            }
        }
    }
    return result;
}
#end_block

#method_before
private Set<Change.Id> visibleChanges(int refSize) {
    if (!showChanges) {
        return Collections.emptySet();
    }
    final Project project = projectCtl.getProject();
    try {
        final Set<Change.Id> visibleChanges = new HashSet<Change.Id>();
        for (Change change : changeCache.get(project.getNameKey(), reviewDb, refSize)) {
            if (projectCtl.controlFor(change).isVisible(reviewDb)) {
                visibleChanges.add(change.getId());
            }
        }
        return visibleChanges;
    } catch (OrmException e) {
        log.error("Cannot load changes for project " + project.getName() + ", assuming no changes are visible", e);
        return Collections.emptySet();
    }
}
#method_after
private Set<Change.Id> visibleChanges() {
    if (!showChanges) {
        return Collections.emptySet();
    }
    final Project project = projectCtl.getProject();
    try {
        final Set<Change.Id> visibleChanges = new HashSet<Change.Id>();
        for (Change change : changeCache.get(project.getNameKey())) {
            if (projectCtl.controlFor(change).isVisible(reviewDb)) {
                visibleChanges.add(change.getId());
            }
        }
        return visibleChanges;
    } catch (OrmException e) {
        log.error("Cannot load changes for project " + project.getName() + ", assuming no changes are visible", e);
        return Collections.emptySet();
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED) {
        createNewChanges();
    }
    newProgress.end();
    doReplaces();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == Result.OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.scheduleUpdate(project.getNameKey(), c.getRefName());
                Branch.NameKey destBranch = new Branch.NameKey(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(destBranch, c.getOldId(), c.getNewId(), currentUser.getAccount());
                commandProgress.update(1);
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    if (!allNewChanges.isEmpty() && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (final Change c : allNewChanges) {
            if (c.getStatus() == Change.Status.DRAFT) {
                addMessage("  " + url + c.getChangeId() + " [DRAFT]");
            } else {
                addMessage("  " + url + c.getChangeId());
            }
        }
        addMessage("");
    }
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (newChange != null && newChange.getResult() == NOT_ATTEMPTED) {
        newChanges = selectNewChanges();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            switch(c.getType()) {
                case CREATE:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case // otherwise known as a fast-forward
                UPDATE:
                    tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
                case UPDATE_NONFASTFORWARD:
                    if (isHead(c)) {
                        autoCloseChanges(c);
                    }
                    break;
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only schedule direct refs updates for replication.
                // Change refs are scheduled when they are created.
                // 
                replication.fire(project.getNameKey(), c.getRefName());
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created) && canonicalWebUrl != null) {
        final String url = canonicalWebUrl;
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            StringBuilder m = new StringBuilder().append("  ").append(url).append(c.change.getChangeId());
            if (c.change.getStatus() == Change.Status.DRAFT) {
                m.append(" [DRAFT]");
            }
            addMessage(m.toString());
        }
        addMessage("");
    }
}
#end_block

#method_before
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#method_after
private void parseCommands(final Collection<ReceiveCommand> commands) {
    for (final ReceiveCommand cmd : commands) {
        if (cmd.getResult() != NOT_ATTEMPTED) {
            // 
            continue;
        }
        if (!Repository.isValidRefName(cmd.getRefName()) || cmd.getRefName().contains("//")) {
            reject(cmd, "not valid ref");
            continue;
        }
        if (MagicBranch.isMagicBranch(cmd.getRefName())) {
            parseNewChangeCommand(cmd);
            continue;
        }
        final Matcher m = NEW_PATCHSET.matcher(cmd.getRefName());
        if (m.matches()) {
            // The referenced change must exist and must still be open.
            // 
            final Change.Id changeId = Change.Id.parse(m.group(1));
            parseReplaceCommand(cmd, changeId);
            continue;
        }
        switch(cmd.getType()) {
            case CREATE:
                parseCreate(cmd);
                break;
            case UPDATE:
                parseUpdate(cmd);
                break;
            case DELETE:
                parseDelete(cmd);
                break;
            case UPDATE_NONFASTFORWARD:
                parseRewind(cmd);
                break;
            default:
                reject(cmd);
                continue;
        }
        if (cmd.getResult() != NOT_ATTEMPTED) {
            continue;
        }
        if (isConfig(cmd)) {
            if (!projectControl.isOwner()) {
                reject(cmd, "not project owner");
                continue;
            }
            switch(cmd.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    try {
                        ProjectConfig cfg = new ProjectConfig(project.getNameKey());
                        cfg.load(repo, cmd.getNewId());
                        if (!cfg.getValidationErrors().isEmpty()) {
                            addError("Invalid project configuration:");
                            for (ValidationError err : cfg.getValidationErrors()) {
                                addError("  " + err.getMessage());
                            }
                            reject(cmd, "invalid project configuration");
                            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                            continue;
                        }
                    } catch (Exception e) {
                        reject(cmd, "invalid project configuration");
                        log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
                        continue;
                    }
                    break;
                case DELETE:
                    break;
                default:
                    reject(cmd);
                    continue;
            }
        }
    }
}
#end_block

#method_before
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd, "can not create new references");
    }
}
#method_after
private void parseCreate(final ReceiveCommand cmd) {
    RevObject obj;
    try {
        obj = rp.getRevWalk().parseAny(cmd.getNewId());
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " creation", err);
        reject(cmd, "invalid object");
        return;
    }
    if (isHead(cmd) && !isCommit(cmd)) {
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canCreate(rp.getRevWalk(), obj)) {
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        errors.put(Error.CREATE, ctl.getRefName());
        reject(cmd);
    }
}
#end_block

#method_before
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd, "can not update the reference as a fast forward");
    }
}
#method_after
private void parseUpdate(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canUpdate()) {
        if (isHead(cmd) && !isCommit(cmd)) {
            return;
        }
        validateNewCommits(ctl, cmd);
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            errors.put(Error.CONFIG_UPDATE, GitRepositoryManager.REF_CONFIG);
        } else {
            errors.put(Error.UPDATE, ctl.getRefName());
        }
        reject(cmd);
    }
}
#end_block

#method_before
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        cmd.execute(rp);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "can not delete references");
        }
    }
}
#method_after
private void parseDelete(final ReceiveCommand cmd) {
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (ctl.canDelete()) {
        batch.addCommand(cmd);
    } else {
        if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
            reject(cmd, "cannot delete project configuration");
        } else {
            errors.put(Error.DELETE, ctl.getRefName());
            reject(cmd, "cannot delete references");
        }
    }
}
#end_block

#method_before
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != ReceiveCommand.Result.NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        cmd.execute(rp);
    } else {
        cmd.setResult(ReceiveCommand.Result.REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#method_after
private void parseRewind(final ReceiveCommand cmd) {
    RevCommit newObject;
    try {
        newObject = rp.getRevWalk().parseCommit(cmd.getNewId());
    } catch (IncorrectObjectTypeException notCommit) {
        newObject = null;
    } catch (IOException err) {
        log.error("Invalid object " + cmd.getNewId().name() + " for " + cmd.getRefName() + " forced update", err);
        reject(cmd, "invalid object");
        return;
    }
    RefControl ctl = projectControl.controlForRef(cmd.getRefName());
    if (newObject != null) {
        validateNewCommits(ctl, cmd);
        if (cmd.getResult() != NOT_ATTEMPTED) {
            return;
        }
    }
    if (ctl.canForceUpdate()) {
        batch.setAllowNonFastForwards(true).addCommand(cmd);
    } else {
        cmd.setResult(REJECTED_NONFASTFORWARD, " need '" + PermissionRule.FORCE_PUSH + "' privilege.");
    }
}
#end_block

#method_before
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "can not upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#method_after
private void parseNewChangeCommand(final ReceiveCommand cmd) {
    // 
    if (newChange != null) {
        reject(cmd, "duplicate request");
        return;
    }
    newChange = cmd;
    String destBranchName = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!destBranchName.startsWith(Constants.R_REFS)) {
        destBranchName = Constants.R_HEADS + destBranchName;
    }
    final String head;
    try {
        head = repo.getFullBranch();
    } catch (IOException e) {
        log.error("Cannot read HEAD symref", e);
        reject(cmd, "internal error");
        return;
    }
    // Split the destination branch by branch and topic.  The topic
    // suffix is entirely optional, so it might not even exist.
    // 
    int split = destBranchName.length();
    for (; ; ) {
        String name = destBranchName.substring(0, split);
        if (rp.getAdvertisedRefs().containsKey(name)) {
            // 
            break;
        } else if (head.equals(name)) {
            // 
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            String n = destBranchName;
            if (n.startsWith(Constants.R_HEADS))
                n = n.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
            return;
        }
    }
    if (split < destBranchName.length()) {
        destTopicName = destBranchName.substring(split + 1);
        if (destTopicName.isEmpty()) {
            destTopicName = null;
        }
    } else {
        destTopicName = null;
    }
    destBranch = new // 
    Branch.NameKey(// 
    project.getNameKey(), destBranchName.substring(0, split));
    destBranchCtl = projectControl.controlForRef(destBranch);
    if (!destBranchCtl.canUpload()) {
        errors.put(Error.CODE_REVIEW, cmd.getRefName());
        reject(cmd, "cannot upload review");
        return;
    }
    // 
    try {
        final RevWalk walk = rp.getRevWalk();
        final RevCommit tip = walk.parseCommit(newChange.getNewId());
        Ref targetRef = rp.getAdvertisedRefs().get(destBranchName);
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(newChange, "no common ancestry");
                return;
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        newChange.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        return;
    }
}
#end_block

#method_before
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(Result.REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#method_after
private void validateNewCommits(RefControl ctl, ReceiveCommand cmd) {
    if (ctl.canForgeAuthor() && ctl.canForgeCommitter() && ctl.canForgeGerritServerIdentity() && ctl.canUploadMerges() && !project.isUseSignedOffBy() && Iterables.isEmpty(rejectCommits) && !GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName()) && !(MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        return;
    }
    final RevWalk walk = rp.getRevWalk();
    walk.reset();
    walk.sort(RevSort.NONE);
    try {
        walk.markStart(walk.parseCommit(cmd.getNewId()));
        for (ObjectId id : existingObjects()) {
            try {
                walk.markUninteresting(walk.parseCommit(id));
            } catch (IOException e) {
                continue;
            }
        }
        RevCommit c;
        while ((c = walk.next()) != null) {
            if (!validCommit(ctl, cmd, c)) {
                break;
            }
        }
    } catch (IOException err) {
        cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", err);
    }
}
#end_block

#method_before
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if ((MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches())) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validCommit(final RefControl ctl, final ReceiveCommand cmd, final RevCommit c) throws MissingObjectException, IOException {
    rp.getRevWalk().parseBody(c);
    final PersonIdent committer = c.getCommitterIdent();
    final PersonIdent author = c.getAuthorIdent();
    // Require permission to upload merges.
    if (c.getParentCount() > 1 && !ctl.canUploadMerges()) {
        reject(cmd, "you are not allowed to upload merges");
        return false;
    }
    // 
    if (c.getParentCount() > 1 && author.getName().equals(gerritIdent.getName()) && author.getEmailAddress().equals(gerritIdent.getEmailAddress()) && !ctl.canForgeGerritServerIdentity()) {
        reject(cmd, "do not amend merges not made by you");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(author.getEmailAddress()) && !ctl.canForgeAuthor()) {
        sendInvalidEmailError(c, "author", author);
        reject(cmd, "invalid author");
        return false;
    }
    // 
    if (!currentUser.getEmailAddresses().contains(committer.getEmailAddress()) && !ctl.canForgeCommitter()) {
        sendInvalidEmailError(c, "committer", committer);
        reject(cmd, "invalid committer");
        return false;
    }
    if (project.isUseSignedOffBy()) {
        // If the project wants Signed-off-by / Acked-by lines, verify we
        // have them for the blamable parties involved on this change.
        // 
        boolean sboAuthor = false, sboCommitter = false, sboMe = false;
        for (final FooterLine footer : c.getFooterLines()) {
            if (footer.matches(FooterKey.SIGNED_OFF_BY)) {
                final String e = footer.getEmailAddress();
                if (e != null) {
                    sboAuthor |= author.getEmailAddress().equals(e);
                    sboCommitter |= committer.getEmailAddress().equals(e);
                    sboMe |= currentUser.getEmailAddresses().contains(e);
                }
            }
        }
        if (!sboAuthor && !sboCommitter && !sboMe && !ctl.canForgeCommitter()) {
            reject(cmd, "not Signed-off-by author/committer/uploader");
            return false;
        }
    }
    final List<String> idList = c.getFooterLines(CHANGE_ID);
    if (MagicBranch.isMagicBranch(cmd.getRefName()) || NEW_PATCHSET.matcher(cmd.getRefName()).matches()) {
        if (idList.isEmpty()) {
            if (project.isRequireChangeID()) {
                String errMsg = "missing Change-Id in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        } else if (idList.size() > 1) {
            reject(cmd, "multiple Change-Id lines in commit message");
            return false;
        } else {
            final String v = idList.get(idList.size() - 1).trim();
            if (!v.matches("^I[0-9a-f]{8,}.*$")) {
                final String errMsg = "missing or invalid Change-Id line format in commit message";
                reject(cmd, errMsg);
                addMessage(getFixedCommitMsgWithChangeId(errMsg, c));
                return false;
            }
        }
    }
    // Check for banned commits to prevent them from entering the tree again.
    if (rejectCommits.contains(c)) {
        reject(cmd, "contains banned commit " + c.getName());
        return false;
    }
    // If this is the special project configuration branch, validate the config.
    if (GitRepositoryManager.REF_CONFIG.equals(ctl.getRefName())) {
        try {
            ProjectConfig cfg = new ProjectConfig(project.getNameKey());
            cfg.load(repo, cmd.getNewId());
            if (!cfg.getValidationErrors().isEmpty()) {
                addError("Invalid project configuration:");
                for (ValidationError err : cfg.getValidationErrors()) {
                    addError("  " + err.getMessage());
                }
                reject(cmd, "invalid project configuration");
                log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName());
                return false;
            }
        } catch (Exception e) {
            reject(cmd, "invalid project configuration");
            log.error("User " + currentUser.getUserName() + " tried to push invalid project configuration " + cmd.getNewId().name() + " for " + project.getName(), e);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = doReplace(req, true);
            if (psi != null) {
                closeChange(req.cmd, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#method_after
private void autoCloseChanges(final ReceiveCommand cmd) {
    final RevWalk rw = rp.getRevWalk();
    try {
        rw.reset();
        rw.markStart(rw.parseCommit(cmd.getNewId()));
        if (!ObjectId.zeroId().equals(cmd.getOldId())) {
            rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
        }
        final Map<ObjectId, Ref> byCommit = changeRefsById();
        final Map<Change.Key, Change.Id> byKey = openChangesByKey(new Branch.NameKey(project.getNameKey(), cmd.getRefName()));
        final List<ReplaceRequest> toClose = new ArrayList<ReplaceRequest>();
        RevCommit c;
        while ((c = rw.next()) != null) {
            final Ref ref = byCommit.get(c.copy());
            if (ref != null) {
                rw.parseBody(c);
                Change.Key closedChange = closeChange(cmd, PatchSet.Id.fromRef(ref.getName()), c);
                closeProgress.update(1);
                if (closedChange != null) {
                    byKey.remove(closedChange);
                }
            }
            rw.parseBody(c);
            for (final String changeId : c.getFooterLines(CHANGE_ID)) {
                final Change.Id onto = byKey.get(new Change.Key(changeId.trim()));
                if (onto != null) {
                    toClose.add(new ReplaceRequest(onto, c, cmd, false));
                    break;
                }
            }
        }
        for (final ReplaceRequest req : toClose) {
            final PatchSet.Id psi = req.validate(true) ? req.insertPatchSet().checkedGet() : null;
            if (psi != null) {
                closeChange(req.inputCommand, psi, req.newCommit);
                closeProgress.update(1);
            }
        }
        // It handles gitlinks if required.
        rw.reset();
        final RevCommit codeReviewCommit = rw.parseCommit(cmd.getNewId());
        final SubmoduleOp subOp = subOpFactory.create(new Branch.NameKey(project.getNameKey(), cmd.getRefName()), codeReviewCommit, rw, repo, project, new ArrayList<Change>(), new HashMap<Change.Id, CodeReviewCommit>());
        subOp.update();
    } catch (IOException e) {
        log.error("Can't scan for changes to close", e);
    } catch (OrmException e) {
        log.error("Can't scan for changes to close", e);
    } catch (SubmoduleException e) {
        log.error("Can't complete git links check", e);
    }
}
#end_block

#method_before
private void closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return;
    }
    final ReplaceResult result = new ReplaceResult();
    result.change = change;
    result.patchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    sendMergedEmail(result);
}
#method_after
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result);
    hooks.doChangeMergedHook(change, currentUser.getAccount(), result.newPatchSet, db);
    sendMergedEmail(result);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(final ReviewDb db, final ReplaceResult result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#method_after
private void markChangeMergedByPush(final ReviewDb db, final ReplaceRequest result) throws OrmException {
    final Change change = result.change;
    final String mergedIntoRef = result.mergedIntoRef;
    change.setCurrentPatchSet(result.info);
    change.setStatus(Change.Status.MERGED);
    ChangeUtil.updated(change);
    approvalsUtil.syncChangeStatus(change);
    final StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Change has been successfully pushed");
    if (!mergedIntoRef.equals(change.getDest().get())) {
        msgBuf.append(" into ");
        if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
            msgBuf.append("branch ");
            msgBuf.append(Repository.shortenRefName(mergedIntoRef));
        } else {
            msgBuf.append(mergedIntoRef);
        }
    }
    msgBuf.append(".");
    final ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), currentUser.getAccountId(), result.info.getKey());
    msg.setMessage(msgBuf.toString());
    db.changeMessages().insert(Collections.singleton(msg));
    db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isOpen()) {
                change.setCurrentPatchSet(result.info);
                change.setStatus(Change.Status.MERGED);
                ChangeUtil.updated(change);
            }
            return change;
        }
    });
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceResult result) {
    if (result != null && result.mergedIntoRef != null) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    final MergedSender cm = mergedSenderFactory.create(result.change);
                    cm.setFrom(currentUser.getAccountId());
                    cm.setPatchSet(result.patchSet, result.info);
                    cm.send();
                } catch (Exception e) {
                    final PatchSet.Id psi = result.patchSet.getId();
                    log.error("Cannot send email for submitted patch set " + psi, e);
                }
            }

            @Override
            public String toString() {
                return "send-email merged";
            }
        }));
        try {
            hooks.doChangeMergedHook(result.change, currentUser.getAccount(), result.patchSet, db);
        } catch (OrmException err) {
            log.error("Cannot open change: " + result.change.getChangeId(), err);
        }
    }
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(result.change);
                cm.setFrom(currentUser.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void insertAncestors(PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#method_after
private void insertAncestors(ReviewDb db, PatchSet.Id id, RevCommit src) throws OrmException {
    final int cnt = src.getParentCount();
    List<PatchSetAncestor> toInsert = new ArrayList<PatchSetAncestor>(cnt);
    for (int p = 0; p < cnt; p++) {
        PatchSetAncestor a;
        a = new PatchSetAncestor(new PatchSetAncestor.Id(id, p + 1));
        a.setAncestorRevision(toRevId(src.getParent(p)));
        toInsert.add(a);
    }
    db.patchSetAncestors().insert(toInsert);
}
#end_block

#method_before
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(ReceiveCommand.Result.REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#method_after
private void reject(final ReceiveCommand cmd, final String why) {
    cmd.setResult(REJECTED_OTHER_REASON, why);
    commandProgress.update(1);
}
#end_block

#method_before
public static CodeReviewCommit getFirstFastForward(final CodeReviewCommit mergeTip, final RevWalk rw, final List<CodeReviewCommit> toMerge) throws MergeException {
    for (final Iterator<CodeReviewCommit> i = toMerge.iterator(); i.hasNext(); ) {
        try {
            final CodeReviewCommit n = i.next();
            if (mergeTip == null || rw.isMergedInto(mergeTip, n)) {
                i.remove();
                return n;
            }
        } catch (IOException e) {
            throw new MergeException("Cannot fast-forward test during merge", e);
        }
    }
    return mergeTip;
}
#method_after
public CodeReviewCommit getFirstFastForward(final CodeReviewCommit mergeTip, final RevWalk rw, final List<CodeReviewCommit> toMerge) throws MergeException {
    for (final Iterator<CodeReviewCommit> i = toMerge.iterator(); i.hasNext(); ) {
        try {
            final CodeReviewCommit n = i.next();
            if (mergeTip == null || rw.isMergedInto(mergeTip, n)) {
                i.remove();
                return n;
            }
        } catch (IOException e) {
            throw new MergeException("Cannot fast-forward test during merge", e);
        }
    }
    return mergeTip;
}
#end_block

#method_before
public static void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#method_after
public void reduceToMinimalMerge(final MergeSorter mergeSorter, final List<CodeReviewCommit> toSort) throws MergeException {
    final Collection<CodeReviewCommit> heads;
    try {
        heads = mergeSorter.sort(toSort);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
    toSort.clear();
    toSort.addAll(heads);
    Collections.sort(toSort, new Comparator<CodeReviewCommit>() {

        @Override
        public int compare(final CodeReviewCommit a, final CodeReviewCommit b) {
            return a.originalOrder - b.originalOrder;
        }
    });
}
#end_block

#method_before
public static PatchSetApproval getSubmitter(final ReviewDb reviewDb, final PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = reviewDb.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#method_after
public PatchSetApproval getSubmitter(final PatchSet.Id c) {
    return getSubmitter(db.get(), c);
}
#end_block

#method_before
public static PatchSetApproval getSubmitter(final ReviewDb reviewDb, final PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = reviewDb.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#method_after
public static PatchSetApproval getSubmitter(final ReviewDb reviewDb, final PatchSet.Id c) {
    if (c == null) {
        return null;
    }
    PatchSetApproval submitter = null;
    try {
        final List<PatchSetApproval> approvals = reviewDb.patchSetApprovals().byPatchSet(c).toList();
        for (PatchSetApproval a : approvals) {
            if (a.getValue() > 0 && a.isSubmit()) {
                if (submitter == null || a.getGranted().compareTo(submitter.getGranted()) > 0) {
                    submitter = a;
                }
            }
        }
    } catch (OrmException e) {
    }
    return submitter;
}
#end_block

#method_before
public static RevCommit createCherryPickFromCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent cherryPickCommitterIdent, String commitMsg, RevWalk rw, Boolean useContentMerge) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    m.setBase(originalCommit.getParent(0));
    if (m.merge(mergeTip, originalCommit)) {
        final CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(m.getResultTreeId());
        mergeCommit.setParentId(mergeTip);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(cherryPickCommitterIdent);
        mergeCommit.setMessage(commitMsg);
        final ObjectId id = commit(inserter, mergeCommit);
        return rw.parseCommit(id);
    } else {
        return null;
    }
}
#method_after
public RevCommit createCherryPickFromCommit(Repository repo, ObjectInserter inserter, RevCommit mergeTip, RevCommit originalCommit, PersonIdent cherryPickCommitterIdent, String commitMsg, RevWalk rw) throws MissingObjectException, IncorrectObjectTypeException, IOException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    m.setBase(originalCommit.getParent(0));
    if (m.merge(mergeTip, originalCommit)) {
        final CommitBuilder mergeCommit = new CommitBuilder();
        mergeCommit.setTreeId(m.getResultTreeId());
        mergeCommit.setParentId(mergeTip);
        mergeCommit.setAuthor(originalCommit.getAuthorIdent());
        mergeCommit.setCommitter(cherryPickCommitterIdent);
        mergeCommit.setMessage(commitMsg);
        final ObjectId id = commit(inserter, mergeCommit);
        return rw.parseCommit(id);
    } else {
        return null;
    }
}
#end_block

#method_before
public static String createCherryPickCommitMessage(final CodeReviewCommit n, final ApprovalTypes approvalTypes, final Provider<String> urlProvider, final ReviewDb db, final IdentifiedUser.GenericFactory identifiedUserFactory) {
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    for (final PatchSetApproval a : getApprovalsForCommit(db, n)) {
        if (a.getValue() <= 0) {
            // Negative votes aren't counted.
            continue;
        }
        if (ApprovalCategory.SUBMIT.equals(a.getCategoryId())) {
            // 
            if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                submitAudit = a;
            }
            continue;
        }
        final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
        final StringBuilder identbuf = new StringBuilder();
        if (acc.getFullName() != null && acc.getFullName().length() > 0) {
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append(acc.getFullName());
        }
        if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
            if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                continue;
            }
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append('<');
            identbuf.append(acc.getPreferredEmail());
            identbuf.append('>');
        }
        if (identbuf.length() == 0) {
            // Nothing reasonable to describe them by? Ignore them.
            continue;
        }
        final String tag;
        if (CRVW.equals(a.getCategoryId())) {
            tag = "Reviewed-by";
        } else if (VRIF.equals(a.getCategoryId())) {
            tag = "Tested-by";
        } else {
            final ApprovalType at = approvalTypes.byId(a.getCategoryId());
            if (at == null) {
                // A deprecated/deleted approval type, ignore it.
                continue;
            }
            tag = at.getCategory().getName().replace(' ', '-');
        }
        if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
            msgbuf.append(tag);
            msgbuf.append(": ");
            msgbuf.append(identbuf);
            msgbuf.append('\n');
        }
    }
    return msgbuf.toString();
}
#method_after
public String createCherryPickCommitMessage(final CodeReviewCommit n) {
    final List<FooterLine> footers = n.getFooterLines();
    final StringBuilder msgbuf = new StringBuilder();
    msgbuf.append(n.getFullMessage());
    if (msgbuf.length() == 0) {
        // WTF, an empty commit message?
        msgbuf.append("<no commit message provided>");
    }
    if (msgbuf.charAt(msgbuf.length() - 1) != '\n') {
        // Missing a trailing LF? Correct it (perhaps the editor was broken).
        msgbuf.append('\n');
    }
    if (footers.isEmpty()) {
        // Doesn't end in a "Signed-off-by: ..." style line? Add another line
        // break to start a new paragraph for the reviewed-by tag lines.
        // 
        msgbuf.append('\n');
    }
    if (!contains(footers, CHANGE_ID, n.change.getKey().get())) {
        msgbuf.append(CHANGE_ID.getName());
        msgbuf.append(": ");
        msgbuf.append(n.change.getKey().get());
        msgbuf.append('\n');
    }
    final String siteUrl = urlProvider.get();
    if (siteUrl != null) {
        final String url = siteUrl + n.patchsetId.getParentKey().get();
        if (!contains(footers, REVIEWED_ON, url)) {
            msgbuf.append(REVIEWED_ON.getName());
            msgbuf.append(": ");
            msgbuf.append(url);
            msgbuf.append('\n');
        }
    }
    PatchSetApproval submitAudit = null;
    for (final PatchSetApproval a : getApprovalsForCommit(n)) {
        if (a.getValue() <= 0) {
            // Negative votes aren't counted.
            continue;
        }
        if (a.isSubmit()) {
            // 
            if (submitAudit == null || a.getGranted().compareTo(submitAudit.getGranted()) > 0) {
                submitAudit = a;
            }
            continue;
        }
        final Account acc = identifiedUserFactory.create(a.getAccountId()).getAccount();
        final StringBuilder identbuf = new StringBuilder();
        if (acc.getFullName() != null && acc.getFullName().length() > 0) {
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append(acc.getFullName());
        }
        if (acc.getPreferredEmail() != null && acc.getPreferredEmail().length() > 0) {
            if (isSignedOffBy(footers, acc.getPreferredEmail())) {
                continue;
            }
            if (identbuf.length() > 0) {
                identbuf.append(' ');
            }
            identbuf.append('<');
            identbuf.append(acc.getPreferredEmail());
            identbuf.append('>');
        }
        if (identbuf.length() == 0) {
            // Nothing reasonable to describe them by? Ignore them.
            continue;
        }
        final String tag;
        if (isCodeReview(a.getLabelId())) {
            tag = "Reviewed-by";
        } else if (isVerified(a.getLabelId())) {
            tag = "Tested-by";
        } else {
            final LabelType lt = project.getLabelTypes().byLabel(a.getLabelId());
            if (lt == null) {
                continue;
            }
            tag = lt.getName();
        }
        if (!contains(footers, new FooterKey(tag), identbuf.toString())) {
            msgbuf.append(tag);
            msgbuf.append(": ");
            msgbuf.append(identbuf);
            msgbuf.append('\n');
        }
    }
    return msgbuf.toString();
}
#end_block

#method_before
public static List<PatchSetApproval> getApprovalsForCommit(final ReviewDb db, final CodeReviewCommit n) {
    List<PatchSetApproval> approvalList = null;
    try {
        approvalList = db.patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
    }
    return approvalList;
}
#method_after
public List<PatchSetApproval> getApprovalsForCommit(final CodeReviewCommit n) {
    try {
        List<PatchSetApproval> approvalList = db.get().patchSetApprovals().byPatchSet(n.patchsetId).toList();
        Collections.sort(approvalList, new Comparator<PatchSetApproval>() {

            @Override
            public int compare(final PatchSetApproval a, final PatchSetApproval b) {
                return a.getGranted().compareTo(b.getGranted());
            }
        });
        return approvalList;
    } catch (OrmException e) {
        log.error("Can't read approval records for " + n.patchsetId, e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
public static PersonIdent computeMergeCommitAuthor(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final List<CodeReviewCommit> codeReviewCommits) {
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : codeReviewCommits) {
        PatchSetApproval s = getSubmitter(reviewDb, c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : codeReviewCommits) {
            try {
                rw.parseBody(c);
            } catch (IOException e) {
                log.warn("Cannot parse commit " + c.name(), e);
                continue;
            }
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(codeReviewCommits.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    return authorIdent;
}
#method_after
public PersonIdent computeMergeCommitAuthor(final PersonIdent myIdent, final RevWalk rw, final List<CodeReviewCommit> codeReviewCommits) {
    PatchSetApproval submitter = null;
    for (final CodeReviewCommit c : codeReviewCommits) {
        PatchSetApproval s = getSubmitter(c.patchsetId);
        if (submitter == null || (s != null && s.getGranted().compareTo(submitter.getGranted()) > 0)) {
            submitter = s;
        }
    }
    // Try to use the submitter's identity for the merge commit author.
    // If all of the commits being merged are created by the submitter,
    // prefer the identity line they used in the commits rather than the
    // preferred identity stored in the user account. This way the Git
    // commit records are more consistent internally.
    // 
    PersonIdent authorIdent;
    if (submitter != null) {
        IdentifiedUser who = identifiedUserFactory.create(submitter.getAccountId());
        Set<String> emails = new HashSet<String>();
        for (RevCommit c : codeReviewCommits) {
            try {
                rw.parseBody(c);
            } catch (IOException e) {
                log.warn("Cannot parse commit " + c.name(), e);
                continue;
            }
            emails.add(c.getAuthorIdent().getEmailAddress());
        }
        final Timestamp dt = submitter.getGranted();
        final TimeZone tz = myIdent.getTimeZone();
        if (emails.size() == 1 && who.getEmailAddresses().contains(emails.iterator().next())) {
            authorIdent = new PersonIdent(codeReviewCommits.get(0).getAuthorIdent(), dt, tz);
        } else {
            authorIdent = who.newCommitterIdent(dt, tz);
        }
    } else {
        authorIdent = myIdent;
    }
    return authorIdent;
}
#end_block

#method_before
public static boolean canMerge(final MergeSorter mergeSorter, final Repository repo, final boolean useContentMerge, final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws MergeException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    final ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(), useContentMerge);
    try {
        return m.merge(new AnyObjectId[] { mergeTip, toMerge });
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            return false;
        }
        throw new MergeException("Cannot merge " + toMerge.name(), e);
    }
}
#method_after
public boolean canMerge(final MergeSorter mergeSorter, final Repository repo, final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws MergeException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    final ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter());
    try {
        return m.merge(new AnyObjectId[] { mergeTip, toMerge });
    } catch (NoMergeBaseException e) {
        return false;
    } catch (IOException e) {
        throw new MergeException("Cannot merge " + toMerge.name(), e);
    }
}
#end_block

#method_before
public static boolean canFastForward(final MergeSorter mergeSorter, final CodeReviewCommit mergeTip, final RevWalk rw, final CodeReviewCommit toMerge) throws MergeException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try {
        return mergeTip == null || rw.isMergedInto(mergeTip, toMerge);
    } catch (IOException e) {
        throw new MergeException("Cannot fast-forward test during merge", e);
    }
}
#method_after
public boolean canFastForward(final MergeSorter mergeSorter, final CodeReviewCommit mergeTip, final RevWalk rw, final CodeReviewCommit toMerge) throws MergeException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try {
        return mergeTip == null || rw.isMergedInto(mergeTip, toMerge);
    } catch (IOException e) {
        throw new MergeException("Cannot fast-forward test during merge", e);
    }
}
#end_block

#method_before
public static boolean canCherryPick(final MergeSorter mergeSorter, final Repository repo, final boolean useContentMerge, final CodeReviewCommit mergeTip, final RevWalk rw, final CodeReviewCommit toMerge) throws MergeException {
    if (mergeTip == null) {
        // 
        return true;
    }
    if (toMerge.getParentCount() == 0) {
        // 
        return false;
    }
    if (toMerge.getParentCount() == 1) {
        // 
        try {
            final ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(), useContentMerge);
            m.setBase(toMerge.getParent(0));
            return m.merge(mergeTip, toMerge);
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + toMerge.name(), e);
        }
    }
    // 
    return canFastForward(mergeSorter, mergeTip, rw, toMerge) || canMerge(mergeSorter, repo, useContentMerge, mergeTip, toMerge);
}
#method_after
public boolean canCherryPick(final MergeSorter mergeSorter, final Repository repo, final CodeReviewCommit mergeTip, final RevWalk rw, final CodeReviewCommit toMerge) throws MergeException {
    if (mergeTip == null) {
        // 
        return true;
    }
    if (toMerge.getParentCount() == 0) {
        // 
        return false;
    }
    if (toMerge.getParentCount() == 1) {
        // 
        try {
            final ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter());
            m.setBase(toMerge.getParent(0));
            return m.merge(mergeTip, toMerge);
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + toMerge.name(), e);
        }
    }
    // 
    return canFastForward(mergeSorter, mergeTip, rw, toMerge) || canMerge(mergeSorter, repo, mergeTip, toMerge);
}
#end_block

#method_before
public static boolean hasMissingDependencies(final MergeSorter mergeSorter, final CodeReviewCommit toMerge) throws MergeException {
    try {
        return !mergeSorter.sort(Collections.singleton(toMerge)).contains(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
}
#method_after
public boolean hasMissingDependencies(final MergeSorter mergeSorter, final CodeReviewCommit toMerge) throws MergeException {
    try {
        return !mergeSorter.sort(Collections.singleton(toMerge)).contains(toMerge);
    } catch (IOException e) {
        throw new MergeException("Branch head sorting failed", e);
    }
}
#end_block

#method_before
public static ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        private final MutableObjectId buf = new MutableObjectId();

        private final static int LAST_BYTE = Constants.OBJECT_ID_LENGTH - 1;

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            // create non-existing dummy ID
            buf.setByte(LAST_BYTE, buf.getByte(LAST_BYTE) + 1);
            return buf.copy();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#method_after
public ObjectInserter createDryRunInserter() {
    return new ObjectInserter() {

        private final MutableObjectId buf = new MutableObjectId();

        private final static int LAST_BYTE = Constants.OBJECT_ID_LENGTH - 1;

        @Override
        public ObjectId insert(int objectType, long length, InputStream in) throws IOException {
            // create non-existing dummy ID
            buf.setByte(LAST_BYTE, buf.getByte(LAST_BYTE) + 1);
            return buf.copy();
        }

        @Override
        public PackParser newPackParser(InputStream in) throws IOException {
            throw new UnsupportedOperationException();
        }

        @Override
        public void flush() throws IOException {
        // Do nothing.
        }

        @Override
        public void release() {
        // Do nothing.
        }
    };
}
#end_block

#method_before
public static CodeReviewCommit mergeOneCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final boolean useContentMerge, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter, useContentMerge);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(reviewDb, identifiedUserFactory, myIdent, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (IOException e) {
        if (e.getMessage().startsWith("Multiple merge bases for")) {
            try {
                failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.CRISS_CROSS_MERGE);
            } catch (IOException e2) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        } else {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return mergeTip;
}
#method_after
public CodeReviewCommit mergeOneCommit(final PersonIdent myIdent, final Repository repo, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws MergeException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(myIdent, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (NoMergeBaseException e) {
        try {
            failed(rw, canMergeFlag, mergeTip, n, getCommitMergeStatus(e.getReason()));
        } catch (IOException e2) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    } catch (IOException e) {
        throw new MergeException("Cannot merge " + n.name(), e);
    }
    return mergeTip;
}
#end_block

#method_before
public static CodeReviewCommit writeMergeCommit(final ReviewDb reviewDb, final IdentifiedUser.GenericFactory identifiedUserFactory, final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(reviewDb, identifiedUserFactory, myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#method_after
public CodeReviewCommit writeMergeCommit(final PersonIdent myIdent, final RevWalk rw, final ObjectInserter inserter, final RevFlag canMergeFlag, final Branch.NameKey destBranch, final CodeReviewCommit mergeTip, final ObjectId treeId, final CodeReviewCommit n) throws IOException, MissingObjectException, IncorrectObjectTypeException {
    final List<CodeReviewCommit> merged = new ArrayList<CodeReviewCommit>();
    rw.resetRetain(canMergeFlag);
    rw.markStart(n);
    rw.markUninteresting(mergeTip);
    for (final RevCommit c : rw) {
        final CodeReviewCommit crc = (CodeReviewCommit) c;
        if (crc.patchsetId != null) {
            merged.add(crc);
        }
    }
    final StringBuilder msgbuf = new StringBuilder();
    if (merged.size() == 1) {
        final CodeReviewCommit c = merged.get(0);
        rw.parseBody(c);
        msgbuf.append("Merge \"");
        msgbuf.append(c.getShortMessage());
        msgbuf.append("\"");
    } else {
        msgbuf.append("Merge changes ");
        for (final Iterator<CodeReviewCommit> i = merged.iterator(); i.hasNext(); ) {
            msgbuf.append(i.next().change.getKey().abbreviate());
            if (i.hasNext()) {
                msgbuf.append(',');
            }
        }
    }
    if (!R_HEADS_MASTER.equals(destBranch.get())) {
        msgbuf.append(" into ");
        msgbuf.append(destBranch.getShortName());
    }
    if (merged.size() > 1) {
        msgbuf.append("\n\n* changes:\n");
        for (final CodeReviewCommit c : merged) {
            rw.parseBody(c);
            msgbuf.append("  ");
            msgbuf.append(c.getShortMessage());
            msgbuf.append("\n");
        }
    }
    PersonIdent authorIdent = computeMergeCommitAuthor(myIdent, rw, merged);
    final CommitBuilder mergeCommit = new CommitBuilder();
    mergeCommit.setTreeId(treeId);
    mergeCommit.setParentIds(mergeTip, n);
    mergeCommit.setAuthor(authorIdent);
    mergeCommit.setCommitter(myIdent);
    mergeCommit.setMessage(msgbuf.toString());
    return (CodeReviewCommit) rw.parseCommit(commit(inserter, mergeCommit));
}
#end_block

#method_before
public static ThreeWayMerger newThreeWayMerger(final Repository repo, final ObjectInserter inserter, final boolean useContentMerge) {
    ThreeWayMerger m;
    if (useContentMerge) {
        // Settings for this project allow us to try and
        // automatically resolve conflicts within files if needed.
        // Use ResolveMerge and instruct to operate in core.
        m = MergeStrategy.RESOLVE.newMerger(repo, true);
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(repo);
    }
    m.setObjectInserter(new ObjectInserter.Filter() {

        @Override
        protected ObjectInserter delegate() {
            return inserter;
        }

        @Override
        public void flush() {
        }

        @Override
        public void release() {
        }
    });
    return m;
}
#method_after
public ThreeWayMerger newThreeWayMerger(final Repository repo, final ObjectInserter inserter) {
    ThreeWayMerger m;
    if (useContentMerge) {
        // new recursive merger, and instruct to operate in core.
        if (useRecursiveMerge) {
            m = MergeStrategy.RECURSIVE.newMerger(repo, true);
        } else {
            m = MergeStrategy.RESOLVE.newMerger(repo, true);
        }
    } else {
        // No auto conflict resolving allowed. If any of the
        // affected files was modified, merge will fail.
        m = MergeStrategy.SIMPLE_TWO_WAY_IN_CORE.newMerger(repo);
    }
    m.setObjectInserter(new ObjectInserter.Filter() {

        @Override
        protected ObjectInserter delegate() {
            return inserter;
        }

        @Override
        public void flush() {
        }

        @Override
        public void release() {
        }
    });
    return m;
}
#end_block

#method_before
public static ObjectId commit(final ObjectInserter inserter, final CommitBuilder mergeCommit) throws IOException, UnsupportedEncodingException {
    ObjectId id = inserter.insert(mergeCommit);
    inserter.flush();
    return id;
}
#method_after
public ObjectId commit(final ObjectInserter inserter, final CommitBuilder mergeCommit) throws IOException, UnsupportedEncodingException {
    ObjectId id = inserter.insert(mergeCommit);
    inserter.flush();
    return id;
}
#end_block

#method_before
public static PatchSetApproval markCleanMerges(final ReviewDb reviewDb, final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws MergeException {
    if (mergeTip == null) {
        // 
        return null;
    }
    try {
        PatchSetApproval submitApproval = null;
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.patchsetId != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (submitApproval == null) {
                    submitApproval = getSubmitter(reviewDb, c.patchsetId);
                }
            }
        }
        return submitApproval;
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#method_after
public PatchSetApproval markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws MergeException {
    if (mergeTip == null) {
        // 
        return null;
    }
    try {
        PatchSetApproval submitApproval = null;
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.patchsetId != null) {
                c.statusCode = CommitMergeStatus.CLEAN_MERGE;
                if (submitApproval == null) {
                    submitApproval = getSubmitter(c.patchsetId);
                }
            }
        }
        return submitApproval;
    } catch (IOException e) {
        throw new MergeException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                newMergeTip = writeCherryPickCommit(mergeTip, n);
                if (newMergeTip != null) {
                    newCommits.put(newMergeTip.patchsetId.getParentKey(), newMergeTip);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = mergeOneCommit(args.db, args.identifiedUserFactory, args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.useContentMerge, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = markCleanMerges(args.db, args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#method_after
@Override
protected CodeReviewCommit _run(final CodeReviewCommit mergeTip, final List<CodeReviewCommit> toMerge) throws MergeException {
    CodeReviewCommit newMergeTip = mergeTip;
    while (!toMerge.isEmpty()) {
        final CodeReviewCommit n = toMerge.remove(0);
        try {
            if (newMergeTip == null) {
                // The branch is unborn. Take a fast-forward resolution to
                // create the branch.
                // 
                newMergeTip = n;
                n.statusCode = CommitMergeStatus.CLEAN_MERGE;
            } else if (n.getParentCount() == 0) {
                // Refuse to merge a root commit into an existing branch,
                // we cannot obtain a delta for the cherry-pick to apply.
                // 
                n.statusCode = CommitMergeStatus.CANNOT_CHERRY_PICK_ROOT;
            } else if (n.getParentCount() == 1) {
                // If there is only one parent, a cherry-pick can be done by
                // taking the delta relative to that one parent and redoing
                // that on the current merge tip.
                // 
                newMergeTip = writeCherryPickCommit(mergeTip, n);
                if (newMergeTip != null) {
                    newCommits.put(newMergeTip.patchsetId.getParentKey(), newMergeTip);
                } else {
                    n.statusCode = CommitMergeStatus.PATH_CONFLICT;
                }
            } else {
                // 
                if (!args.mergeUtil.hasMissingDependencies(args.mergeSorter, n)) {
                    if (args.rw.isMergedInto(newMergeTip, n)) {
                        newMergeTip = n;
                    } else {
                        newMergeTip = args.mergeUtil.mergeOneCommit(args.myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, newMergeTip, n);
                    }
                    final PatchSetApproval submitApproval = args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, newMergeTip, args.alreadyAccepted);
                    setRefLogIdent(submitApproval);
                } else {
                // One or more dependencies were not met. The status was
                // already marked on the commit so we have nothing further
                // to perform at this time.
                // 
                }
            }
        } catch (IOException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        } catch (OrmException e) {
            throw new MergeException("Cannot merge " + n.name(), e);
        }
    }
    return newMergeTip;
}
#end_block

#method_before
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = getSubmitter(args.db, n.change.currPatchSetId());
    PersonIdent cherryPickCommitterIdent = null;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = createCherryPickCommitMessage(n, approvalTypes, urlProvider, args.db, args.identifiedUserFactory);
    final CodeReviewCommit newCommit = (CodeReviewCommit) createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw, args.useContentMerge);
    if (newCommit == null) {
        return null;
    }
    n.change.nextPatchSetId();
    final PatchSet ps = new PatchSet(n.change.currPatchSetId());
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    insertAncestors(args.db, ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    for (PatchSetApproval a : getApprovalsForCommit(args.db, n)) {
        args.db.patchSetApprovals().insert(Collections.singleton(new PatchSetApproval(ps.getId(), a)));
    }
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    replication.fire(n.change.getProject(), ru.getName());
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#method_after
private CodeReviewCommit writeCherryPickCommit(final CodeReviewCommit mergeTip, final CodeReviewCommit n) throws IOException, OrmException {
    args.rw.parseBody(n);
    final PatchSetApproval submitAudit = args.mergeUtil.getSubmitter(n.change.currentPatchSetId());
    PersonIdent cherryPickCommitterIdent = null;
    if (submitAudit != null) {
        cherryPickCommitterIdent = args.identifiedUserFactory.create(submitAudit.getAccountId()).newCommitterIdent(submitAudit.getGranted(), args.myIdent.getTimeZone());
    } else {
        cherryPickCommitterIdent = args.myIdent;
    }
    final String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(n);
    final CodeReviewCommit newCommit = (CodeReviewCommit) args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip, n, cherryPickCommitterIdent, cherryPickCmtMsg, args.rw);
    if (newCommit == null) {
        return null;
    }
    PatchSet.Id id = ChangeUtil.nextPatchSetId(args.repo, n.change.currentPatchSetId());
    final PatchSet ps = new PatchSet(id);
    ps.setCreatedOn(new Timestamp(System.currentTimeMillis()));
    ps.setUploader(submitAudit.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    insertAncestors(args.db, ps.getId(), newCommit);
    args.db.patchSets().insert(Collections.singleton(ps));
    n.change.setCurrentPatchSet(patchSetInfoFactory.get(newCommit, ps.getId()));
    args.db.changes().update(Collections.singletonList(n.change));
    final List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.mergeUtil.getApprovalsForCommit(n)) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
    }
    args.db.patchSetApprovals().insert(approvals);
    final RefUpdate ru = args.repo.updateRef(ps.getRefName());
    ru.setExpectedOldObjectId(ObjectId.zeroId());
    ru.setNewObjectId(newCommit);
    ru.disableRefLog();
    if (ru.update(args.rw) != RefUpdate.Result.NEW) {
        throw new IOException(String.format("Failed to create ref %s in %s: %s", ps.getRefName(), n.change.getDest().getParentKey().get(), ru.getResult()));
    }
    gitRefUpdated.fire(n.change.getProject(), ru);
    newCommit.copyFrom(n);
    newCommit.statusCode = CommitMergeStatus.CLEAN_PICK;
    newCommits.put(newCommit.patchsetId.getParentKey(), newCommit);
    setRefLogIdent(submitAudit);
    return newCommit;
}
#end_block

#method_before
@Override
public boolean dryRun(final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws MergeException {
    return canCherryPick(args.mergeSorter, args.repo, args.useContentMerge, mergeTip, args.rw, toMerge);
}
#method_after
@Override
public boolean dryRun(final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws MergeException {
    return args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge);
}
#end_block

#method_before
public static boolean isGroupReference(String configValue) {
    return configValue.startsWith(PREFIX);
}
#method_after
public static boolean isGroupReference(String configValue) {
    return configValue != null && configValue.startsWith(PREFIX);
}
#end_block

#method_before
public static String extractGroupName(String configValue) {
    if (!isGroupReference(configValue)) {
        return null;
    }
    return configValue.substring(PREFIX.length()).trim();
}
#method_after
@Nullable
public static String extractGroupName(String configValue) {
    if (!isGroupReference(configValue)) {
        return null;
    }
    return configValue.substring(PREFIX.length()).trim();
}
#end_block

#method_before
public void addDiff(int endA, int endB, List<Edit> internalEdit) {
    int lenA = endA - nextA;
    int lenB = endB - nextB;
    checkState(lenA > 0 || lenB > 0);
    ContentEntry e = entry();
    if (lenA > 0) {
        e.a = Lists.newArrayListWithCapacity(lenA);
        for (; nextA < endA; nextA++) {
            e.a.add(fileA.get(nextA));
        }
    }
    if (lenB > 0) {
        e.b = Lists.newArrayListWithCapacity(lenB);
        for (; nextB < endB; nextB++) {
            e.b.add(fileB.get(nextB));
        }
    }
    if (internalEdit != null && !internalEdit.isEmpty()) {
        e.editA = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        e.editB = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        for (Edit edit : internalEdit) {
            if (edit.getBeginA() != edit.getEndA()) {
                e.editA.add(ImmutableList.of(edit.getBeginA(), edit.getEndA() - edit.getBeginA()));
            }
            if (edit.getBeginB() != edit.getEndB()) {
                e.editB.add(ImmutableList.of(edit.getBeginB(), edit.getEndB() - edit.getBeginB()));
            }
        }
    }
}
#method_after
void addDiff(int endA, int endB, List<Edit> internalEdit) {
    int lenA = endA - nextA;
    int lenB = endB - nextB;
    checkState(lenA > 0 || lenB > 0);
    ContentEntry e = entry();
    if (lenA > 0) {
        e.a = Lists.newArrayListWithCapacity(lenA);
        for (; nextA < endA; nextA++) {
            e.a.add(fileA.get(nextA));
        }
    }
    if (lenB > 0) {
        e.b = Lists.newArrayListWithCapacity(lenB);
        for (; nextB < endB; nextB++) {
            e.b.add(fileB.get(nextB));
        }
    }
    if (internalEdit != null && !internalEdit.isEmpty()) {
        e.editA = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        e.editB = Lists.newArrayListWithCapacity(internalEdit.size() * 2);
        for (Edit edit : internalEdit) {
            if (edit.getBeginA() != edit.getEndA()) {
                e.editA.add(ImmutableList.of(edit.getBeginA(), edit.getEndA() - edit.getBeginA()));
            }
            if (edit.getBeginB() != edit.getEndB()) {
                e.editB.add(ImmutableList.of(edit.getBeginB(), edit.getEndB() - edit.getBeginB()));
            }
        }
    }
}
#end_block

#method_before
ContentEntry entry() {
    ContentEntry e = new ContentEntry();
    lines.add(e);
    return e;
}
#method_after
private ContentEntry entry() {
    ContentEntry e = new ContentEntry();
    lines.add(e);
    return e;
}
#end_block

#method_before
@Override
public String toString() {
    // is wrapped into a TrustedListenableFutureTask.
    try {
        if (runnable.getClass().isAssignableFrom(Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask"))) {
            Class<?> trustedFutureInterruptibleTask = Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask");
            for (Field field : runnable.getClass().getDeclaredFields()) {
                if (field.getType().isAssignableFrom(trustedFutureInterruptibleTask)) {
                    field.setAccessible(true);
                    Object innerObj = field.get(runnable);
                    for (Field innerField : innerObj.getClass().getDeclaredFields()) {
                        if (innerField.getType().isAssignableFrom(Callable.class)) {
                            innerField.setAccessible(true);
                            return ((Callable<?>) innerField.get(innerObj)).toString();
                        }
                    }
                }
            }
        }
    } catch (ClassNotFoundException | IllegalArgumentException | IllegalAccessException e) {
        log.debug("Cannot get a proper name for ListenableFutureTask: {}", e.getMessage());
    }
    return runnable.toString();
}
#method_after
@Override
public String toString() {
    // is wrapped into a TrustedListenableFutureTask.
    try {
        if (runnable.getClass().isAssignableFrom(Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask"))) {
            Class<?> trustedFutureInterruptibleTask = Class.forName("com.google.common.util.concurrent.TrustedListenableFutureTask$TrustedFutureInterruptibleTask");
            for (Field field : runnable.getClass().getDeclaredFields()) {
                if (field.getType().isAssignableFrom(trustedFutureInterruptibleTask)) {
                    field.setAccessible(true);
                    Object innerObj = field.get(runnable);
                    for (Field innerField : innerObj.getClass().getDeclaredFields()) {
                        if (innerField.getType().isAssignableFrom(Callable.class)) {
                            innerField.setAccessible(true);
                            return ((Callable<?>) innerField.get(innerObj)).toString();
                        }
                    }
                }
            }
        }
    } catch (ClassNotFoundException | IllegalArgumentException | IllegalAccessException e) {
        log.debug("Cannot get a proper name for TrustedListenableFutureTask: {}", e.getMessage());
    }
    return runnable.toString();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Repository git;
    try {
        git = mgr.openRepository(allProjects);
    } catch (RepositoryNotFoundException e) {
        throw new OrmException(e);
    }
    try {
        MetaDataUpdate md = new MetaDataUpdate(new NoReplication(), allProjects, git);
        ProjectConfig config = ProjectConfig.read(md);
        Map<Integer, ContributorAgreement> agreements = getAgreementToAdd(db, config);
        if (agreements.isEmpty()) {
            return;
        }
        ui.message("Moved contributor agreements to project.config");
        // Create the group for individuals.
        createGroupForIndividuals(db, config, agreements);
        // Scan AccountAgreement
        long minTime = addAccountAgreements(db, agreements);
        ProjectConfig base = ProjectConfig.read(md, null);
        for (ContributorAgreement agreement : agreements.values()) {
            base.replace(agreement);
        }
        BatchMetaDataUpdate batch = base.openUpdate(md);
        try {
            // Scan AccountGroupAgreement
            List<AccountGroupAgreement> groupAgreements = getAccountGroupAgreements(db, agreements);
            // Find the earliest change
            for (AccountGroupAgreement aga : groupAgreements) {
                minTime = Math.min(minTime, aga.getTime());
            }
            // 1 Minute
            minTime -= 60 * 1000;
            CommitBuilder commit = new CommitBuilder();
            commit.setAuthor(new PersonIdent(serverUser, new Date(minTime)));
            commit.setCommitter(new PersonIdent(serverUser, new Date(minTime)));
            commit.setMessage("Add the ContributorAgreements for upgrage to Gerrit Code Review schema 65\n");
            batch.write(commit);
            for (AccountGroupAgreement aga : groupAgreements) {
                AccountGroup group = db.accountGroups().get(aga.groupId);
                if (group == null) {
                    continue;
                }
                ContributorAgreement agreement = agreements.get(aga.claId);
                agreement.getAccepted().add(new PermissionRule(config.resolve(group)));
                base.replace(agreement);
                PersonIdent ident = null;
                if (aga.reviewedBy != null) {
                    Account ua = db.accounts().get(aga.reviewedBy);
                    if (ua != null) {
                        String name = ua.getFullName();
                        String email = ua.getPreferredEmail();
                        if (email == null || email.isEmpty()) {
                            // No preferred email is configured. Use a generic identity so we
                            // don't leak an address the user may have given us, but doesn't
                            // necessarily want to publish through Git records.
                            // 
                            String user = ua.getUserName();
                            if (user == null || user.isEmpty()) {
                                user = "account-" + ua.getId().toString();
                            }
                            String host = SystemReader.getInstance().getHostname();
                            email = user + "@" + host;
                        }
                        if (name == null || name.isEmpty()) {
                            final int at = email.indexOf('@');
                            if (0 < at) {
                                name = email.substring(0, at);
                            } else {
                                name = anonymousCowardName;
                            }
                        }
                        ident = new PersonIdent(name, email, new Date(aga.getTime()), TimeZone.getDefault());
                    }
                }
                if (ident == null) {
                    ident = new PersonIdent(serverUser, new Date(aga.getTime()));
                }
                // Build the commits such that it keeps track of the date added and
                // who added it.
                commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(ident);
                commit.setMessage(String.format("Add the accepted group \"%s\" to " + "contributor agreement\n\"%s\" for upgrage to Gerrit Code " + "Review schema 65\n", group.getName(), agreement.getName()));
                batch.write(commit);
            }
            // Merge the agreements with the other data in project.config.
            commit = new CommitBuilder();
            commit.setAuthor(serverUser);
            commit.setCommitter(serverUser);
            commit.setMessage("Upgrade to Gerrit Code Review schema 65\n");
            commit.addParentId(config.getRevision());
            batch.write(config, commit);
            // Save the the final metadata.
            if (!batch.commitAt(config.getRevision())) {
                throw new OrmException("Cannot update " + allProjects);
            }
        } finally {
            batch.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    } finally {
        git.close();
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    Repository git;
    try {
        git = mgr.openRepository(allProjects);
    } catch (RepositoryNotFoundException e) {
        throw new OrmException(e);
    }
    try {
        MetaDataUpdate md = new MetaDataUpdate(new NoReplication(), allProjects, git);
        ProjectConfig config = ProjectConfig.read(md);
        Map<Integer, ContributorAgreement> agreements = getAgreementToAdd(db, config);
        if (agreements.isEmpty()) {
            return;
        }
        ui.message("Moved contributor agreements to project.config");
        // Create the auto verify groups.
        List<AccountGroup.Id> adminGroupIds = getAdministrateServerGroups(db, config);
        for (ContributorAgreement agreement : agreements.values()) {
            if (agreement.getAutoVerify() != null) {
                getOrCreateGroupForIndividuals(db, config, adminGroupIds, agreement);
            }
        }
        // Scan AccountAgreement
        long minTime = addAccountAgreements(db, config, adminGroupIds, agreements);
        ProjectConfig base = ProjectConfig.read(md, null);
        for (ContributorAgreement agreement : agreements.values()) {
            base.replace(agreement);
        }
        base.getAccountsSection().setSameGroupVisibility(config.getAccountsSection().getSameGroupVisibility());
        BatchMetaDataUpdate batch = base.openUpdate(md);
        try {
            // Scan AccountGroupAgreement
            List<AccountGroupAgreement> groupAgreements = getAccountGroupAgreements(db, agreements);
            // Find the earliest change
            for (AccountGroupAgreement aga : groupAgreements) {
                minTime = Math.min(minTime, aga.getTime());
            }
            // 1 Minute
            minTime -= 60 * 1000;
            CommitBuilder commit = new CommitBuilder();
            commit.setAuthor(new PersonIdent(serverUser, new Date(minTime)));
            commit.setCommitter(new PersonIdent(serverUser, new Date(minTime)));
            commit.setMessage("Add the ContributorAgreements for upgrade to Gerrit Code Review schema 65\n");
            batch.write(commit);
            for (AccountGroupAgreement aga : groupAgreements) {
                AccountGroup group = db.accountGroups().get(aga.groupId);
                if (group == null) {
                    continue;
                }
                ContributorAgreement agreement = agreements.get(aga.claId);
                agreement.getAccepted().add(new PermissionRule(config.resolve(group)));
                base.replace(agreement);
                PersonIdent ident = null;
                if (aga.reviewedBy != null) {
                    Account ua = db.accounts().get(aga.reviewedBy);
                    if (ua != null) {
                        String name = ua.getFullName();
                        String email = ua.getPreferredEmail();
                        if (email == null || email.isEmpty()) {
                            // No preferred email is configured. Use a generic identity so we
                            // don't leak an address the user may have given us, but doesn't
                            // necessarily want to publish through Git records.
                            // 
                            String user = ua.getUserName();
                            if (user == null || user.isEmpty()) {
                                user = "account-" + ua.getId().toString();
                            }
                            String host = SystemReader.getInstance().getHostname();
                            email = user + "@" + host;
                        }
                        if (name == null || name.isEmpty()) {
                            final int at = email.indexOf('@');
                            if (0 < at) {
                                name = email.substring(0, at);
                            } else {
                                name = anonymousCowardName;
                            }
                        }
                        ident = new PersonIdent(name, email, new Date(aga.getTime()), TimeZone.getDefault());
                    }
                }
                if (ident == null) {
                    ident = new PersonIdent(serverUser, new Date(aga.getTime()));
                }
                // Build the commits such that it keeps track of the date added and
                // who added it.
                commit = new CommitBuilder();
                commit.setAuthor(ident);
                commit.setCommitter(new PersonIdent(serverUser, new Date(aga.getTime())));
                String msg = String.format("Accept %s contributor agreement for %s\n", agreement.getName(), group.getName());
                if (!Strings.isNullOrEmpty(aga.reviewComments)) {
                    msg += "\n" + aga.reviewComments + "\n";
                }
                commit.setMessage(msg);
                batch.write(commit);
            }
            // Merge the agreements with the other data in project.config.
            commit = new CommitBuilder();
            commit.setAuthor(serverUser);
            commit.setCommitter(serverUser);
            commit.setMessage("Upgrade to Gerrit Code Review schema 65\n");
            commit.addParentId(config.getRevision());
            batch.write(config, commit);
            // Save the the final metadata.
            if (!batch.commitAt(config.getRevision())) {
                throw new OrmException("Cannot update " + allProjects);
            }
        } finally {
            batch.close();
        }
    } catch (IOException e) {
        throw new OrmException(e);
    } catch (ConfigInvalidException e) {
        throw new OrmException(e);
    } finally {
        git.close();
    }
}
#end_block

#method_before
private List<AccountGroup.Id> getAdministrateServerGroups(ReviewDb db, ProjectConfig cfg) throws OrmException {
    List<PermissionRule> rules = cfg.getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER).getRules();
    List<AccountGroup.Id> groups = Lists.newArrayListWithExpectedSize(rules.size());
    for (PermissionRule rule : rules) {
        if (rule.getAction() == Action.ALLOW) {
            AccountGroup group = db.accountGroups().byUUID(rule.getGroup().getUUID()).toList().get(0);
            if (group != null) {
                groups.add(group.getId());
            }
        }
    }
    if (groups.isEmpty()) {
        throw new IllegalStateException("no administrator group found");
    }
    return groups;
}
#method_after
private List<AccountGroup.Id> getAdministrateServerGroups(ReviewDb db, ProjectConfig cfg) throws OrmException {
    List<PermissionRule> rules = cfg.getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER).getRules();
    List<AccountGroup.Id> groups = Lists.newArrayListWithExpectedSize(rules.size());
    for (PermissionRule rule : rules) {
        if (rule.getAction() == Action.ALLOW) {
            groups.add(db.accountGroups().byUUID(rule.getGroup().getUUID()).toList().get(0).getId());
        }
    }
    if (groups.isEmpty()) {
        throw new IllegalStateException("no administrator group found");
    }
    return groups;
}
#end_block

#method_before
private long addAccountAgreements(ReviewDb db, Map<Integer, ContributorAgreement> agreements) throws SQLException, OrmException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT account_id, cla_id, accepted_on, reviewed_by," + "       reviewed_on, review_comments " + "FROM account_agreements WHERE status = 'V'");
        try {
            long minTime = System.currentTimeMillis();
            while (rs.next()) {
                Account.Id accountId = new Account.Id(rs.getInt(1));
                Account.Id reviewerId = new Account.Id(rs.getInt(4));
                if (rs.wasNull()) {
                    reviewerId = accountId;
                }
                int claId = rs.getInt(2);
                ContributorAgreement agreement = agreements.get(claId);
                if (agreement == null) {
                    // Agreement is invalid
                    continue;
                }
                Timestamp acceptedOn = rs.getTimestamp(3);
                minTime = Math.min(minTime, acceptedOn.getTime());
                // Enter Agreement
                AccountGroup group = db.accountGroups().byUUID(agreement.getAccepted().get(0).getGroup().getUUID()).toList().get(0);
                if (group == null) {
                    throw new IllegalStateException("unexpect null AccountGroup");
                }
                final AccountGroupMember.Key key = new AccountGroupMember.Key(accountId, group.getId());
                AccountGroupMember m = db.accountGroupMembers().get(key);
                if (m == null) {
                    m = new AccountGroupMember(key);
                    db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, reviewerId, acceptedOn)));
                    db.accountGroupMembers().insert(Collections.singleton(m));
                // No need to evict the AccountCache, since it is not used in
                // this migration.
                }
            }
            return minTime;
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
}
#method_after
private long addAccountAgreements(ReviewDb db, ProjectConfig config, List<AccountGroup.Id> adminGroupIds, Map<Integer, ContributorAgreement> agreements) throws SQLException, OrmException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT account_id, cla_id, accepted_on, reviewed_by," + "       reviewed_on, review_comments " + "FROM account_agreements WHERE status = 'V'");
        try {
            long minTime = System.currentTimeMillis();
            while (rs.next()) {
                Account.Id accountId = new Account.Id(rs.getInt(1));
                Account.Id reviewerId = new Account.Id(rs.getInt(4));
                if (rs.wasNull()) {
                    reviewerId = accountId;
                }
                int claId = rs.getInt(2);
                ContributorAgreement agreement = agreements.get(claId);
                if (agreement == null) {
                    // Agreement is invalid
                    continue;
                }
                Timestamp acceptedOn = rs.getTimestamp(3);
                minTime = Math.min(minTime, acceptedOn.getTime());
                // Enter Agreement
                GroupReference individualGroup = getOrCreateGroupForIndividuals(db, config, adminGroupIds, agreement);
                AccountGroup.Id groupId = db.accountGroups().byUUID(individualGroup.getUUID()).toList().get(0).getId();
                final AccountGroupMember.Key key = new AccountGroupMember.Key(accountId, groupId);
                AccountGroupMember m = db.accountGroupMembers().get(key);
                if (m == null) {
                    m = new AccountGroupMember(key);
                    db.accountGroupMembersAudit().insert(Collections.singleton(new AccountGroupMemberAudit(m, reviewerId, acceptedOn)));
                    db.accountGroupMembers().insert(Collections.singleton(m));
                }
            }
            return minTime;
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
}
#end_block

#method_before
private List<AccountGroupAgreement> getAccountGroupAgreements(ReviewDb db, Map<Integer, ContributorAgreement> agreements) throws SQLException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT group_id, cla_id, accepted_on, reviewed_by, reviewed_on " + "FROM account_group_agreements");
        try {
            List<AccountGroupAgreement> groupAgreements = Lists.newArrayList();
            while (rs.next()) {
                AccountGroupAgreement a = new AccountGroupAgreement();
                a.groupId = new AccountGroup.Id(rs.getInt(1));
                a.claId = rs.getInt(2);
                if (!agreements.containsKey(a.claId)) {
                    // Agreement is invalid
                    continue;
                }
                a.acceptedOn = rs.getTimestamp(3);
                a.reviewedBy = new Account.Id(rs.getInt(4));
                if (rs.wasNull()) {
                    a.reviewedBy = null;
                }
                a.reviewedOn = rs.getTimestamp(5);
                if (rs.wasNull()) {
                    a.reviewedOn = null;
                }
                groupAgreements.add(a);
            }
            return groupAgreements;
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
}
#method_after
private List<AccountGroupAgreement> getAccountGroupAgreements(ReviewDb db, Map<Integer, ContributorAgreement> agreements) throws SQLException {
    Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
    try {
        ResultSet rs = stmt.executeQuery("SELECT group_id, cla_id, accepted_on, reviewed_by, reviewed_on, " + "       review_comments " + "FROM account_group_agreements");
        try {
            List<AccountGroupAgreement> groupAgreements = Lists.newArrayList();
            while (rs.next()) {
                AccountGroupAgreement a = new AccountGroupAgreement();
                a.groupId = new AccountGroup.Id(rs.getInt(1));
                a.claId = rs.getInt(2);
                if (!agreements.containsKey(a.claId)) {
                    // Agreement is invalid
                    continue;
                }
                a.acceptedOn = rs.getTimestamp(3);
                a.reviewedBy = new Account.Id(rs.getInt(4));
                if (rs.wasNull()) {
                    a.reviewedBy = null;
                }
                a.reviewedOn = rs.getTimestamp(5);
                if (rs.wasNull()) {
                    a.reviewedOn = null;
                }
                a.reviewComments = rs.getString(6);
                if (rs.wasNull()) {
                    a.reviewComments = null;
                }
                groupAgreements.add(a);
            }
            return groupAgreements;
        } finally {
            rs.close();
        }
    } finally {
        stmt.close();
    }
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    contributorAgreements = new HashMap<String, ContributorAgreement>();
    for (String name : rc.getSubsections(CONTRIBUTOR_AGREEMENT)) {
        ContributorAgreement ca = getContributorAgreement(name, true);
        ca.setDescription(rc.getString(CONTRIBUTOR_AGREEMENT, name, KEY_DESCRIPTION));
        ca.setRequireContactInformation(rc.getBoolean(CONTRIBUTOR_AGREEMENT, name, KEY_REQUIRE_CONTACT_INFORMATION, false));
        ca.setAgreementUrl(rc.getString(CONTRIBUTOR_AGREEMENT, name, KEY_AGREEMENT_URL));
        Permission perm = new Permission(KEY_ACCEPTED);
        loadPermissionRules(rc, CONTRIBUTOR_AGREEMENT, name, KEY_ACCEPTED, groupsByName, perm, false);
        ca.setAccepted(perm.getRules());
        perm = new Permission(KEY_AUTO_VERIFY);
        loadPermissionRules(rc, CONTRIBUTOR_AGREEMENT, name, KEY_AUTO_VERIFY, groupsByName, perm, false);
        if (perm.getRules().isEmpty()) {
            ca.setAutoVerify(null);
        } else if (perm.getRules().size() > 1) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + CONTRIBUTOR_AGREEMENT + "." + name + "." + KEY_AUTO_VERIFY + ": at most one group may be set"));
        } else if (perm.getRules().get(0).getAction() != Action.ALLOW) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + CONTRIBUTOR_AGREEMENT + "." + name + "." + KEY_AUTO_VERIFY + ": the group must be allowed"));
        } else {
            ca.setAutoVerify(perm.getRules().get(0).getGroup());
        }
    }
    accessSections = new HashMap<String, AccessSection>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                if (isPermission(varName)) {
                    Permission perm = as.getPermission(varName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, perm.isLabel());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (GlobalCapability.isCapability(varName)) {
            if (capability == null) {
                capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
                accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
            }
            Permission perm = capability.getPermission(varName, true);
            loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
        }
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
}
#end_block

#method_before
private void loadPermissionRules(Config rc, String section, String subsection, String varName, Map<String, GroupReference> groupsByName, Permission perm, boolean useRange) {
    for (String ruleString : rc.getStringList(section, subsection, varName)) {
        PermissionRule rule;
        try {
            rule = PermissionRule.fromString(ruleString, useRange);
        } catch (IllegalArgumentException notRule) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + section + (subsection != null ? "." + subsection : "") + "." + varName + ": " + notRule.getMessage()));
            continue;
        }
        GroupReference ref = groupsByName.get(rule.getGroup().getName());
        if (ref == null) {
            // The group wasn't mentioned in the groups table, so there is
            // no valid UUID for it. Pool the reference anyway so at least
            // all rules in the same file share the same GroupReference.
            // 
            ref = rule.getGroup();
            groupsByName.put(ref.getName(), ref);
            error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GROUP_LIST));
        }
        rule.setGroup(ref);
        perm.add(rule);
    }
}
#method_after
private List<PermissionRule> loadPermissionRules(Config rc, String section, String subsection, String varName, Map<String, GroupReference> groupsByName, boolean useRange) {
    Permission perm = new Permission(varName);
    loadPermissionRules(rc, section, subsection, varName, groupsByName, perm, useRange);
    return perm.getRules();
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    for (ContributorAgreement ca : sort(contributorAgreements.values())) {
        set(rc, CONTRIBUTOR_AGREEMENT, ca.getName(), KEY_DESCRIPTION, ca.getDescription());
        set(rc, CONTRIBUTOR_AGREEMENT, ca.getName(), KEY_REQUIRE_CONTACT_INFORMATION, ca.isRequireContactInformation());
        set(rc, CONTRIBUTOR_AGREEMENT, ca.getName(), KEY_AGREEMENT_URL, ca.getAgreementUrl());
        if (ca.getAutoVerify() != null) {
            if (ca.getAutoVerify().getUUID() != null) {
                keepGroups.add(ca.getAutoVerify().getUUID());
            }
            String autoVerify = new PermissionRule(ca.getAutoVerify()).asString(false);
            set(rc, CONTRIBUTOR_AGREEMENT, ca.getName(), KEY_AUTO_VERIFY, autoVerify);
        } else {
            rc.unset(CONTRIBUTOR_AGREEMENT, ca.getName(), KEY_AUTO_VERIFY);
        }
        List<String> rules = new ArrayList<String>();
        for (PermissionRule rule : sort(ca.getAccepted())) {
            if (rule.getGroup().getUUID() != null) {
                keepGroups.add(rule.getGroup().getUUID());
            }
            rules.add(rule.asString(false));
        }
        rc.setStringList(CONTRIBUTOR_AGREEMENT, ca.getName(), KEY_ACCEPTED, rules);
    }
    AccessSection capability = accessSections.get(AccessSection.GLOBAL_CAPABILITIES);
    if (capability != null) {
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(capability.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = GlobalCapability.hasRange(permission.getName());
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(CAPABILITY, null, permission.getName(), rules);
        }
        for (String varName : rc.getNames(CAPABILITY)) {
            if (GlobalCapability.isCapability(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(CAPABILITY, null, varName);
            }
        }
    } else {
        rc.unsetSection(CAPABILITY, null);
    }
    for (AccessSection as : sort(accessSections.values())) {
        String refName = as.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(refName)) {
            continue;
        }
        StringBuilder doNotInherit = new StringBuilder();
        for (Permission perm : sort(as.getPermissions())) {
            if (perm.getExclusiveGroup()) {
                if (0 < doNotInherit.length()) {
                    doNotInherit.append(' ');
                }
                doNotInherit.append(perm.getName());
            }
        }
        if (0 < doNotInherit.length()) {
            rc.setString(ACCESS, refName, KEY_GROUP_PERMISSIONS, doNotInherit.toString());
        } else {
            rc.unset(ACCESS, refName, KEY_GROUP_PERMISSIONS);
        }
        Set<String> have = new HashSet<String>();
        for (Permission permission : sort(as.getPermissions())) {
            have.add(permission.getName().toLowerCase());
            boolean needRange = permission.isLabel();
            List<String> rules = new ArrayList<String>();
            for (PermissionRule rule : sort(permission.getRules())) {
                GroupReference group = rule.getGroup();
                if (group.getUUID() != null) {
                    keepGroups.add(group.getUUID());
                }
                rules.add(rule.asString(needRange));
            }
            rc.setStringList(ACCESS, refName, permission.getName(), rules);
        }
        for (String varName : rc.getNames(ACCESS, refName)) {
            if (isPermission(varName) && !have.contains(varName.toLowerCase())) {
                rc.unset(ACCESS, refName, varName);
            }
        }
    }
    for (String name : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(name) && !accessSections.containsKey(name)) {
            rc.unsetSection(ACCESS, name);
        }
    }
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
public void run(String section, String key, String password) throws Exception {
    Section passwordSection = sections.get(section, null);
    if (ui.isBatch()) {
        passwordSection.setSecure(key, password);
    } else {
        ui.header("Set password for [%s]", section);
        passwordSection.passwordForKey("Enter " + key, key);
    }
}
#method_after
public void run(String section, String key, String password) throws Exception {
    Section passwordSection = sections.get(section, null);
    if (ui.isBatch()) {
        passwordSection.setSecure(key, password);
    } else {
        ui.header("Set password for [%s]", section);
        passwordSection.passwordForKey("Enter password", key);
    }
}
#end_block

#method_before
private void executeIndexChangeTask(String projectName, int id, boolean deleted) {
    if (!Context.isForwardedEvent()) {
        if (deleted) {
            IndexEvent event = new IndexEvent();
            event.targetSha = ObjectId.zeroId().name();
            IndexChangeTask task = new IndexChangeTask(projectName, id, deleted, event);
            if (queuedTasks.add(task)) {
                executor.execute(task);
            }
        } else {
            ChangeChecker checker = changeChecker.create(projectName + "~" + id);
            try {
                checker.newIndexEvent().map(event -> new IndexChangeTask(projectName, id, deleted, event)).ifPresent(task -> {
                    if (queuedTasks.add(task)) {
                        executor.execute(task);
                    }
                });
            } catch (Exception e) {
                log.warn("Unable to create task to handle change {}~{}", projectName, id, e);
            }
        }
    }
}
#method_after
private void executeIndexChangeTask(String projectName, int id, boolean deleted) {
    if (!Context.isForwardedEvent()) {
        if (deleted) {
            deleteChangeFromIndex(projectName, id);
        } else {
            reindexChange(projectName, id);
        }
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException, PermissionBackendException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit = rw.parseCommit(baseCommitId);
    CurrentUser changeOwner = identifiedUserFactory.create(notes.getChange().getOwner());
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, notes, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(notes, changeOwner), originalPatchSet), baseCommitId.name());
    rebasedPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefs(ctx.getRepoView().getRefs(originalPatchSet.getId().getParentKey().toRefPrefix()).keySet(), notes.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(notes, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setFireRevisionCreated(fireRevisionCreated).setCheckAddPatchSetPermission(checkAddPatchSetPermission).setValidate(validate);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null && !base.notes().getChange().isMerged()) {
        if (!base.notes().getChange().isMerged()) {
            // Add to end of relation chain for open base change.
            patchSetInserter.setGroups(base.patchSet().getGroups());
        } else {
            // If the base is merged, start a new relation chain.
            patchSetInserter.setGroups(GroupCollector.getDefaultGroups(rebasedCommit));
        }
    }
    patchSetInserter.updateRepo(ctx);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException, NoSuchChangeException, PermissionBackendException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit = rw.parseCommit(baseCommitId);
    CurrentUser changeOwner = identifiedUserFactory.create(notes.getChange().getOwner());
    String newCommitMessage;
    if (detailedCommitMessage) {
        rw.parseBody(baseCommit);
        newCommitMessage = newMergeUtil().createCommitMessageOnSubmit(original, baseCommit, notes, originalPatchSet.getId());
    } else {
        newCommitMessage = original.getFullMessage();
    }
    rebasedCommit = rebaseCommit(ctx, original, baseCommit, newCommitMessage);
    Base base = rebaseUtil.parseBase(new RevisionResource(changeResourceFactory.create(notes, changeOwner), originalPatchSet), baseCommitId.name());
    rebasedPatchSetId = ChangeUtil.nextPatchSetIdFromChangeRefs(ctx.getRepoView().getRefs(originalPatchSet.getId().getParentKey().toRefPrefix()).keySet(), notes.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(notes, rebasedPatchSetId, rebasedCommit).setDescription("Rebase").setFireRevisionCreated(fireRevisionCreated).setCheckAddPatchSetPermission(checkAddPatchSetPermission).setValidate(validate).setSendEmail(sendEmail);
    if (postMessage) {
        patchSetInserter.setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    }
    if (base != null && !base.notes().getChange().isMerged()) {
        if (!base.notes().getChange().isMerged()) {
            // Add to end of relation chain for open base change.
            patchSetInserter.setGroups(base.patchSet().getGroups());
        } else {
            // If the base is merged, start a new relation chain.
            patchSetInserter.setGroups(GroupCollector.getDefaultGroups(rebasedCommit));
        }
    }
    patchSetInserter.updateRepo(ctx);
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    NotifyResolver.Result notify = ctx.getNotify(change.getId());
    if (notify.shouldNotify() && sendEmail) {
        checkNotNull(changeMessage, "change message cannot be null");
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.send();
        } catch (Exception err) {
            logger.atSevere().withCause(err).log("Cannot send email for new patch set on change %s", change.getId());
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    NotifyResolver.Result notify = ctx.getNotify(change.getId());
    if (notify.shouldNotify() && sendEmail) {
        requireNonNull(changeMessage);
        try {
            ReplacePatchSetSender cm = replacePatchSetFactory.create(ctx.getProject(), change.getId());
            cm.setFrom(ctx.getAccountId());
            cm.setPatchSet(patchSet, patchSetInfo);
            cm.setChangeMessage(changeMessage.getMessage(), ctx.getWhen());
            cm.addReviewers(oldReviewers.byState(REVIEWER));
            cm.addExtraCC(oldReviewers.byState(CC));
            cm.setNotify(notify);
            cm.send();
        } catch (Exception err) {
            logger.atSevere().withCause(err).log("Cannot send email for new patch set on change %s", change.getId());
        }
    }
    if (fireRevisionCreated) {
        revisionCreated.fire(change, patchSet, ctx.getAccount(), ctx.getWhen(), notify);
    }
}
#end_block

#method_before
private Optional<String> expressAsProjectsQuery() {
    return !all && state != com.google.gerrit.extensions.client.ProjectState.HIDDEN && Strings.isNullOrEmpty(matchPrefix) && Strings.isNullOrEmpty(matchRegex) && Strings.isNullOrEmpty(matchSubstring) && type == FilterType.ALL && (showBranch == null || showBranch.isEmpty()) ? Optional.of(stateToQuery()) : Optional.empty();
}
#method_after
private Optional<String> expressAsProjectsQuery() {
    return !all && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && // TODO: see Issue 10446
    isNullOrEmpty(matchSubstring) && type == FilterType.ALL && showBranch.isEmpty() ? Optional.of(stateToQuery()) : Optional.empty();
}
#end_block

#method_before
private String stateToQuery() {
    List<String> queries = new ArrayList<>();
    if (state == null) {
        queries.add("(state:active OR state:read-only)");
    } else {
        queries.add(String.format("(state:%s)", state.toQueryValue()));
    }
    return Joiner.on(" AND ").join(queries).toString();
}
#method_after
private String stateToQuery() {
    List<String> queries = new ArrayList<>();
    if (state == null) {
        queries.add("(state:active OR state:read-only)");
    } else {
        queries.add(String.format("(state:%s)", state.name()));
    }
    return Joiner.on(" AND ").join(queries).toString();
}
#end_block

#method_before
private SortedMap<String, ProjectInfo> applyAsQuery(String query) throws BadRequestException {
    try {
        QueryProjects queryProjects = queryProjectsProvider.get();
        queryProjects.setQuery(query);
        Stream<ProjectInfo> projects = queryProjects.apply(null).stream().skip(start);
        if (limit > 0) {
            projects = projects.limit(limit);
        }
        return projects.collect(ImmutableSortedMap.toImmutableSortedMap(Ordering.natural(), (p) -> {
            return p.name;
        }, (p) -> {
            if (showDescription) {
                return p;
            }
            p.description = null;
            return p;
        }));
    } catch (OrmException | MethodNotAllowedException e) {
        throw new BadRequestException("Internal error while processing the query request", e);
    }
}
#method_after
private SortedMap<String, ProjectInfo> applyAsQuery(String query) throws BadRequestException {
    try {
        return queryProjectsProvider.get().withQuery(query).withStart(start).withLimit(limit).apply().stream().collect(ImmutableSortedMap.toImmutableSortedMap(natural(), p -> p.name, p -> showDescription ? p : nullifyDescription(p)));
    } catch (OrmException | MethodNotAllowedException e) {
        logger.atWarning().withCause(e).log("Internal error while processing the query '{}' request", query);
        throw new BadRequestException("Internal error while processing the query request");
    }
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        Iterable<Project.NameKey> projectNames = filter(perm)::iterator;
        for (Project.NameKey projectName : projectNames) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        Iterable<Project.NameKey> projectNames = filter(perm)::iterator;
        for (Project.NameKey projectName : projectNames) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private void processCommandsUnsafe(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    parsePushOptions();
    try (TraceContext traceContext = TraceContext.newTrace(tracePushOption.isPresent(), tracePushOption.orElse(null), (tagName, traceId) -> addMessage(tagName + ": " + traceId))) {
        traceContext.addTag(RequestId.Type.RECEIVE_ID, new RequestId(project.getNameKey().get()));
        // Log the push options here, rather than in parsePushOptions(), so that they are included
        // into the trace if tracing is enabled.
        logger.atFine().log("push options: %s", receivePack.getPushOptions());
        if (!projectState.getProject().getState().permitsWrite()) {
            for (ReceiveCommand cmd : commands) {
                reject(cmd, "prohibited by Gerrit: project state does not permit write");
            }
            return;
        }
        logger.atFine().log("Parsing %d commands", commands.size());
        List<ReceiveCommand> magicCommands = new ArrayList<>();
        List<ReceiveCommand> directPatchSetPushCommands = new ArrayList<>();
        List<ReceiveCommand> regularCommands = new ArrayList<>();
        for (ReceiveCommand cmd : commands) {
            if (MagicBranch.isMagicBranch(cmd.getRefName())) {
                magicCommands.add(cmd);
            } else if (isDirectChangesPush(cmd.getRefName())) {
                directPatchSetPushCommands.add(cmd);
            } else {
                regularCommands.add(cmd);
            }
        }
        int commandTypes = (magicCommands.isEmpty() ? 0 : 1) + (directPatchSetPushCommands.isEmpty() ? 0 : 1) + (regularCommands.isEmpty() ? 0 : 1);
        if (commandTypes > 1) {
            rejectRemaining(commands, "cannot combine normal pushes and magic pushes");
            return;
        }
        try {
            if (!regularCommands.isEmpty()) {
                handleRegularCommands(regularCommands, progress);
                return;
            }
            for (ReceiveCommand cmd : directPatchSetPushCommands) {
                parseDirectChangesPush(cmd);
            }
            boolean first = true;
            for (ReceiveCommand cmd : magicCommands) {
                if (first) {
                    parseMagicBranch(cmd);
                    first = false;
                } else {
                    reject(cmd, "duplicate request");
                }
            }
        } catch (PermissionBackendException | NoSuchProjectException | IOException err) {
            logger.atSevere().withCause(err).log("Failed to process refs in %s", project.getName());
            return;
        }
        Task newProgress = progress.beginSubTask("new", UNKNOWN);
        Task replaceProgress = progress.beginSubTask("updated", UNKNOWN);
        List<CreateRequest> newChanges = Collections.emptyList();
        if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
            newChanges = selectNewAndReplacedChangesFromMagicBranch(newProgress);
        }
        // Commit validation has already happened, so any changes without Change-Id are for the
        // deprecated feature.
        warnAboutMissingChangeId(newChanges);
        preparePatchSetsForReplace(newChanges);
        insertChangesAndPatchSets(newChanges, replaceProgress);
        newProgress.end();
        replaceProgress.end();
        queueSuccessMessages(newChanges);
        refsPublishDeprecationWarning();
    }
}
#method_after
private void processCommandsUnsafe(Collection<ReceiveCommand> commands, MultiProgressMonitor progress) {
    parsePushOptions();
    try (TraceContext traceContext = TraceContext.newTrace(tracePushOption.isPresent(), tracePushOption.orElse(null), (tagName, traceId) -> addMessage(tagName + ": " + traceId))) {
        traceContext.addTag(RequestId.Type.RECEIVE_ID, new RequestId(project.getNameKey().get()));
        logger.atFinest().log("Calling user: %s", user.getLoggableName());
        // Log the push options here, rather than in parsePushOptions(), so that they are included
        // into the trace if tracing is enabled.
        logger.atFine().log("push options: %s", receivePack.getPushOptions());
        if (!projectState.getProject().getState().permitsWrite()) {
            for (ReceiveCommand cmd : commands) {
                reject(cmd, "prohibited by Gerrit: project state does not permit write");
            }
            return;
        }
        logger.atFine().log("Parsing %d commands", commands.size());
        List<ReceiveCommand> magicCommands = new ArrayList<>();
        List<ReceiveCommand> directPatchSetPushCommands = new ArrayList<>();
        List<ReceiveCommand> regularCommands = new ArrayList<>();
        for (ReceiveCommand cmd : commands) {
            if (MagicBranch.isMagicBranch(cmd.getRefName())) {
                magicCommands.add(cmd);
            } else if (isDirectChangesPush(cmd.getRefName())) {
                directPatchSetPushCommands.add(cmd);
            } else {
                regularCommands.add(cmd);
            }
        }
        int commandTypes = (magicCommands.isEmpty() ? 0 : 1) + (directPatchSetPushCommands.isEmpty() ? 0 : 1) + (regularCommands.isEmpty() ? 0 : 1);
        if (commandTypes > 1) {
            rejectRemaining(commands, "cannot combine normal pushes and magic pushes");
            return;
        }
        try {
            if (!regularCommands.isEmpty()) {
                handleRegularCommands(regularCommands, progress);
                return;
            }
            for (ReceiveCommand cmd : directPatchSetPushCommands) {
                parseDirectChangesPush(cmd);
            }
            boolean first = true;
            for (ReceiveCommand cmd : magicCommands) {
                if (first) {
                    parseMagicBranch(cmd);
                    first = false;
                } else {
                    reject(cmd, "duplicate request");
                }
            }
        } catch (PermissionBackendException | NoSuchProjectException | IOException err) {
            logger.atSevere().withCause(err).log("Failed to process refs in %s", project.getName());
            return;
        }
        Task newProgress = progress.beginSubTask("new", UNKNOWN);
        Task replaceProgress = progress.beginSubTask("updated", UNKNOWN);
        List<CreateRequest> newChanges = Collections.emptyList();
        if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
            newChanges = selectNewAndReplacedChangesFromMagicBranch(newProgress);
        }
        // Commit validation has already happened, so any changes without Change-Id are for the
        // deprecated feature.
        warnAboutMissingChangeId(newChanges);
        preparePatchSetsForReplace(newChanges);
        insertChangesAndPatchSets(newChanges, replaceProgress);
        newProgress.end();
        replaceProgress.end();
        queueSuccessMessages(newChanges);
        logger.atFine().log("Command results: %s", lazy(() -> commands.stream().map(ReceiveCommits::commandToString).collect(joining(","))));
    }
}
#end_block

#method_before
private void handleRegularCommands(List<ReceiveCommand> cmds, MultiProgressMonitor progress) throws PermissionBackendException, IOException, NoSuchProjectException {
    for (ReceiveCommand cmd : cmds) {
        parseRegularCommand(cmd);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRefLogMessage("push");
        int added = 0;
        for (ReceiveCommand cmd : cmds) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
                added++;
            }
        }
        logger.atFine().log("Added %d additional ref updates", added);
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        rejectRemaining(cmds, "internal server error");
        logger.atFine().withCause(e).log("update failed:");
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : cmds) {
        // they involve kicking off an additional BatchUpdate.
        if (c.getResult() != OK) {
            continue;
        }
        if (isHead(c) || isConfig(c)) {
            switch(c.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    Task closeProgress = progress.beginSubTask("closed", UNKNOWN);
                    autoCloseChanges(c, closeProgress);
                    closeProgress.end();
                    branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                    break;
                case DELETE:
                    break;
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(db, TimeUtil.nowTs(), user);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logger.atSevere().withCause(e).log("Can't update the superprojects");
        }
    }
}
#method_after
private void handleRegularCommands(List<ReceiveCommand> cmds, MultiProgressMonitor progress) throws PermissionBackendException, IOException, NoSuchProjectException {
    resultChangeIds.setMagicPush(false);
    for (ReceiveCommand cmd : cmds) {
        parseRegularCommand(cmd);
    }
    try (BatchUpdate bu = batchUpdateFactory.create(project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins);
        bu.setRefLogMessage("push");
        int added = 0;
        for (ReceiveCommand cmd : cmds) {
            if (cmd.getResult() == NOT_ATTEMPTED) {
                bu.addRepoOnlyOp(new UpdateOneRefOp(cmd));
                added++;
            }
        }
        logger.atFine().log("Added %d additional ref updates", added);
        bu.execute();
    } catch (UpdateException | RestApiException e) {
        rejectRemaining(cmds, "internal server error");
        logger.atFine().withCause(e).log("update failed:");
    }
    Set<Branch.NameKey> branches = new HashSet<>();
    for (ReceiveCommand c : cmds) {
        // they involve kicking off an additional BatchUpdate.
        if (c.getResult() != OK) {
            continue;
        }
        if (isHead(c) || isConfig(c)) {
            switch(c.getType()) {
                case CREATE:
                case UPDATE:
                case UPDATE_NONFASTFORWARD:
                    Task closeProgress = progress.beginSubTask("closed", UNKNOWN);
                    autoCloseChanges(c, closeProgress);
                    closeProgress.end();
                    branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                    break;
                case DELETE:
                    break;
            }
        }
    }
    // Update superproject gitlinks if required.
    if (!branches.isEmpty()) {
        try (MergeOpRepoManager orm = ormProvider.get()) {
            orm.setContext(TimeUtil.nowTs(), user);
            SubmoduleOp op = subOpFactory.create(branches, orm);
            op.updateSuperProjects();
        } catch (SubmoduleException e) {
            logger.atSevere().withCause(e).log("Can't update the superprojects");
        }
    }
}
#end_block

#method_before
private void queueSuccessMessages(List<CreateRequest> newChanges) {
    if (sequentialSuccessMessages) {
        queueSuccessMessagesSequential(newChanges);
    } else {
        queueSuccessMessagesGrouped(newChanges);
    }
}
#method_after
private void queueSuccessMessages(List<CreateRequest> newChanges) {
    // adjacency list for commit => parent
    Map<String, String> adjList = new HashMap<>();
    for (CreateRequest cr : newChanges) {
        String parent = cr.commit.getParentCount() == 0 ? null : cr.commit.getParent(0).name();
        adjList.put(cr.commit.name(), parent);
    }
    for (ReplaceRequest rr : replaceByChange.values()) {
        String parent = null;
        if (rr.revCommit != null) {
            parent = rr.revCommit.getParentCount() == 0 ? null : rr.revCommit.getParent(0).name();
        }
        adjList.put(rr.newCommitId.name(), parent);
    }
    // get commits that are not parents
    Set<String> leafs = new TreeSet<>(adjList.keySet());
    leafs.removeAll(adjList.values());
    // go backwards from the last commit to its parent(s)
    Set<String> ordered = new LinkedHashSet<>();
    for (String leaf : leafs) {
        if (ordered.contains(leaf)) {
            continue;
        }
        while (leaf != null) {
            if (!ordered.contains(leaf)) {
                ordered.add(leaf);
            }
            leaf = adjList.get(leaf);
        }
    }
    // reverse the order to start with earliest commit
    List<String> orderedCommits = new ArrayList<>(ordered);
    Collections.reverse(orderedCommits);
    Map<String, CreateRequest> created = newChanges.stream().filter(r -> r.change != null).collect(Collectors.toMap(r -> r.commit.name(), r -> r));
    Map<String, ReplaceRequest> updated = replaceByChange.values().stream().filter(r -> r.inputCommand.getResult() == OK).collect(Collectors.toMap(r -> r.newCommitId.name(), r -> r));
    if (created.isEmpty() && updated.isEmpty()) {
        return;
    }
    addMessage("");
    addMessage("SUCCESS");
    addMessage("");
    boolean edit = false;
    Boolean isPrivate = null;
    Boolean wip = null;
    if (!updated.isEmpty()) {
        edit = magicBranch != null && (magicBranch.edit || magicBranch.draft);
        if (magicBranch != null) {
            if (magicBranch.isPrivate) {
                isPrivate = true;
            } else if (magicBranch.removePrivate) {
                isPrivate = false;
            }
            if (magicBranch.workInProgress) {
                wip = true;
            } else if (magicBranch.ready) {
                wip = false;
            }
        }
    }
    for (String commit : orderedCommits) {
        if (created.get(commit) != null) {
            addCreatedMessage(created.get(commit));
        } else if (updated.get(commit) != null) {
            addReplacedMessage(updated.get(commit), edit, isPrivate, wip);
        }
    }
    addMessage("");
}
#end_block

#method_before
private void addCreatedMessage(CreateRequest c, String suffix) {
    addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()) + suffix);
}
#method_after
private void addCreatedMessage(CreateRequest c) {
    addMessage(changeFormatter.newChange(ChangeReportFormatter.Input.builder().setChange(c.change).build()));
}
#end_block

#method_before
private void addReplacedMessage(ReplaceRequest u, boolean edit, Boolean isPrivate, Boolean wip) {
    String subject;
    if (edit) {
        try {
            subject = receivePack.getRevWalk().parseCommit(u.newCommitId).getShortMessage();
        } catch (IOException e) {
            // Log and fall back to original change subject
            logger.atWarning().withCause(e).log("failed to get subject for edit patch set");
            subject = u.notes.getChange().getSubject();
        }
    } else {
        subject = u.info.getSubject();
    }
    if (isPrivate == null) {
        isPrivate = u.notes.getChange().isPrivate();
    }
    if (wip == null) {
        wip = u.notes.getChange().isWorkInProgress();
    }
    ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
    addMessage(changeFormatter.changeUpdated(input));
}
#method_after
private void addReplacedMessage(ReplaceRequest u, boolean edit, Boolean isPrivate, Boolean wip) {
    String subject;
    if (edit) {
        subject = u.revCommit == null ? u.notes.getChange().getSubject() : u.revCommit.getShortMessage();
    } else {
        subject = u.info.getSubject();
    }
    if (isPrivate == null) {
        isPrivate = u.notes.getChange().isPrivate();
    }
    if (wip == null) {
        wip = u.notes.getChange().isWorkInProgress();
    }
    ChangeReportFormatter.Input input = ChangeReportFormatter.Input.builder().setChange(u.notes.getChange()).setSubject(subject).setIsEdit(edit).setIsPrivate(isPrivate).setIsWorkInProgress(wip).build();
    addMessage(changeFormatter.changeUpdated(input));
}
#end_block

#method_before
private void insertChangesAndPatchSets(List<CreateRequest> newChanges, Task replaceProgress) {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logger.atWarning().log("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db, project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins).updateChangesInParallel();
        bu.setRefLogMessage("push");
        logger.atFine().log("Adding %d replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logger.atFine().log("Adding %d create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logger.atFine().log("Adding %d group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logger.atFine().log("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        replaceByChange.values().stream().forEach(req -> resultChangeIds.add(Key.REPLACED, req.ontoChange));
        newChanges.stream().forEach(req -> resultChangeIds.add(Key.CREATED, req.changeId));
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logger.atFine().log("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addError(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (BadRequestException | UnprocessableEntityException e) {
        logger.atFine().withCause(e).log("Rejecting due to client error");
        reject(magicBranchCmd, e.getMessage());
    } catch (RestApiException | IOException e) {
        logger.atSevere().withCause(e).log("Can't insert change/patch set for %s", project.getName());
        reject(magicBranchCmd, "internal server error: " + e.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addError(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException | PermissionBackendException e) {
            logger.atSevere().withCause(e).log("Error submitting changes to %s", project.getName());
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#method_after
private void insertChangesAndPatchSets(List<CreateRequest> newChanges, Task replaceProgress) {
    ReceiveCommand magicBranchCmd = magicBranch != null ? magicBranch.cmd : null;
    if (magicBranchCmd != null && magicBranchCmd.getResult() != NOT_ATTEMPTED) {
        logger.atWarning().log("Skipping change updates on %s because ref update failed: %s %s", project.getName(), magicBranchCmd.getResult(), Strings.nullToEmpty(magicBranchCmd.getMessage()));
        return;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(project.getNameKey(), user.materializedCopy(), TimeUtil.nowTs());
        ObjectInserter ins = repo.newObjectInserter();
        ObjectReader reader = ins.newReader();
        RevWalk rw = new RevWalk(reader)) {
        bu.setRepository(repo, rw, ins);
        bu.setRefLogMessage("push");
        logger.atFine().log("Adding %d replace requests", newChanges.size());
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.addOps(bu, replaceProgress);
        }
        logger.atFine().log("Adding %d create requests", newChanges.size());
        for (CreateRequest create : newChanges) {
            create.addOps(bu);
        }
        logger.atFine().log("Adding %d group update requests", newChanges.size());
        updateGroups.forEach(r -> r.addOps(bu));
        logger.atFine().log("Executing batch");
        try {
            bu.execute();
        } catch (UpdateException e) {
            throw INSERT_EXCEPTION.apply(e);
        }
        replaceByChange.values().stream().forEach(req -> resultChangeIds.add(ResultChangeIds.Key.REPLACED, req.ontoChange));
        newChanges.stream().forEach(req -> resultChangeIds.add(ResultChangeIds.Key.CREATED, req.changeId));
        if (magicBranchCmd != null) {
            magicBranchCmd.setResult(OK);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            String rejectMessage = replace.getRejectMessage();
            if (rejectMessage == null) {
                if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
                    // Not necessarily the magic branch, so need to set OK on the original value.
                    replace.inputCommand.setResult(OK);
                }
            } else {
                logger.atFine().log("Rejecting due to message from ReplaceOp");
                reject(replace.inputCommand, rejectMessage);
            }
        }
    } catch (ResourceConflictException e) {
        addError(e.getMessage());
        reject(magicBranchCmd, "conflict");
    } catch (BadRequestException | UnprocessableEntityException | AuthException e) {
        logger.atFine().withCause(e).log("Rejecting due to client error");
        reject(magicBranchCmd, e.getMessage());
    } catch (RestApiException | IOException e) {
        logger.atSevere().withCause(e).log("Can't insert change/patch set for %s", project.getName());
        reject(magicBranchCmd, "internal server error: " + e.getMessage());
    }
    if (magicBranch != null && magicBranch.submit) {
        try {
            submit(newChanges, replaceByChange.values());
        } catch (ResourceConflictException e) {
            addError(e.getMessage());
            reject(magicBranchCmd, "conflict");
        } catch (RestApiException | OrmException | UpdateException | IOException | ConfigInvalidException | PermissionBackendException e) {
            logger.atSevere().withCause(e).log("Error submitting changes to %s", project.getName());
            reject(magicBranchCmd, "error during submit");
        }
    }
}
#end_block

#method_before
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) throws CmdLineException {
    if (!notesMigration.readChanges()) {
        throw cmdLineParser.reject("cannot add hashtags; noteDb is disabled");
    }
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#method_after
@Option(name = "--hashtag", aliases = { "-t" }, metaVar = "HASHTAG", usage = "add hashtag to changes")
void addHashtag(String token) {
    String hashtag = cleanupHashtag(token);
    if (!hashtag.isEmpty()) {
        hashtags.add(hashtag);
    }
// TODO(dpursehouse): validate hashtags
}
#end_block

#method_before
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    logger.atFine().log("Found magic branch %s", cmd.getRefName());
    MagicBranchInput magicBranch = new MagicBranchInput(user, cmd, labelTypes, notesMigration);
    String ref;
    magicBranch.cmdLineParser = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(repo, receivePack.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!magicBranch.cmdLineParser.wasHelpRequestedByOption()) {
            logger.atFine().log("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happens
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%d)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (magicBranch.cmdLineParser.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        magicBranch.cmdLineParser.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logger.atFine().log("Handling %s", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    if (!receivePack.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logger.atFine().log("Ref %s not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    Optional<AuthException> err = checkRefPermission(magicBranch.perm, RefPermission.CREATE_CHANGE);
    if (err.isPresent()) {
        rejectProhibited(cmd, err.get());
        return;
    }
    // after repo-tool supports private and work-in-progress changes.
    if (magicBranch.draft && !receiveConfig.allowDrafts) {
        errors.put(CODE_REVIEW_ERROR, ref);
        reject(cmd, "draft workflow is disabled");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    boolean privateByDefault = projectCache.get(project.getNameKey()).is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    setChangeAsPrivate = magicBranch.draft || magicBranch.isPrivate || (privateByDefault && !magicBranch.removePrivate);
    if (receiveConfig.disablePrivateChanges && setChangeAsPrivate) {
        reject(cmd, "private changes are disabled");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        err = checkRefPermission(magicBranch.perm, RefPermission.UPDATE_BY_SUBMIT);
        if (err.isPresent()) {
            rejectProhibited(cmd, err.get());
            return;
        }
    }
    RevWalk walk = receivePack.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logger.atFine().log("Tip of push: %s", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logger.atSevere().withCause(ex).log("Invalid pack upload; one or more objects weren't sent");
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logger.atFine().log("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logger.atFine().log("Handling %%base: %s", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logger.atWarning().withCause(e).log("Project %s cannot read %s", project.getName(), id.name());
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(cmd, magicBranch.dest);
            if (branchTip == null) {
                // readBranchTip already rejected cmd.
                return;
            }
            magicBranch.baseCommit = Collections.singletonList(branchTip);
            logger.atFine().log("Set baseCommit = %s", magicBranch.baseCommit.get(0).name());
        }
    } catch (IOException ex) {
        logger.atWarning().withCause(ex).log("Error walking to %s in project %s", destBranch, project.getName());
        reject(cmd, "internal server error");
        return;
    }
    if (magicBranch.deprecatedTopicSeen) {
        messages.add(new ValidationMessage("WARNING: deprecated topic syntax. Use %topic=TOPIC instead", false));
        logger.atInfo().log("deprecated topic push seen for project %s", project.getName());
    }
    if (validateConnected(magicBranch.cmd, magicBranch.dest, tip)) {
        this.magicBranch = magicBranch;
    }
}
#method_after
private void parseMagicBranch(ReceiveCommand cmd) throws PermissionBackendException {
    logger.atFine().log("Found magic branch %s", cmd.getRefName());
    MagicBranchInput magicBranch = new MagicBranchInput(user, cmd, labelTypes);
    String ref;
    magicBranch.cmdLineParser = optionParserFactory.create(magicBranch);
    try {
        ref = magicBranch.parse(repo, receivePack.getAdvertisedRefs().keySet(), pushOptions);
    } catch (CmdLineException e) {
        if (!magicBranch.cmdLineParser.wasHelpRequestedByOption()) {
            logger.atFine().log("Invalid branch syntax");
            reject(cmd, e.getMessage());
            return;
        }
        // never happens
        ref = null;
    }
    if (magicBranch.topic != null && magicBranch.topic.length() > ChangeUtil.TOPIC_MAX_LENGTH) {
        reject(cmd, String.format("topic length exceeds the limit (%d)", ChangeUtil.TOPIC_MAX_LENGTH));
    }
    if (magicBranch.cmdLineParser.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        magicBranch.cmdLineParser.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (projectState.isAllUsers() && RefNames.REFS_USERS_SELF.equals(ref)) {
        logger.atFine().log("Handling %s", RefNames.REFS_USERS_SELF);
        ref = RefNames.refsUsers(user.getAccountId());
    }
    // configuration.
    if (!receivePack.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
        logger.atFine().log("Ref %s not found", ref);
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.perm = permissions.ref(ref);
    Optional<AuthException> err = checkRefPermission(magicBranch.perm, RefPermission.CREATE_CHANGE);
    if (err.isPresent()) {
        rejectProhibited(cmd, err.get());
        return;
    }
    // after repo-tool supports private and work-in-progress changes.
    if (magicBranch.draft && !receiveConfig.allowDrafts) {
        errors.put(CODE_REVIEW_ERROR, ref);
        reject(cmd, "draft workflow is disabled");
        return;
    }
    if (magicBranch.isPrivate && magicBranch.removePrivate) {
        reject(cmd, "the options 'private' and 'remove-private' are mutually exclusive");
        return;
    }
    boolean privateByDefault = projectCache.get(project.getNameKey()).is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    setChangeAsPrivate = magicBranch.draft || magicBranch.isPrivate || (privateByDefault && !magicBranch.removePrivate);
    if (receiveConfig.disablePrivateChanges && setChangeAsPrivate) {
        reject(cmd, "private changes are disabled");
        return;
    }
    if (magicBranch.workInProgress && magicBranch.ready) {
        reject(cmd, "the options 'wip' and 'ready' are mutually exclusive");
        return;
    }
    if (magicBranch.publishComments && magicBranch.noPublishComments) {
        reject(cmd, "the options 'publish-comments' and 'no-publish-comments' are mutually exclusive");
        return;
    }
    if (magicBranch.submit) {
        err = checkRefPermission(magicBranch.perm, RefPermission.UPDATE_BY_SUBMIT);
        if (err.isPresent()) {
            rejectProhibited(cmd, err.get());
            return;
        }
    }
    RevWalk walk = receivePack.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
        logger.atFine().log("Tip of push: %s", tip.name());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logger.atSevere().withCause(ex).log("Invalid pack upload; one or more objects weren't sent");
        return;
    }
    String destBranch = magicBranch.dest.get();
    try {
        if (magicBranch.merged) {
            if (magicBranch.base != null) {
                reject(cmd, "cannot use merged with base");
                return;
            }
            RevCommit branchTip = readBranchTip(magicBranch.dest);
            if (branchTip == null) {
                reject(cmd, magicBranch.dest.get() + " not found");
                return;
            }
            if (!walk.isMergedInto(tip, branchTip)) {
                reject(cmd, "not merged into branch");
                return;
            }
        }
        // if %base or %merged was specified, ignore newChangeForAllNotInTarget.
        if (tip.getParentCount() > 1 || magicBranch.base != null || magicBranch.merged || tip.getParentCount() == 0) {
            logger.atFine().log("Forcing newChangeForAllNotInTarget = false");
            newChangeForAllNotInTarget = false;
        }
        if (magicBranch.base != null) {
            logger.atFine().log("Handling %%base: %s", magicBranch.base);
            magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
            for (ObjectId id : magicBranch.base) {
                try {
                    magicBranch.baseCommit.add(walk.parseCommit(id));
                } catch (IncorrectObjectTypeException notCommit) {
                    reject(cmd, "base must be a commit");
                    return;
                } catch (MissingObjectException e) {
                    reject(cmd, "base not found");
                    return;
                } catch (IOException e) {
                    logger.atWarning().withCause(e).log("Project %s cannot read %s", project.getName(), id.name());
                    reject(cmd, "internal server error");
                    return;
                }
            }
        } else if (newChangeForAllNotInTarget) {
            RevCommit branchTip = readBranchTip(magicBranch.dest);
            if (branchTip != null) {
                magicBranch.baseCommit = Collections.singletonList(branchTip);
                logger.atFine().log("Set baseCommit = %s", magicBranch.baseCommit.get(0).name());
            } else {
                // repository and to review an initial project configuration.
                if (!ref.equals(readHEAD(repo)) && !ref.equals(RefNames.REFS_CONFIG)) {
                    reject(cmd, magicBranch.dest.get() + " not found");
                    return;
                }
            }
        }
    } catch (IOException ex) {
        logger.atWarning().withCause(ex).log("Error walking to %s in project %s", destBranch, project.getName());
        reject(cmd, "internal server error");
        return;
    }
    if (magicBranch.deprecatedTopicSeen) {
        messages.add(new ValidationMessage("WARNING: deprecated topic syntax. Use %topic=TOPIC instead", false));
        logger.atInfo().log("deprecated topic push seen for project %s", project.getName());
    }
    if (validateConnected(magicBranch.cmd, magicBranch.dest, tip)) {
        this.magicBranch = magicBranch;
        this.resultChangeIds.setMagicPush(true);
    }
}
#end_block

#method_before
private static String readHEAD(Repository repo) {
    try {
        return repo.getFullBranch();
    } catch (IOException e) {
        logger.atSevere().withCause(e).log("Cannot read HEAD symref");
        return null;
    }
}
#method_after
private static String readHEAD(Repository repo) {
    try {
        String head = repo.getFullBranch();
        logger.atFine().log("HEAD = %s", head);
        return head;
    } catch (IOException e) {
        logger.atSevere().withCause(e).log("Cannot read HEAD symref");
        return null;
    }
}
#end_block

#method_before
private RevCommit readBranchTip(ReceiveCommand cmd, Branch.NameKey branch) throws IOException {
    Ref r = allRefs().get(branch.get());
    if (r == null) {
        reject(cmd, branch.get() + " not found");
        return null;
    }
    return receivePack.getRevWalk().parseCommit(r.getObjectId());
}
#method_after
private RevCommit readBranchTip(Branch.NameKey branch) throws IOException {
    Ref r = allRefs().get(branch.get());
    if (r == null) {
        return null;
    }
    return receivePack.getRevWalk().parseCommit(r.getObjectId());
}
#end_block

#method_before
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logger.atFine().log("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = receivePack.getRevWalk().parseCommit(cmd.getNewId());
        logger.atFine().log("Replacing with %s", newCommit);
    } catch (IOException e) {
        logger.atSevere().withCause(e).log("Cannot parse %s as commit", cmd.getNewId().name());
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(db, project.getNameKey(), changeId).getChange();
    } catch (NoSuchChangeException e) {
        logger.atSevere().withCause(e).log("Change not found %s", changeId);
        reject(cmd, "change " + changeId + " not found");
        return;
    } catch (OrmException e) {
        logger.atSevere().withCause(e).log("Cannot lookup existing change %s", changeId);
        reject(cmd, "database error");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    BranchCommitValidator validator = commitValidatorFactory.create(projectState, changeEnt.getDest(), user);
    try {
        if (validator.validCommit(receivePack.getRevWalk().getObjectReader(), cmd, newCommit, false, messages, rejectCommits, changeEnt)) {
            logger.atFine().log("Replacing change %s", changeEnt.getId());
            requestReplace(cmd, true, changeEnt, newCommit);
        }
    } catch (IOException e) {
        reject(cmd, "I/O exception validating commit");
    }
}
#method_after
private void parseReplaceCommand(ReceiveCommand cmd, Change.Id changeId) {
    logger.atFine().log("Parsing replace command");
    if (cmd.getType() != ReceiveCommand.Type.CREATE) {
        reject(cmd, "invalid usage");
        return;
    }
    RevCommit newCommit;
    try {
        newCommit = receivePack.getRevWalk().parseCommit(cmd.getNewId());
        logger.atFine().log("Replacing with %s", newCommit);
    } catch (IOException e) {
        logger.atSevere().withCause(e).log("Cannot parse %s as commit", cmd.getNewId().name());
        reject(cmd, "invalid commit");
        return;
    }
    Change changeEnt;
    try {
        changeEnt = notesFactory.createChecked(project.getNameKey(), changeId).getChange();
    } catch (NoSuchChangeException e) {
        logger.atSevere().withCause(e).log("Change not found %s", changeId);
        reject(cmd, "change " + changeId + " not found");
        return;
    } catch (OrmException e) {
        logger.atSevere().withCause(e).log("Cannot lookup existing change %s", changeId);
        reject(cmd, "database error");
        return;
    }
    if (!project.getNameKey().equals(changeEnt.getProject())) {
        reject(cmd, "change " + changeId + " does not belong to project " + project.getName());
        return;
    }
    BranchCommitValidator validator = commitValidatorFactory.create(projectState, changeEnt.getDest(), user);
    try {
        if (validator.validCommit(receivePack.getRevWalk().getObjectReader(), cmd, newCommit, false, messages, rejectCommits, changeEnt)) {
            logger.atFine().log("Replacing change %s", changeEnt.getId());
            requestReplace(cmd, true, changeEnt, newCommit);
        }
    } catch (IOException e) {
        reject(cmd, "I/O exception validating commit");
    }
}
#end_block

#method_before
private List<CreateRequest> selectNewAndReplacedChangesFromMagicBranch(Task newProgress) {
    logger.atFine().log("Finding new and replaced changes");
    List<CreateRequest> newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), db, psUtil, notesFactory, project.getNameKey());
    BranchCommitValidator validator = commitValidatorFactory.create(projectState, magicBranch.dest, user);
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return Collections.emptyList();
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).is(BooleanProjectConfig.REJECT_IMPLICIT_MERGES) && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = receivePack.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            receivePack.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                pending.put(c, lookupByChangeKey(c, new Change.Key(idList.get(idList.size() - 1).trim())));
            } else {
                pending.put(c, lookupByCommit(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logger.atFine().log("%d changes exceeds limit of %d", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logger.atFine().log("Creating new change for %s even though it is already tracked", name);
            }
            if (!validator.validCommit(receivePack.getRevWalk().getObjectReader(), magicBranch.cmd, c, magicBranch.merged, messages, rejectCommits, null)) {
                // Not a change the user can propose? Abort as early as possible.
                logger.atFine().log("Aborting early due to invalid commit");
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logger.atFine().log("Rejecting merge commit %s with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get(), newProgress));
                continue;
            }
        }
        logger.atFine().log("Finished initial RevWalk with %d commits total: %d already" + " tracked, %d new changes with no Change-Id, and %d deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logger.atFine().log("Multiple commits with Change-Id %s", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                return Collections.emptyList();
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logger.atFine().log("Multiple changes in branch %s with Change-Id %s: %s", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                return Collections.emptyList();
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        return Collections.emptyList();
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get(), newProgress));
        }
        logger.atFine().log("Finished deferred lookups with %d updates and %d new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logger.atSevere().withCause(e).log("Invalid pack upload; one or more objects weren't sent");
        return Collections.emptyList();
    } catch (OrmException e) {
        logger.atSevere().withCause(e).log("Cannot query database to locate prior changes");
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return newChanges;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logger.atFine().log("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logger.atSevere().withCause(e).log("Error collecting groups for changes");
        reject(magicBranch.cmd, "internal server error");
    }
    return newChanges;
}
#method_after
private List<CreateRequest> selectNewAndReplacedChangesFromMagicBranch(Task newProgress) {
    logger.atFine().log("Finding new and replaced changes");
    List<CreateRequest> newChanges = new ArrayList<>();
    ListMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(changeRefsById(), psUtil, notesFactory, project.getNameKey());
    BranchCommitValidator validator = commitValidatorFactory.create(projectState, magicBranch.dest, user);
    try {
        RevCommit start = setUpWalkForSelectingChanges();
        if (start == null) {
            return Collections.emptyList();
        }
        LinkedHashMap<RevCommit, ChangeLookup> pending = new LinkedHashMap<>();
        Set<Change.Key> newChangeIds = new HashSet<>();
        int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        int total = 0;
        int alreadyTracked = 0;
        boolean rejectImplicitMerges = start.getParentCount() == 1 && projectCache.get(project.getNameKey()).is(BooleanProjectConfig.REJECT_IMPLICIT_MERGES) && // late.
        !magicBranch.merged;
        Set<RevCommit> mergedParents;
        if (rejectImplicitMerges) {
            mergedParents = new HashSet<>();
        } else {
            mergedParents = null;
        }
        for (; ; ) {
            RevCommit c = receivePack.getRevWalk().next();
            if (c == null) {
                break;
            }
            total++;
            receivePack.getRevWalk().parseBody(c);
            String name = c.name();
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (rejectImplicitMerges) {
                Collections.addAll(mergedParents, c.getParents());
                mergedParents.remove(c);
            }
            boolean commitAlreadyTracked = !existingRefs.isEmpty();
            if (commitAlreadyTracked) {
                alreadyTracked++;
                // different target branch.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                if (!(newChangeForAllNotInTarget || magicBranch.base != null)) {
                    continue;
                }
            }
            List<String> idList = c.getFooterLines(CHANGE_ID);
            if (!idList.isEmpty()) {
                pending.put(c, lookupByChangeKey(c, new Change.Key(idList.get(idList.size() - 1).trim())));
            } else {
                pending.put(c, lookupByCommit(c));
            }
            int n = pending.size() + newChanges.size();
            if (maxBatchChanges != 0 && n > maxBatchChanges) {
                logger.atFine().log("%d changes exceeds limit of %d", n, maxBatchChanges);
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                return Collections.emptyList();
            }
            if (commitAlreadyTracked) {
                boolean changeExistsOnDestBranch = false;
                for (ChangeData cd : pending.get(c).destChanges) {
                    if (cd.change().getDest().equals(magicBranch.dest)) {
                        changeExistsOnDestBranch = true;
                        break;
                    }
                }
                if (changeExistsOnDestBranch) {
                    continue;
                }
                logger.atFine().log("Creating new change for %s even though it is already tracked", name);
            }
            if (!validator.validCommit(receivePack.getRevWalk().getObjectReader(), magicBranch.cmd, c, magicBranch.merged, messages, rejectCommits, null)) {
                // Not a change the user can propose? Abort as early as possible.
                logger.atFine().log("Aborting early due to invalid commit");
                return Collections.emptyList();
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
                logger.atFine().log("Rejecting merge commit %s with newChangeForAllNotInTarget", name);
            // TODO(dborowitz): Should we early return here?
            }
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get(), newProgress));
                continue;
            }
        }
        logger.atFine().log("Finished initial RevWalk with %d commits total: %d already" + " tracked, %d new changes with no Change-Id, and %d deferred" + " lookups", total, alreadyTracked, newChanges.size(), pending.size());
        if (rejectImplicitMerges) {
            rejectImplicitMerges(mergedParents);
        }
        for (Iterator<ChangeLookup> itr = pending.values().iterator(); itr.hasNext(); ) {
            ChangeLookup p = itr.next();
            if (p.changeKey == null) {
                continue;
            }
            if (newChangeIds.contains(p.changeKey)) {
                logger.atFine().log("Multiple commits with Change-Id %s", p.changeKey);
                reject(magicBranch.cmd, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
                return Collections.emptyList();
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                logger.atFine().log("Multiple changes in branch %s with Change-Id %s: %s", magicBranch.dest, p.changeKey, changes.stream().map(cd -> cd.getId().toString()).collect(joining()));
                // WTF, multiple changes in this branch have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique per branch.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                return Collections.emptyList();
            }
            if (changes.size() == 1) {
                // Schedule as a replacement to this one matching change.
                // 
                RevId currentPs = changes.get(0).currentPatchSet().getRevision();
                // If Commit is already current PatchSet of target Change.
                if (p.commit.name().equals(currentPs.get())) {
                    if (pending.size() == 1) {
                        // There are no commits left to check, all commits in pending were already
                        // current PatchSet of the corresponding target changes.
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                    } else {
                        // Commit is already current PatchSet.
                        // Remove from pending and try next commit.
                        itr.remove();
                        continue;
                    }
                }
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                }
                return Collections.emptyList();
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    return Collections.emptyList();
                }
                // double check against the existing refs
                if (foundInExistingRef(existing.get(p.commit))) {
                    if (pending.size() == 1) {
                        reject(magicBranch.cmd, "commit(s) already exists (as current patchset)");
                        return Collections.emptyList();
                    }
                    itr.remove();
                    continue;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get(), newProgress));
        }
        logger.atFine().log("Finished deferred lookups with %d updates and %d new changes", replaceByChange.size(), newChanges.size());
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        logger.atSevere().withCause(e).log("Invalid pack upload; one or more objects weren't sent");
        return Collections.emptyList();
    } catch (OrmException e) {
        logger.atSevere().withCause(e).log("Cannot query database to locate prior changes");
        reject(magicBranch.cmd, "database error");
        return Collections.emptyList();
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return Collections.emptyList();
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return newChanges;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        List<Integer> newIds = seq.nextChangeIds(newChanges.size());
        for (int i = 0; i < newChanges.size(); i++) {
            CreateRequest create = newChanges.get(i);
            create.setChangeId(newIds.get(i));
            create.groups = ImmutableList.copyOf(groups.get(create.commit));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
        logger.atFine().log("Finished updating groups from GroupCollector");
    } catch (OrmException e) {
        logger.atSevere().withCause(e).log("Error collecting groups for changes");
        reject(magicBranch.cmd, "internal server error");
    }
    return newChanges;
}
#end_block

#method_before
private boolean foundInExistingRef(Collection<Ref> existingRefs) throws OrmException {
    for (Ref ref : existingRefs) {
        ChangeNotes notes = notesFactory.create(db, project.getNameKey(), Change.Id.fromRef(ref.getName()));
        Change change = notes.getChange();
        if (change.getDest().equals(magicBranch.dest)) {
            logger.atFine().log("Found change %s from existing refs.", change.getKey());
            // Reindex the change asynchronously, ignoring errors.
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = indexer.indexAsync(project.getNameKey(), change.getId());
            return true;
        }
    }
    return false;
}
#method_after
private boolean foundInExistingRef(Collection<Ref> existingRefs) throws OrmException {
    for (Ref ref : existingRefs) {
        ChangeNotes notes = notesFactory.create(project.getNameKey(), Change.Id.fromRef(ref.getName()));
        Change change = notes.getChange();
        if (change.getDest().equals(magicBranch.dest)) {
            logger.atFine().log("Found change %s from existing refs.", change.getKey());
            // Reindex the change asynchronously, ignoring errors.
            @SuppressWarnings("unused")
            Future<?> possiblyIgnoredError = indexer.indexAsync(project.getNameKey(), change.getId());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        requireNonNull(r.change, () -> String.format("cannot submit new change %s; op may not have run", r.changeId));
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    requireNonNull(tipChange, () -> String.format("tip of push does not correspond to a change; found these changes: %s", bySha));
    logger.atFine().log("Processing submit with tip change %s (%s)", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, tipChange, user, false, new SubmitInput(), false);
    }
}
#method_after
private void submit(Collection<CreateRequest> create, Collection<ReplaceRequest> replace) throws OrmException, RestApiException, UpdateException, IOException, ConfigInvalidException, PermissionBackendException {
    Map<ObjectId, Change> bySha = Maps.newHashMapWithExpectedSize(create.size() + replace.size());
    for (CreateRequest r : create) {
        requireNonNull(r.change, () -> String.format("cannot submit new change %s; op may not have run", r.changeId));
        bySha.put(r.commit, r.change);
    }
    for (ReplaceRequest r : replace) {
        bySha.put(r.newCommitId, r.notes.getChange());
    }
    Change tipChange = bySha.get(magicBranch.cmd.getNewId());
    requireNonNull(tipChange, () -> String.format("tip of push does not correspond to a change; found these changes: %s", bySha));
    logger.atFine().log("Processing submit with tip change %s (%s)", tipChange.getId(), magicBranch.cmd.getNewId());
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(tipChange, user, false, new SubmitInput(), false);
    }
}
#end_block

#method_before
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(db, replaceByChange.values().stream().map(r -> r.ontoChange).collect(toList()));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#method_after
private void readChangesForReplace() throws OrmException {
    Collection<ChangeNotes> allNotes = notesFactory.create(replaceByChange.values().stream().map(r -> r.ontoChange).collect(toList()));
    for (ChangeNotes notes : allNotes) {
        replaceByChange.get(notes.getChangeId()).notes = notes;
    }
}
#end_block

#method_before
private boolean validateNewPatchSetNoteDb() throws IOException, OrmException, PermissionBackendException {
    if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = receivePack.getRevWalk().parseCommit(newCommitId);
    // Not allowed to create a new patch set if the current patch set is locked.
    if (psUtil.isPatchSetLocked(notes)) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    try {
        permissions.change(notes).database(db).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : receivePack.getRepository().getRefDatabase().getRefsByPrefix("refs/changes")) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (receivePack.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    return true;
}
#method_after
private boolean validateNewPatchSetNoteDb() throws IOException, OrmException, PermissionBackendException {
    if (notes == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    Change change = notes.getChange();
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = receivePack.getRevWalk().parseCommit(newCommitId);
    // Not allowed to create a new patch set if the current patch set is locked.
    if (psUtil.isPatchSetLocked(notes)) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    try {
        permissions.change(notes).check(ChangePermission.ADD_PATCH_SET);
    } catch (AuthException no) {
        reject(inputCommand, "cannot add patch set to " + ontoChange + ".");
        return false;
    }
    if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (Ref r : receivePack.getRepository().getRefDatabase().getRefsByPrefix("refs/changes")) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (receivePack.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, SAME_CHANGE_ID_IN_MULTIPLE_CHANGES);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void sameTreeWarning() throws IOException {
    RevCommit newCommit = receivePack.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        boolean messageEq = Objects.equals(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = receivePack.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq) {
            addMessage(String.format("warning: no changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("warning: ").append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
}
#method_after
private void sameTreeWarning() throws IOException {
    RevWalk rw = receivePack.getRevWalk();
    RevCommit newCommit = rw.parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        rw.parseBody(newCommit);
        rw.parseBody(priorCommit);
        boolean messageEq = Objects.equals(newCommit.getFullMessage(), priorCommit.getFullMessage());
        boolean parentsEq = parentsEqual(newCommit, priorCommit);
        boolean authorEq = authorEqual(newCommit, priorCommit);
        ObjectReader reader = receivePack.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq) {
            addMessage(String.format("warning: no changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("warning: ").append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
}
#end_block

#method_before
private void addOps(BatchUpdate bu) {
    bu.addOp(psId.getParentKey(), new BatchUpdateOp() {

        @Override
        public boolean updateChange(ChangeContext ctx) throws OrmException {
            PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
            List<String> oldGroups = ps.getGroups();
            if (oldGroups == null) {
                if (groups == null) {
                    return false;
                }
            } else if (sameGroups(oldGroups, groups)) {
                return false;
            }
            psUtil.setGroups(ctx.getDb(), ctx.getUpdate(psId), ps, groups);
            return true;
        }
    });
}
#method_after
private void addOps(BatchUpdate bu) {
    bu.addOp(psId.getParentKey(), new BatchUpdateOp() {

        @Override
        public boolean updateChange(ChangeContext ctx) throws OrmException {
            PatchSet ps = psUtil.get(ctx.getNotes(), psId);
            List<String> oldGroups = ps.getGroups();
            if (oldGroups == null) {
                if (groups == null) {
                    return false;
                }
            } else if (sameGroups(oldGroups, groups)) {
                return false;
            }
            psUtil.setGroups(ctx.getUpdate(psId), ps, groups);
            return true;
        }
    });
}
#end_block

#method_before
private void autoCloseChanges(ReceiveCommand cmd, Task progress) {
    logger.atFine().log("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    Set<Change.Id> ids = new HashSet<>();
    // handleRegularCommands
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(db, projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins).updateChangesInParallel();
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeNotes> notes = getChangeNotes(psId.getParentKey());
                        if (notes.isPresent() && notes.get().getChange().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = executeIndexQuery(() -> openChangesByKeyByBranch(branch));
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!req.validateNewPatchSetForAutoClose()) {
                        logger.atFine().log("Not closing %s because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(req.replaceOp::getPatchSet));
                    bu.addOp(id, new ChangeProgressOp(progress));
                    ids.add(id);
                }
                logger.atFine().log("Auto-closing %s changes with existing patch sets and %s with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logger.atSevere().withCause(e).log("Failed to auto-close changes");
                return null;
            }
            // If we are here, we didn't throw UpdateException. Record the result.
            // The ordering is indeterminate due to the HashSet; unfortunately, Change.Id doesn't
            // fit into TreeSet.
            ids.stream().forEach(id -> resultChangeIds.add(Key.AUTOCLOSED, id));
            return null;
        }, // eat up the whole timeout so that no time is left to retry this outer action.
        RetryHelper.options().timeout(retryHelper.getDefaultTimeout(ActionType.CHANGE_UPDATE).multipliedBy(5)).build());
    } catch (RestApiException e) {
        logger.atSevere().withCause(e).log("Can't insert patchset");
    } catch (UpdateException e) {
        logger.atSevere().withCause(e).log("Failed to auto-close changes");
    }
}
#method_after
private void autoCloseChanges(ReceiveCommand cmd, Task progress) {
    logger.atFine().log("Starting auto-closing of changes");
    String refName = cmd.getRefName();
    Set<Change.Id> ids = new HashSet<>();
    // handleRegularCommands
    try {
        retryHelper.execute(updateFactory -> {
            try (BatchUpdate bu = updateFactory.create(projectState.getNameKey(), user, TimeUtil.nowTs());
                ObjectInserter ins = repo.newObjectInserter();
                ObjectReader reader = ins.newReader();
                RevWalk rw = new RevWalk(reader)) {
                bu.setRepository(repo, rw, ins);
                // TODO(dborowitz): Teach BatchUpdate to ignore missing changes.
                RevCommit newTip = rw.parseCommit(cmd.getNewId());
                Branch.NameKey branch = new Branch.NameKey(project.getNameKey(), refName);
                rw.reset();
                rw.markStart(newTip);
                if (!ObjectId.zeroId().equals(cmd.getOldId())) {
                    rw.markUninteresting(rw.parseCommit(cmd.getOldId()));
                }
                ListMultimap<ObjectId, Ref> byCommit = changeRefsById();
                Map<Change.Key, ChangeNotes> byKey = null;
                List<ReplaceRequest> replaceAndClose = new ArrayList<>();
                int existingPatchSets = 0;
                int newPatchSets = 0;
                COMMIT: for (RevCommit c; (c = rw.next()) != null; ) {
                    rw.parseBody(c);
                    for (Ref ref : byCommit.get(c.copy())) {
                        PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
                        Optional<ChangeNotes> notes = getChangeNotes(psId.getParentKey());
                        if (notes.isPresent() && notes.get().getChange().getDest().equals(branch)) {
                            existingPatchSets++;
                            bu.addOp(psId.getParentKey(), mergedByPushOpFactory.create(requestScopePropagator, psId, refName));
                            continue COMMIT;
                        }
                    }
                    for (String changeId : c.getFooterLines(CHANGE_ID)) {
                        if (byKey == null) {
                            byKey = executeIndexQuery(() -> openChangesByKeyByBranch(branch));
                        }
                        ChangeNotes onto = byKey.get(new Change.Key(changeId.trim()));
                        if (onto != null) {
                            newPatchSets++;
                            // Hold onto this until we're done with the walk, as the call to
                            // req.validate below calls isMergedInto which resets the walk.
                            ReplaceRequest req = new ReplaceRequest(onto.getChangeId(), c, cmd, false);
                            req.notes = onto;
                            replaceAndClose.add(req);
                            continue COMMIT;
                        }
                    }
                }
                for (ReplaceRequest req : replaceAndClose) {
                    Change.Id id = req.notes.getChangeId();
                    if (!req.validateNewPatchSetForAutoClose()) {
                        logger.atFine().log("Not closing %s because validation failed", id);
                        continue;
                    }
                    req.addOps(bu, null);
                    bu.addOp(id, mergedByPushOpFactory.create(requestScopePropagator, req.psId, refName).setPatchSetProvider(req.replaceOp::getPatchSet));
                    bu.addOp(id, new ChangeProgressOp(progress));
                    ids.add(id);
                }
                logger.atFine().log("Auto-closing %s changes with existing patch sets and %s with new patch sets", existingPatchSets, newPatchSets);
                bu.execute();
            } catch (IOException | OrmException | PermissionBackendException e) {
                logger.atSevere().withCause(e).log("Failed to auto-close changes");
                return null;
            }
            // If we are here, we didn't throw UpdateException. Record the result.
            // The ordering is indeterminate due to the HashSet; unfortunately, Change.Id doesn't
            // fit into TreeSet.
            ids.stream().forEach(id -> resultChangeIds.add(ResultChangeIds.Key.AUTOCLOSED, id));
            return null;
        }, // eat up the whole timeout so that no time is left to retry this outer action.
        RetryHelper.options().timeout(retryHelper.getDefaultTimeout(ActionType.CHANGE_UPDATE).multipliedBy(5)).build());
    } catch (RestApiException e) {
        logger.atSevere().withCause(e).log("Can't insert patchset");
    } catch (UpdateException e) {
        logger.atSevere().withCause(e).log("Failed to auto-close changes");
    }
}
#end_block

#method_before
private Optional<ChangeNotes> getChangeNotes(Change.Id changeId) throws OrmException {
    try {
        return Optional.of(notesFactory.createChecked(db, project.getNameKey(), changeId));
    } catch (NoSuchChangeException e) {
        return Optional.empty();
    }
}
#method_after
private Optional<ChangeNotes> getChangeNotes(Change.Id changeId) throws OrmException {
    try {
        return Optional.of(notesFactory.createChecked(project.getNameKey(), changeId));
    } catch (NoSuchChangeException e) {
        return Optional.empty();
    }
}
#end_block

#method_before
private static Path ensureExists(Path dataDir) {
    Path pluginDataDirectory = dataDir.resolve(SAML);
    if (!Files.isDirectory(pluginDataDirectory)) {
        try {
            Files.createDirectories(pluginDataDirectory);
        } catch (IOException e) {
            log.error("Creation of saml data dir [{}] failed.", pluginDataDirectory, e);
            throw new RuntimeException(e);
        }
    }
    return pluginDataDirectory;
}
#method_after
private static Path ensureExists(Path dataDir) throws IOException {
    return Files.createDirectories(dataDir.resolve(SAML));
}
#end_block

#method_before
private List<Entry<Account, Integer>> getApprovalAccounts() {
    Map<Account, Integer> reviewersApproved = new HashMap<>();
    try {
        List<ChangeInfo> infoList = gApi.changes().query("status:merged -age:" + plusTwoAge + "weeks limit:" + plusTwoLimit + " -label:Code-Review=2," + change.getOwner().get() + " label:Code-Review=2 project:" + projectName.toString()).withOptions(ListChangesOption.LABELS, ListChangesOption.DETAILED_ACCOUNTS).get();
        for (ChangeInfo info : infoList) {
            // TODO Check if this is good enough
            try {
                Account account = accountCache.getByUsername(info.labels.get("Code-Review").approved.username).get().getAccount();
                if (reviewersApproved.containsKey(account)) {
                    reviewersApproved.put(account, reviewersApproved.get(account) + 1);
                } else {
                    reviewersApproved.put(account, 1);
                }
            } catch (java.util.NoSuchElementException e) {
                log.error("No username for this account found in cache {}", e);
            }
        }
    } catch (RestApiException e) {
        log.error(e.getMessage(), e);
    }
    log.debug("getApprovalAccounts found {} reviewers", reviewersApproved.size());
    try {
        List<Entry<Account, Integer>> approvalAccounts = Ordering.from(new Comparator<Entry<Account, Integer>>() {

            @Override
            public int compare(Entry<Account, Integer> o1, Entry<Account, Integer> o2) {
                return o1.getValue() - o2.getValue();
            }
        }).greatestOf(reviewersApproved.entrySet(), reviewersApproved.size());
        return approvalAccounts;
    } catch (Exception e) {
        log.error(e.getMessage(), e);
    }
    return new ArrayList<>();
}
#method_after
private List<Entry<Account, Integer>> getApprovalAccounts() {
    Map<Account, Integer> reviewersApproved = new HashMap<>();
    try {
        List<ChangeInfo> infoList = gApi.changes().query("status:merged -age:" + plusTwoAge + "weeks limit:" + plusTwoLimit + " -label:Code-Review=2," + change.getOwner().get() + " label:Code-Review=2 project:" + projectName.toString()).withOptions(ListChangesOption.LABELS, ListChangesOption.DETAILED_ACCOUNTS).get();
        for (ChangeInfo info : infoList) {
            // TODO Check if this is good enough
            Optional<AccountState> accountState = accountCache.getByUsername(info.labels.get("Code-Review").approved.username);
            if (accountState.isPresent()) {
                Account account = accountState.get().getAccount();
                if (reviewersApproved.containsKey(account)) {
                    reviewersApproved.put(account, reviewersApproved.get(account) + 1);
                } else {
                    reviewersApproved.put(account, 1);
                }
            } else {
                log.error("No username for this account found in cache");
            }
        }
    } catch (RestApiException e) {
        log.error(e.getMessage(), e);
    }
    log.debug("getApprovalAccounts found {} reviewers", reviewersApproved.size());
    try {
        List<Entry<Account, Integer>> approvalAccounts = Ordering.from(new Comparator<Entry<Account, Integer>>() {

            @Override
            public int compare(Entry<Account, Integer> o1, Entry<Account, Integer> o2) {
                return o1.getValue() - o2.getValue();
            }
        }).greatestOf(reviewersApproved.entrySet(), reviewersApproved.size());
        return approvalAccounts;
    } catch (Exception e) {
        log.error(e.getMessage(), e);
    }
    return new ArrayList<>();
}
#end_block

#method_before
private List<Entry<Account, Integer>> getReviewers(List<Edit> edits, BlameResult blameResult) {
    Map<Account, Integer> blameData = new HashMap<>();
    try {
        for (Edit edit : edits) {
            for (int i = edit.getBeginA(); i < edit.getEndA(); i++) {
                RevCommit commit = blameResult.getSourceCommit(i);
                Set<Account.Id> idSet = emails.getAccountFor(commit.getAuthorIdent().getEmailAddress());
                for (Account.Id id : idSet) {
                    Account account = accountCache.get(id).get().getAccount();
                    if (account.isActive() && !change.getOwner().equals(account.getId())) {
                        Integer count = blameData.get(account);
                        if (count == null) {
                            count = 1;
                        } else {
                            count = count + 1;
                        }
                        blameData.put(account, count);
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(e.getMessage(), e);
    }
    List<Entry<Account, Integer>> topReviewers = Ordering.from(new Comparator<Entry<Account, Integer>>() {

        @Override
        public int compare(Entry<Account, Integer> itemOne, Entry<Account, Integer> itemTwo) {
            return itemOne.getValue() - itemTwo.getValue();
        }
    }).greatestOf(blameData.entrySet(), maxReviewers * 2);
    // TODO Check if maxReviewers * 2 is sufficient
    log.debug("getReviewers found {} reviewers", topReviewers.size());
    return topReviewers;
}
#method_after
private List<Entry<Account, Integer>> getReviewers(List<Edit> edits, BlameResult blameResult) {
    Map<Account, Integer> blameData = new HashMap<>();
    try {
        for (Edit edit : edits) {
            for (int i = edit.getBeginA(); i < edit.getEndA(); i++) {
                RevCommit commit = blameResult.getSourceCommit(i);
                Set<Account.Id> idSet = emails.getAccountFor(commit.getAuthorIdent().getEmailAddress());
                for (Account.Id id : idSet) {
                    Optional<AccountState> accountState = accountCache.get(id);
                    if (accountState.isPresent()) {
                        Account account = accountState.get().getAccount();
                        if (account.isActive() && !change.getOwner().equals(account.getId())) {
                            Integer count = blameData.get(account);
                            if (count == null) {
                                count = 1;
                            } else {
                                count = count + 1;
                            }
                            blameData.put(account, count);
                        }
                    }
                }
            }
        }
    } catch (Exception e) {
        log.error(e.getMessage(), e);
    }
    List<Entry<Account, Integer>> topReviewers = Ordering.from(new Comparator<Entry<Account, Integer>>() {

        @Override
        public int compare(Entry<Account, Integer> itemOne, Entry<Account, Integer> itemTwo) {
            return itemOne.getValue() - itemTwo.getValue();
        }
    }).greatestOf(blameData.entrySet(), maxReviewers * 2);
    // TODO Check if maxReviewers * 2 is sufficient
    log.debug("getReviewers found {} reviewers", topReviewers.size());
    return topReviewers;
}
#end_block

#method_before
@Override
public Enumeration<String> getHeaderNames() {
    Enumeration<String> wrappedHeaderNames = super.getHeaderNames();
    HashSet<String> headerNames = new HashSet<>();
    while (wrappedHeaderNames.hasMoreElements()) {
        String header = wrappedHeaderNames.nextElement();
        if (!authHeaders.contains(header.toUpperCase())) {
            headerNames.add(header);
        }
    }
    return Iterators.asEnumeration(headerNames.iterator());
}
#method_after
@Override
public Enumeration<String> getHeaderNames() {
    Enumeration<String> wrappedHeaderNames = super.getHeaderNames();
    HashSet<String> headerNames = new HashSet<>();
    while (wrappedHeaderNames.hasMoreElements()) {
        String header = wrappedHeaderNames.nextElement();
        if (!authHeaders.contains(header.toUpperCase())) {
            headerNames.add(wrappedHeaderNames.nextElement());
        }
    }
    return Iterators.asEnumeration(headerNames.iterator());
}
#end_block

#method_before
@Override
public Enumeration<String> getHeaderNames() {
    Enumeration<String> wrappedHeaderNames = super.getHeaderNames();
    HashSet<String> headerNames = new HashSet<>();
    while (wrappedHeaderNames.hasMoreElements()) {
        String header = wrappedHeaderNames.nextElement();
        if (!authHeaders.contains(header.toUpperCase())) {
            headerNames.add(header);
        }
    }
    return Iterators.asEnumeration(headerNames.iterator());
}
#method_after
@Override
public Enumeration<String> getHeaderNames() {
    Enumeration<String> wrappedHeaderNames = super.getHeaderNames();
    HashSet<String> headerNames = new HashSet<>();
    while (wrappedHeaderNames.hasMoreElements()) {
        String header = wrappedHeaderNames.nextElement();
        if (!authHeaders.contains(header.toUpperCase())) {
            headerNames.add(wrappedHeaderNames.nextElement());
        }
    }
    return Iterators.asEnumeration(headerNames.iterator());
}
#end_block

#method_before
public List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) throws NoSuchProjectException, IOException {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        BatchUpdate bu = getRepo(project).getUpdate();
        updates.add(bu.setRefLogMessage("merged"));
    }
    return updates;
}
#method_after
public List<BatchUpdate> batchUpdates(Collection<Project.NameKey> projects) throws NoSuchProjectException, IOException {
    List<BatchUpdate> updates = new ArrayList<>(projects.size());
    for (Project.NameKey project : projects) {
        updates.add(getRepo(project).getUpdate().setNotify(notify).setRefLogMessage("merged"));
    }
    return updates;
}
#end_block

#method_before
public ReviewerAddition prepare(ChangeNotes notes, CurrentUser user, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    requireNonNull(input.reviewer);
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(notes.getProjectName()).is(BooleanProjectConfig.ENABLE_REVIEWER_BY_EMAIL);
    ReviewerAddition byAccountId = addByAccountId(input, notes, user);
    ReviewerAddition wholeGroup = null;
    if (!byAccountId.exactMatchFound) {
        wholeGroup = addWholeGroup(input, notes, user, confirmed, allowGroup, allowByEmail);
        if (wholeGroup != null && wholeGroup.exactMatchFound) {
            return wholeGroup;
        }
    }
    if (byAccountId != null && wholeGroup != null && byAccountId.failureType == FailureType.NOT_FOUND && wholeGroup.failureType == FailureType.NOT_FOUND) {
        return fail(byAccountId.input, FailureType.NOT_FOUND, byAccountId.result.error + "\n" + wholeGroup.result.error);
    }
    if (byAccountId != null && byAccountId.failureType != FailureType.NOT_FOUND) {
        return byAccountId;
    }
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(input, notes, user);
}
#method_after
public ReviewerAddition prepare(ChangeNotes notes, CurrentUser user, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    requireNonNull(input.reviewer);
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(notes.getProjectName()).is(BooleanProjectConfig.ENABLE_REVIEWER_BY_EMAIL);
    ReviewerAddition byAccountId = addByAccountId(input, notes, user);
    ReviewerAddition wholeGroup = null;
    if (!byAccountId.exactMatchFound) {
        wholeGroup = addWholeGroup(input, notes, user, confirmed, allowGroup, allowByEmail);
        if (wholeGroup != null && wholeGroup.exactMatchFound) {
            return wholeGroup;
        }
    }
    if (wholeGroup != null && byAccountId.failureType == FailureType.NOT_FOUND && wholeGroup.failureType == FailureType.NOT_FOUND) {
        return fail(byAccountId.input, FailureType.NOT_FOUND, byAccountId.result.error + "\n" + wholeGroup.result.error);
    }
    if (byAccountId.failureType != FailureType.NOT_FOUND) {
        return byAccountId;
    }
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(input, notes, user);
}
#end_block

#method_before
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, RevertInput input) throws OrmException, IOException, RestApiException, UpdateException, ConfigInvalidException {
    String message = Strings.emptyToNull(input.message);
    Change.Id changeIdToRevert = notes.getChangeId();
    PatchSet.Id patchSetId = notes.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(notes, patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = notes.getProjectName();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = serverIdent.get();
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = notes.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        NotifyResolver.Result notify = notifyResolver.resolve(firstNonNull(input.notify, NotifyHandling.NONE), input.notifyDetails);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, notes.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(notes);
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setReviewersAndCcs(reviewers, ccs);
        ins.setRevertOf(changeIdToRevert);
        try (BatchUpdate bu = updateFactory.create(project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.setNotify(notify);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(changeToRevert, ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#method_after
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, RevertInput input) throws OrmException, IOException, RestApiException, UpdateException, ConfigInvalidException {
    String message = Strings.emptyToNull(input.message);
    Change.Id changeIdToRevert = notes.getChangeId();
    PatchSet.Id patchSetId = notes.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(notes, patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = notes.getProjectName();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = serverIdent.get();
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = notes.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        NotifyResolver.Result notify = notifyResolver.resolve(firstNonNull(input.notify, NotifyHandling.ALL), input.notifyDetails);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, notes.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(notes);
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setReviewersAndCcs(reviewers, ccs);
        ins.setRevertOf(changeIdToRevert);
        try (BatchUpdate bu = updateFactory.create(project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.setNotify(notify);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(changeToRevert, ins));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#end_block

#method_before
@Test
public void byExtension() throws Exception {
    if (getSchemaVersion() < 52) {
        assertMissingField(ChangeField.EXTENSION);
        String unsupportedOperatorMsg = "'extension' operator is not supported by change index version";
        assertFailingQuery("extension:txt", unsupportedOperatorMsg);
        assertFailingQuery("ext:txt", unsupportedOperatorMsg);
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChangeWithFiles(repo, "foo.h", "foo.cc"));
    Change change2 = insert(repo, newChangeWithFiles(repo, "bar.H", "bar.CC"));
    Change change3 = insert(repo, newChangeWithFiles(repo, "dir/baz.h", "dir/baz.cc"));
    Change change4 = insert(repo, newChangeWithFiles(repo, "Quux.java"));
    assertQuery("extension:java", change4);
    assertQuery("ext:java", change4);
    assertQuery("ext:.java", change4);
    assertQuery("ext:jAvA", change4);
    assertQuery("ext:.jAvA", change4);
    assertQuery("ext:cc", change3, change2, change1);
}
#method_after
@Test
public void byExtension() throws Exception {
    if (getSchemaVersion() < 52) {
        assertMissingField(ChangeField.EXTENSION);
        String unsupportedOperatorMsg = "'extension' operator is not supported by change index version";
        assertFailingQuery("extension:txt", unsupportedOperatorMsg);
        assertFailingQuery("ext:txt", unsupportedOperatorMsg);
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChangeWithFiles(repo, "foo.h", "foo.cc"));
    Change change2 = insert(repo, newChangeWithFiles(repo, "bar.H", "bar.CC"));
    Change change3 = insert(repo, newChangeWithFiles(repo, "dir/baz.h", "dir/baz.cc"));
    Change change4 = insert(repo, newChangeWithFiles(repo, "Quux.java", "foo"));
    assertQuery("extension:java", change4);
    assertQuery("ext:java", change4);
    assertQuery("ext:.java", change4);
    assertQuery("ext:jAvA", change4);
    assertQuery("ext:.jAvA", change4);
    assertQuery("ext:cc", change3, change2, change1);
    if (getSchemaVersion() >= 56) {
        // matching changes with files that have no extension is possible
        assertQuery("ext:\"\"", change4);
        assertFailingQuery("ext:");
    }
}
#end_block

#method_before
protected void assertFailingQuery(String query, String expectedMessage) throws Exception {
    try {
        assertQuery(query);
        fail("expected BadRequestException for query '" + query + "'");
    } catch (BadRequestException e) {
        assertThat(e.getMessage()).isEqualTo(expectedMessage);
    }
}
#method_after
protected void assertFailingQuery(String query) throws Exception {
    assertFailingQuery(query, null);
}
#end_block

#method_before
protected void assertFailingQuery(String query, String expectedMessage) throws Exception {
    try {
        assertQuery(query);
        fail("expected BadRequestException for query '" + query + "'");
    } catch (BadRequestException e) {
        assertThat(e.getMessage()).isEqualTo(expectedMessage);
    }
}
#method_after
protected void assertFailingQuery(String query, @Nullable String expectedMessage) throws Exception {
    try {
        assertQuery(query);
        fail("expected BadRequestException for query '" + query + "'");
    } catch (BadRequestException e) {
        if (expectedMessage != null) {
            assertThat(e.getMessage()).isEqualTo(expectedMessage);
        }
    }
}
#end_block

#method_before
public ReviewerAddition prepare(ChangeNotes notes, CurrentUser user, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    requireNonNull(input.reviewer);
    NotifyResolver.Result notify;
    try {
        notify = resolveNotify(notes, input);
    } catch (BadRequestException e) {
        return fail(input, FailureType.OTHER, e.getMessage());
    }
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(notes.getProjectName()).is(BooleanProjectConfig.ENABLE_REVIEWER_BY_EMAIL);
    ReviewerAddition byAccountId = addByAccountId(input, notes, user, notify);
    ReviewerAddition wholeGroup = null;
    if (!byAccountId.exactMatchFound) {
        wholeGroup = addWholeGroup(input, notes, user, notify, confirmed, allowGroup, allowByEmail);
        if (wholeGroup != null && wholeGroup.exactMatchFound) {
            return wholeGroup;
        }
    }
    if (byAccountId != null && wholeGroup != null && byAccountId.failureType == FailureType.NOT_FOUND && wholeGroup.failureType == FailureType.NOT_FOUND) {
        return fail(byAccountId.input, FailureType.NOT_FOUND, byAccountId.result.error + "\n" + wholeGroup.result.error);
    }
    if (byAccountId != null && byAccountId.failureType != FailureType.NOT_FOUND) {
        return byAccountId;
    }
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(input, notes, user, notify);
}
#method_after
public ReviewerAddition prepare(ChangeNotes notes, CurrentUser user, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    requireNonNull(input.reviewer);
    NotifyResolver.Result notify;
    try {
        notify = resolveNotify(notes, input);
    } catch (BadRequestException e) {
        return fail(input, FailureType.OTHER, e.getMessage());
    }
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(notes.getProjectName()).is(BooleanProjectConfig.ENABLE_REVIEWER_BY_EMAIL);
    ReviewerAddition byAccountId = addByAccountId(input, notes, user, notify);
    ReviewerAddition wholeGroup = null;
    if (!byAccountId.exactMatchFound) {
        wholeGroup = addWholeGroup(input, notes, user, notify, confirmed, allowGroup, allowByEmail);
        if (wholeGroup != null && wholeGroup.exactMatchFound) {
            return wholeGroup;
        }
    }
    if (wholeGroup != null && byAccountId.failureType == FailureType.NOT_FOUND && wholeGroup.failureType == FailureType.NOT_FOUND) {
        return fail(byAccountId.input, FailureType.NOT_FOUND, byAccountId.result.error + "\n" + wholeGroup.result.error);
    }
    if (byAccountId.failureType != FailureType.NOT_FOUND) {
        return byAccountId;
    }
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(input, notes, user, notify);
}
#end_block

#method_before
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException, PatchListNotAvailableException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    ProjectState projectState = projectCache.checkedGet(revision.getProject());
    LabelTypes labelTypes = projectState.getLabelTypes(revision.getNotes());
    input.drafts = firstNonNull(input.drafts, DraftHandling.KEEP);
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, labelTypes, input);
    }
    if (input.labels != null) {
        checkLabels(revision, labelTypes, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    NotifyResolver.Result notify = notifyResolver.resolve(input.notify, input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<ReviewerAddition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent individual AddReviewersOps from sending one email each. Instead, we call
            // batchEmailReviewers at the very end to send out a single email.
            // TODO(dborowitz): I think this still sends out separate emails if any of input.reviewers
            // specifies explicit accountsToNotify. Unclear whether that's a good thing.
            reviewerInput.notify = NotifyHandling.NONE;
            ReviewerAddition result = reviewerAdder.prepare(revision.getNotes(), revision.getUser(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (ReviewerAddition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            ReviewerAddition selfAddition = reviewerAdder.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            WorkInProgressOp.checkPermissions(permissionBackend, revision.getUser(), revision.getChange());
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(projectState, revision.getPatchSet().getId(), input, notify.accounts()));
        bu.execute();
        // Re-read change to take into account results of the update.
        ChangeData cd = changeDataFactory.create(revision.getProject(), revision.getChange().getId());
        for (ReviewerAddition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults(cd);
        }
        boolean readyForReview = (output.ready != null && output.ready) || !revision.getChange().isWorkInProgress();
        // Sending from AddReviewersOp was suppressed so we can send a single batch email here.
        batchEmailReviewers(revision.getUser(), revision.getChange(), reviewerResults, notify, readyForReview);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(BatchUpdate.Factory updateFactory, RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException, PermissionBackendException, ConfigInvalidException, PatchListNotAvailableException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    ProjectState projectState = projectCache.checkedGet(revision.getProject());
    LabelTypes labelTypes = projectState.getLabelTypes(revision.getNotes());
    input.drafts = firstNonNull(input.drafts, DraftHandling.KEEP);
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, labelTypes, input);
    }
    if (input.labels != null) {
        checkLabels(revision, labelTypes, input.labels);
    }
    if (input.comments != null) {
        cleanUpComments(input.comments);
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        input.notify = defaultNotify(revision.getChange(), input);
    }
    NotifyResolver.Result notify = notifyResolver.resolve(input.notify, input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<ReviewerAddition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent individual AddReviewersOps from sending one email each. Instead, we call
            // batchEmailReviewers at the very end to send out a single email.
            // TODO(dborowitz): I think this still sends out separate emails if any of input.reviewers
            // specifies explicit accountsToNotify. Unclear whether that's a good thing.
            reviewerInput.notify = NotifyHandling.NONE;
            ReviewerAddition result = reviewerAdder.prepare(revision.getNotes(), revision.getUser(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        output.error = ERROR_ADDING_REVIEWER;
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = updateFactory.create(revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = revision.getUser().getAccountId();
        boolean ccOrReviewer = false;
        if (input.labels != null && !input.labels.isEmpty()) {
            ccOrReviewer = input.labels.values().stream().filter(v -> v != 0).findFirst().isPresent();
        }
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (ReviewerAddition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            ReviewerAddition selfAddition = reviewerAdder.ccCurrentUser(revision.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        // Add WorkInProgressOp if requested.
        if (input.ready || input.workInProgress) {
            if (input.ready && input.workInProgress) {
                output.error = ERROR_WIP_READY_MUTUALLY_EXCLUSIVE;
                return Response.withStatusCode(SC_BAD_REQUEST, output);
            }
            WorkInProgressOp.checkPermissions(permissionBackend, revision.getUser(), revision.getChange());
            if (input.ready) {
                output.ready = true;
            }
            // Suppress notifications in WorkInProgressOp, we'll take care of
            // them in this endpoint.
            WorkInProgressOp.Input wipIn = new WorkInProgressOp.Input();
            wipIn.notify = NotifyHandling.NONE;
            bu.addOp(revision.getChange().getId(), workInProgressOpFactory.create(input.workInProgress, wipIn));
        }
        // Add the review op.
        bu.addOp(revision.getChange().getId(), new Op(projectState, revision.getPatchSet().getId(), input, notify.accounts()));
        bu.execute();
        // Re-read change to take into account results of the update.
        ChangeData cd = changeDataFactory.create(revision.getProject(), revision.getChange().getId());
        for (ReviewerAddition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults(cd);
        }
        // Sending from AddReviewersOp was suppressed so we can send a single batch email here.
        batchEmailReviewers(revision.getUser(), revision.getChange(), reviewerResults, notify);
    }
    return Response.ok(output);
}
#end_block

#method_before
private void batchEmailReviewers(CurrentUser user, Change change, List<ReviewerAddition> reviewerAdditions, NotifyResolver.Result notify, boolean readyForReview) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (ReviewerAddition addition : reviewerAdditions) {
        if (addition.state() == ReviewerState.REVIEWER) {
            to.addAll(addition.reviewers);
            toByEmail.addAll(addition.reviewersByEmail);
        } else if (addition.state() == ReviewerState.CC) {
            cc.addAll(addition.reviewers);
            ccByEmail.addAll(addition.reviewersByEmail);
        }
    }
    addReviewersEmail.emailReviewers(user.asIdentifiedUser(), change, to, cc, toByEmail, ccByEmail, notify);
}
#method_after
private void batchEmailReviewers(CurrentUser user, Change change, List<ReviewerAddition> reviewerAdditions, NotifyResolver.Result notify) {
    List<Account.Id> to = new ArrayList<>();
    List<Account.Id> cc = new ArrayList<>();
    List<Address> toByEmail = new ArrayList<>();
    List<Address> ccByEmail = new ArrayList<>();
    for (ReviewerAddition addition : reviewerAdditions) {
        if (addition.state() == ReviewerState.REVIEWER) {
            to.addAll(addition.reviewers);
            toByEmail.addAll(addition.reviewersByEmail);
        } else if (addition.state() == ReviewerState.CC) {
            cc.addAll(addition.reviewers);
            ccByEmail.addAll(addition.reviewersByEmail);
        }
    }
    addReviewersEmail.emailReviewers(user.asIdentifiedUser(), change, to, cc, toByEmail, ccByEmail, notify);
}
#end_block

#method_before
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, RevertInput input) throws OrmException, IOException, RestApiException, UpdateException, ConfigInvalidException {
    String message = Strings.emptyToNull(input.message);
    Change.Id changeIdToRevert = notes.getChangeId();
    PatchSet.Id patchSetId = notes.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(notes, patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = notes.getProjectName();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = serverIdent.get();
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = notes.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        NotifyResolver.Result notify = notifyResolver.resolve(firstNonNull(input.notify, NotifyHandling.NONE), input.notifyDetails);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, notes.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ins.setNotify(notify.handling());
        ins.setAccountsToNotify(notify.accounts());
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(notes);
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setReviewersAndCcs(reviewers, ccs);
        ins.setRevertOf(changeIdToRevert);
        try (BatchUpdate bu = updateFactory.create(project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(changeToRevert, ins, notify.handling(), notify.accounts()));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#method_after
private Change.Id revert(BatchUpdate.Factory updateFactory, ChangeNotes notes, CurrentUser user, RevertInput input) throws OrmException, IOException, RestApiException, UpdateException, ConfigInvalidException {
    String message = Strings.emptyToNull(input.message);
    Change.Id changeIdToRevert = notes.getChangeId();
    PatchSet.Id patchSetId = notes.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(notes, patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = notes.getProjectName();
    try (Repository git = repoManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk revWalk = new RevWalk(reader)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = serverIdent.get();
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = notes.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ObjectId id = oi.insert(revertCommitBuilder);
        RevCommit revertCommit = revWalk.parseCommit(id);
        NotifyResolver.Result notify = notifyResolver.resolve(firstNonNull(input.notify, NotifyHandling.ALL), input.notifyDetails);
        ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, notes.getChange().getDest().get()).setTopic(changeToRevert.getTopic());
        ins.setMessage("Uploaded patch set 1.");
        ins.setNotify(notify.handling());
        ins.setAccountsToNotify(notify.accounts());
        ReviewerSet reviewerSet = approvalsUtil.getReviewers(notes);
        Set<Account.Id> reviewers = new HashSet<>();
        reviewers.add(changeToRevert.getOwner());
        reviewers.addAll(reviewerSet.byState(ReviewerStateInternal.REVIEWER));
        reviewers.remove(user.getAccountId());
        Set<Account.Id> ccs = new HashSet<>(reviewerSet.byState(ReviewerStateInternal.CC));
        ccs.remove(user.getAccountId());
        ins.setReviewersAndCcs(reviewers, ccs);
        ins.setRevertOf(changeIdToRevert);
        try (BatchUpdate bu = updateFactory.create(project, user, now)) {
            bu.setRepository(git, revWalk, oi);
            bu.insertChange(ins);
            bu.addOp(changeId, new NotifyOp(changeToRevert, ins, notify.handling(), notify.accounts()));
            bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
            bu.execute();
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#end_block

#method_before
/*
   * AbandonedSender tests.
   */
@Test
public void abandonReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * AbandonedSender tests.
   */
@Test
public void abandonReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, OWNER);
    // Self-CC applies *after* need for sending notification is determined.
    // Since there are no recipients before including the user taking action,
    // there should no notification sent.
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, OWNER);
    // Self-CC applies *after* need for sending notification is determined.
    // Since there are no recipients before including the user taking action,
    // there should no notification sent.
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyNoneCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyNoneCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner, ALL);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner, ALL);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * AddReviewerSender tests.
   */
private void addReviewerToReviewableChange(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * AddReviewerSender tests.
   */
private void addReviewerToReviewableChange(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelf(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelf(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOther(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOther(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOtherCcingSelf(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOtherCcingSelf(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerByEmailToReviewableChange(Adder adder) throws Exception {
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerByEmailToReviewableChange(Adder adder) throws Exception {
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToWipChange(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToWipChange(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableWipChangeSingly() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(singly(), sc.changeId, sc.owner, reviewer.email);
    // TODO(dborowitz): In theory this should match the batch case, but we don't currently pass
    // enough info into AddReviewersEmail#emailReviewers to distinguish the reviewStarted case.
    // Complicating the emailReviewers arguments is not the answer; this needs to be rewritten.
    // Tolerate the difference for now.
    assertThat(sender).notSent();
}
#method_after
@Test
public void addReviewerToReviewableWipChangeSingly() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(singly(), sc.changeId, sc.owner, reviewer.email);
    // TODO(dborowitz): In theory this should match the batch case, but we don't currently pass
    // enough info into AddReviewersEmail#emailReviewers to distinguish the reviewStarted case.
    // Complicating the emailReviewers arguments is not the answer; this needs to be rewritten.
    // Tolerate the difference for now.
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToWipChangeNotifyAll(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToWipChangeNotifyAll(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeNotifyOwnerReviewers(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeNotifyOwnerReviewers(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyOwner(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyOwner(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyNone(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyNone(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addNonUserReviewerByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).to("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addNonUserReviewerByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).to("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addNonUserCcByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).cc("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addNonUserCcByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).cc("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * CommentSender tests.
   */
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * CommentSender tests.
   */
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER_REVIEWERS);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER_REVIEWERS);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    // TODO(logan): Why not send to owner?
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    // TODO(logan): Why not send to owner?
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, NONE);
    // TODO(logan): Why not send to owner?
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, NONE);
    // TODO(logan): Why not send to owner?
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByBot() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:bot");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByBot() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:bot");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByOwner() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByOwner() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByOwnerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED, ALL);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByOwnerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED, ALL);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByBot() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByBot() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableWipChangeByBot() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableWipChangeByBot() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableWipChangeByBotNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, ALL, "tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableWipChangeByBotNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, ALL, "tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableWipChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableWipChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void noCommentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).notSent();
}
#method_after
@Test
public void noCommentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void addReviewerOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().reviewer(other.email).setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(other).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void addReviewerOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().reviewer(other.email).setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(other).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * CreateChangeSender tests.
   */
@Test
public void createReviewableChange() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * CreateChangeSender tests.
   */
@Test
public void createReviewableChange() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChange() throws Exception {
    stagePreChange("refs/for/master%wip");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createWipChange() throws Exception {
    stagePreChange("refs/for/master%wip");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChangeWithWorkInProgressByDefaultForProject() throws Exception {
    setWorkInProgressByDefault(project, InheritableBoolean.TRUE);
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createWipChangeWithWorkInProgressByDefaultForProject() throws Exception {
    setWorkInProgressByDefault(project, InheritableBoolean.TRUE);
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChangeWithWorkInProgressByDefaultForUser() throws Exception {
    // Make sure owner user is created
    StagedChange sc = stageReviewableChange();
    // All was cleaned already
    assertThat(sender).notSent();
    // Toggle workInProgress flag for owner
    GeneralPreferencesInfo prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    prefs.workInProgressByDefault = true;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
    // Create another change without notification that should be wip
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).notSent();
    // Clean up workInProgressByDefault by owner
    prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    Truth.assertThat(prefs.workInProgressByDefault).isTrue();
    prefs.workInProgressByDefault = false;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
}
#method_after
@Test
public void createWipChangeWithWorkInProgressByDefaultForUser() throws Exception {
    // Make sure owner user is created
    StagedChange sc = stageReviewableChange();
    // All was cleaned already
    assertThat(sender).didNotSend();
    // Toggle workInProgress flag for owner
    GeneralPreferencesInfo prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    prefs.workInProgressByDefault = true;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
    // Create another change without notification that should be wip
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).didNotSend();
    // Clean up workInProgressByDefault by owner
    prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    Truth.assertThat(prefs.workInProgressByDefault).isTrue();
    prefs.workInProgressByDefault = false;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
}
#end_block

#method_before
@Test
public void createReviewableChangeWithNotifyOwnerReviewers() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER_REVIEWERS");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithNotifyOwnerReviewers() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER_REVIEWERS");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithNotifyOwner() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithNotifyOwner() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithNotifyNone() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithNotifyNone() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChangeWithNotifyAll() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master%wip,notify=ALL");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createWipChangeWithNotifyAll() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master%wip,notify=ALL");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithReviewersAndCcs() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=" + users.reviewer.username, "cc=" + users.ccer.username));
    FakeEmailSenderSubject subject = assertThat(sender).sent("newchange", spc).to(spc.reviewer, spc.watchingProjectOwner);
    subject.cc(spc.ccer);
    subject.bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithReviewersAndCcs() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=" + users.reviewer.username, "cc=" + users.ccer.username));
    FakeEmailSenderSubject subject = assertThat(sender).sent("newchange", spc).to(spc.reviewer, spc.watchingProjectOwner);
    subject.cc(spc.ccer);
    subject.bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithReviewersAndCcsByEmail() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=nobody1@example.com,cc=nobody2@example.com"));
    spc.supportReviewersByEmail = true;
    assertThat(sender).sent("newchange", spc).to("nobody1@example.com").to(spc.watchingProjectOwner).cc("nobody2@example.com").bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithReviewersAndCcsByEmail() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=nobody1@example.com,cc=nobody2@example.com"));
    spc.supportReviewersByEmail = true;
    assertThat(sender).sent("newchange", spc).to("nobody1@example.com").to(spc.watchingProjectOwner).cc("nobody2@example.com").bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * DeleteReviewerSender tests.
   */
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * DeleteReviewerSender tests.
   */
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(sc.reviewer, sc.ccer, extraReviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(sc.reviewer, sc.ccer, extraReviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerWithApprovalFromWipChangeNotifyOwner() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerWithApprovalFromWipChangeNotifyOwner() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerByEmailFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerByEmailFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private StagedChange stageWipChangeWithExtraReviewer() throws Exception {
    StagedChange sc = stageChangeWithExtraReviewer(this::stageWipChange);
    assertThat(sender).notSent();
    return sc;
}
#method_after
private StagedChange stageWipChangeWithExtraReviewer() throws Exception {
    StagedChange sc = stageChangeWithExtraReviewer(this::stageWipChange);
    assertThat(sender).didNotSend();
    return sc;
}
#end_block

#method_before
/*
   * DeleteVoteSender tests.
   */
@Test
public void deleteVoteFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * DeleteVoteSender tests.
   */
@Test
public void deleteVoteFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewersWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewersWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyNoneWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyNoneWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * MergedSender tests.
   */
@Test
public void mergeByOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner);
    assertThat(sender).sent("merged", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * MergedSender tests.
   */
@Test
public void mergeByOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner);
    assertThat(sender).sent("merged", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByReviewer() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByReviewer() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER_REVIEWERS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER_REVIEWERS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * ReplacePatchSetSender tests.
   */
@Test
public void newPatchSetByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * ReplacePatchSetSender tests.
   */
@Test
public void newPatchSetByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOwnerOnReviewableChangeToWip() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOwnerOnReviewableChangeToWip() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip,notify=ALL", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip,notify=ALL", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeToReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeToReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnReviewableChangeAddingReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnReviewableChangeAddingReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeAddingReviewer() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeAddingReviewer() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeAddingReviewerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%notify=ALL,r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeAddingReviewerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%notify=ALL,r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeSettingReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeSettingReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageEditByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageEditByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageEditByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageEditByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE, CC_ON_OWN_COMMENTS);
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE, CC_ON_OWN_COMMENTS);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnWipChangeSelfCc() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnWipChangeSelfCc() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner, ALL);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner, ALL);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * RestoredSender tests.
   */
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * RestoredSender tests.
   */
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableWipChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableWipChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreWipChange() throws Exception {
    StagedChange sc = stageAbandonedWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreWipChange() throws Exception {
    StagedChange sc = stageAbandonedWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * RevertedSender tests.
   */
@Test
public void revertChangeByOwner() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * RevertedSender tests.
   */
@Test
public void revertChangeByOwner() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void revertChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.owner, sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void revertChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.owner, sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void revertChangeByOther() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void revertChangeByOther() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void revertChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer, other).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(other, sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void revertChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer, other).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(other, sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * SetAssigneeSender tests.
   */
@Test
public void setAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * SetAssigneeSender tests.
   */
@Test
public void setAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(sc.owner).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(sc.owner).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(admin).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(admin).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void changeAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    sender.clear();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void changeAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    sender.clear();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * Start review and WIP tests.
   */
@Test
public void startReviewOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    startReview(sc);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * Start review and WIP tests.
   */
@Test
public void startReviewOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    startReview(sc);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void startReviewOnWipChangeCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    startReview(sc);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void startReviewOnWipChangeCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    startReview(sc);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    gApi.changes().id(sc.changeId).setWorkInProgress();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    gApi.changes().id(sc.changeId).setWorkInProgress();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * AbandonedSender tests.
   */
@Test
public void abandonReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * AbandonedSender tests.
   */
@Test
public void abandonReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOther() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwnersReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER_REVIEWERS);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, OWNER);
    // Self-CC applies *after* need for sending notification is determined.
    // Since there are no recipients before including the user taking action,
    // there should no notification sent.
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, OWNER);
    // Self-CC applies *after* need for sending notification is determined.
    // Since there are no recipients before including the user taking action,
    // there should no notification sent.
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    abandon(sc.changeId, other, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).sent("abandon", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableChangeNotifyNoneCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableChangeNotifyNoneCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    abandon(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void abandonWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner, ALL);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void abandonWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    abandon(sc.changeId, sc.owner, ALL);
    assertThat(sender).sent("abandon", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ABANDONED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * AddReviewerSender tests.
   */
private void addReviewerToReviewableChange(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * AddReviewerSender tests.
   */
private void addReviewerToReviewableChange(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelf(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelf(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOther(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOther(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOtherCcingSelf(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOtherCcingSelf(Adder adder) throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, other, reviewer.email, CC_ON_OWN_COMMENTS, null);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.owner, sc.reviewer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerByEmailToReviewableChange(Adder adder) throws Exception {
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerByEmailToReviewableChange(Adder adder) throws Exception {
    String email = "addedbyemail@example.com";
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, email);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(email).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToWipChange(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToWipChange(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void addReviewerToReviewableWipChangeSingly() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(singly(), sc.changeId, sc.owner, reviewer.email);
    // TODO(dborowitz): In theory this should match the batch case, but we don't currently pass
    // enough info into AddReviewersEmail#emailReviewers to distinguish the reviewStarted case.
    // Complicating the emailReviewers arguments is not the answer; this needs to be rewritten.
    // Tolerate the difference for now.
    assertThat(sender).notSent();
}
#method_after
@Test
public void addReviewerToReviewableWipChangeSingly() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(singly(), sc.changeId, sc.owner, reviewer.email);
    // TODO(dborowitz): In theory this should match the batch case, but we don't currently pass
    // enough info into AddReviewersEmail#emailReviewers to distinguish the reviewStarted case.
    // Complicating the emailReviewers arguments is not the answer; this needs to be rewritten.
    // Tolerate the difference for now.
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToWipChangeNotifyAll(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToWipChangeNotifyAll(Adder adder) throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, NotifyHandling.ALL);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeNotifyOwnerReviewers(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeNotifyOwnerReviewers(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, OWNER_REVIEWERS);
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(reviewer).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyOwner(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyOwner(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyNone(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).notSent();
}
#method_after
private void addReviewerToReviewableChangeByOwnerCcingSelfNotifyNone(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount reviewer = accountCreator.create("added", "added@example.com", "added");
    addReviewer(adder, sc.changeId, sc.owner, reviewer.email, CC_ON_OWN_COMMENTS, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addNonUserReviewerByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).to("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addNonUserReviewerByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).to("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
private void addNonUserCcByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).cc("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
private void addNonUserCcByEmail(Adder adder) throws Exception {
    StagedChange sc = stageReviewableChange();
    addReviewer(adder, sc.changeId, sc.owner, "nonexistent@example.com");
    assertThat(sender).sent("newchange", sc).cc("nonexistent@example.com").cc(sc.reviewer).cc(sc.ccerByEmail, sc.reviewerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * CommentSender tests.
   */
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * CommentSender tests.
   */
@Test
public void commentOnReviewableChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.reviewer, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOther() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOtherCcingSelf() throws Exception {
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    StagedChange sc = stageReviewableChange();
    review(other, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER_REVIEWERS);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER_REVIEWERS);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    // TODO(logan): Why not send to owner?
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, OWNER);
    // TODO(logan): Why not send to owner?
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    review(sc.owner, sc.changeId, ENABLED, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, NONE);
    // TODO(logan): Why not send to owner?
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    review(sc.owner, sc.changeId, ENABLED, NONE);
    // TODO(logan): Why not send to owner?
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableChangeByBot() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:bot");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableChangeByBot() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:bot");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByOwner() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByOwner() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, CC_ON_OWN_COMMENTS);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByOwnerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED, ALL);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByOwnerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    review(sc.owner, sc.changeId, ENABLED, ALL);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeByBot() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeByBot() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableWipChangeByBot() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableWipChangeByBot() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, null, "autogenerated:tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableWipChangeByBotNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, ALL, "tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableWipChangeByBotNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount bot = sc.testAccount("bot");
    review(bot, sc.changeId, ENABLED, ALL, "tag");
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnReviewableWipChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnReviewableWipChangeByOwner() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    review(sc.owner, sc.changeId, ENABLED);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void noCommentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).notSent();
}
#method_after
@Test
public void noCommentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentAndSetWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(true);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void commentOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void commentOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().message("ok").setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void addReviewerOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().reviewer(other.email).setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(other).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void addReviewerOnWipChangeAndStartReview() throws Exception {
    StagedChange sc = stageWipChange();
    ReviewInput in = ReviewInput.noScore().reviewer(other.email).setWorkInProgress(false);
    gApi.changes().id(sc.changeId).revision("current").review(in);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    // TODO(logan): Should CCs be included?
    assertThat(sender).sent("newchange", sc).to(other).cc(sc.reviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * CreateChangeSender tests.
   */
@Test
public void createReviewableChange() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * CreateChangeSender tests.
   */
@Test
public void createReviewableChange() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChange() throws Exception {
    stagePreChange("refs/for/master%wip");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createWipChange() throws Exception {
    stagePreChange("refs/for/master%wip");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChangeWithWorkInProgressByDefaultForProject() throws Exception {
    setWorkInProgressByDefault(project, InheritableBoolean.TRUE);
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createWipChangeWithWorkInProgressByDefaultForProject() throws Exception {
    setWorkInProgressByDefault(project, InheritableBoolean.TRUE);
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChangeWithWorkInProgressByDefaultForUser() throws Exception {
    // Make sure owner user is created
    StagedChange sc = stageReviewableChange();
    // All was cleaned already
    assertThat(sender).notSent();
    // Toggle workInProgress flag for owner
    GeneralPreferencesInfo prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    prefs.workInProgressByDefault = true;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
    // Create another change without notification that should be wip
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).notSent();
    // Clean up workInProgressByDefault by owner
    prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    Truth.assertThat(prefs.workInProgressByDefault).isTrue();
    prefs.workInProgressByDefault = false;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
}
#method_after
@Test
public void createWipChangeWithWorkInProgressByDefaultForUser() throws Exception {
    // Make sure owner user is created
    StagedChange sc = stageReviewableChange();
    // All was cleaned already
    assertThat(sender).didNotSend();
    // Toggle workInProgress flag for owner
    GeneralPreferencesInfo prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    prefs.workInProgressByDefault = true;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
    // Create another change without notification that should be wip
    StagedPreChange spc = stagePreChange("refs/for/master");
    Truth.assertThat(gApi.changes().id(spc.changeId).get().workInProgress).isTrue();
    assertThat(sender).didNotSend();
    // Clean up workInProgressByDefault by owner
    prefs = gApi.accounts().id(sc.owner.id.get()).getPreferences();
    Truth.assertThat(prefs.workInProgressByDefault).isTrue();
    prefs.workInProgressByDefault = false;
    gApi.accounts().id(sc.owner.id.get()).setPreferences(prefs);
}
#end_block

#method_before
@Test
public void createReviewableChangeWithNotifyOwnerReviewers() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER_REVIEWERS");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithNotifyOwnerReviewers() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER_REVIEWERS");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithNotifyOwner() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithNotifyOwner() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithNotifyNone() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithNotifyNone() throws Exception {
    stagePreChange("refs/for/master%notify=OWNER");
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createWipChangeWithNotifyAll() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master%wip,notify=ALL");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createWipChangeWithNotifyAll() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master%wip,notify=ALL");
    assertThat(sender).sent("newchange", spc).to(spc.watchingProjectOwner).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithReviewersAndCcs() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=" + users.reviewer.username, "cc=" + users.ccer.username));
    FakeEmailSenderSubject subject = assertThat(sender).sent("newchange", spc).to(spc.reviewer, spc.watchingProjectOwner);
    subject.cc(spc.ccer);
    subject.bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithReviewersAndCcs() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=" + users.reviewer.username, "cc=" + users.ccer.username));
    FakeEmailSenderSubject subject = assertThat(sender).sent("newchange", spc).to(spc.reviewer, spc.watchingProjectOwner);
    subject.cc(spc.ccer);
    subject.bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void createReviewableChangeWithReviewersAndCcsByEmail() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=nobody1@example.com,cc=nobody2@example.com"));
    spc.supportReviewersByEmail = true;
    assertThat(sender).sent("newchange", spc).to("nobody1@example.com").to(spc.watchingProjectOwner).cc("nobody2@example.com").bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void createReviewableChangeWithReviewersAndCcsByEmail() throws Exception {
    StagedPreChange spc = stagePreChange("refs/for/master", users -> ImmutableList.of("r=nobody1@example.com,cc=nobody2@example.com"));
    spc.supportReviewersByEmail = true;
    assertThat(sender).sent("newchange", spc).to("nobody1@example.com").to(spc.watchingProjectOwner).cc("nobody2@example.com").bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * DeleteReviewerSender tests.
   */
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * DeleteReviewerSender tests.
   */
@Test
public void deleteReviewerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).cc(admin, extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(sc.reviewer, sc.ccer, extraReviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteCcerFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraCcer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraCcer).cc(sc.reviewer, sc.ccer, extraReviewer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteReviewer", sc).to(sc.owner, extraReviewer).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableChangeByOwnerCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    setEmailStrategy(sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    removeReviewer(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    removeReviewer(sc, extraReviewer);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerFromWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer, NotifyHandling.ALL);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).cc(extraCcer, sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerWithApprovalFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    removeReviewer(sc, extraReviewer);
    assertThat(sender).sent("deleteReviewer", sc).to(extraReviewer).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerWithApprovalFromWipChangeNotifyOwner() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerWithApprovalFromWipChangeNotifyOwner() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    removeReviewer(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteReviewerByEmailFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteReviewerByEmailFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    gApi.changes().id(sc.changeId).reviewer(sc.reviewerByEmail).remove();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * DeleteVoteSender tests.
   */
@Test
public void deleteVoteFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * DeleteVoteSender tests.
   */
@Test
public void deleteVoteFromReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(admin, EmailStrategy.CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewersWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyOwnerReviewersWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER_REVIEWERS);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(admin.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.OWNER);
    assertThat(sender).sent("deleteVote", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableChangeNotifyNoneWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableChangeNotifyNoneWithSelfCc() throws Exception {
    StagedChange sc = stageReviewableChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer, NotifyHandling.NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void deleteVoteFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void deleteVoteFromWipChange() throws Exception {
    StagedChange sc = stageWipChangeWithExtraReviewer();
    recommend(sc, extraReviewer);
    requestScopeOperations.setApiUser(sc.owner.getId());
    deleteVote(sc, extraReviewer);
    assertThat(sender).sent("deleteVote", sc).cc(sc.reviewer, sc.ccer, extraReviewer, extraCcer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * MergedSender tests.
   */
@Test
public void mergeByOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner);
    assertThat(sender).sent("merged", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * MergedSender tests.
   */
@Test
public void mergeByOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner);
    assertThat(sender).sent("merged", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.owner, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByReviewer() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByReviewer() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByReviewerCcingSelf() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, sc.reviewer, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS, SUBMITTED_CHANGES).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER_REVIEWERS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER_REVIEWERS);
    assertThat(sender).sent("merged", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherCcingSelfNotifyOwner() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, OWNER);
    assertThat(sender).sent("merged", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    merge(sc.changeId, other, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void mergeByOtherCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void mergeByOtherCcingSelfNotifyNone() throws Exception {
    StagedChange sc = stageChangeReadyForMerge();
    setEmailStrategy(other, EmailStrategy.CC_ON_OWN_COMMENTS);
    merge(sc.changeId, other, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * ReplacePatchSetSender tests.
   */
@Test
public void newPatchSetByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * ReplacePatchSetSender tests.
   */
@Test
public void newPatchSetByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER_REVIEWERS", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).notTo(// TODO(logan): This shouldn't be sent *from* the owner.
    sc.owner).to(sc.reviewer).to(other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=OWNER", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other);
    // TODO(logan): This email shouldn't come from the owner, and that's why
    // no email is currently sent (owner isn't CCing self).
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%notify=NONE", other, EmailStrategy.CC_ON_OWN_COMMENTS);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetByOwnerOnReviewableChangeToWip() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetByOwnerOnReviewableChangeToWip() throws Exception {
    StagedChange sc = stageReviewableChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip,notify=ALL", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%wip,notify=ALL", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeToReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeToReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    pushTo(sc, "refs/for/master%wip", sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnReviewableChangeAddingReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnReviewableChangeAddingReviewer() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeAddingReviewer() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeAddingReviewer() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%r=" + newReviewer.username, sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeAddingReviewerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%notify=ALL,r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeAddingReviewerNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    TestAccount newReviewer = sc.testAccount("newReviewer");
    pushTo(sc, "refs/for/master%notify=ALL,r=" + newReviewer.username, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer, newReviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void newPatchSetOnWipChangeSettingReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void newPatchSetOnWipChangeSettingReady() throws Exception {
    StagedChange sc = stageWipChange();
    pushTo(sc, "refs/for/master%ready", sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageEditByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageEditByOwnerOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageEditByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageEditByOtherOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCc() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer, other).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwnerReviewers() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER_REVIEWERS, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner, sc.reviewer).cc(sc.ccer, other).cc(sc.reviewerByEmail, sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyOwner() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, OWNER, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE);
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE, CC_ON_OWN_COMMENTS);
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnReviewableChangeOwnerSelfCcNotifyNone() throws Exception {
    StagedChange sc = stageReviewableChange();
    editCommitMessage(sc, other, NONE, CC_ON_OWN_COMMENTS);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner);
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageByOtherOnWipChangeSelfCc() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageByOtherOnWipChangeSelfCc() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, other, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("newpatchset", sc).to(sc.owner).cc(other).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void editCommitMessageOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner, ALL);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void editCommitMessageOnWipChangeNotifyAll() throws Exception {
    StagedChange sc = stageWipChange();
    editCommitMessage(sc, sc.owner, ALL);
    assertThat(sender).sent("newpatchset", sc).to(sc.reviewer).cc(sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(NEW_PATCHSETS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * RestoredSender tests.
   */
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * RestoredSender tests.
   */
@Test
public void restoreReviewableChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableWipChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableWipChange() throws Exception {
    StagedChange sc = stageAbandonedReviewableWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreWipChange() throws Exception {
    StagedChange sc = stageAbandonedWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreWipChange() throws Exception {
    StagedChange sc = stageAbandonedWipChange();
    restore(sc.changeId, sc.owner);
    assertThat(sender).sent("restore", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, sc.owner, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void restoreReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void restoreReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageAbandonedReviewableChange();
    restore(sc.changeId, admin, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("restore", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * RevertedSender tests.
   */
@Test
public void revertChangeByOwner() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * RevertedSender tests.
   */
@Test
public void revertChangeByOwner() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void revertChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.owner, sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void revertChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, sc.owner, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.owner, sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void revertChangeByOther() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void revertChangeByOther() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void revertChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer, other).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(other, sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void revertChangeByOtherCcingSelf() throws Exception {
    StagedChange sc = stageChange();
    revert(sc, other, CC_ON_OWN_COMMENTS);
    // email for the newly created revert change
    assertThat(sender).sent("newchange", sc).to(sc.owner, sc.reviewer, sc.watchingProjectOwner, admin).cc(sc.ccer, other).bcc(NEW_CHANGES, NEW_PATCHSETS).noOneElse();
    // email for the change that is reverted
    assertThat(sender).sent("revert", sc).to(sc.owner).cc(other, sc.reviewer, sc.ccer, admin).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * SetAssigneeSender tests.
   */
@Test
public void setAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * SetAssigneeSender tests.
   */
@Test
public void setAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(sc.owner).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableChangeByOwnerCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(sc.owner).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableChangeByAdmin() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(admin).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableChangeByAdminCcingSelf() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, admin, sc.assignee, CC_ON_OWN_COMMENTS);
    assertThat(sender).sent("setassignee", sc).cc(admin).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void changeAssigneeOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    TestAccount other = accountCreator.create("other", "other@example.com", "other");
    assign(sc, sc.owner, other);
    sender.clear();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void changeAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    sender.clear();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void changeAssigneeToSelfOnReviewableChange() throws Exception {
    StagedChange sc = stageReviewableChange();
    assign(sc, sc.owner, sc.assignee);
    sender.clear();
    assign(sc, sc.owner, sc.owner);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnReviewableWipChange() throws Exception {
    StagedChange sc = stageReviewableWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setAssigneeOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setAssigneeOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    assign(sc, sc.owner, sc.assignee);
    assertThat(sender).sent("setassignee", sc).cc(sc.reviewerByEmail, // TODO(logan): This is probably not intended!
    sc.ccerByEmail).to(sc.assignee).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
/*
   * Start review and WIP tests.
   */
@Test
public void startReviewOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    startReview(sc);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
/*
   * Start review and WIP tests.
   */
@Test
public void startReviewOnWipChange() throws Exception {
    StagedChange sc = stageWipChange();
    startReview(sc);
    assertThat(sender).sent("comment", sc).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void startReviewOnWipChangeCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    startReview(sc);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).notSent();
}
#method_after
@Test
public void startReviewOnWipChangeCcingSelf() throws Exception {
    StagedChange sc = stageWipChange();
    setEmailStrategy(sc.owner, CC_ON_OWN_COMMENTS);
    startReview(sc);
    assertThat(sender).sent("comment", sc).to(sc.owner).cc(sc.reviewer, sc.ccer).cc(sc.reviewerByEmail, sc.ccerByEmail).bcc(sc.starrer).bcc(ALL_COMMENTS).noOneElse();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Test
public void setWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    gApi.changes().id(sc.changeId).setWorkInProgress();
    assertThat(sender).notSent();
}
#method_after
@Test
public void setWorkInProgress() throws Exception {
    StagedChange sc = stageReviewableChange();
    gApi.changes().id(sc.changeId).setWorkInProgress();
    assertThat(sender).didNotSend();
}
#end_block

#method_before
@Override
public Enumeration<String> getHeaderNames() {
    final Enumeration<String> wrappedHeaderNames = super.getHeaderNames();
    HashSet<String> headerNames = new HashSet<>();
    while (wrappedHeaderNames.hasMoreElements()) {
        String header = wrappedHeaderNames.nextElement();
        if (!authHeaders.contains(header.toUpperCase())) {
            headerNames.add(header);
        }
    }
    return Iterators.asEnumeration(headerNames.iterator());
}
#method_after
@Override
public Enumeration<String> getHeaderNames() {
    final Enumeration<String> wrappedHeaderNames = super.getHeaderNames();
    HashSet<String> headerNames = new HashSet<>();
    while (wrappedHeaderNames.hasMoreElements()) {
        String header = wrappedHeaderNames.nextElement();
        if (!authHeaders.contains(header.toUpperCase())) {
            headerNames.add(wrappedHeaderNames.nextElement());
        }
    }
    return Iterators.asEnumeration(headerNames.iterator());
}
#end_block

#method_before
@Override
protected Result doCheck() throws Exception {
    for (Project.NameKey repoNameKey : this.systemRepoNameKeys) {
        Repository repo = repositoryManager.openRepository(repoNameKey);
        ObjectId headObj = repo.resolve("refs/meta/config");
        repo.open(headObj).getType();
    }
    return Result.PASSED;
}
#method_after
@Override
protected Result doCheck() throws Exception {
    for (Project.NameKey repoNameKey : repositoryNameKeys) {
        try (Repository repo = repositoryManager.openRepository(repoNameKey)) {
            repo.open(repo.resolve("refs/meta/config")).getType();
        }
    }
    return Result.PASSED;
}
#end_block

#method_before
@Before
public void setupAllProjects() throws Exception {
    Guice.createInjector(new HealthCheckModule()).injectMembers(this);
    InMemoryRepositoryManager.Repo allProjectsRepo = inMemoryRepositoryManager.createRepository(allProjectsName);
    createCommit(allProjectsRepo, "refs/meta/config");
    InMemoryRepositoryManager.Repo allUsersRepo = inMemoryRepositoryManager.createRepository(allUsersName);
    createCommit(allUsersRepo, "refs/meta/config");
}
#method_after
@Before
public void setupAllProjects() throws Exception {
    Guice.createInjector(new HealthCheckModule()).injectMembers(this);
    InMemoryRepositoryManager.Repo allProjects = inMemoryRepositoryManager.createRepository(allProjectsName);
    createCommit(allProjects, "refs/meta/config");
    InMemoryRepositoryManager.Repo allUsers = inMemoryRepositoryManager.createRepository(allUsersName);
    createCommit(allUsers, "refs/meta/config");
}
#end_block

#method_before
@Test
public void shouldBeHealthyWhenJGitIsWorking() {
    JGitHealthCheck reviewDbCheck = new JGitHealthCheck(executor, DEFAULT_CONFIG, getWorkingRepositoryManager(), allProjectsName, allUsersName);
    assertThat(reviewDbCheck.run().result).isEqualTo(Result.PASSED);
}
#method_after
@Test
public void shouldBeHealthyWhenJGitIsWorking() {
    JGitHealthCheck reviewDbCheck = new JGitHealthCheck(executor, DEFAULT_CONFIG, getWorkingRepositoryManager());
    assertThat(reviewDbCheck.run().result).isEqualTo(Result.PASSED);
}
#end_block

#method_before
private GitRepositoryManager getFailingGitRepositoryManager(Project.NameKey... failingRepos) {
    return new GitRepositoryManager() {

        @Override
        public Repository openRepository(Project.NameKey name) throws RepositoryNotFoundException, IOException {
            if (Arrays.asList(failingRepos).contains(name)) {
                throw new RepositoryNotFoundException("Can't fine repository " + name);
            } else {
                return inMemoryRepositoryManager.openRepository(name);
            }
        }

        @Override
        public Repository createRepository(Project.NameKey name) throws RepositoryCaseMismatchException, RepositoryNotFoundException, IOException {
            if (Arrays.asList(failingRepos).contains(name)) {
                throw new IOException("Can't create repositories");
            } else {
                return inMemoryRepositoryManager.createRepository(name);
            }
        }

        @Override
        public SortedSet<Project.NameKey> list() {
            return Collections.emptySortedSet();
        }
    };
}
#method_after
private GitRepositoryManager getFailingGitRepositoryManager() {
    return new GitRepositoryManager() {

        @Override
        public Repository openRepository(Project.NameKey name) throws RepositoryNotFoundException, IOException {
            throw new RepositoryNotFoundException("Can't find repository " + name);
        }

        @Override
        public Repository createRepository(Project.NameKey name) throws RepositoryCaseMismatchException, RepositoryNotFoundException, IOException {
            throw new IOException("Can't create repositories");
        }

        @Override
        public SortedSet<Project.NameKey> list() {
            return Collections.emptySortedSet();
        }
    };
}
#end_block

#method_before
@Override
public Object apply(TopLevelResource resource) throws BadRequestException, PermissionBackendException {
    if (format == OutputFormat.TEXT) {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        display(buf);
        return BinaryResult.create(buf.toByteArray()).setContentType("text/plain").setCharacterEncoding(UTF_8);
    }
    return apply();
}
#method_after
@Override
public Object apply(TopLevelResource resource) throws BadRequestException, PermissionBackendException {
    if (format == OutputFormat.TEXT) {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        displayToStream(buf);
        return BinaryResult.create(buf.toByteArray()).setContentType("text/plain").setCharacterEncoding(UTF_8);
    }
    return apply();
}
#end_block

#method_before
private Optional<String> expressAsProjectsQuery() {
    return !all && state != com.google.gerrit.extensions.client.ProjectState.HIDDEN && Strings.isNullOrEmpty(matchPrefix) && Strings.isNullOrEmpty(matchRegex) && Strings.isNullOrEmpty(matchSubstring) && type == FilterType.ALL && (showBranch == null || showBranch.isEmpty()) && !showTree ? Optional.of(stateToQuery()) : Optional.empty();
}
#method_after
private Optional<String> expressAsProjectsQuery() {
    return !all && state != HIDDEN && isNullOrEmpty(matchPrefix) && isNullOrEmpty(matchRegex) && // TODO: see Issue 10446
    isNullOrEmpty(matchSubstring) && type == FilterType.ALL && showBranch.isEmpty() && !showTree ? Optional.of(stateToQuery()) : Optional.empty();
}
#end_block

#method_before
private String stateToQuery() {
    List<String> queries = new ArrayList<>();
    if (state == null) {
        queries.add("(state:active OR state:read-only)");
    } else {
        queries.add(String.format("(state:%s)", state.toQueryValue()));
    }
    return Joiner.on(" AND ").join(queries).toString();
}
#method_after
private String stateToQuery() {
    List<String> queries = new ArrayList<>();
    if (state == null) {
        queries.add("(state:active OR state:read-only)");
    } else {
        queries.add(String.format("(state:%s)", state.name()));
    }
    return Joiner.on(" AND ").join(queries).toString();
}
#end_block

#method_before
private SortedMap<String, ProjectInfo> applyAsQuery(String query) throws BadRequestException {
    try {
        return newProjectsStream(query).collect(ImmutableSortedMap.toImmutableSortedMap(Ordering.natural(), (p) -> {
            return p.name;
        }, (p) -> {
            if (showDescription) {
                return p;
            }
            p.description = null;
            return p;
        }));
    } catch (OrmException | MethodNotAllowedException e) {
        throw new BadRequestException("Internal error while processing the query request", e);
    }
}
#method_after
private SortedMap<String, ProjectInfo> applyAsQuery(String query) throws BadRequestException {
    try {
        return queryProjectsProvider.get().withQuery(query).withStart(start).withLimit(limit).apply().stream().collect(ImmutableSortedMap.toImmutableSortedMap(natural(), p -> p.name, p -> showDescription ? p : nullifyDescription(p)));
    } catch (OrmException | MethodNotAllowedException e) {
        logger.atWarning().withCause(e).log("Internal error while processing the query '{}' request", query);
        throw new BadRequestException("Internal error while processing the query request");
    }
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    Optional<String> projectsQuery = expressAsProjectsQuery();
    if (projectsQuery.isPresent()) {
        displayToOutputStream(projectsQuery.get(), stdout);
        return null;
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        Iterable<Project.NameKey> projectNames = filter(perm)::iterator;
        for (Project.NameKey projectName : projectNames) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
@Nullable
public SortedMap<String, ProjectInfo> display(@Nullable PrintWriter stdout) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    if (type == FilterType.PARENT_CANDIDATES) {
        // Historically, PARENT_CANDIDATES implied showDescription.
        showDescription = true;
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        Iterable<Project.NameKey> projectNames = filter(perm)::iterator;
        for (Project.NameKey projectName : projectNames) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            if (type != FilterType.PARENT_CANDIDATES) {
                List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
                info.webLinks = links.isEmpty() ? null : links;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    if (auditEventModule != null) {
        modules.add(auditEventModule);
    } else {
        modules.add(new AuditModule());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (!slave && VersionManager.getOnlineUpgrade(config) && // Schema upgrade is handled by OnlineNoteDbMigrator in this case.
    !migrateToNoteDb()) {
        modules.add(new OnlineUpgrader.Module());
    }
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    modules.add(new GerritInstanceNameModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(new DefaultUrlFormatter.Module());
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (slave) {
        modules.add(new PeriodicGroupIndexer.Module());
    } else {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    modules.addAll(testSysModules);
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    if (auditEventModule != null) {
        modules.add(auditEventModule);
    } else {
        modules.add(new AuditModule());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (VersionManager.getOnlineUpgrade(config) && // Schema upgrade is handled by OnlineNoteDbMigrator in this case.
    !migrateToNoteDb()) {
        modules.add(new OnlineUpgrader.Module());
    }
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    modules.add(new GerritInstanceNameModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(new DefaultUrlFormatter.Module());
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (slave) {
        modules.add(new PeriodicGroupIndexer.Module());
    } else {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    modules.addAll(testSysModules);
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#end_block

#method_before
@Override
public int run() throws Exception {
    if (stopOnly) {
        RuntimeShutdown.manualShutdown();
        return 0;
    }
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = getSitePath().resolve("logs").resolve("gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    try {
        start();
        RuntimeShutdown.add(() -> {
            log.info("caught shutdown, cleaning up");
            stop();
        });
        log.info("Gerrit Code Review" + myVersion() + " ready");
        if (runId != null) {
            try {
                Files.write(runFile, (runId + "\n").getBytes(UTF_8));
                runFile.toFile().setReadable(true, false);
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#method_after
@Override
public int run() throws Exception {
    if (stopOnly) {
        RuntimeShutdown.manualShutdown();
        return 0;
    }
    if (doInit) {
        try {
            new Init(getSitePath()).run();
        } catch (Exception e) {
            throw die("Init failed", e);
        }
    }
    mustHaveValidSite();
    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {

        @Override
        public void uncaughtException(Thread t, Throwable e) {
            log.error("Thread " + t.getName() + " threw exception", e);
        }
    });
    if (runId != null) {
        runFile = getSitePath().resolve("logs").resolve("gerrit.run");
    }
    if (httpd == null) {
        httpd = !slave;
    }
    if (!httpd && !sshd) {
        throw die("No services enabled, nothing to do");
    }
    try {
        start();
        RuntimeShutdown.add(() -> {
            log.info("caught shutdown, cleaning up");
            stop();
        });
        log.info("Gerrit Code Review " + myVersion() + " ready");
        if (runId != null) {
            try {
                Files.write(runFile, (runId + "\n").getBytes(UTF_8));
                runFile.toFile().setReadable(true, false);
            } catch (IOException err) {
                log.warn("Cannot write --run-id to " + runFile, err);
            }
        }
        if (serverStarted != null) {
            serverStarted.run();
        }
        if (inspector) {
            JythonShell shell = new JythonShell();
            shell.set("m", manager);
            shell.set("ds", dbInjector.getInstance(DataSourceProvider.class));
            shell.set("schk", dbInjector.getInstance(SchemaVersionCheck.class));
            shell.set("d", this);
            shell.run();
        } else {
            RuntimeShutdown.waitFor();
        }
        return 0;
    } catch (Throwable err) {
        log.error("Unable to start daemon", err);
        return 1;
    }
}
#end_block

#method_before
private String myVersion() {
    StringBuilder version = new StringBuilder();
    if (slave) {
        version.append(" [slave]");
    }
    if (headless) {
        version.append(" [headless]");
    }
    version.append(" ").append(getVersion());
    return version.toString();
}
#method_after
private String myVersion() {
    List<String> versionParts = new ArrayList<>();
    if (slave) {
        versionParts.add("[slave]");
    }
    if (headless) {
        versionParts.add("[headless]");
    }
    versionParts.add(getVersion());
    return Joiner.on(" ").join(versionParts);
}
#end_block

#method_before
public static LabelType withDefaultValues(String name) {
    checkName(name);
    List<LabelValue> values = new ArrayList<>(2);
    values.add(new LabelValue((short) 0, "Rejected"));
    values.add(new LabelValue((short) 1, "Approved"));
    return new LabelType(name, values);
}
#method_after
public static LabelType withDefaultValues(String name) {
    checkName(name);
    return withDefaultValuesDoNotCheckName(name);
}
#end_block

#method_before
public LabelValue getDefaultValue() {
    return defaultValue;
}
#method_after
public short getDefaultValue() {
    return defaultValue;
}
#end_block

#method_before
public void setDefaultValue(LabelValue defaultValue) {
    this.defaultValue = defaultValue;
}
#method_after
public void setDefaultValue(short defaultValue) {
    this.defaultValue = defaultValue;
}
#end_block

#method_before
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        int defaultValue = rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
        if (defaultValue <= getMaxValue(values) && defaultValue >= getMinValue(values)) {
            String text = getValueText(defaultValue, values);
            if (text != null) {
                label.setDefaultValue(new LabelValue((short) defaultValue, text));
            }
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, defaultValue, name)));
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, false));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#method_after
private void loadLabelSections(Config rc) throws IOException {
    Map<String, String> lowerNames = Maps.newHashMapWithExpectedSize(2);
    labelSections = Maps.newLinkedHashMap();
    for (String name : rc.getSubsections(LABEL)) {
        String lower = name.toLowerCase();
        if (lowerNames.containsKey(lower)) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Label \"%s\" conflicts with \"%s\"", name, lowerNames.get(lower))));
        }
        lowerNames.put(lower, name);
        List<LabelValue> values = Lists.newArrayList();
        for (String value : rc.getStringList(LABEL, name, KEY_VALUE)) {
            try {
                values.add(parseLabelValue(value));
            } catch (IllegalArgumentException notValue) {
                error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\": %s", KEY_VALUE, value, name, notValue.getMessage())));
            }
        }
        LabelType label;
        try {
            label = new LabelType(name, values);
        } catch (IllegalArgumentException badName) {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid label \"%s\"", name)));
            continue;
        }
        String abbr = rc.getString(LABEL, name, KEY_ABBREVIATION);
        if (abbr != null) {
            label.setAbbreviation(abbr);
        }
        String functionName = Objects.firstNonNull(rc.getString(LABEL, name, KEY_FUNCTION), "MaxWithBlock");
        if (LABEL_FUNCTIONS.contains(functionName)) {
            label.setFunctionName(functionName);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s for label \"%s\". Valid names are: %s", KEY_FUNCTION, name, Joiner.on(", ").join(LABEL_FUNCTIONS))));
            label.setFunctionName(null);
        }
        short dv = (short) rc.getInt(LABEL, name, KEY_DEFAULT_VALUE, 0);
        if (isInRange(dv, values)) {
            label.setDefaultValue(dv);
        } else {
            error(new ValidationError(PROJECT_CONFIG, String.format("Invalid %s \"%s\" for label \"%s\"", KEY_DEFAULT_VALUE, dv, name)));
        }
        label.setCopyMinScore(rc.getBoolean(LABEL, name, KEY_COPY_MIN_SCORE, false));
        label.setCopyMaxScore(rc.getBoolean(LABEL, name, KEY_COPY_MAX_SCORE, false));
        label.setCopyAllScoresOnTrivialRebase(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, false));
        label.setCopyAllScoresIfNoCodeChange(rc.getBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, false));
        label.setCanOverride(rc.getBoolean(LABEL, name, KEY_CAN_OVERRIDE, true));
        label.setRefPatterns(getStringListOrNull(rc, LABEL, name, KEY_Branch));
        labelSections.put(name, label);
    }
}
#end_block

#method_before
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        if (!LabelType.defaultAbbreviation(name).equals(label.getAbbreviation())) {
            rc.setString(LABEL, name, KEY_ABBREVIATION, label.getAbbreviation());
        } else {
            rc.unset(LABEL, name, KEY_ABBREVIATION);
        }
        if (label.getDefaultValue().getValue() != 0) {
            rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue().getValue());
        } else {
            rc.unset(LABEL, name, KEY_DEFAULT_VALUE);
        }
        if (label.isCopyMinScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MIN_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MIN_SCORE);
        }
        if (label.isCopyMaxScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MAX_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MAX_SCORE);
        }
        if (label.isCopyAllScoresOnTrivialRebase()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        }
        if (label.isCopyAllScoresIfNoCodeChange()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE);
        }
        if (!label.canOverride()) {
            rc.setBoolean(LABEL, name, KEY_CAN_OVERRIDE, false);
        } else {
            rc.unset(LABEL, name, KEY_CAN_OVERRIDE);
        }
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#method_after
private void saveLabelSections(Config rc) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(LABEL));
    if (!Lists.newArrayList(labelSections.keySet()).equals(existing)) {
        // Order of sections changed, remove and rewrite them all.
        for (String name : existing) {
            rc.unsetSection(LABEL, name);
        }
    }
    Set<String> toUnset = Sets.newHashSet(existing);
    for (Map.Entry<String, LabelType> e : labelSections.entrySet()) {
        String name = e.getKey();
        LabelType label = e.getValue();
        toUnset.remove(name);
        rc.setString(LABEL, name, KEY_FUNCTION, label.getFunctionName());
        if (!LabelType.defaultAbbreviation(name).equals(label.getAbbreviation())) {
            rc.setString(LABEL, name, KEY_ABBREVIATION, label.getAbbreviation());
        } else {
            rc.unset(LABEL, name, KEY_ABBREVIATION);
        }
        rc.setInt(LABEL, name, KEY_DEFAULT_VALUE, label.getDefaultValue());
        if (label.isCopyMinScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MIN_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MIN_SCORE);
        }
        if (label.isCopyMaxScore()) {
            rc.setBoolean(LABEL, name, KEY_COPY_MAX_SCORE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_MAX_SCORE);
        }
        if (label.isCopyAllScoresOnTrivialRebase()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_ON_TRIVIAL_REBASE);
        }
        if (label.isCopyAllScoresIfNoCodeChange()) {
            rc.setBoolean(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE, true);
        } else {
            rc.unset(LABEL, name, KEY_COPY_ALL_SCORES_IF_NO_CHANGE);
        }
        if (!label.canOverride()) {
            rc.setBoolean(LABEL, name, KEY_CAN_OVERRIDE, false);
        } else {
            rc.unset(LABEL, name, KEY_CAN_OVERRIDE);
        }
        List<String> values = Lists.newArrayListWithCapacity(label.getValues().size());
        for (LabelValue value : label.getValues()) {
            values.add(value.format());
        }
        rc.setStringList(LABEL, name, KEY_VALUE, values);
    }
    for (String name : toUnset) {
        rc.unsetSection(LABEL, name);
    }
}
#end_block

#method_before
@UiHandler("post")
void onPost(ClickEvent e) {
    in.message(getMessage());
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }
    });
    hide();
}
#method_after
@UiHandler("post")
void onPost(ClickEvent e) {
    postReview();
}
#end_block

#method_before
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    hide();
}
#method_after
@UiHandler("cancel")
void onCancel(ClickEvent e) {
    message.setText("");
    hide();
}
#end_block

#method_before
private void renderRadio(int row, List<Short> columns, LabelAndValues lv) {
    String id = lv.info.name();
    labelHelpColumn = 1 + columns.size();
    labelsTable.setText(row, 0, id);
    CellFormatter fmt = labelsTable.getCellFormatter();
    fmt.setStyleName(row, 0, style.label_name());
    fmt.setStyleName(row, labelHelpColumn, style.label_help());
    ApprovalInfo self = Gerrit.isSignedIn() ? lv.info.for_user(Gerrit.getUserAccount().getId().get()) : null;
    final LabelRadioGroup group = new LabelRadioGroup(row, id, lv.permitted.size());
    for (int i = 0; i < columns.size(); i++) {
        Short v = columns.get(i);
        if (lv.permitted.contains(v)) {
            String text = lv.info.value_text(LabelValue.formatValue(v));
            LabelRadioButton b = new LabelRadioButton(group, text, v);
            // set default label value
            if ((self != null && v == self.value()) || (self == null && v == 0)) {
                b.setValue(true);
                group.select(b);
                labelsTable.setText(row, labelHelpColumn, b.text);
            }
            group.buttons.add(b);
            labelsTable.setWidget(row, 1 + i, b);
        }
    }
    if (CODE_REVIEW.equalsIgnoreCase(id) && !group.buttons.isEmpty()) {
        lgtm = new Runnable() {

            @Override
            public void run() {
                group.selectMax();
            }
        };
    }
}
#method_after
private void renderRadio(int row, List<Short> columns, LabelAndValues lv) {
    String id = lv.info.name();
    Short dv = normalizeDefaultValue(lv.info.defaultValue(), lv.permitted);
    labelHelpColumn = 1 + columns.size();
    labelsTable.setText(row, 0, id);
    CellFormatter fmt = labelsTable.getCellFormatter();
    fmt.setStyleName(row, 0, style.label_name());
    fmt.setStyleName(row, labelHelpColumn, style.label_help());
    ApprovalInfo self = Gerrit.isSignedIn() ? lv.info.for_user(Gerrit.getUserAccount().getId().get()) : null;
    final LabelRadioGroup group = new LabelRadioGroup(row, id, lv.permitted.size());
    for (int i = 0; i < columns.size(); i++) {
        Short v = columns.get(i);
        if (lv.permitted.contains(v)) {
            String text = lv.info.value_text(LabelValue.formatValue(v));
            LabelRadioButton b = new LabelRadioButton(group, text, v);
            if ((self != null && v == self.value()) || (self == null && v.equals(dv))) {
                b.setValue(true);
                group.select(b);
                in.label(group.label, v);
                labelsTable.setText(row, labelHelpColumn, b.text);
            }
            group.buttons.add(b);
            labelsTable.setWidget(row, 1 + i, b);
        }
    }
    if (CODE_REVIEW.equalsIgnoreCase(id) && !group.buttons.isEmpty()) {
        lgtm = new Runnable() {

            @Override
            public void run() {
                group.selectMax();
            }
        };
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    showUsernameInReviewCategory = new CheckBox(Util.C.showUsernameInReviewCategory());
    showAbbreviatedUsernameInReviewCategory = new CheckBox(Util.C.showAbbreviatedUsernameInReviewCategory());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    changeScreen = new ListBox();
    changeScreen.addItem(Util.M.changeScreenServerDefault(getLabel(Gerrit.getConfig().getChangeScreen())), "");
    changeScreen.addItem(Util.C.changeScreenOldUi(), AccountGeneralPreferences.ChangeScreen.OLD_UI.name());
    changeScreen.addItem(Util.C.changeScreenNewUi(), AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    final Grid formGrid = new Grid(14, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showAbbreviatedUsernameInReviewCategory);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, Util.C.changeScreenLabel());
        formGrid.setWidget(row, fieldIdx, changeScreen);
        row++;
        formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
        formGrid.setWidget(row, fieldIdx, diffView);
    }
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(showUsernameInReviewCategory);
    e.listenTo(showAbbreviatedUsernameInReviewCategory);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(commentVisibilityStrategy);
    e.listenTo(changeScreen);
    e.listenTo(diffView);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    changeScreen = new ListBox();
    changeScreen.addItem(Util.M.changeScreenServerDefault(getLabel(Gerrit.getConfig().getChangeScreen())), "");
    changeScreen.addItem(Util.C.changeScreenOldUi(), AccountGeneralPreferences.ChangeScreen.OLD_UI.name());
    changeScreen.addItem(Util.C.changeScreenNewUi(), AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    final Grid formGrid = new Grid(13, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, Util.C.changeScreenLabel());
        formGrid.setWidget(row, fieldIdx, changeScreen);
        row++;
        formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
        formGrid.setWidget(row, fieldIdx, diffView);
    }
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(commentVisibilityStrategy);
    e.listenTo(changeScreen);
    e.listenTo(diffView);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    showUsernameInReviewCategory.setEnabled(on);
    showAbbreviatedUsernameInReviewCategory.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
    changeScreen.setEnabled(on);
    diffView.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
    changeScreen.setEnabled(on);
    diffView.setEnabled(on);
}
#end_block

#method_before
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    reversePatchSetOrder.setValue(p.reversePatchSetOrder());
    showUsernameInReviewCategory.setValue(p.showUsernameInReviewCategory());
    showAbbreviatedUsernameInReviewCategory.setValue(p.showAbbreviatedUsernameInReviewCategory());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT, p.commentVisibilityStrategy());
    setListBox(changeScreen, null, p.changeScreen());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#method_after
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    reversePatchSetOrder.setValue(p.reversePatchSetOrder());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(commentVisibilityStrategy, AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT, p.commentVisibilityStrategy());
    setListBox(changeScreen, null, p.changeScreen());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setShowUsernameInReviewCategory(showUsernameInReviewCategory.getValue());
    p.setShowAbbreviatedUsernameInReviewCategory(showAbbreviatedUsernameInReviewCategory.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, CommentVisibilityStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.setChangeScreen(getListBox(changeScreen, null, AccountGeneralPreferences.ChangeScreen.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").post(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            Dispatcher.changeScreen2 = false;
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, CommentVisibilityStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.setChangeScreen(getListBox(changeScreen, null, AccountGeneralPreferences.ChangeScreen.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").post(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            Dispatcher.changeScreen2 = false;
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
public static Preferences create(AccountGeneralPreferences in, List<TopMenuItem> myMenus) {
    Preferences p = createObject().cast();
    if (in == null) {
        in = AccountGeneralPreferences.createDefault();
    }
    p.changesPerPage(in.getMaximumPageSize());
    p.showSiteHeader(in.isShowSiteHeader());
    p.useFlashClipboard(in.isUseFlashClipboard());
    p.downloadScheme(in.getDownloadUrl());
    p.downloadCommand(in.getDownloadCommand());
    p.copySelfOnEmail(in.isCopySelfOnEmails());
    p.dateFormat(in.getDateFormat());
    p.timeFormat(in.getTimeFormat());
    p.reversePatchSetOrder(in.isReversePatchSetOrder());
    p.showUsernameInReviewCategory(in.isShowUsernameInReviewCategory());
    p.showAbbreviatedUsernameInReviewCategory(in.isShowAbbreviatedUsernameInReviewCategory());
    p.relativeDateInChangeTable(in.isRelativeDateInChangeTable());
    p.sizeBarInChangeTable(in.isSizeBarInChangeTable());
    p.legacycidInChangeTable(in.isLegacycidInChangeTable());
    p.commentVisibilityStrategy(in.getCommentVisibilityStrategy());
    p.diffView(in.getDiffView());
    p.changeScreen(in.getChangeScreen());
    p.setMyMenus(myMenus);
    return p;
}
#method_after
public static Preferences create(AccountGeneralPreferences in, List<TopMenuItem> myMenus) {
    Preferences p = createObject().cast();
    if (in == null) {
        in = AccountGeneralPreferences.createDefault();
    }
    p.changesPerPage(in.getMaximumPageSize());
    p.showSiteHeader(in.isShowSiteHeader());
    p.useFlashClipboard(in.isUseFlashClipboard());
    p.downloadScheme(in.getDownloadUrl());
    p.downloadCommand(in.getDownloadCommand());
    p.copySelfOnEmail(in.isCopySelfOnEmails());
    p.dateFormat(in.getDateFormat());
    p.timeFormat(in.getTimeFormat());
    p.reversePatchSetOrder(in.isReversePatchSetOrder());
    p.relativeDateInChangeTable(in.isRelativeDateInChangeTable());
    p.sizeBarInChangeTable(in.isSizeBarInChangeTable());
    p.legacycidInChangeTable(in.isLegacycidInChangeTable());
    p.commentVisibilityStrategy(in.getCommentVisibilityStrategy());
    p.reviewCategoryStrategy(in.getReviewCategoryStrategy());
    p.diffView(in.getDiffView());
    p.changeScreen(in.getChangeScreen());
    p.setMyMenus(myMenus);
    return p;
}
#end_block

#method_before
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    db.accounts().beginTransaction(accountId);
    try {
        Account a = db.accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            p.setDownloadUrl(i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.copySelfOnEmail != null) {
            p.setCopySelfOnEmails(i.copySelfOnEmail);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.reversePatchSetOrder != null) {
            p.setReversePatchSetOrder(i.reversePatchSetOrder);
        }
        if (i.showUsernameInReviewCategory != null) {
            p.setShowUsernameInReviewCategory(i.showUsernameInReviewCategory);
        }
        if (i.showAbbreviatedUsernameInReviewCategory != null) {
            p.setShowAbbreviatedUsernameInReviewCategory(i.showAbbreviatedUsernameInReviewCategory);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.commentVisibilityStrategy != null) {
            p.setCommentVisibilityStrategy(i.commentVisibilityStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.changeScreen != null) {
            p.setChangeScreen(i.changeScreen);
        }
        db.accounts().update(Collections.singleton(a));
        db.commit();
        storeMyMenus(versionedPrefs, i.my);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.rollback();
    }
}
#method_after
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    db.get().accounts().beginTransaction(accountId);
    try {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            p.setDownloadUrl(i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.copySelfOnEmail != null) {
            p.setCopySelfOnEmails(i.copySelfOnEmail);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.reversePatchSetOrder != null) {
            p.setReversePatchSetOrder(i.reversePatchSetOrder);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.commentVisibilityStrategy != null) {
            p.setCommentVisibilityStrategy(i.commentVisibilityStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.changeScreen != null) {
            p.setChangeScreen(i.changeScreen);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.get().rollback();
    }
}
#end_block

#method_before
@Override
public Object apply(ConfigResource rsrc, Input i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.copySelfOnEmail != null || i.dateFormat != null || i.timeFormat != null || i.reversePatchSetOrder != null || i.showUsernameInReviewCategory != null || i.showAbbreviatedUsernameInReviewCategory != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.commentVisibilityStrategy != null || i.diffView != null || i.changeScreen != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        return new PreferenceInfo(null, p, md.getRepository());
    } finally {
        md.close();
    }
}
#method_after
@Override
public Object apply(ConfigResource rsrc, Input i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.copySelfOnEmail != null || i.dateFormat != null || i.timeFormat != null || i.reversePatchSetOrder != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.reviewCategoryStrategy != null || i.commentVisibilityStrategy != null || i.diffView != null || i.changeScreen != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        return new PreferenceInfo(null, p, md.getRepository());
    } finally {
        md.close();
    }
}
#end_block

#method_before
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    reversePatchSetOrder = false;
    showUserInReview = false;
    showUserAbbrevInReview = false;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    commentVisibilityStrategy = null;
    diffView = null;
    changeScreen = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
}
#method_after
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    copySelfOnEmail = false;
    reversePatchSetOrder = false;
    reviewCategoryStrategy = null;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    commentVisibilityStrategy = null;
    diffView = null;
    changeScreen = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable() && useNewFeatures) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (useNewFeatures) {
        if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
            table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        } else {
            table.setWidget(row, col, getSizeWidget(c));
            fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        }
        col++;
    }
    boolean displayName = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowUsernameInReviewCategory();
    boolean displayAbbrev = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowAbbreviatedUsernameInReviewCategory();
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        if (label.rejected() != null) {
            user = label.rejected().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                if (displayAbbrev) {
                    user = getAbbreviation(user, " ");
                }
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            if (displayName && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                if (displayAbbrev) {
                    user = getAbbreviation(user, " ");
                }
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            String vstr = String.valueOf(label._value());
            if (displayName && user != null) {
                if (displayAbbrev) {
                    user = getAbbreviation(user, " ");
                }
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            String vstr = "+" + label._value();
            if (displayName && user != null) {
                if (displayAbbrev) {
                    user = getAbbreviation(user, " ");
                }
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayName && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = DOM.getParent(fmt.getElement(row, 0));
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable() && useNewFeatures) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (useNewFeatures) {
        if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
            table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        } else {
            table.setWidget(row, col, getSizeWidget(c));
            fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
        }
        col++;
    }
    boolean displayInfo = Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isShowInfoInReviewCategory();
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE;
        if (label.rejected() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (displayInfo && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (displayInfo && user != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(user));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (displayInfo && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (displayInfo && user != null) {
                vstr = vstr + " " + user;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (!displayInfo && user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private String getAbbreviation(String name, String token) {
    StringBuilder abbrev = new StringBuilder();
    for (String t : name.split(token)) {
        abbrev.append(t.substring(0, 1).toUpperCase());
    }
    return abbrev.toString();
}
#method_after
private static String getAbbreviation(String name, String token) {
    StringBuilder abbrev = new StringBuilder();
    if (name != null) {
        for (String t : name.split(token)) {
            abbrev.append(t.substring(0, 1).toUpperCase());
        }
    }
    return abbrev.toString();
}
#end_block

#method_before
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "master", "commit after unsubscribe");
    pushChangeTo(subRepo, "master", "commit after unsubscribe");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#method_after
@Test
public void testSubscriptionUnsubscribe() throws Exception {
    TestRepository<?> superRepo = createProjectWithPush("super-project");
    TestRepository<?> subRepo = createProjectWithPush("subscribed-to-project");
    pushChangeTo(subRepo, "master");
    createSubscription(superRepo, "master", "subscribed-to-project", "master");
    pushChangeTo(subRepo, "master");
    ObjectId subHEADbeforeUnsubscribing = pushChangeTo(subRepo, "master");
    deleteAllSubscriptions(superRepo, "master");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
    pushChangeTo(superRepo, "refs/heads/master", "commit after unsubscribe", "");
    pushChangeTo(subRepo, "refs/heads/master", "commit after unsubscribe", "");
    expectToHaveSubmoduleState(superRepo, "master", "subscribed-to-project", subHEADbeforeUnsubscribing);
}
#end_block

#method_before
protected ObjectId pushChangeTo(TestRepository<?> repo, String branch) throws Exception {
    return pushChangeTo(repo, branch, "some change");
}
#method_after
protected ObjectId pushChangeTo(TestRepository<?> repo, String ref, String message, String topic) throws Exception {
    ObjectId ret = repo.branch("HEAD").commit().insertChangeId().message(message).add("a.txt", "a contents: " + contentCounter.incrementAndGet()).create();
    String refspec = "HEAD:" + ref;
    if (!topic.isEmpty()) {
        refspec += "/" + topic;
    }
    repo.git().push().setRemote("origin").setRefSpecs(new RefSpec(refspec)).call();
    return ret;
}
#end_block

#method_before
protected ObjectId pushChangeTo(TestRepository<?> repo, String branch) throws Exception {
    return pushChangeTo(repo, branch, "some change");
}
#method_after
protected ObjectId pushChangeTo(TestRepository<?> repo, String branch) throws Exception {
    return pushChangeTo(repo, "refs/heads/" + branch, "some change", "");
}
#end_block

#method_before
protected void createSubscription(TestRepository<?> repo, String branch, String subscribeToRepo, String subscribeToBranch) throws Exception {
    Config config = new Config();
    addSubmoduleSubscription(config, subscribeToRepo, subscribeToBranch);
    pushSubscriptionConfig(repo, branch, config);
}
#method_after
protected void createSubscription(TestRepository<?> repo, String branch, String subscribeToRepo, String subscribeToBranch) throws Exception {
    Config config = new Config();
    prepareSubscriptionConfigEntry(config, subscribeToRepo, subscribeToBranch);
    pushSubscriptionConfig(repo, branch, config);
}
#end_block

#method_before
// For historic reasons we will first go into the submitted state
private void submitAllChanges(ChangeSet cs, boolean force) throws OrmException, ResourceConflictException, IOException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        switch(cd.change().getStatus()) {
            case ABANDONED:
                throw new ResourceConflictException("Change " + cd.getId() + " was abandoned while processing this change set");
            case DRAFT:
                throw new ResourceConflictException("Cannot submit draft " + cd.getId());
            case NEW:
                RevisionResource rsrc = new RevisionResource(new ChangeResource(cd.changeControl(), null), cd.currentPatchSet());
                logDebug("Submitting change id {}", cd.change().getId());
                submit.submit(rsrc, caller, force);
                break;
            case MERGED:
            // we're racing here, but having it already merged is fine.
            case SUBMITTED:
        }
    }
}
#method_after
// For historic reasons we will first go into the submitted state
private void submitAllChanges(ChangeSet cs, IdentifiedUser caller, boolean force) throws OrmException, ResourceConflictException, IOException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        switch(cd.change().getStatus()) {
            case ABANDONED:
                throw new ResourceConflictException("Change " + cd.getId() + " was abandoned while processing this change set");
            case DRAFT:
                throw new ResourceConflictException("Cannot submit draft " + cd.getId());
            case NEW:
                RevisionResource rsrc = new RevisionResource(new ChangeResource(cd.changeControl(), null), cd.currentPatchSet());
                logDebug("Submitting change id {}", cd.change().getId());
                submit.submit(rsrc, caller, force);
                break;
            case MERGED:
            // we're racing here, but having it already merged is fine.
            case SUBMITTED:
        }
    }
}
#end_block

#method_before
public void merge(boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Submitting all calculated changes while " + "enforcing submit rules");
            submitAllChanges(cs, false);
            logDebug("Checking permissions");
            checkPermissions(cs);
        } else {
            logDebug("Submitting all calculated changes ignoring submit rules");
            submitAllChanges(cs, true);
        }
        try {
            integrateIntoHistory(cs);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge(ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Submitting all calculated changes while " + "enforcing submit rules");
            submitAllChanges(cs, caller, false);
            logDebug("Checking permissions");
            checkPermissions(cs);
        } else {
            logDebug("Submitting all calculated changes ignoring submit rules");
            submitAllChanges(cs, caller, true);
        }
        try {
            integrateIntoHistory(cs);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", changes);
    Map<Branch.NameKey, ListMultimap<SubmitType, Change>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = validateChangeList(queryProvider.get().submitted(branch));
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch));
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    if (submitType != SubmitType.CHERRY_PICK) {
                        // For cherry picking we have relaxed atomic guarantees
                        // as traditionally Gerrit kept going cherry picking if one
                        // failed. We want to keep it for now.
                        updateChangeStatus(submitting.get(submitType), branch, true);
                    }
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false);
                    updateSubmoduleSubscriptions(branch, submitting.get(submitType), getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(cs.branches());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, ListMultimap<SubmitType, Change>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = validateChangeList(internalChangeQuery.submitted(branch));
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch));
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    if (submitType != SubmitType.CHERRY_PICK) {
                        // For cherry picking we have relaxed atomic guarantees
                        // as traditionally Gerrit kept going cherry picking if one
                        // failed. We want to keep it for now.
                        updateChangeStatus(submitting.get(submitType), branch, true);
                    }
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false);
                    updateSubmoduleSubscriptions(subOp, branch, getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(subOp, cs.branches());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#end_block

#method_before
private void updateSubmoduleSubscriptions(Branch.NameKey destBranch, List<Change> submitted, CodeReviewCommit branchTip) {
    MergeTip mergeTip = mergeTips.get(destBranch);
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip.getCurrentTip())) {
        logDebug("Updating submodule subscriptions for {} changes", submitted.size());
        SubmoduleOp subOp = subOpFactory.create();
        try {
            subOp.updateSubmoduleSubscriptions(destBranch);
        } catch (SubmoduleException e) {
            logError("The gitLinks were not updated according to the subscriptions", e);
        }
    }
}
#method_after
private void updateSubmoduleSubscriptions(SubmoduleOp subOp, Branch.NameKey destBranch, CodeReviewCommit branchTip) {
    MergeTip mergeTip = mergeTips.get(destBranch);
    if (mergeTip != null && (branchTip == null || branchTip != mergeTip.getCurrentTip())) {
        logDebug("Updating submodule subscriptions for branch {}", destBranch);
        try {
            subOp.updateSubmoduleSubscriptions(db, destBranch);
        } catch (SubmoduleException e) {
            logError("The submodule subscriptions were not updated according" + "to the .gitmodules files", e);
        }
    }
}
#end_block

#method_before
private void updateSuperProjects(Set<Branch.NameKey> branches) {
    SubmoduleOp subOp = subOpFactory.create();
    try {
        subOp.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        if (log.isErrorEnabled()) {
            log.error("The gitLinks were not updated according to the subscriptions", e);
        }
    }
}
#method_after
private void updateSuperProjects(SubmoduleOp subOp, Set<Branch.NameKey> branches) {
    logDebug("Updating superprojects");
    try {
        subOp.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        logError("The gitlinks were not updated according to the " + "subscriptions", e);
    }
}
#end_block

#method_before
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : queryProvider.get().byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#method_after
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#end_block

#method_before
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    try {
        // Update superproject gitlinks if required.
        SubmoduleOp op = subOpFactory.create();
        op.updateSubmoduleSubscriptions(branches);
        op.updateSuperProjects(branches);
    } catch (SubmoduleException e) {
        if (log.isErrorEnabled()) {
            log.error("Can't complete git links check", e);
        }
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#method_after
void processCommands(final Collection<ReceiveCommand> commands, final MultiProgressMonitor progress) {
    newProgress = progress.beginSubTask("new", UNKNOWN);
    replaceProgress = progress.beginSubTask("updated", UNKNOWN);
    closeProgress = progress.beginSubTask("closed", UNKNOWN);
    commandProgress = progress.beginSubTask("refs", UNKNOWN);
    batch = repo.getRefDatabase().newBatchUpdate();
    batch.setRefLogIdent(rp.getRefLogIdent());
    batch.setRefLogMessage("push", true);
    parseCommands(commands);
    if (magicBranch != null && magicBranch.cmd.getResult() == NOT_ATTEMPTED) {
        selectNewAndReplacedChangesFromMagicBranch();
    }
    preparePatchSetsForReplace();
    if (!batch.getCommands().isEmpty()) {
        try {
            if (!batch.isAllowNonFastForwards() && magicBranch != null && magicBranch.edit) {
                batch.setAllowNonFastForwards(true);
            }
            batch.execute(rp.getRevWalk(), commandProgress);
        } catch (IOException err) {
            int cnt = 0;
            for (ReceiveCommand cmd : batch.getCommands()) {
                if (cmd.getResult() == NOT_ATTEMPTED) {
                    cmd.setResult(REJECTED_OTHER_REASON, "internal server error");
                    cnt++;
                }
            }
            log.error(String.format("Failed to store %d refs in %s", cnt, project.getName()), err);
        }
    }
    insertChangesAndPatchSets();
    newProgress.end();
    replaceProgress.end();
    if (!errors.isEmpty()) {
        for (Error error : errors.keySet()) {
            rp.sendMessage(buildError(error, errors.get(error)));
        }
        rp.sendMessage(String.format("User: %s", displayName(currentUser)));
        rp.sendMessage(COMMAND_REJECTION_MESSAGE_FOOTER);
    }
    Set<Branch.NameKey> branches = Sets.newHashSet();
    for (final ReceiveCommand c : commands) {
        if (c.getResult() == OK) {
            if (c.getType() == ReceiveCommand.Type.UPDATE) {
                // aka fast-forward
                tagCache.updateFastForward(project.getNameKey(), c.getRefName(), c.getOldId(), c.getNewId());
            }
            if (isHead(c) || isConfig(c)) {
                switch(c.getType()) {
                    case CREATE:
                    case UPDATE:
                    case UPDATE_NONFASTFORWARD:
                        autoCloseChanges(c);
                        branches.add(new Branch.NameKey(project.getNameKey(), c.getRefName()));
                        break;
                    case DELETE:
                        ResultSet<SubmoduleSubscription> submoduleSubscriptions = null;
                        Branch.NameKey projRef = new Branch.NameKey(project.getNameKey(), c.getRefName());
                        try {
                            submoduleSubscriptions = db.submoduleSubscriptions().bySuperProject(projRef);
                            db.submoduleSubscriptions().delete(submoduleSubscriptions);
                        } catch (OrmException e) {
                            log.error("Cannot delete submodule subscription(s) of branch " + projRef + ": " + submoduleSubscriptions, e);
                        }
                        break;
                }
            }
            if (isConfig(c)) {
                projectCache.evict(project);
                ProjectState ps = projectCache.get(project.getNameKey());
                // 
                repoManager.setProjectDescription(// 
                project.getNameKey(), ps.getProject().getDescription());
            }
            if (!MagicBranch.isMagicBranch(c.getRefName())) {
                // We only fire gitRefUpdated for direct refs updates.
                // Events for change refs are fired when they are created.
                // 
                gitRefUpdated.fire(project.getNameKey(), c);
                hooks.doRefUpdatedHook(new Branch.NameKey(project.getNameKey(), c.getRefName()), c.getOldId(), c.getNewId(), currentUser.getAccount());
            }
        }
    }
    // Update superproject gitlinks if required.
    SubmoduleOp op = subOpProvider.get();
    try {
        op.updateSubmoduleSubscriptions(db, branches);
        op.updateSuperProjects(db, branches);
    } catch (SubmoduleException e) {
        log.error("Can't update submodule subscriptions " + "or update the superprojects", e);
    }
    closeProgress.end();
    commandProgress.end();
    progress.end();
    reportMessages();
}
#end_block

#method_before
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#method_after
private void insertChangesAndPatchSets() {
    int replaceCount = 0;
    int okToInsert = 0;
    for (Map.Entry<Change.Id, ReplaceRequest> e : replaceByChange.entrySet()) {
        ReplaceRequest replace = e.getValue();
        if (magicBranch != null && replace.inputCommand == magicBranch.cmd) {
            replaceCount++;
            if (replace.cmd != null && replace.cmd.getResult() == OK) {
                okToInsert++;
            }
        } else if (replace.cmd != null && replace.cmd.getResult() == OK) {
            try {
                if (replace.insertPatchSet().checkedGet() != null) {
                    replace.inputCommand.setResult(OK);
                }
            } catch (IOException | RestApiException err) {
                reject(replace.inputCommand, "internal server error");
                log.error(String.format("Cannot add patch set to %d of %s", e.getKey().get(), project.getName()), err);
            }
        } else if (replace.inputCommand.getResult() == NOT_ATTEMPTED) {
            reject(replace.inputCommand, "internal server error");
            log.error(String.format("Replacement for project %s was not attempted", project.getName()));
        }
    }
    if (magicBranch == null || magicBranch.cmd.getResult() != NOT_ATTEMPTED) {
        // No need to continue.
        return;
    }
    List<String> lastCreateChangeErrors = Lists.newArrayList();
    for (CreateRequest create : newChanges) {
        if (create.cmd.getResult() == OK) {
            okToInsert++;
        } else {
            String createChangeResult = String.format("%s %s", create.cmd.getResult(), Strings.nullToEmpty(create.cmd.getMessage())).trim();
            lastCreateChangeErrors.add(createChangeResult);
            log.error(String.format("Command %s on %s:%s not completed: %s", create.cmd.getType(), project.getName(), create.cmd.getRefName(), createChangeResult));
        }
    }
    if (okToInsert != replaceCount + newChanges.size()) {
        // One or more new references failed to create. Assume the
        // system isn't working correctly anymore and abort.
        reject(magicBranch.cmd, "Unable to create changes: " + Joiner.on(' ').join(lastCreateChangeErrors));
        log.error(String.format("Only %d of %d new change refs created in %s; aborting", okToInsert, replaceCount + newChanges.size(), project.getName()));
        return;
    }
    try {
        List<CheckedFuture<?, RestApiException>> futures = Lists.newArrayList();
        for (ReplaceRequest replace : replaceByChange.values()) {
            if (replace.inputCommand == magicBranch.cmd) {
                futures.add(replace.insertPatchSet());
            }
        }
        for (CreateRequest create : newChanges) {
            futures.add(create.insertChange());
        }
        for (UpdateGroupsRequest update : updateGroups) {
            futures.add(update.updateGroups());
        }
        for (CheckedFuture<?, RestApiException> f : futures) {
            f.checkedGet();
        }
        magicBranch.cmd.setResult(OK);
    } catch (RestApiException err) {
        log.error("Can't insert change/patchset for " + project.getName() + ". " + err.getMessage(), err);
        String rejection = "internal server error";
        if (err.getCause() != null) {
            rejection += ": " + err.getCause().getMessage();
        }
        reject(magicBranch.cmd, rejection);
    } catch (IOException err) {
        log.error("Can't read commits for " + project.getName(), err);
        reject(magicBranch.cmd, "internal server error");
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    List<Change> changes;
    try {
        // Force submit even if submit rule evaluation fails.
        changes = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    try {
        mergeFactory.create(ChangeSet.create(changes), (IdentifiedUser) changeCtl.getCurrentUser()).merge(false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    for (Change c : changes) {
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, IOException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    List<Change> changes;
    try {
        // Force submit even if submit rule evaluation fails.
        changes = submit.submit(rsrc, currentUser, true);
    } catch (ResourceConflictException e) {
        throw new IOException(e);
    }
    try {
        mergeOpProvider.get().merge(ChangeSet.create(changes), (IdentifiedUser) changeCtl.getCurrentUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    for (Change c : changes) {
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case SUBMITTED:
                addMessage("Change " + c.getChangeId() + " submitted.");
                break;
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#end_block

#method_before
protected void updateSubmoduleSubscriptions(Branch.NameKey destBranch) throws SubmoduleException {
    if (urlProvider.get() == null) {
        logAndThrowSubmoduleException("Cannot establish canonical web url used to access gerrit." + " It should be provided in gerrit.config file.");
    }
    try (ReviewDb schema = schemaFactory.open()) {
        Repository repo = repoManager.openRepository(destBranch.getParentKey());
        ObjectId id = repo.resolve(destBranch.get());
        RevWalk rw = CodeReviewCommit.newRevWalk(repo);
        RevCommit commit = rw.parseCommit(id);
        Set<SubmoduleSubscription> oldSubscriptions = Sets.newHashSet(schema.submoduleSubscriptions().bySuperProject(destBranch));
        Set<SubmoduleSubscription> newSubscriptions;
        TreeWalk tw = TreeWalk.forPath(repo, GIT_MODULES, commit.getTree());
        if (tw != null && (FileMode.REGULAR_FILE.equals(tw.getRawMode(0)) || FileMode.EXECUTABLE_FILE.equals(tw.getRawMode(0)))) {
            BlobBasedConfig bbc = new BlobBasedConfig(null, repo, commit, GIT_MODULES);
            String thisServer = new URI(urlProvider.get()).getHost();
            newSubscriptions = subSecParserFactory.create(bbc, thisServer, destBranch).parseAllSections();
        } else {
            newSubscriptions = Collections.emptySet();
        }
        Set<SubmoduleSubscription> alreadySubscribeds = new HashSet<>();
        for (SubmoduleSubscription s : newSubscriptions) {
            if (oldSubscriptions.contains(s)) {
                alreadySubscribeds.add(s);
            }
        }
        oldSubscriptions.removeAll(newSubscriptions);
        newSubscriptions.removeAll(alreadySubscribeds);
        if (!oldSubscriptions.isEmpty()) {
            schema.submoduleSubscriptions().delete(oldSubscriptions);
        }
        if (!newSubscriptions.isEmpty()) {
            schema.submoduleSubscriptions().insert(newSubscriptions);
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Database problem at update of subscriptions table from " + GIT_MODULES + " file.", e);
    } catch (ConfigInvalidException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table: " + GIT_MODULES + " config file is invalid.", e);
    } catch (IOException e) {
        logAndThrowSubmoduleException("Problem at update of subscriptions table from " + GIT_MODULES + ".", e);
    } catch (URISyntaxException e) {
        logAndThrowSubmoduleException("Incorrect gerrit canonical web url provided in gerrit.config file.", e);
    }
}
#method_after
void updateSubmoduleSubscriptions(ReviewDb db, Set<Branch.NameKey> branches) throws SubmoduleException {
    for (Branch.NameKey branch : branches) {
        updateSubmoduleSubscriptions(db, branch);
    }
}
#end_block

#method_before
protected void updateSuperProjects(Set<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try (ReviewDb schema = schemaFactory.open()) {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Map<Branch.NameKey, Set<SubmoduleSubscription>> targets = Maps.newHashMap();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : schema.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                if (!targets.containsKey(sub.getSuperProject())) {
                    targets.put(sub.getSuperProject(), Sets.newHashSet(sub));
                } else {
                    targets.get(sub.getSuperProject()).add(sub);
                }
            }
        }
        updatedSubscribers.addAll(Sets.newHashSet(updatedBranches));
        // update subscribers
        for (Branch.NameKey dest : targets.keySet()) {
            int size = targets.get(dest).size();
            Map<String, Branch.NameKey> paths = new HashMap<>(size);
            for (final SubmoduleSubscription s : targets.get(dest)) {
                paths.put(s.getPath(), s.getSubmodule());
            }
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(dest, paths);
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest + " due to " + e.getMessage());
            } catch (Exception e) {
                log.error("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#method_after
protected void updateSuperProjects(ReviewDb db, Set<Branch.NameKey> updatedBranches) throws SubmoduleException {
    try {
        // These (repo/branch) will be updated later with all the given
        // individual submodule subscriptions
        Multimap<Branch.NameKey, SubmoduleSubscription> targets = HashMultimap.create();
        for (Branch.NameKey updatedBranch : updatedBranches) {
            for (SubmoduleSubscription sub : db.submoduleSubscriptions().bySubmodule(updatedBranch)) {
                targets.put(sub.getSuperProject(), sub);
            }
        }
        updatedSubscribers.addAll(updatedBranches);
        // Update subscribers.
        for (Branch.NameKey dest : targets.keySet()) {
            try {
                if (!updatedSubscribers.add(dest)) {
                    log.error("Possible circular subscription involving " + dest);
                } else {
                    updateGitlinks(db, dest, targets.get(dest));
                }
            } catch (SubmoduleException e) {
                log.warn("Cannot update gitlinks for " + dest, e);
            }
        }
    } catch (OrmException e) {
        logAndThrowSubmoduleException("Cannot read subscription records", e);
    }
}
#end_block

#method_before
private void updateGitlinks(final Branch.NameKey subscriber, final Map<String, Branch.NameKey> paths) throws SubmoduleException {
    PersonIdent author = null;
    Repository pdb = null;
    RevWalk recRw = null;
    final Map<String, ObjectId> modules = new HashMap<>();
    try {
        boolean sameAuthorForAll = true;
        for (final Map.Entry<String, Branch.NameKey> me : paths.entrySet()) {
            Repository subrepo = repoManager.openRepository(me.getValue().getParentKey());
            ObjectId updateTo = subrepo.resolve(me.getValue().get());
            modules.put(me.getKey(), updateTo);
            RevWalk rw = CodeReviewCommit.newRevWalk(subrepo);
            RevCommit c = rw.parseCommit(updateTo);
            if (c == null) {
                continue;
            }
            if (author == null) {
                author = c.getAuthorIdent();
            } else if (!author.equals(c.getAuthorIdent())) {
                sameAuthorForAll = false;
            }
        }
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        final ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (final Map.Entry<String, Branch.NameKey> me : paths.entrySet()) {
            ed.add(new PathEdit(me.getKey()) {

                @Override
                public void apply(DirCacheEntry ent) {
                    ent.setFileMode(FileMode.GITLINK);
                    ObjectId id = modules.get(me.getKey());
                    ent.setObjectId(id);
                }
            });
        }
        ed.finish();
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        final CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(getCommitMessage());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#method_after
private void updateGitlinks(ReviewDb db, Branch.NameKey subscriber, Collection<SubmoduleSubscription> updates) throws SubmoduleException {
    PersonIdent author = null;
    Repository pdb = null;
    RevWalk recRw = null;
    StringBuilder msgbuf = new StringBuilder("Updated git submodules\n\n");
    try {
        boolean sameAuthorForAll = true;
        pdb = repoManager.openRepository(subscriber.getParentKey());
        if (pdb.getRef(subscriber.get()) == null) {
            throw new SubmoduleException("The branch was probably deleted from the subscriber repository");
        }
        DirCache dc = readTree(pdb, pdb.getRef(subscriber.get()));
        DirCacheEditor ed = dc.editor();
        for (SubmoduleSubscription s : updates) {
            try (Repository subrepo = repoManager.openRepository(s.getSubmodule().getParentKey());
                RevWalk rw = CodeReviewCommit.newRevWalk(subrepo)) {
                Ref ref = subrepo.getRefDatabase().exactRef(s.getSubmodule().get());
                if (ref == null) {
                    ed.add(new DeletePath(s.getPath()));
                    continue;
                }
                final ObjectId updateTo = ref.getObjectId();
                RevCommit newCommit = rw.parseCommit(updateTo);
                if (author == null) {
                    author = newCommit.getAuthorIdent();
                } else if (!author.equals(newCommit.getAuthorIdent())) {
                    sameAuthorForAll = false;
                }
                DirCacheEntry dce = dc.getEntry(s.getPath());
                ObjectId oldId = null;
                if (dce != null) {
                    if (!dce.getFileMode().equals(FileMode.GITLINK)) {
                        log.error("Requested to update gitlink " + s.getPath() + " in " + s.getSubmodule().getParentKey().get() + " but entry " + "doesn't have gitlink file mode.");
                        continue;
                    }
                    oldId = dce.getObjectId();
                } else {
                    // This submodule did not exist before. We do not want to add
                    // the full submodule history to the commit message, so omit it.
                    oldId = updateTo;
                }
                ed.add(new PathEdit(s.getPath()) {

                    @Override
                    public void apply(DirCacheEntry ent) {
                        ent.setFileMode(FileMode.GITLINK);
                        ent.setObjectId(updateTo);
                    }
                });
                msgbuf.append("Project: " + s.getSubmodule().getParentKey().get());
                msgbuf.append(" " + s.getSubmodule().getShortName());
                msgbuf.append(" " + updateTo.getName());
                msgbuf.append("\n\n");
                try {
                    rw.markStart(newCommit);
                    if (oldId != null) {
                        rw.markUninteresting(rw.parseCommit(oldId));
                    }
                    for (RevCommit c : rw) {
                        msgbuf.append(c.getFullMessage() + "\n\n");
                    }
                } catch (IOException e) {
                    logAndThrowSubmoduleException("Could not perform a revwalk to " + "create superproject commit message", e);
                }
            }
        }
        ed.finish();
        if (!sameAuthorForAll || author == null) {
            author = myIdent;
        }
        ObjectInserter oi = pdb.newObjectInserter();
        ObjectId tree = dc.writeTree(oi);
        ObjectId currentCommitId = pdb.getRef(subscriber.get()).getObjectId();
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(tree);
        commit.setParentIds(new ObjectId[] { currentCommitId });
        commit.setAuthor(author);
        commit.setCommitter(myIdent);
        commit.setMessage(msgbuf.toString());
        oi.insert(commit);
        oi.flush();
        ObjectId commitId = oi.idFor(Constants.OBJ_COMMIT, commit.build());
        final RefUpdate rfu = pdb.updateRef(subscriber.get());
        rfu.setForceUpdate(false);
        rfu.setNewObjectId(commitId);
        rfu.setExpectedOldObjectId(currentCommitId);
        rfu.setRefLogMessage("Submit to " + subscriber.getParentKey().get(), true);
        switch(rfu.update()) {
            case NEW:
            case FAST_FORWARD:
                gitRefUpdated.fire(subscriber.getParentKey(), rfu);
                changeHooks.doRefUpdatedHook(subscriber, rfu, account);
                // sent to inform users about the updated branch
                break;
            default:
                throw new IOException(rfu.getResult().name());
        }
        recRw = new RevWalk(pdb);
        // Recursive call: update subscribers of the subscriber
        updateSuperProjects(db, Sets.newHashSet(subscriber));
    } catch (IOException e) {
        throw new SubmoduleException("Cannot update gitlinks for " + subscriber.get(), e);
    } finally {
        if (recRw != null) {
            recRw.close();
        }
        if (pdb != null) {
            pdb.close();
        }
    }
}
#end_block

#method_before
protected void createSubscription(TestRepository<?> repo, String branch, String subscribeToRepo, String subscribeToBranch) throws Exception {
    Config config = new Config();
    addSubmoduleSubscription(config, subscribeToRepo, subscribeToBranch);
    pushSubscriptionConfig(repo, branch, config);
}
#method_after
protected void createSubscription(TestRepository<?> repo, String branch, String subscribeToRepo, String subscribeToBranch) throws Exception {
    Config config = new Config();
    prepareSubscriptionConfigEntry(config, subscribeToRepo, subscribeToBranch);
    pushSubscriptionConfig(repo, branch, config);
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, ChangeSet.create(change), caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    ChangeSet submittedChanges = ChangeSet.create(change);
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, submittedChanges, caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        checkSubmitRule(cd, cd.currentPatchSet(), false);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs = null;
    try {
        cs = mergeSuperSet.completeChangeSet(db, ChangeSet.create(cd.change()));
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(cs.ids().size()));
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(submitProblems).setVisible(true).setEnabled(false);
    } else {
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        checkSubmitRule(cd, cd.currentPatchSet(), false);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, ChangeSet.create(cd.change()));
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#end_block

#method_before
@Test
public void evilRefName() throws Exception {
    setUpSimpleRefs();
    String evilRefName = "refs/evil/<script>window.close();</script>/&foo";
    assertTrue(Repository.isValidRefName(evilRefName));
    repo.branch(evilRefName).commit().create();
    String text = buildText("/repo/+refs/evil").getActualBodyString();
    assertEquals(id(evilRefName) + " refs/evil/&lt;script&gt;window.close();&lt;/script&gt;/&amp;foo\n", text);
}
#method_after
@Test
public void evilRefName() throws Exception {
    setUpSimpleRefs();
    String evilRefName = "refs/evil/<script>window.close();</script>/&foo";
    assertTrue(Repository.isValidRefName(evilRefName));
    repo.branch(evilRefName).commit().create();
    FakeHttpServletResponse res = buildText("/repo/+refs/evil");
    assertEquals(id(evilRefName) + " refs/evil/&lt;script&gt;window.close();&lt;/script&gt;/&amp;foo\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void getRefsTextAll() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs").getActualBodyString();
    assertEquals(id("HEAD") + " HEAD\n" + id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n" + id("refs/tags/atag") + " refs/tags/atag\n" + peeled("refs/tags/atag") + " refs/tags/atag^{}\n" + id("refs/tags/ctag") + " refs/tags/ctag\n", text);
}
#method_after
@Test
public void getRefsTextAll() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs");
    assertEquals(id("HEAD") + " HEAD\n" + id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n" + id("refs/tags/atag") + " refs/tags/atag\n" + peeled("refs/tags/atag") + " refs/tags/atag^{}\n" + id("refs/tags/ctag") + " refs/tags/ctag\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void getRefsTextAllTrailingSlash() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs/").getActualBodyString();
    assertEquals(id("HEAD") + " HEAD\n" + id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n" + id("refs/tags/atag") + " refs/tags/atag\n" + peeled("refs/tags/atag") + " refs/tags/atag^{}\n" + id("refs/tags/ctag") + " refs/tags/ctag\n", text);
}
#method_after
@Test
public void getRefsTextAllTrailingSlash() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs/");
    assertEquals(id("HEAD") + " HEAD\n" + id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n" + id("refs/tags/atag") + " refs/tags/atag\n" + peeled("refs/tags/atag") + " refs/tags/atag^{}\n" + id("refs/tags/ctag") + " refs/tags/ctag\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void getRefsHeadsText() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs/heads").getActualBodyString();
    assertEquals(id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n", text);
}
#method_after
@Test
public void getRefsHeadsText() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs/heads");
    assertEquals(id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void getRefsHeadsTextTrailingSlash() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs/heads/").getActualBodyString();
    assertEquals(id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n", text);
}
#method_after
@Test
public void getRefsHeadsTextTrailingSlash() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs/heads/");
    assertEquals(id("refs/heads/branch") + " refs/heads/branch\n" + id("refs/heads/master") + " refs/heads/master\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void noHeadText() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs/HEAD").getActualBodyString();
    // /+refs/foo means refs/foo(/*), so this is empty.
    assertEquals("", text);
}
#method_after
@Test
public void noHeadText() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs/HEAD");
    // /+refs/foo means refs/foo(/*), so this is empty.
    assertEquals("", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void singleHeadText() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs/heads/master").getActualBodyString();
    assertEquals(id("refs/heads/master") + " refs/heads/master\n", text);
}
#method_after
@Test
public void singleHeadText() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs/heads/master");
    assertEquals(id("refs/heads/master") + " refs/heads/master\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void singlePeeledTagText() throws Exception {
    setUpSimpleRefs();
    String text = buildText("/repo/+refs/tags/atag").getActualBodyString();
    assertEquals(id("refs/tags/atag") + " refs/tags/atag\n" + peeled("refs/tags/atag") + " refs/tags/atag^{}\n", text);
}
#method_after
@Test
public void singlePeeledTagText() throws Exception {
    setUpSimpleRefs();
    FakeHttpServletResponse res = buildText("/repo/+refs/tags/atag");
    assertEquals(id("refs/tags/atag") + " refs/tags/atag\n" + peeled("refs/tags/atag") + " refs/tags/atag^{}\n", res.getActualBodyString());
}
#end_block

#method_before
@Test
public void getRefsJsonAll() throws Exception {
    setUpSimpleRefs();
    Map<String, RefJsonData> result = serveRefJson("/repo/+refs");
    List<String> keys = ImmutableList.copyOf(result.keySet());
    assertEquals(ImmutableList.of("HEAD", "refs/heads/branch", "refs/heads/master", "refs/tags/atag", "refs/tags/ctag"), keys);
    RefJsonData head = result.get(keys.get(0));
    assertEquals(id("HEAD"), head.value);
    assertNull(head.peeled);
    assertEquals("refs/heads/master", head.target);
    RefJsonData branch = result.get(keys.get(1));
    assertEquals(id("refs/heads/branch"), branch.value);
    assertNull(branch.peeled);
    assertNull(branch.target);
    RefJsonData master = result.get(keys.get(2));
    assertEquals(id("refs/heads/master"), master.value);
    assertNull(master.peeled);
    assertNull(master.target);
    RefJsonData atag = result.get(keys.get(3));
    assertEquals(id("refs/tags/atag"), atag.value);
    assertEquals(peeled("refs/tags/atag"), atag.peeled);
    assertNull(atag.target);
    RefJsonData ctag = result.get(keys.get(4));
    assertEquals(id("refs/tags/ctag"), ctag.value);
    assertNull(ctag.peeled);
    assertNull(ctag.target);
}
#method_after
@Test
public void getRefsJsonAll() throws Exception {
    setUpSimpleRefs();
    Map<String, RefJsonData> result = buildRefJson("/repo/+refs");
    List<String> keys = ImmutableList.copyOf(result.keySet());
    assertEquals(ImmutableList.of("HEAD", "refs/heads/branch", "refs/heads/master", "refs/tags/atag", "refs/tags/ctag"), keys);
    RefJsonData head = result.get(keys.get(0));
    assertEquals(id("HEAD"), head.value);
    assertNull(head.peeled);
    assertEquals("refs/heads/master", head.target);
    RefJsonData branch = result.get(keys.get(1));
    assertEquals(id("refs/heads/branch"), branch.value);
    assertNull(branch.peeled);
    assertNull(branch.target);
    RefJsonData master = result.get(keys.get(2));
    assertEquals(id("refs/heads/master"), master.value);
    assertNull(master.peeled);
    assertNull(master.target);
    RefJsonData atag = result.get(keys.get(3));
    assertEquals(id("refs/tags/atag"), atag.value);
    assertEquals(peeled("refs/tags/atag"), atag.peeled);
    assertNull(atag.target);
    RefJsonData ctag = result.get(keys.get(4));
    assertEquals(id("refs/tags/ctag"), ctag.value);
    assertNull(ctag.peeled);
    assertNull(ctag.target);
}
#end_block

#method_before
@Test
public void getRefsHeadsJson() throws Exception {
    setUpSimpleRefs();
    Map<String, RefJsonData> result = serveRefJson("/repo/+refs/heads");
    List<String> keys = ImmutableList.copyOf(result.keySet());
    assertEquals(ImmutableList.of("branch", "master"), keys);
    RefJsonData branch = result.get(keys.get(0));
    assertEquals(id("refs/heads/branch"), branch.value);
    assertNull(branch.peeled);
    assertNull(branch.target);
    RefJsonData master = result.get(keys.get(1));
    assertEquals(id("refs/heads/master"), master.value);
    assertNull(master.peeled);
    assertNull(master.target);
}
#method_after
@Test
public void getRefsHeadsJson() throws Exception {
    setUpSimpleRefs();
    Map<String, RefJsonData> result = buildRefJson("/repo/+refs/heads");
    List<String> keys = ImmutableList.copyOf(result.keySet());
    assertEquals(ImmutableList.of("branch", "master"), keys);
    RefJsonData branch = result.get(keys.get(0));
    assertEquals(id("refs/heads/branch"), branch.value);
    assertNull(branch.peeled);
    assertNull(branch.target);
    RefJsonData master = result.get(keys.get(1));
    assertEquals(id("refs/heads/master"), master.value);
    assertNull(master.peeled);
    assertNull(master.target);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    DfsRepository r = new InMemoryRepository(new DfsRepositoryDescription("repo"));
    repo = new TestRepository<>(r);
    servlet = TestGitilesServlet.create(repo);
}
#method_after
@Before
public void setUp() throws Exception {
    repo = new TestRepository<DfsRepository>(new InMemoryRepository(new DfsRepositoryDescription("repo")));
    servlet = TestGitilesServlet.create(repo);
}
#end_block

#method_before
protected FakeHttpServletResponse build(String path) throws Exception {
    return build(path, null, 200);
}
#method_after
protected FakeHttpServletResponse build(String path) throws Exception {
    return buildResponse(path, null, SC_OK);
}
#end_block

#method_before
protected Map<String, ?> buildData(String path) throws Exception {
    // Render the page through Soy to ensure templates are valid, then return
    // the Soy data for introspection.
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setPathInfo(path);
    FakeHttpServletResponse res = build(path);
    servlet.service(req, res);
    return BaseServlet.getData(req);
}
#method_after
protected Map<String, ?> buildData(String path) throws Exception {
    // Render the page through Soy to ensure templates are valid, then return
    // the Soy data for introspection.
    FakeHttpServletRequest req = FakeHttpServletRequest.newRequest();
    req.setPathInfo(path);
    FakeHttpServletResponse res = new FakeHttpServletResponse();
    servlet.service(req, res);
    return BaseServlet.getData(req);
}
#end_block

#method_before
protected FakeHttpServletResponse buildText(String path) throws Exception {
    FakeHttpServletResponse res = build(path, "text", 200);
    assertEquals("text/plain", res.getHeader(HttpHeaders.CONTENT_TYPE));
    return res;
}
#method_after
protected FakeHttpServletResponse buildText(String path) throws Exception {
    FakeHttpServletResponse res = buildResponse(path, "format=text", SC_OK);
    assertEquals("text/plain", res.getHeader(HttpHeaders.CONTENT_TYPE));
    return res;
}
#end_block

#method_before
private String buildJsonRaw(String path) throws Exception {
    FakeHttpServletResponse res = build(path, "json", 200);
    assertEquals("application/json", res.getHeader(HttpHeaders.CONTENT_TYPE));
    String body = res.getActualBodyString();
    String magic = ")]}'\n";
    assertEquals(magic, body.substring(0, magic.length()));
    return body.substring(magic.length());
}
#method_after
private String buildJsonRaw(String path) throws Exception {
    FakeHttpServletResponse res = buildResponse(path, "format=json", SC_OK);
    assertEquals("application/json", res.getHeader(HttpHeaders.CONTENT_TYPE));
    String body = res.getActualBodyString();
    String magic = ")]}'\n";
    assertEquals(magic, body.substring(0, magic.length()));
    return body.substring(magic.length());
}
#end_block

#method_before
protected <T> T buildJson(String path, Class<T> classOfT) throws Exception {
    return new Gson().<T>fromJson(buildJsonRaw(path), classOfT);
}
#method_after
protected <T> T buildJson(String path, Class<T> classOfT) throws Exception {
    return new Gson().fromJson(buildJsonRaw(path), classOfT);
}
#end_block

#method_before
protected void assertNotFound(String path, String format) throws Exception {
    build(path, format, 404);
}
#method_after
protected void assertNotFound(String path, String queryString) throws Exception {
    buildResponse(path, queryString, SC_NOT_FOUND);
}
#end_block

#method_before
@Test
public void blobText() throws Exception {
    repo.branch("master").commit().add("foo", "contents").create();
    String text = buildText("/repo/+/master/foo", "100644");
    assertEquals("contents", decodeBase64(text));
}
#method_after
@Test
public void blobText() throws Exception {
    repo.branch("master").commit().add("foo", "contents").create();
    String text = buildBlob("/repo/+/master/foo", "100644");
    assertEquals("contents", text);
}
#end_block

#method_before
@Test
public void symlinkText() throws Exception {
    final RevBlob link = repo.blob("foo");
    repo.branch("master").commit().edit(new PathEdit("baz") {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.SYMLINK);
            ent.setObjectId(link);
        }
    }).create();
    String text = buildText("/repo/+/master/baz", "120000");
    assertEquals("foo", decodeBase64(text));
}
#method_after
@Test
public void symlinkText() throws Exception {
    final RevBlob link = repo.blob("foo");
    repo.branch("master").commit().edit(new PathEdit("baz") {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.SYMLINK);
            ent.setObjectId(link);
        }
    }).create();
    String text = buildBlob("/repo/+/master/baz", "120000");
    assertEquals("foo", text);
}
#end_block

#method_before
@Test
public void treeText() throws Exception {
    RevBlob blob = repo.blob("contents");
    RevTree tree = repo.tree(repo.file("foo/bar", blob));
    repo.branch("master").commit().setTopLevelTree(tree).create();
    String expected = "040000 tree " + repo.get(tree, "foo").name() + "\tfoo\n";
    assertEquals(expected, decodeBase64(buildText("/repo/+/master/", "040000")));
    expected = "100644 blob " + blob.name() + "\tbar\n";
    assertEquals(expected, decodeBase64(buildText("/repo/+/master/foo", "040000")));
    assertEquals(expected, decodeBase64(buildText("/repo/+/master/foo/", "040000")));
}
#method_after
@Test
public void treeText() throws Exception {
    RevBlob blob = repo.blob("contents");
    RevTree tree = repo.tree(repo.file("foo/bar", blob));
    repo.branch("master").commit().setTopLevelTree(tree).create();
    String expected = "040000 tree " + repo.get(tree, "foo").name() + "\tfoo\n";
    assertEquals(expected, buildBlob("/repo/+/master/", "040000"));
    expected = "100644 blob " + blob.name() + "\tbar\n";
    assertEquals(expected, buildBlob("/repo/+/master/foo", "040000"));
    assertEquals(expected, buildBlob("/repo/+/master/foo/", "040000"));
}
#end_block

#method_before
@Test
public void treeTextEscaped() throws Exception {
    RevBlob blob = repo.blob("contents");
    repo.branch("master").commit().add("foo\nbar\rbaz", blob).create();
    assertEquals("100644 blob " + blob.name() + "\t\"foo\\nbar\\rbaz\"\n", decodeBase64(buildText("/repo/+/master/", "040000")));
}
#method_after
@Test
public void treeTextEscaped() throws Exception {
    RevBlob blob = repo.blob("contents");
    repo.branch("master").commit().add("foo\nbar\rbaz", blob).create();
    assertEquals("100644 blob " + blob.name() + "\t\"foo\\nbar\\rbaz\"\n", buildBlob("/repo/+/master/", "040000"));
}
#end_block

#method_before
@Test
public void nonBlobText() throws Exception {
    String gitmodules = "[submodule \"gitiles\"]\n" + "  path = gitiles\n" + "  url = https://gerrit.googlesource.com/gitiles\n";
    final String gitilesSha = "2b2f34bba3c2be7e2506ce6b1f040949da350cf9";
    repo.branch("master").commit().add("foo/bar", "contents").add(".gitmodules", gitmodules).edit(new PathEdit("gitiles") {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(ObjectId.fromString(gitilesSha));
        }
    }).create();
    assertNotFound("/repo/+/master/nonexistent", "text");
    assertNotFound("/repo/+/master/gitiles", "text");
}
#method_after
@Test
public void nonBlobText() throws Exception {
    String gitmodules = "[submodule \"gitiles\"]\n" + "  path = gitiles\n" + "  url = https://gerrit.googlesource.com/gitiles\n";
    final String gitilesSha = "2b2f34bba3c2be7e2506ce6b1f040949da350cf9";
    repo.branch("master").commit().add("foo/bar", "contents").add(".gitmodules", gitmodules).edit(new PathEdit("gitiles") {

        @Override
        public void apply(DirCacheEntry ent) {
            ent.setFileMode(FileMode.GITLINK);
            ent.setObjectId(ObjectId.fromString(gitilesSha));
        }
    }).create();
    assertNotFound("/repo/+/master/nonexistent", "format=text");
    assertNotFound("/repo/+/master/gitiles", "format=text");
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    List<Change> changes = Lists.newArrayList(rsrc.getChange());
    try {
        mergeOpProvider.get().merge(db, new ChangeSet(changes), (IdentifiedUser) changeCtl.getCurrentUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    for (Change c : changes) {
        c = db.changes().get(c.getId());
        switch(c.getStatus()) {
            case MERGED:
                addMessage("Change " + c.getChangeId() + " merged.");
                break;
            case NEW:
                ChangeMessage msg = submit.getConflictMessage(rsrc);
                if (msg != null) {
                    addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                    break;
                }
            // $FALL-THROUGH$
            default:
                addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
        }
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try {
        mergeOpProvider.get().merge(db, rsrc.getChange(), (IdentifiedUser) changeCtl.getCurrentUser(), false);
    } catch (NoSuchChangeException e) {
        throw new OrmException(e);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
@Override
public String getETag(RevisionResource rsrc) {
    Hasher h = Hashing.md5().newHasher();
    CurrentUser user = rsrc.getControl().getCurrentUser();
    try {
        rsrc.getChangeResource().prepareETag(h, user);
        h.putBoolean(Submit.wholeTopicEnabled(config));
        ReviewDb db = dbProvider.get();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, new ChangeSet(rsrc.getChange()));
        ProjectControl ctl = rsrc.getControl().getProjectControl();
        for (Change c : cs.changes()) {
            new ChangeResource(ctl.controlFor(c)).prepareETag(h, user);
        }
    } catch (IOException | OrmException e) {
        throw new OrmRuntimeException(e);
    }
    return h.hash().toString();
}
#method_after
@Override
public String getETag(RevisionResource rsrc) {
    Hasher h = Hashing.md5().newHasher();
    CurrentUser user = rsrc.getControl().getCurrentUser();
    try {
        rsrc.getChangeResource().prepareETag(h, user);
        h.putBoolean(Submit.wholeTopicEnabled(config));
        ReviewDb db = dbProvider.get();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, rsrc.getChange());
        for (ChangeData cd : cs.changes()) {
            new ChangeResource(cd.changeControl()).prepareETag(h, user);
        }
    } catch (IOException | OrmException e) {
        throw new OrmRuntimeException(e);
    }
    return h.hash().toString();
}
#end_block

#method_before
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), new ChangeSet(resource.getChange()));
        if (cs.size() > 1) {
            return json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).format(cs.ids());
        } else {
            return Collections.emptyList();
        }
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#method_after
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), resource.getChange());
        if (cs.size() > 1) {
            return json.create(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT)).format(cs.ids());
        } else {
            return Collections.emptyList();
        }
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, new ChangeSet(change), caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        ReviewDb db = dbProvider.get();
        for (PatchSet.Id psId : cs.patchIds()) {
            ChangeControl changeControl = changeControlFactory.controlFor(psId.getParentKey(), identifiedUser);
            ChangeData c = changeDataFactory.create(db, changeControl);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CLICK_FAILURE_OTHER_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (NoSuchChangeException | OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (PatchSet.Id psId : cs.patchIds()) {
            ChangeControl changeControl = changeControlFactory.controlFor(psId.getParentKey(), identifiedUser);
            ChangeData c = changeDataFactory.create(db, changeControl);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CLICK_FAILURE_OTHER_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (NoSuchChangeException | OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, new ChangeSet(cd.change()));
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, cd.change());
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : (cs.size() > 1) ? labelWithParents : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(cs.size() > 1 ? labelWithParents : label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#end_block

#method_before
public Set<Change.Id> ids() {
    return changeIds;
}
#method_after
public ImmutableSet<Change.Id> ids() {
    ImmutableSet.Builder<Change.Id> ret = ImmutableSet.builder();
    for (ChangeData cd : changeData) {
        ret.add(cd.getId());
    }
    return ret.build();
}
#end_block

#method_before
public Set<PatchSet.Id> patchIds() {
    return patchsetIds;
}
#method_after
public Set<PatchSet.Id> patchIds() throws OrmException {
    Set<PatchSet.Id> ret = new HashSet<>();
    for (ChangeData cd : changeData) {
        ret.add(cd.change().currentPatchSetId());
    }
    return ret;
}
#end_block

#method_before
public Multimap<Project.NameKey, Branch.NameKey> branchesByProject() {
    return branchByProject;
}
#method_after
public SetMultimap<Project.NameKey, Branch.NameKey> branchesByProject() throws OrmException {
    SetMultimap<Project.NameKey, Branch.NameKey> ret = HashMultimap.create();
    for (ChangeData cd : changeData) {
        ret.put(cd.change().getProject(), cd.change().getDest());
    }
    return ret;
}
#end_block

#method_before
public Multimap<Project.NameKey, Change.Id> changesByProject() {
    return changeIdbyProject;
}
#method_after
public Multimap<Project.NameKey, Change.Id> changesByProject() throws OrmException {
    ListMultimap<Project.NameKey, Change.Id> ret = ArrayListMultimap.create();
    for (ChangeData cd : changeData) {
        ret.put(cd.change().getProject(), cd.getId());
    }
    return ret;
}
#end_block

#method_before
public Multimap<Branch.NameKey, Change.Id> changesByBranch() {
    return changeIdbyBranch;
}
#method_after
public Multimap<Branch.NameKey, Change.Id> changesByBranch() throws OrmException {
    ListMultimap<Branch.NameKey, Change.Id> ret = ArrayListMultimap.create();
    for (ChangeData cd : changeData) {
        ret.put(cd.change().getDest(), cd.getId());
    }
    return ret;
}
#end_block

#method_before
public Set<Change> changes() {
    return changes;
}
#method_after
public ImmutableCollection<ChangeData> changes() {
    return changeData;
}
#end_block

#method_before
public int size() {
    return ids().size();
}
#method_after
public int size() {
    return changeData.size();
}
#end_block

#method_before
public ChangeSet completeChangeSet(ReviewDb db, ChangeSet changes) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, changes);
    } else {
        return completeChangeSetWithoutTopic(db, changes);
    }
}
#method_after
public ChangeSet completeChangeSet(ReviewDb db, Change change) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeData cd = changeDataFactory.create(db, change.getId());
    if (Submit.wholeTopicEnabled(cfg)) {
        return completeChangeSetIncludingTopics(db, new ChangeSet(cd));
    } else {
        return completeChangeSetWithoutTopic(db, new ChangeSet(cd));
    }
}
#end_block

#method_before
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<Change> ret = new ArrayList<>();
    for (Project.NameKey project : changes.projects()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : changes.changesByProject().get(project)) {
                ChangeData cd = changeDataFactory.create(db, cId);
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId());
                }
                if (r.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd.change());
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                for (RevCommit c : rw) {
                    hashes.add(c.name());
                }
                if (!hashes.isEmpty()) {
                    // Merged changes are ok to exclude
                    Iterable<ChangeData> destChanges = queryProvider.get().byCommitsOnBranchNotMerged(cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        Change chg = chd.change();
                        ret.add(chg);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret);
}
#method_after
private ChangeSet completeChangeSetWithoutTopic(ReviewDb db, ChangeSet changes) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    List<ChangeData> ret = new ArrayList<>();
    Multimap<Project.NameKey, Change.Id> pc = changes.changesByProject();
    for (Project.NameKey project : pc.keySet()) {
        try (Repository repo = repoManager.openRepository(project);
            RevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
            for (Change.Id cId : pc.get(project)) {
                ChangeData cd = changeDataFactory.create(db, cId);
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    logErrorAndThrow("Failed to get submit type for " + cd.getId());
                }
                if (r.type == SubmitType.CHERRY_PICK) {
                    ret.add(cd);
                    continue;
                }
                // Get the underlying git commit object
                PatchSet ps = cd.currentPatchSet();
                String objIdStr = ps.getRevision().get();
                RevCommit commit = rw.parseCommit(ObjectId.fromString(objIdStr));
                // Collect unmerged ancestors
                Branch.NameKey destBranch = cd.change().getDest();
                repo.getRefDatabase().refresh();
                Ref ref = repo.getRefDatabase().getRef(destBranch.get());
                rw.reset();
                rw.sort(RevSort.TOPO);
                rw.markStart(commit);
                if (ref != null) {
                    RevCommit head = rw.parseCommit(ref.getObjectId());
                    rw.markUninteresting(head);
                }
                List<String> hashes = new ArrayList<>();
                for (RevCommit c : rw) {
                    hashes.add(c.name());
                }
                if (!hashes.isEmpty()) {
                    // Merged changes are ok to exclude
                    Iterable<ChangeData> destChanges = queryProvider.get().byCommitsOnBranchNotMerged(cd.change().getDest(), hashes);
                    for (ChangeData chd : destChanges) {
                        ret.add(chd);
                    }
                }
            }
        }
    }
    return new ChangeSet(ret);
}
#end_block

#method_before
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes);
    while (!done) {
        List<Change> chgs = new ArrayList<>();
        done = true;
        for (Change c : newCs.changes()) {
            chgs.add(c);
            String topic = c.getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                for (ChangeData addCd : queryProvider.get().byTopicOpen(topic)) {
                    chgs.add(addCd.change());
                }
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(chgs);
        newCs = completeChangeSetWithoutTopic(db, changes);
    }
    return newCs;
}
#method_after
private ChangeSet completeChangeSetIncludingTopics(ReviewDb db, ChangeSet changes) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    Set<String> topicsTraversed = new HashSet<>();
    boolean done = false;
    ChangeSet newCs = completeChangeSetWithoutTopic(db, changes);
    while (!done) {
        List<ChangeData> chgs = new ArrayList<>();
        done = true;
        for (ChangeData cd : newCs.changes()) {
            chgs.add(cd);
            String topic = cd.change().getTopic();
            if (!Strings.isNullOrEmpty(topic) && !topicsTraversed.contains(topic)) {
                chgs.addAll(queryProvider.get().byTopicOpen(topic));
                done = false;
                topicsTraversed.add(topic);
            }
        }
        changes = new ChangeSet(chgs);
        newCs = completeChangeSetWithoutTopic(db, changes);
    }
    return newCs;
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
private void locatePaths() {
    URL pluginClassesUrl = getClass().getProtectionDomain().getCodeSource().getLocation();
    Path basePath = Paths.get(pluginClassesUrl.getPath());
    int idx = 0;
    int buckOutIdx = 0;
    int pluginsIdx = 0;
    for (Path subPath : basePath) {
        if (subPath.getFileName().endsWith("buck-out")) {
            buckOutIdx = idx;
        }
        if (subPath.getFileName().endsWith("plugins")) {
            pluginsIdx = idx;
        }
        idx++;
    }
    Path buckOut = basePath.getRoot().resolve(basePath.subpath(0, buckOutIdx + 1));
    gen = buckOut.resolve("gen");
    pluginRoot = buckOut.getParent();
    standalone = pluginsIdx == 0;
    if (!standalone) {
        pluginSubPath = basePath.subpath(pluginsIdx, pluginsIdx + 2);
    }
}
#method_after
private void locatePaths() {
    URL pluginClassesUrl = getClass().getProtectionDomain().getCodeSource().getLocation();
    Path basePath = Paths.get(pluginClassesUrl.getPath()).getParent();
    int idx = 0;
    int buckOutIdx = 0;
    int pluginsIdx = 0;
    for (Path subPath : basePath) {
        if (subPath.endsWith("plugins")) {
            pluginsIdx = idx;
        }
        if (subPath.endsWith(BUCKOUT)) {
            buckOutIdx = idx;
        }
        idx++;
    }
    maven = buckOutIdx == 0;
    standalone = checkStandalone(basePath);
    if (maven) {
        pluginRoot = basePath.getParent();
    } else {
        pluginRoot = basePath.getRoot().resolve(basePath.subpath(0, buckOutIdx));
    }
    gen = pluginRoot.resolve(BUCKOUT).resolve("gen");
    if (standalone) {
        pluginSource = pluginRoot;
    } else {
        pluginSubPath = basePath.subpath(pluginsIdx, pluginsIdx + 2);
        pluginSource = pluginRoot.resolve(pluginSubPath);
    }
}
#end_block

#method_before
private void retrievePluginName() throws IOException {
    Path pluginSource;
    if (standalone) {
        pluginSource = pluginRoot;
    } else {
        pluginSource = pluginRoot.resolve(pluginSubPath);
    }
    Path buckFile = pluginSource.resolve("BUCK");
    byte[] bytes = Files.readAllBytes(buckFile);
    String buckContent = new String(bytes, StandardCharsets.UTF_8).replaceAll("\\s+", "");
    Matcher matcher = Pattern.compile("gerrit_plugin\\(name='(.*?)'").matcher(buckContent);
    if (matcher.find()) {
        pluginName = matcher.group(1);
    }
    if (pluginName == null || pluginName.isEmpty()) {
        if (standalone) {
            pluginName = pluginRoot.getFileName().toString();
        } else {
            pluginName = pluginSubPath.getFileName().toString();
        }
    }
}
#method_after
private void retrievePluginName() throws IOException {
    Path buckFile = pluginSource.resolve("BUCK");
    byte[] bytes = Files.readAllBytes(buckFile);
    String buckContent = new String(bytes, StandardCharsets.UTF_8).replaceAll("\\s+", "");
    Matcher matcher = Pattern.compile("gerrit_plugin\\(name='(.*?)'").matcher(buckContent);
    if (matcher.find()) {
        pluginName = matcher.group(1);
    }
    if (Strings.isNullOrEmpty(pluginName)) {
        if (standalone) {
            pluginName = pluginRoot.getFileName().toString();
        } else {
            pluginName = pluginSubPath.getFileName().toString();
        }
    }
}
#end_block

#method_before
private void buildPluginJar() throws IOException, InterruptedException {
    String buck = "buck";
    ProcessBuilder processBuilder;
    if (standalone) {
        processBuilder = new ProcessBuilder(buck, "build", "//:" + pluginName).directory(pluginRoot.toFile()).redirectErrorStream(true);
    } else {
        Properties properties = loadBuckProperties(gen);
        buck = MoreObjects.firstNonNull(properties.getProperty(BUCKLC), BUCKLC);
        processBuilder = new ProcessBuilder(buck, "build", pluginSubPath.toString()).directory(pluginRoot.toFile()).redirectErrorStream(true);
        if (properties.containsKey(PATH)) {
            processBuilder.environment().put(PATH, properties.getProperty(PATH));
        }
    }
    Path forceJar;
    if (standalone) {
        forceJar = pluginRoot.resolve(EMPTY);
    } else {
        forceJar = pluginRoot.resolve(pluginSubPath).resolve(EMPTY);
    }
    Files.createFile(forceJar);
    try {
        processBuilder.start().waitFor();
    } finally {
        Files.delete(forceJar);
        // otherwise jar not made next time if missing again:
        processBuilder.start().waitFor();
    }
}
#method_after
private void buildPluginJar() throws IOException, InterruptedException {
    Properties properties = loadBuckProperties();
    String buck = MoreObjects.firstNonNull(properties.getProperty(BUCKLC), BUCKLC);
    String target;
    if (standalone) {
        target = "//:" + pluginName;
    } else {
        target = pluginSubPath.toString();
    }
    ProcessBuilder processBuilder = new ProcessBuilder(buck, BUILD, target).directory(pluginRoot.toFile()).redirectErrorStream(true);
    Path forceJar = pluginSource.resolve(EMPTY);
    Files.createFile(forceJar);
    try {
        processBuilder.start().waitFor();
    } finally {
        Files.delete(forceJar);
        // otherwise jar not made next time if missing again:
        processBuilder.start().waitFor();
    }
}
#end_block

#method_before
private Properties loadBuckProperties(Path gen) throws IOException {
    Properties properties = new Properties();
    Path propertiesPath = gen.resolve("tools").resolve("buck.properties");
    try (InputStream in = Files.newInputStream(propertiesPath)) {
        properties.load(in);
    }
    return properties;
}
#method_after
private Properties loadBuckProperties() throws IOException {
    Properties properties = new Properties();
    Path propertiesPath = gen.resolve("tools").resolve("buck.properties");
    if (Files.exists(propertiesPath)) {
        try (InputStream in = Files.newInputStream(propertiesPath)) {
            properties.load(in);
        }
    }
    return properties;
}
#end_block

#method_before
private void createTestSite() throws IOException {
    SitePaths sitePath = new SitePaths(testSite);
    pluginsPath = Files.createDirectories(sitePath.plugins_dir);
    Files.createDirectories(sitePath.tmp_dir);
}
#method_after
private void createTestSite() throws IOException {
    SitePaths sitePath = new SitePaths(testSite);
    pluginsSitePath = Files.createDirectories(sitePath.plugins_dir);
    Files.createDirectories(sitePath.tmp_dir);
}
#end_block

#method_before
private void copyJarToTestSite() throws IOException {
    Path pluginOut;
    if (standalone) {
        pluginOut = gen;
    } else {
        pluginOut = gen.resolve(pluginSubPath);
    }
    Path jar = pluginOut.resolve(pluginName + ".jar");
    Path dest = pluginsPath.resolve(jar.getFileName());
    Files.copy(jar, dest, StandardCopyOption.REPLACE_EXISTING);
}
#method_after
private void copyJarToTestSite() throws IOException {
    Path pluginOut;
    if (standalone) {
        pluginOut = gen;
    } else {
        pluginOut = gen.resolve(pluginSubPath);
    }
    Path jar = pluginOut.resolve(pluginName + ".jar");
    Path dest = pluginsSitePath.resolve(jar.getFileName());
    Files.copy(jar, dest, StandardCopyOption.REPLACE_EXISTING);
}
#end_block

#method_before
private void assertChangeSetMergeable(ChangeData change, boolean expected) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException, NoSuchChangeException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(db, change.change(), user(admin));
    assertThat(submit.isPatchSetMergeable(cs)).isEqualTo(expected);
}
#method_after
private void assertChangeSetMergeable(ChangeData change, boolean expected) throws MissingObjectException, IncorrectObjectTypeException, IOException, OrmException {
    ChangeSet cs = mergeSuperSet.completeChangeSet(db, change.change(), user(admin));
    assertThat(submit.isPatchSetMergeable(cs)).isEqualTo(expected);
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
        Boolean csIsMergeable = isPatchSetMergeable(cs);
        if (csIsMergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!csIsMergeable) {
            return CLICK_FAILURE_OTHER_TOOLTIP;
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException | IOException | NoSuchChangeException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
        Boolean csIsMergeable = isPatchSetMergeable(cs);
        if (csIsMergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!csIsMergeable) {
            return CHANGES_NOT_MERGEABLE;
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
public Boolean isPatchSetMergeable(ChangeSet cs) throws OrmException, IOException, NoSuchChangeException {
    Map<ChangeData, Boolean> mergeabilityMap = new HashMap<>();
    for (ChangeData change : cs.changes()) {
        mergeabilityMap.put(change, false);
    }
    Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
    for (Branch.NameKey branch : cbb.keySet()) {
        Collection<ChangeData> targetBranch = cbb.get(branch);
        HashMap<Change.Id, RevCommit> commits = findCommits(targetBranch, branch.getParentKey());
        Set<ObjectId> allParents = Sets.newHashSetWithExpectedSize(cs.size());
        for (RevCommit commit : commits.values()) {
            for (RevCommit parent : commit.getParents()) {
                allParents.add(parent.getId());
            }
        }
        for (ChangeData change : targetBranch) {
            RevCommit commit = commits.get(change.getId());
            boolean isMergeCommit = commit.getParentCount() > 1;
            boolean isLastInChain = !allParents.contains(commit.getId());
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            change.setMergeable(null);
            Boolean mergeable = change.isMergeable();
            if (mergeable == null) {
                // Skip whole check, cannot determine if mergeable
                return null;
            }
            mergeabilityMap.put(change, mergeable);
            if (isLastInChain && isMergeCommit && mergeable) {
                for (ChangeData c : targetBranch) {
                    mergeabilityMap.put(c, true);
                }
                break;
            }
        }
    }
    return !mergeabilityMap.values().contains(Boolean.FALSE);
}
#method_after
public Boolean isPatchSetMergeable(ChangeSet cs) throws OrmException, IOException {
    Map<ChangeData, Boolean> mergeabilityMap = new HashMap<>();
    for (ChangeData change : cs.changes()) {
        mergeabilityMap.put(change, false);
    }
    Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
    for (Branch.NameKey branch : cbb.keySet()) {
        Collection<ChangeData> targetBranch = cbb.get(branch);
        HashMap<Change.Id, RevCommit> commits = findCommits(targetBranch, branch.getParentKey());
        Set<ObjectId> allParents = Sets.newHashSetWithExpectedSize(cs.size());
        for (RevCommit commit : commits.values()) {
            for (RevCommit parent : commit.getParents()) {
                allParents.add(parent.getId());
            }
        }
        for (ChangeData change : targetBranch) {
            RevCommit commit = commits.get(change.getId());
            boolean isMergeCommit = commit.getParentCount() > 1;
            boolean isLastInChain = !allParents.contains(commit.getId());
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            change.setMergeable(null);
            Boolean mergeable = change.isMergeable();
            if (mergeable == null) {
                // Skip whole check, cannot determine if mergeable
                return null;
            }
            mergeabilityMap.put(change, mergeable);
            if (isLastInChain && isMergeCommit && mergeable) {
                for (ChangeData c : targetBranch) {
                    mergeabilityMap.put(c, true);
                }
                break;
            }
        }
    }
    return !mergeabilityMap.values().contains(Boolean.FALSE);
}
#end_block

#method_before
private HashMap<Change.Id, RevCommit> findCommits(Collection<ChangeData> changes, Project.NameKey project) throws IOException, OrmException, NoSuchChangeException {
    HashMap<Change.Id, RevCommit> commits = new HashMap<>();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk walk = new RevWalk(repo)) {
        for (ChangeData change : changes) {
            String commitId;
            if (notesMigration.enabled()) {
                ChangeNotes notes = changeNotesFactory.createChecked(change.getId());
                commitId = notes.getCurrentPatchSet().getRevision().get();
            } else {
                PatchSet patchSet = dbProvider.get().patchSets().get(change.change().currentPatchSetId());
                commitId = patchSet.getRevision().get();
            }
            ObjectId objectId = ObjectId.fromString(commitId);
            RevCommit commit = walk.parseCommit(objectId);
            commits.put(change.getId(), commit);
        }
    }
    return commits;
}
#method_after
private HashMap<Change.Id, RevCommit> findCommits(Collection<ChangeData> changes, Project.NameKey project) throws IOException, OrmException {
    HashMap<Change.Id, RevCommit> commits = new HashMap<>();
    try (Repository repo = repoManager.openRepository(project);
        RevWalk walk = new RevWalk(repo)) {
        for (ChangeData change : changes) {
            RevCommit commit = walk.parseCommit(ObjectId.fromString(psUtil.current(dbProvider.get(), change.notes()).getRevision().get()));
            commits.put(change.getId(), commit);
        }
    }
    return commits;
}
#end_block

#method_before
private static void patch(String token, PatchSet.Id baseId, Patch.Key id, DisplaySide side, int line, String panelType) {
    String panel = panelType;
    if (panel == null) {
        int c = token.lastIndexOf(',');
        panel = 0 <= c ? token.substring(c + 1) : "";
    }
    if ("".equals(panel) || /* DEPRECATED URL */
    "cm".equals(panel)) {
        if (preferUnified() || UserAgent.isMobile()) {
            unified(token, baseId, id, side, line);
        } else {
            codemirror(token, baseId, id, side, line, false);
        }
    } else if ("sidebyside".equals(panel)) {
        codemirror(token, baseId, id, side, line, false);
    } else if ("unified".equals(panel)) {
        unified(token, baseId, id, side, line);
    } else if ("unified1".equals(panel)) {
        unified1(token, baseId, id);
    } else if ("edit".equals(panel)) {
        codemirror(token, null, id, side, line, true);
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void patch(String token, PatchSet.Id baseId, Patch.Key id, DisplaySide side, int line, String panelType) {
    String panel = panelType;
    if (panel == null) {
        int c = token.lastIndexOf(',');
        panel = 0 <= c ? token.substring(c + 1) : "";
    }
    if ("".equals(panel) || /* DEPRECATED URL */
    "cm".equals(panel)) {
        if (preferUnified() || (UserAgent.isPortrait() && UserAgent.isMobile())) {
            unified(token, baseId, id, side, line);
        } else {
            codemirror(token, baseId, id, side, line, false);
        }
    } else if ("sidebyside".equals(panel)) {
        codemirror(token, baseId, id, side, line, false);
    } else if ("unified".equals(panel)) {
        unified(token, baseId, id, side, line);
    } else if ("unified1".equals(panel)) {
        unified1(token, baseId, id);
    } else if ("edit".equals(panel)) {
        codemirror(token, null, id, side, line, true);
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
@Test
public void byLabel() throws Exception {
    accountManager.authenticate(AuthRequest.forUser("anotheruser"));
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null);
    ChangeInserter ins2 = newChange(repo, null, null, null, null);
    ChangeInserter ins3 = newChange(repo, null, null, null, null);
    ChangeInserter ins4 = newChange(repo, null, null, null, null);
    ChangeInserter ins5 = newChange(repo, null, null, null, null);
    Change noLabelChange = insert(ins);
    Change reviewPlus1Change = insert(ins2);
    Change reviewPlus2Change = insert(ins3);
    Change reviewMinus1Change = insert(ins4);
    Change reviewMinus2Change = insert(ins5);
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(new ReviewInput().label("Code-Review", 1));
    gApi.changes().id(reviewPlus2Change.getId().get()).current().review(new ReviewInput().label("Code-Review", 2));
    gApi.changes().id(reviewMinus1Change.getId().get()).current().review(new ReviewInput().label("Code-Review", -1));
    gApi.changes().id(reviewMinus2Change.getId().get()).current().review(new ReviewInput().label("Code-Review", -2));
    assertQuery("label:Code-Review=-2", reviewMinus2Change);
    assertQuery("label:Code-Review-2", reviewMinus2Change);
    assertQuery("label:Code-Review=-1", reviewMinus1Change);
    assertQuery("label:Code-Review-1", reviewMinus1Change);
    assertQuery("label:Code-Review=0", noLabelChange);
    assertQuery("label:Code-Review=+1", reviewPlus1Change);
    assertQuery("label:Code-Review=1", reviewPlus1Change);
    assertQuery("label:Code-Review+1", reviewPlus1Change);
    assertQuery("label:Code-Review=+2", reviewPlus2Change);
    assertQuery("label:Code-Review=2", reviewPlus2Change);
    assertQuery("label:Code-Review+2", reviewPlus2Change);
    assertQuery("label:Code-Review>-3", reviewMinus2Change, reviewMinus1Change, reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review>=-2", reviewMinus2Change, reviewMinus1Change, reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review>-2", reviewMinus1Change, reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review>=-1", reviewMinus1Change, reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review>-1", reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review>=0", reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review>0", reviewPlus2Change, reviewPlus1Change);
    assertQuery("label:Code-Review>=1", reviewPlus2Change, reviewPlus1Change);
    assertQuery("label:Code-Review>1", reviewPlus2Change);
    assertQuery("label:Code-Review>=2", reviewPlus2Change);
    assertQuery("label:Code-Review>2");
    assertQuery("label:Code-Review<=2", reviewMinus2Change, reviewMinus1Change, reviewPlus2Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review<2", reviewMinus2Change, reviewMinus1Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review<=1", reviewMinus2Change, reviewMinus1Change, reviewPlus1Change, noLabelChange);
    assertQuery("label:Code-Review<1", reviewMinus2Change, reviewMinus1Change, noLabelChange);
    assertQuery("label:Code-Review<=0", reviewMinus2Change, reviewMinus1Change, noLabelChange);
    assertQuery("label:Code-Review<0", reviewMinus2Change, reviewMinus1Change);
    assertQuery("label:Code-Review<=-1", reviewMinus2Change, reviewMinus1Change);
    assertQuery("label:Code-Review<-1", reviewMinus2Change);
    assertQuery("label:Code-Review<=-2", reviewMinus2Change);
    assertQuery("label:Code-Review<-2");
    assertQuery("label:Code-Review=+1,anotheruser");
    assertQuery("label:Code-Review=+1,user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,group=Administrators", reviewPlus1Change);
}
#method_after
@Test
public void byLabel() throws Exception {
    accountManager.authenticate(AuthRequest.forUser("anotheruser"));
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins = newChange(repo, null, null, null, null);
    ChangeInserter ins2 = newChange(repo, null, null, null, null);
    ChangeInserter ins3 = newChange(repo, null, null, null, null);
    ChangeInserter ins4 = newChange(repo, null, null, null, null);
    ChangeInserter ins5 = newChange(repo, null, null, null, null);
    Change reviewMinus2Change = insert(ins);
    gApi.changes().id(reviewMinus2Change.getId().get()).current().review(ReviewInput.reject());
    Change reviewMinus1Change = insert(ins2);
    gApi.changes().id(reviewMinus1Change.getId().get()).current().review(ReviewInput.dislike());
    Change noLabelChange = insert(ins3);
    Change reviewPlus1Change = insert(ins4);
    gApi.changes().id(reviewPlus1Change.getId().get()).current().review(ReviewInput.recommend());
    Change reviewPlus2Change = insert(ins5);
    gApi.changes().id(reviewPlus2Change.getId().get()).current().review(ReviewInput.approve());
    Map<Integer, Change> changes = new LinkedHashMap<>(5);
    changes.put(2, reviewPlus2Change);
    changes.put(1, reviewPlus1Change);
    changes.put(-1, reviewMinus1Change);
    changes.put(-2, reviewMinus2Change);
    changes.put(0, noLabelChange);
    assertQuery("label:Code-Review=-2", reviewMinus2Change);
    assertQuery("label:Code-Review-2", reviewMinus2Change);
    assertQuery("label:Code-Review=-1", reviewMinus1Change);
    assertQuery("label:Code-Review-1", reviewMinus1Change);
    assertQuery("label:Code-Review=0", noLabelChange);
    assertQuery("label:Code-Review=+1", reviewPlus1Change);
    assertQuery("label:Code-Review=1", reviewPlus1Change);
    assertQuery("label:Code-Review+1", reviewPlus1Change);
    assertQuery("label:Code-Review=+2", reviewPlus2Change);
    assertQuery("label:Code-Review=2", reviewPlus2Change);
    assertQuery("label:Code-Review+2", reviewPlus2Change);
    assertQuery("label:Code-Review>-3", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>=-2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review>-2", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>=-1", codeReviewInRange(changes, -1, 2));
    assertQuery("label:Code-Review>-1", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>=0", codeReviewInRange(changes, 0, 2));
    assertQuery("label:Code-Review>0", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>=1", codeReviewInRange(changes, 1, 2));
    assertQuery("label:Code-Review>1", reviewPlus2Change);
    assertQuery("label:Code-Review>=2", reviewPlus2Change);
    assertQuery("label:Code-Review>2");
    assertQuery("label:Code-Review<=2", codeReviewInRange(changes, -2, 2));
    assertQuery("label:Code-Review<2", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<=1", codeReviewInRange(changes, -2, 1));
    assertQuery("label:Code-Review<1", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<=0", codeReviewInRange(changes, -2, 0));
    assertQuery("label:Code-Review<0", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<=-1", codeReviewInRange(changes, -2, -1));
    assertQuery("label:Code-Review<-1", reviewMinus2Change);
    assertQuery("label:Code-Review<=-2", reviewMinus2Change);
    assertQuery("label:Code-Review<-2");
    assertQuery("label:Code-Review=+1,anotheruser");
    assertQuery("label:Code-Review=+1,user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,user=user", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,Administrators", reviewPlus1Change);
    assertQuery("label:Code-Review=+1,group=Administrators", reviewPlus1Change);
}
#end_block

#method_before
private Change.Id revert(ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(git)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            RevCommit revertCommit = revWalk.parseCommit(id);
            ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setValidatePolicy(CommitValidators.Policy.GERRIT).setTopic(changeToRevert.getTopic());
            ins.setMessage("Uploaded patch set 1.");
            Set<Account.Id> reviewers = new HashSet<>();
            reviewers.add(changeToRevert.getOwner());
            for (Map.Entry<ReviewerStateInternal, Collection<Account.Id>> entry : ctl.getNotes().getReviewers().asMap().entrySet()) {
                if (entry.getKey() == ReviewerStateInternal.REMOVED) {
                    continue;
                }
                for (Account.Id accountId : entry.getValue()) {
                    if (accountId != user.getAccountId()) {
                        reviewers.add(accountId);
                    }
                }
            }
            ins.setReviewers(reviewers);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
                bu.setRepository(git, revWalk, oi);
                bu.insertChange(ins);
                bu.addOp(changeId, new SendEmailOp(ins));
                bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
                bu.execute();
            }
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#method_after
private Change.Id revert(ChangeControl ctl, String message) throws OrmException, IOException, RestApiException, UpdateException {
    Change.Id changeIdToRevert = ctl.getChange().getId();
    PatchSet.Id patchSetId = ctl.getChange().currentPatchSetId();
    PatchSet patch = psUtil.get(db.get(), ctl.getNotes(), patchSetId);
    if (patch == null) {
        throw new ResourceNotFoundException(changeIdToRevert.toString());
    }
    Project.NameKey project = ctl.getProject().getNameKey();
    CurrentUser user = ctl.getUser();
    try (Repository git = repoManager.openRepository(project);
        RevWalk revWalk = new RevWalk(git)) {
        RevCommit commitToRevert = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        if (commitToRevert.getParentCount() == 0) {
            throw new ResourceConflictException("Cannot revert initial commit");
        }
        Timestamp now = TimeUtil.nowTs();
        PersonIdent committerIdent = new PersonIdent(serverIdent, now);
        PersonIdent authorIdent = user.asIdentifiedUser().newCommitterIdent(now, committerIdent.getTimeZone());
        RevCommit parentToCommitToRevert = commitToRevert.getParent(0);
        revWalk.parseHeaders(parentToCommitToRevert);
        CommitBuilder revertCommitBuilder = new CommitBuilder();
        revertCommitBuilder.addParentId(commitToRevert);
        revertCommitBuilder.setTreeId(parentToCommitToRevert.getTree());
        revertCommitBuilder.setAuthor(authorIdent);
        revertCommitBuilder.setCommitter(authorIdent);
        Change changeToRevert = ctl.getChange();
        if (message == null) {
            message = MessageFormat.format(ChangeMessages.get().revertChangeDefaultMessage, changeToRevert.getSubject(), patch.getRevision().get());
        }
        ObjectId computedChangeId = ChangeIdUtil.computeChangeId(parentToCommitToRevert.getTree(), commitToRevert, authorIdent, committerIdent, message);
        revertCommitBuilder.setMessage(ChangeIdUtil.insertId(message, computedChangeId, true));
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId id = oi.insert(revertCommitBuilder);
            oi.flush();
            RevCommit revertCommit = revWalk.parseCommit(id);
            ChangeInserter ins = changeInserterFactory.create(changeId, revertCommit, ctl.getChange().getDest().get()).setValidatePolicy(CommitValidators.Policy.GERRIT).setTopic(changeToRevert.getTopic());
            ins.setMessage("Uploaded patch set 1.");
            Set<Account.Id> reviewers = new HashSet<>();
            reviewers.add(changeToRevert.getOwner());
            reviewers.addAll(approvalsUtil.getReviewers(db.get(), ctl.getNotes()).all());
            reviewers.remove(user.getAccountId());
            ins.setReviewers(reviewers);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, user, now)) {
                bu.setRepository(git, revWalk, oi);
                bu.insertChange(ins);
                bu.addOp(changeId, new SendEmailOp(ins));
                bu.addOp(changeToRevert.getId(), new PostRevertedMessageOp(computedChangeId));
                bu.execute();
            }
        }
        return changeId;
    } catch (RepositoryNotFoundException e) {
        throw new ResourceNotFoundException(changeIdToRevert.toString(), e);
    }
}
#end_block

#method_before
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    List<ChangeData> changes = getChangesCorrespondingToId(changeId);
    if (changes.isEmpty()) {
        throw new NoSuchChangeException(changeId);
    }
    return create(db, project, changeId);
}
#method_after
public ChangeNotes createChecked(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException, NoSuchChangeException {
    Change change = unwrap(db).changes().get(changeId);
    if (change == null || !change.getProject().equals(project)) {
        throw new NoSuchChangeException(changeId);
    }
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public ChangeNotes createChecked(Change.Id changeId) throws OrmException, NoSuchChangeException {
    List<ChangeData> changes = getChangesCorrespondingToId(changeId);
    if (changes.isEmpty()) {
        throw new NoSuchChangeException(changeId);
    }
    if (changes.size() != 1) {
        log.error(String.format("Multiple changes found for %d", changeId.get()));
        throw new NoSuchChangeException(changeId);
    }
    return changes.get(0).notes();
}
#method_after
public ChangeNotes createChecked(Change.Id changeId) throws OrmException, NoSuchChangeException {
    InternalChangeQuery query = queryProvider.get().noFields();
    List<ChangeData> changes = query.byLegacyChangeId(changeId);
    if (changes.isEmpty()) {
        throw new NoSuchChangeException(changeId);
    }
    if (changes.size() != 1) {
        log.error(String.format("Multiple changes found for %d", changeId.get()));
        throw new NoSuchChangeException(changeId);
    }
    return changes.get(0).notes();
}
#end_block

#method_before
public ChangeNotes create(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    Change change = unwrap(db).changes().get(changeId);
    checkNotNull(change, "change %s not found in ReviewDb", changeId);
    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s, but actual" + " project is %s", project, changeId, change.getProject());
    // database
    return new ChangeNotes(args, project, change).load();
}
#method_after
public ChangeNotes create(ReviewDb db, Project.NameKey project, Change.Id changeId) throws OrmException {
    Change change = unwrap(db).changes().get(changeId);
    checkNotNull(change, "change %s not found in ReviewDb", changeId);
    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s, but actual" + " project is %s", project, changeId, change.getProject());
    // database
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public ChangeNotes createFromIndexedChange(Change change) {
    return new ChangeNotes(args, change.getProject(), change);
}
#method_after
public ChangeNotes createFromIndexedChange(Change change) {
    return new ChangeNotes(args, change);
}
#end_block

#method_before
public ChangeNotes createFromIdOnlyWhenNoteDbDisabled(ReviewDb db, Change.Id changeId) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call" + " createFromIdOnlyWhenNoteDbDisabled when NoteDb is enabled");
    Change change = unwrap(db).changes().get(changeId);
    checkNotNull(change, "change %s not found in ReviewDb", changeId);
    return new ChangeNotes(args, change.getProject(), change).load();
}
#method_after
public ChangeNotes createFromIdOnlyWhenNoteDbDisabled(ReviewDb db, Change.Id changeId) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call" + " createFromIdOnlyWhenNoteDbDisabled when NoteDb is enabled");
    Change change = unwrap(db).changes().get(changeId);
    checkNotNull(change, "change %s not found in ReviewDb", changeId);
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public ChangeNotes createWithAutoRebuildingDisabled(Change change, ChainedReceiveCommands cmds) throws OrmException {
    return new ChangeNotes(args, change.getProject(), change, false, cmds).load();
}
#method_after
public ChangeNotes createWithAutoRebuildingDisabled(Change change, RefCache refs) throws OrmException {
    return new ChangeNotes(args, change, false, refs).load();
}
#end_block

#method_before
// TODO(ekempin): Remove when database backend is deleted
private ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(Change change) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call" + " createFromChangeWhenNoteDbDisabled when NoteDb is enabled");
    return new ChangeNotes(args, change.getProject(), change).load();
}
#method_after
// TODO(ekempin): Remove when database backend is deleted
private ChangeNotes createFromChangeOnlyWhenNoteDbDisabled(Change change) throws OrmException {
    checkState(!args.migration.readChanges(), "do not call" + " createFromChangeWhenNoteDbDisabled when NoteDb is enabled");
    return new ChangeNotes(args, change).load();
}
#end_block

#method_before
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(unwrap(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    return new ChangeNotes(args, project, change).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#method_after
public CheckedFuture<ChangeNotes, OrmException> createAsync(final ListeningExecutorService executorService, final ReviewDb db, final Project.NameKey project, final Change.Id changeId) {
    return Futures.makeChecked(Futures.transformAsync(unwrap(db).changes().getAsync(changeId), new AsyncFunction<Change, ChangeNotes>() {

        @Override
        public ListenableFuture<ChangeNotes> apply(final Change change) {
            return executorService.submit(new Callable<ChangeNotes>() {

                @Override
                public ChangeNotes call() throws Exception {
                    checkArgument(change.getProject().equals(project), "passed project %s when creating ChangeNotes for %s," + " but actual project is %s", project, changeId, change.getProject());
                    // request scope for the rebuilder to open the db.
                    return new ChangeNotes(args, change, false, null).load();
                }
            });
        }
    }), new Function<Exception, OrmException>() {

        @Override
        public OrmException apply(Exception e) {
            if (e instanceof OrmException) {
                return (OrmException) e;
            }
            return new OrmException(e);
        }
    });
}
#end_block

#method_before
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    for (Change.Id id : ids) {
        changeNotes.add(create(db, project, id));
    }
    return changeNotes;
}
#method_after
private List<ChangeNotes> scanNoteDb(Repository repo, ReviewDb db, Project.NameKey project) throws OrmException, IOException {
    Set<Change.Id> ids = scan(repo);
    List<ChangeNotes> changeNotes = new ArrayList<>(ids.size());
    db = unwrap(db);
    for (Change.Id id : ids) {
        Change change = db.changes().get(id);
        if (change == null) {
            log.warn("skipping change {} found in project {} " + "but not in ReviewDb", id, project);
            continue;
        } else if (!change.getProject().equals(project)) {
            log.error("skipping change {} found in project {} " + "because ReviewDb change has project {}", id, project, change.getProject());
            continue;
        }
        log.debug("adding change {} found in project {}", id, project);
        changeNotes.add(new ChangeNotes(args, change).load());
    }
    return changeNotes;
}
#end_block

#method_before
public ImmutableMap<PatchSet.Id, PatchSet> getPatchSets() {
    return patchSets;
}
#method_after
public ImmutableMap<PatchSet.Id, PatchSet> getPatchSets() {
    return state.patchSets();
}
#end_block

#method_before
public ImmutableListMultimap<PatchSet.Id, PatchSetApproval> getApprovals() {
    return approvals;
}
#method_after
public ImmutableListMultimap<PatchSet.Id, PatchSetApproval> getApprovals() {
    return state.approvals();
}
#end_block

#method_before
public ImmutableSetMultimap<ReviewerStateInternal, Account.Id> getReviewers() {
    return reviewers;
}
#method_after
public ReviewerSet getReviewers() {
    return state.reviewers();
}
#end_block

#method_before
public ImmutableSet<String> getHashtags() {
    return ImmutableSortedSet.copyOf(hashtags);
}
#method_after
public ImmutableSet<String> getHashtags() {
    return ImmutableSortedSet.copyOf(state.hashtags());
}
#end_block

#method_before
public ImmutableList<Account.Id> getAllPastReviewers() {
    return allPastReviewers;
}
#method_after
public ImmutableList<Account.Id> getAllPastReviewers() {
    return state.allPastReviewers();
}
#end_block

#method_before
public ImmutableList<SubmitRecord> getSubmitRecords() {
    return submitRecords;
}
#method_after
public ImmutableList<SubmitRecord> getSubmitRecords() {
    return state.submitRecords();
}
#end_block

#method_before
public ImmutableList<ChangeMessage> getChangeMessages() {
    return allChangeMessages;
}
#method_after
public ImmutableList<ChangeMessage> getChangeMessages() {
    return state.allChangeMessages();
}
#end_block

#method_before
public ImmutableListMultimap<PatchSet.Id, ChangeMessage> getChangeMessagesByPatchSet() {
    return changeMessagesByPatchSet;
}
#method_after
public ImmutableListMultimap<PatchSet.Id, ChangeMessage> getChangeMessagesByPatchSet() {
    return state.changeMessagesByPatchSet();
}
#end_block

#method_before
public ImmutableListMultimap<RevId, PatchLineComment> getComments() {
    return comments;
}
#method_after
public ImmutableListMultimap<RevId, PatchLineComment> getComments() {
    return state.publishedComments();
}
#end_block

#method_before
public ImmutableListMultimap<RevId, PatchLineComment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, PatchLineComment> published = comments;
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, PatchLineComment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), new Predicate<Map.Entry<RevId, PatchLineComment>>() {

        @Override
        public boolean apply(Map.Entry<RevId, PatchLineComment> in) {
            for (PatchLineComment c : published.get(in.getKey())) {
                if (c.getKey().equals(in.getValue().getKey())) {
                    return false;
                }
            }
            return true;
        }
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#method_after
public ImmutableListMultimap<RevId, PatchLineComment> getDraftComments(Account.Id author) throws OrmException {
    loadDraftComments(author);
    final Multimap<RevId, PatchLineComment> published = state.publishedComments();
    // Filter out any draft comments that also exist in the published map, in
    // case the update to All-Users to delete them during the publish operation
    // failed.
    Multimap<RevId, PatchLineComment> filtered = Multimaps.filterEntries(draftCommentNotes.getComments(), new Predicate<Map.Entry<RevId, PatchLineComment>>() {

        @Override
        public boolean apply(Map.Entry<RevId, PatchLineComment> in) {
            for (PatchLineComment c : published.get(in.getKey())) {
                if (c.getKey().equals(in.getValue().getKey())) {
                    return false;
                }
            }
            return true;
        }
    });
    return ImmutableListMultimap.copyOf(filtered);
}
#end_block

#method_before
private void loadDraftComments(Account.Id author) throws OrmException {
    if (draftCommentNotes == null || !author.equals(draftCommentNotes.getAuthor())) {
        draftCommentNotes = new DraftCommentNotes(args, change, author, autoRebuild);
        draftCommentNotes.load();
    }
}
#method_after
private void loadDraftComments(Account.Id author) throws OrmException {
    if (draftCommentNotes == null || !author.equals(draftCommentNotes.getAuthor())) {
        draftCommentNotes = new DraftCommentNotes(args, change, author, autoRebuild, rebuildResult);
        draftCommentNotes.load();
    }
}
#end_block

#method_before
@Override
protected String getRefName() {
    return ChangeNoteUtil.changeRefName(getChangeId());
}
#method_after
@Override
protected String getRefName() {
    return changeMetaRef(getChangeId());
}
#end_block

#method_before
public PatchSet getCurrentPatchSet() {
    PatchSet.Id psId = change.currentPatchSetId();
    return checkNotNull(patchSets.get(psId), "missing current patch set %s", psId.get());
}
#method_after
public PatchSet getCurrentPatchSet() {
    PatchSet.Id psId = change.currentPatchSetId();
    return checkNotNull(state.patchSets().get(psId), "missing current patch set %s", psId.get());
}
#end_block

#method_before
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (ChangeNotesParser parser = new ChangeNotesParser(project, change.getId(), rev, handle.walk(), args.repoManager, args.noteUtil, args.metrics)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        revisionNoteMap = parser.revisionNoteMap;
        change.setKey(new Change.Key(parser.changeId));
        change.setDest(new Branch.NameKey(project, parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // TODO(dborowitz): This should be an error, but for now it's required
            // for some tests to pass.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#method_after
@Override
protected void onLoad(LoadHandle handle) throws IOException, ConfigInvalidException {
    ObjectId rev = handle.id();
    if (rev == null) {
        loadDefaults();
        return;
    }
    ChangeNotesCache.Value v = args.cache.get().get(getProjectName(), getChangeId(), rev, handle.walk());
    state = v.state();
    state.copyColumnsTo(change);
    revisionNoteMap = v.revisionNoteMap();
}
#end_block

#method_before
@Override
protected void loadDefaults() {
    approvals = ImmutableListMultimap.of();
    reviewers = ImmutableSetMultimap.of();
    submitRecords = ImmutableList.of();
    allChangeMessages = ImmutableList.of();
    changeMessagesByPatchSet = ImmutableListMultimap.of();
    comments = ImmutableListMultimap.of();
    hashtags = ImmutableSet.of();
    patchSets = ImmutableSortedMap.of();
    allPastReviewers = ImmutableList.of();
}
#method_after
@Override
protected void loadDefaults() {
    state = ChangeNotesState.empty(change);
}
#end_block

#method_before
@Override
public Project.NameKey getProjectName() {
    return project;
}
#method_after
@Override
public Project.NameKey getProjectName() {
    return change.getProject();
}
#end_block

#method_before
@Override
protected ObjectId readRef(Repository repo) throws IOException {
    return cmds != null ? cmds.getObjectId(repo, getRefName()) : super.readRef(repo);
}
#method_after
@Override
protected ObjectId readRef(Repository repo) throws IOException {
    return refs != null ? refs.get(getRefName()).orNull() : super.readRef(repo);
}
#end_block

#method_before
@Override
protected LoadHandle openHandle(Repository repo) throws IOException {
    if (autoRebuild) {
        NoteDbChangeState state = NoteDbChangeState.parse(change);
        if (state == null || !state.isChangeUpToDate(repo)) {
            return rebuildAndOpen(repo);
        }
    }
    return super.openHandle(repo);
}
#method_after
@Override
protected LoadHandle openHandle(Repository repo) throws IOException {
    if (autoRebuild) {
        NoteDbChangeState state = NoteDbChangeState.parse(change);
        ObjectId id = readRef(repo);
        if (state == null && id == null) {
            return super.openHandle(repo, id);
        }
        RefCache refs = this.refs != null ? this.refs : new RepoRefCache(repo);
        if (!NoteDbChangeState.isChangeUpToDate(state, refs, getChangeId())) {
            return rebuildAndOpen(repo, id);
        }
    }
    return super.openHandle(repo);
}
#end_block

#method_before
private LoadHandle rebuildAndOpen(Repository repo) throws IOException {
    try {
        NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId());
        if (newState == null) {
            // May be null in tests.
            return super.openHandle(repo);
        }
        repo.scanForRepoChanges();
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), newState.getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException | ConfigInvalidException e) {
        throw new IOException(e);
    }
}
#method_after
private LoadHandle rebuildAndOpen(Repository repo, ObjectId oldId) throws IOException {
    try (Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES)) {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager manager = rebuilder.stage(db, cid);
        if (manager == null) {
            // May be null in tests.
            return super.openHandle(repo, oldId);
        }
        NoteDbUpdateManager.Result r = manager.stageAndApplyDelta(change);
        try {
            rebuilder.execute(db, cid, manager);
            repo.scanForRepoChanges();
        } catch (OrmException | IOException e) {
            // Rebuilding failed. Most likely cause is contention on one or more
            // change refs; there are other types of errors that can happen during
            // rebuilding, but generally speaking they should happen during stage(),
            // not execute(). Assume that some other worker is going to successfully
            // store the rebuilt state, which is deterministic given an input
            // ChangeBundle.
            // 
            // Parse notes from the staged result so we can return something useful
            // to the caller instead of throwing.
            args.metrics.autoRebuildFailureCount.increment(CHANGES);
            rebuildResult = checkNotNull(r);
            checkNotNull(r.newState());
            checkNotNull(r.staged());
            return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().changeObjects()), r.newState().getChangeMetaId());
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), r.newState().getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo, oldId);
    } catch (OrmException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@Override
protected List<Change> impl(RequestContext ctx) throws OrmException {
    String ref = event.getRefName();
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    if (ref.equals(RefNames.REFS_CONFIG)) {
        return asChanges(queryProvider.get().byProjectOpen(project));
    } else {
        return asChanges(queryProvider.get().byBranchOpen(new Branch.NameKey(project, ref)));
    }
}
#method_after
@Override
protected List<Change> impl(RequestContext ctx) throws OrmException {
    String ref = event.getRefName();
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    if (ref.equals(RefNames.REFS_CONFIG)) {
        return asChanges(queryProvider.get().byProjectOpen(project));
    }
    return asChanges(queryProvider.get().byBranchOpen(new Branch.NameKey(project, ref)));
}
#end_block

#method_before
@Override
protected Void impl(RequestContext ctx) throws OrmException, IOException, NoSuchChangeException {
    // Reload change, as some time may have passed since GetChanges.
    ReviewDb db = ctx.getReviewDbProvider().get();
    try {
        Change c = notesFactory.createChecked(db, new Project.NameKey(event.getProjectName()), id).getChange();
        indexerFactory.create(executor, indexes).index(db, c);
    } catch (NoSuchChangeException e) {
    // Drown, the change could have been a draft and got deleted
    }
    return null;
}
#method_after
@Override
protected Void impl(RequestContext ctx) throws OrmException, IOException, NoSuchChangeException {
    // Reload change, as some time may have passed since GetChanges.
    ReviewDb db = ctx.getReviewDbProvider().get();
    try {
        Change c = notesFactory.createChecked(db, new Project.NameKey(event.getProjectName()), id).getChange();
        indexerFactory.create(executor, indexes).index(db, c);
    } catch (NoSuchChangeException e) {
        indexerFactory.create(executor, indexes).delete(id);
    }
    return null;
}
#end_block

#method_before
@SuppressWarnings("unused")
public void updateRepo(RepoContext ctx) throws Exception {
}
#method_after
public void updateRepo(RepoContext ctx) throws Exception {
}
#end_block

#method_before
@SuppressWarnings("unused")
public void postUpdate(Context ctx) throws Exception {
}
#method_after
/**
 * Override this method to do something after the update
 * e.g. send email or run hooks
 *
 * @param ctx context
 */
public void postUpdate(Context ctx) throws Exception {
}
#end_block

#method_before
@SuppressWarnings("unused")
public boolean updateChange(ChangeContext ctx) throws Exception {
    return false;
}
#method_after
public boolean updateChange(ChangeContext ctx) throws Exception {
    return false;
}
#end_block

#method_before
static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    try {
        Order order = getOrder(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps();
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        for (BatchUpdate u : updates) {
            u.executePostOps();
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#method_after
static void execute(Collection<BatchUpdate> updates, Listener listener) throws UpdateException, RestApiException {
    if (updates.isEmpty()) {
        return;
    }
    try {
        Order order = getOrder(updates);
        boolean updateChangesInParallel = getUpdateChangesInParallel(updates);
        switch(order) {
            case REPO_BEFORE_DB:
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel);
                }
                listener.afterUpdateChanges();
                break;
            case DB_BEFORE_REPO:
                for (BatchUpdate u : updates) {
                    u.executeChangeOps(updateChangesInParallel);
                }
                listener.afterUpdateChanges();
                for (BatchUpdate u : updates) {
                    u.executeUpdateRepo();
                }
                listener.afterUpdateRepos();
                for (BatchUpdate u : updates) {
                    u.executeRefUpdates();
                }
                listener.afterRefUpdates();
                break;
            default:
                throw new IllegalStateException("invalid execution order: " + order);
        }
        List<CheckedFuture<?, IOException>> indexFutures = new ArrayList<>();
        for (BatchUpdate u : updates) {
            indexFutures.addAll(u.indexFutures);
        }
        ChangeIndexer.allAsList(indexFutures).get();
        for (BatchUpdate u : updates) {
            if (u.batchRefUpdate != null) {
                // Fire ref update events only after all mutations are finished, since
                // callers may assume a patch set ref being created means the change
                // was created, or a branch advancing meaning some changes were
                // closed.
                u.gitRefUpdated.fire(u.project, u.batchRefUpdate, u.getUser().isIdentifiedUser() ? u.getUser().getAccountId() : null);
            }
        }
        for (BatchUpdate u : updates) {
            u.executePostOps();
        }
    } catch (UpdateException | RestApiException e) {
        // failure.
        throw e;
    // Convert other common non-REST exception types with user-visible
    // messages to corresponding REST exception types
    } catch (InvalidChangeOperationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    } catch (NoSuchChangeException | NoSuchRefException | NoSuchProjectException e) {
        throw new ResourceNotFoundException(e.getMessage(), e);
    } catch (Exception e) {
        Throwables.propagateIfPossible(e);
        throw new UpdateException(e);
    }
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        } else {
            refUpdateResults.put(cmd.getRefName(), cmd.getNewId());
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException {
    if (commands == null || commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
private void executeChangeOps() throws UpdateException, RestApiException {
    try {
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            Change.Id id = e.getKey();
            db.changes().beginTransaction(id);
            ChangeContext ctx;
            NoteDbUpdateManager updateManager = null;
            boolean dirty = false;
            try {
                ctx = newChangeContext(id);
                // Call updateChange on each op.
                for (Op op : e.getValue()) {
                    dirty |= op.updateChange(ctx);
                }
                if (!dirty) {
                    return;
                }
                // Stage the NoteDb update and store its state in the Change.
                if (!ctx.deleted && notesMigration.writeChanges()) {
                    updateManager = stageNoteDbUpdate(ctx);
                }
                // Bump lastUpdatedOn or rowVersion and commit.
                Iterable<Change> cs = changesToUpdate(ctx);
                if (newChanges.containsKey(id)) {
                    // Insert rather than upsert in case of a race on change IDs.
                    db.changes().insert(cs);
                } else if (ctx.deleted) {
                    db.changes().delete(cs);
                } else {
                    db.changes().update(cs);
                }
                db.commit();
            } finally {
                db.rollback();
            }
            // Execute NoteDb updates after committing ReviewDb updates.
            if (notesMigration.writeChanges()) {
                if (updateManager != null) {
                    updateManager.execute();
                }
                if (ctx.deleted) {
                    new ChangeDelete(plcUtil, getRepository(), ctx.getNotes()).delete();
                }
            }
            // Reindex changes.
            if (ctx.deleted) {
                indexFutures.add(indexer.deleteAsync(id));
            } else {
                indexFutures.add(indexer.indexAsync(ctx.getProject(), id));
            }
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
}
#method_after
private void executeChangeOps(boolean parallel) throws UpdateException, RestApiException {
    ListeningExecutorService executor = parallel ? changeUpdateExector : MoreExecutors.newDirectExecutorService();
    List<ChangeTask> tasks = new ArrayList<>(ops.keySet().size());
    try {
        if (notesMigration.commitChangeWrites() && repo != null) {
            // A NoteDb change may have been rebuilt since the repo was originally
            // opened, so make sure we see that.
            repo.scanForRepoChanges();
        }
        if (!ops.isEmpty() && notesMigration.failChangeWrites()) {
            // this is a programmer error.
            throw new OrmException(NoteDbUpdateManager.CHANGES_READ_ONLY);
        }
        List<ListenableFuture<?>> futures = new ArrayList<>(ops.keySet().size());
        for (Map.Entry<Change.Id, Collection<Op>> e : ops.asMap().entrySet()) {
            ChangeTask task = new ChangeTask(e.getKey(), e.getValue(), Thread.currentThread());
            tasks.add(task);
            futures.add(executor.submit(task));
        }
        Futures.allAsList(futures).get();
        if (notesMigration.commitChangeWrites()) {
            executeNoteDbUpdates(tasks);
        }
    } catch (ExecutionException | InterruptedException e) {
        Throwables.propagateIfInstanceOf(e.getCause(), UpdateException.class);
        Throwables.propagateIfInstanceOf(e.getCause(), RestApiException.class);
        throw new UpdateException(e);
    } catch (OrmException | IOException e) {
        throw new UpdateException(e);
    }
    // Reindex changes.
    for (ChangeTask task : tasks) {
        if (task.deleted) {
            indexFutures.add(indexer.deleteAsync(task.id));
        } else if (task.dirty) {
            indexFutures.add(indexer.indexAsync(project, task.id));
        }
    }
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    out.reviewerChanges = reviewerChanges(cd);
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, GpgException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(ctl, fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus() != Change.Status.MERGED) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        out.mergeable = cd.isMergeable();
    }
    out.submittable = Submit.submittable(cd);
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars().get(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = user.getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    out.submitted = getSubmittedOn(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
        out.reviewers = new HashMap<>();
        for (Map.Entry<ReviewerStateInternal, Map<Account.Id, Timestamp>> e : cd.reviewers().asTable().rowMap().entrySet()) {
            out.reviewers.put(e.getKey().asReviewerState(), toAccountInfo(e.getValue().keySet()));
        }
    }
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, cd, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(change.getId(), null, ImmutableSet.<String>of(), ImmutableSortedMap.<PatchSet.Id, PatchSet>of(), ImmutableListMultimap.<PatchSet.Id, PatchSetApproval>of(), ReviewerSet.empty(), ImmutableList.<Account.Id>of(), ImmutableTable.<Timestamp, ReviewerStateInternal, Account.Id>of(), ImmutableList.<SubmitRecord>of(), ImmutableList.<ChangeMessage>of(), ImmutableListMultimap.<PatchSet.Id, ChangeMessage>of(), ImmutableListMultimap.<RevId, PatchLineComment>of());
}
#method_after
static ChangeNotesState empty(Change change) {
    return new AutoValue_ChangeNotesState(change.getId(), null, ImmutableSet.<String>of(), ImmutableSortedMap.<PatchSet.Id, PatchSet>of(), ImmutableListMultimap.<PatchSet.Id, PatchSetApproval>of(), ReviewerSet.empty(), ImmutableList.<Account.Id>of(), ImmutableList.<ReviewerStatusUpdate>of(), ImmutableList.<SubmitRecord>of(), ImmutableList.<ChangeMessage>of(), ImmutableListMultimap.<PatchSet.Id, ChangeMessage>of(), ImmutableListMultimap.<RevId, PatchLineComment>of());
}
#end_block

#method_before
static ChangeNotesState create(Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Change.Status status, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, Table<Timestamp, ReviewerStateInternal, Account.Id> reviewerChanges, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, PatchLineComment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status), ImmutableSet.copyOf(hashtags), ImmutableSortedMap.copyOf(patchSets, ReviewDbUtil.intKeyOrdering()), ImmutableListMultimap.copyOf(approvals), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableTable.copyOf(reviewerChanges), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#method_after
static ChangeNotesState create(Change.Id changeId, Change.Key changeKey, Timestamp createdOn, Timestamp lastUpdatedOn, Account.Id owner, String branch, @Nullable PatchSet.Id currentPatchSetId, String subject, @Nullable String topic, @Nullable String originalSubject, @Nullable String submissionId, @Nullable Change.Status status, @Nullable Set<String> hashtags, Map<PatchSet.Id, PatchSet> patchSets, Multimap<PatchSet.Id, PatchSetApproval> approvals, ReviewerSet reviewers, List<Account.Id> allPastReviewers, List<ReviewerStatusUpdate> reviewerUpdates, List<SubmitRecord> submitRecords, List<ChangeMessage> allChangeMessages, Multimap<PatchSet.Id, ChangeMessage> changeMessagesByPatchSet, Multimap<RevId, PatchLineComment> publishedComments) {
    if (hashtags == null) {
        hashtags = ImmutableSet.of();
    }
    return new AutoValue_ChangeNotesState(changeId, new AutoValue_ChangeNotesState_ChangeColumns(changeKey, createdOn, lastUpdatedOn, owner, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status), ImmutableSet.copyOf(hashtags), ImmutableSortedMap.copyOf(patchSets, ReviewDbUtil.intKeyOrdering()), ImmutableListMultimap.copyOf(approvals), reviewers, ImmutableList.copyOf(allPastReviewers), ImmutableList.copyOf(reviewerUpdates), ImmutableList.copyOf(submitRecords), ImmutableList.copyOf(allChangeMessages), ImmutableListMultimap.copyOf(changeMessagesByPatchSet), ImmutableListMultimap.copyOf(publishedComments));
}
#end_block

#method_before
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, reviewerChanges, submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#method_after
private ChangeNotesState buildState() {
    return ChangeNotesState.create(id, new Change.Key(changeId), createdOn, lastUpdatedOn, ownerId, branch, currentPatchSetId, subject, topic, originalSubject, submissionId, status, hashtags, patchSets, buildApprovals(), ReviewerSet.fromTable(Tables.transpose(reviewers)), allPastReviewers, buildReviewerUpdates(), submitRecords, buildAllMessages(), buildMessagesByPatchSet(), comments);
}
#end_block

#method_before
private void parseReviewer(Timestamp ts, ReviewerStateInternal state, String line) throws ConfigInvalidException {
    PersonIdent ident = RawParseUtils.parsePersonIdent(line);
    if (ident == null) {
        throw invalidFooter(state.getFooterKey(), line);
    }
    Account.Id accountId = noteUtil.parseIdent(ident, id);
    reviewerChanges.put(ts, state, accountId);
    if (!reviewers.containsRow(accountId)) {
        reviewers.put(accountId, state, ts);
    }
}
#method_after
private void parseReviewer(Timestamp ts, ReviewerStateInternal state, String line) throws ConfigInvalidException {
    PersonIdent ident = RawParseUtils.parsePersonIdent(line);
    if (ident == null) {
        throw invalidFooter(state.getFooterKey(), line);
    }
    Account.Id accountId = noteUtil.parseIdent(ident, id);
    reviewerUpdates.add(ReviewerStatusUpdate.create(ts, ownerId, accountId, state));
    if (!reviewers.containsRow(accountId)) {
        reviewers.put(accountId, state, ts);
    }
}
#end_block

#method_before
@Test
public void reviewAndAddGroupReviewers() throws Exception {
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "reviewAndAddGroupReviewers");
    List<String> usernames = new ArrayList<>(largeGroupSize);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    gApi.groups().id(largeGroup).addMembers(usernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(usernames.subList(0, mediumGroupSize).toArray(new String[mediumGroupSize]));
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    // Attempt to add overly large group as reviewers.
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false).reviewer(largeGroup);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(3);
    AddReviewerResult reviewerResult = result.reviewers.get(largeGroup);
    assertThat(reviewerResult).isNotNull();
    assertThat(reviewerResult.confirm).isNull();
    assertThat(reviewerResult.error).isNotNull();
    assertThat(reviewerResult.error).contains("has too many members to add them all as reviewers");
    // No labels should have changed, and no reviewers/CCs should have been added.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.messages).hasSize(1);
    assertThat(c.reviewers.get(REVIEWER)).isNull();
    assertThat(c.reviewers.get(CC)).isNull();
    // Attempt to add group large enough to require confirmation, without
    // confirmation, as reviewers.
    input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false).reviewer(mediumGroup);
    result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(3);
    reviewerResult = result.reviewers.get(mediumGroup);
    assertThat(reviewerResult).isNotNull();
    assertThat(reviewerResult.confirm).isTrue();
    assertThat(reviewerResult.error).contains("has " + mediumGroupSize + " members. Do you want to add them all" + " as reviewers?");
    // No labels should have changed, and no reviewers/CCs should have been added.
    c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.messages).hasSize(1);
    assertThat(c.reviewers.get(REVIEWER)).isNull();
    assertThat(c.reviewers.get(CC)).isNull();
    // Retrying with confirmation should successfully approve and add reviewers/CCs.
    input = ReviewInput.approve().reviewer(user.email).reviewer(mediumGroup, CC, true);
    result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.messages).hasSize(2);
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, users.subList(0, mediumGroupSize));
    } else {
        // If not in NoteDb mode, then user is returned with the CC group.
        assertReviewers(c, REVIEWER, admin);
        List<TestAccount> expectedCC = users.subList(0, mediumGroupSize);
        expectedCC.add(user);
        assertReviewers(c, CC, expectedCC);
    }
}
#method_after
@Test
public void reviewAndAddGroupReviewers() throws Exception {
    int largeGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS + 1;
    int mediumGroupSize = PostReviewers.DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK + 1;
    List<TestAccount> users = createAccounts(largeGroupSize, "reviewAndAddGroupReviewers");
    List<String> usernames = new ArrayList<>(largeGroupSize);
    for (TestAccount u : users) {
        usernames.add(u.username);
    }
    String largeGroup = createGroup("largeGroup");
    String mediumGroup = createGroup("mediumGroup");
    gApi.groups().id(largeGroup).addMembers(usernames.toArray(new String[largeGroupSize]));
    gApi.groups().id(mediumGroup).addMembers(usernames.subList(0, mediumGroupSize).toArray(new String[mediumGroupSize]));
    TestAccount observer = accounts.user2();
    PushOneCommit.Result r = createChange();
    // Attempt to add overly large group as reviewers.
    ReviewInput input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false).reviewer(largeGroup);
    ReviewResult result = review(r.getChangeId(), r.getCommit().name(), input, SC_BAD_REQUEST);
    assertThat(result.labels).isNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(3);
    AddReviewerResult reviewerResult = result.reviewers.get(largeGroup);
    assertThat(reviewerResult).isNotNull();
    assertThat(reviewerResult.confirm).isNull();
    assertThat(reviewerResult.error).isNotNull();
    assertThat(reviewerResult.error).contains("has too many members to add them all as reviewers");
    // No labels should have changed, and no reviewers/CCs should have been added.
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.messages).hasSize(1);
    assertThat(c.reviewers.get(REVIEWER)).isNull();
    assertThat(c.reviewers.get(CC)).isNull();
    // Attempt to add group large enough to require confirmation, without
    // confirmation, as reviewers.
    input = ReviewInput.approve().reviewer(user.email).reviewer(observer.email, CC, false).reviewer(mediumGroup);
    result = review(r.getChangeId(), r.getCommit().name(), input, SC_BAD_REQUEST);
    assertThat(result.labels).isNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(3);
    reviewerResult = result.reviewers.get(mediumGroup);
    assertThat(reviewerResult).isNotNull();
    assertThat(reviewerResult.confirm).isTrue();
    assertThat(reviewerResult.error).contains("has " + mediumGroupSize + " members. Do you want to add them all" + " as reviewers?");
    // No labels should have changed, and no reviewers/CCs should have been added.
    c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.messages).hasSize(1);
    assertThat(c.reviewers.get(REVIEWER)).isNull();
    assertThat(c.reviewers.get(CC)).isNull();
    // Retrying with confirmation should successfully approve and add reviewers/CCs.
    input = ReviewInput.approve().reviewer(user.email).reviewer(mediumGroup, CC, true);
    result = review(r.getChangeId(), r.getCommit().name(), input);
    assertThat(result.labels).isNotNull();
    assertThat(result.reviewers).isNotNull();
    assertThat(result.reviewers).hasSize(2);
    c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.messages).hasSize(2);
    if (notesMigration.readChanges()) {
        assertReviewers(c, REVIEWER, admin, user);
        assertReviewers(c, CC, users.subList(0, mediumGroupSize));
    } else {
        // If not in NoteDb mode, then user is returned with the CC group.
        assertReviewers(c, REVIEWER, admin);
        List<TestAccount> expectedCC = users.subList(0, mediumGroupSize);
        expectedCC.add(user);
        assertReviewers(c, CC, expectedCC);
    }
}
#end_block

#method_before
@Test
public void noteDbAddReviewerToReviewerChangeInfo() throws Exception {
    setNotesMigration(true, true);
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    addReviewer(changeId, in);
    in.state = REMOVED;
    addReviewer(changeId, in);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertThat(c.reviewerChanges).isNotNull();
    assertThat(c.reviewerChanges).hasSize(2);
    Iterator<ReviewerChangeInfo> it = c.reviewerChanges.iterator();
    ReviewerChangeInfo reviewerChange = it.next();
    assertThat(reviewerChange.state).isEqualTo(REVIEWER);
    assertThat(reviewerChange.author._accountId).isEqualTo(user.getId().get());
    reviewerChange = it.next();
    assertThat(reviewerChange.state).isEqualTo(CC);
    assertThat(reviewerChange.author._accountId).isEqualTo(user.getId().get());
}
#method_after
@Test
public void noteDbAddReviewerToReviewerChangeInfo() throws Exception {
    assume().that(notesMigration.readChanges()).isTrue();
    PushOneCommit.Result r = createChange();
    String changeId = r.getChangeId();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    in.state = CC;
    addReviewer(changeId, in);
    in.state = REVIEWER;
    addReviewer(changeId, in);
    setApiUser(user);
    // NoteDb adds reviewer to a change on every review.
    gApi.changes().id(changeId).current().review(ReviewInput.dislike());
    deleteReviewer(changeId, user).assertNoContent();
    ChangeInfo c = gApi.changes().id(changeId).get();
    assertThat(c.reviewerUpdates).isNotNull();
    assertThat(c.reviewerUpdates).hasSize(3);
    Iterator<ReviewerUpdateInfo> it = c.reviewerUpdates.iterator();
    ReviewerUpdateInfo reviewerChange = it.next();
    assertThat(reviewerChange.state).isEqualTo(CC);
    assertThat(reviewerChange.reviewer._accountId).isEqualTo(user.getId().get());
    assertThat(reviewerChange.updatedBy._accountId).isEqualTo(admin.getId().get());
    reviewerChange = it.next();
    assertThat(reviewerChange.state).isEqualTo(REVIEWER);
    assertThat(reviewerChange.reviewer._accountId).isEqualTo(user.getId().get());
    assertThat(reviewerChange.updatedBy._accountId).isEqualTo(admin.getId().get());
    reviewerChange = it.next();
    assertThat(reviewerChange.state).isEqualTo(REMOVED);
    assertThat(reviewerChange.reviewer._accountId).isEqualTo(user.getId().get());
    assertThat(reviewerChange.updatedBy._accountId).isEqualTo(admin.getId().get());
}
#end_block

#method_before
private AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(changeId, in);
}
#method_after
private AddReviewerResult addReviewer(String changeId, String reviewer) throws Exception {
    return addReviewer(changeId, reviewer, SC_OK);
}
#end_block

#method_before
private AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/reviewers", in);
    return readContentFromJson(resp, AddReviewerResult.class);
}
#method_after
private AddReviewerResult addReviewer(String changeId, String reviewer, int expectedStatus) throws Exception {
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = reviewer;
    return addReviewer(changeId, in, expectedStatus);
}
#end_block

#method_before
private AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/reviewers", in);
    return readContentFromJson(resp, AddReviewerResult.class);
}
#method_after
private AddReviewerResult addReviewer(String changeId, AddReviewerInput in) throws Exception {
    return addReviewer(changeId, in, SC_OK);
}
#end_block

#method_before
private ReviewResult review(String changeId, String revisionId, ReviewInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/revisions/" + revisionId + "/review", in);
    return readContentFromJson(resp, ReviewResult.class);
}
#method_after
private ReviewResult review(String changeId, String revisionId, ReviewInput in) throws Exception {
    return review(changeId, revisionId, in, SC_OK);
}
#end_block

#method_before
private ReviewResult review(String changeId, String revisionId, ReviewInput in) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/revisions/" + revisionId + "/review", in);
    return readContentFromJson(resp, ReviewResult.class);
}
#method_after
private ReviewResult review(String changeId, String revisionId, ReviewInput in, int expectedStatus) throws Exception {
    RestResponse resp = adminRestSession.post("/changes/" + changeId + "/revisions/" + revisionId + "/review", in);
    return readContentFromJson(resp, expectedStatus, ReviewResult.class);
}
#end_block

#method_before
private static <T> T readContentFromJson(RestResponse r, Class<T> clazz) throws Exception {
    r.assertOK();
    JsonReader jsonReader = new JsonReader(r.getReader());
    jsonReader.setLenient(true);
    return newGson().fromJson(jsonReader, clazz);
}
#method_after
private static <T> T readContentFromJson(RestResponse r, int expectedStatus, Class<T> clazz) throws Exception {
    r.assertStatus(expectedStatus);
    JsonReader jsonReader = new JsonReader(r.getReader());
    jsonReader.setLenient(true);
    return newGson().fromJson(jsonReader, clazz);
}
#end_block

#method_before
private LoadHandle rebuildAndOpen(Repository repo, ObjectId oldId) throws IOException {
    Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES);
    try {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager.Result r;
        try (NoteDbUpdateManager manager = rebuilder.stage(db, cid)) {
            if (manager == null) {
                // May be null in tests.
                return super.openHandle(repo, oldId);
            }
            r = manager.stageAndApplyDelta(change);
            try {
                rebuilder.execute(db, cid, manager);
                repo.scanForRepoChanges();
            } catch (OrmException | IOException e) {
                // Rebuilding failed. Most likely cause is contention on one or more
                // change refs; there are other types of errors that can happen during
                // rebuilding, but generally speaking they should happen during stage(),
                // not execute(). Assume that some other worker is going to successfully
                // store the rebuilt state, which is deterministic given an input
                // ChangeBundle.
                // 
                // Parse notes from the staged result so we can return something useful
                // to the caller instead of throwing.
                log.debug("Rebuilding change {} failed", getChangeId());
                args.metrics.autoRebuildFailureCount.increment(CHANGES);
                rebuildResult = checkNotNull(r);
                checkNotNull(r.newState());
                checkNotNull(r.staged());
                return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().changeObjects()), r.newState().getChangeMetaId());
            }
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), r.newState().getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo, oldId);
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        log.debug("Rebuilt change {} in project {} in {} ms", getChangeId(), getProjectName(), TimeUnit.MILLISECONDS.convert(timer.stop(), TimeUnit.NANOSECONDS));
    }
}
#method_after
private LoadHandle rebuildAndOpen(Repository repo, ObjectId oldId) throws IOException {
    Timer1.Context timer = args.metrics.autoRebuildLatency.start(CHANGES);
    try {
        Change.Id cid = getChangeId();
        ReviewDb db = args.db.get();
        ChangeRebuilder rebuilder = args.rebuilder.get();
        NoteDbUpdateManager.Result r;
        try (NoteDbUpdateManager manager = rebuilder.stage(db, cid)) {
            if (manager == null) {
                // May be null in tests.
                return super.openHandle(repo, oldId);
            }
            r = manager.stageAndApplyDelta(change);
            try {
                rebuilder.execute(db, cid, manager);
                repo.scanForRepoChanges();
            } catch (OrmException | IOException e) {
                // Rebuilding failed. Most likely cause is contention on one or more
                // change refs; there are other types of errors that can happen during
                // rebuilding, but generally speaking they should happen during stage(),
                // not execute(). Assume that some other worker is going to successfully
                // store the rebuilt state, which is deterministic given an input
                // ChangeBundle.
                // 
                // Parse notes from the staged result so we can return something useful
                // to the caller instead of throwing.
                log.debug("Rebuilding change {} failed: {}", getChangeId(), e.getMessage());
                args.metrics.autoRebuildFailureCount.increment(CHANGES);
                rebuildResult = checkNotNull(r);
                checkNotNull(r.newState());
                checkNotNull(r.staged());
                return LoadHandle.create(ChangeNotesCommit.newStagedRevWalk(repo, r.staged().changeObjects()), r.newState().getChangeMetaId());
            }
        }
        return LoadHandle.create(ChangeNotesCommit.newRevWalk(repo), r.newState().getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo, oldId);
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        log.debug("Rebuilt change {} in project {} in {} ms", getChangeId(), getProjectName(), TimeUnit.MILLISECONDS.convert(timer.stop(), TimeUnit.NANOSECONDS));
    }
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = Optional.fromNullable(ctx.getChange().getAssignee());
    if (input.assignee == null) {
        if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
            throw new AuthException("Cannot set Assignee to empty");
        }
        return false;
    }
    Account oldAssignee = null;
    if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", ctx.getChange().getChangeId(), newAssigneeUser.getUserName()));
    }
    // notedb
    update.setAssignee(newAssigneeUser.getAccountId());
    // reviewdb
    change.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws OrmException, RestApiException {
    if (!ctx.getControl().canEditAssignee()) {
        throw new AuthException("Changing Assignee not permitted");
    }
    Change change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(change.currentPatchSetId());
    Optional<Account.Id> oldAssigneeId = Optional.fromNullable(ctx.getChange().getAssignee());
    if (input.assignee == null) {
        if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
            throw new AuthException("Cannot set Assignee to empty");
        }
        return false;
    }
    Account oldAssignee = null;
    if (oldAssigneeId != null && oldAssigneeId.isPresent()) {
        oldAssignee = accountInfosFactory.create().get(oldAssigneeId.get());
    }
    IdentifiedUser newAssigneeUser = accounts.parse(input.assignee);
    if (oldAssigneeId != null && oldAssigneeId.equals(newAssigneeUser.getAccountId())) {
        newAssignee = oldAssignee;
        return false;
    }
    if (!newAssigneeUser.getAccount().isActive()) {
        throw new UnprocessableEntityException(String.format("Account of %s is not active", newAssigneeUser.getUserName()));
    }
    if (!ctx.getControl().forUser(newAssigneeUser).isRefVisible()) {
        throw new AuthException(String.format("Change %s is not visible to %s.", ctx.getChange().getChangeId(), newAssigneeUser.getUserName()));
    }
    try {
        for (AssigneeValidationListener validator : validationListeners) {
            validator.validateAssignee(change, newAssigneeUser.getAccount());
        }
    } catch (ValidationException e) {
        throw new BadRequestException(e.getMessage());
    }
    // notedb
    update.setAssignee(newAssigneeUser.getAccountId());
    // reviewdb
    change.setAssignee(newAssigneeUser.getAccountId());
    this.newAssignee = newAssigneeUser.getAccount();
    addMessage(ctx, update, oldAssignee);
    return true;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(RobotComments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), ROBOT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    post(CHANGE_KIND, "merge").to(CreateMergePatchSet.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "assignee").to(GetAssignee.class);
    get(CHANGE_KIND, "past_assignees").to(GetPastAssignees.class);
    put(CHANGE_KIND, "assignee").to(PutAssignee.class);
    delete(CHANGE_KIND, "assignee").to(DeleteAssignee.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    post(REVIEWER_KIND, "delete").to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    post(VOTE_KIND, "delete").to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    get(REVISION_KIND, "preview_submit").to(PreviewSubmit.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    put(REVISION_KIND, "description").to(PutDescription.class);
    get(REVISION_KIND, "description").to(GetDescription.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    get(REVISION_KIND, "mergelist").to(GetMergeList.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "robotcomments").to(RobotComments.class);
    get(ROBOT_COMMENT_KIND).to(GetRobotComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    get(FILE_KIND, "blame").to(GetBlame.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetAssigneeOp.Factory.class);
    factory(SetHashtagsOp.Factory.class);
    factory(ChangeResource.Factory.class);
}
#end_block

#method_before
@Override
public Response<String> apply(RevisionResource req, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canEditDescription()) {
        throw new AuthException("changing description not permitted");
    }
    Op op = new Op(input != null ? input : new Input(), req.getPatchSet());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newDescription) ? Response.<String>none() : Response.ok(op.newDescription);
}
#method_after
@Override
public Response<String> apply(RevisionResource rsrc, Input input) throws UpdateException, RestApiException {
    ChangeControl ctl = rsrc.getControl();
    if (!ctl.canEditDescription()) {
        throw new AuthException("changing description not permitted");
    }
    Op op = new Op(input != null ? input : new Input(), rsrc.getPatchSet().getId());
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), rsrc.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(rsrc.getChange().getId(), op);
        u.execute();
    }
    return Strings.isNullOrEmpty(op.newDescription) ? Response.none() : Response.ok(op.newDescription);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(ps.getId());
    newDescription = Strings.nullToEmpty(input.description);
    oldDescription = Strings.nullToEmpty(ps.getDescription());
    if (oldDescription.equals(newDescription)) {
        return false;
    }
    String summary;
    if (oldDescription.isEmpty()) {
        summary = "Description set to " + newDescription;
    } else if (newDescription.isEmpty()) {
        summary = "Description " + oldDescription + " removed";
    } else {
        summary = String.format("Description changed from %s to %s", oldDescription, newDescription);
    }
    ps.setDescription(newDescription);
    update.setPsDescription(newDescription);
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx.getDb(), ps.getId(), ctx.getUser(), ctx.getWhen(), summary, ChangeMessagesUtil.TAG_SET_DESCRIPTION);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    ChangeUpdate update = ctx.getUpdate(psId);
    newDescription = Strings.nullToEmpty(input.description);
    oldDescription = Strings.nullToEmpty(ps.getDescription());
    if (oldDescription.equals(newDescription)) {
        return false;
    }
    String summary;
    if (oldDescription.isEmpty()) {
        summary = "Description set to \"" + newDescription + "\"";
    } else if (newDescription.isEmpty()) {
        summary = "Description \"" + oldDescription + "\" removed";
    } else {
        summary = "Description changed to \"" + newDescription + "\"";
    }
    ps.setDescription(newDescription);
    update.setPsDescription(newDescription);
    ctx.getDb().patchSets().update(Collections.singleton(ps));
    ChangeMessage cmsg = ChangeMessagesUtil.newMessage(ctx.getDb(), psId, ctx.getUser(), ctx.getWhen(), summary, ChangeMessagesUtil.TAG_SET_DESCRIPTION);
    cmUtil.addChangeMessage(ctx.getDb(), update, cmsg);
    return true;
}
#end_block

#method_before
@Override
public com.google.gerrit.extensions.webui.UiAction.Description getDescription(RevisionResource resource) {
    return new UiAction.Description().setLabel("Edit Description").setVisible(resource.getControl().canEditTopicName());
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource rsrc) {
    return new UiAction.Description().setLabel("Edit Description").setVisible(rsrc.getControl().canEditDescription());
}
#end_block

#method_before
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    return revisionActions.apply(revision).value();
}
#method_after
@Override
public Map<String, ActionInfo> actions() throws RestApiException {
    try {
        return revisionActions.apply(revision).value();
    } catch (OrmException e) {
        throw new RestApiException("Cannot get actions", e);
    }
}
#end_block

#method_before
public boolean canReadCommit(ReviewDb db, Repository repo, RevCommit commit) throws OrmException {
    List<ChangeData> changes = internalChangeQuery.byCommit(commit);
    for (ChangeData change : changes) {
        if (change.changeControl(getUser()).isVisible(db)) {
            return true;
        }
    }
    return changes.isEmpty() && canReadCommitFromVisibleRef(db, repo, commit);
}
#method_after
public boolean canReadCommit(ReviewDb db, Repository repo, RevCommit commit) {
    // Look for changes associated with the commit.
    try {
        List<ChangeData> changes = queryProvider.get().byProjectCommit(getProject().getNameKey(), commit);
        for (ChangeData change : changes) {
            if (controlFor(db, change.change()).isVisible(db)) {
                return true;
            }
        }
    } catch (OrmException e) {
        log.error("Cannot look up change for commit " + commit.name() + " in " + getProject().getName(), e);
    }
    // Scan all visible refs.
    return canReadCommitFromVisibleRef(db, repo, commit);
}
#end_block

#method_before
public boolean canReadCommitFromVisibleRef(ReviewDb db, Repository repo, RevCommit commit) {
    try (RevWalk rw = new RevWalk(repo)) {
        return isMergedIntoVisibleRef(repo, db, rw, commit, repo.getAllRefs().values());
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
        return false;
    }
}
#method_after
private boolean canReadCommitFromVisibleRef(ReviewDb db, Repository repo, RevCommit commit) {
    try (RevWalk rw = new RevWalk(repo)) {
        return isMergedIntoVisibleRef(repo, db, rw, commit, repo.getAllRefs().values());
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
        return false;
    }
}
#end_block

#method_before
private GeneralPreferencesInfo read(Account.Id id, GeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        // Load all users default prefs
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(allUsers);
        GeneralPreferencesInfo allUserPrefs = new GeneralPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.GENERAL, null, allUserPrefs, GeneralPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), updateDefaults(allUserPrefs), in);
        loadDashboardColumns(r, p, dp);
        return loadMyMenusAndUrlAliases(r, p, dp);
    }
}
#method_after
private GeneralPreferencesInfo read(Account.Id id, GeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        // Load all users default prefs
        VersionedAccountPreferences dp = VersionedAccountPreferences.forDefault();
        dp.load(allUsers);
        GeneralPreferencesInfo allUserPrefs = new GeneralPreferencesInfo();
        loadSection(dp.getConfig(), UserConfigSections.GENERAL, null, allUserPrefs, GeneralPreferencesInfo.defaults(), in);
        // Load user prefs
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), updateDefaults(allUserPrefs), in);
        loadChangeTableColumns(r, p, dp);
        return loadMyMenusAndUrlAliases(r, p, dp);
    }
}
#end_block

#method_before
@Test
public void getAndSetPreferences() throws Exception {
    GeneralPreferencesInfo o = gApi.accounts().id(user42.id.toString()).getPreferences();
    assertPrefs(o, GeneralPreferencesInfo.defaults(), "my", "dashboard");
    assertThat(o.my).hasSize(7);
    assertThat(o.dashboard).isEmpty();
    GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults();
    // change all default values
    i.changesPerPage *= -1;
    i.showSiteHeader ^= true;
    i.useFlashClipboard ^= true;
    i.downloadCommand = DownloadCommand.REPO_DOWNLOAD;
    i.dateFormat = DateFormat.US;
    i.timeFormat = TimeFormat.HHMM_24;
    i.emailStrategy = EmailStrategy.DISABLED;
    i.defaultBaseForMerges = DefaultBase.AUTO_MERGE;
    i.highlightAssigneeInChangeTable ^= true;
    i.relativeDateInChangeTable ^= true;
    i.sizeBarInChangeTable ^= true;
    i.legacycidInChangeTable ^= true;
    i.muteCommonPathPrefixes ^= true;
    i.signedOffBy ^= true;
    i.reviewCategoryStrategy = ReviewCategoryStrategy.ABBREV;
    i.diffView = DiffView.UNIFIED_DIFF;
    i.my = new ArrayList<>();
    i.my.add(new MenuItem("name", "url"));
    i.dashboard = new ArrayList<>();
    i.dashboard.add("Status");
    i.urlAliases = new HashMap<>();
    i.urlAliases.put("foo", "bar");
    o = gApi.accounts().id(user42.getId().toString()).setPreferences(i);
    assertPrefs(o, i, "my");
    assertThat(o.my).hasSize(1);
    assertThat(o.dashboard).hasSize(1);
}
#method_after
@Test
public void getAndSetPreferences() throws Exception {
    GeneralPreferencesInfo o = gApi.accounts().id(user42.id.toString()).getPreferences();
    assertPrefs(o, GeneralPreferencesInfo.defaults(), "my", "changeTable");
    assertThat(o.my).hasSize(7);
    assertThat(o.changeTable).isEmpty();
    GeneralPreferencesInfo i = GeneralPreferencesInfo.defaults();
    // change all default values
    i.changesPerPage *= -1;
    i.showSiteHeader ^= true;
    i.useFlashClipboard ^= true;
    i.downloadCommand = DownloadCommand.REPO_DOWNLOAD;
    i.dateFormat = DateFormat.US;
    i.timeFormat = TimeFormat.HHMM_24;
    i.emailStrategy = EmailStrategy.DISABLED;
    i.defaultBaseForMerges = DefaultBase.AUTO_MERGE;
    i.highlightAssigneeInChangeTable ^= true;
    i.relativeDateInChangeTable ^= true;
    i.sizeBarInChangeTable ^= true;
    i.legacycidInChangeTable ^= true;
    i.muteCommonPathPrefixes ^= true;
    i.signedOffBy ^= true;
    i.reviewCategoryStrategy = ReviewCategoryStrategy.ABBREV;
    i.diffView = DiffView.UNIFIED_DIFF;
    i.my = new ArrayList<>();
    i.my.add(new MenuItem("name", "url"));
    i.changeTable = new ArrayList<>();
    i.changeTable.add("Status");
    i.urlAliases = new HashMap<>();
    i.urlAliases.put("foo", "bar");
    o = gApi.accounts().id(user42.getId().toString()).setPreferences(i);
    assertPrefs(o, i, "my");
    assertThat(o.my).hasSize(1);
    assertThat(o.changeTable).hasSize(1);
}
#end_block

#method_before
@Test
public void getPreferencesWithConfiguredDefaults() throws Exception {
    GeneralPreferencesInfo d = GeneralPreferencesInfo.defaults();
    int newChangesPerPage = d.changesPerPage * 2;
    GeneralPreferencesInfo update = new GeneralPreferencesInfo();
    update.changesPerPage = newChangesPerPage;
    gApi.config().server().setDefaultPreferences(update);
    GeneralPreferencesInfo o = gApi.accounts().id(user42.getId().toString()).getPreferences();
    // assert configured defaults
    assertThat(o.changesPerPage).isEqualTo(newChangesPerPage);
    // assert hard-coded defaults
    assertPrefs(o, d, "my", "dashboard", "changesPerPage");
}
#method_after
@Test
public void getPreferencesWithConfiguredDefaults() throws Exception {
    GeneralPreferencesInfo d = GeneralPreferencesInfo.defaults();
    int newChangesPerPage = d.changesPerPage * 2;
    GeneralPreferencesInfo update = new GeneralPreferencesInfo();
    update.changesPerPage = newChangesPerPage;
    gApi.config().server().setDefaultPreferences(update);
    GeneralPreferencesInfo o = gApi.accounts().id(user42.getId().toString()).getPreferences();
    // assert configured defaults
    assertThat(o.changesPerPage).isEqualTo(newChangesPerPage);
    // assert hard-coded defaults
    assertPrefs(o, d, "my", "changeTable", "changesPerPage");
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, BadRequestException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.dashboard = i.dashboard;
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, BadRequestException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.changeTable = i.changeTable;
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#end_block

#method_before
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyDashboardColumns(prefs, i.dashboard);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyChangeTableColumns(prefs, i.changeTable);
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#end_block

#method_before
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    boolean unresolved = false;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    boolean hasUnresolved = (RawParseUtils.match(note, curr.value, UNRESOLVED.getBytes(UTF_8))) != -1;
    if (hasUnresolved) {
        String unresolvedStr = parseStringField(note, curr, changeId, UNRESOLVED);
        unresolved = Boolean.parseBoolean(unresolvedStr);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId, unresolved);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#method_after
private Comment parseComment(byte[] note, MutableInteger curr, String currentFileName, PatchSet.Id psId, RevId revId, boolean isForBase, Integer parentNumber) throws ConfigInvalidException {
    Change.Id changeId = psId.getParentKey();
    // Check if there is a new file.
    boolean newFile = (RawParseUtils.match(note, curr.value, FILE.getBytes(UTF_8))) != -1;
    if (newFile) {
        // If so, parse the new file name.
        currentFileName = parseFilename(note, curr, changeId);
    } else if (currentFileName == null) {
        throw parseException(changeId, "could not parse %s", FILE);
    }
    CommentRange range = parseCommentRange(note, curr);
    if (range == null) {
        throw parseException(changeId, "could not parse %s", COMMENT_RANGE);
    }
    Timestamp commentTime = parseTimestamp(note, curr, changeId);
    Account.Id aId = parseAuthor(note, curr, changeId, AUTHOR);
    boolean hasRealAuthor = (RawParseUtils.match(note, curr.value, REAL_AUTHOR.getBytes(UTF_8))) != -1;
    Account.Id raId = null;
    if (hasRealAuthor) {
        raId = parseAuthor(note, curr, changeId, REAL_AUTHOR);
    }
    boolean hasParent = (RawParseUtils.match(note, curr.value, PARENT.getBytes(UTF_8))) != -1;
    String parentUUID = null;
    boolean unresolved = false;
    if (hasParent) {
        parentUUID = parseStringField(note, curr, changeId, PARENT);
    }
    boolean hasUnresolved = (RawParseUtils.match(note, curr.value, UNRESOLVED.getBytes(UTF_8))) != -1;
    if (hasUnresolved) {
        unresolved = parseBooleanField(note, curr, changeId, UNRESOLVED);
    }
    String uuid = parseStringField(note, curr, changeId, UUID);
    boolean hasTag = (RawParseUtils.match(note, curr.value, TAG.getBytes(UTF_8))) != -1;
    String tag = null;
    if (hasTag) {
        tag = parseStringField(note, curr, changeId, TAG);
    }
    int commentLength = parseCommentLength(note, curr, changeId);
    String message = RawParseUtils.decode(UTF_8, note, curr.value, curr.value + commentLength);
    checkResult(message, "message contents", changeId);
    Comment c = new Comment(new Comment.Key(uuid, currentFileName, psId.get()), aId, commentTime, isForBase ? (short) (parentNumber == null ? 0 : -parentNumber) : (short) 1, message, serverId, unresolved);
    c.lineNbr = range.getEndLine();
    c.parentUuid = parentUUID;
    c.tag = tag;
    c.setRevId(revId);
    if (raId != null) {
        c.setRealAuthor(raId);
    }
    if (range.getStartCharacter() != -1) {
        c.setRange(range);
    }
    curr.value = RawParseUtils.nextLF(note, curr.value + commentLength);
    curr.value = RawParseUtils.nextLF(note, curr.value);
    return c;
}
#end_block

#method_before
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Multimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null;
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#method_after
public Response<ReviewResult> apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException, IOException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    } else if (input.drafts == null) {
        input.drafts = DraftHandling.DELETE;
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.robotComments != null) {
        if (!migration.readChanges()) {
            throw new MethodNotAllowedException("robot comments not supported");
        }
        checkRobotComments(revision, input.robotComments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    Multimap<RecipientType, Account.Id> accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    Map<String, AddReviewerResult> reviewerJsonResults = null;
    List<PostReviewers.Addition> reviewerResults = Lists.newArrayList();
    boolean hasError = false;
    boolean confirm = false;
    if (input.reviewers != null) {
        reviewerJsonResults = Maps.newHashMap();
        for (AddReviewerInput reviewerInput : input.reviewers) {
            // Prevent notifications because setting reviewers is batched.
            reviewerInput.notify = NotifyHandling.NONE;
            PostReviewers.Addition result = postReviewers.prepareApplication(revision.getChangeResource(), reviewerInput, true);
            reviewerJsonResults.put(reviewerInput.reviewer, result.result);
            if (result.result.error != null) {
                hasError = true;
                continue;
            }
            if (result.result.confirm != null) {
                confirm = true;
                continue;
            }
            reviewerResults.add(result);
        }
    }
    ReviewResult output = new ReviewResult();
    output.reviewers = reviewerJsonResults;
    if (hasError || confirm) {
        return Response.withStatusCode(SC_BAD_REQUEST, output);
    }
    output.labels = input.labels;
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        Account.Id id = bu.getUser().getAccountId();
        boolean ccOrReviewer = input.labels != null && !input.labels.isEmpty();
        if (!ccOrReviewer) {
            // Check if user was already CCed or reviewing prior to this review.
            ReviewerSet currentReviewers = approvalsUtil.getReviewers(db.get(), revision.getChangeResource().getNotes());
            ccOrReviewer = currentReviewers.all().contains(id);
        }
        // themselves as a reviewer or to the CC list.
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            bu.addOp(revision.getChange().getId(), reviewerResult.op);
            if (!ccOrReviewer && reviewerResult.result.reviewers != null) {
                for (ReviewerInfo reviewerInfo : reviewerResult.result.reviewers) {
                    if (Objects.equals(id.get(), reviewerInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
            if (!ccOrReviewer && reviewerResult.result.ccs != null) {
                for (AccountInfo accountInfo : reviewerResult.result.ccs) {
                    if (Objects.equals(id.get(), accountInfo._accountId)) {
                        ccOrReviewer = true;
                        break;
                    }
                }
            }
        }
        if (!ccOrReviewer) {
            // User posting this review isn't currently in the reviewer or CC list,
            // isn't being explicitly added, and isn't voting on any label.
            // Automatically CC them on this change so they receive replies.
            PostReviewers.Addition selfAddition = postReviewers.ccCurrentUser(bu.getUser(), revision);
            bu.addOp(revision.getChange().getId(), selfAddition.op);
        }
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input, accountsToNotify, reviewerResults));
        bu.execute();
        for (PostReviewers.Addition reviewerResult : reviewerResults) {
            reviewerResult.gatherResults();
        }
        emailReviewers(revision.getChange(), reviewerResults, input.notify, accountsToNotify);
    }
    return Response.ok(output);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException, UnprocessableEntityException {
    user = ctx.getIdentifiedUser();
    notes = ctx.getNotes();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= insertRobotComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    return dirty;
}
#end_block

#method_before
private boolean insertComments(ChangeContext ctx) throws OrmException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#method_after
private boolean insertComments(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    Map<String, List<CommentInput>> map = in.comments;
    if (map == null) {
        map = Collections.emptyMap();
    }
    Map<String, Comment> drafts = Collections.emptyMap();
    if (!map.isEmpty() || in.drafts != DraftHandling.KEEP) {
        if (in.drafts == DraftHandling.PUBLISH_ALL_REVISIONS) {
            drafts = changeDrafts(ctx);
        } else {
            drafts = patchSetDrafts(ctx);
        }
    }
    List<Comment> toDel = new ArrayList<>();
    List<Comment> toPublish = new ArrayList<>();
    Set<CommentSetEntry> existingIds = in.omitDuplicateComments ? readExistingComments(ctx) : Collections.emptySet();
    for (Map.Entry<String, List<CommentInput>> ent : map.entrySet()) {
        String path = ent.getKey();
        for (CommentInput c : ent.getValue()) {
            String parent = Url.decode(c.inReplyTo);
            Comment e = drafts.remove(Url.decode(c.id));
            if (e == null) {
                e = commentsUtil.newComment(ctx, path, psId, c.side(), c.message, c.unresolved, parent);
            } else {
                e.writtenOn = ctx.getWhen();
                e.side = c.side();
                e.message = c.message;
            }
            setCommentRevId(e, patchListCache, ctx.getChange(), ps);
            e.setLineNbrAndRange(c.line, c.range);
            e.tag = in.tag;
            if (existingIds.contains(CommentSetEntry.create(e))) {
                continue;
            }
            toPublish.add(e);
        }
    }
    switch(in.drafts) {
        case KEEP:
        default:
            break;
        case DELETE:
            toDel.addAll(drafts.values());
            break;
        case PUBLISH:
            for (Comment e : drafts.values()) {
                toPublish.add(publishComment(ctx, e, ps));
            }
            break;
        case PUBLISH_ALL_REVISIONS:
            publishAllRevisions(ctx, drafts, toPublish);
            break;
    }
    ChangeUpdate u = ctx.getUpdate(psId);
    commentsUtil.deleteComments(ctx.getDb(), u, toDel);
    commentsUtil.putComments(ctx.getDb(), u, Status.PUBLISHED, toPublish);
    comments.addAll(toPublish);
    return !toDel.isEmpty() || !toPublish.isEmpty();
}
#end_block

#method_before
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    if (PrimaryStorage.of(update.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        ctx.getDb().patchSetApprovals().delete(del);
        ctx.getDb().patchSetApprovals().upsert(ups);
    }
    return !del.isEmpty() || !ups.isEmpty();
}
#method_after
private boolean updateLabels(ChangeContext ctx) throws OrmException, ResourceConflictException {
    Map<String, Short> inLabels = MoreObjects.firstNonNull(in.labels, Collections.<String, Short>emptyMap());
    // losing access to a label after the change was submitted.
    if (inLabels.isEmpty() && ctx.getChange().getStatus().isClosed()) {
        return false;
    }
    List<PatchSetApproval> del = new ArrayList<>();
    List<PatchSetApproval> ups = new ArrayList<>();
    Map<String, PatchSetApproval> current = scanLabels(ctx, del);
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> allApprovals = getAllApprovals(labelTypes, approvalsByKey(current.values()), inLabels);
    Map<String, Short> previous = getPreviousApprovals(allApprovals, approvalsByKey(current.values()));
    ChangeUpdate update = ctx.getUpdate(psId);
    for (Map.Entry<String, Short> ent : allApprovals.entrySet()) {
        String name = ent.getKey();
        LabelType lt = checkNotNull(labelTypes.byLabel(name), name);
        PatchSetApproval c = current.remove(lt.getName());
        String normName = lt.getName();
        approvals.put(normName, (short) 0);
        if (ent.getValue() == null || ent.getValue() == 0) {
            // User requested delete of this label.
            oldApprovals.put(normName, null);
            if (c != null) {
                if (c.getValue() != 0) {
                    addLabelDelta(normName, (short) 0);
                    oldApprovals.put(normName, previous.get(normName));
                }
                del.add(c);
                update.putApproval(normName, (short) 0);
            }
        } else if (c != null && c.getValue() != ent.getValue()) {
            c.setValue(ent.getValue());
            c.setGranted(ctx.getWhen());
            c.setTag(in.tag);
            ctx.getUser().updateRealAccountId(c::setRealAccountId);
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putApproval(normName, ent.getValue());
        } else if (c != null && c.getValue() == ent.getValue()) {
            current.put(normName, c);
            oldApprovals.put(normName, null);
            approvals.put(normName, c.getValue());
        } else if (c == null) {
            c = ApprovalsUtil.newApproval(psId, user, lt.getLabelId(), ent.getValue(), ctx.getWhen());
            c.setTag(in.tag);
            c.setGranted(ctx.getWhen());
            ups.add(c);
            addLabelDelta(normName, c.getValue());
            oldApprovals.put(normName, previous.get(normName));
            approvals.put(normName, c.getValue());
            update.putReviewer(user.getAccountId(), REVIEWER);
            update.putApproval(normName, ent.getValue());
        }
    }
    validatePostSubmitLabels(ctx, labelTypes, previous, ups, del);
    // This allows us to preserve their CC status.
    if (current.isEmpty() && del.isEmpty() && ups.isEmpty() && !isReviewer(ctx)) {
        return false;
    }
    forceCallerAsReviewer(ctx, current, ups, del);
    ctx.getDb().patchSetApprovals().delete(del);
    ctx.getDb().patchSetApprovals().upsert(ups);
    return !del.isEmpty() || !ups.isEmpty();
}
#end_block

#method_before
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, Boolean unresolved, String parentUuid) throws OrmException {
    if (unresolved == null) {
        // Inherit unresolved value from inReplyTo comment if not specified.
        Comment.Key key = new Comment.Key(parentUuid, path, psId.patchSetId);
        Optional<Comment> parent = this.get(ctx.getDb(), ctx.getNotes(), key);
        if (parent.isPresent()) {
            unresolved = parent.get().unresolved;
        } else {
            // Default to false if comment is not descended from another.
            unresolved = false;
        }
    }
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, unresolved);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#method_after
public Comment newComment(ChangeContext ctx, String path, PatchSet.Id psId, short side, String message, @Nullable Boolean unresolved, @Nullable String parentUuid) throws OrmException, UnprocessableEntityException {
    if (unresolved == null) {
        if (parentUuid == null) {
            // Default to false if comment is not descended from another.
            unresolved = false;
        } else {
            // Inherit unresolved value from inReplyTo comment if not specified.
            Comment.Key key = new Comment.Key(parentUuid, path, psId.patchSetId);
            Optional<Comment> parent = get(ctx.getDb(), ctx.getNotes(), key);
            if (!parent.isPresent()) {
                throw new UnprocessableEntityException("Invalid parentUuid supplied for comment");
            }
            unresolved = parent.get().unresolved;
        }
    }
    Comment c = new Comment(new Comment.Key(ChangeUtil.messageUUID(ctx.getDb()), path, psId.get()), ctx.getUser().getAccountId(), ctx.getWhen(), side, message, serverId, unresolved);
    ctx.getUser().updateRealAccountId(c::setRealAuthor);
    return c;
}
#end_block

#method_before
public void deleteComments(ReviewDb db, ChangeUpdate update, Iterable<Comment> comments) throws OrmException {
    for (Comment c : comments) {
        update.deleteComment(c);
    }
    if (PrimaryStorage.of(update.getChange()) == REVIEW_DB) {
        // Avoid OrmConcurrencyException trying to delete non-existent entities.
        db.patchComments().delete(toPatchLineComments(update.getId(), PatchLineComment.Status.DRAFT, comments));
    }
}
#method_after
public void deleteComments(ReviewDb db, ChangeUpdate update, Iterable<Comment> comments) throws OrmException {
    for (Comment c : comments) {
        update.deleteComment(c);
    }
    db.patchComments().delete(toPatchLineComments(update.getId(), PatchLineComment.Status.DRAFT, comments));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n" + numComments(parsedComments.size());
    }
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg);
    List<Comment> comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = ps;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message, false, null);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
            comment.unresolved = c.inReplyTo.unresolved;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, UnprocessableEntityException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new OrmException("patch set not found: " + psId);
    }
    String changeMsg = "Patch Set " + psId.get() + ":";
    if (parsedComments.get(0).type == MailComment.CommentType.CHANGE_MESSAGE) {
        if (parsedComments.size() > 1) {
            changeMsg += "\n" + numComments(parsedComments.size() - 1);
        }
        changeMsg += "\n" + parsedComments.get(0).message;
    } else {
        changeMsg += "\n" + numComments(parsedComments.size());
    }
    ChangeMessage msg = ChangeMessagesUtil.newMessage(ctx, changeMsg, tag);
    changeMessagesUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), msg);
    List<Comment> comments = new ArrayList<>();
    for (MailComment c : parsedComments) {
        if (c.type == MailComment.CommentType.CHANGE_MESSAGE) {
            continue;
        }
        String fileName;
        // The patch set that this comment is based on is different if this
        // comment was sent in reply to a comment on a previous patch set.
        PatchSet psForComment;
        Side side;
        if (c.inReplyTo != null) {
            fileName = c.inReplyTo.key.filename;
            psForComment = psUtil.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(ctx.getChange().getId(), c.inReplyTo.key.patchSetId));
            side = Side.fromShort(c.inReplyTo.side);
        } else {
            fileName = c.fileName;
            psForComment = ps;
            side = Side.REVISION;
        }
        Comment comment = commentsUtil.newComment(ctx, fileName, psForComment.getId(), (short) side.ordinal(), c.message, false, null);
        comment.tag = tag;
        if (c.inReplyTo != null) {
            comment.parentUuid = c.inReplyTo.key.uuid;
            comment.lineNbr = c.inReplyTo.lineNbr;
            comment.range = c.inReplyTo.range;
            comment.unresolved = c.inReplyTo.unresolved;
        }
        CommentsUtil.setCommentRevId(comment, patchListCache, ctx.getChange(), psForComment);
        comments.add(comment);
    }
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), Status.PUBLISHED, comments);
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    String parentUuid = Url.decode(in.inReplyTo);
    comment = commentsUtil.newComment(ctx, in.path, ps.getId(), in.side(), in.message.trim(), in.unresolved, parentUuid);
    comment.setLineNbrAndRange(in.line, in.range);
    comment.tag = in.tag;
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(psId), Status.DRAFT, Collections.singleton(comment));
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException, UnprocessableEntityException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    String parentUuid = Url.decode(in.inReplyTo);
    comment = commentsUtil.newComment(ctx, in.path, ps.getId(), in.side(), in.message.trim(), in.unresolved, parentUuid);
    comment.setLineNbrAndRange(in.line, in.range);
    comment.tag = in.tag;
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    commentsUtil.putComments(ctx.getDb(), ctx.getUpdate(psId), Status.DRAFT, Collections.singleton(comment));
    ctx.bumpLastUpdatedOn(false);
    return true;
}
#end_block

#method_before
@Test
public void postComment() throws Exception {
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1", null);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertThat(comment).isEqualTo(infoToInput(file).apply(actual));
        assertThat(comment).isEqualTo(infoToInput(file).apply(getPublishedComment(changeId, revId, actual.id)));
    }
}
#method_after
@Test
public void postComment() throws Exception {
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1", false);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        assertThat(comment).isEqualTo(infoToInput(file).apply(actual));
        assertThat(comment).isEqualTo(infoToInput(file).apply(getPublishedComment(changeId, revId, actual.id)));
    }
}
#end_block

#method_before
@Test
public void postCommentOnMergeCommitChange() throws Exception {
    for (Integer line : lines) {
        String file = "foo";
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master", file);
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1", null);
        CommentInput c2 = newComment(file, Side.PARENT, line, "auto-merge of ps-1", null);
        CommentInput c3 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c4 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3, c4));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3, c4);
    }
    // for the commit message comments on the auto-merge are not possible
    for (Integer line : lines) {
        String file = Patch.COMMIT_MSG;
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1", null);
        CommentInput c2 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c3 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3);
    }
}
#method_after
@Test
public void postCommentOnMergeCommitChange() throws Exception {
    for (Integer line : lines) {
        String file = "foo";
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master", file);
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1", false);
        CommentInput c2 = newComment(file, Side.PARENT, line, "auto-merge of ps-1", false);
        CommentInput c3 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c4 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3, c4));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3, c4);
    }
    // for the commit message comments on the auto-merge are not possible
    for (Integer line : lines) {
        String file = Patch.COMMIT_MSG;
        PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        ReviewInput input = new ReviewInput();
        CommentInput c1 = newComment(file, Side.REVISION, line, "ps-1", false);
        CommentInput c2 = newCommentOnParent(file, 1, line, "parent-1 of ps-1");
        CommentInput c3 = newCommentOnParent(file, 2, line, "parent-2 of ps-1");
        input.comments = new HashMap<>();
        input.comments.put(file, ImmutableList.of(c1, c2, c3));
        revision(r).review(input);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        assertThat(Lists.transform(result.get(file), infoToInput(file))).containsExactly(c1, c2, c3);
    }
}
#end_block

#method_before
@Test
public void postCommentOnCommitMessageOnAutoMerge() throws Exception {
    PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
    ReviewInput input = new ReviewInput();
    CommentInput c = newComment(Patch.COMMIT_MSG, Side.PARENT, 0, "comment on auto-merge", null);
    input.comments = new HashMap<>();
    input.comments.put(Patch.COMMIT_MSG, ImmutableList.of(c));
    exception.expect(BadRequestException.class);
    exception.expectMessage("cannot comment on " + Patch.COMMIT_MSG + " on auto-merge");
    revision(r).review(input);
}
#method_after
@Test
public void postCommentOnCommitMessageOnAutoMerge() throws Exception {
    PushOneCommit.Result r = createMergeCommitChange("refs/for/master");
    ReviewInput input = new ReviewInput();
    CommentInput c = newComment(Patch.COMMIT_MSG, Side.PARENT, 0, "comment on auto-merge", false);
    input.comments = new HashMap<>();
    input.comments.put(Patch.COMMIT_MSG, ImmutableList.of(c));
    exception.expect(BadRequestException.class);
    exception.expectMessage("cannot comment on " + Patch.COMMIT_MSG + " on auto-merge");
    revision(r).review(input);
}
#end_block

#method_before
@Test
public void listComments() throws Exception {
    String file = "file";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, "contents");
    PushOneCommit.Result r = push.to("refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    assertThat(getPublishedComments(changeId, revId)).isEmpty();
    List<CommentInput> expectedComments = new ArrayList<>();
    for (Integer line : lines) {
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment " + line, null);
        expectedComments.add(comment);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
    }
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    List<CommentInfo> actualComments = result.get(file);
    assertThat(Lists.transform(actualComments, infoToInput(file))).containsExactlyElementsIn(expectedComments);
}
#method_after
@Test
public void listComments() throws Exception {
    String file = "file";
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, "contents");
    PushOneCommit.Result r = push.to("refs/for/master");
    String changeId = r.getChangeId();
    String revId = r.getCommit().getName();
    assertThat(getPublishedComments(changeId, revId)).isEmpty();
    List<CommentInput> expectedComments = new ArrayList<>();
    for (Integer line : lines) {
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment " + line, false);
        expectedComments.add(comment);
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        revision(r).review(input);
    }
    Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
    assertThat(result).isNotEmpty();
    List<CommentInfo> actualComments = result.get(file);
    assertThat(Lists.transform(actualComments, infoToInput(file))).containsExactlyElementsIn(expectedComments);
}
#end_block

#method_before
@Test
public void insertCommentsWithHistoricTimestamp() throws Exception {
    Timestamp timestamp = new Timestamp(0);
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        Timestamp origLastUpdated = r.getChange().change().getLastUpdatedOn();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1", null);
        comment.updated = timestamp;
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        ChangeResource changeRsrc = changes.get().parse(TopLevelResource.INSTANCE, IdString.fromDecoded(changeId));
        RevisionResource revRsrc = revisions.parse(changeRsrc, IdString.fromDecoded(revId));
        postReview.get().apply(revRsrc, input, timestamp);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        CommentInput ci = infoToInput(file).apply(actual);
        ci.updated = comment.updated;
        assertThat(comment).isEqualTo(ci);
        assertThat(actual.updated).isEqualTo(gApi.changes().id(r.getChangeId()).info().created);
        // Updating historic comments doesn't cause lastUpdatedOn to regress.
        assertThat(r.getChange().change().getLastUpdatedOn()).isEqualTo(origLastUpdated);
    }
}
#method_after
@Test
public void insertCommentsWithHistoricTimestamp() throws Exception {
    Timestamp timestamp = new Timestamp(0);
    for (Integer line : lines) {
        String file = "file";
        String contents = "contents " + line;
        PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo, "first subject", file, contents);
        PushOneCommit.Result r = push.to("refs/for/master");
        String changeId = r.getChangeId();
        String revId = r.getCommit().getName();
        Timestamp origLastUpdated = r.getChange().change().getLastUpdatedOn();
        ReviewInput input = new ReviewInput();
        CommentInput comment = newComment(file, Side.REVISION, line, "comment 1", false);
        comment.updated = timestamp;
        input.comments = new HashMap<>();
        input.comments.put(comment.path, Lists.newArrayList(comment));
        ChangeResource changeRsrc = changes.get().parse(TopLevelResource.INSTANCE, IdString.fromDecoded(changeId));
        RevisionResource revRsrc = revisions.parse(changeRsrc, IdString.fromDecoded(revId));
        postReview.get().apply(revRsrc, input, timestamp);
        Map<String, List<CommentInfo>> result = getPublishedComments(changeId, revId);
        assertThat(result).isNotEmpty();
        CommentInfo actual = Iterables.getOnlyElement(result.get(comment.path));
        CommentInput ci = infoToInput(file).apply(actual);
        ci.updated = comment.updated;
        assertThat(comment).isEqualTo(ci);
        assertThat(actual.updated).isEqualTo(gApi.changes().id(r.getChangeId()).info().created);
        // Updating historic comments doesn't cause lastUpdatedOn to regress.
        assertThat(r.getChange().change().getLastUpdatedOn()).isEqualTo(origLastUpdated);
    }
}
#end_block

#method_before
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    List<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/1/a.txt@a2\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + url + "#/c/12/1/a.txt@1\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/12/2/a.txt@a1\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@a2\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@1\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + url + "#/c/12/2/a.txt@2\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n" + "\n");
}
#method_after
@Test
public void publishCommentsAllRevisions() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = pushFactory.create(db, admin.getIdent(), testRepo, SUBJECT, FILE_NAME, "new\ncntent\n", r1.getChangeId()).to("refs/for/master");
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "nit: trailing whitespace"));
    addDraft(r1.getChangeId(), r1.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "what happened to this?"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "join lines"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "typo: content"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 1, "comment 1 on base"));
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.PARENT, 2, "comment 2 on base"));
    PushOneCommit.Result other = createChange();
    // Drafts on other changes aren't returned.
    addDraft(other.getChangeId(), other.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 1, "unrelated comment"));
    setApiUser(admin);
    // Drafts by other users aren't returned.
    addDraft(r2.getChangeId(), r2.getCommit().getName(), newDraft(FILE_NAME, Side.REVISION, 2, "oops"));
    setApiUser(user);
    ReviewInput reviewInput = new ReviewInput();
    reviewInput.drafts = DraftHandling.PUBLISH_ALL_REVISIONS;
    reviewInput.message = "comments";
    gApi.changes().id(r2.getChangeId()).current().review(reviewInput);
    assertThat(gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps1Map = gApi.changes().id(r1.getChangeId()).revision(r1.getCommit().name()).comments();
    assertThat(ps1Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps1List = ps1Map.get(FILE_NAME);
    assertThat(ps1List).hasSize(2);
    assertThat(ps1List.get(0).message).isEqualTo("what happened to this?");
    assertThat(ps1List.get(0).side).isEqualTo(Side.PARENT);
    assertThat(ps1List.get(1).message).isEqualTo("nit: trailing whitespace");
    assertThat(ps1List.get(1).side).isNull();
    assertThat(gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).drafts()).isEmpty();
    Map<String, List<CommentInfo>> ps2Map = gApi.changes().id(r2.getChangeId()).revision(r2.getCommit().name()).comments();
    assertThat(ps2Map.keySet()).containsExactly(FILE_NAME);
    List<CommentInfo> ps2List = ps2Map.get(FILE_NAME);
    assertThat(ps2List).hasSize(4);
    assertThat(ps2List.get(0).message).isEqualTo("comment 1 on base");
    assertThat(ps2List.get(1).message).isEqualTo("comment 2 on base");
    assertThat(ps2List.get(2).message).isEqualTo("join lines");
    assertThat(ps2List.get(3).message).isEqualTo("typo: content");
    List<Message> messages = email.getMessages(r2.getChangeId(), "comment");
    assertThat(messages).hasSize(1);
    String url = canonicalWebUrl.get();
    int c = r1.getChange().getId().get();
    assertThat(extractComments(messages.get(0).body())).isEqualTo("Patch Set 2:\n" + "\n" + "(6 comments)\n" + "\n" + "comments\n" + "\n" + url + "#/c/" + c + "/1/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/" + c + "/1/a.txt@a2\n" + "PS1, Line 2: \n" + "what happened to this?\n" + "\n" + "\n" + url + "#/c/" + c + "/1/a.txt@1\n" + "PS1, Line 1: ew\n" + "nit: trailing whitespace\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt\n" + "File a.txt:\n" + "\n" + url + "#/c/" + c + "/2/a.txt@a1\n" + "PS2, Line 1: \n" + "comment 1 on base\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt@a2\n" + "PS2, Line 2: \n" + "comment 2 on base\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt@1\n" + "PS2, Line 1: ew\n" + "join lines\n" + "\n" + "\n" + url + "#/c/" + c + "/2/a.txt@2\n" + "PS2, Line 2: nten\n" + "typo: content\n" + "\n" + "\n");
}
#end_block

#method_before
private static CommentInput newCommentOnParent(String path, int parent, int line, String message) {
    CommentInput c = new CommentInput();
    return populate(c, path, Side.PARENT, Integer.valueOf(parent), line, message, null);
}
#method_after
private static CommentInput newCommentOnParent(String path, int parent, int line, String message) {
    CommentInput c = new CommentInput();
    return populate(c, path, Side.PARENT, Integer.valueOf(parent), line, message, false);
}
#end_block

#method_before
private DraftInput newDraft(String path, Side side, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, side, null, line, message, null);
}
#method_after
private DraftInput newDraft(String path, Side side, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, side, null, line, message, false);
}
#end_block

#method_before
private DraftInput newDraftOnParent(String path, int parent, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, Side.PARENT, Integer.valueOf(parent), line, message, null);
}
#method_after
private DraftInput newDraftOnParent(String path, int parent, int line, String message) {
    DraftInput d = new DraftInput();
    return populate(d, path, Side.PARENT, Integer.valueOf(parent), line, message, false);
}
#end_block

#method_before
private static void copy(Comment from, Comment to) {
    to.side = from.side == null ? Side.REVISION : from.side;
    to.parent = from.parent;
    to.line = from.line;
    to.message = from.message;
    to.range = from.range;
}
#method_after
private static void copy(Comment from, Comment to) {
    to.side = from.side == null ? Side.REVISION : from.side;
    to.parent = from.parent;
    to.line = from.line;
    to.message = from.message;
    to.range = from.range;
    to.unresolved = from.unresolved;
}
#end_block

#method_before
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        for (RevCommit c : accepted) {
            // n also tip of directly pushed branch => n remains 'interesting' here
            if (!c.equals(n)) {
                rw.markUninteresting(c);
            }
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                // 
                if (isMerged(c)) {
                    break;
                }
                if (n.missing == null) {
                    n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                    n.missing = new ArrayList<>();
                }
                n.missing.add(c);
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#method_after
public List<CodeReviewCommit> sort(Collection<CodeReviewCommit> incoming) throws IOException {
    final List<CodeReviewCommit> sorted = new ArrayList<>();
    final Set<CodeReviewCommit> sort = new HashSet<>(incoming);
    while (!sort.isEmpty()) {
        final CodeReviewCommit n = removeOne(sort);
        rw.resetRetain(canMergeFlag);
        rw.markStart(n);
        if (initialTip != null) {
            rw.markUninteresting(initialTip);
        }
        CodeReviewCommit c;
        final List<CodeReviewCommit> contents = new ArrayList<>();
        while ((c = rw.next()) != null) {
            if (!c.has(canMergeFlag) || !incoming.contains(c)) {
                if (isAlreadyMerged(c, n.change().getDest())) {
                    rw.markUninteresting(c);
                } else {
                    // 
                    if (n.missing == null) {
                        n.setStatusCode(CommitMergeStatus.MISSING_DEPENDENCY);
                        n.missing = new ArrayList<>();
                    }
                    n.missing.add(c);
                }
                // dependency. Not need to walk further.
                break;
            } else {
                contents.add(c);
            }
        }
        if (n.getStatusCode() == CommitMergeStatus.MISSING_DEPENDENCY) {
            continue;
        }
        sort.removeAll(contents);
        Collections.reverse(contents);
        sorted.removeAll(contents);
        sorted.addAll(contents);
    }
    return sorted;
}
#end_block

#method_before
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        // TODO(tandrii): add extension point to customize this commit message.
        String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        // TODO(tandrii): add extension point to customize commit message while
        // rebasing.
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#method_after
@Override
public void updateRepoImpl(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, args.mergeTip.getCurrentTip(), args.rw, toMerge)) {
        if (!rebaseAlways) {
            args.mergeTip.moveTipTo(amendGitlink(toMerge), toMerge);
            toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            acceptMergeTip(args.mergeTip);
            return;
        }
        // RebaseAlways means we modify commit message.
        args.rw.parseBody(toMerge);
        newPatchSetId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
        RevCommit mergeTip = args.mergeTip.getCurrentTip();
        args.rw.parseBody(mergeTip);
        String cherryPickCmtMsg = args.mergeUtil.createCommitMessageOnSubmit(toMerge, mergeTip);
        PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
        try {
            newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, args.mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw, 0, true);
        } catch (MergeConflictException mce) {
            // Unlike in Cherry-pick case, this should never happen.
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IllegalStateException("MergeConflictException on message edit must not happen");
        } catch (MergeIdenticalTreeException mie) {
            // this should not happen
            toMerge.setStatusCode(SKIPPED_IDENTICAL_TREE);
            return;
        }
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSetId.toRefName()));
    } else {
        // Stale read of patch set is ok; see comments in RebaseChangeOp.
        PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
        rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, args.mergeTip.getCurrentTip().name()).setFireRevisionCreated(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE).setCheckAddPatchSetPermission(false).setDetailedCommitMessage(rebaseAlways).setPostMessage(false);
        try {
            rebaseOp.updateRepo(ctx);
        } catch (MergeConflictException | NoSuchChangeException e) {
            toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
            throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
        }
        newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
        newPatchSetId = rebaseOp.getPatchSetId();
    }
    newCommit = amendGitlink(newCommit);
    newCommit.copyFrom(toMerge);
    newCommit.setPatchsetId(newPatchSetId);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(args.mergeTip.getCurrentTip());
    acceptMergeTip(args.mergeTip);
}
#end_block

#method_before
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // Took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, false, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#method_after
@Override
public PatchSet updateChangeImpl(ChangeContext ctx) throws NoSuchChangeException, ResourceConflictException, OrmException, IOException {
    if (newCommit == null) {
        checkState(!rebaseAlways, "RebaseAlways must never fast forward");
        // otherwise, took the fast-forward option, nothing to do.
        return null;
    }
    PatchSet newPs;
    if (rebaseOp != null) {
        rebaseOp.updateChange(ctx);
        newPs = rebaseOp.getPatchSet();
    } else {
        // CherryPick
        PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
        newPs = args.psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(newPatchSetId), newPatchSetId, newCommit, false, prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of(), null, null);
    }
    ctx.getChange().setCurrentPatchSet(args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, newPatchSetId));
    newCommit.setControl(ctx.getControl());
    return newPs;
}
#end_block

#method_before
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrationException {
    try {
        return new RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag, args.internalChangeQuery).sort(toSort);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#method_after
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrationException {
    try {
        return new RebaseSorter(args.rw, args.mergeTip.getInitialTip(), args.alreadyAccepted, args.canMergeFlag, args.internalChangeQuery, args.changeKindCache, args.repo).sort(toSort);
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#end_block

#method_before
public GroupReference getGroup(AccountGroup.UUID uuid) {
    return groupList.byUUID(uuid);
}
#method_after
public GroupReference getGroup(String groupName) {
    return groupsByName.get(groupName);
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    Map<String, GroupReference> groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setMatchAuthorToCommitterDate(getEnum(rc, PROJECT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, InheritableBoolean.INHERIT));
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadBranchOrderSection(rc);
    loadNotifySections(rc, groupsByName);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    readGroupList();
    groupsByName = mapGroupReferences();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    if (rc.getStringList(ACCESS, null, KEY_INHERIT_FROM).length > 1) {
        // The config must not contain more than one parent to inherit from
        // as there is no guarantee which of the parents would be used then.
        error(new ValidationError(PROJECT_CONFIG, "Cannot inherit from multiple projects"));
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, InheritableBoolean.INHERIT));
    p.setUseSignedOffBy(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, InheritableBoolean.INHERIT));
    p.setRequireChangeID(getEnum(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, InheritableBoolean.INHERIT));
    p.setCreateNewChangeForAllNotInTarget(getEnum(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, InheritableBoolean.INHERIT));
    p.setEnableSignedPush(getEnum(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setRequireSignedPush(getEnum(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, InheritableBoolean.INHERIT));
    p.setMaxObjectSizeLimit(rc.getString(RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT));
    p.setRejectImplicitMerges(getEnum(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, InheritableBoolean.INHERIT));
    p.setEnableReviewerByEmail(getEnum(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, InheritableBoolean.INHERIT));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, DEFAULT_SUBMIT_ACTION));
    p.setUseContentMerge(getEnum(rc, SUBMIT, null, KEY_MERGE_CONTENT, InheritableBoolean.INHERIT));
    p.setMatchAuthorToCommitterDate(getEnum(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, InheritableBoolean.INHERIT));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, DEFAULT_STATE_VALUE));
    p.setDefaultDashboard(rc.getString(DASHBOARD, null, KEY_DEFAULT));
    p.setLocalDefaultDashboard(rc.getString(DASHBOARD, null, KEY_LOCAL_DEFAULT));
    loadAccountsSection(rc);
    loadContributorAgreements(rc);
    loadAccessSections(rc);
    loadBranchOrderSection(rc);
    loadNotifySections(rc);
    loadLabelSections(rc);
    loadCommentLinkSections(rc);
    loadSubscribeSections(rc);
    mimeTypes = new ConfiguredMimeTypes(projectName.get(), rc);
    loadPluginSections(rc);
    loadReceiveSection(rc);
    loadExtensionPanelSections(rc);
}
#end_block

#method_before
private void loadAccountsSection(Config rc, Map<String, GroupReference> groupsByName) {
    accountsSection = new AccountsSection();
    accountsSection.setSameGroupVisibility(loadPermissionRules(rc, ACCOUNTS, null, KEY_SAME_GROUP_VISIBILITY, groupsByName, false));
}
#method_after
private void loadAccountsSection(Config rc) {
    accountsSection = new AccountsSection();
    accountsSection.setSameGroupVisibility(loadPermissionRules(rc, ACCOUNTS, null, KEY_SAME_GROUP_VISIBILITY, groupsByName, false));
}
#end_block

#method_before
private void loadContributorAgreements(Config rc, Map<String, GroupReference> groupsByName) {
    contributorAgreements = new HashMap<>();
    for (String name : rc.getSubsections(CONTRIBUTOR_AGREEMENT)) {
        ContributorAgreement ca = getContributorAgreement(name, true);
        ca.setDescription(rc.getString(CONTRIBUTOR_AGREEMENT, name, KEY_DESCRIPTION));
        ca.setAgreementUrl(rc.getString(CONTRIBUTOR_AGREEMENT, name, KEY_AGREEMENT_URL));
        ca.setAccepted(loadPermissionRules(rc, CONTRIBUTOR_AGREEMENT, name, KEY_ACCEPTED, groupsByName, false));
        List<PermissionRule> rules = loadPermissionRules(rc, CONTRIBUTOR_AGREEMENT, name, KEY_AUTO_VERIFY, groupsByName, false);
        if (rules.isEmpty()) {
            ca.setAutoVerify(null);
        } else if (rules.size() > 1) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + CONTRIBUTOR_AGREEMENT + "." + name + "." + KEY_AUTO_VERIFY + ": at most one group may be set"));
        } else if (rules.get(0).getAction() != Action.ALLOW) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + CONTRIBUTOR_AGREEMENT + "." + name + "." + KEY_AUTO_VERIFY + ": the group must be allowed"));
        } else {
            ca.setAutoVerify(rules.get(0).getGroup());
        }
    }
}
#method_after
private void loadContributorAgreements(Config rc) {
    contributorAgreements = new HashMap<>();
    for (String name : rc.getSubsections(CONTRIBUTOR_AGREEMENT)) {
        ContributorAgreement ca = getContributorAgreement(name, true);
        ca.setDescription(rc.getString(CONTRIBUTOR_AGREEMENT, name, KEY_DESCRIPTION));
        ca.setAgreementUrl(rc.getString(CONTRIBUTOR_AGREEMENT, name, KEY_AGREEMENT_URL));
        ca.setAccepted(loadPermissionRules(rc, CONTRIBUTOR_AGREEMENT, name, KEY_ACCEPTED, groupsByName, false));
        List<PermissionRule> rules = loadPermissionRules(rc, CONTRIBUTOR_AGREEMENT, name, KEY_AUTO_VERIFY, groupsByName, false);
        if (rules.isEmpty()) {
            ca.setAutoVerify(null);
        } else if (rules.size() > 1) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + CONTRIBUTOR_AGREEMENT + "." + name + "." + KEY_AUTO_VERIFY + ": at most one group may be set"));
        } else if (rules.get(0).getAction() != Action.ALLOW) {
            error(new ValidationError(PROJECT_CONFIG, "Invalid rule in " + CONTRIBUTOR_AGREEMENT + "." + name + "." + KEY_AUTO_VERIFY + ": the group must be allowed"));
        } else {
            ca.setAutoVerify(rules.get(0).getGroup());
        }
    }
}
#end_block

#method_before
private void loadNotifySections(Config rc, Map<String, GroupReference> groupsByName) {
    notifySections = new HashMap<>();
    for (String sectionName : rc.getSubsections(NOTIFY)) {
        NotifyConfig n = new NotifyConfig();
        n.setName(sectionName);
        n.setFilter(rc.getString(NOTIFY, sectionName, KEY_FILTER));
        EnumSet<NotifyType> types = EnumSet.noneOf(NotifyType.class);
        types.addAll(ConfigUtil.getEnumList(rc, NOTIFY, sectionName, KEY_TYPE, NotifyType.ALL));
        n.setTypes(types);
        n.setHeader(rc.getEnum(NOTIFY, sectionName, KEY_HEADER, NotifyConfig.Header.BCC));
        for (String dst : rc.getStringList(NOTIFY, sectionName, KEY_EMAIL)) {
            if (dst.startsWith("group ")) {
                String groupName = dst.substring(6).trim();
                GroupReference ref = groupsByName.get(groupName);
                if (ref == null) {
                    ref = new GroupReference(null, groupName);
                    groupsByName.put(ref.getName(), ref);
                }
                if (ref.getUUID() != null) {
                    n.addEmail(ref);
                } else {
                    error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GroupList.FILE_NAME));
                }
            } else if (dst.startsWith("user ")) {
                error(new ValidationError(PROJECT_CONFIG, dst + " not supported"));
            } else {
                try {
                    n.addEmail(Address.parse(dst));
                } catch (IllegalArgumentException err) {
                    error(new ValidationError(PROJECT_CONFIG, "notify section \"" + sectionName + "\" has invalid email \"" + dst + "\""));
                }
            }
        }
        notifySections.put(sectionName, n);
    }
}
#method_after
private void loadNotifySections(Config rc) {
    notifySections = new HashMap<>();
    for (String sectionName : rc.getSubsections(NOTIFY)) {
        NotifyConfig n = new NotifyConfig();
        n.setName(sectionName);
        n.setFilter(rc.getString(NOTIFY, sectionName, KEY_FILTER));
        EnumSet<NotifyType> types = EnumSet.noneOf(NotifyType.class);
        types.addAll(ConfigUtil.getEnumList(rc, NOTIFY, sectionName, KEY_TYPE, NotifyType.ALL));
        n.setTypes(types);
        n.setHeader(rc.getEnum(NOTIFY, sectionName, KEY_HEADER, NotifyConfig.Header.BCC));
        for (String dst : rc.getStringList(NOTIFY, sectionName, KEY_EMAIL)) {
            String groupName = GroupReference.extractGroupName(dst);
            if (groupName != null) {
                GroupReference ref = groupsByName.get(groupName);
                if (ref == null) {
                    ref = new GroupReference(null, groupName);
                    groupsByName.put(ref.getName(), ref);
                }
                if (ref.getUUID() != null) {
                    n.addEmail(ref);
                } else {
                    error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GroupList.FILE_NAME));
                }
            } else if (dst.startsWith("user ")) {
                error(new ValidationError(PROJECT_CONFIG, dst + " not supported"));
            } else {
                try {
                    n.addEmail(Address.parse(dst));
                } catch (IllegalArgumentException err) {
                    error(new ValidationError(PROJECT_CONFIG, "notify section \"" + sectionName + "\" has invalid email \"" + dst + "\""));
                }
            }
        }
        notifySections.put(sectionName, n);
    }
}
#end_block

#method_before
private void loadAccessSections(Config rc, Map<String, GroupReference> groupsByName) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    n = convertLegacyPermission(n);
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                String convertedName = convertLegacyPermission(varName);
                if (isPermission(convertedName)) {
                    Permission perm = as.getPermission(convertedName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(convertedName));
                } else {
                    sectionsWithUnknownPermissions.add(as.getName());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#method_after
private void loadAccessSections(Config rc) {
    accessSections = new HashMap<>();
    sectionsWithUnknownPermissions = new HashSet<>();
    for (String refName : rc.getSubsections(ACCESS)) {
        if (RefConfigSection.isValid(refName) && isValidRegex(refName)) {
            AccessSection as = getAccessSection(refName, true);
            for (String varName : rc.getStringList(ACCESS, refName, KEY_GROUP_PERMISSIONS)) {
                for (String n : varName.split("[, \t]{1,}")) {
                    n = convertLegacyPermission(n);
                    if (isPermission(n)) {
                        as.getPermission(n, true).setExclusiveGroup(true);
                    }
                }
            }
            for (String varName : rc.getNames(ACCESS, refName)) {
                String convertedName = convertLegacyPermission(varName);
                if (isPermission(convertedName)) {
                    Permission perm = as.getPermission(convertedName, true);
                    loadPermissionRules(rc, ACCESS, refName, varName, groupsByName, perm, Permission.hasRange(convertedName));
                } else {
                    sectionsWithUnknownPermissions.add(as.getName());
                }
            }
        }
    }
    AccessSection capability = null;
    for (String varName : rc.getNames(CAPABILITY)) {
        if (capability == null) {
            capability = new AccessSection(AccessSection.GLOBAL_CAPABILITIES);
            accessSections.put(AccessSection.GLOBAL_CAPABILITIES, capability);
        }
        Permission perm = capability.getPermission(varName, true);
        loadPermissionRules(rc, CAPABILITY, null, varName, groupsByName, perm, GlobalCapability.hasRange(varName));
    }
}
#end_block

#method_before
private void loadPluginSections(Config rc) {
    pluginConfigs = new HashMap<>();
    for (String plugin : rc.getSubsections(PLUGIN)) {
        Config pluginConfig = new Config();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            String value = rc.getString(PLUGIN, plugin, name);
            if (value.startsWith("Group[")) {
                GroupReference refFromString = GroupReference.fromString(value);
                GroupReference ref = groupList.byUUID(refFromString.getUUID());
                if (ref == null) {
                    ref = refFromString;
                    error(new ValidationError(PROJECT_CONFIG, "group \"" + ref.getName() + "\" not in " + GroupList.FILE_NAME));
                }
                rc.setString(PLUGIN, plugin, name, ref.toString());
            }
            pluginConfig.setStringList(PLUGIN, plugin, name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#method_after
private void loadPluginSections(Config rc) {
    pluginConfigs = new HashMap<>();
    for (String plugin : rc.getSubsections(PLUGIN)) {
        Config pluginConfig = new Config();
        pluginConfigs.put(plugin, pluginConfig);
        for (String name : rc.getNames(PLUGIN, plugin)) {
            String value = rc.getString(PLUGIN, plugin, name);
            String groupName = GroupReference.extractGroupName(value);
            if (groupName != null) {
                GroupReference ref = groupsByName.get(groupName);
                if (ref == null) {
                    error(new ValidationError(PROJECT_CONFIG, "group \"" + groupName + "\" not in " + GroupList.FILE_NAME));
                }
                rc.setString(PLUGIN, plugin, name, value);
            }
            pluginConfig.setStringList(PLUGIN, plugin, name, Arrays.asList(rc.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, PROJECT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, p.getMatchAuthorToCommitterDate(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, p.getEnableReviewerByEmail(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.getUseContributorAgreements(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.getUseSignedOffBy(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.getRequireChangeID(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_USE_ALL_NOT_IN_TARGET, p.getCreateNewChangeForAllNotInTarget(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_MAX_OBJECT_SIZE_LIMIT, validMaxObjectSizeLimit(p.getMaxObjectSizeLimit()));
    set(rc, RECEIVE, null, KEY_ENABLE_SIGNED_PUSH, p.getEnableSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_PUSH, p.getRequireSignedPush(), InheritableBoolean.INHERIT);
    set(rc, RECEIVE, null, KEY_REJECT_IMPLICIT_MERGES, p.getRejectImplicitMerges(), InheritableBoolean.INHERIT);
    set(rc, REVIEWER, null, KEY_ENABLE_REVIEWER_BY_EMAIL, p.getEnableReviewerByEmail(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), DEFAULT_SUBMIT_ACTION);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.getUseContentMerge(), InheritableBoolean.INHERIT);
    set(rc, SUBMIT, null, KEY_MATCH_AUTHOR_DATE_WITH_COMMITTER_DATE, p.getMatchAuthorToCommitterDate(), InheritableBoolean.INHERIT);
    set(rc, PROJECT, null, KEY_STATE, p.getState(), DEFAULT_STATE_VALUE);
    set(rc, DASHBOARD, null, KEY_DEFAULT, p.getDefaultDashboard());
    set(rc, DASHBOARD, null, KEY_LOCAL_DEFAULT, p.getLocalDefaultDashboard());
    Set<AccountGroup.UUID> keepGroups = new HashSet<>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    savePluginSections(rc, keepGroups);
    groupList.retainUUIDs(keepGroups);
    saveLabelSections(rc);
    saveSubscribeSections(rc);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
    return true;
}
#end_block

#method_before
private void savePluginSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, Config> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        Config pluginConfig = e.getValue();
        for (String name : pluginConfig.getNames(PLUGIN, plugin)) {
            String value = pluginConfig.getString(PLUGIN, plugin, name);
            if (value.startsWith("Group[")) {
                GroupReference ref = resolve(GroupReference.fromString(value));
                if (ref.getUUID() != null) {
                    keepGroups.add(ref.getUUID());
                    pluginConfig.setString(PLUGIN, plugin, name, ref.toString());
                }
            }
            rc.setStringList(PLUGIN, plugin, name, Arrays.asList(pluginConfig.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#method_after
private void savePluginSections(Config rc, Set<AccountGroup.UUID> keepGroups) {
    List<String> existing = Lists.newArrayList(rc.getSubsections(PLUGIN));
    for (String name : existing) {
        rc.unsetSection(PLUGIN, name);
    }
    for (Entry<String, Config> e : pluginConfigs.entrySet()) {
        String plugin = e.getKey();
        Config pluginConfig = e.getValue();
        for (String name : pluginConfig.getNames(PLUGIN, plugin)) {
            String value = pluginConfig.getString(PLUGIN, plugin, name);
            String groupName = GroupReference.extractGroupName(value);
            if (groupName != null) {
                GroupReference ref = groupsByName.get(groupName);
                if (ref != null && ref.getUUID() != null) {
                    keepGroups.add(ref.getUUID());
                    pluginConfig.setString(PLUGIN, plugin, name, "group " + ref.getName());
                }
            }
            rc.setStringList(PLUGIN, plugin, name, Arrays.asList(pluginConfig.getStringList(PLUGIN, plugin, name)));
        }
    }
}
#end_block

#method_before
public ReviewerAddition prepare(ChangeNotes notes, CurrentUser user, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    requireNonNull(input.reviewer);
    ListMultimap<RecipientType, Account.Id> accountsToNotify;
    try {
        accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    } catch (BadRequestException e) {
        return fail(input, FailureType.OTHER, e.getMessage());
    }
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(notes.getProjectName()).is(BooleanProjectConfig.ENABLE_REVIEWER_BY_EMAIL);
    ReviewerAddition byAccountId = addByAccountId(input, notes, user, accountsToNotify, allowGroup, allowByEmail);
    ReviewerAddition wholeGroup = null;
    if (byAccountId == null || !byAccountId.exactMatchFound) {
        wholeGroup = addWholeGroup(input, notes, user, accountsToNotify, confirmed, allowGroup, allowByEmail);
        if (wholeGroup != null && wholeGroup.exactMatchFound) {
            return wholeGroup;
        }
    }
    if (byAccountId != null) {
        return byAccountId;
    }
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(input, notes, user, accountsToNotify);
}
#method_after
public ReviewerAddition prepare(ChangeNotes notes, CurrentUser user, AddReviewerInput input, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    requireNonNull(input.reviewer);
    ListMultimap<RecipientType, Account.Id> accountsToNotify;
    try {
        accountsToNotify = notifyUtil.resolveAccounts(input.notifyDetails);
    } catch (BadRequestException e) {
        return fail(input, FailureType.OTHER, e.getMessage());
    }
    boolean confirmed = input.confirmed();
    boolean allowByEmail = projectCache.checkedGet(notes.getProjectName()).is(BooleanProjectConfig.ENABLE_REVIEWER_BY_EMAIL);
    ReviewerAddition byAccountId = addByAccountId(input, notes, user, accountsToNotify);
    ReviewerAddition wholeGroup = null;
    if (!byAccountId.exactMatchFound) {
        wholeGroup = addWholeGroup(input, notes, user, accountsToNotify, confirmed, allowGroup, allowByEmail);
        if (wholeGroup != null && wholeGroup.exactMatchFound) {
            return wholeGroup;
        }
    }
    if (byAccountId != null && wholeGroup != null && byAccountId.failureType == FailureType.NOT_FOUND && wholeGroup.failureType == FailureType.NOT_FOUND) {
        return fail(byAccountId.input, FailureType.NOT_FOUND, byAccountId.result.error + "\n" + wholeGroup.result.error);
    }
    if (byAccountId != null && byAccountId.failureType != FailureType.NOT_FOUND) {
        return byAccountId;
    }
    if (wholeGroup != null) {
        return wholeGroup;
    }
    return addByEmail(input, notes, user, accountsToNotify);
}
#end_block

#method_before
@Nullable
private ReviewerAddition addByAccountId(AddReviewerInput input, ChangeNotes notes, CurrentUser user, ListMultimap<RecipientType, Account.Id> accountsToNotify, boolean allowGroup, boolean allowByEmail) throws OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    IdentifiedUser reviewerUser;
    boolean exactMatchFound = false;
    try {
        reviewerUser = accountResolver.resolve(input.reviewer).asUniqueUser();
        if (input.reviewer.equalsIgnoreCase(reviewerUser.getName()) || input.reviewer.equals(String.valueOf(reviewerUser.getAccountId()))) {
            exactMatchFound = true;
        }
    } catch (UnprocessableEntityException e) {
        if (!allowGroup && !allowByEmail) {
            // Only return failure if we aren't going to try other interpretations.
            return fail(input, FailureType.NOT_FOUND, MessageFormat.format(ChangeMessages.get().reviewerNotFoundUser, input.reviewer));
        }
        return null;
    }
    if (isValidReviewer(notes.getChange().getDest(), reviewerUser.getAccount())) {
        return new ReviewerAddition(input, notes, user, ImmutableSet.of(reviewerUser.getAccountId()), null, accountsToNotify, exactMatchFound);
    }
    if (!reviewerUser.getAccount().isActive()) {
        if (allowByEmail && input.state() == CC) {
            return null;
        }
        return fail(input, FailureType.OTHER, MessageFormat.format(ChangeMessages.get().reviewerInactive, input.reviewer));
    }
    return fail(input, FailureType.OTHER, MessageFormat.format(ChangeMessages.get().reviewerCantSeeChange, input.reviewer));
}
#method_after
@Nullable
private ReviewerAddition addByAccountId(AddReviewerInput input, ChangeNotes notes, CurrentUser user, ListMultimap<RecipientType, Account.Id> accountsToNotify) throws OrmException, PermissionBackendException, IOException, ConfigInvalidException {
    IdentifiedUser reviewerUser;
    boolean exactMatchFound = false;
    try {
        reviewerUser = accountResolver.resolve(input.reviewer).asUniqueUser();
        if (input.reviewer.equalsIgnoreCase(reviewerUser.getName()) || input.reviewer.equals(String.valueOf(reviewerUser.getAccountId()))) {
            exactMatchFound = true;
        }
    } catch (UnprocessableEntityException e) {
        // group, but if not, the error message will be useful.
        return fail(input, FailureType.NOT_FOUND, e.getMessage());
    }
    if (isValidReviewer(notes.getChange().getDest(), reviewerUser.getAccount())) {
        return new ReviewerAddition(input, notes, user, ImmutableSet.of(reviewerUser.getAccountId()), null, accountsToNotify, exactMatchFound);
    }
    return fail(input, FailureType.OTHER, MessageFormat.format(ChangeMessages.get().reviewerCantSeeChange, input.reviewer));
}
#end_block

#method_before
private boolean isValidReviewer(Branch.NameKey branch, Account member) throws PermissionBackendException {
    if (!member.isActive()) {
        return false;
    }
    try {
        // Check ref permission instead of change permission, since change permissions take into
        // account the private bit, whereas adding a user as a reviewer is explicitly allowing them to
        // see private changes.
        permissionBackend.absentUser(member.getId()).ref(branch).check(RefPermission.READ);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#method_after
private boolean isValidReviewer(Branch.NameKey branch, Account member) throws PermissionBackendException {
    try {
        // Check ref permission instead of change permission, since change permissions take into
        // account the private bit, whereas adding a user as a reviewer is explicitly allowing them to
        // see private changes.
        permissionBackend.absentUser(member.getId()).ref(branch).check(RefPermission.READ);
        return true;
    } catch (AuthException e) {
        return false;
    }
}
#end_block

#method_before
public ReviewerAdditionList prepare(ChangeNotes notes, CurrentUser user, Iterable<? extends AddReviewerInput> inputs, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Process CC ops before reviewer ops, so a user that appears in both lists ends up as a
    // reviewer; the last call to ChangeUpdate#putReviewer wins. This can happen if the caller
    // specifies the same string twice, or less obviously if they specify multiple groups with
    // overlapping members.
    // TODO(dborowitz): Consider changing interface to allow excluding reviewers that were
    // previously processed, to proactively prevent overlap so we don't have to rely on this subtle
    // behavior.
    ImmutableList<AddReviewerInput> sorted = Streams.stream(inputs).sorted(comparing(i -> i.state(), Ordering.explicit(ReviewerState.CC, ReviewerState.REVIEWER))).collect(toImmutableList());
    List<ReviewerAddition> additions = new ArrayList<>();
    for (AddReviewerInput input : sorted) {
        additions.add(prepare(notes, user, input, allowGroup));
    }
    return new ReviewerAdditionList(additions);
}
#method_after
public ReviewerAdditionList prepare(ChangeNotes notes, CurrentUser user, Iterable<? extends AddReviewerInput> inputs, boolean allowGroup) throws OrmException, IOException, PermissionBackendException, ConfigInvalidException {
    // Process CC ops before reviewer ops, so a user that appears in both lists ends up as a
    // reviewer; the last call to ChangeUpdate#putReviewer wins. This can happen if the caller
    // specifies the same string twice, or less obviously if they specify multiple groups with
    // overlapping members.
    // TODO(dborowitz): Consider changing interface to allow excluding reviewers that were
    // previously processed, to proactively prevent overlap so we don't have to rely on this subtle
    // behavior.
    ImmutableList<AddReviewerInput> sorted = Streams.stream(inputs).sorted(comparing(AddReviewerInput::state, Ordering.explicit(ReviewerState.CC, ReviewerState.REVIEWER))).collect(toImmutableList());
    List<ReviewerAddition> additions = new ArrayList<>();
    for (AddReviewerInput input : sorted) {
        additions.add(prepare(notes, user, input, allowGroup));
    }
    return new ReviewerAdditionList(additions);
}
#end_block

#method_before
public static String exceptionMessage(Result result) {
    checkArgument(result.asList().size() != 1);
    if (result.asList().isEmpty()) {
        if (result.isSelf()) {
            return "Resolving account '" + result.input() + "' requires login";
        }
        // into account.
        return "Account '" + result.input() + "' not found";
    }
    return result.asList().stream().map(AccountState::getAccount).map(a -> a.getId() + ": " + a.getNameEmail(result.accountResolver().anonymousCowardName)).collect(joining("\n", "Account '" + result.input() + "' is ambiguous:\n", ""));
}
#method_after
public static String exceptionMessage(Result result) {
    checkArgument(result.asList().size() != 1);
    if (result.asList().isEmpty()) {
        if (result.isSelf()) {
            return "Resolving account '" + result.input() + "' requires login";
        }
        if (result.filteredInactive().isEmpty()) {
            return "Account '" + result.input() + "' not found";
        }
        return result.filteredInactive().stream().map(a -> formatForException(result, a)).collect(joining("\n", "Account '" + result.input() + "' only matches inactive accounts. To use an inactive account, retry with" + " one of the following exact account IDs:\n", ""));
    }
    return result.asList().stream().map(a -> formatForException(result, a)).collect(joining("\n", "Account '" + result.input() + "' is ambiguous:\n", ""));
}
#end_block

#method_before
public IdentifiedUser asUniqueUserOnBehalfOf(CurrentUser caller) throws UnresolvableAccountException {
    ensureUnique();
    if (isSelf()) {
        // TODO(dborowitz): This preserves old behavior, but it seems wrong to discard the caller.
        return self.get().asIdentifiedUser();
    }
    return userFactory.runAs(null, list.get(0).getAccount().getId(), requireNonNull(caller));
}
#method_after
public IdentifiedUser asUniqueUserOnBehalfOf(CurrentUser caller) throws UnresolvableAccountException {
    ensureUnique();
    if (isSelf()) {
        // TODO(dborowitz): This preserves old behavior, but it seems wrong to discard the caller.
        return self.get().asIdentifiedUser();
    }
    return userFactory.runAs(null, list.get(0).getAccount().getId(), requireNonNull(caller).getRealUser());
}
#end_block

#method_before
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#method_after
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Account.Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#end_block

#method_before
@VisibleForTesting
Result searchImpl(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws OrmException, ConfigInvalidException, IOException {
    visibilitySupplier = Suppliers.memoize(visibilitySupplier::get);
    for (Searcher<?> searcher : searchers) {
        Optional<Result> result = trySearch(searcher, input, visibilitySupplier);
        if (result.isPresent()) {
            return result.get();
        }
    }
    return emptyResult(input);
}
#method_after
@VisibleForTesting
Result searchImpl(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws OrmException, ConfigInvalidException, IOException {
    visibilitySupplier = Suppliers.memoize(visibilitySupplier::get);
    List<AccountState> inactive = new ArrayList<>();
    for (Searcher<?> searcher : searchers) {
        Optional<Stream<AccountState>> maybeResults = searcher.trySearch(input);
        if (!maybeResults.isPresent()) {
            continue;
        }
        Stream<AccountState> results = maybeResults.get();
        if (!searcher.callerMayAssumeCandidatesAreVisible()) {
            results = results.filter(visibilitySupplier.get());
        }
        List<AccountState> list;
        if (searcher.callerShouldFilterOutInactiveCandidates()) {
            // Keep track of all inactive candidates discovered by any searchers. If we end up short-
            // circuiting, the inactive list will be discarded.
            List<AccountState> active = new ArrayList<>();
            results.forEach(a -> (a.getAccount().isActive() ? active : inactive).add(a));
            list = active;
        } else {
            list = results.collect(toImmutableList());
        }
        if (!list.isEmpty()) {
            return createResult(input, list);
        }
        if (searcher.shortCircuitIfNoResults()) {
            // For a short-circuiting searcher, return results even if empty.
            return !inactive.isEmpty() ? emptyResult(input, inactive) : createResult(input, list);
        }
    }
    return emptyResult(input, inactive);
}
#end_block

#method_before
private Result createResult(String input, ImmutableList<AccountState> list, Searcher<?> searcher) {
    return new Result(input, list, Optional.of(searcher.toString()));
}
#method_after
private Result createResult(String input, List<AccountState> list) {
    return new Result(input, list, ImmutableList.of());
}
#end_block

#method_before
private Result emptyResult(String input) {
    return new Result(input, ImmutableList.of(), Optional.empty());
}
#method_after
private Result emptyResult(String input, List<AccountState> inactive) {
    return new Result(input, ImmutableList.of(), inactive);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> ext(String ext) {
    return extension(ext);
}
#method_after
@Operator
public Predicate<ChangeData> ext(String ext) throws QueryParseException {
    return extension(ext);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> extension(String ext) {
    return new FileExtensionPredicate(ext);
}
#method_after
@Operator
public Predicate<ChangeData> extension(String ext) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXTENSION)) {
        return new FileExtensionPredicate(ext);
    }
    throw new QueryParseException("'extension' operator is not supported by change index version");
}
#end_block

#method_before
@Test
public void onlyExactIdReturnsInactiveAccounts() throws Exception {
    TestAccount account = accountOperations.account(accountOperations.newAccount().fullname("Inactiveuser Name").preferredEmail("inactiveuser@example.com").username("inactiveusername").create()).get();
    Account.Id id = account.accountId();
    ImmutableList<String> inputs = ImmutableList.of(account.fullname().get() + " (" + account.accountId() + ")", account.fullname().get(), account.preferredEmail().get(), account.fullname().get() + "<" + account.preferredEmail().get() + ">", Splitter.on(' ').splitToList(account.fullname().get()).get(0));
    assertThat(resolve(account.accountId())).containsExactly(id);
    for (String input : inputs) {
        assertThat(resolve(input)).named("results for %s (active)", input).containsExactly(id);
    }
    gApi.accounts().id(id.get()).setActive(false);
    assertThat(resolve(account.accountId())).containsExactly(id);
    for (String input : inputs) {
        assertThat(resolve(input)).named("results for %s (inactive)", input).isEmpty();
        assertThat(resolveByNameOrEmail(input)).named("results by name or email for %s (inactive)", input).isEmpty();
    }
}
#method_after
@Test
public void onlyExactIdReturnsInactiveAccounts() throws Exception {
    TestAccount account = accountOperations.account(accountOperations.newAccount().fullname("Inactiveuser Name").preferredEmail("inactiveuser@example.com").username("inactiveusername").create()).get();
    Account.Id id = account.accountId();
    String nameEmail = account.fullname().get() + " <" + account.preferredEmail().get() + ">";
    ImmutableList<String> inputs = ImmutableList.of(account.fullname().get() + " (" + account.accountId() + ")", account.fullname().get(), account.preferredEmail().get(), nameEmail, Splitter.on(' ').splitToList(account.fullname().get()).get(0));
    assertThat(resolve(account.accountId())).containsExactly(id);
    for (String input : inputs) {
        assertThat(resolve(input)).named("results for %s (active)", input).containsExactly(id);
    }
    gApi.accounts().id(id.get()).setActive(false);
    assertThat(resolve(account.accountId())).containsExactly(id);
    for (String input : inputs) {
        Result result = accountResolver.resolve(input);
        assertThat(result.asIdSet()).named("results for %s (inactive)", input).isEmpty();
        try {
            result.asUnique();
            assert_().fail("expected UnresolvableAccountException");
        } catch (UnresolvableAccountException e) {
            assertThat(e).hasMessageThat().isEqualTo("Account '" + input + "' only matches inactive accounts. To use an inactive account, retry" + " with one of the following exact account IDs:\n" + id + ": " + nameEmail);
        }
        assertThat(resolveByNameOrEmail(input)).named("results by name or email for %s (inactive)", input).isEmpty();
    }
}
#end_block

#method_before
public static String exceptionMessage(Result result) {
    checkArgument(result.asList().size() != 1);
    if (result.asList().isEmpty()) {
        if (result.isSelf()) {
            return "Resolving account '" + result.input() + "' requires login";
        }
        // into account.
        return "Account '" + result.input() + "' not found";
    }
    return result.asList().stream().map(AccountState::getAccount).map(a -> a.getId() + ": " + a.getNameEmail(result.accountResolver().anonymousCowardName)).collect(joining("\n", "Account '" + result.input() + "' is ambiguous:\n", ""));
}
#method_after
public static String exceptionMessage(Result result) {
    checkArgument(result.asList().size() != 1);
    if (result.asList().isEmpty()) {
        if (result.isSelf()) {
            return "Resolving account '" + result.input() + "' requires login";
        }
        if (result.filteredInactive().isEmpty()) {
            return "Account '" + result.input() + "' not found";
        }
        return result.filteredInactive().stream().map(a -> formatForException(result, a)).collect(joining("\n", "Account '" + result.input() + "' only matches inactive accounts. To use an inactive account, retry with" + " one of the following exact account IDs:\n", ""));
    }
    return result.asList().stream().map(a -> formatForException(result, a)).collect(joining("\n", "Account '" + result.input() + "' is ambiguous:\n", ""));
}
#end_block

#method_before
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#method_after
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Account.Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#end_block

#method_before
@VisibleForTesting
Result searchImpl(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws OrmException, ConfigInvalidException, IOException {
    visibilitySupplier = Suppliers.memoize(visibilitySupplier::get);
    for (Searcher<?> searcher : searchers) {
        Optional<Result> result = trySearch(searcher, input, visibilitySupplier);
        if (result.isPresent()) {
            return result.get();
        }
    }
    return emptyResult(input);
}
#method_after
@VisibleForTesting
Result searchImpl(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws OrmException, ConfigInvalidException, IOException {
    visibilitySupplier = Suppliers.memoize(visibilitySupplier::get);
    List<AccountState> inactive = new ArrayList<>();
    for (Searcher<?> searcher : searchers) {
        Optional<Stream<AccountState>> maybeResults = searcher.trySearch(input);
        if (!maybeResults.isPresent()) {
            continue;
        }
        Stream<AccountState> results = maybeResults.get();
        if (!searcher.callerMayAssumeCandidatesAreVisible()) {
            results = results.filter(visibilitySupplier.get());
        }
        List<AccountState> list;
        if (searcher.callerShouldFilterOutInactiveCandidates()) {
            // Keep track of all inactive candidates discovered by any searchers. If we end up short-
            // circuiting, the inactive list will be discarded.
            List<AccountState> active = new ArrayList<>();
            results.forEach(a -> (a.getAccount().isActive() ? active : inactive).add(a));
            list = active;
        } else {
            list = results.collect(toImmutableList());
        }
        if (!list.isEmpty()) {
            return createResult(input, list);
        }
        if (searcher.shortCircuitIfNoResults()) {
            // For a short-circuiting searcher, return results even if empty.
            return !inactive.isEmpty() ? emptyResult(input, inactive) : createResult(input, list);
        }
    }
    return emptyResult(input, inactive);
}
#end_block

#method_before
private Result createResult(String input, ImmutableList<AccountState> list, Searcher<?> searcher) {
    return new Result(input, list, Optional.of(searcher.toString()));
}
#method_after
private Result createResult(String input, List<AccountState> list) {
    return new Result(input, list, ImmutableList.of());
}
#end_block

#method_before
private Result emptyResult(String input) {
    return new Result(input, ImmutableList.of(), Optional.empty());
}
#method_after
private Result emptyResult(String input, List<AccountState> inactive) {
    return new Result(input, ImmutableList.of(), inactive);
}
#end_block

#method_before
@Test
public void noShortCircuit() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("foo", false, newAccount(1)), new TestSearcher("bar", false, newAccount(2), newAccount(3)));
    Result result = search("foo", searchers, allVisible());
    assertThat(result.input()).isEqualTo("foo");
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1));
    assertThat(result.searcher()).hasValue("foo(1)");
    result = search("bar", searchers, allVisible());
    assertThat(result.input()).isEqualTo("bar");
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(2, 3));
    assertThat(result.searcher()).hasValue("bar(2,3)");
    result = search("baz", searchers, allVisible());
    assertThat(result.input()).isEqualTo("baz");
    assertThat(result.asIdSet()).isEmpty();
    assertThat(result.searcher()).isEmpty();
}
#method_after
@Test
public void noShortCircuit() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("foo", false, newAccount(1)), new TestSearcher("bar", false, newAccount(2), newAccount(3)));
    Result result = search("foo", searchers, allVisible());
    assertThat(result.input()).isEqualTo("foo");
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1));
    result = search("bar", searchers, allVisible());
    assertThat(result.input()).isEqualTo("bar");
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(2, 3));
    result = search("baz", searchers, allVisible());
    assertThat(result.input()).isEqualTo("baz");
    assertThat(result.asIdSet()).isEmpty();
}
#end_block

#method_before
@Test
public void shortCircuit() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("f.*", true), new TestSearcher("foo|bar", false, newAccount(1)));
    Result result = search("foo", searchers, allVisible());
    assertThat(result.input()).isEqualTo("foo");
    assertThat(result.asIdSet()).isEmpty();
    assertThat(result.searcher()).hasValue("f.*()");
    result = search("bar", searchers, allVisible());
    assertThat(result.input()).isEqualTo("bar");
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1));
    assertThat(result.searcher()).hasValue("foo|bar(1)");
}
#method_after
@Test
public void shortCircuit() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("f.*", true), new TestSearcher("foo|bar", false, newAccount(1)));
    Result result = search("foo", searchers, allVisible());
    assertThat(result.input()).isEqualTo("foo");
    assertThat(result.asIdSet()).isEmpty();
    result = search("bar", searchers, allVisible());
    assertThat(result.input()).isEqualTo("bar");
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1));
}
#end_block

#method_before
@Test
public void dontShortCircuitAfterFilteringInactiveCandidatesResultsInEmptyList() throws Exception {
    AccountState account1 = newAccount(1);
    AccountState account2 = newInactiveAccount(2);
    TestSearcher searcher1 = new TestSearcher("foo", false, account2);
    searcher1.setCallerShouldFilterOutInactiveCandidates();
    TestSearcher searcher2 = new TestSearcher("foo", false, account1, account2);
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(searcher1, searcher2);
    // searcher1 matched, but filtered out all candidates because account2 is inactive. Actual
    // result came from searcher2 instead.
    Result result = search("foo", searchers, allVisible());
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1, 2));
    assertThat(result.searcher()).hasValue("foo(1,2)");
}
#method_after
@Test
public void dontShortCircuitAfterFilteringInactiveCandidatesResultsInEmptyList() throws Exception {
    AccountState account1 = newAccount(1);
    AccountState account2 = newInactiveAccount(2);
    TestSearcher searcher1 = new TestSearcher("foo", false, account2);
    searcher1.setCallerShouldFilterOutInactiveCandidates();
    TestSearcher searcher2 = new TestSearcher("foo", false, account1, account2);
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(searcher1, searcher2);
    // searcher1 matched, but filtered out all candidates because account2 is inactive. Actual
    // result came from searcher2 instead.
    Result result = search("foo", searchers, allVisible());
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1, 2));
}
#end_block

#method_before
@Test
public void shortCircuitAfterFilteringInactiveCandidatesResultsInEmptyList() throws Exception {
    AccountState account1 = newAccount(1);
    AccountState account2 = newInactiveAccount(2);
    TestSearcher searcher1 = new TestSearcher("foo", true, account2);
    searcher1.setCallerShouldFilterOutInactiveCandidates();
    TestSearcher searcher2 = new TestSearcher("foo", false, account1, account2);
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(searcher1, searcher2);
    // searcher1 matched and then filtered out all candidates because account2 is inactive, but
    // still short-circuited.
    Result result = search("foo", searchers, allVisible());
    assertThat(result.asIdSet()).isEmpty();
    assertThat(result.searcher()).hasValue("foo(2)");
}
#method_after
@Test
public void shortCircuitAfterFilteringInactiveCandidatesResultsInEmptyList() throws Exception {
    AccountState account1 = newAccount(1);
    AccountState account2 = newInactiveAccount(2);
    TestSearcher searcher1 = new TestSearcher("foo", true, account2);
    searcher1.setCallerShouldFilterOutInactiveCandidates();
    TestSearcher searcher2 = new TestSearcher("foo", false, account1, account2);
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(searcher1, searcher2);
    // searcher1 matched and then filtered out all candidates because account2 is inactive, but
    // still short-circuited.
    Result result = search("foo", searchers, allVisible());
    assertThat(result.asIdSet()).isEmpty();
    assertThat(filteredInactiveIds(result)).containsExactlyElementsIn(ids(2));
}
#end_block

#method_before
@Test
public void asUniqueWithNoResults() throws Exception {
    try {
        String input = "foo";
        ImmutableList<Searcher<?>> searchers = ImmutableList.of();
        Supplier<Predicate<AccountState>> visibilitySupplier = allVisible();
        search(input, searchers, visibilitySupplier).asUnique();
        assert_().fail("Expected UnprocessableEntityException");
    } catch (UnprocessableEntityException e) {
        assertThat(e).hasMessageThat().isEqualTo("Account 'foo' not found");
    }
}
#method_after
@Test
public void asUniqueWithNoResults() throws Exception {
    try {
        String input = "foo";
        ImmutableList<Searcher<?>> searchers = ImmutableList.of();
        Supplier<Predicate<AccountState>> visibilitySupplier = allVisible();
        search(input, searchers, visibilitySupplier).asUnique();
        assert_().fail("Expected UnresolvableAccountException");
    } catch (UnresolvableAccountException e) {
        assertThat(e).hasMessageThat().isEqualTo("Account 'foo' not found");
    }
}
#end_block

#method_before
@Test
public void asUniqueWithMultipleResults() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("foo", false, newAccount(1), newAccount(2)));
    try {
        search("foo", searchers, allVisible()).asUnique();
        assert_().fail("Expected UnprocessableEntityException");
    } catch (UnprocessableEntityException e) {
        assertThat(e).hasMessageThat().isEqualTo("Account 'foo' is ambiguous:\n1: Anonymous Name (1)\n2: Anonymous Name (2)");
    }
}
#method_after
@Test
public void asUniqueWithMultipleResults() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("foo", false, newAccount(1), newAccount(2)));
    try {
        search("foo", searchers, allVisible()).asUnique();
        assert_().fail("Expected UnresolvableAccountException");
    } catch (UnresolvableAccountException e) {
        assertThat(e).hasMessageThat().isEqualTo("Account 'foo' is ambiguous:\n1: Anonymous Name (1)\n2: Anonymous Name (2)");
    }
}
#end_block

#method_before
private Result search(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws Exception {
    return new AccountResolver2(null, null, null, null, null, null, null, "Anonymous Name").searchImpl(input, searchers, visibilitySupplier);
}
#method_after
private Result search(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws Exception {
    return newAccountResolver().searchImpl(input, searchers, visibilitySupplier);
}
#end_block

#method_before
@Test
public void dontFilterInactive() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("foo", false, newInactiveAccount(1)), new TestSearcher("f.*", false, newInactiveAccount(2)));
    Result result = search("foo", searchers, allVisible());
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1));
    assertThat(getOnlyElement(result.asList()).getAccount().isActive()).isFalse();
    assertThat(filteredInactiveIds(result)).isEmpty();
}
#method_after
@Test
public void dontFilterInactive() throws Exception {
    ImmutableList<Searcher<?>> searchers = ImmutableList.of(new TestSearcher("foo", false, newInactiveAccount(1)), new TestSearcher("f.*", false, newInactiveAccount(2)));
    Result result = search("foo", searchers, allVisible());
    // Searchers always short-circuit when finding a non-empty result list, and this one didn't
    // filter out inactive results, so the second searcher never ran.
    assertThat(result.asIdSet()).containsExactlyElementsIn(ids(1));
    assertThat(getOnlyElement(result.asList()).getAccount().isActive()).isFalse();
    assertThat(filteredInactiveIds(result)).isEmpty();
}
#end_block

#method_before
@VisibleForTesting
Result searchImpl(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws OrmException, ConfigInvalidException, IOException {
    visibilitySupplier = Suppliers.memoize(visibilitySupplier::get);
    List<AccountState> inactive = new ArrayList<>();
    for (Searcher<?> searcher : searchers) {
        Optional<Stream<AccountState>> maybeResults = searcher.trySearch(input);
        if (!maybeResults.isPresent()) {
            continue;
        }
        Stream<AccountState> results = maybeResults.get();
        if (!searcher.callerMayAssumeCandidatesAreVisible()) {
            results = results.filter(visibilitySupplier.get());
        }
        List<AccountState> list;
        if (searcher.callerShouldFilterOutInactiveCandidates()) {
            // Keep track of all inactive candidates discovered by any searchers. If we end up short-
            // circuiting, the inactive list will be discarded.
            List<AccountState> active = new ArrayList<>();
            results.forEach(a -> (a.getAccount().isActive() ? active : inactive).add(a));
            list = active;
        } else {
            list = results.collect(toImmutableList());
        }
        if (!list.isEmpty()) {
            return createResult(input, list, searcher);
        }
        if (searcher.shortCircuitIfNoResults()) {
            // For a short-circuiting searcher, return results even if empty.
            return !inactive.isEmpty() ? emptyResult(input, inactive) : createResult(input, list, searcher);
        }
    }
    return emptyResult(input, inactive);
}
#method_after
@VisibleForTesting
Result searchImpl(String input, ImmutableList<Searcher<?>> searchers, Supplier<Predicate<AccountState>> visibilitySupplier) throws OrmException, ConfigInvalidException, IOException {
    visibilitySupplier = Suppliers.memoize(visibilitySupplier::get);
    List<AccountState> inactive = new ArrayList<>();
    for (Searcher<?> searcher : searchers) {
        Optional<Stream<AccountState>> maybeResults = searcher.trySearch(input);
        if (!maybeResults.isPresent()) {
            continue;
        }
        Stream<AccountState> results = maybeResults.get();
        if (!searcher.callerMayAssumeCandidatesAreVisible()) {
            results = results.filter(visibilitySupplier.get());
        }
        List<AccountState> list;
        if (searcher.callerShouldFilterOutInactiveCandidates()) {
            // Keep track of all inactive candidates discovered by any searchers. If we end up short-
            // circuiting, the inactive list will be discarded.
            List<AccountState> active = new ArrayList<>();
            results.forEach(a -> (a.getAccount().isActive() ? active : inactive).add(a));
            list = active;
        } else {
            list = results.collect(toImmutableList());
        }
        if (!list.isEmpty()) {
            return createResult(input, list);
        }
        if (searcher.shortCircuitIfNoResults()) {
            // For a short-circuiting searcher, return results even if empty.
            return !inactive.isEmpty() ? emptyResult(input, inactive) : createResult(input, list);
        }
    }
    return emptyResult(input, inactive);
}
#end_block

#method_before
private Result createResult(String input, List<AccountState> list, Searcher<?> searcher) {
    return new Result(input, list, ImmutableList.of());
}
#method_after
private Result createResult(String input, List<AccountState> list) {
    return new Result(input, list, ImmutableList.of());
}
#end_block

#method_before
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#method_after
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Account.Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#end_block

#method_before
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#method_after
@Override
public Stream<AccountState> search(String nameOrEmail) throws OrmException, IOException {
    // TODO(dborowitz): This would probably work as a Searcher<Address>
    int lt = nameOrEmail.indexOf('<');
    int gt = nameOrEmail.indexOf('>');
    Set<Account.Id> ids = emails.getAccountFor(nameOrEmail.substring(lt + 1, gt));
    ImmutableList<AccountState> allMatches = toAccountStates(ids).collect(toImmutableList());
    if (allMatches.isEmpty() || allMatches.size() == 1) {
        return allMatches.stream();
    }
    // More than one match. If there are any that match the full name as well, return only that
    // subset. Otherwise, all are equally non-matching, so return the full set.
    String name = nameOrEmail.substring(0, lt - 1);
    ImmutableList<AccountState> nameMatches = allMatches.stream().filter(a -> name.equals(a.getAccount().getFullName())).collect(toImmutableList());
    return !nameMatches.isEmpty() ? nameMatches.stream() : allMatches.stream();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> ext(String ext) {
    return extension(ext);
}
#method_after
@Operator
public Predicate<ChangeData> ext(String ext) throws QueryParseException {
    return extension(ext);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> extension(String ext) {
    return new FileExtensionPredicate(ext);
}
#method_after
@Operator
public Predicate<ChangeData> extension(String ext) throws QueryParseException {
    if (args.getSchema().hasField(ChangeField.EXTENSION)) {
        return new FileExtensionPredicate(ext);
    }
    throw new QueryParseException("'extension' operator is not supported by change index version");
}
#end_block

#method_before
@Test
public void typeSet() {
    assertThat(getType().equals(TYPE)).isTrue();
}
#method_after
@Test
public void typeSet() {
    assertThat(getType()).isEqualTo(TYPE);
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    IdentifiedUser me = user.get().asIdentifiedUser();
    processChangeInput(input, me);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = null;
        List<String> groups = Collections.emptyList();
        if (input.baseChange != null) {
            ChangeNotes baseChange = getBaseChange(input.baseChange);
            basePatchSet = psUtil.current(baseChange);
            groups = basePatchSet.getGroups();
        }
        ObjectId parentCommit = getParentCommit(git, rw, input.branch, input.newBranch, basePatchSet, input.baseCommit);
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        String commitMessage = getCommitMessage(input.subject, me, oi, mergeTip, author);
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    IdentifiedUser me = user.get().asIdentifiedUser();
    checkAndSanitizeChangeInput(input, me);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        PatchSet basePatchSet = null;
        List<String> groups = Collections.emptyList();
        if (input.baseChange != null) {
            ChangeNotes baseChange = getBaseChange(input.baseChange);
            basePatchSet = psUtil.current(baseChange);
            groups = basePatchSet.getGroups();
        }
        ObjectId parentCommit = getParentCommit(git, rw, input.branch, input.newBranch, basePatchSet, input.baseCommit);
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        String commitMessage = getCommitMessage(input.subject, me, oi, mergeTip, author);
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    IdentifiedUser me = user.get().asIdentifiedUser();
    processChangeInput(input, me);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(input.branch);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", input.branch));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(me.state().getGeneralPreferences().signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, me.state().getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    IdentifiedUser me = user.get().asIdentifiedUser();
    checkAndSanitizeChangeInput(input, me);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(input.branch);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", input.branch));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(me.state().getGeneralPreferences().signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, me.state().getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    IdentifiedUser me = user.get().asIdentifiedUser();
    processChangeInput(input, me);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(input.branch);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", input.branch));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(me.state().getGeneralPreferences().signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, me.state().getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    IdentifiedUser me = user.get().asIdentifiedUser();
    checkAndSanitizeChangeInput(input, me);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(input.branch);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", input.branch));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(me.state().getGeneralPreferences().signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, me.state().getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(input.workInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    processChangeInput(input);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(input.branch);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", input.branch));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState accountState = me.state();
        GeneralPreferencesInfo info = accountState.getGeneralPreferences();
        boolean isWorkInProgress = input.workInProgress == null ? projectState.is(BooleanProjectConfig.WORK_IN_PROGRESS_BY_DEFAULT) || MoreObjects.firstNonNull(info.workInProgressByDefault, false) : input.workInProgress;
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, accountState.getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(isWorkInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    checkAndSanitizeChangeInput(input);
    ProjectResource projectResource = projectsCollection.parse(input.project);
    ProjectState projectState = projectResource.getProjectState();
    projectState.checkStatePermitsWrite();
    Project.NameKey project = projectResource.getNameKey();
    contributorAgreements.check(project, user.get());
    checkRequiredPermissions(project, input.branch);
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(input.branch);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, input.branch));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", input.branch));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState accountState = me.state();
        GeneralPreferencesInfo info = accountState.getGeneralPreferences();
        boolean isWorkInProgress = input.workInProgress == null ? projectState.is(BooleanProjectConfig.WORK_IN_PROGRESS_BY_DEFAULT) || MoreObjects.firstNonNull(info.workInProgressByDefault, false) : input.workInProgress;
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, accountState.getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, projectState, mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, input.branch);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(input.isPrivate);
        ins.setWorkInProgress(isWorkInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    processChangeInput(input);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    boolean privateByDefault = rsrc.getProjectState().is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    boolean isPrivate = input.isPrivate == null ? privateByDefault : input.isPrivate;
    if (isPrivate && disablePrivateChanges) {
        throw new MethodNotAllowedException("private changes are disabled");
    }
    contributorAgreements.check(rsrc.getNameKey(), rsrc.getUser());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    try {
        permissionBackend.currentUser().project(project).ref(refName).check(RefPermission.READ);
    } catch (AuthException e) {
        throw new ResourceNotFoundException(String.format("ref %s not found", refName));
    }
    permissionBackend.currentUser().project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    rsrc.getProjectState().checkStatePermitsWrite();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(refName);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, refName));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState accountState = me.state();
        GeneralPreferencesInfo info = accountState.getGeneralPreferences();
        boolean isWorkInProgress = input.workInProgress == null ? rsrc.getProjectState().is(BooleanProjectConfig.WORK_IN_PROGRESS_BY_DEFAULT) || MoreObjects.firstNonNull(info.workInProgressByDefault, false) : input.workInProgress;
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, accountState.getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getProjectState(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(isPrivate);
        ins.setWorkInProgress(isWorkInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
protected Response<ChangeInfo> applyImpl(BatchUpdate.Factory updateFactory, TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException, PermissionBackendException, ConfigInvalidException {
    checkAndSanitizeChangeInput(input);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    boolean privateByDefault = rsrc.getProjectState().is(BooleanProjectConfig.PRIVATE_BY_DEFAULT);
    boolean isPrivate = input.isPrivate == null ? privateByDefault : input.isPrivate;
    if (isPrivate && disablePrivateChanges) {
        throw new MethodNotAllowedException("private changes are disabled");
    }
    contributorAgreements.check(rsrc.getNameKey(), rsrc.getUser());
    Project.NameKey project = rsrc.getNameKey();
    String refName = RefNames.fullName(input.branch);
    try {
        permissionBackend.currentUser().project(project).ref(refName).check(RefPermission.READ);
    } catch (AuthException e) {
        throw new ResourceNotFoundException(String.format("ref %s not found", refName));
    }
    permissionBackend.currentUser().project(project).ref(refName).check(RefPermission.CREATE_CHANGE);
    rsrc.getProjectState().checkStatePermitsWrite();
    try (Repository git = gitManager.openRepository(project);
        ObjectInserter oi = git.newObjectInserter();
        ObjectReader reader = oi.newReader();
        RevWalk rw = new RevWalk(reader)) {
        ObjectId parentCommit;
        List<String> groups;
        Ref destRef = git.getRefDatabase().exactRef(refName);
        if (input.baseChange != null) {
            List<ChangeNotes> notes = changeFinder.find(input.baseChange);
            if (notes.size() != 1) {
                throw new UnprocessableEntityException("Base change not found: " + input.baseChange);
            }
            ChangeNotes change = Iterables.getOnlyElement(notes);
            try {
                permissionBackend.currentUser().change(change).check(ChangePermission.READ);
            } catch (AuthException e) {
                throw new UnprocessableEntityException("Read not permitted for " + input.baseChange);
            }
            PatchSet ps = psUtil.current(change);
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else if (input.baseCommit != null) {
            try {
                parentCommit = ObjectId.fromString(input.baseCommit);
            } catch (InvalidObjectIdException e) {
                throw new UnprocessableEntityException(String.format("Base %s doesn't represent a valid SHA-1", input.baseCommit));
            }
            RevCommit parentRevCommit = rw.parseCommit(parentCommit);
            RevCommit destRefRevCommit = rw.parseCommit(destRef.getObjectId());
            if (!rw.isMergedInto(parentRevCommit, destRefRevCommit)) {
                throw new BadRequestException(String.format("Commit %s doesn't exist on ref %s", input.baseCommit, refName));
            }
            groups = Collections.emptyList();
        } else {
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                }
                parentCommit = destRef.getObjectId();
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new BadRequestException("Must provide a destination branch");
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState accountState = me.state();
        GeneralPreferencesInfo info = accountState.getGeneralPreferences();
        boolean isWorkInProgress = input.workInProgress == null ? rsrc.getProjectState().is(BooleanProjectConfig.WORK_IN_PROGRESS_BY_DEFAULT) || MoreObjects.firstNonNull(info.workInProgressByDefault, false) : input.workInProgress;
        // Add a Change-Id line if there isn't already one
        String commitMessage = input.subject;
        if (ChangeIdUtil.indexOfChangeId(commitMessage, "\n") == -1) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, commitMessage);
            commitMessage = ChangeIdUtil.insertId(commitMessage, id);
        }
        if (Boolean.TRUE.equals(info.signedOffBy)) {
            commitMessage = Joiner.on("\n").join(commitMessage.trim(), String.format("%s%s", SIGNED_OFF_BY_TAG, accountState.getAccount().getNameEmail(anonymousCowardName)));
        }
        RevCommit c;
        if (input.merge != null) {
            // create a merge commit
            if (!(submitType.equals(SubmitType.MERGE_ALWAYS) || submitType.equals(SubmitType.MERGE_IF_NECESSARY))) {
                throw new BadRequestException("Submit type: " + submitType + " is not supported");
            }
            c = newMergeCommit(git, oi, rw, rsrc.getProjectState(), mergeTip, input.merge, author, commitMessage);
        } else {
            // create an empty commit
            c = newCommit(oi, rw, author, mergeTip, commitMessage);
        }
        Change.Id changeId = new Change.Id(seq.nextChangeId());
        ChangeInserter ins = changeInserterFactory.create(changeId, c, refName);
        ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
        ins.setTopic(input.topic);
        ins.setPrivate(isPrivate);
        ins.setWorkInProgress(isWorkInProgress);
        ins.setGroups(groups);
        ins.setNotify(input.notify);
        ins.setAccountsToNotify(notifyUtil.resolveAccounts(input.notifyDetails));
        try (BatchUpdate bu = updateFactory.create(project, me, now)) {
            bu.setRepository(git, rw, oi);
            bu.insertChange(ins);
            bu.execute();
        }
        ChangeJson json = jsonFactory.noOptions();
        return Response.created(json.format(ins.getChange()));
    } catch (IllegalArgumentException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    try {
        List<ProjectInfo> children = gApi.projects().query("parent:" + rsrc.getName()).withLimit(10).get();
        if (!children.isEmpty()) {
            throw new CannotDeleteProjectException("Cannot delete project because it has children (show only max 10): " + children.stream().map(info -> info.name).collect(joining(",")));
        }
    } catch (RestApiException e) {
        throw new CannotDeleteProjectException(String.format("Unable to verify if '%s' has children projects.", rsrc.getName()));
    }
}
#method_after
private void assertHasNoChildProjects(ProjectResource rsrc) throws CannotDeleteProjectException {
    try {
        List<ProjectInfo> children = listChildProjectsProvider.get().withLimit(1).apply(rsrc);
        if (!children.isEmpty()) {
            throw new CannotDeleteProjectException("Cannot delete project because it has at least one child: " + Iterables.getOnlyElement(children).name);
        }
    } catch (OrmException | PermissionBackendException | RestApiException e) {
        throw new CannotDeleteProjectException(String.format("Unable to verify if '%s' has children projects.", rsrc.getName()));
    }
}
#end_block

#method_before
private void assertIsNotSubmodule(Project.NameKey projectNameKey) throws CannotDeleteProjectException {
    try (Repository repo = repoManager.openRepository(projectNameKey);
        MergeOpRepoManager mergeOp = mergeOpProvider.get()) {
        Set<Branch.NameKey> branches = new HashSet<>();
        for (Ref ref : repo.getRefDatabase().getRefs(RefNames.REFS_HEADS).values()) {
            branches.add(new Branch.NameKey(projectNameKey, ref.getName()));
        }
        SubmoduleOp sub = subOpFactory.create(branches, mergeOp);
        for (Branch.NameKey b : branches) {
            if (!sub.superProjectSubscriptionsForSubmoduleBranch(b).isEmpty()) {
                throw new CannotDeleteProjectException("Project is subscribed by other projects.");
            }
        }
    } catch (RepositoryNotFoundException e) {
    // we're trying to delete the repository,
    // so this exception should not stop us
    } catch (IOException | SubmoduleException e) {
        throw new CannotDeleteProjectException("Project is subscribed by other projects.");
    }
}
#method_after
private void assertIsNotSubmodule(Project.NameKey projectNameKey) throws CannotDeleteProjectException {
    try (Repository repo = repoManager.openRepository(projectNameKey);
        MergeOpRepoManager mergeOp = mergeOpProvider.get()) {
        Set<Branch.NameKey> branches = repo.getRefDatabase().getRefsByPrefix(REFS_HEADS).stream().map(ref -> new Branch.NameKey(projectNameKey, ref.getName())).collect(toSet());
        SubmoduleOp sub = subOpFactory.create(branches, mergeOp);
        for (Branch.NameKey b : branches) {
            if (!sub.superProjectSubscriptionsForSubmoduleBranch(b).isEmpty()) {
                throw new CannotDeleteProjectException("Project is subscribed by other projects.");
            }
        }
    } catch (RepositoryNotFoundException e) {
    // we're trying to delete the repository,
    // so this exception should not stop us
    } catch (IOException | SubmoduleException e) {
        throw new CannotDeleteProjectException("Project is subscribed by other projects.");
    }
}
#end_block

#method_before
private void assertHasNoTags(Project.NameKey projectNameKey) throws CannotDeleteProjectException {
    try (Repository repo = repoManager.openRepository(projectNameKey)) {
        if (!repo.getRefDatabase().getRefs(Constants.R_TAGS).isEmpty()) {
            throw new CannotDeleteProjectException(String.format("Project %s has tags", projectNameKey));
        }
    } catch (IOException e) {
        throw new CannotDeleteProjectException(e);
    }
}
#method_after
private void assertHasNoTags(Project.NameKey projectNameKey) throws CannotDeleteProjectException {
    try (Repository repo = repoManager.openRepository(projectNameKey)) {
        if (!repo.getRefDatabase().getRefsByPrefix(REFS_TAGS).isEmpty()) {
            throw new CannotDeleteProjectException(String.format("Project %s has tags", projectNameKey));
        }
    } catch (IOException e) {
        throw new CannotDeleteProjectException(e);
    }
}
#end_block

#method_before
@Override
public List<ProjectInfo> children(int limit) throws RestApiException {
    ListChildProjects list = children.list();
    list.setLimit(limit);
    try {
        return list.apply(checkExists());
    } catch (Exception e) {
        throw asRestApiException("Cannot list children", e);
    }
}
#method_after
@Override
public List<ProjectInfo> children(int limit) throws RestApiException {
    try {
        return children.list().withLimit(limit).apply(checkExists());
    } catch (Exception e) {
        throw asRestApiException("Cannot list children", e);
    }
}
#end_block

#method_before
@Override
public List<ProjectInfo> apply(ProjectResource rsrc) throws PermissionBackendException, OrmException, ResourceConflictException, BadRequestException, MethodNotAllowedException {
    if (recursive && limit != 0) {
        throw new ResourceConflictException("recursive and limit options are mutually exclusive");
    }
    rsrc.getProjectState().checkStatePermitsRead();
    if (recursive) {
        return childProjects.list(rsrc.getNameKey());
    }
    return directChildProjects(rsrc.getNameKey());
}
#method_after
@Override
public List<ProjectInfo> apply(ProjectResource rsrc) throws PermissionBackendException, OrmException, RestApiException {
    if (limit < 0) {
        throw new BadRequestException("limit must be a positive number");
    }
    if (recursive && limit != 0) {
        throw new ResourceConflictException("recursive and limit options are mutually exclusive");
    }
    rsrc.getProjectState().checkStatePermitsRead();
    if (recursive) {
        return childProjects.list(rsrc.getNameKey());
    }
    return directChildProjects(rsrc.getNameKey());
}
#end_block

#method_before
private List<ProjectInfo> directChildProjects(Project.NameKey parent) throws OrmException, BadRequestException, MethodNotAllowedException {
    PermissionBackend.WithUser currentUser = permissionBackend.currentUser();
    QueryProjects query = queryProvider.get();
    query.setQuery("parent:" + parent.get());
    if (limit != 0) {
        query.setLimit(limit);
    }
    return query.apply(TopLevelResource.INSTANCE).stream().filter(p -> currentUser.project(new Project.NameKey(p.name)).testOrFalse(ProjectPermission.ACCESS)).map(p -> json.format(projectCache.get(p.name))).collect(toList());
}
#method_after
private List<ProjectInfo> directChildProjects(Project.NameKey parent) throws OrmException, RestApiException {
    PermissionBackend.WithUser currentUser = permissionBackend.currentUser();
    return queryProvider.get().withQuery("parent:" + parent.get()).withLimit(limit).apply(TopLevelResource.INSTANCE).stream().filter(p -> currentUser.project(new Project.NameKey(p.name)).testOrFalse(ProjectPermission.ACCESS)).collect(toList());
}
#end_block

#method_before
@Override
public List<ProjectInfo> apply(ProjectResource rsrc) throws PermissionBackendException, ResourceConflictException, RestApiException {
    rsrc.getProjectState().checkStatePermitsRead();
    if (recursive) {
        return childProjects.list(rsrc.getNameKey());
    }
    return directChildProjects(rsrc.getNameKey());
}
#method_after
@Override
public List<ProjectInfo> apply(ProjectResource rsrc) throws PermissionBackendException, OrmException, RestApiException {
    rsrc.getProjectState().checkStatePermitsRead();
    if (recursive) {
        return childProjects.list(rsrc.getNameKey());
    }
    return directChildProjects(rsrc.getNameKey());
}
#end_block

#method_before
private List<ProjectInfo> directChildProjects(Project.NameKey parent) throws PermissionBackendException, RestApiException {
    List<Project.NameKey> children = gApi.projects().query("parent:" + parent.get()).get().stream().map(p -> new Project.NameKey(p.name)).collect(toList());
    return permissionBackend.currentUser().filter(ProjectPermission.ACCESS, children).stream().sorted().map(p -> json.format(projectCache.get(p))).collect(toList());
}
#method_after
private List<ProjectInfo> directChildProjects(Project.NameKey parent) throws OrmException, RestApiException {
    PermissionBackend.WithUser currentUser = permissionBackend.currentUser();
    return queryProvider.get().withQuery("parent:" + parent.get()).apply(TopLevelResource.INSTANCE).stream().filter(p -> currentUser.project(new Project.NameKey(p.name)).testOrFalse(ProjectPermission.ACCESS)).collect(toList());
}
#end_block

#method_before
@Override
public Response.Accepted apply(ProjectResource rsrc, IndexProjectInput input) throws IOException, AuthException, OrmException, PermissionBackendException, ResourceConflictException, RestApiException {
    String response = "Project " + rsrc.getName() + " submitted for reindexing";
    reindex(rsrc.getNameKey(), input.async);
    if (Boolean.TRUE.equals(input.indexChildren)) {
        ListChildProjects listChildProjects = listChildProjectsProvider.get();
        listChildProjects.setRecursive(true);
        for (ProjectInfo child : listChildProjects.apply(rsrc)) {
            reindex(new Project.NameKey(child.name), input.async);
        }
        response += " (indexing children recursively)";
    }
    return Response.accepted(response);
}
#method_after
@Override
public Response.Accepted apply(ProjectResource rsrc, IndexProjectInput input) throws IOException, OrmException, PermissionBackendException, RestApiException {
    String response = "Project " + rsrc.getName() + " submitted for reindexing";
    reindex(rsrc.getNameKey(), input.async);
    if (Boolean.TRUE.equals(input.indexChildren)) {
        ListChildProjects listChildProjects = listChildProjectsProvider.get();
        listChildProjects.setRecursive(true);
        for (ProjectInfo child : listChildProjects.apply(rsrc)) {
            reindex(new Project.NameKey(child.name), input.async);
        }
        response += " (indexing children recursively)";
    }
    return Response.accepted(response);
}
#end_block

#method_before
private <I extends ChangeInfo> I toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId, Supplier<I> changeInfoSupplier) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    I out = changeInfoSupplier.get();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.assignee = in.getAssignee() != null ? accountLoader.get(in.getAssignee()) : null;
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (mergeableOnlySetWhenRequested) {
            out.mergeable = has(MERGEABLE) ? cd.isMergeable() : null;
        } else if (!has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.totalCommentCount = cd.totalCommentCount();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsJson.labelsFor(accountLoader, cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? labelsJson.permittedLabels(user.getAccountId(), cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    if (pluginDefinedAttributesFactory.isPresent()) {
        out.plugins = pluginDefinedAttributesFactory.get().create(cd);
    }
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisionJson.getRevisions(accountLoader, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#method_after
private <I extends ChangeInfo> I toChangeInfoImpl(ChangeData cd, Optional<PatchSet.Id> limitToPsId, Supplier<I> changeInfoSupplier) throws PatchListNotAvailableException, GpgException, OrmException, PermissionBackendException, IOException {
    I out = changeInfoSupplier.get();
    CurrentUser user = userProvider.get();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.notes(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.project(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.assignee = in.getAssignee() != null ? accountLoader.get(in.getAssignee()) : null;
    out.hashtags = cd.hashtags();
    out.changeId = in.getKey().get();
    if (in.getStatus().isOpen()) {
        SubmitTypeRecord str = cd.submitTypeRecord();
        if (str.isOk()) {
            out.submitType = str.type;
        }
        if (!excludeMergeableInChangeInfo && !has(SKIP_MERGEABLE)) {
            out.mergeable = cd.isMergeable();
        }
        if (has(SUBMITTABLE)) {
            out.submittable = submittable(cd);
        }
    }
    Optional<ChangedLines> changedLines = cd.changedLines();
    if (changedLines.isPresent()) {
        out.insertions = changedLines.get().insertions;
        out.deletions = changedLines.get().deletions;
    }
    out.isPrivate = in.isPrivate() ? true : null;
    out.workInProgress = in.isWorkInProgress() ? true : null;
    out.hasReviewStarted = in.hasReviewStarted();
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.totalCommentCount = cd.totalCommentCount();
    out.unresolvedCommentCount = cd.unresolvedCommentCount();
    if (user.isIdentifiedUser()) {
        Collection<String> stars = cd.stars(user.getAccountId());
        out.starred = stars.contains(StarredChangesUtil.DEFAULT_LABEL) ? true : null;
        if (!stars.isEmpty()) {
            out.stars = stars;
        }
    }
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        out.reviewed = cd.isReviewedBy(user.getAccountId()) ? true : null;
    }
    out.labels = labelsJson.labelsFor(accountLoader, cd, has(LABELS), has(DETAILED_LABELS));
    out.requirements = requirementsFor(cd);
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (user.isIdentifiedUser() && (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId()))) {
            out.permittedLabels = cd.change().getStatus() != Change.Status.ABANDONED ? labelsJson.permittedLabels(user.getAccountId(), cd) : ImmutableMap.of();
        }
        out.reviewers = reviewerMap(cd.reviewers(), cd.reviewersByEmail(), false);
        out.pendingReviewers = reviewerMap(cd.pendingReviewers(), cd.pendingReviewersByEmail(), true);
        out.removableReviewers = removableReviewers(cd, out);
    }
    setSubmitter(cd, out);
    if (pluginDefinedAttributesFactory.isPresent()) {
        out.plugins = pluginDefinedAttributesFactory.get().create(cd);
    }
    out.revertOf = cd.change().getRevertOf() != null ? cd.change().getRevertOf().get() : null;
    if (has(REVIEWER_UPDATES)) {
        out.reviewerUpdates = reviewerUpdates(cd);
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(cd);
    }
    finish(out);
    // it will be passed to ActionVisitors as-is.
    if (needRevisions) {
        out.revisions = revisionJson.getRevisions(accountLoader, cd, src, limitToPsId, out);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, cd.notes());
    }
    if (has(TRACKING_IDS)) {
        ListMultimap<String, String> set = trackingFooters.extract(cd.commitFooters());
        out.trackingIds = set.entries().stream().map(e -> new TrackingIdInfo(e.getKey(), e.getValue())).collect(toList());
    }
    return out;
}
#end_block

#method_before
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    UpdateUI ui = new UpdateUiImpl(pruneList);
    reviewDbSchemaUpdater.update(ui);
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (this.ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (this.ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
    noteDbSchemaUpdater.update(ui);
}
#method_after
void upgradeSchema() throws OrmException {
    final List<String> pruneList = new ArrayList<>();
    UpdateUI uiImpl = new UpdateUIImpl(ui, pruneList);
    reviewDbSchemaUpdater.update(uiImpl);
    if (!pruneList.isEmpty()) {
        StringBuilder msg = new StringBuilder();
        msg.append("Execute the following SQL to drop unused objects:\n");
        msg.append("\n");
        for (String sql : pruneList) {
            msg.append("  ");
            msg.append(sql);
            msg.append(";\n");
        }
        if (ui.isBatch()) {
            System.err.print(msg);
            System.err.flush();
        } else if (ui.yesno(true, "%s\nExecute now", msg)) {
            try (JdbcSchema db = (JdbcSchema) unwrapDb(schema.open());
                JdbcExecutor e = new JdbcExecutor(db)) {
                for (String sql : pruneList) {
                    e.execute(sql);
                }
            }
        }
    }
    noteDbSchemaUpdater.update(uiImpl);
}
#end_block

#method_before
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = Paths.get(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            List<String> pluginsToInstall;
            String installPlugins = System.getProperty("gerrit.install_plugins");
            if (installPlugins == null) {
                pluginsToInstall = null;
            } else {
                pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins);
            }
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext), pluginsToInstall).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            logger.atSevere().withCause(first.getCause()).log(buf.toString());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        initIndexType();
        config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setDbCfgInjector(dbInjector, cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#method_after
private synchronized void init() {
    if (manager == null) {
        String path = System.getProperty(GERRIT_SITE_PATH);
        if (path != null) {
            sitePath = Paths.get(path);
        } else {
            throw new ProvisionException(GERRIT_SITE_PATH + " must be defined");
        }
        if (System.getProperty("gerrit.init") != null) {
            List<String> pluginsToInstall;
            String installPlugins = System.getProperty("gerrit.install_plugins");
            if (installPlugins == null) {
                pluginsToInstall = null;
            } else {
                pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins);
            }
            new SiteInitializer(path, System.getProperty(GERRIT_SITE_PATH), new UnzippedDistribution(servletContext), pluginsToInstall).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            logger.atSevere().withCause(first.getCause()).log(buf.toString());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        initIndexType();
        config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setDbCfgInjector(dbInjector, cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#end_block

#method_before
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
        // If we didn't get the site path from the system property
        // we need to get it from the database, as that's our old
        // method of locating the site path on disk.
        // 
        modules.add(new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toProvider(SitePathFromSystemConfigProvider.class).in(SINGLETON);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new DatabaseModule());
    modules.add(new NotesMigration.Module());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#method_after
private Injector createDbInjector() {
    final List<Module> modules = new ArrayList<>();
    AbstractModule secureStore = createSecureStoreModule();
    modules.add(secureStore);
    if (sitePath != null) {
        Module sitePathModule = new AbstractModule() {

            @Override
            protected void configure() {
                bind(Path.class).annotatedWith(SitePath.class).toInstance(sitePath);
            }
        };
        modules.add(sitePathModule);
        Module configModule = new GerritServerConfigModule();
        modules.add(configModule);
        Injector cfgInjector = Guice.createInjector(sitePathModule, configModule, secureStore);
        Config cfg = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        String dbType = cfg.getString("database", null, "type");
        final DataSourceType dst = Guice.createInjector(new DataSourceModule(), configModule, sitePathModule, secureStore).getInstance(Key.get(DataSourceType.class, Names.named(dbType.toLowerCase())));
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(DataSourceType.class).toInstance(dst);
                bind(DataSourceProvider.Context.class).toInstance(DataSourceProvider.Context.MULTI_USER);
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(DataSourceProvider.class).in(SINGLETON);
                listener().to(DataSourceProvider.class);
            }
        });
    } else {
        modules.add(new LifecycleModule() {

            @Override
            protected void configure() {
                bind(Key.get(DataSource.class, Names.named("ReviewDb"))).toProvider(ReviewDbDataSourceProvider.class).in(SINGLETON);
                listener().to(ReviewDbDataSourceProvider.class);
            }
        });
        modules.add(new GerritServerConfigModule());
    }
    modules.add(new DatabaseModule());
    modules.add(new NotesMigration.Module());
    modules.add(new DropWizardMetricMaker.ApiModule());
    return Guice.createInjector(PRODUCTION, modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new AuditModule());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new GerritInstanceNameModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new DefaultUrlFormatter.Module());
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new AuditModule());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new GerritInstanceNameModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new DefaultUrlFormatter.Module());
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false, false));
            bind(GerritRuntime.class).toInstance(GerritRuntime.DAEMON);
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(sysInjector.getInstance(GerritAuthModule.class));
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(RequestContextFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(sysInjector.getInstance(GerritAuthModule.class));
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    if (sshInjector != null) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    modules.add(H2CacheBasedWebSession.module());
    modules.add(new HttpPluginModule());
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    GerritOptions opts = sysInjector.getInstance(GerritOptions.class);
    if (opts.enableMasterFeatures()) {
        modules.add(sysInjector.getInstance(StaticModule.class));
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(ReviewDbSchemaVersionCheck.module());
    modules.add(NoteDbSchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new AuditModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    modules.add(new GerritInstanceNameModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(new DefaultUrlFormatter.Module());
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (slave) {
        modules.add(new PeriodicGroupIndexer.Module());
    } else {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(ReviewDbSchemaVersionCheck.module());
    modules.add(NoteDbSchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Plugin module needs to be inserted *before* the index module.
    // There is the concept of LifecycleModule, in Gerrit's own extension
    // to Guice, which has these:
    // listener().to(SomeClassImplementingLifecycleListener.class);
    // and the start() methods of each such listener are executed in the
    // order they are declared.
    // Makes sure that PluginLoader.start() is executed before the
    // LuceneIndexModule.start() so that plugins get loaded and the respective
    // Guice modules installed so that the on-line reindexing will happen
    // with the proper classes (e.g. group backends, custom Prolog
    // predicates) and the associated rules ready to be evaluated.
    modules.add(new PluginModule());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    if (auditEventModule != null) {
        modules.add(auditEventModule);
    } else {
        modules.add(new AuditModule());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    modules.add(new GerritInstanceNameModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(new DefaultUrlFormatter.Module());
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (slave) {
        modules.add(new PeriodicGroupIndexer.Module());
    } else {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#end_block

#method_before
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GerritAuthModule.class));
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    modules.add(sysInjector.getInstance(StaticModule.class));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createWebInjector() {
    final List<Module> modules = new ArrayList<>();
    if (sshd) {
        modules.add(new ProjectQoSFilter.Module());
    }
    modules.add(RequestContextFilter.module());
    modules.add(RequestMetricsFilter.module());
    modules.add(H2CacheBasedWebSession.module());
    modules.add(sysInjector.getInstance(GerritAuthModule.class));
    modules.add(sysInjector.getInstance(GitOverHttpModule.class));
    modules.add(AllRequestFilter.module());
    modules.add(sysInjector.getInstance(WebModule.class));
    modules.add(sysInjector.getInstance(RequireSslFilter.Module.class));
    modules.add(new HttpPluginModule());
    if (sshd) {
        modules.add(sshInjector.getInstance(WebSshGlueModule.class));
    } else {
        modules.add(new NoSshModule());
    }
    AuthConfig authConfig = cfgInjector.getInstance(AuthConfig.class);
    if (authConfig.getAuthType() == AuthType.OPENID || authConfig.getAuthType() == AuthType.OPENID_SSO) {
        modules.add(new OpenIdModule());
    } else if (authConfig.getAuthType() == AuthType.OAUTH) {
        modules.add(new OAuthModule());
    }
    modules.add(sysInjector.getInstance(GetUserFilter.Module.class));
    // StaticModule contains a "/*" wildcard, place it last.
    GerritOptions opts = sysInjector.getInstance(GerritOptions.class);
    if (opts.enableMasterFeatures()) {
        modules.add(sysInjector.getInstance(StaticModule.class));
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@Override
public boolean indexAccount(final int accountId, IndexEvent event) {
    return new Request("index account", accountId) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "index/account", accountId), event);
        }
    }.execute();
}
#method_after
@Override
public boolean indexAccount(final int accountId, IndexEvent event) {
    return execute(RequestMethod.POST, "index account", "index/account", accountId, event);
}
#end_block

#method_before
@Override
public boolean indexChange(String projectName, int changeId, IndexEvent event) {
    return new Request("index change", changeId) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(buildIndexEndpoint(projectName, changeId), event);
        }
    }.execute();
}
#method_after
@Override
public boolean indexChange(String projectName, int changeId, IndexEvent event) {
    return execute(RequestMethod.POST, "index change", "index/change", buildIndexEndpoint(projectName, changeId), event);
}
#end_block

#method_before
@Override
public boolean deleteChangeFromIndex(final int changeId, IndexEvent event) {
    return new Request("delete change", changeId) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.delete(buildIndexEndpoint(changeId), event);
        }
    }.execute();
}
#method_after
@Override
public boolean deleteChangeFromIndex(final int changeId, IndexEvent event) {
    return execute(RequestMethod.DELETE, "delete change", "index/change", buildIndexEndpoint(changeId), event);
}
#end_block

#method_before
@Override
public boolean indexGroup(final String uuid, IndexEvent event) {
    return new Request("index group", uuid) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "index/group", uuid), event);
        }
    }.execute();
}
#method_after
@Override
public boolean indexGroup(final String uuid, IndexEvent event) {
    return execute(RequestMethod.POST, "index group", "index/group", uuid, event);
}
#end_block

#method_before
private String buildIndexEndpoint(String projectName, int changeId) {
    String escapedProjectName = Url.encode(projectName);
    return Joiner.on("/").join(pluginRelativePath, "index/change", escapedProjectName + '~' + changeId);
}
#method_after
private String buildIndexEndpoint(String projectName, int changeId) {
    String escapedProjectName = Url.encode(projectName);
    return escapedProjectName + '~' + changeId;
}
#end_block

#method_before
@Override
public boolean indexProject(String projectName) {
    return new Request("index project", projectName) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "index/project", Url.encode(projectName)));
        }
    }.execute();
}
#method_after
@Override
public boolean indexProject(String projectName, IndexEvent event) {
    return execute(RequestMethod.POST, "index project", "index/project", Url.encode(projectName), event);
}
#end_block

#method_before
@Override
public boolean send(final Event event) {
    return new Request("send event", event.type) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "event"), event);
        }
    }.execute();
}
#method_after
@Override
public boolean send(final Event event) {
    return execute(RequestMethod.POST, "send event", "event", event.type, event);
}
#end_block

#method_before
@Override
public boolean evict(final String cacheName, final Object key) {
    return new Request("invalidate cache " + cacheName, key) {

        @Override
        HttpResult send() throws IOException {
            String json = GsonParser.toJson(cacheName, key);
            return httpSession.post(Joiner.on("/").join(pluginRelativePath, "cache", cacheName), json);
        }
    }.execute();
}
#method_after
@Override
public boolean evict(final String cacheName, final Object key) {
    String json = GsonParser.toJson(cacheName, key);
    return execute(RequestMethod.POST, "invalidate cache " + cacheName, "cache", cacheName, json);
}
#end_block

#method_before
@Override
public boolean addToProjectList(String projectName) {
    return new Request("Update project_list, add ", projectName) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.post(buildProjectListEndpoint(projectName));
        }
    }.execute();
}
#method_after
@Override
public boolean addToProjectList(String projectName) {
    return execute(RequestMethod.POST, "Update project_list, add ", buildProjectListEndpoint(), Url.encode(projectName));
}
#end_block

#method_before
@Override
public boolean removeFromProjectList(String projectName) {
    return new Request("Update project_list, remove ", projectName) {

        @Override
        HttpResult send() throws IOException {
            return httpSession.delete(buildProjectListEndpoint(projectName));
        }
    }.execute();
}
#method_after
@Override
public boolean removeFromProjectList(String projectName) {
    return execute(RequestMethod.DELETE, "Update project_list, remove ", buildProjectListEndpoint(), Url.encode(projectName));
}
#end_block

#method_before
private String buildProjectListEndpoint(String projectName) {
    return Joiner.on("/").join(pluginRelativePath, "cache", Constants.PROJECT_LIST, Url.encode(projectName));
}
#method_after
private static String buildProjectListEndpoint() {
    return Joiner.on("/").join("cache", Constants.PROJECT_LIST);
}
#end_block

#method_before
boolean execute() {
    log.debug("Executing {} {}", action, key);
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            log.debug("{} {} OK", action, key);
            return true;
        } catch (ForwardingException e) {
            int maxTries = cfg.http().maxTries();
            log.debug("Failed to {} {} [{}/{}]", action, key, execCnt, maxTries, e);
            if (!e.isRecoverable()) {
                log.error("{} {} failed with unrecoverable error; giving up", action, key, e);
                return false;
            }
            if (execCnt >= maxTries) {
                log.error("Failed to {} {} after {} tries; giving up", action, key, maxTries);
                return false;
            }
            log.debug("Retrying to {} {}", action, key);
            try {
                Thread.sleep(cfg.http().retryInterval());
            } catch (InterruptedException ie) {
                log.error("{} {} was interrupted; giving up", action, key, ie);
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
}
#method_after
boolean execute() {
    log.debug("Executing {} {} towards {}", action, key, destination);
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            log.debug("{} {} towards {} OK", action, key, destination);
            return true;
        } catch (ForwardingException e) {
            int maxTries = cfg.http().maxTries();
            log.debug("Failed to {} {} on {} [{}/{}]", action, key, destination, execCnt, maxTries, e);
            if (!e.isRecoverable()) {
                log.error("{} {} towards {} failed with unrecoverable error; giving up", action, key, destination, e);
                return false;
            }
            if (execCnt >= maxTries) {
                log.error("Failed to {} {} on {} after {} tries; giving up", action, key, destination, maxTries);
                return false;
            }
            log.debug("Retrying to {} {} on {}", action, key, destination);
            try {
                Thread.sleep(cfg.http().retryInterval());
            } catch (InterruptedException ie) {
                log.error("{} {} towards {} was interrupted; giving up", action, key, destination, ie);
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
}
#end_block

#method_before
private void executeIndexChangeTask(String projectName, int id, boolean deleted) {
    if (!Context.isForwardedEvent()) {
        IndexChangeTask task = new IndexChangeTask(projectName, id, deleted);
        if (queuedTasks.add(task)) {
            executor.execute(task);
        }
    }
}
#method_after
private void executeIndexChangeTask(String projectName, int id, boolean deleted) {
    if (!Context.isForwardedEvent()) {
        ChangeChecker checker = changeChecker.create(projectName + "~" + id);
        try {
            checker.newIndexEvent().map(event -> new IndexChangeTask(projectName, id, deleted, event)).ifPresent(task -> {
                if (queuedTasks.add(task)) {
                    executor.execute(task);
                }
            });
        } catch (Exception e) {
            log.warn("Unable to create task to handle change {}~{}", projectName, id, e);
        }
    }
}
#end_block

#method_before
@Override
public void execute() {
    forwarder.indexProject(projectName);
}
#method_after
@Override
public void execute() {
    forwarder.indexProject(projectName, indexEvent);
}
#end_block

#method_before
@Override
protected void doIndex(Project.NameKey projectName, Optional<IndexEvent> indexEvent) throws IOException, OrmException {
    indexer.index(projectName);
    log.debug("Project {} successfully indexed", projectName);
}
#method_after
@Override
protected void doIndex(Project.NameKey projectName, Optional<IndexEvent> indexEvent) throws IOException {
    indexer.index(projectName);
    log.debug("Project {} successfully indexed", projectName);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Executor.class).annotatedWith(IndexExecutor.class).toProvider(IndexExecutorProvider.class);
    listener().to(IndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), AccountIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), GroupIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), ProjectIndexedListener.class).to(IndexEventHandler.class);
}
#method_after
@Override
protected void configure() {
    bind(Executor.class).annotatedWith(IndexExecutor.class).toProvider(IndexExecutorProvider.class);
    bind(ScheduledExecutorService.class).annotatedWith(ForwardedIndexExecutor.class).toProvider(ForwardedIndexExecutorProvider.class);
    listener().to(IndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), AccountIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), GroupIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), ProjectIndexedListener.class).to(IndexEventHandler.class);
    install(new FactoryModuleBuilder().implement(ChangeChecker.class, ChangeCheckerImpl.class).build(ChangeCheckerImpl.Factory.class));
}
#end_block

#method_before
@Override
Project.NameKey parse(String projectName) {
    return new Project.NameKey(projectName);
}
#method_after
@Override
Project.NameKey parse(String projectName) {
    return new Project.NameKey(Url.decode(projectName));
}
#end_block

#method_before
private static Map<String, Ref> getTaggableRefsMap(Repository repo) throws PermissionBackendException {
    try {
        return repo.getRefDatabase().getRefs().stream().filter(r -> !RefNames.isGerritRef(r.getName()) && !r.getName().startsWith(RefNames.REFS_TAGS)).collect(toMap(Ref::getName, r -> r));
    } catch (IOException e) {
        throw new PermissionBackendException(e);
    }
}
#method_after
private static Map<String, Ref> getTaggableRefsMap(Repository repo) throws PermissionBackendException {
    try {
        return repo.getRefDatabase().getRefs().stream().filter(r -> !RefNames.isGerritRef(r.getName()) && !r.getName().startsWith(RefNames.REFS_TAGS) && !r.isSymbolic()).collect(toMap(Ref::getName, r -> r));
    } catch (IOException e) {
        throw new PermissionBackendException(e);
    }
}
#end_block

#method_before
@Override
public void start() {
    for (HealthCheck healthCheck : healthChecks) {
        String name = healthCheck.name();
        Counter0 failureMetric = metricMaker.newCounter(String.format("%s/failure", name), new Description(String.format("%s healthcheck failures count", name)).setCumulative().setRate().setUnit("failures"));
        CallbackMetric0 latencyMetric = metricMaker.newCallbackMetric(String.format("%s/latency", name), Long.class, new Description(String.format("%s health check latency execution (ms)", name)).setGauge().setUnit(Description.Units.MILLISECONDS));
        Runnable metricCallBack = () -> {
            HealthCheck.Status status = healthCheck.getLatestStatus();
            latencyMetric.set(healthCheck.getLatestStatus().elapsed);
            if (status.isFailure()) {
                failureMetric.increment();
            }
        };
        registeredMetrics.add(failureMetric);
        registeredMetrics.add(metricMaker.newTrigger(latencyMetric, metricCallBack));
        triggers.add(metricCallBack);
    }
}
#method_after
@Override
public void start() {
    for (HealthCheck healthCheck : healthChecks) {
        String name = healthCheck.name();
        Counter0 failureMetric = metricMaker.newCounter(String.format("%s/failure", name), new Description(String.format("%s healthcheck failures count", name)).setCumulative().setRate().setUnit("failures"));
        CallbackMetric0<Long> latencyMetric = metricMaker.newCallbackMetric(String.format("%s/latest_latency", name), Long.class, new Description(String.format("%s health check latency execution (ms)", name)).setGauge().setUnit(Description.Units.MILLISECONDS));
        Runnable metricCallBack = () -> {
            HealthCheck.StatusSummary status = healthCheck.getLatestStatus();
            latencyMetric.set(healthCheck.getLatestStatus().elapsed);
            if (status.isFailure()) {
                failureMetric.increment();
            }
        };
        registeredMetrics.add(failureMetric);
        registeredMetrics.add(metricMaker.newTrigger(latencyMetric, metricCallBack));
        triggers.add(metricCallBack);
    }
}
#end_block

#method_before
@Override
public void stop() {
    synchronized (registeredMetrics) {
        Iterator<RegistrationHandle> itr = registeredMetrics.iterator();
        while (itr.hasNext()) {
            itr.next().remove();
            itr.remove();
        }
    }
}
#method_after
@Override
public void stop() {
    for (RegistrationHandle handle : registeredMetrics) {
        handle.remove();
    }
}
#end_block

#method_before
public void triggerAll() {
    synchronized (triggers) {
        triggers.forEach(Runnable::run);
    }
}
#method_after
@VisibleForTesting
public void triggerAll() {
    triggers.forEach(Runnable::run);
}
#end_block

#method_before
@Override
public Status run() {
    final long ts = System.currentTimeMillis();
    Status status = null;
    ListenableFuture<Status> resultFuture = executor.submit(() -> {
        Result healthy;
        try {
            healthy = doCheck();
        } catch (Exception e) {
            log.warn("Check {} failed", name, e);
            healthy = Result.FAILED;
        }
        return new Status(healthy, ts, System.currentTimeMillis() - ts);
    });
    try {
        status = resultFuture.get(timeout, TimeUnit.MILLISECONDS);
    } catch (TimeoutException e) {
        log.warn("Check {} timed out", name, e);
        status = new Status(Result.TIMEOUT, ts, System.currentTimeMillis() - ts);
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Check {} failed while waiting for its future result", name, e);
        status = new Status(Result.FAILED, ts, System.currentTimeMillis() - ts);
    } finally {
        this.latestStatus = status;
    }
    return status;
}
#method_after
@Override
public StatusSummary run() {
    final long ts = System.currentTimeMillis();
    ListenableFuture<StatusSummary> resultFuture = executor.submit(() -> {
        Result healthy;
        try {
            healthy = doCheck();
        } catch (Exception e) {
            log.warn("Check {} failed", name, e);
            healthy = Result.FAILED;
        }
        return new StatusSummary(healthy, ts, System.currentTimeMillis() - ts);
    });
    try {
        latestStatus = resultFuture.get(timeout, TimeUnit.MILLISECONDS);
    } catch (TimeoutException e) {
        log.warn("Check {} timed out", name, e);
        latestStatus = new StatusSummary(Result.TIMEOUT, ts, System.currentTimeMillis() - ts);
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Check {} failed while waiting for its future result", name, e);
        latestStatus = new StatusSummary(Result.FAILED, ts, System.currentTimeMillis() - ts);
    }
    return latestStatus;
}
#end_block

#method_before
@Override
public Status getLatestStatus() {
    return latestStatus;
}
#method_after
@Override
public StatusSummary getLatestStatus() {
    return latestStatus;
}
#end_block

#method_before
@Override
protected Result doCheck() {
    return returnStatus.result;
}
#method_after
@Override
protected Result doCheck() {
    return latestStatus.result;
}
#end_block

#method_before
@Override
public Status run() {
    latestStatus = returnStatus;
    return latestStatus;
}
#method_after
@Override
public StatusSummary run() {
    return latestStatus;
}
#end_block

#method_before
@Override
public Status getLatestStatus() {
    return this.latestStatus;
}
#method_after
@Override
public StatusSummary getLatestStatus() {
    return this.latestStatus;
}
#end_block

#method_before
public static String getRestPathWithoutIds(HttpServletRequest req) {
    String encodedPathInfo = req.getRequestURI().substring(req.getContextPath().length());
    if (encodedPathInfo.startsWith("/")) {
        encodedPathInfo = encodedPathInfo.substring(1);
    }
    if (encodedPathInfo.startsWith("a/")) {
        encodedPathInfo = encodedPathInfo.substring(2);
    }
    String[] parts = encodedPathInfo.split("/");
    StringBuilder result = new StringBuilder(parts.length / 2 + 1);
    for (int i = 0; i < parts.length; i = i + 2) {
        result.append("/");
        result.append(parts[i]);
    }
    return result.toString();
}
#method_after
public static String getRestPathWithoutIds(HttpServletRequest req) {
    String encodedPathInfo = req.getRequestURI().substring(req.getContextPath().length());
    if (encodedPathInfo.startsWith("/")) {
        encodedPathInfo = encodedPathInfo.substring(1);
    }
    if (encodedPathInfo.startsWith("a/")) {
        encodedPathInfo = encodedPathInfo.substring(2);
    }
    String[] parts = encodedPathInfo.split("/");
    StringBuilder result = new StringBuilder(parts.length);
    for (int i = 0; i < parts.length; i = i + 2) {
        result.append("/");
        result.append(parts[i]);
    }
    return result.toString();
}
#end_block

#method_before
void enforce(RestResource rsrc, HttpServletRequest req) throws QuotaException {
    String pathForQuotaReporting = RequestUtil.getRestPathWithoutIds(req);
    // Enrich the quota request we we are operating on an interesting collection
    QuotaBackend.WithResource report = quotaBackend.currentUser();
    if (rsrc instanceof ChangeResource) {
        ChangeResource changeResource = (ChangeResource) rsrc;
        report = quotaBackend.currentUser().change(changeResource.getId(), changeResource.getProject());
    } else if (rsrc instanceof AccountResource) {
        AccountResource accountResource = (AccountResource) rsrc;
        report = quotaBackend.currentUser().account(accountResource.getUser().getAccountId());
    } else if (rsrc instanceof ProjectResource) {
        ProjectResource accountResource = (ProjectResource) rsrc;
        report = quotaBackend.currentUser().account(accountResource.getUser().getAccountId());
    }
    report.requestToken(quotaGroup(pathForQuotaReporting, req.getMethod())).throwOnError();
}
#method_after
void enforce(RestResource rsrc, HttpServletRequest req) throws QuotaException {
    String pathForQuotaReporting = RequestUtil.getRestPathWithoutIds(req);
    // Enrich the quota request we are operating on an interesting collection
    QuotaBackend.WithResource report = quotaBackend.currentUser();
    if (rsrc instanceof ChangeResource) {
        ChangeResource changeResource = (ChangeResource) rsrc;
        report = quotaBackend.currentUser().change(changeResource.getId(), changeResource.getProject());
    } else if (rsrc instanceof AccountResource) {
        AccountResource accountResource = (AccountResource) rsrc;
        report = quotaBackend.currentUser().account(accountResource.getUser().getAccountId());
    } else if (rsrc instanceof ProjectResource) {
        ProjectResource accountResource = (ProjectResource) rsrc;
        report = quotaBackend.currentUser().account(accountResource.getUser().getAccountId());
    }
    report.requestToken(quotaGroup(pathForQuotaReporting, req.getMethod())).throwOnError();
}
#end_block

#method_before
@Test
public void byExtension() throws Exception {
    if (getSchemaVersion() < 52) {
        assertMissingField(ChangeField.EXTENSION);
        assertFailingQuery("extension:txt", "'extension' operator is not supported by change index version");
        assertFailingQuery("ext:txt", "'extension' operator is not supported by change index version");
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChangeWithFiles(repo, "foo.h", "foo.cc"));
    Change change2 = insert(repo, newChangeWithFiles(repo, "bar.H", "bar.CC"));
    Change change3 = insert(repo, newChangeWithFiles(repo, "dir/baz.h", "dir/baz.cc"));
    Change change4 = insert(repo, newChangeWithFiles(repo, "Quux.java"));
    assertQuery("extension:java", change4);
    assertQuery("ext:java", change4);
    assertQuery("ext:.java", change4);
    assertQuery("ext:jAvA", change4);
    assertQuery("ext:.jAvA", change4);
    assertQuery("ext:cc", change3, change2, change1);
}
#method_after
@Test
public void byExtension() throws Exception {
    if (getSchemaVersion() < 52) {
        assertMissingField(ChangeField.EXTENSION);
        String unsupportedOperatorMsg = "'extension' operator is not supported by change index version";
        assertFailingQuery("extension:txt", unsupportedOperatorMsg);
        assertFailingQuery("ext:txt", unsupportedOperatorMsg);
        return;
    }
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = insert(repo, newChangeWithFiles(repo, "foo.h", "foo.cc"));
    Change change2 = insert(repo, newChangeWithFiles(repo, "bar.H", "bar.CC"));
    Change change3 = insert(repo, newChangeWithFiles(repo, "dir/baz.h", "dir/baz.cc"));
    Change change4 = insert(repo, newChangeWithFiles(repo, "Quux.java"));
    assertQuery("extension:java", change4);
    assertQuery("ext:java", change4);
    assertQuery("ext:.java", change4);
    assertQuery("ext:jAvA", change4);
    assertQuery("ext:.jAvA", change4);
    assertQuery("ext:cc", change3, change2, change1);
}
#end_block

#method_before
@Before
public void beforeEach() throws Exception {
    CredentialsProvider.setDefault(new UsernamePasswordCredentialsProvider(admin.username, admin.httpPassword));
    selectProtocol(AbstractPushForReview.Protocol.HTTP);
    auditService.clearEvents();
}
#method_after
@Before
public void beforeEach() throws Exception {
    CredentialsProvider.setDefault(new UsernamePasswordCredentialsProvider(admin.username, admin.httpPassword));
    selectProtocol(AbstractPushForReview.Protocol.HTTP);
}
#end_block

#method_before
@Test
@Sandboxed
public void receivePackAuditEventLog() throws Exception {
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master")).call();
    waitForAudit();
    // Git smart protocol makes two requests:
    // https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt
    assertThat(auditService.auditEvents.size()).isEqualTo(2);
    AuditEvent e = auditService.auditEvents.get(1);
    assertThat(e.who.getAccountId()).isEqualTo(admin.id);
    assertThat(e.what).endsWith("/git-receive-pack");
    assertThat(e.params).isEmpty();
    assertThat(((HttpAuditEvent) e).httpStatus).isEqualTo(HttpServletResponse.SC_OK);
}
#method_after
@Test
@Sandboxed
public void receivePackAuditEventLog() throws Exception {
    FakeGroupAuditService auditService = clearAuditService();
    testRepo.git().push().setRemote("origin").setRefSpecs(new RefSpec("HEAD:refs/for/master")).call();
    waitForAudit(auditService);
    // Git smart protocol makes two requests:
    // https://github.com/git/git/blob/master/Documentation/technical/http-protocol.txt
    assertThat(auditService.auditEvents.size()).isEqualTo(2);
    AuditEvent e = auditService.auditEvents.get(1);
    assertThat(e.who.getAccountId()).isEqualTo(admin.id);
    assertThat(e.what).endsWith("/git-receive-pack");
    assertThat(e.params).isEmpty();
    assertThat(((HttpAuditEvent) e).httpStatus).isEqualTo(HttpServletResponse.SC_OK);
}
#end_block

#method_before
@Test
@Sandboxed
public void uploadPackAuditEventLog() throws Exception {
    testRepo.git().fetch().call();
    waitForAudit();
    assertThat(auditService.auditEvents.size()).isEqualTo(1);
    AuditEvent e = auditService.auditEvents.get(0);
    assertThat(e.who.toString()).isEqualTo("ANONYMOUS");
    assertThat(e.params.get("service")).containsExactlyElementsIn(Collections.singletonList("git-upload-pack"));
    assertThat(e.what).endsWith("service=git-upload-pack");
    assertThat(((HttpAuditEvent) e).httpStatus).isEqualTo(HttpServletResponse.SC_OK);
}
#method_after
@Test
@Sandboxed
public void uploadPackAuditEventLog() throws Exception {
    FakeGroupAuditService auditService = clearAuditService();
    testRepo.git().fetch().call();
    waitForAudit(auditService);
    assertThat(auditService.auditEvents.size()).isEqualTo(1);
    AuditEvent e = auditService.auditEvents.get(0);
    assertThat(e.who.toString()).isEqualTo("ANONYMOUS");
    assertThat(e.params.get("service")).containsExactlyElementsIn(Collections.singletonList("git-upload-pack"));
    assertThat(e.what).endsWith("service=git-upload-pack");
    assertThat(((HttpAuditEvent) e).httpStatus).isEqualTo(HttpServletResponse.SC_OK);
}
#end_block

#method_before
private void waitForAudit() throws InterruptedException {
    synchronized (auditService.auditEvents) {
        auditService.auditEvents.wait(AUDIT_EVENT_TIMEOUT);
    }
}
#method_after
private void waitForAudit(FakeGroupAuditService auditService) throws InterruptedException {
    synchronized (auditService.auditEvents) {
        auditService.auditEvents.wait(AUDIT_EVENT_TIMEOUT);
    }
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        Iterable<Project.NameKey> projectNames = filter(perm)::iterator;
        for (Project.NameKey projectName : projectNames) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
            info.webLinks = links.isEmpty() ? null : links;
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        Iterable<ProjectState> projectStatesIt = filter(perm)::iterator;
        for (ProjectState e : projectStatesIt) {
            Project.NameKey projectName = e.getNameKey();
            if (e.getProject().getState() == HIDDEN && !all && state != HIDDEN) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
            info.webLinks = links.isEmpty() ? null : links;
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
private Stream<Project.NameKey> filter(PermissionBackend.WithUser perm) throws BadRequestException {
    Stream<Project.NameKey> matches = StreamSupport.stream(scan().spliterator(), false);
    return matches.filter(p -> perm.project(p).testOrFalse(ProjectPermission.ACCESS));
}
#method_after
private Stream<ProjectState> filter(PermissionBackend.WithUser perm) throws BadRequestException {
    return StreamSupport.stream(scan().spliterator(), false).map(projectCache::get).filter(Objects::nonNull).filter(p -> permissionCheck(p, perm));
}
#end_block

#method_before
public Optional<RateLimit> firstMatching(AccountLimitsConfig.Type type, IdentifiedUser user) {
    Optional<Map<String, AccountLimitsConfig.RateLimit>> limits = getRatelimits(type);
    if (limits.isPresent()) {
        GroupMembership membership = user.getEffectiveGroups();
        for (String groupName : limits.get().keySet()) {
            try {
                GroupResource group = groupsCollection.parse(TopLevelResource.INSTANCE, IdString.fromDecoded(groupName));
                Optional<GroupDescription.Internal> maybeInternalGroup = group.asInternalGroup();
                if (!maybeInternalGroup.isPresent()) {
                    log.error("Ignoring limits for non-internal group ''{}'' in quota.config", groupName);
                } else if (membership.contains(maybeInternalGroup.get().getGroupUUID())) {
                    return Optional.ofNullable(limits.get().get(groupName));
                }
            } catch (ResourceNotFoundException e) {
                log.error("Ignoring limits for unknown group ''{}'' in quota.config", groupName);
            } catch (AuthException e) {
                log.error("Ignoring limits for non-visible group ''{}'' in quota.config", groupName);
            }
        }
    }
    return Optional.empty();
}
#method_after
public Optional<RateLimit> firstMatching(AccountLimitsConfig.Type type, IdentifiedUser user) {
    Optional<Map<String, AccountLimitsConfig.RateLimit>> limits = getRatelimits(type);
    if (limits.isPresent()) {
        GroupMembership memberShip = user.getEffectiveGroups();
        for (String groupName : limits.get().keySet()) {
            try {
                GroupResource group = groupsCollection.parse(TopLevelResource.INSTANCE, IdString.fromDecoded(groupName));
                Optional<GroupDescription.Internal> maybeInternalGroup = group.asInternalGroup();
                if (!maybeInternalGroup.isPresent()) {
                    log.error("Ignoring limits for non-internal group ''{}'' in quota.config", groupName);
                } else if (memberShip.contains(maybeInternalGroup.get().getGroupUUID())) {
                    return Optional.ofNullable(limits.get().get(groupName));
                }
            } catch (ResourceNotFoundException e) {
                log.error("Ignoring limits for unknown group ''{}'' in quota.config", groupName);
            } catch (AuthException e) {
                log.error("Ignoring limits for non-visible group ''{}'' in quota.config", groupName);
            }
        }
    }
    return Optional.empty();
}
#end_block

#method_before
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (Project.NameKey projectName : filter(perm)) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#method_after
public SortedMap<String, ProjectInfo> display(@Nullable OutputStream displayOutputStream) throws BadRequestException, PermissionBackendException {
    if (all && state != null) {
        throw new BadRequestException("'all' and 'state' may not be used together");
    }
    if (groupUuid != null) {
        try {
            if (!groupControlFactory.controlFor(groupUuid).isVisible()) {
                return Collections.emptySortedMap();
            }
        } catch (NoSuchGroupException ex) {
            return Collections.emptySortedMap();
        }
    }
    PrintWriter stdout = null;
    if (displayOutputStream != null) {
        stdout = new PrintWriter(new BufferedWriter(new OutputStreamWriter(displayOutputStream, UTF_8)));
    }
    int foundIndex = 0;
    int found = 0;
    TreeMap<String, ProjectInfo> output = new TreeMap<>();
    Map<String, String> hiddenNames = new HashMap<>();
    Map<Project.NameKey, Boolean> accessibleParents = new HashMap<>();
    PermissionBackend.WithUser perm = permissionBackend.user(currentUser);
    final TreeMap<Project.NameKey, ProjectNode> treeMap = new TreeMap<>();
    try {
        for (Project.NameKey projectName : filter(perm)) {
            final ProjectState e = projectCache.get(projectName);
            if (e == null || (e.getProject().getState() == HIDDEN && !all && state != HIDDEN)) {
                // If state HIDDEN wasn't selected, and it's HIDDEN, pretend it's not present.
                continue;
            }
            if (state != null && e.getProject().getState() != state) {
                continue;
            }
            if (groupUuid != null && !e.getLocalGroups().contains(GroupReference.forGroup(groupResolver.parseId(groupUuid.get())))) {
                continue;
            }
            ProjectInfo info = new ProjectInfo();
            if (showTree && !format.isJson()) {
                treeMap.put(projectName, projectNodeFactory.create(e.getProject(), true));
                continue;
            }
            info.name = projectName.get();
            if (showTree && format.isJson()) {
                ProjectState parent = Iterables.getFirst(e.parents(), null);
                if (parent != null) {
                    if (isParentAccessible(accessibleParents, perm, parent)) {
                        info.parent = parent.getName();
                    } else {
                        info.parent = hiddenNames.get(parent.getName());
                        if (info.parent == null) {
                            info.parent = "?-" + (hiddenNames.size() + 1);
                            hiddenNames.put(parent.getName(), info.parent);
                        }
                    }
                }
            }
            if (showDescription) {
                info.description = Strings.emptyToNull(e.getProject().getDescription());
            }
            info.state = e.getProject().getState();
            try {
                if (!showBranch.isEmpty()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                        boolean canReadAllRefs = e.statePermitsRead();
                        if (canReadAllRefs) {
                            try {
                                permissionBackend.user(currentUser).project(e.getNameKey()).check(ProjectPermission.READ);
                            } catch (AuthException exp) {
                                canReadAllRefs = false;
                            }
                        }
                        List<Ref> refs = getBranchRefs(projectName, canReadAllRefs);
                        if (!hasValidRef(refs)) {
                            continue;
                        }
                        for (int i = 0; i < showBranch.size(); i++) {
                            Ref ref = refs.get(i);
                            if (ref != null && ref.getObjectId() != null) {
                                if (info.branches == null) {
                                    info.branches = new LinkedHashMap<>();
                                }
                                info.branches.put(showBranch.get(i), ref.getObjectId().name());
                            }
                        }
                    }
                } else if (!showTree && type.useMatch()) {
                    try (Repository git = repoManager.openRepository(projectName)) {
                        if (!type.matches(git)) {
                            continue;
                        }
                    }
                }
            } catch (RepositoryNotFoundException err) {
                // If the Git repository is gone, the project doesn't actually exist anymore.
                continue;
            } catch (IOException err) {
                logger.atWarning().withCause(err).log("Unexpected error reading %s", projectName);
                continue;
            }
            List<WebLinkInfo> links = webLinks.getProjectLinks(projectName.get());
            info.webLinks = links.isEmpty() ? null : links;
            if (foundIndex++ < start) {
                continue;
            }
            if (limit > 0 && ++found > limit) {
                break;
            }
            if (stdout == null || format.isJson()) {
                output.put(info.name, info);
                continue;
            }
            if (!showBranch.isEmpty()) {
                for (String name : showBranch) {
                    String ref = info.branches != null ? info.branches.get(name) : null;
                    if (ref == null) {
                        // Print stub (forty '-' symbols)
                        ref = "----------------------------------------";
                    }
                    stdout.print(ref);
                    stdout.print(' ');
                }
            }
            stdout.print(info.name);
            if (info.description != null) {
                // We still want to list every project as one-liners, hence escaping \n.
                stdout.print(" - " + StringUtil.escapeString(info.description));
            }
            stdout.print('\n');
        }
        for (ProjectInfo info : output.values()) {
            info.id = Url.encode(info.name);
            info.name = null;
        }
        if (stdout == null) {
            return output;
        } else if (format.isJson()) {
            format.newGson().toJson(output, new TypeToken<Map<String, ProjectInfo>>() {
            }.getType(), stdout);
            stdout.print('\n');
        } else if (showTree && treeMap.size() > 0) {
            printProjectTree(stdout, treeMap);
        }
        return null;
    } finally {
        if (stdout != null) {
            stdout.flush();
        }
    }
}
#end_block

#method_before
@Test
public void shouldBeHealthyWhenListProjectsWorks() {
    ProjectsListHealthCheck jGitHealthCheck = new ProjectsListHealthCheck(executor, getWorkingProjectList(0), new DisabledMetricMaker());
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.PASSED);
}
#method_after
@Test
public void shouldBeHealthyWhenListProjectsWorks() {
    ProjectsListHealthCheck jGitHealthCheck = new ProjectsListHealthCheck(executor, getWorkingProjectList(0), metricsHandlerFactory);
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.PASSED);
}
#end_block

#method_before
@Test
public void shouldBeUnhealthyWhenListProjectsIsFailing() {
    ProjectsListHealthCheck jGitHealthCheck = new ProjectsListHealthCheck(executor, getFailingProjectList(), new DisabledMetricMaker());
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.FAILED);
}
#method_after
@Test
public void shouldBeUnhealthyWhenListProjectsIsFailing() {
    ProjectsListHealthCheck jGitHealthCheck = new ProjectsListHealthCheck(executor, getFailingProjectList(), metricsHandlerFactory);
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.FAILED);
}
#end_block

#method_before
@Test
public void shouldBeUnhealthyWhenListProjectsIsTimingOut() {
    ProjectsListHealthCheck jGitHealthCheck = new ProjectsListHealthCheck(executor, getWorkingProjectList(AbstractHealthCheck.CHECK_TIMEOUT * 2), new DisabledMetricMaker());
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.TIMEOUT);
}
#method_after
@Test
public void shouldBeUnhealthyWhenListProjectsIsTimingOut() {
    ProjectsListHealthCheck jGitHealthCheck = new ProjectsListHealthCheck(executor, getWorkingProjectList(AbstractHealthCheck.CHECK_TIMEOUT * 2), metricsHandlerFactory);
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.TIMEOUT);
}
#end_block

#method_before
private ListProjects getFailingProjectList() {
    return new ListProjects(null, null, null, null, null, null, null, null) {

        @Override
        public SortedMap<String, ProjectInfo> apply() throws BadRequestException {
            throw new IllegalArgumentException("Unable to return project list");
        }
    };
}
#method_after
private ListProjects getFailingProjectList() {
    return new ListProjects(null, null, null, null, null, null, null) {

        @Override
        public SortedMap<String, ProjectInfo> apply() throws BadRequestException {
            throw new IllegalArgumentException("Unable to return project list");
        }
    };
}
#end_block

#method_before
private ListProjects getWorkingProjectList(long execTime) {
    return new ListProjects(null, null, null, null, null, null, null, null) {

        @Override
        public SortedMap<String, ProjectInfo> apply() throws BadRequestException {
            SortedMap<String, ProjectInfo> projects = new TreeMap<>();
            projects.put("testproject", new ProjectInfo());
            try {
                Thread.sleep(execTime);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            return projects;
        }
    };
}
#method_after
private ListProjects getWorkingProjectList(long execTime) {
    return new ListProjects(null, null, null, null, null, null, null) {

        @Override
        public SortedMap<String, ProjectInfo> apply() throws BadRequestException {
            SortedMap<String, ProjectInfo> projects = new TreeMap<>();
            projects.put("testproject", new ProjectInfo());
            try {
                Thread.sleep(execTime);
            } catch (InterruptedException e) {
                throw new IllegalStateException(e);
            }
            return projects;
        }
    };
}
#end_block

#method_before
@Test
public void shouldBeHealthyWhenJGitIsWorking() {
    JGitHealthCheck reviewDbCheck = new JGitHealthCheck(executor, getWorkingRepositoryManager(), allProjectsName, new DisabledMetricMaker());
    assertThat(reviewDbCheck.run().result).isEqualTo(Result.PASSED);
}
#method_after
@Test
public void shouldBeHealthyWhenJGitIsWorking() {
    JGitHealthCheck reviewDbCheck = new JGitHealthCheck(executor, getWorkingRepositoryManager(), allProjectsName, metricsHandlerFactory);
    assertThat(reviewDbCheck.run().result).isEqualTo(Result.PASSED);
}
#end_block

#method_before
@Test
public void shouldBeUnhealthyWhenJGitIsFailing() {
    JGitHealthCheck jGitHealthCheck = new JGitHealthCheck(executor, getFailingGitRepositoryManager(), allProjectsName, new DisabledMetricMaker());
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.FAILED);
}
#method_after
@Test
public void shouldBeUnhealthyWhenJGitIsFailing() {
    JGitHealthCheck jGitHealthCheck = new JGitHealthCheck(executor, getFailingGitRepositoryManager(), allProjectsName, metricsHandlerFactory);
    assertThat(jGitHealthCheck.run().result).isEqualTo(Result.FAILED);
}
#end_block

#method_before
@Override
public Status run() {
    final long ts = System.currentTimeMillis();
    ListenableFuture<Status> resultFuture = executor.submit(() -> {
        Result healthy;
        try {
            healthy = doCheck();
        } catch (Exception e) {
            log.warn("Check {} failed", name, e);
            healthy = Result.FAILED;
        }
        Status status = new Status(healthy, ts, System.currentTimeMillis() - ts);
        metrics.sendMetrics(status);
        return status;
    });
    try {
        return resultFuture.get(CHECK_TIMEOUT, TimeUnit.MILLISECONDS);
    } catch (TimeoutException e) {
        log.warn("Check {} timed out", name, e);
        return new Status(Result.TIMEOUT, ts, System.currentTimeMillis() - ts);
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Check {} failed while waiting for its future result", name, e);
        return new Status(Result.FAILED, ts, System.currentTimeMillis() - ts);
    }
}
#method_after
@Override
public Status run() {
    final long ts = System.currentTimeMillis();
    Status status = null;
    ListenableFuture<Status> resultFuture = executor.submit(() -> {
        Result healthy;
        try {
            healthy = doCheck();
        } catch (Exception e) {
            log.warn("Check {} failed", name, e);
            healthy = Result.FAILED;
        }
        return new Status(healthy, ts, System.currentTimeMillis() - ts);
    });
    try {
        status = resultFuture.get(CHECK_TIMEOUT, TimeUnit.MILLISECONDS);
    } catch (TimeoutException e) {
        log.warn("Check {} timed out", name, e);
        status = new Status(Result.TIMEOUT, ts, System.currentTimeMillis() - ts);
    } catch (InterruptedException | ExecutionException e) {
        log.warn("Check {} failed while waiting for its future result", name, e);
        status = new Status(Result.FAILED, ts, System.currentTimeMillis() - ts);
    } finally {
        metricsHandler.sendMetrics(status);
    }
    return status;
}
#end_block

#method_before
@Test
public void shouldBeHealthyWhenReviewDbIsWorking() {
    ReviewDbHealthCheck reviewDbCheck = new ReviewDbHealthCheck(executor, workingReviewDbFactory, new DisabledMetricMaker());
    assertThat(reviewDbCheck.run().result).isEqualTo(HealthCheck.Result.PASSED);
}
#method_after
@Test
public void shouldBeHealthyWhenReviewDbIsWorking() {
    ReviewDbHealthCheck reviewDbCheck = new ReviewDbHealthCheck(executor, workingReviewDbFactory, metricsHandlerFactory);
    assertThat(reviewDbCheck.run().result).isEqualTo(HealthCheck.Result.PASSED);
}
#end_block

#method_before
@Test
public void shouldBeUnhealthyWhenReviewDbIsFailing() {
    ReviewDbHealthCheck reviewDbCheck = new ReviewDbHealthCheck(executor, getFailingReviewDbProvider(), new DisabledMetricMaker());
    assertThat(reviewDbCheck.run().result).isEqualTo(HealthCheck.Result.FAILED);
}
#method_after
@Test
public void shouldBeUnhealthyWhenReviewDbIsFailing() {
    ReviewDbHealthCheck reviewDbCheck = new ReviewDbHealthCheck(executor, getFailingReviewDbProvider(), metricsHandlerFactory);
    assertThat(reviewDbCheck.run().result).isEqualTo(HealthCheck.Result.FAILED);
}
#end_block

#method_before
@Test
public void readAllProjectsBaseConfigFromSitePaths() throws Exception {
    ProjectConfig cfg = factory.create(ALL_PROJECTS);
    cfg.load(db);
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.INHERIT);
    Files.write(sitePaths.etc_dir.resolve(ALL_PROJECTS_CONFIG), ImmutableList.of("[receive]", "requireChangeId = false"));
    cfg.load(db);
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.FALSE);
}
#method_after
@Test
public void readAllProjectsBaseConfigFromSitePaths() throws Exception {
    ProjectConfig cfg = factory.create(ALL_PROJECTS);
    cfg.load(db);
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.INHERIT);
    writeDefaultAllProjectsConfig("[receive]", "requireChangeId = false");
    cfg.load(db);
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.FALSE);
}
#end_block

#method_before
@Test
public void readOtherProjectIgnoresAllProjectsBaseConfig() throws Exception {
    ProjectConfig cfg = factory.create(new Project.NameKey("test"));
    cfg.load(db);
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.INHERIT);
    Files.write(sitePaths.etc_dir.resolve(ALL_PROJECTS_CONFIG), ImmutableList.of("[receive]", "requireChangeId = false"));
    cfg.load(db);
    // If we went through ProjectState, then this would return FALSE, since project.config for
    // All-Projects would inherit from all_projects.config, and this project would inherit from
    // All-Projects. But in ProjectConfig itself, there is no inheritance from All-Projects, so this
    // continues to return the default.
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.INHERIT);
}
#method_after
@Test
public void readOtherProjectIgnoresAllProjectsBaseConfig() throws Exception {
    ProjectConfig cfg = factory.create(new Project.NameKey("test"));
    cfg.load(db);
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.INHERIT);
    writeDefaultAllProjectsConfig("[receive]", "requireChangeId = false");
    cfg.load(db);
    // If we went through ProjectState, then this would return FALSE, since project.config for
    // All-Projects would inherit from all_projects.config, and this project would inherit from
    // All-Projects. But in ProjectConfig itself, there is no inheritance from All-Projects, so this
    // continues to return the default.
    assertThat(cfg.getProject().getBooleanConfig(REQUIRE_CHANGE_ID)).isEqualTo(InheritableBoolean.INHERIT);
}
#end_block

#method_before
public ProjectConfig create(Project.NameKey projectName) {
    return new ProjectConfig(projectName, projectName.equals(allProjects) ? // Delay loading till onLoad method.
    new FileBasedConfig(sitePaths.etc_dir.resolve(ALL_PROJECTS_CONFIG).toFile(), FS.DETECTED) : null);
}
#method_after
public ProjectConfig create(Project.NameKey projectName) {
    return new ProjectConfig(projectName, getBaseConfig(sitePaths, allProjects, projectName));
}
#end_block

#method_before
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repo, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        Map<String, Ref> refs;
        if (opts.prefixes().isEmpty()) {
            refs = repo.getAllRefs();
        } else {
            try {
                refs = repo.getRefDatabase().getRefsByPrefix(opts.prefixes().toArray(new String[0])).stream().collect(Collectors.toMap(Ref::getName, r -> r));
            } catch (IOException e) {
                refs = new HashMap<>();
            }
        }
        return perm.filter(refs, repo, opts);
    } catch (PermissionBackendException e) {
        ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
        ex.initCause(e);
        throw ex;
    }
}
#method_after
@Override
protected Map<String, Ref> getAdvertisedRefs(Repository repo, RevWalk revWalk) throws ServiceMayNotContinueException {
    try {
        Map<String, Ref> refs;
        List<String> prefixes = opts.prefixes();
        if (prefixes.isEmpty() || prefixes.get(0).isEmpty()) {
            refs = repo.getAllRefs();
        } else {
            ImmutableMap.Builder<String, Ref> b = new ImmutableMap.Builder<>();
            for (String prefix : prefixes) {
                for (Ref ref : repo.getRefDatabase().getRefsByPrefix(prefix)) {
                    b.put(ref.getName(), ref);
                }
            }
            refs = b.build();
        }
        return perm.filter(refs, repo, opts);
    } catch (IOException | PermissionBackendException e) {
        ServiceMayNotContinueException ex = new ServiceMayNotContinueException();
        ex.initCause(e);
        throw ex;
    }
}
#end_block

#method_before
public T database(ReviewDb db) {
    return database(Providers.of(checkNotNull(db, "ReviewDb")));
}
#method_after
public T database(ReviewDb db) {
    return database(Providers.of(requireNonNull(db, "ReviewDb")));
}
#end_block

#method_before
public Set<Project.NameKey> filter(ProjectPermission perm, Collection<Project.NameKey> projects) throws PermissionBackendException {
    checkNotNull(perm, "ProjectPermission");
    checkNotNull(projects, "projects");
    Set<Project.NameKey> allowed = Sets.newHashSetWithExpectedSize(projects.size());
    for (Project.NameKey project : projects) {
        try {
            project(project).check(perm);
            allowed.add(project);
        } catch (AuthException e) {
        // Do not include this project in allowed.
        } catch (PermissionBackendException e) {
            if (e.getCause() instanceof RepositoryNotFoundException) {
                logger.atWarning().withCause(e).log("Could not find repository of the project %s", project.get());
            // Do not include this project because doesn't exist
            } else {
                throw e;
            }
        }
    }
    return allowed;
}
#method_after
public Set<Project.NameKey> filter(ProjectPermission perm, Collection<Project.NameKey> projects) throws PermissionBackendException {
    requireNonNull(perm, "ProjectPermission");
    requireNonNull(projects, "projects");
    Set<Project.NameKey> allowed = Sets.newHashSetWithExpectedSize(projects.size());
    for (Project.NameKey project : projects) {
        try {
            project(project).check(perm);
            allowed.add(project);
        } catch (AuthException e) {
        // Do not include this project in allowed.
        } catch (PermissionBackendException e) {
            if (e.getCause() instanceof RepositoryNotFoundException) {
                logger.atWarning().withCause(e).log("Could not find repository of the project %s", project.get());
            // Do not include this project because doesn't exist
            } else {
                throw e;
            }
        }
    }
    return allowed;
}
#end_block

#method_before
public static Builder builder() {
    return new AutoValue_PermissionBackend_RefFilterOptions.Builder().setFilterMeta(false).setFilterTagsSeparately(false).setPrefixes(Collections.emptyList());
}
#method_after
public static Builder builder() {
    return new AutoValue_PermissionBackend_RefFilterOptions.Builder().setFilterMeta(false).setFilterTagsSeparately(false).setPrefixes(Collections.singletonList(""));
}
#end_block

#method_before
public Set<LabelPermission.WithValue> test(LabelType label) throws PermissionBackendException {
    return test(valuesOf(checkNotNull(label, "LabelType")));
}
#method_after
public Set<LabelPermission.WithValue> test(LabelType label) throws PermissionBackendException {
    return test(valuesOf(requireNonNull(label, "LabelType")));
}
#end_block

#method_before
public Set<LabelPermission.WithValue> testLabels(Collection<LabelType> types) throws PermissionBackendException {
    checkNotNull(types, "LabelType");
    return test(types.stream().flatMap((t) -> valuesOf(t).stream()).collect(toSet()));
}
#method_after
public Set<LabelPermission.WithValue> testLabels(Collection<LabelType> types) throws PermissionBackendException {
    requireNonNull(types, "LabelType");
    return test(types.stream().flatMap((t) -> valuesOf(t).stream()).collect(toSet()));
}
#end_block

#method_before
private void store(AbstractIndexRestApiServlet.IndexName index, LocalDateTime latestTs) {
    LocalDateTime currTs = storedTs.get(index);
    if (currTs == null || latestTs.isAfter(currTs)) {
        Path indexTsFile = dataDir.resolve(index.name().toLowerCase());
        try {
            Files.write(indexTsFile, latestTs.format(formatter).getBytes(StandardCharsets.UTF_8));
            storedTs.put(index, currTs);
        } catch (IOException e) {
            log.error("Unable to update last timestamp for index " + index, e);
        }
    }
}
#method_after
private void store(AbstractIndexRestApiServlet.IndexName index, LocalDateTime latestTs) {
    Optional<LocalDateTime> currTs = getUpdateTs(index);
    if (!currTs.isPresent() || latestTs.isAfter(currTs.get())) {
        Path indexTsFile = dataDir.resolve(index.name().toLowerCase());
        try {
            Files.write(indexTsFile, latestTs.format(formatter).getBytes(StandardCharsets.UTF_8));
        } catch (IOException e) {
            log.error("Unable to update last timestamp for index " + index, e);
        }
    }
}
#end_block

#method_before
@Override
public Optional<ChangeNotes> getChangeNotes() throws OrmException {
    try (ManualRequestContext ctx = oneOffReqCtx.open()) {
        this.changeNotes = Optional.ofNullable(changeFinder.findOne(changeId));
        return changeNotes;
    }
}
#method_after
@Override
public Optional<ChangeNotes> getChangeNotes() throws OrmException {
    try (ManualRequestContext ctx = oneOffReqCtx.open()) {
        changeNotes = Optional.ofNullable(changeFinder.findOne(changeId));
        return changeNotes;
    }
}
#end_block

#method_before
@Override
public boolean isChangeUpToDate(Optional<IndexEvent> indexEvent) throws IOException, OrmException {
    getComputedChangeTs();
    if (!computedChangeTs.isPresent()) {
        log.warn("Unable to compute last updated ts for change {}", changeId);
        return true;
    }
    if (indexEvent.isPresent() && indexEvent.get().targetSha == null) {
        return indexEvent.map(e -> (computedChangeTs.get() >= e.eventCreatedOn)).orElse(true);
    }
    return indexEvent.map(e -> (computedChangeTs.get() > e.eventCreatedOn) || (computedChangeTs.get() == e.eventCreatedOn) && (Objects.equals(getBranchTargetSha(), e.targetSha))).orElse(true);
}
#method_after
@Override
public boolean isChangeUpToDate(Optional<IndexEvent> indexEvent) throws IOException, OrmException {
    getComputedChangeTs();
    log.debug("Checking change {} against index event {}", this, indexEvent);
    if (!computedChangeTs.isPresent()) {
        log.warn("Unable to compute last updated ts for change {}", changeId);
        return false;
    }
    if (indexEvent.isPresent() && indexEvent.get().targetSha == null) {
        return indexEvent.map(e -> (computedChangeTs.get() >= e.eventCreatedOn)).orElse(true);
    }
    return indexEvent.map(e -> (computedChangeTs.get() > e.eventCreatedOn) || (computedChangeTs.get() == e.eventCreatedOn) && (Objects.equals(getBranchTargetSha(), e.targetSha))).orElse(true);
}
#end_block

#method_before
private String getBranchTargetSha() {
    try {
        try (Repository repo = gitRepoMgr.openRepository(changeNotes.get().getProjectName())) {
            String refName = changeNotes.get().getChange().getDest().get();
            Ref ref = repo.exactRef(refName);
            if (ref == null) {
                log.warn("Unable to find target ref {} for change {}", refName, changeId);
                return null;
            }
            return ref.getTarget().getObjectId().getName();
        }
    } catch (IOException e) {
        log.warn("Unable to resolve target branch SHA for change {}", changeId, e);
        return null;
    }
}
#method_after
private String getBranchTargetSha() {
    try (Repository repo = gitRepoMgr.openRepository(changeNotes.get().getProjectName())) {
        String refName = changeNotes.get().getChange().getDest().get();
        Ref ref = repo.exactRef(refName);
        if (ref == null) {
            log.warn("Unable to find target ref {} for change {}", refName, changeId);
            return null;
        }
        return ref.getTarget().getObjectId().getName();
    } catch (IOException e) {
        log.warn("Unable to resolve target branch SHA for change {}", changeId, e);
        return null;
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    when(changeDbMock.open()).thenReturn(dbMock);
    id = new Change.Id(TEST_CHANGE_NUMBER);
    change = new Change(null, id, null, null, TimeUtil.nowTs());
    when(changeNotes.getChange()).thenReturn(change);
    when(changeCheckerFactoryMock.create(any())).thenReturn(changeCheckerAbsentMock);
    handler = new ForwardedIndexChangeHandler(indexerMock, changeDbMock, configurationMock, indexExecutorMock, ctxMock, changeCheckerFactoryMock);
}
#method_after
@Before
public void setUp() throws Exception {
    when(changeDbMock.open()).thenReturn(dbMock);
    id = new Change.Id(TEST_CHANGE_NUMBER);
    change = new Change(null, id, null, null, TimeUtil.nowTs());
    when(changeNotes.getChange()).thenReturn(change);
    when(configMock.index()).thenReturn(indexMock);
    when(indexMock.numStripedLocks()).thenReturn(10);
    when(changeCheckerFactoryMock.create(any())).thenReturn(changeCheckerAbsentMock);
    handler = new ForwardedIndexChangeHandler(indexerMock, changeDbMock, changeFinderMock, configMock, indexExecutorMock, ctxMock, changeCheckerFactoryMock);
}
#end_block

#method_before
private void doIndex(String id, Optional<Object> maybeBody, int retryCount) throws IOException, OrmException {
    ChangeNotes change = null;
    Optional<ChangeIndexedEvent> indexEvent = maybeBody.map(e -> (ChangeIndexedEvent) e);
    try (ReviewDb db = schemaFactory.open()) {
        change = changeFinder.findOne(id);
        if (change != null) {
            Timestamp changeTs = computeLastChangeTs(db, change);
            indexer.index(db, change.getChange());
            if (isChangeUpToDate(changeTs, indexEvent)) {
                log.debug("Change {} successfully indexed", id);
            } else {
                log.warn("Change {} indexed, however it may be inaccurate as it seems too old compared compared to the event timestamp (event-Ts={} >> change-Ts={})", id, indexEvent, changeTs);
                rescheduleIndex(id, maybeBody, retryCount++);
            }
        } else {
            log.warn("Change {} could not be found in the local Git repository (eventTs={})", id, indexEvent);
        }
    } catch (Exception e) {
        if (!isCausedByNoSuchChangeException(e)) {
            throw e;
        }
        log.debug("Change {} was deleted, aborting forwarded indexing the change.", id);
    }
    if (change == null) {
        indexer.delete(parseChangeId(id));
        log.warn("Change {} not found, deleted from index", id);
    }
}
#method_after
@Override
protected void doIndex(String id, Optional<IndexEvent> indexEvent) throws IOException, OrmException {
    doIndex(id, indexEvent, 0);
}
#end_block

#method_before
private void rescheduleIndex(final String id, final Optional<Object> maybeBody, int retryCount) {
    int retryInterval = configuration.index().retryInterval();
    int maxTries = configuration.index().maxTries();
    if (retryCount >= maxTries) {
        log.error("Change {} could not be indexed after {} retries. *CHANGE INDEX IS STALE*");
        return;
    }
    log.warn("Retrying for the #{} time to index Change {} after {} msecs", retryCount, id, retryInterval);
    indexExecutor.schedule(() -> {
        try {
            doIndex(id, maybeBody);
        } catch (Exception e) {
            log.warn("Change {} could not be indexed", id, e);
        }
    }, retryInterval, TimeUnit.MILLISECONDS);
}
#method_after
private void rescheduleIndex(String id, Optional<IndexEvent> indexEvent, int retryCount) {
    if (retryCount > maxTries) {
        log.error("Change {} could not be indexed after {} retries. Change index could be stale.", id, retryCount);
        return;
    }
    log.warn("Retrying for the #{} time to index Change {} after {} msecs", retryCount, id, retryInterval);
    indexExecutor.schedule(() -> {
        try (ManualRequestContext ctx = oneOffCtx.open()) {
            Context.setForwardedEvent(true);
            doIndex(id, indexEvent, retryCount);
        } catch (Exception e) {
            log.warn("Change {} could not be indexed", id, e);
        }
    }, retryInterval, TimeUnit.MILLISECONDS);
}
#end_block

#method_before
@Override
protected void doDelete(String id) throws IOException {
    indexer.delete(parseChangeId(id));
    log.debug("Change {} successfully deleted from index", id);
}
#method_after
@Override
protected void doDelete(String id, Optional<IndexEvent> indexEvent) throws IOException {
    indexer.delete(parseChangeId(id));
    log.debug("Change {} successfully deleted from index", id);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    when(schemaFactoryMock.open()).thenReturn(dbMock);
    id = new Change.Id(TEST_CHANGE_NUMBER);
    change = new Change(null, id, null, null, TimeUtil.nowTs());
    when(changeNotes.getChange()).thenReturn(change);
    handler = new ForwardedIndexChangeHandler(indexerMock, schemaFactoryMock, changeFinderMock, commentsUtilMock, indexExecutorMock, configurationMock);
}
#method_after
@Before
public void setUp() throws Exception {
    when(schemaFactoryMock.open()).thenReturn(dbMock);
    id = new Change.Id(TEST_CHANGE_NUMBER);
    change = new Change(null, id, null, null, TimeUtil.nowTs());
    when(changeNotes.getChange()).thenReturn(change);
    when(configMock.index()).thenReturn(indexMock);
    when(indexMock.numStripedLocks()).thenReturn(10);
    when(changeCheckerFactoryMock.create(any())).thenReturn(changeCheckerAbsentMock);
    handler = new ForwardedIndexChangeHandler(indexerMock, schemaFactoryMock, changeFinderMock, configMock, indexExecutorMock, ctxMock, changeCheckerFactoryMock);
}
#end_block

#method_before
@Test
public void changeIsDeletedFromIndex() throws Exception {
    handler.index(TEST_CHANGE_ID, Operation.DELETE);
    verify(indexerMock, times(1)).delete(id);
}
#method_after
@Test
public void changeIsDeletedFromIndex() throws Exception {
    handler.index(TEST_CHANGE_ID, Operation.DELETE, Optional.empty());
    verify(indexerMock, times(1)).delete(id);
}
#end_block

#method_before
@Test
public void changeToIndexDoesNotExist() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_DOES_NOT_EXIST);
    handler.index(TEST_CHANGE_ID, Operation.INDEX);
    verify(indexerMock, times(1)).delete(id);
}
#method_after
@Test
public void changeToIndexDoesNotExist() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_DOES_NOT_EXIST, CHANGE_OUTDATED);
    handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
    verify(indexerMock, times(1)).delete(id);
}
#end_block

#method_before
@Test
public void schemaThrowsExceptionWhenLookingUpForChange() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS, THROW_ORM_EXCEPTION);
    exception.expect(OrmException.class);
    handler.index(TEST_CHANGE_ID, Operation.INDEX);
}
#method_after
@Test
public void schemaThrowsExceptionWhenLookingUpForChange() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS, THROW_ORM_EXCEPTION, CHANGE_UP_TO_DATE);
    exception.expect(OrmException.class);
    handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
}
#end_block

#method_before
@Test
public void indexerThrowsNoSuchChangeExceptionTryingToPostChange() throws Exception {
    doThrow(new NoSuchChangeException(id)).when(schemaFactoryMock).open();
    handler.index(TEST_CHANGE_ID, Operation.INDEX);
    verify(indexerMock, times(1)).delete(id);
}
#method_after
@Test
public void indexerThrowsNoSuchChangeExceptionTryingToPostChange() throws Exception {
    doThrow(new NoSuchChangeException(id)).when(schemaFactoryMock).open();
    handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
    verify(indexerMock, times(1)).delete(id);
}
#end_block

#method_before
@Test
public void indexerThrowsNestedNoSuchChangeExceptionTryingToPostChange() throws Exception {
    OrmException e = new OrmException("test", new NoSuchChangeException(id));
    doThrow(e).when(schemaFactoryMock).open();
    handler.index(TEST_CHANGE_ID, Operation.INDEX);
    verify(indexerMock, times(1)).delete(id);
}
#method_after
@Test
public void indexerThrowsNestedNoSuchChangeExceptionTryingToPostChange() throws Exception {
    OrmException e = new OrmException("test", new NoSuchChangeException(id));
    doThrow(e).when(schemaFactoryMock).open();
    handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
    verify(indexerMock, times(1)).delete(id);
}
#end_block

#method_before
@Test
public void indexerThrowsIOExceptionTryingToIndexChange() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS, DO_NOT_THROW_ORM_EXCEPTION, THROW_IO_EXCEPTION);
    exception.expect(IOException.class);
    handler.index(TEST_CHANGE_ID, Operation.INDEX);
}
#method_after
@Test
public void indexerThrowsIOExceptionTryingToIndexChange() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS, DO_NOT_THROW_ORM_EXCEPTION, THROW_IO_EXCEPTION, CHANGE_UP_TO_DATE);
    exception.expect(IOException.class);
    handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
}
#end_block

#method_before
@Test
public void shouldSetAndUnsetForwardedContext() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS);
    // this doAnswer is to allow to assert that context is set to forwarded
    // while cache eviction is called.
    doAnswer((Answer<Void>) invocation -> {
        assertThat(Context.isForwardedEvent()).isTrue();
        return null;
    }).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
    assertThat(Context.isForwardedEvent()).isFalse();
    handler.index(TEST_CHANGE_ID, Operation.INDEX);
    assertThat(Context.isForwardedEvent()).isFalse();
    verify(indexerMock, times(1)).index(any(ReviewDb.class), any(Change.class));
}
#method_after
@Test
public void shouldSetAndUnsetForwardedContext() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS, CHANGE_UP_TO_DATE);
    // this doAnswer is to allow to assert that context is set to forwarded
    // while cache eviction is called.
    doAnswer((Answer<Void>) invocation -> {
        assertThat(Context.isForwardedEvent()).isTrue();
        return null;
    }).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
    assertThat(Context.isForwardedEvent()).isFalse();
    handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
    assertThat(Context.isForwardedEvent()).isFalse();
    verify(indexerMock, times(1)).index(any(ReviewDb.class), any(Change.class));
}
#end_block

#method_before
@Test
public void shouldSetAndUnsetForwardedContextEvenIfExceptionIsThrown() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS);
    doAnswer((Answer<Void>) invocation -> {
        assertThat(Context.isForwardedEvent()).isTrue();
        throw new IOException("someMessage");
    }).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
    assertThat(Context.isForwardedEvent()).isFalse();
    try {
        handler.index(TEST_CHANGE_ID, Operation.INDEX);
        fail("should have thrown an IOException");
    } catch (IOException e) {
        assertThat(e.getMessage()).isEqualTo("someMessage");
    }
    assertThat(Context.isForwardedEvent()).isFalse();
    verify(indexerMock, times(1)).index(any(ReviewDb.class), any(Change.class));
}
#method_after
@Test
public void shouldSetAndUnsetForwardedContextEvenIfExceptionIsThrown() throws Exception {
    setupChangeAccessRelatedMocks(CHANGE_EXISTS, CHANGE_UP_TO_DATE);
    doAnswer((Answer<Void>) invocation -> {
        assertThat(Context.isForwardedEvent()).isTrue();
        throw new IOException("someMessage");
    }).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
    assertThat(Context.isForwardedEvent()).isFalse();
    try {
        handler.index(TEST_CHANGE_ID, Operation.INDEX, Optional.empty());
        fail("should have thrown an IOException");
    } catch (IOException e) {
        assertThat(e.getMessage()).isEqualTo("someMessage");
    }
    assertThat(Context.isForwardedEvent()).isFalse();
    verify(indexerMock, times(1)).index(any(ReviewDb.class), any(Change.class));
}
#end_block

#method_before
private void setupChangeAccessRelatedMocks(boolean changeExist, boolean ormException) throws OrmException, IOException {
    setupChangeAccessRelatedMocks(changeExist, ormException, DO_NOT_THROW_IO_EXCEPTION);
}
#method_after
private void setupChangeAccessRelatedMocks(boolean changeExist, boolean changeUpToDate) throws Exception {
    setupChangeAccessRelatedMocks(changeExist, DO_NOT_THROW_ORM_EXCEPTION, DO_NOT_THROW_IO_EXCEPTION, changeUpToDate);
}
#end_block

#method_before
private void setupChangeAccessRelatedMocks(boolean changeExists, boolean ormException, boolean ioException) throws OrmException, IOException {
    if (ormException) {
        doThrow(new OrmException("")).when(schemaFactoryMock).open();
    } else {
        when(schemaFactoryMock.open()).thenReturn(dbMock);
        if (changeExists) {
            when(changeFinderMock.findOne(TEST_CHANGE_ID)).thenReturn(changeNotes);
            if (ioException) {
                doThrow(new IOException("io-error")).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
            }
        } else {
            when(changeFinderMock.findOne(TEST_CHANGE_ID)).thenReturn(null);
        }
    }
}
#method_after
private void setupChangeAccessRelatedMocks(boolean changeExist, boolean ormException, boolean changeUpToDate) throws OrmException, IOException {
    setupChangeAccessRelatedMocks(changeExist, ormException, DO_NOT_THROW_IO_EXCEPTION, changeUpToDate);
}
#end_block

#method_before
private void setupChangeAccessRelatedMocks(boolean changeExists, boolean ormException, boolean ioException) throws OrmException, IOException {
    if (ormException) {
        doThrow(new OrmException("")).when(schemaFactoryMock).open();
    } else {
        when(schemaFactoryMock.open()).thenReturn(dbMock);
        if (changeExists) {
            when(changeFinderMock.findOne(TEST_CHANGE_ID)).thenReturn(changeNotes);
            if (ioException) {
                doThrow(new IOException("io-error")).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
            }
        } else {
            when(changeFinderMock.findOne(TEST_CHANGE_ID)).thenReturn(null);
        }
    }
}
#method_after
private void setupChangeAccessRelatedMocks(boolean changeExists, boolean ormException, boolean ioException, boolean changeIsUpToDate) throws OrmException, IOException {
    if (ormException) {
        doThrow(new OrmException("")).when(schemaFactoryMock).open();
    } else {
        when(schemaFactoryMock.open()).thenReturn(dbMock);
        if (changeExists) {
            when(changeCheckerFactoryMock.create(TEST_CHANGE_ID)).thenReturn(changeCheckerPresentMock);
            when(changeCheckerPresentMock.getChangeNotes()).thenReturn(Optional.of(changeNotes));
            if (ioException) {
                doThrow(new IOException("io-error")).when(indexerMock).index(any(ReviewDb.class), any(Change.class));
            }
        }
    }
    when(changeCheckerPresentMock.isChangeUpToDate(any())).thenReturn(changeIsUpToDate);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Executor.class).annotatedWith(IndexExecutor.class).toProvider(IndexExecutorProvider.class);
    bind(ScheduledExecutorService.class).annotatedWith(ForwardedIndexExecutor.class).toProvider(ForwardedIndexExecutorProvider.class);
    listener().to(IndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), AccountIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), GroupIndexedListener.class).to(IndexEventHandler.class);
}
#method_after
@Override
protected void configure() {
    bind(Executor.class).annotatedWith(IndexExecutor.class).toProvider(IndexExecutorProvider.class);
    bind(ScheduledExecutorService.class).annotatedWith(ForwardedIndexExecutor.class).toProvider(ForwardedIndexExecutorProvider.class);
    listener().to(IndexExecutorProvider.class);
    DynamicSet.bind(binder(), ChangeIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), AccountIndexedListener.class).to(IndexEventHandler.class);
    DynamicSet.bind(binder(), GroupIndexedListener.class).to(IndexEventHandler.class);
    install(new FactoryModuleBuilder().implement(ChangeChecker.class, ChangeCheckerImpl.class).build(ChangeCheckerImpl.Factory.class));
}
#end_block

#method_before
@Override
public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
    if (capabilityChecker.canViewMetrics() || canExportUsingBearerToken(req)) {
        super.service(req, res);
    } else {
        HttpServletResponse httpResponse = (HttpServletResponse) res;
        httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN, "Forbidden access");
    }
}
#method_after
@Override
public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
    if (capabilityChecker.canViewMetrics() || canExportUsingPrometheusBearerToken(req)) {
        super.service(req, res);
    } else {
        HttpServletResponse httpResponse = (HttpServletResponse) res;
        httpResponse.sendError(HttpServletResponse.SC_FORBIDDEN, "Forbidden access");
    }
}
#end_block

#method_before
public List<Change.Id> rename(List<Change.Id> changes, Project.NameKey oldProjectKey, Project.NameKey newProjectKey, ProgressMonitor pm) throws OrmException {
    pm.beginTask("Updating changes in the database", UNKNOWN);
    Connection conn = ((JdbcSchema) schemaFactory.open()).getConnection();
    try (Statement stmt = conn.createStatement()) {
        conn.setAutoCommit(false);
        try {
            log.debug("Updating the changes in the DB related to project {}", oldProjectKey.get());
            for (Change.Id cd : changes) {
                stmt.addBatch("update changes set dest_project_name='" + newProjectKey.get() + "' where change_id =" + cd.id + ";");
            }
            stmt.executeBatch();
            updateWatchEntries(oldProjectKey, newProjectKey);
            conn.commit();
            log.debug("Successfully updated the changes in the DB related to project {}", oldProjectKey.get());
            return changes;
        } finally {
            conn.setAutoCommit(true);
        }
    } catch (SQLException e) {
        try {
            log.error("Failed to update changes in the DB for the project {}, rolling back the operation.", oldProjectKey.get());
            conn.rollback();
        } catch (SQLException ex) {
            throw new OrmException(ex);
        }
        throw new OrmException(e);
    }
}
#method_after
public List<Change.Id> rename(List<Change.Id> changes, Project.NameKey oldProjectKey, Project.NameKey newProjectKey, ProgressMonitor pm) throws OrmException {
    pm.beginTask("Updating changes in the database");
    Connection conn = ((JdbcSchema) schemaFactory.open()).getConnection();
    try (Statement stmt = conn.createStatement()) {
        conn.setAutoCommit(false);
        try {
            log.debug("Updating the changes in the DB related to project {}", oldProjectKey.get());
            for (Change.Id cd : changes) {
                stmt.addBatch("update changes set dest_project_name='" + newProjectKey.get() + "' where change_id =" + cd.id + ";");
            }
            stmt.executeBatch();
            updateWatchEntries(oldProjectKey, newProjectKey);
            conn.commit();
            log.debug("Successfully updated the changes in the DB related to project {}", oldProjectKey.get());
            return changes;
        } finally {
            conn.setAutoCommit(true);
        }
    } catch (SQLException e) {
        try {
            log.error("Failed to update changes in the DB for the project {}, rolling back the operation.", oldProjectKey.get());
            conn.rollback();
        } catch (SQLException ex) {
            throw new OrmException(ex);
        }
        throw new OrmException(e);
    }
}
#end_block

#method_before
void assertCanRename(ProjectResource rsrc, Input input, ProgressMonitor pm) throws ResourceConflictException, BadRequestException, AuthException {
    try {
        pm.beginTask("Checking preconditions", UNKNOWN);
        assertNewNameNotNull(input);
        assertRenamePermission(rsrc);
        renamePreconditions.assertCanRename(rsrc, new Project.NameKey(input.name));
        log.debug("Rename preconditions check successful.");
    } catch (CannotRenameProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
void assertCanRename(ProjectResource rsrc, Input input, ProgressMonitor pm) throws ResourceConflictException, BadRequestException, AuthException {
    try {
        pm.beginTask("Checking preconditions");
        assertNewNameNotNull(input);
        assertRenamePermission(rsrc);
        renamePreconditions.assertCanRename(rsrc, new Project.NameKey(input.name));
        log.debug("Rename preconditions check successful.");
    } catch (CannotRenameProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
void doRename(List<Change.Id> changeIds, ProjectResource rsrc, Input input, ProgressMonitor pm) throws Exception {
    Project.NameKey oldProjectKey = rsrc.getControl().getProject().getNameKey();
    Project.NameKey newProjectKey = new Project.NameKey(input.name);
    Exception ex = null;
    try {
        fsHandler.rename(oldProjectKey, newProjectKey, pm);
        log.debug("Renamed the git repo to {} successfully.", newProjectKey.get());
        cacheHandler.update(rsrc.getControl().getProject(), newProjectKey);
        List<Change.Id> updatedChangeIds = dbHandler.rename(changeIds, oldProjectKey, newProjectKey, pm);
        log.debug("Updated the changes in DB successfully for project {}.", oldProjectKey.get());
        // if the DB update is successful, update the secondary index
        indexHandler.updateIndex(updatedChangeIds, newProjectKey, pm);
        log.debug("Updated the secondary index successfully for project {}.", oldProjectKey.get());
        lockUnlockProject.unlock(newProjectKey);
        log.debug("Unlocked the repo {} after rename operation.", newProjectKey.get());
        pluginEvent.fire(pluginName, pluginName, oldProjectKey.get() + ":" + newProjectKey.get());
    } catch (Exception e) {
        ex = e;
        throw e;
    } finally {
        renameLog.onRename((IdentifiedUser) userProvider.get(), oldProjectKey, input, ex);
    }
}
#method_after
void doRename(List<Change.Id> changeIds, ProjectResource rsrc, Input input, ProgressMonitor pm) throws InterruptedException, OrmException, ConfigInvalidException, IOException {
    Project.NameKey oldProjectKey = rsrc.getControl().getProject().getNameKey();
    Project.NameKey newProjectKey = new Project.NameKey(input.name);
    Exception ex = null;
    try {
        fsHandler.rename(oldProjectKey, newProjectKey, pm);
        log.debug("Renamed the git repo to {} successfully.", newProjectKey.get());
        cacheHandler.update(rsrc.getControl().getProject(), newProjectKey);
        List<Change.Id> updatedChangeIds = dbHandler.rename(changeIds, oldProjectKey, newProjectKey, pm);
        log.debug("Updated the changes in DB successfully for project {}.", oldProjectKey.get());
        // if the DB update is successful, update the secondary index
        indexHandler.updateIndex(updatedChangeIds, newProjectKey, pm);
        log.debug("Updated the secondary index successfully for project {}.", oldProjectKey.get());
        lockUnlockProject.unlock(newProjectKey);
        log.debug("Unlocked the repo {} after rename operation.", newProjectKey.get());
        pluginEvent.fire(pluginName, pluginName, oldProjectKey.get() + ":" + newProjectKey.get());
    } catch (Exception e) {
        ex = e;
        throw e;
    } finally {
        renameLog.onRename((IdentifiedUser) userProvider.get(), oldProjectKey, input, ex);
    }
}
#end_block

#method_before
List<Change.Id> getChanges(ProjectResource rsrc, ProgressMonitor pm) throws OrmException {
    pm.beginTask("Retrieving the list of changes from DB", UNKNOWN);
    Project.NameKey oldProjectKey = rsrc.getControl().getProject().getNameKey();
    return dbHandler.getChangeIds(oldProjectKey);
}
#method_after
List<Change.Id> getChanges(ProjectResource rsrc, ProgressMonitor pm) throws OrmException {
    pm.beginTask("Retrieving the list of changes from DB");
    Project.NameKey oldProjectKey = rsrc.getControl().getProject().getNameKey();
    return dbHandler.getChangeIds(oldProjectKey);
}
#end_block

#method_before
public void rename(Project.NameKey oldProjectKey, Project.NameKey newProjectKey, ProgressMonitor pm) throws IOException, RepositoryNotFoundException {
    Repository repository = repoManager.openRepository(oldProjectKey);
    File repoFile = repository.getDirectory();
    RepositoryCache.close(repository);
    pm.beginTask("Renaming git repository", UNKNOWN);
    renameGitRepository(repoFile, newProjectKey, oldProjectKey);
}
#method_after
public void rename(Project.NameKey oldProjectKey, Project.NameKey newProjectKey, ProgressMonitor pm) throws IOException, RepositoryNotFoundException {
    Repository repository = repoManager.openRepository(oldProjectKey);
    File repoFile = repository.getDirectory();
    RepositoryCache.close(repository);
    pm.beginTask("Renaming git repository");
    renameGitRepository(repoFile, newProjectKey, oldProjectKey);
}
#end_block

#method_before
@Override
public synchronized void beginTask(String taskName, int work) {
    endTask();
    if (work == UNKNOWN) {
        task = new UnknownTask(taskName);
    } else {
        task = new Task(taskName, work);
    }
}
#method_after
@Override
public synchronized void beginTask(String taskName) {
    beginTask(taskName, UNKNOWN);
}
#end_block

#method_before
@Override
public void run() throws Exception {
    try {
        RenameProject.Input input = new RenameProject.Input();
        input.name = newProjectName;
        ProjectResource rsrc = new ProjectResource(projectControl);
        try (CommandProgressMonitor monitor = new CommandProgressMonitor(stdout)) {
            renameProject.assertCanRename(rsrc, input, monitor);
            List<Change.Id> changeIds = renameProject.getChanges(rsrc, monitor);
            if (continueRename(changeIds, monitor)) {
                renameProject.doRename(changeIds, rsrc, input, monitor);
            } else {
                String cancellationMsg = "Rename operation was cancelled by user.";
                log.debug(cancellationMsg);
                stdout.println(cancellationMsg);
                stdout.flush();
            }
        }
    } catch (AuthException | ResourceConflictException | OrmException | IOException e) {
        throw die(e);
    }
}
#method_after
@Override
public void run() throws Exception {
    try {
        RenameProject.Input input = new RenameProject.Input();
        input.name = newProjectName;
        ProjectResource rsrc = new ProjectResource(projectControl);
        try (CommandProgressMonitor monitor = new CommandProgressMonitor(stdout)) {
            renameProject.assertCanRename(rsrc, input, monitor);
            List<Change.Id> changeIds = renameProject.getChanges(rsrc, monitor);
            if (continueRename(changeIds, monitor)) {
                renameProject.doRename(changeIds, rsrc, input, monitor);
            } else {
                String cancellationMsg = "Rename operation was cancelled by user.";
                log.debug(cancellationMsg);
                stdout.println(cancellationMsg);
                stdout.flush();
            }
        }
    } catch (RestApiException | OrmException | IOException e) {
        throw die(e);
    }
}
#end_block

#method_before
@Override
public void receive(Message msg) {
    synchronized (this) {
        if (peerAddress != null) {
            return;
        }
        peerAddress = msg.getSrc();
        String url = (String) msg.getObject();
        peerInfo = new PeerInfo(url);
        log.info("receive(): Set new peerInfo: {}", url);
    }
}
#method_after
@Override
public void receive(Message msg) {
    synchronized (this) {
        if (peerAddress != null) {
            return;
        }
        peerAddress = msg.getSrc();
        String url = (String) msg.getObject();
        peerInfo = Optional.of(new PeerInfo(url));
        log.info("receive(): Set new peerInfo: {}", url);
    }
}
#end_block

#method_before
@Override
public void viewAccepted(View view) {
    log.info("viewAccepted(view: {}) called", view);
    synchronized (this) {
        if (view.getMembers().size() > 2) {
            log.warn("{} members joined the jgroups cluster {} ({}). " + " Only two members are supported. Members: {}", view.getMembers().size(), jgroupsConfig.clusterName(), channel.getName(), view.getMembers());
        }
        if (peerAddress != null && !view.getMembers().contains(peerAddress)) {
            log.info("viewAccepted(): removed peerInfo");
            peerAddress = null;
            peerInfo = null;
        }
    }
    if (view.size() > 1) {
        try {
            channel.send(new Message(null, myUrl));
        } catch (Exception e) {
            // channel communication caused an error. Can't do much about it.
            log.error("Sending a message over channel {} to cluster {} failed", channel.getName(), jgroupsConfig.clusterName(), e);
        }
    }
}
#method_after
@Override
public void viewAccepted(View view) {
    log.info("viewAccepted(view: {}) called", view);
    synchronized (this) {
        if (view.getMembers().size() > 2) {
            log.warn("{} members joined the jgroups cluster {} ({}). " + " Only two members are supported. Members: {}", view.getMembers().size(), jgroupsConfig.clusterName(), channel.getName(), view.getMembers());
        }
        if (peerAddress != null && !view.getMembers().contains(peerAddress)) {
            log.info("viewAccepted(): removed peerInfo");
            peerAddress = null;
            peerInfo = Optional.empty();
        }
    }
    if (view.size() > 1) {
        try {
            channel.send(new Message(null, myUrl));
        } catch (Exception e) {
            // channel communication caused an error. Can't do much about it.
            log.error("Sending a message over channel {} to cluster {} failed", channel.getName(), jgroupsConfig.clusterName(), e);
        }
    }
}
#end_block

#method_before
@Override
public Set<PeerInfo> get() {
    return peerInfo != null ? ImmutableSet.of(peerInfo) : ImmutableSet.of();
}
#method_after
@Override
public Set<PeerInfo> get() {
    return peerInfo.isPresent() ? ImmutableSet.of(peerInfo.get()) : ImmutableSet.of();
}
#end_block

#method_before
@Override
public void stop() {
    if (channel != null) {
        log.info("closing jgroups channel {} (cluster {})", channel.getName(), jgroupsConfig.clusterName());
        channel.close();
    }
    peerInfo = null;
    peerAddress = null;
}
#method_after
@Override
public void stop() {
    if (channel != null) {
        log.info("closing jgroups channel {} (cluster {})", channel.getName(), jgroupsConfig.clusterName());
        channel.close();
    }
    peerInfo = Optional.empty();
    peerAddress = null;
}
#end_block

#method_before
@Nullable
private static String trimTrailingSlash(@Nullable String in) {
    return in == null ? null : CharMatcher.is('/').trimTrailingFrom(in);
}
#method_after
@Nullable
private static String trimTrailingSlash(@Nullable String in) {
    return in == null ? in : CharMatcher.is('/').trimTrailingFrom(in);
}
#end_block

#method_before
private Request createRequest(RequestMethod method, PeerInfo peer, String action, String endpoint, Object id, String payload) {
    return new Request(action, id) {

        @Override
        HttpResult send() throws IOException {
            String request = Joiner.on("/").join(peer.getDirectUrl(), pluginRelativePath, endpoint, id);
            if (RequestMethod.POST == method) {
                return httpSession.post(request, payload);
            }
            return httpSession.delete(request);
        }
    };
}
#method_after
private Request createRequest(RequestMethod method, PeerInfo peer, String action, String endpoint, Object id, String payload) {
    String destination = peer.getDirectUrl();
    return new Request(action, id, destination) {

        @Override
        HttpResult send() throws IOException {
            String request = Joiner.on("/").join(destination, pluginRelativePath, endpoint, id);
            switch(method) {
                case POST:
                    return httpSession.post(request, payload);
                case DELETE:
                default:
                    return httpSession.delete(request);
            }
        }
    };
}
#end_block

#method_before
boolean execute() {
    log.debug("Executing {} {}", action, key);
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            log.debug("{} {} OK", action, key);
            return true;
        } catch (ForwardingException e) {
            int maxTries = cfg.http().maxTries();
            log.debug("Failed to {} {} [{}/{}]", action, key, execCnt, maxTries, e);
            if (!e.isRecoverable()) {
                log.error("{} {} failed with unrecoverable error; giving up", action, key, e);
                return false;
            }
            if (execCnt >= maxTries) {
                log.error("Failed to {} {} after {} tries; giving up", action, key, maxTries);
                return false;
            }
            log.debug("Retrying to {} {}", action, key);
            try {
                Thread.sleep(cfg.http().retryInterval());
            } catch (InterruptedException ie) {
                log.error("{} {} was interrupted; giving up", action, key, ie);
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
}
#method_after
boolean execute() {
    log.debug("Executing {} {} towards {}", action, key, destination);
    for (; ; ) {
        try {
            execCnt++;
            tryOnce();
            log.debug("{} {} towards {} OK", action, key, destination);
            return true;
        } catch (ForwardingException e) {
            int maxTries = cfg.http().maxTries();
            log.debug("Failed to {} {} on {} [{}/{}]", action, key, destination, execCnt, maxTries, e);
            if (!e.isRecoverable()) {
                log.error("{} {} towards {} failed with unrecoverable error; giving up", action, key, destination, e);
                return false;
            }
            if (execCnt >= maxTries) {
                log.error("Failed to {} {} on {} after {} tries; giving up", action, key, destination, maxTries);
                return false;
            }
            log.debug("Retrying to {} {} on {}", action, key, destination);
            try {
                Thread.sleep(cfg.http().retryInterval());
            } catch (InterruptedException ie) {
                log.error("{} {} towards {} was interrupted; giving up", action, key, destination, ie);
                Thread.currentThread().interrupt();
                return false;
            }
        }
    }
}
#end_block

#method_before
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(QuoteUtil.quote((projectName))).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(QuoteUtil.quote(projectName + "/.git/hooks/"));
        if (extraCommand != null) {
            b.append(" && (cd ").append(QuoteUtil.quote(projectName)).append(" && ").append(extraCommand).append(")");
        }
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(QuoteUtil.quote(projectName)).append(" && curl -Lo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme, project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#method_after
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(QuoteUtil.quote((projectName))).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(QuoteUtil.quote(projectName + "/.git/hooks/"));
        if (extraCommand != null) {
            b.append(" && (cd ").append(QuoteUtil.quote(projectName)).append(" && ").append(extraCommand).append(")");
        }
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(QuoteUtil.quote(projectName)).append(" && mkdir -p .git/hooks").append(" && curl -Lo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme, project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#end_block

#method_before
@Override
public boolean acquirePermit() {
    if (permitsPerHour() - availablePermits() == warnLimit) {
        rateLimitLog.info("{} exceeded the warning limit of {} uploadpacks per hour.", userResolver.getUserName(key).orElse(key), warnLimit);
    }
    boolean acquirePermit = delegate.acquirePermit();
    if (!acquirePermit && !wasLogged) {
        rateLimitLog.info("{} was blocked due to exceeding the limit of {} uploadpacks per hour." + " {} remaining to permits replenishing.", userResolver.getUserName(key).orElse(key), permitsPerHour(), secondsToMsSs(remainingTime(TimeUnit.SECONDS)));
        wasLogged = true;
    }
    return acquirePermit;
}
#method_after
@Override
public synchronized boolean acquirePermit() {
    boolean acquirePermit = delegate.acquirePermit();
    if (usedPermits() == warnLimit) {
        rateLimitLog.info("{} reached the warning limit of {} uploadpacks per hour.", userResolver.getUserName(key).orElse(key), warnLimit);
        warningWasLogged = true;
    }
    if (!acquirePermit && !wasLogged) {
        rateLimitLog.info("{} was blocked due to exceeding the limit of {} uploadpacks per hour." + " {} remaining to permits replenishing.", userResolver.getUserName(key).orElse(key), permitsPerHour(), secondsToMsSs(remainingTime(TimeUnit.SECONDS)));
        wasLogged = true;
    }
    return acquirePermit;
}
#end_block

#method_before
@Override
public void replenishPermits() {
    delegate.replenishPermits();
}
#method_after
@Override
public void replenishPermits() {
    warningWasLogged = false;
    delegate.replenishPermits();
}
#end_block

#method_before
private Map<String, AccountGroup.UUID> getResolvedGroups(Config config, GroupsCollection groupsCollection) {
    LinkedHashMap<String, AccountGroup.UUID> groups = new LinkedHashMap<>();
    for (String groupName : config.getSubsections(GROUP_SECTION)) {
        GroupDescription.Basic groupDesc = groupsCollection.parseId(groupName);
        if (groupDesc == null) {
            throw new ProvisionException(String.format("Invalid configuration, group not found: %s", groupName));
        }
        groups.put(groupName, groupDesc.getGroupUUID());
    }
    return groups;
}
#method_after
private Map<String, AccountGroup.UUID> getResolvedGroups(Config config, GroupsCollection groupsCollection) {
    LinkedHashMap<String, AccountGroup.UUID> groups = new LinkedHashMap<>();
    for (String groupName : config.getSubsections(GROUP_SECTION)) {
        GroupDescription.Basic groupDesc = groupsCollection.parseId(groupName);
        // Group either is mis-configured, never existed, or was deleted/removed since.
        if (groupDesc == null) {
            log.warn(String.format("Invalid configuration, group not found: %s", groupName));
        } else {
            groups.put(groupName, groupDesc.getGroupUUID());
        }
    }
    return groups;
}
#end_block

#method_before
private void parseGroupRateLimits(Config config, String groupName, AccountGroup.UUID groupUUID) throws ProvisionException {
    for (String typeName : config.getNames(GROUP_SECTION, groupName, true)) {
        RateLimitType rateLimitType = RateLimitType.from(typeName);
        if (rateLimitType != null) {
            rateLimits.put(rateLimitType, groupUUID, parseRateLimit(config, groupName, rateLimitType));
        } else {
            throw new ProvisionException(String.format("Invalid configuration, unsupported rate limit: %s", typeName));
        }
    }
}
#method_after
private void parseGroupRateLimits(Config config, String groupName, AccountGroup.UUID groupUUID) throws ProvisionException {
    for (String typeName : config.getNames(GROUP_SECTION, groupName, true)) {
        RateLimitType rateLimitType = RateLimitType.from(typeName);
        if (rateLimitType != null) {
            rateLimits.put(rateLimitType, groupUUID, parseRateLimit(config, groupName, rateLimitType));
        } else {
            throw new ProvisionException(String.format("Invalid configuration, unsupported rate limit type: %s", typeName));
        }
    }
}
#end_block

#method_before
private static String parseLimitExceededMsg(Config config) {
    String msg = config.getString("configuration", null, "uploadpackLimitExceededMsg");
    return (msg != null) ? msg : DEFAULT_RATE_LIMIT_EXCEEDED_MSG;
}
#method_after
private static String parseLimitExceededMsg(Config config) {
    String msg = config.getString("configuration", null, "uploadpackLimitExceededMsg");
    return (msg != null) ? msg : DEFAULT_UPLOADPACK_LIMIT_EXCEEDED_MSG;
}
#end_block

#method_before
@Override
protected void run() throws UnloggedFailure, ExecutionException {
    if (all && (!accountIds.isEmpty() || !remoteHosts.isEmpty())) {
        throw die("cannot use --all with --user or --remotehost");
    }
    if (all) {
        for (RateLimiter rateLimiter : uploadPackPerHour.asMap().values()) {
            rateLimiter.replenishPermits();
        }
        return;
    }
    for (Account.Id accountId : accountIds) {
        replenishIfPresent(Integer.toString(accountId.get()));
    }
    for (String remoteHost : remoteHosts) {
        replenishIfPresent(remoteHost);
    }
}
#method_after
@Override
protected void run() throws UnloggedFailure {
    if (all && (!accountIds.isEmpty() || !remoteHosts.isEmpty())) {
        throw die("cannot use --all with --user or --remotehost");
    }
    if (all) {
        for (RateLimiter rateLimiter : uploadPackPerHour.asMap().values()) {
            rateLimiter.replenishPermits();
        }
        return;
    }
    for (Account.Id accountId : accountIds) {
        replenishIfPresent(Integer.toString(accountId.get()));
    }
    for (String remoteHost : remoteHosts) {
        replenishIfPresent(remoteHost);
    }
}
#end_block

#method_before
@Override
public void onBeginNegotiate(Repository repository, Project project, String remoteHost, UploadPack up, Collection<? extends ObjectId> wants, int cntOffered) throws ValidationException {
    String key = null;
    CurrentUser u = user.get();
    if (u.isIdentifiedUser()) {
        key = Integer.toString(u.asIdentifiedUser().getAccountId().get());
    } else {
        key = remoteHost;
    }
    try {
        RateLimiter limiter = uploadPackPerHour.get(key);
        if (limiter != null && !limiter.acquirePermit()) {
            throw new RateLimitException(MessageFormat.format(limitExceededMsgFormat, limiter.permitsPerHour()));
        }
    } catch (ExecutionException e) {
        log.warn("Cannot get rate limits for {}: {}", key, e);
    }
}
#method_after
@Override
public void onBeginNegotiate(Repository repository, Project project, String remoteHost, UploadPack up, Collection<? extends ObjectId> wants, int cntOffered) throws ValidationException {
    String key;
    CurrentUser u = user.get();
    if (u.isIdentifiedUser()) {
        key = Integer.toString(u.asIdentifiedUser().getAccountId().get());
    } else {
        key = remoteHost;
    }
    try {
        RateLimiter limiter = uploadPackPerHour.get(key);
        if (limiter != null && !limiter.acquirePermit()) {
            throw new RateLimitException(MessageFormat.format(limitExceededMsgFormat, limiter.permitsPerHour()));
        }
    } catch (ExecutionException e) {
        log.warn("Cannot get rate limits for {}: {}", key, e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), UploadValidationListener.class).to(RateLimitUploadPack.class);
    bind(Configuration.class).asEagerSingleton();
    bind(ScheduledExecutorService.class).annotatedWith(RateLimitExecutor.class).toProvider(RateLimitExecutorProvider.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(RateLimitExecutorProvider.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(RateLimiterStatsLog.class);
    install(new FactoryModuleBuilder().build(HourlyRateLimiter.Factory.class));
    install(new FactoryModuleBuilder().build(WarningHourlyRateLimiter.Factory.class));
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), UploadValidationListener.class).to(RateLimitUploadPack.class);
    bind(Configuration.class).asEagerSingleton();
    bind(ScheduledExecutorService.class).annotatedWith(RateLimitExecutor.class).toProvider(RateLimitExecutorProvider.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(RateLimitExecutorProvider.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(RateLimiterStatsLog.class);
    install(new FactoryModuleBuilder().build(HourlyRateLimiter.Factory.class));
    install(new FactoryModuleBuilder().build(WarningHourlyRateLimiter.Factory.class));
    install(new FactoryModuleBuilder().build(WarningHourlyUnlimitedRateLimiter.Factory.class));
}
#end_block

#method_before
@Provides
@Named(UPLOAD_PACK_PER_HOUR)
@Singleton
LoadingCache<String, RateLimiter> getUploadPackPerHourCache(Provider<RateLimiterLoader> loader) {
    return CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.HOURS).removalListener((RemovalListener<String, RateLimiter>) removalNotication -> removalNotication.getValue().close()).build(loader.get());
}
#method_after
@Provides
@Named(UPLOAD_PACK_PER_HOUR)
@Singleton
LoadingCache<String, RateLimiter> getUploadPackPerHourCache(Provider<RateLimiterLoader> loader) {
    return CacheBuilder.newBuilder().expireAfterAccess(1, TimeUnit.HOURS).removalListener((RemovalListener<String, RateLimiter>) removalNotification -> removalNotification.getValue().close()).build(loader.get());
}
#end_block

#method_before
@Override
public RateLimiter load(String key) throws Exception {
    Optional<RateLimit> limit = finder.find(RateLimitType.UPLOAD_PACK_PER_HOUR, key);
    Optional<RateLimit> warn = finder.find(RateLimitType.UPLOAD_PACK_PER_HOUR_WARN, key);
    if (!limit.isPresent()) {
        return UnlimitedRateLimiter.INSTANCE;
    }
    RateLimiter rateLimiter = hourlyRateLimiterFactory.create(limit.get().getRatePerHour());
    return !warn.isPresent() ? rateLimiter : warningHourlyRateLimiterFactory.create(rateLimiter, key, warn.get().getRatePerHour());
}
#method_after
@Override
public RateLimiter load(String key) {
    Optional<RateLimit> limit = finder.find(RateLimitType.UPLOAD_PACK_PER_HOUR, key);
    Optional<RateLimit> warn = finder.find(RateLimitType.UPLOAD_PACK_PER_HOUR_WARN, key);
    if (!limit.isPresent() && !warn.isPresent()) {
        return UnlimitedRateLimiter.INSTANCE;
    }
    // In the case that there is a warning but no limit
    Integer myLimit = Integer.MAX_VALUE;
    if (limit.isPresent()) {
        myLimit = limit.get().getRatePerHour();
    }
    RateLimiter rateLimiter = hourlyRateLimiterFactory.create(myLimit);
    if (warn.isPresent()) {
        if (limit.isPresent()) {
            return warningHourlyRateLimiterFactory.create(rateLimiter, key, warn.get().getRatePerHour());
        }
        return warningHourlyUnlimitedRateLimiterFactory.create(rateLimiter, key, warn.get().getRatePerHour());
    }
    return rateLimiter;
}
#end_block

#method_before
@Override
public boolean acquirePermit() {
    return semaphore.tryAcquire();
}
#method_after
@Override
public synchronized boolean acquirePermit() {
    boolean permit = semaphore.tryAcquire();
    if (permit) {
        usedPermits.getAndIncrement();
    }
    return permit;
}
#end_block

#method_before
@Override
public void replenishPermits() {
    semaphore.release(maxPermits - semaphore.availablePermits());
}
#method_after
@Override
public synchronized void replenishPermits() {
    semaphore.release(usedPermits());
    usedPermits.set(0);
}
#end_block

#method_before
@Test
public void testUploadPackPerHourRateLimit() {
    globalPluginConfig.setInt("group", someGroupDescMock.getName(), RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), 123);
    Map<AccountGroup.UUID, RateLimit> rateLimit = getConfiguration().getRatelimits(RateLimitType.UPLOAD_PACK_PER_HOUR);
    assertThat(rateLimit).hasSize(1);
    assertThat(rateLimit.get(someGroupDescMock.getGroupUUID()).getRatePerHour()).isEqualTo(123);
}
#method_after
@Test
public void testUploadPackPerHourRateLimit() {
    globalPluginConfig.setInt(groupTagName, someGroupDescMock.getName(), RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), validRate);
    Map<AccountGroup.UUID, RateLimit> rateLimit = getConfiguration().getRatelimits(RateLimitType.UPLOAD_PACK_PER_HOUR);
    assertThat(rateLimit).hasSize(1);
    assertThat(rateLimit.get(someGroupDescMock.getGroupUUID()).getRatePerHour()).isEqualTo(validRate);
}
#end_block

#method_before
@Test
public void testInvalidRateLimitType() {
    globalPluginConfig.setInt("group", someGroupDescMock.getName(), "invalidTypePerHour", 123);
    exception.expect(ProvisionException.class);
    exception.expectMessage("Invalid configuration, unsupported rate limit: invalidTypePerHour");
    getConfiguration();
}
#method_after
@Test
public void testInvalidRateLimitType() {
    globalPluginConfig.setInt(groupTagName, someGroupDescMock.getName(), "invalidTypePerHour", validRate);
    exception.expect(ProvisionException.class);
    exception.expectMessage("Invalid configuration, unsupported rate limit type: invalidTypePerHour");
    getConfiguration();
}
#end_block

#method_before
@Test
public void testInvalidRateLimitValue() {
    globalPluginConfig.setString("group", someGroupDescMock.getName(), RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), "123aaa");
    exception.expect(ProvisionException.class);
    exception.expectMessage("Invalid configuration, 'rate limit value '123aaa' for 'group.someGroup.uploadpackperhour' is not a valid number");
    getConfiguration();
}
#method_after
@Test
public void testInvalidRateLimitValue() {
    globalPluginConfig.setString(groupTagName, someGroupDescMock.getName(), RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), invalidType);
    exception.expect(ProvisionException.class);
    exception.expectMessage("Invalid configuration, 'rate limit value '" + invalidType + "' for 'group.someGroup.uploadpackperhour' is not a valid number");
    getConfiguration();
}
#end_block

#method_before
@Test
public void testInvalidGroup() {
    globalPluginConfig.setString("group", "nonexistingGroup", RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), "123");
    exception.expect(ProvisionException.class);
    exception.expectMessage("Invalid configuration, group not found: nonexistingGroup");
    getConfiguration();
}
#method_after
@Test
public void testInvalidGroup() {
    // Set a good group and a bad and ensure the good is still parsed
    globalPluginConfig.setInt(groupTagName, someGroupDescMock.getName(), RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), validRate);
    globalPluginConfig.setString(groupTagName, "nonexistingGroup", RateLimitType.UPLOAD_PACK_PER_HOUR.toString(), "badGroup");
    Map<AccountGroup.UUID, RateLimit> rateLimit = getConfiguration().getRatelimits(RateLimitType.UPLOAD_PACK_PER_HOUR);
    assertThat(rateLimit).hasSize(1);
    assertThat(rateLimit.get(someGroupDescMock.getGroupUUID()).getRatePerHour()).isEqualTo(validRate);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    scheduledExecutorMock = mock(ScheduledExecutorService.class);
    limiter = new HourlyRateLimiter(scheduledExecutorMock, RATE);
}
#method_after
@Before
public void setUp() {
    scheduledExecutorMock = mock(ScheduledExecutorService.class);
    limiter = new HourlyRateLimiter(scheduledExecutorMock, RATE);
}
#end_block

#method_before
@Override
public String getCommand(DownloadScheme scheme, String project) {
    Optional<String> username = userProvider.get().getUserName();
    if (!username.isPresent()) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username.get()).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/");
        if (extraCommand != null) {
            b.append(" && (cd ").append(projectName).append(" && ").append(extraCommand).append(")");
        }
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && mkdir -p .git/hooks ").append(" && curl -Lo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme, project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#method_after
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (configCommand != null) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && ").append(configCommand).append(")").toString();
    }
    if (scheme instanceof SshScheme) {
        StringBuilder b = new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p");
        if (sshScheme.getSshdPort() != 22) {
            b.append(" -P ").append(sshScheme.getSshdPort());
        }
        b.append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/");
        return b.toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && (cd ").append(projectName).append(" && mkdir -p .git/hooks").append(" && curl -Lo").append(TARGET).append(HOOK).append(" ").append(getHttpHost(scheme, project)).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#end_block

#method_before
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo is local by matching hostnames
            if (submodUrl.getHost().equals(this.canonicalWebUrl.getHost())) {
                // relativize submodUrl only if it is found locally
                try {
                    String repoName = submodUrl.getPath();
                    while (repoName.startsWith("/")) {
                        repoName = repoName.substring(1);
                    }
                    reader.openRepository(repoName);
                    submodUrl = relativize(targetURI, URI.create(repoName));
                } catch (RepositoryNotFoundException e) {
                }
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        PersonIdent author = new PersonIdent(serverIdent.getName(), serverIdent.getEmailAddress(), new Date(), serverIdent.getTimeZone());
        commit.setAuthor(author);
        commit.setCommitter(author);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#method_after
private void updateSubmodules(Repository repo, String targetRef, URI targetURI, JiriProjects projects, GerritRemoteReader reader) throws IOException, GitAPIException {
    DirCache index = DirCache.newInCore();
    DirCacheBuilder builder = index.builder();
    ObjectInserter inserter = repo.newObjectInserter();
    try (RevWalk rw = new RevWalk(repo)) {
        Config cfg = new Config();
        projects.sortByPath();
        String parent = null;
        for (JiriProjects.Project proj : projects.getProjects()) {
            String path = proj.getPath();
            String nameUri = proj.getRemote();
            if (parent != null) {
                String p1 = StringUtil.stripAndAddCharsAtEnd(path, "/");
                String p2 = StringUtil.stripAndAddCharsAtEnd(parent, "/");
                if (p1.startsWith(p2)) {
                    warn("Skipping project %s(%s) as git doesn't support nested submodules", proj.getName(), path);
                    continue;
                }
            }
            ObjectId objectId;
            String ref = proj.getRef();
            if (ObjectId.isId(ref)) {
                objectId = ObjectId.fromString(ref);
            } else {
                objectId = reader.sha1(nameUri, ref);
                if (objectId == null) {
                    warn("failed to get ref '%s' for '%s', skipping", ref, nameUri);
                    continue;
                }
            }
            // can be branch or tag
            cfg.setString("submodule", path, "branch", ref);
            if (proj.getHistorydepth() > 0) {
                cfg.setBoolean("submodule", path, "shallow", true);
                if (proj.getHistorydepth() != 1) {
                    warn("Project %s(%s) has historydepth other than 1. Submodule only support shallow of depth 1.", proj.getName(), proj.getPath());
                }
            }
            URI submodUrl = URI.create(nameUri);
            // check if repo is local by matching hostnames
            String repoName = submodUrl.getPath();
            while (repoName.startsWith("/")) {
                repoName = repoName.substring(1);
            }
            URI localURI = getLocalURI(repoName);
            if (localURI != null && localURI.getHost().equals(submodUrl.getHost())) {
                submodUrl = relativize(targetURI, URI.create(repoName));
            }
            cfg.setString("submodule", path, "path", path);
            cfg.setString("submodule", path, "url", submodUrl.toString());
            // create gitlink
            DirCacheEntry dcEntry = new DirCacheEntry(path);
            dcEntry.setObjectId(objectId);
            dcEntry.setFileMode(FileMode.GITLINK);
            builder.add(dcEntry);
            parent = path;
        }
        String content = cfg.toText();
        // create a new DirCacheEntry for .gitmodules file.
        final DirCacheEntry dcEntry = new DirCacheEntry(Constants.DOT_GIT_MODULES);
        ObjectId objectId = inserter.insert(Constants.OBJ_BLOB, content.getBytes(Constants.CHARACTER_ENCODING));
        dcEntry.setObjectId(objectId);
        dcEntry.setFileMode(FileMode.REGULAR_FILE);
        builder.add(dcEntry);
        builder.finish();
        ObjectId treeId = index.writeTree(inserter);
        // Create a Commit object, populate it and write it
        ObjectId headId = repo.resolve(targetRef + "^{commit}");
        CommitBuilder commit = new CommitBuilder();
        commit.setTreeId(treeId);
        if (headId != null)
            commit.setParentIds(headId);
        PersonIdent author = new PersonIdent(serverIdent.getName(), serverIdent.getEmailAddress(), new Date(), serverIdent.getTimeZone());
        commit.setAuthor(author);
        commit.setCommitter(author);
        commit.setMessage(RepoText.get().repoCommitMessage);
        ObjectId commitId = inserter.insert(commit);
        inserter.flush();
        RefUpdate ru = repo.updateRef(targetRef);
        ru.setNewObjectId(commitId);
        ru.setExpectedOldObjectId(headId != null ? headId : ObjectId.zeroId());
        Result rc = ru.update(rw);
        switch(rc) {
            case NEW:
            case FORCED:
            case FAST_FORWARD:
                // Successful. Do nothing.
                break;
            case REJECTED:
            case LOCK_FAILURE:
                throw new ConcurrentRefUpdateException(MessageFormat.format(JGitText.get().cannotLock, targetRef), ru.getRef(), rc);
            default:
                throw new JGitInternalException(MessageFormat.format(JGitText.get().updatingRefFailed, targetRef, commitId.name(), rc));
        }
    }
}
#end_block

#method_before
private void checkCreateCommit(Repository repo, RevCommit commit, Project.NameKey project, PermissionBackend.ForRef forRef) throws AuthException, PermissionBackendException {
    try {
        // If the user has update (push) permission, they can create the ref regardless
        // of whether they are pushing any new objects along with the create.
        forRef.check(RefPermission.UPDATE);
        return;
    } catch (AuthException denied) {
    // Fall through to check reachability.
    }
    if (reachable.fromHeadsOrTags(project, repo, commit)) {
        // even if they don't have push permission.
        return;
    }
    AuthException e = new AuthException(String.format("%s for creating new commit object not permitted", RefPermission.UPDATE.describeForException()));
    e.setAdvice("use a SHA1 visible to you, or get push permission on the ref");
    throw e;
}
#method_after
private void checkCreateCommit(Repository repo, RevCommit commit, Project.NameKey project, PermissionBackend.ForRef forRef) throws AuthException, PermissionBackendException {
    try {
        // If the user has update (push) permission, they can create the ref regardless
        // of whether they are pushing any new objects along with the create.
        forRef.check(RefPermission.UPDATE);
        return;
    } catch (AuthException denied) {
    // Fall through to check reachability.
    }
    if (reachable.fromHeadsOrTags(project, repo, commit)) {
        // even if they don't have push permission.
        return;
    }
    AuthException e = new AuthException(String.format("%s for creating new commit object not permitted", RefPermission.UPDATE.describeForException()));
    e.setAdvice(String.format("use a SHA1 visible to you, or get %s permission on the ref", RefPermission.UPDATE.describeForException()));
    throw e;
}
#end_block

#method_before
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            // Get the patch list:
            PatchList patchList = null;
            try {
                patchList = getPatchList(c.key.patchSetId);
            } catch (PatchListNotAvailableException e) {
                logger.atSevere().withCause(e).log("Failed to get patch list");
            }
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    logger.atWarning().withCause(e).log("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getName());
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    groups.sort(Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#method_after
private List<CommentSender.FileCommentGroup> getGroupedInlineComments(Repository repo) {
    List<CommentSender.FileCommentGroup> groups = new ArrayList<>();
    // Loop over the comments and collect them into groups based on the file
    // location of the comment.
    FileCommentGroup currentGroup = null;
    for (Comment c : inlineComments) {
        // If it's a new group:
        if (currentGroup == null || !c.key.filename.equals(currentGroup.filename) || c.key.patchSetId != currentGroup.patchSetId) {
            currentGroup = new FileCommentGroup();
            currentGroup.filename = c.key.filename;
            currentGroup.patchSetId = c.key.patchSetId;
            // Get the patch list:
            PatchList patchList = null;
            try {
                patchList = getPatchList(c.key.patchSetId);
            } catch (PatchListObjectTooLargeException e) {
                logger.atWarning().log("Failed to get patch list: %s", e.getMessage());
            } catch (PatchListNotAvailableException e) {
                logger.atSevere().withCause(e).log("Failed to get patch list");
            }
            groups.add(currentGroup);
            if (patchList != null) {
                try {
                    currentGroup.fileData = new PatchFile(repo, patchList, c.key.filename);
                } catch (IOException e) {
                    logger.atWarning().withCause(e).log("Cannot load %s from %s in %s", c.key.filename, patchList.getNewId().name(), projectState.getName());
                    currentGroup.fileData = null;
                }
            }
        }
        if (currentGroup.fileData != null) {
            currentGroup.comments.add(c);
        }
    }
    groups.sort(Comparator.comparing(g -> g.filename, FilenameComparator.INSTANCE));
    return groups;
}
#end_block

#method_before
protected PatchList getPatchList(int patchSetId) throws PatchListNotAvailableException {
    PatchSet patchSet = new PatchSet(new PatchSet.Id(change.getId(), patchSetId));
    return args.patchListCache.get(change, patchSet);
}
#method_after
protected PatchList getPatchList(int patchSetId) throws PatchListNotAvailableException {
    PatchSet ps;
    if (patchSetId == patchSet.getPatchSetId()) {
        ps = patchSet;
    } else {
        try {
            ps = args.patchSetUtil.get(changeData.db(), changeData.notes(), new PatchSet.Id(change.getId(), patchSetId));
        } catch (OrmException e) {
            throw new PatchListNotAvailableException("Failed to get patchSet");
        }
    }
    return args.patchListCache.get(change, ps);
}
#end_block

#method_before
@Override
public void start() {
    startPublisherThread();
    if (!isConnected()) {
        connect();
        monitorTimer.schedule(new TimerTask() {

            @Override
            public void run() {
                if (!isConnected()) {
                    LOGGER.info("#start: try to reconnect");
                    connect();
                }
            }
        }, MONITOR_FIRSTTIME_DELAY, properties.getSection(Monitor.class).interval);
    }
}
#method_after
@Override
public void start() {
    ensurePublisherThreadStarted();
    if (!isConnected()) {
        connect();
        monitorTimer.schedule(new TimerTask() {

            @Override
            public void run() {
                if (!isConnected()) {
                    LOGGER.info("#start: try to reconnect");
                    connect();
                }
            }
        }, MONITOR_FIRSTTIME_DELAY, properties.getSection(Monitor.class).interval);
    }
}
#end_block

#method_before
protected RequestContext newRequestContext(Account.Id requestUserId) {
    final CurrentUser requestUser = userFactory.create(requestUserId);
    return new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return requestUser;
        }
    };
}
#method_after
protected RequestContext newRequestContext(Account.Id requestUserId) {
    final CurrentUser requestUser = userFactory.create(requestUserId);
    return () -> requestUser;
}
#end_block

#method_before
protected void setAnonymous() {
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return anonymousUser.get();
        }
    });
}
#method_after
protected void setAnonymous() {
    requestContext.setContext(anonymousUser::get);
}
#end_block

#method_before
protected RequestContext newRequestContext(Account.Id requestUserId) {
    final CurrentUser requestUser = userFactory.create(requestUserId);
    return new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return requestUser;
        }
    };
}
#method_after
protected RequestContext newRequestContext(Account.Id requestUserId) {
    final CurrentUser requestUser = userFactory.create(requestUserId);
    return () -> requestUser;
}
#end_block

#method_before
protected void setAnonymous() {
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return anonymousUser.get();
        }
    });
}
#method_after
protected void setAnonymous() {
    requestContext.setContext(anonymousUser::get);
}
#end_block

#method_before
@Override
void add(Document doc, Values<ProjectData> values) {
    // Add separate DocValues fields for those fields needed for sorting.
    FieldDef<ProjectData, ?> f = values.getField();
    if (f == NAME) {
        String value = (String) getOnlyElement(values.getValues());
        doc.add(new SortedDocValuesField(NAME_SORT_FIELD, new BytesRef(value)));
    }
    super.add(doc, values);
}
#method_after
@Override
void add(Document doc, Values<ProjectData> values) {
    // Add separate DocValues field for the field that is needed for sorting.
    FieldDef<ProjectData, ?> f = values.getField();
    if (f == NAME) {
        String value = (String) getOnlyElement(values.getValues());
        doc.add(new SortedDocValuesField(NAME_SORT_FIELD, new BytesRef(value)));
    }
    super.add(doc, values);
}
#end_block

#method_before
@Override
void add(Document doc, Values<InternalGroup> values) {
    // Add separate DocValues fields for those fields needed for sorting.
    FieldDef<InternalGroup, ?> f = values.getField();
    if (f == UUID) {
        String value = (String) getOnlyElement(values.getValues());
        doc.add(new SortedDocValuesField(UUID_SORT_FIELD, new BytesRef(value)));
    }
    super.add(doc, values);
}
#method_after
@Override
void add(Document doc, Values<InternalGroup> values) {
    // Add separate DocValues field for the field that is needed for sorting.
    FieldDef<InternalGroup, ?> f = values.getField();
    if (f == UUID) {
        String value = (String) getOnlyElement(values.getValues());
        doc.add(new SortedDocValuesField(UUID_SORT_FIELD, new BytesRef(value)));
    }
    super.add(doc, values);
}
#end_block

#method_before
protected RequestContext newRequestContext(Account.Id requestUserId) {
    final CurrentUser requestUser = userFactory.create(requestUserId);
    return new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return requestUser;
        }
    };
}
#method_after
protected RequestContext newRequestContext(Account.Id requestUserId) {
    final CurrentUser requestUser = userFactory.create(requestUserId);
    return () -> requestUser;
}
#end_block

#method_before
protected void setAnonymous() {
    requestContext.setContext(new RequestContext() {

        @Override
        public CurrentUser getUser() {
            return anonymousUser.get();
        }
    });
}
#method_after
protected void setAnonymous() {
    requestContext.setContext(anonymousUser::get);
}
#end_block

#method_before
@Test
public void sortedByFullname() throws Exception {
    String appendix = name("name");
    AccountInfo userFoo = newAccountWithFullName("user1", "foo-" + appendix);
    AccountInfo userBar = newAccountWithFullName("user2", "bar-" + appendix);
    AccountInfo userBaz = newAccountWithFullName("user3", "baz-" + appendix);
    String query = "name:" + userFoo.name + " OR name:" + userBar.name + " OR name:" + userBaz.name;
    // Must request details to populate fullname in the results. If fullname is not set sorting by
    // fullname is not possible.
    assertQuery(newQuery(query).withOption(ListAccountsOption.DETAILS), userBar, userBaz, userFoo);
}
#method_after
@Test
public void sortedByFullname() throws Exception {
    String appendix = name("name");
    // Use an account creation order that ensures that sorting by fullname differs from sorting by
    // account ID.
    AccountInfo userFoo = newAccountWithFullName("user1", "foo-" + appendix);
    AccountInfo userBar = newAccountWithFullName("user2", "bar-" + appendix);
    AccountInfo userBaz = newAccountWithFullName("user3", "baz-" + appendix);
    assertThat(userFoo._accountId).isLessThan(userBar._accountId);
    assertThat(userBar._accountId).isLessThan(userBaz._accountId);
    String query = "name:" + userFoo.name + " OR name:" + userBar.name + " OR name:" + userBaz.name;
    // Must request details to populate fullname in the results. If fullname is not set sorting by
    // fullname is not possible.
    assertQuery(newQuery(query).withOption(ListAccountsOption.DETAILS), userBar, userBaz, userFoo);
}
#end_block

#method_before
@Override
public void onEvent(Event event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = e.getProjectNameKey();
    int maxReviewers;
    String ignoreSubjectRegEx;
    String ignoreFileRegEx;
    try {
        maxReviewers = cfg.getFromProjectConfigWithInheritance(projectName, pluginName).getInt("maxReviewers", 3);
        ignoreSubjectRegEx = cfg.getFromProjectConfigWithInheritance(projectName, pluginName).getString("ignoreSubjectRegEx", "");
        ignoreFileRegEx = cfg.getFromProjectConfigWithInheritance(projectName, pluginName).getString("ignoreFileRegEx", "");
    } catch (NoSuchProjectException x) {
        log.error(x.getMessage(), x);
        return;
    }
    if (maxReviewers <= 0) {
        return;
    }
    try (Repository git = repoManager.openRepository(projectName);
        RevWalk rw = new RevWalk(git)) {
        final ChangeData cd = getChangeData(e.getChangeKey(), projectName, e.getRefName());
        if (cd == null) {
            log.warn("Unique change with key: '" + e.getChangeKey().toString() + "' on project key: '" + projectName.toString() + "' for ref: '" + e.getRefName() + "' not found.");
            return;
        }
        final Change change = cd.change();
        Change.Id changeId = new Change.Id(e.change.get().number);
        PatchSet.Id psId = new PatchSet.Id(changeId, e.patchSet.get().number);
        PatchSet ps = cd.patchSet(psId);
        if (ps == null) {
            log.warn("Patch set " + psId.get() + " not found in change " + changeId.get() + ".");
            return;
        }
        final RevCommit commit = rw.parseCommit(ObjectId.fromString(e.patchSet.get().revision));
        if (!ignoreSubjectRegEx.isEmpty() && commit.getShortMessage().matches(ignoreSubjectRegEx)) {
            return;
        }
        final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git, ignoreFileRegEx);
        workQueue.getDefaultQueue().submit(new Runnable() {

            @Override
            public void run() {
                RequestContext old = tl.setContext(new RequestContext() {

                    @Override
                    public CurrentUser getUser() {
                        return identifiedUserFactory.create(change.getOwner());
                    }

                    @Override
                    public Provider<ReviewDb> getReviewDbProvider() {
                        return new Provider<ReviewDb>() {

                            @Override
                            public ReviewDb get() {
                                if (db == null) {
                                    try {
                                        db = schemaFactory.open();
                                    } catch (OrmException e) {
                                        throw new ProvisionException("Cannot open ReviewDb", e);
                                    }
                                }
                                return db;
                            }
                        };
                    }
                });
                try {
                    task.run();
                } finally {
                    tl.setContext(old);
                    if (db != null) {
                        db.close();
                        db = null;
                    }
                }
            }
        });
    } catch (OrmException | IOException x) {
        log.error(x.getMessage(), x);
    }
}
#method_after
@Override
public void onEvent(Event event) {
    if (!(event instanceof PatchSetCreatedEvent)) {
        return;
    }
    PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
    Project.NameKey projectName = e.getProjectNameKey();
    int maxReviewers;
    String ignoreSubjectRegEx;
    String ignoreFileRegEx;
    try {
        maxReviewers = cfg.getFromProjectConfigWithInheritance(projectName, pluginName).getInt("maxReviewers", 3);
        ignoreSubjectRegEx = cfg.getFromProjectConfigWithInheritance(projectName, pluginName).getString("ignoreSubjectRegEx", "");
        ignoreFileRegEx = cfg.getFromProjectConfigWithInheritance(projectName, pluginName).getString("ignoreFileRegEx", "");
    } catch (NoSuchProjectException x) {
        log.error(x.getMessage(), x);
        return;
    }
    if (maxReviewers <= 0) {
        return;
    }
    try (Repository git = repoManager.openRepository(projectName);
        RevWalk rw = new RevWalk(git);
        ReviewDb reviewDb = schemaFactory.open()) {
        Change.Id changeId = new Change.Id(e.change.get().number);
        final ChangeData cd = changeDataFactory.create(reviewDb, projectName, changeId);
        if (cd == null) {
            log.warn("Change with id: '{}' on project key: '{}' not found.", changeId.get(), projectName.toString());
            return;
        }
        final Change change = cd.change();
        PatchSet.Id psId = new PatchSet.Id(changeId, e.patchSet.get().number);
        PatchSet ps = cd.patchSet(psId);
        if (ps == null) {
            log.warn("Patch set {} not found in change {}.", psId.get(), changeId.get());
            return;
        }
        final RevCommit commit = rw.parseCommit(ObjectId.fromString(e.patchSet.get().revision));
        if (!ignoreSubjectRegEx.isEmpty() && commit.getShortMessage().matches(ignoreSubjectRegEx)) {
            return;
        }
        final Runnable task = reviewersByBlameFactory.create(commit, change, ps, maxReviewers, git, ignoreFileRegEx);
        workQueue.getDefaultQueue().submit(new Runnable() {

            @Override
            public void run() {
                RequestContext old = tl.setContext(new RequestContext() {

                    @Override
                    public CurrentUser getUser() {
                        return identifiedUserFactory.create(change.getOwner());
                    }

                    @Override
                    public Provider<ReviewDb> getReviewDbProvider() {
                        return new Provider<ReviewDb>() {

                            @Override
                            public ReviewDb get() {
                                if (db == null) {
                                    try {
                                        db = schemaFactory.open();
                                    } catch (OrmException e) {
                                        throw new ProvisionException("Cannot open ReviewDb", e);
                                    }
                                }
                                return db;
                            }
                        };
                    }
                });
                try {
                    task.run();
                } finally {
                    tl.setContext(old);
                    if (db != null) {
                        db.close();
                        db = null;
                    }
                }
            }
        });
    } catch (OrmException | IOException x) {
        log.error(x.getMessage(), x);
    }
}
#end_block

#method_before
private static QuotaResponse.Aggregated request(PluginSetContext<QuotaEnforcer> quotaEnforcers, String quotaGroup, QuotaRequestContext requestContext, long numTokens, boolean deduct) {
    checkState(numTokens > 0, "numTokens must be a positive, non-zero long");
    // PluginSets can change their content when plugins (de-)register. Copy the currently registered
    // plugins so that we can iterate twice on a stable list.
    List<PluginSetEntryContext<QuotaEnforcer>> enforcers = ImmutableList.copyOf(quotaEnforcers);
    List<QuotaResponse> responses = new ArrayList<>(enforcers.size());
    for (int i = 0; i < enforcers.size(); i++) {
        PluginSetEntryContext<QuotaEnforcer> enforcer = enforcers.get(i);
        try {
            if (deduct) {
                responses.add(enforcer.call(p -> p.requestTokens(quotaGroup, requestContext, numTokens)));
            } else {
                responses.add(enforcer.call(p -> p.dryRun(quotaGroup, requestContext, numTokens)));
            }
        } catch (RuntimeException e) {
            // exception to adhere to the API contract.
            if (deduct) {
                refillAfterErrorOrException(enforcers, responses, quotaGroup, requestContext, numTokens);
            }
            throw e;
        }
    }
    if (deduct && responses.stream().anyMatch(r -> r.status().isError())) {
        // Roll back the quota request for all enforcers that deducted the quota (= the request
        // succeeded). Don't touch failed enforcers as the interface contract said that failed
        // requests should not be deducted.
        refillAfterErrorOrException(enforcers, responses, quotaGroup, requestContext, numTokens);
    }
    logger.atFine().log("Quota request for %s with %s (deduction=%s) for %s token returned %s", quotaGroup, requestContext, deduct ? "(deduction=yes)" : "(deduction=no)", numTokens, responses);
    return QuotaResponse.Aggregated.create(ImmutableList.copyOf(responses));
}
#method_after
private static QuotaResponse.Aggregated request(PluginSetContext<QuotaEnforcer> quotaEnforcers, String quotaGroup, QuotaRequestContext requestContext, long numTokens, boolean deduct) {
    checkState(numTokens > 0, "numTokens must be a positive, non-zero long");
    // PluginSets can change their content when plugins (de-)register. Copy the currently registered
    // plugins so that we can iterate twice on a stable list.
    List<PluginSetEntryContext<QuotaEnforcer>> enforcers = ImmutableList.copyOf(quotaEnforcers);
    List<QuotaResponse> responses = new ArrayList<>(enforcers.size());
    for (PluginSetEntryContext<QuotaEnforcer> enforcer : enforcers) {
        try {
            if (deduct) {
                responses.add(enforcer.call(p -> p.requestTokens(quotaGroup, requestContext, numTokens)));
            } else {
                responses.add(enforcer.call(p -> p.dryRun(quotaGroup, requestContext, numTokens)));
            }
        } catch (RuntimeException e) {
            // exception to adhere to the API contract.
            if (deduct) {
                refillAfterErrorOrException(enforcers, responses, quotaGroup, requestContext, numTokens);
            }
            throw e;
        }
    }
    if (deduct && responses.stream().anyMatch(r -> r.status().isError())) {
        // Roll back the quota request for all enforcers that deducted the quota (= the request
        // succeeded). Don't touch failed enforcers as the interface contract said that failed
        // requests should not be deducted.
        refillAfterErrorOrException(enforcers, responses, quotaGroup, requestContext, numTokens);
    }
    logger.atFine().log("Quota request for %s with %s (deduction=%s) for %s token returned %s", quotaGroup, requestContext, deduct ? "(deduction=yes)" : "(deduction=no)", numTokens, responses);
    return QuotaResponse.Aggregated.create(ImmutableList.copyOf(responses));
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new AuditModule());
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new PluginModule());
    if (VersionManager.getOnlineUpgrade(config)) {
        modules.add(new OnlineUpgrader.Module());
    }
    modules.add(new WorkQueue.Module());
    modules.add(new GerritInstanceNameModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new DefaultUrlFormatter.Module());
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
            bind(GerritRuntime.class).toInstance(GerritRuntime.DAEMON);
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    modules.add(new EventBroker.Module());
    modules.add(new JdbcAccountPatchReviewStore.Module(config));
    modules.add(cfgInjector.getInstance(GitRepositoryManagerModule.class));
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module());
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new AuditModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new PluginModule());
    if (VersionManager.getOnlineUpgrade(config)) {
        modules.add(new OnlineUpgrader.Module());
    }
    modules.add(new RestApiModule());
    modules.add(new WorkQueue.Module());
    modules.add(new GerritInstanceNameModule());
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(new DefaultUrlFormatter.Module());
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, false, false, false));
            bind(GerritRuntime.class).toInstance(GerritRuntime.DAEMON);
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    modules.add(new AccountDeactivator.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new PluginModule());
    if (VersionManager.getOnlineUpgrade(config) && // Schema upgrade is handled by OnlineNoteDbMigrator in this case.
    !migrateToNoteDb()) {
        modules.add(new OnlineUpgrader.Module());
    }
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    if (auditEventModule != null) {
        modules.add(auditEventModule);
    } else {
        modules.add(new AuditModule());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    modules.add(new GerritInstanceNameModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(new DefaultUrlFormatter.Module());
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (slave) {
        modules.add(new PeriodicGroupIndexer.Module());
    } else {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new DropWizardMetricMaker.RestModule());
    modules.add(new LogFileCompressor.Module());
    // Index module shutdown must happen before work queue shutdown, otherwise
    // work queue can get stuck waiting on index futures that will never return.
    modules.add(createIndexModule());
    modules.add(new WorkQueue.Module());
    modules.add(new StreamEventsApiListener.Module());
    modules.add(new EventBroker.Module());
    modules.add(inMemoryTest ? new InMemoryAccountPatchReviewStore.Module() : new JdbcAccountPatchReviewStore.Module(config));
    modules.add(new SysExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new GerritApiModule());
    modules.add(new PluginApiModule());
    modules.add(new SearchingChangeCacheImpl.Module(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultPermissionBackendModule());
    modules.add(new DefaultMemoryCacheModule());
    modules.add(new H2CacheModule());
    modules.add(cfgInjector.getInstance(MailReceiver.Module.class));
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    if (auditEventModule != null) {
        modules.add(auditEventModule);
    } else {
        modules.add(new AuditModule());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginModule());
    if (VersionManager.getOnlineUpgrade(config) && // Schema upgrade is handled by OnlineNoteDbMigrator in this case.
    !migrateToNoteDb()) {
        modules.add(new OnlineUpgrader.Module());
    }
    modules.add(new RestApiModule());
    modules.add(new GpgModule(config));
    modules.add(new StartupChecks.Module());
    modules.add(new GerritInstanceNameModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    modules.add(new DefaultUrlFormatter.Module());
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(config, headless, slave, polyGerritDev));
            if (inMemoryTest) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    if (slave) {
        modules.add(new PeriodicGroupIndexer.Module());
    } else {
        modules.add(new AccountDeactivator.Module());
        modules.add(new ChangeCleanupRunner.Module());
    }
    if (migrateToNoteDb()) {
        modules.add(new OnlineNoteDbMigrator.Module(trial));
    }
    if (testSysModule != null) {
        modules.add(testSysModule);
    }
    modules.add(new LocalMergeSuperSetComputation.Module());
    modules.add(new DefaultProjectNameLockManager.Module());
    return cfgInjector.createChildInjector(ModuleOverloader.override(modules, LibModuleLoader.loadModules(cfgInjector)));
}
#end_block

