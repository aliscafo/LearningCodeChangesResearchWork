117
#method_before
@Override
protected boolean validate() {
    final boolean result = validateImpl();
    if (!result && !isInternalExecution() && !getParameters().isRerun()) {
        logValidationFailed();
    }
    return result;
}
#method_after
@Override
protected final boolean validate() {
    final boolean result = validateImpl();
    if (!result && !isInternalExecution() && !getParameters().isRerun()) {
        logValidationFailed();
    }
    return result;
}
#end_block

#method_before
private TransferDiskImageParameters createInitParams() {
    Disk newDisk = diskModel.getDisk();
    AddDiskParameters diskParameters = new AddDiskParameters(newDisk);
    if (diskModel.getDiskStorageType().getEntity() == DiskStorageType.IMAGE || diskModel.getDiskStorageType().getEntity() == DiskStorageType.CINDER) {
        diskParameters.setStorageDomainId(getDiskModel().getStorageDomain().getSelectedItem().getId());
    }
    TransferDiskImageParameters parameters = new TransferDiskImageParameters(diskParameters.getStorageDomainId(), AsyncDataProvider.getInstance().getTransferImageInactivityTimeoutInSeconds(), diskParameters);
    parameters.setTransferSize(getImageSize());
    parameters.setVdsId(getDiskModel().getHost().getSelectedItem().getId());
    return parameters;
}
#method_after
private TransferDiskImageParameters createInitParams() {
    Disk newDisk = diskModel.getDisk();
    AddDiskParameters diskParameters = new AddDiskParameters(newDisk);
    if (diskModel.getDiskStorageType().getEntity() == DiskStorageType.IMAGE || diskModel.getDiskStorageType().getEntity() == DiskStorageType.CINDER) {
        diskParameters.setStorageDomainId(getDiskModel().getStorageDomain().getSelectedItem().getId());
    }
    TransferDiskImageParameters parameters = new TransferDiskImageParameters(diskParameters.getStorageDomainId(), AsyncDataProvider.getInstance().getTransferImageClientInactivityTimeoutInSeconds(), diskParameters);
    parameters.setTransferSize(getImageSize());
    parameters.setVdsId(getDiskModel().getHost().getSelectedItem().getId());
    return parameters;
}
#end_block

#method_before
public static boolean isSpecialDevice(String device, VmDeviceGeneralType type) {
    switch(type) {
        case SOUND:
            return true;
        case CONSOLE:
            return VmDeviceType.CONSOLE.getName().equals(device);
        case SMARTCARD:
            return VmDeviceType.SMARTCARD.getName().equals(device);
        case REDIR:
            return VmDeviceType.SPICEVMC.getName().equals(device);
        case BALLOON:
            return VmDeviceType.MEMBALLOON.getName().equals(device);
        case WATCHDOG:
            return VmDeviceType.WATCHDOG.getName().equals(device);
        case RNG:
            return VmDeviceType.VIRTIO.getName().equals(device);
        case CONTROLLER:
            if (VmDeviceType.VIRTIOSERIAL.getName().equals(device)) {
                return true;
            }
            if (VmDeviceType.VIRTIOSCSI.getName().equals(device)) {
                return true;
            }
            return false;
        default:
            return VmDeviceType.USB.getName().equals(device);
    }
}
#method_after
public static boolean isSpecialDevice(String device, VmDeviceGeneralType type) {
    switch(type) {
        case SOUND:
            return true;
        case CONSOLE:
            return VmDeviceType.CONSOLE.getName().equals(device);
        case SMARTCARD:
            return VmDeviceType.SMARTCARD.getName().equals(device);
        case REDIR:
            return VmDeviceType.SPICEVMC.getName().equals(device);
        case BALLOON:
            return VmDeviceType.MEMBALLOON.getName().equals(device);
        case WATCHDOG:
            return VmDeviceType.WATCHDOG.getName().equals(device);
        case RNG:
            return VmDeviceType.VIRTIO.getName().equals(device);
        case CONTROLLER:
            return VmDeviceType.VIRTIOSERIAL.getName().equals(device) || VmDeviceType.VIRTIOSCSI.getName().equals(device);
        default:
            return VmDeviceType.USB.getName().equals(device);
    }
}
#end_block

#method_before
@Override
protected ImageTransferDao prepareDao() {
    return dbFacade.getImageTransferDao();
}
#method_after
@Override
protected ImageTransferDao prepareDao() {
    return dao;
}
#end_block

#method_before
@Override
public void edit(T object) {
    doEdit(object);
    updateUiCommonMaps();
    updateUiCommonEditorVisitor();
    registerPropertyChangeListener(object);
    accept(visitor);
}
#method_after
@Override
public void edit(T object) {
    // Cleanup on previously edited object
    removePropertyChangeListener(getObject());
    // Initialize Editor Driver with newly edited object
    doEdit(object);
    updateUiCommonMaps();
    updateUiCommonEditorVisitor();
    updatePropertyChangeListener(object);
    // Traverse Editor hierarchy to handle UiCommon specifics
    accept(visitor);
}
#end_block

#method_before
private void updateUiCommonMaps() {
    cleanupUiCommonMaps();
    // All UiCommon map creators depend on currently edited object
    listenerMap = getListenerMap();
    eventMap = getEventMap();
    ownerModels = getOwnerModels();
}
#method_after
private void updateUiCommonMaps() {
    cleanupUiCommonMaps();
    // Map creator methods depend on currently edited object
    listenerMap = getListenerMap();
    eventMap = getEventMap();
    ownerModels = getOwnerModels();
}
#end_block

#method_before
protected void cleanupEditorDriver() {
    // At this point, model cleanup is already done
    cleanupUiCommonMaps();
    removePropertyChangeListener(getObject());
}
#method_after
protected void cleanupEditorDriver() {
    // At this point, the model is already cleaned up
    cleanupUiCommonMaps();
    removePropertyChangeListener(getObject());
}
#end_block

#method_before
public String encode(String data) throws GeneralSecurityException, IOException {
    Base64 base64 = new Base64(0);
    Map<String, String> map = new HashMap<>();
    byte[] random = new byte[8];
    secureRandom.nextBytes(random);
    map.put("salt", base64.encodeToString(random));
    map.put("digest", "sha1");
    DateFormat df = new SimpleDateFormat(DATE_FORMAT);
    df.setTimeZone(TimeZone.getTimeZone("UTC"));
    map.put("validFrom", df.format(new Date()));
    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    cal.add(Calendar.SECOND, lifetime);
    map.put("validTo", df.format(cal.getTime()));
    map.put("data", data);
    /*
         * Calculate signature on fields in map
         */
    Signature signature = Signature.getInstance(String.format("%swith%s", map.get("digest"), key.getAlgorithm()));
    signature.initSign(key);
    StringBuilder fields = new StringBuilder();
    for (Map.Entry<String, String> entry : map.entrySet()) {
        if (fields.length() > 0) {
            fields.append(",");
        }
        fields.append(entry.getKey());
        signature.update(entry.getValue().getBytes(StandardCharsets.UTF_8));
    }
    /*
         * Add unsigned fields
         */
    map.put("signedFields", fields.toString());
    map.put("signature", base64.encodeToString(signature.sign()));
    map.put("certificate", String.format("-----BEGIN CERTIFICATE-----\n" + "%s" + "-----END CERTIFICATE-----\n", new Base64(76).encodeToString(cert.getEncoded())));
    return base64.encodeToString(new ObjectMapper().writeValueAsString(map).getBytes(StandardCharsets.UTF_8));
}
#method_after
public String encode(String data) throws GeneralSecurityException, IOException {
    Base64 base64 = new Base64(0);
    Map<String, String> map = new HashMap<>();
    byte[] random = new byte[8];
    SECURE_RANDOM.nextBytes(random);
    map.put("salt", base64.encodeToString(random));
    map.put("digest", "sha1");
    DateFormat df = new SimpleDateFormat(DATE_FORMAT);
    df.setTimeZone(TimeZone.getTimeZone("UTC"));
    map.put("validFrom", df.format(new Date()));
    Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("UTC"));
    cal.add(Calendar.SECOND, lifetime);
    map.put("validTo", df.format(cal.getTime()));
    map.put("data", data);
    /*
         * Calculate signature on fields in map
         */
    Signature signature = Signature.getInstance(String.format("%swith%s", map.get("digest"), key.getAlgorithm()));
    signature.initSign(key);
    StringBuilder fields = new StringBuilder();
    for (Map.Entry<String, String> entry : map.entrySet()) {
        if (fields.length() > 0) {
            fields.append(",");
        }
        fields.append(entry.getKey());
        signature.update(entry.getValue().getBytes(StandardCharsets.UTF_8));
    }
    /*
         * Add unsigned fields
         */
    map.put("signedFields", fields.toString());
    map.put("signature", base64.encodeToString(signature.sign()));
    map.put("certificate", String.format("-----BEGIN CERTIFICATE-----\n" + "%s" + "-----END CERTIFICATE-----\n", new Base64(76).encodeToString(cert.getEncoded())));
    return base64.encodeToString(new ObjectMapper().writeValueAsString(map).getBytes(StandardCharsets.UTF_8));
}
#end_block

#method_before
public static String crypt(String password) {
    byte[] r = new byte[SALT_MAX_LENGTH];
    char[] salt = new char[r.length];
    secureRandom.nextBytes(r);
    for (int i = 0; i < r.length; i++) {
        salt[i] = b64t[(r[i] & 0xff) % b64t.length];
    }
    return crypt(password, new String(salt));
}
#method_after
public static String crypt(String password) {
    byte[] r = new byte[SALT_MAX_LENGTH];
    char[] salt = new char[r.length];
    SECURE_RANDOM.nextBytes(r);
    for (int i = 0; i < r.length; i++) {
        salt[i] = b64t[(r[i] & 0xff) % b64t.length];
    }
    return crypt(password, new String(salt));
}
#end_block

#method_before
private void replicateDiskStart() {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        throw new EngineException(EngineError.down, "VM " + getParameters().getVmId() + " is not running on any VDS");
    }
    StorageType targetType = this.getStorageDomainById(getParameters().getTargetStorageDomainId(), getParameters().getStoragePoolId()).getStorageStaticData().getStorageType();
    Optional<String> diskType = vmInfoBuildUtils.getNetworkDiskType(getVm(), targetType);
    // Start disk migration
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), diskType.orElse(null));
    VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.VmReplicateDiskStart, migrationStartParams);
    if (!ret.getSucceeded()) {
        log.error("Failed VmReplicateDiskStart (Disk '{}' , VM '{}')", getParameters().getImageGroupID(), getParameters().getVmId());
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#method_after
private void replicateDiskStart() {
    if (Guid.Empty.equals(getParameters().getVdsId())) {
        throw new EngineException(EngineError.down, "VM " + getParameters().getVmId() + " is not running on any VDS");
    }
    StorageType targetType = getDstStorageDomain().getStorageStaticData().getStorageType();
    Optional<String> diskType = vmInfoBuildUtils.getNetworkDiskType(getVm(), targetType);
    // Start disk migration
    VmReplicateDiskParameters migrationStartParams = new VmReplicateDiskParameters(getParameters().getVdsId(), getParameters().getVmId(), getParameters().getStoragePoolId(), getParameters().getSourceStorageDomainId(), getParameters().getTargetStorageDomainId(), getParameters().getImageGroupID(), getParameters().getDestinationImageId(), diskType.orElse(null));
    VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.VmReplicateDiskStart, migrationStartParams);
    if (!ret.getSucceeded()) {
        log.error("Failed VmReplicateDiskStart (Disk '{}' , VM '{}')", getParameters().getImageGroupID(), getParameters().getVmId());
        throw new EngineException(ret.getVdsError().getCode(), ret.getVdsError().getMessage());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean validate = super.validate();
    if (!validate) {
        auditLogDirector.log(this, AuditLogType.USER_MOVED_DISK_FINISHED_FAILURE);
    }
    if (!getVm().isRunningAndQualifyForDisksMigration()) {
        return failValidation(EngineMessage.CANNOT_LIVE_MIGRATE_VM_SHOULD_BE_IN_PAUSED_OR_UP_STATUS);
    }
    setStoragePoolId(getVm().getStoragePoolId());
    if (!validateDestDomainsSpaceRequirements()) {
        return false;
    }
    getReturnValue().setValid(isDiskNotShareable(getParameters().getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(getParameters().getImageId()));
    if (!getReturnValue().isValid()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand() && validate;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (!getVm().isRunningAndQualifyForDisksMigration()) {
        return failValidation(EngineMessage.CANNOT_LIVE_MIGRATE_VM_SHOULD_BE_IN_PAUSED_OR_UP_STATUS);
    }
    setStoragePoolId(getVm().getStoragePoolId());
    if (!validate(new StorageDomainValidator(getDstStorageDomain()).isNotBackupDomain()) || !validateDestDomainsSpaceRequirements()) {
        return false;
    }
    getReturnValue().setValid(isDiskNotShareable(getParameters().getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(getParameters().getImageId()));
    if (!getReturnValue().isValid()) {
        return false;
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand();
}
#end_block

#method_before
protected boolean validateDestDomainsSpaceRequirements() {
    Guid destDomainId = getParameters().getTargetStorageDomainId();
    DiskImage diskImage = getDiskImageByImageId(getParameters().getImageId());
    Guid storagePoolId = diskImage.getStoragePoolId();
    StorageDomain destDomain = getStorageDomainById(destDomainId, storagePoolId);
    if (!isStorageDomainWithinThresholds(destDomain)) {
        return false;
    }
    List<DiskImage> allImageSnapshots = diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId());
    diskImage.getSnapshots().addAll(allImageSnapshots);
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator(destDomain);
    if (!validate(storageDomainValidator.hasSpaceForClonedDisks(Collections.singleton(diskImage)))) {
        return false;
    }
    return true;
}
#method_after
protected boolean validateDestDomainsSpaceRequirements() {
    if (!isStorageDomainWithinThresholds(getDstStorageDomain())) {
        return false;
    }
    DiskImage diskImage = getDiskImageByImageId(getParameters().getImageId());
    List<DiskImage> allImageSnapshots = diskImageDao.getAllSnapshotsForLeaf(diskImage.getImageId());
    diskImage.getSnapshots().addAll(allImageSnapshots);
    StorageDomainValidator storageDomainValidator = createStorageDomainValidator(getDstStorageDomain());
    if (!validate(storageDomainValidator.hasSpaceForClonedDisks(Collections.singleton(diskImage)))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected CommandContext createOvaCreationStepContext() {
    CommandContext commandCtx = null;
    StepEnum step = StepEnum.CREATING_OVA;
    try {
        Step removeVmStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), step, ExecutionMessageDirector.resolveStepMessage(step, Collections.emptyMap()));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(removeVmStep);
        ctx.setMonitored(true);
        commandCtx = cloneContext().withoutCompensationContext().withExecutionContext(ctx).withoutLock();
    } catch (RuntimeException e) {
        log.error("Failed to create command context of creating OVA '{}': {}", getVmName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#method_after
protected CommandContext createOvaCreationStepContext() {
    CommandContext commandCtx = null;
    StepEnum step = StepEnum.CREATING_OVA;
    try {
        Step ovaCreationStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), step, ExecutionMessageDirector.resolveStepMessage(step, Collections.emptyMap()));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(ovaCreationStep);
        ctx.setMonitored(true);
        commandCtx = cloneContext().withoutCompensationContext().withExecutionContext(ctx).withoutLock();
    } catch (RuntimeException e) {
        log.error("Failed to create command context of creating OVA '{}': {}", getVmName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#end_block

#method_before
@Override
protected void processImages() {
    ArrayList<Guid> diskIds = getVm().getImages().stream().map(this::createDisk).collect(Collectors.toCollection(ArrayList::new));
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#method_after
@Override
protected void processImages() {
    ArrayList<Guid> diskIds = getVm().getImages().stream().map(this::adjustDisk).map(this::createDisk).collect(Collectors.toCollection(ArrayList::new));
    getParameters().setDisks(diskIds);
    setSucceeded(true);
}
#end_block

#method_before
protected AddDiskParameters buildAddDiskParameters(DiskImage image) {
    image.setDiskAlias(renameDiskAlias(getVm().getOrigin(), image.getDiskAlias()));
    AddDiskParameters diskParameters = new AddDiskParameters(image.getDiskVmElementForVm(getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    diskParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return diskParameters;
}
#method_after
protected AddDiskParameters buildAddDiskParameters(DiskImage image) {
    AddDiskParameters diskParameters = new AddDiskParameters(image.getDiskVmElementForVm(getVmId()), image);
    diskParameters.setStorageDomainId(getStorageDomainId());
    diskParameters.setParentCommand(getActionType());
    diskParameters.setParentParameters(getParameters());
    diskParameters.setShouldRemainIllegalOnFailedExecution(true);
    diskParameters.setStorageDomainId(getParameters().getDestDomainId());
    diskParameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    return diskParameters;
}
#end_block

#method_before
protected CommandContext createConversionStepContext(StepEnum step) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = Collections.singletonMap(VdcObjectType.VM.name().toLowerCase(), getVmName());
        Step removeVmStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), step, ExecutionMessageDirector.resolveStepMessage(step, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(removeVmStep);
        ctx.setMonitored(true);
        commandCtx = cloneContext().withoutCompensationContext().withExecutionContext(ctx).withoutLock();
    } catch (RuntimeException e) {
        log.error("Failed to create command context of converting VM '{}': {}", getVmName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#method_after
protected CommandContext createConversionStepContext(StepEnum step) {
    CommandContext commandCtx = null;
    try {
        Map<String, String> values = Collections.singletonMap(VdcObjectType.VM.name().toLowerCase(), getVmName());
        Step conversionStep = executionHandler.addSubStep(getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), step, ExecutionMessageDirector.resolveStepMessage(step, values));
        ExecutionContext ctx = new ExecutionContext();
        ctx.setStep(conversionStep);
        ctx.setMonitored(true);
        commandCtx = cloneContext().withoutCompensationContext().withExecutionContext(ctx).withoutLock();
    } catch (RuntimeException e) {
        log.error("Failed to create command context of converting VM '{}': {}", getVmName(), e.getMessage());
        log.debug("Exception", e);
    }
    return commandCtx;
}
#end_block

#method_before
public void postProcessRefresh(boolean succeeded) {
    try {
        try {
            moveVDSToMaintenanceIfNeeded();
            saveDataToDb();
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
        } finally {
            // save all data to db
            saveDataToDb();
        }
    } catch (Throwable t) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", t);
        log.debug("Exception", t);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#method_after
public void postProcessRefresh(boolean succeeded) {
    try {
        try {
            moveVDSToMaintenanceIfNeeded();
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
        } finally {
            // save all data to db
            saveDataToDb();
        }
    } catch (Throwable t) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", t);
        log.debug("Exception", t);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#end_block

#method_before
private void refreshCapabilities() {
    // refresh dynamic data
    vdsManager.refreshCapabilities(vds, new RefreshCapabilitiesCallback());
}
#method_after
private void refreshCapabilities() {
    // refresh dynamic data
    vdsManager.refreshCapabilities(vds, new RefreshCapabilitiesCallback(vds));
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
        VDSStatus refreshReturnStatus = vdsManager.continueRefreshCapabilities(processHardwareNeededAtomic, vds, oldVds, (VDSReturnValue) response.get("result"));
        continueRefreshCapabilities(refreshReturnStatus, processHardwareNeededAtomic);
        refreshVdsRunTimeInfo(false);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
        VDSStatus refreshReturnStatus = vdsManager.processRefreshCapabilitiesResponse(processHardwareNeededAtomic, vds, oldVds, (VDSReturnValue) response.get("result"));
        processRefreshCapabilitiesResponse(refreshReturnStatus, processHardwareNeededAtomic);
        refreshVdsRunTimeInfo(false);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        continueRefreshVdsStats((VDSReturnValue) response.get("result"));
        refreshVdsRunTimeInfo(true);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        processRefreshVdsStatsResponse((VDSReturnValue) response.get("result"));
        refreshVdsRunTimeInfo(true);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#end_block

#method_before
private boolean beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    boolean executingAsyncVdsCommand = false;
    if (vdsManager.getbeforeFirstRefresh()) {
        executingAsyncVdsCommand = true;
        vdsManager.refreshCapabilities(vds, new BeforeFirstRefreshTreatmentCallback());
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return false;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
    return executingAsyncVdsCommand;
}
#method_after
private boolean beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    boolean executingAsyncVdsCommand = false;
    if (vdsManager.getbeforeFirstRefresh()) {
        executingAsyncVdsCommand = true;
        vdsManager.refreshCapabilities(vds, new BeforeFirstRefreshTreatmentCallback(vds));
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return false;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
    return executingAsyncVdsCommand;
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    boolean succeeded = true;
    try {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        vdsManager.continueRefreshCapabilities(processHardwareCapsNeededTemp, vds, oldVds, (VDSReturnValue) response.get("result"));
        continueBeforeFirstRefreshTreatment(processHardwareCapsNeededTemp);
        if (vdsManager.isTimeToRefreshStatistics()) {
            saveVdsDynamic |= refreshCommitedMemory(vds, vdsManager.getLastVmsList(), resourceManager);
        }
    } catch (Throwable t) {
        succeeded = false;
        onFailure(t);
    } finally {
        if (succeeded) {
            postProcessRefresh(true);
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    boolean succeeded = true;
    try {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        vdsManager.processRefreshCapabilitiesResponse(processHardwareCapsNeededTemp, vds, oldVds, (VDSReturnValue) response.get("result"));
        processBeforeFirstRefreshTreatmentResponse(processHardwareCapsNeededTemp);
        if (vdsManager.isTimeToRefreshStatistics()) {
            saveVdsDynamic |= refreshCommitedMemory(vds, vdsManager.getLastVmsList(), resourceManager);
        }
    } catch (Throwable t) {
        succeeded = false;
        onFailure(t);
    } finally {
        if (succeeded) {
            postProcessRefresh(true);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    try {
        synchronized (this) {
            if (succeeded) {
                unrespondedAttempts.set(0);
                setLastUpdate();
                Guid storagePoolId = null;
                ArrayList<VDSDomainsData> domainsList = null;
                try {
                    hostMonitoring.afterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                        storagePoolId = cachedVds.getStoragePoolId();
                        domainsList = cachedVds.getDomains();
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
                // synchronized part of code
                if (domainsList != null) {
                    updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
                }
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        continueRefreshCapabilities(new AtomicBoolean(), vds, oldVDS, (VDSReturnValue) response.get("result"));
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        processRefreshCapabilitiesResponse(new AtomicBoolean(), vds, vds.clone(), (VDSReturnValue) response.get("result"));
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
private void updateIteration() {
    if (refreshIteration.equals(NUMBER_HOST_REFRESHES_BEFORE_SAVE)) {
        refreshIteration.set(1);
    } else {
        refreshIteration.incrementAndGet();
    }
}
#method_after
private void updateIteration() {
    if (isTimeToRefreshStatistics()) {
        refreshIteration.set(1);
    } else {
        refreshIteration.incrementAndGet();
    }
}
#end_block

#method_before
public boolean isTimeToRefreshStatistics() {
    return refreshIteration.equals(NUMBER_HOST_REFRESHES_BEFORE_SAVE);
}
#method_after
public boolean isTimeToRefreshStatistics() {
    return refreshIteration.get() == NUMBER_HOST_REFRESHES_BEFORE_SAVE;
}
#end_block

#method_before
public void afterRefreshTreatment(boolean succeeded) {
    try {
        synchronized (this) {
            if (succeeded) {
                unrespondedAttempts.set(0);
                setLastUpdate();
                Guid storagePoolId = null;
                ArrayList<VDSDomainsData> domainsList = null;
                try {
                    hostMonitoring.afterRefreshTreatment();
                    // the storage anymore (so there is no sense in updating the domains list in that case).
                    if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                        storagePoolId = cachedVds.getStoragePoolId();
                        domainsList = cachedVds.getDomains();
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
                // synchronized part of code
                if (domainsList != null) {
                    updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
                }
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#method_after
public void afterRefreshTreatment(boolean succeeded) {
    if (!succeeded) {
        lockManager.releaseLock(monitoringLock);
        return;
    }
    try {
        synchronized (this) {
            unrespondedAttempts.set(0);
            setLastUpdate();
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            try {
                hostMonitoring.afterRefreshTreatment();
                // the storage anymore (so there is no sense in updating the domains list in that case).
                if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                    storagePoolId = cachedVds.getStoragePoolId();
                    domainsList = cachedVds.getDomains();
                }
                hostMonitoring = null;
            } catch (IRSErrorException ex) {
                logAfterRefreshFailureMessage(ex);
                if (log.isDebugEnabled()) {
                    logException(ex);
                }
            } catch (RuntimeException ex) {
                logAfterRefreshFailureMessage(ex);
                logException(ex);
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        }
    } catch (Exception e) {
        log.error("Timer update runtime info failed. Exception:", ExceptionUtils.getRootCauseMessage(e));
        log.debug("Exception:", e);
    } finally {
        lockManager.releaseLock(monitoringLock);
    }
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        continueRefreshCapabilities(new AtomicBoolean(), vds, oldVDS, (VDSReturnValue) response.get("result"));
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        processRefreshCapabilitiesResponse(new AtomicBoolean(), vds, vds.clone(), (VDSReturnValue) response.get("result"));
    } catch (Throwable t) {
        onFailure(t);
    } finally {
        if (vds != null) {
            updateDynamicData(vds.getDynamicData());
            updateNumaData(vds);
            // Update VDS after testing special hardware capabilities
            monitoringStrategy.processHardwareCapabilities(vds);
            // Always check VdsVersion
            resourceManager.getEventListener().handleVdsVersion(vds.getId());
        }
    }
}
#end_block

#method_before
public void postProcessRefresh(boolean succeeded) {
    try {
        try {
            moveVDSToMaintenanceIfNeeded();
            saveDataToDb();
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
        } finally {
            // save all data to db
            saveDataToDb();
        }
    } catch (Throwable t) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", t);
        log.debug("Exception", t);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#method_after
public void postProcessRefresh(boolean succeeded) {
    try {
        try {
            moveVDSToMaintenanceIfNeeded();
            if (firstStatus != vds.getStatus() && vds.getStatus() == VDSStatus.Up) {
                // use this lock in order to allow only one host updating DB and
                // calling UpEvent in a time
                vdsManager.cancelRecoveryJob();
                log.debug("Host '{}' ({}) firing up event.", vds.getName(), vds.getId());
                vdsManager.setIsSetNonOperationalExecuted(!getVdsEventListener().vdsUpEvent(vds));
            }
        } finally {
            // save all data to db
            saveDataToDb();
        }
    } catch (Throwable t) {
        logFailureMessage("ResourceManager::refreshVdsRunTimeInfo:", t);
        log.debug("Exception", t);
    } finally {
        vdsManager.afterRefreshTreatment(succeeded);
    }
}
#end_block

#method_before
private void refreshCapabilities() {
    // refresh dynamic data
    vdsManager.refreshCapabilities(vds, new RefreshCapabilitiesCallback());
}
#method_after
private void refreshCapabilities() {
    // refresh dynamic data
    vdsManager.refreshCapabilities(vds, new RefreshCapabilitiesCallback(vds));
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    try {
        final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
        VDSStatus refreshReturnStatus = vdsManager.continueRefreshCapabilities(processHardwareNeededAtomic, vds, oldVds, (VDSReturnValue) response.get("result"));
        continueRefreshCapabilities(refreshReturnStatus, processHardwareNeededAtomic);
        refreshVdsRunTimeInfo(false);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    try {
        final AtomicBoolean processHardwareNeededAtomic = new AtomicBoolean();
        VDSStatus refreshReturnStatus = vdsManager.processRefreshCapabilitiesResponse(processHardwareNeededAtomic, vds, oldVds, (VDSReturnValue) response.get("result"));
        processRefreshCapabilitiesResponse(refreshReturnStatus, processHardwareNeededAtomic);
        refreshVdsRunTimeInfo(false);
    } catch (Throwable t) {
        onFailure(t);
    }
}
#end_block

#method_before
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, host='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = resourceManager.runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    continueRefreshVdsStats(statsReturnValue);
}
#method_after
public void refreshVdsStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vdsManager::refreshVdsStats entered, host='{}'({})", vds.getName(), vds.getId());
    }
    // get statistics data, images checks and vm_count data (dynamic)
    fetchHostInterfaces();
    VDSReturnValue statsReturnValue = resourceManager.runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
    processRefreshVdsStatsResponse(statsReturnValue);
}
#end_block

#method_before
private boolean beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    boolean executingAsyncVdsCommand = false;
    if (vdsManager.getbeforeFirstRefresh()) {
        executingAsyncVdsCommand = true;
        vdsManager.refreshCapabilities(vds, new BeforeFirstRefreshTreatmentCallback());
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return false;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
    return executingAsyncVdsCommand;
}
#method_after
private boolean beforeFirstRefreshTreatment(boolean isVdsUpOrGoingToMaintenance) {
    boolean executingAsyncVdsCommand = false;
    if (vdsManager.getbeforeFirstRefresh()) {
        executingAsyncVdsCommand = true;
        vdsManager.refreshCapabilities(vds, new BeforeFirstRefreshTreatmentCallback(vds));
    } else if (isVdsUpOrGoingToMaintenance || vds.getStatus() == VDSStatus.Error) {
        return false;
    }
    // show status UP in audit only when InitVdsOnUpCommand finished successfully
    if (vds.getStatus() != VDSStatus.Up) {
        AuditLogable logable = createAuditLogableForHost();
        logable.addCustomValue("HostStatus", vds.getStatus().toString());
        auditLog(logable, AuditLogType.VDS_DETECTED);
    }
    return executingAsyncVdsCommand;
}
#end_block

#method_before
@Override
public void onResponse(Map<String, Object> response) {
    boolean succeeded = true;
    try {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        vdsManager.continueRefreshCapabilities(processHardwareCapsNeededTemp, vds, oldVds, (VDSReturnValue) response.get("result"));
        continueBeforeFirstRefreshTreatment(processHardwareCapsNeededTemp);
        if (vdsManager.isTimeToRefreshStatistics()) {
            saveVdsDynamic |= refreshCommitedMemory(vds, vdsManager.getLastVmsList(), resourceManager);
        }
    } catch (Throwable t) {
        succeeded = false;
        onFailure(t);
    } finally {
        if (succeeded) {
            postProcessRefresh(true);
        }
    }
}
#method_after
@Override
public void onResponse(Map<String, Object> response) {
    boolean succeeded = true;
    try {
        final AtomicBoolean processHardwareCapsNeededTemp = new AtomicBoolean();
        vdsManager.processRefreshCapabilitiesResponse(processHardwareCapsNeededTemp, vds, oldVds, (VDSReturnValue) response.get("result"));
        processBeforeFirstRefreshTreatmentResponse(processHardwareCapsNeededTemp);
        if (vdsManager.isTimeToRefreshStatistics()) {
            saveVdsDynamic |= refreshCommitedMemory(vds, vdsManager.getLastVmsList(), resourceManager);
        }
    } catch (Throwable t) {
        succeeded = false;
        onFailure(t);
    } finally {
        if (succeeded) {
            postProcessRefresh(true);
        }
    }
}
#end_block

#method_before
@Test
public void validateVmShareableDisk() {
    initStorageDomain(srcStorageId);
    DiskImage diskImage = initDiskImage(diskImageGroupId, diskImageId);
    diskImage.setShareable(true);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
}
#method_after
@Test
public void validateVmShareableDisk() {
    initStorageDomain(srcStorageId);
    initStorageDomain(dstStorageId);
    DiskImage diskImage = initDiskImage(diskImageGroupId, diskImageId);
    diskImage.setShareable(true);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
}
#end_block

#method_before
@Test
public void validateCantLiveMigrateToBackupDomain() {
    StorageDomain dstStorageDomain = initStorageDomain(srcStorageId);
    dstStorageDomain.setBackup(true);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_DISKS_ON_BACKUP_STORAGE);
}
#method_after
@Test
public void validateCantLiveMigrateToBackupDomain() {
    initStorageDomain(srcStorageId);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setBackup(true);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_DISKS_ON_BACKUP_STORAGE);
}
#end_block

#method_before
@Test
public void validateVmShareableDisk() {
    initStorageDomain(srcStorageId);
    DiskImage diskImage = initDiskImage(diskImageGroupId, diskImageId);
    diskImage.setShareable(true);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
}
#method_after
@Test
public void validateVmShareableDisk() {
    initStorageDomain(srcStorageId);
    initStorageDomain(dstStorageId);
    DiskImage diskImage = initDiskImage(diskImageGroupId, diskImageId);
    diskImage.setShareable(true);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISK_NOT_SUPPORTED);
}
#end_block

#method_before
@Test
public void validateInvalidDestinationDomain() {
    StorageDomain srcStorageDomain = initStorageDomain(srcStorageId);
    srcStorageDomain.setStatus(StorageDomainStatus.Active);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setStorageDomainType(StorageDomainType.ISO);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
}
#method_after
@Test
public void validateInvalidDestinationDomain() {
    initStorageDomain(srcStorageId);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setStorageDomainType(StorageDomainType.ISO);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
}
#end_block

#method_before
@Test
public void validateCantLiveMigrateToBackupDomain() {
    StorageDomain dstStorageDomain = initStorageDomain(srcStorageId);
    dstStorageDomain.setBackup(true);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_DISKS_ON_BACKUP_STORAGE);
}
#method_after
@Test
public void validateCantLiveMigrateToBackupDomain() {
    initStorageDomain(srcStorageId);
    StorageDomain dstStorageDomain = initStorageDomain(dstStorageId);
    dstStorageDomain.setBackup(true);
    initDiskImage(diskImageGroupId, diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageGroupId);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_DISKS_ON_BACKUP_STORAGE);
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        StorageDomain storageDomain = storageDomainDao.get(newDiskImage.getStorageIds().get(0));
        if (storageDomain.getStorageType().isBlockDomain()) {
            if (newDiskImage.getSize() / BYTES_IN_GB > Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_BIGGER_THAN_MAXIMUM, ReplacementUtils.createSetVariableString("MaxBlockDiskSize", Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize)));
            }
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!ActionUtils.canExecute(Collections.singletonList(vm), VM.class, ActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        StorageDomain storageDomain = storageDomainDao.get(newDiskImage.getStorageIds().get(0));
        if (storageDomain.getStorageType().isBlockDomain()) {
            Integer maxBlockDiskSize = Config.<Integer>getValue(ConfigValues.MaxBlockDiskSize);
            if (newDiskImage.getSize() / BYTES_IN_GB > maxBlockDiskSize) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_MAX_SIZE_EXCEEDED, String.format("$max_disk_size %1$s", maxBlockDiskSize));
            }
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!ActionUtils.canExecute(Collections.singletonList(vm), VM.class, ActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
private String renderGibibyteSize(long size) {
    long sizeInGB = (unit == SizeUnit.GiB) ? size : SizeConverter.convert(size, unit, SizeUnit.GiB).longValue();
    // $NON-NLS-1$
    return messages.gibibytes(sizeInGB >= 1 ? String.valueOf(sizeInGB) : "< 1");
}
#method_after
private String renderGibibyteSize(long size) {
    long sizeInGiB = (unit == SizeUnit.GiB) ? size : SizeConverter.convert(size, unit, SizeUnit.GiB).longValue();
    // $NON-NLS-1$
    return messages.gibibytes(sizeInGiB >= 1 ? String.valueOf(sizeInGiB) : "< 1");
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        serviceLoader.load(PmHealthCheckManager.class);
        serviceLoader.load(EngineBackupAwarenessManager.class);
        serviceLoader.load(DataCenterCompatibilityChecker.class);
        serviceLoader.load(ResourceManager.class);
        serviceLoader.load(HostDeviceManager.class);
        serviceLoader.load(IrsProxyManager.class);
        serviceLoader.load(OvfDataUpdater.class);
        StoragePoolStatusHandler.init();
        serviceLoader.load(GlusterJobsManager.class);
        resourceManager.get().scheduleJobsForHosts();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        serviceLoader.load(SchedulingManager.class);
        sessionDataContainer.cleanupEngineSessionsOnStartup();
        serviceLoader.load(DwhHeartBeat.class);
        serviceLoader.load(CommandsRepository.class);
        serviceLoader.load(AsyncTaskManager.class);
        serviceLoader.load(CommandCoordinatorUtil.class);
        serviceLoader.load(CommandCallbacksPoller.class);
        serviceLoader.load(CommandEntityCleanupManager.class);
        commandsRepository.get().handleUnmanagedCommands();
        if (Config.<Boolean>getValue(ConfigValues.AffinityRulesEnforcementManagerEnabled)) {
            serviceLoader.load(AffinityRulesEnforcementManager.class);
        }
        serviceLoader.load(CertificationValidityChecker.class);
        serviceLoader.load(HostUpdatesCheckerService.class);
        serviceLoader.load(IPTablesDeprecationNotifier.class);
        serviceLoader.load(ExternalNetworkSyncService.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#method_after
@Override
@PostConstruct
public void create() {
    try {
        // This must be done before starting to sample the hosts status from VDSM since the sampling will turn such host from Reboot to NonResponsive
        serviceLoader.load(PmHealthCheckManager.class);
        serviceLoader.load(EngineBackupAwarenessManager.class);
        serviceLoader.load(DataCenterCompatibilityChecker.class);
        serviceLoader.load(ResourceManager.class);
        serviceLoader.load(HostDeviceManager.class);
        serviceLoader.load(IrsProxyManager.class);
        serviceLoader.load(OvfDataUpdater.class);
        StoragePoolStatusHandler.init();
        serviceLoader.load(GlusterJobsManager.class);
        resourceManager.get().scheduleJobsForHosts();
        try {
            log.info("Init VM custom properties utilities");
            VmPropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of vm custom properties failed.", e);
        }
        try {
            log.info("Init device custom properties utilities");
            DevicePropertiesUtils.getInstance().init();
        } catch (InitializationException e) {
            log.error("Initialization of device custom properties failed.", e);
        }
        serviceLoader.load(SchedulingManager.class);
        sessionDataContainer.cleanupEngineSessionsOnStartup();
        serviceLoader.load(DwhHeartBeat.class);
        commandsRepository.get().handleUnmanagedCommands();
        serviceLoader.load(AsyncTaskManager.class);
        serviceLoader.load(CommandCoordinatorUtil.class);
        serviceLoader.load(CommandCallbacksPoller.class);
        serviceLoader.load(CommandEntityCleanupManager.class);
        if (Config.<Boolean>getValue(ConfigValues.AffinityRulesEnforcementManagerEnabled)) {
            serviceLoader.load(AffinityRulesEnforcementManager.class);
        }
        serviceLoader.load(CertificationValidityChecker.class);
        serviceLoader.load(HostUpdatesCheckerService.class);
        serviceLoader.load(IPTablesDeprecationNotifier.class);
        serviceLoader.load(ExternalNetworkSyncService.class);
    } catch (Exception ex) {
        log.error("Failed to initialize backend", ex);
        throw ex;
    }
}
#end_block

#method_before
public void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.get().updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).map(x -> retrieveCommand(x.getId())).filter(Objects::nonNull).forEach(CommandBase::reacquireLocks);
}
#method_after
public void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).map(x -> retrieveCommand(x.getId())).filter(Objects::nonNull).forEach(CommandBase::reacquireLocks);
}
#end_block

#method_before
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    initChildHierarchy();
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    persistCommand(cmdEntity);
    if (cmdContext != null) {
        contextsCache.get().put(cmdEntity.getId(), cmdContext);
    }
}
#method_after
public void persistCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    initChildHierarchy();
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    persistCommand(cmdEntity);
    if (cmdContext != null) {
        contextsCache.put(cmdEntity.getId(), cmdContext);
    }
}
#end_block

#method_before
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get().get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallbackNotified(existingCmdEntity.isCallbackNotified());
    }
    commandsCache.get().put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallbackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && commandsCache.get().get(cmdEntity.getParentCommandId()) != null && commandsCache.get().get(cmdEntity.getParentCommandId()).isCallbackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallbackNotified()) {
            addToCallbackMap(cmdEntity);
        }
    }
}
#method_after
public void persistCommand(CommandEntity cmdEntity) {
    if (Guid.isNullOrEmpty(cmdEntity.getId())) {
        return;
    }
    CommandEntity existingCmdEntity = commandsCache.get(cmdEntity.getId());
    if (existingCmdEntity != null) {
        cmdEntity.setExecuted(existingCmdEntity.isExecuted());
        cmdEntity.setCallbackNotified(existingCmdEntity.isCallbackNotified());
    }
    commandsCache.put(cmdEntity);
    // check if callback is enabled or if parent command has callback enabled
    if (cmdEntity.isCallbackEnabled() || (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && commandsCache.get(cmdEntity.getParentCommandId()) != null && commandsCache.get(cmdEntity.getParentCommandId()).isCallbackEnabled())) {
        buildCmdHierarchy(cmdEntity);
        if (!cmdEntity.isCallbackNotified()) {
            addToCallbackMap(cmdEntity);
        }
    }
}
#end_block

#method_before
public CommandContext retrieveCommandContext(Guid cmdId) {
    return contextsCache.get().get(cmdId);
}
#method_after
public CommandContext retrieveCommandContext(Guid cmdId) {
    return contextsCache.get(cmdId);
}
#end_block

#method_before
public CommandBase<?> retrieveCommand(Guid commandId) {
    return retrieveCommand(commandsCache.get().get(commandId), retrieveCommandContext(commandId));
}
#method_after
public CommandBase<?> retrieveCommand(Guid commandId) {
    return retrieveCommand(commandsCache.get(commandId), retrieveCommandContext(commandId));
}
#end_block

#method_before
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsCache.get().updateCommandStatus(commandId, status);
}
#method_after
public void updateCommandStatus(final Guid commandId, final CommandStatus status) {
    commandsCache.updateCommandStatus(commandId, status);
}
#end_block

#method_before
public CommandStatus getCommandStatus(final Guid commandId) {
    CommandEntity cmdEntity = commandsCache.get().get(commandId);
    if (cmdEntity != null) {
        return cmdEntity.getCommandStatus();
    }
    return CommandStatus.UNKNOWN;
}
#method_after
public CommandStatus getCommandStatus(final Guid commandId) {
    CommandEntity cmdEntity = commandsCache.get(commandId);
    if (cmdEntity != null) {
        return cmdEntity.getCommandStatus();
    }
    return CommandStatus.UNKNOWN;
}
#end_block

#method_before
public CommandEntity getCommandEntity(Guid commandId) {
    return Guid.isNullOrEmpty(commandId) ? null : commandsCache.get().get(commandId);
}
#method_after
public CommandEntity getCommandEntity(Guid commandId) {
    return Guid.isNullOrEmpty(commandId) ? null : commandsCache.get(commandId);
}
#end_block

#method_before
public void updateCallbackNotified(final Guid commandId) {
    commandsCache.get().updateCallbackNotified(commandId);
}
#method_after
public void updateCallbackNotified(final Guid commandId) {
    commandsCache.updateCallbackNotified(commandId);
}
#end_block

#method_before
public List<CommandEntity> getCommands(boolean onlyWithCallbackEnabled) {
    List<CommandEntity> cmdEntities = new ArrayList<>();
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.get().keySet()) {
        cmdEntity = commandsCache.get().get(cmdId);
        if (!onlyWithCallbackEnabled || commandsCache.get().get(cmdId).isCallbackEnabled()) {
            cmdEntities.add(cmdEntity);
        }
    }
    return cmdEntities;
}
#method_after
public List<CommandEntity> getCommands(boolean onlyWithCallbackEnabled) {
    List<CommandEntity> cmdEntities = new ArrayList<>();
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.keySet()) {
        cmdEntity = commandsCache.get(cmdId);
        if (!onlyWithCallbackEnabled || commandsCache.get(cmdId).isCallbackEnabled()) {
            cmdEntities.add(cmdEntity);
        }
    }
    return cmdEntities;
}
#end_block

#method_before
public void removeCommand(Guid commandId) {
    commandsCache.get().remove(commandId);
    contextsCache.get().remove(commandId);
    updateCmdHierarchy(commandId);
}
#method_after
public void removeCommand(Guid commandId) {
    commandsCache.remove(commandId);
    contextsCache.remove(commandId);
    updateCmdHierarchy(commandId);
}
#end_block

#method_before
public void removeAllCommandsBeforeDate(final DateTime cutoff) {
    commandsCache.get().removeAllCommandsBeforeDate(cutoff);
    synchronized (LOCK) {
        childHierarchyInitialized = false;
    }
}
#method_after
public void removeAllCommandsBeforeDate(final DateTime cutoff) {
    commandsCache.removeAllCommandsBeforeDate(cutoff);
    synchronized (LOCK) {
        childHierarchyInitialized = false;
    }
}
#end_block

#method_before
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    commandsCache.get().persistCommandAssociatedEntities(cmdAssociatedEntities);
}
#method_after
public void persistCommandAssociatedEntities(Collection<CommandAssociatedEntity> cmdAssociatedEntities) {
    commandsCache.persistCommandAssociatedEntities(cmdAssociatedEntities);
}
#end_block

#method_before
public List<CommandEntity> getChildCmdsByParentCmdId(Guid cmdId) {
    return commandsCache.get().getChildCmdsByParentCmdId(cmdId);
}
#method_after
public List<CommandEntity> getChildCmdsByParentCmdId(Guid cmdId) {
    return commandsCache.getChildCmdsByParentCmdId(cmdId);
}
#end_block

#method_before
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return commandsCache.get().getCommandIdsByEntityId(entityId);
}
#method_after
public List<Guid> getCommandIdsByEntityId(Guid entityId) {
    return commandsCache.getCommandIdsByEntityId(entityId);
}
#end_block

#method_before
public List<Guid> getCommandIdsBySessionSeqId(long engineSessionSeqId) {
    List<Guid> cmdIds = new ArrayList<>();
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.get().keySet()) {
        cmdEntity = commandsCache.get().get(cmdId);
        if (cmdEntity != null && cmdEntity.getEngineSessionSeqId() != SsoSessionUtils.EMPTY_SESSION_SEQ_ID && cmdEntity.getEngineSessionSeqId() == engineSessionSeqId) {
            cmdIds.add(cmdId);
        }
    }
    return cmdIds;
}
#method_after
public List<Guid> getCommandIdsBySessionSeqId(long engineSessionSeqId) {
    List<Guid> cmdIds = new ArrayList<>();
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.keySet()) {
        cmdEntity = commandsCache.get(cmdId);
        if (cmdEntity != null && cmdEntity.getEngineSessionSeqId() != SsoSessionUtils.EMPTY_SESSION_SEQ_ID && cmdEntity.getEngineSessionSeqId() == engineSessionSeqId) {
            cmdIds.add(cmdId);
        }
    }
    return cmdIds;
}
#end_block

#method_before
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return commandsCache.get().getCommandAssociatedEntities(cmdId);
}
#method_after
public List<CommandAssociatedEntity> getCommandAssociatedEntities(Guid cmdId) {
    return commandsCache.getCommandAssociatedEntities(cmdId);
}
#end_block

#method_before
public void updateCommandData(Guid commandId, Map<String, Serializable> data) {
    commandsCache.get().updateCommandData(commandId, data);
}
#method_after
public void updateCommandData(Guid commandId, Map<String, Serializable> data) {
    commandsCache.updateCommandData(commandId, data);
}
#end_block

#method_before
public void updateCommandExecuted(Guid commandId) {
    commandsCache.get().updateCommandExecuted(commandId);
}
#method_after
public void updateCommandExecuted(Guid commandId) {
    commandsCache.updateCommandExecuted(commandId);
}
#end_block

#method_before
public boolean hasCommandEntitiesWithRootCommandId(Guid rootCommandId) {
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.get().keySet()) {
        cmdEntity = commandsCache.get().get(cmdId);
        if (cmdEntity != null && !Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && !cmdEntity.getRootCommandId().equals(cmdId) && cmdEntity.getRootCommandId().equals(rootCommandId)) {
            return true;
        }
    }
    return false;
}
#method_after
public boolean hasCommandEntitiesWithRootCommandId(Guid rootCommandId) {
    CommandEntity cmdEntity;
    for (Guid cmdId : commandsCache.keySet()) {
        cmdEntity = commandsCache.get(cmdId);
        if (cmdEntity != null && !Guid.isNullOrEmpty(cmdEntity.getRootCommandId()) && !cmdEntity.getRootCommandId().equals(cmdId) && cmdEntity.getRootCommandId().equals(rootCommandId)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private Optional<BalanceResult> getBalance(FindVmAndDestinations findVmAndDestinations, final List<VDS> overUtilizedHosts, final List<VDS> underUtilizedHosts) {
    return findVmAndDestinations.invoke(overUtilizedHosts, underUtilizedHosts, getVmDao(), getVmStatisticsDao()).map(res -> new BalanceResult(res.getVmToMigrate().getId(), res.getDestinationHosts().stream().map(VDS::getId).collect(Collectors.toList()), res.getVmToMigrate().getRunOnVds()));
}
#method_after
private Optional<BalanceResult> getBalance(FindVmAndDestinations findVmAndDestinations, final List<VDS> overUtilizedHosts, final List<VDS> underUtilizedHosts) {
    return findVmAndDestinations.invoke(overUtilizedHosts, underUtilizedHosts, vmDao, vmStatisticsDao).map(res -> new BalanceResult(res.getVmToMigrate().getId(), res.getDestinationHosts().stream().map(VDS::getId).collect(Collectors.toList()), res.getVmToMigrate().getRunOnVds()));
}
#end_block

#method_before
protected List<VDS> getOverUtilizedCPUHosts(Collection<VDS> relevantHosts, final int highUtilization, final int cpuOverCommitDurationMinutes) {
    List<VDS> overUtilizedHosts = relevantHosts.stream().filter(p -> (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) >= highUtilization && p.getCpuOverCommitTimestamp() != null && (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes) && p.getVmCount() > 0).collect(Collectors.toList());
    if (overUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        Cluster cluster = getClusterDao().get(overUtilizedHosts.get(0).getClusterId());
        Collections.sort(overUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores()).reversed());
    }
    return overUtilizedHosts;
}
#method_after
protected List<VDS> getOverUtilizedCPUHosts(Collection<VDS> relevantHosts, final int highUtilization, final int cpuOverCommitDurationMinutes) {
    List<VDS> overUtilizedHosts = relevantHosts.stream().filter(p -> (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) >= highUtilization && p.getCpuOverCommitTimestamp() != null && (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes) && p.getVmCount() > 0).collect(Collectors.toList());
    if (overUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        Cluster cluster = clusterDao.get(overUtilizedHosts.get(0).getClusterId());
        Collections.sort(overUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores(), slaValidator).reversed());
    }
    return overUtilizedHosts;
}
#end_block

#method_before
protected List<VDS> getUnderUtilizedCPUHosts(Collection<VDS> relevantHosts, final int lowUtilization, final int minVmCount, final int cpuOverCommitDurationMinutes) {
    List<VDS> underUtilizedHosts = relevantHosts.stream().filter(p -> (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) < lowUtilization && p.getVmCount() >= minVmCount && (p.getCpuOverCommitTimestamp() == null || (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes))).collect(Collectors.toList());
    if (underUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        Cluster cluster = getClusterDao().get(underUtilizedHosts.get(0).getClusterId());
        Collections.sort(underUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores()));
    }
    return underUtilizedHosts;
}
#method_after
protected List<VDS> getUnderUtilizedCPUHosts(Collection<VDS> relevantHosts, final int lowUtilization, final int minVmCount, final int cpuOverCommitDurationMinutes) {
    List<VDS> underUtilizedHosts = relevantHosts.stream().filter(p -> (p.getUsageCpuPercent() + calcSpmCpuConsumption(p)) < lowUtilization && p.getVmCount() >= minVmCount && (p.getCpuOverCommitTimestamp() == null || (getTime().getTime() - p.getCpuOverCommitTimestamp().getTime()) >= TimeUnit.MINUTES.toMillis(cpuOverCommitDurationMinutes))).collect(Collectors.toList());
    if (underUtilizedHosts.size() > 1) {
        // Assume all hosts belong to the same cluster
        Cluster cluster = clusterDao.get(underUtilizedHosts.get(0).getClusterId());
        Collections.sort(underUtilizedHosts, new VdsCpuUsageComparator(cluster != null && cluster.getCountThreadsAsCores(), slaValidator));
    }
    return underUtilizedHosts;
}
#end_block

#method_before
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    // If Vm in Paused mode - no additional memory allocation needed
    if (vm.getStatus() == VMStatus.Paused) {
        return hosts;
    }
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    boolean vmNumaPinned = isVmNumaPinned(vmNumaNodes);
    List<VDS> filteredList = new ArrayList<>();
    for (VDS vds : hosts) {
        // Check physical memory needed to start / receive the VM
        // This is probably not needed for all VMs, but QEMU might attempt full
        // allocation without provoked and fail if there is not enough memory
        int pendingRealMemory = PendingMemory.collectForHost(getPendingResourceManager(), vds.getId());
        if (!SlaValidator.getInstance().hasPhysMemoryToRunVM(vds, vm, pendingRealMemory)) {
            Long hostAvailableMem = vds.getMemFree() + vds.getSwapFree();
            log.debug("Host '{}' has insufficient memory to run the VM. Only {} MB of physical memory + swap are available.", vds.getName(), hostAvailableMem);
            messages.addMessage(vds.getId(), String.format("$availableMem %1$d", hostAvailableMem));
            messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
            continue;
        }
        // * there isn't enough memory for pinned vNode in pNode
        if (vm.getNumaTuneMode() == NumaTuneMode.STRICT && vmNumaPinned && (!vds.isNumaSupport() || !canVmNumaPinnedToVds(vm, vmNumaNodes, vds))) {
            log.debug("Host '{}' cannot accommodate memory of VM's pinned virtual NUMA nodes within host's physical NUMA nodes", vds.getName());
            messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_MEMORY_PINNED_NUMA.toString());
            continue;
        }
        filteredList.add(vds);
    }
    List<VDS> resultList = new ArrayList<>();
    List<VDS> overcommitFailed = new ArrayList<>();
    boolean canDelay = false;
    for (VDS vds : filteredList) {
        // Otherwise, pending memory will not change by waiting.
        if (vds.getPendingVmemSize() > 0) {
            canDelay = true;
        }
        // Check logical memory using overcommit, pending and guaranteed memory rules
        if (SlaValidator.getInstance().hasOvercommitMemoryToRunVM(vds, vm)) {
            resultList.add(vds);
        } else {
            overcommitFailed.add(vds);
        }
    }
    // Wait a while, to see if pending memory was freed on some host
    if (canDelay && resultList.isEmpty()) {
        log.debug("Not enough memory on hosts. Delaying...");
        overcommitFailed.clear();
        runVmDelayer.delay(filteredList.stream().map(VDS::getId).collect(Collectors.toList()));
        for (VDS vds : filteredList) {
            // Refresh pending memory
            int pendingMemory = PendingOvercommitMemory.collectForHost(getPendingResourceManager(), vds.getId());
            vds.setPendingVmemSize(pendingMemory);
            // Check logical memory using overcommit, pending and guaranteed memory rules
            if (SlaValidator.getInstance().hasOvercommitMemoryToRunVM(vds, vm)) {
                resultList.add(vds);
            } else {
                overcommitFailed.add(vds);
            }
        }
    }
    for (VDS vds : overcommitFailed) {
        log.debug("Host '{}' is already too close to the memory overcommitment limit. It can only accept {} MB of additional memory load.", vds.getName(), vds.getMaxSchedulingMemory());
        messages.addMessage(vds.getId(), String.format("$availableMem %1$f", vds.getMaxSchedulingMemory()));
        messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
    }
    return resultList;
}
#method_after
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    // If Vm in Paused mode - no additional memory allocation needed
    if (vm.getStatus() == VMStatus.Paused) {
        return hosts;
    }
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    boolean vmNumaPinned = isVmNumaPinned(vmNumaNodes);
    List<VDS> filteredList = new ArrayList<>();
    for (VDS vds : hosts) {
        // Check physical memory needed to start / receive the VM
        // This is probably not needed for all VMs, but QEMU might attempt full
        // allocation without provoked and fail if there is not enough memory
        int pendingRealMemory = PendingMemory.collectForHost(getPendingResourceManager(), vds.getId());
        if (!slaValidator.hasPhysMemoryToRunVM(vds, vm, pendingRealMemory)) {
            Long hostAvailableMem = vds.getMemFree() + vds.getSwapFree();
            log.debug("Host '{}' has insufficient memory to run the VM. Only {} MB of physical memory + swap are available.", vds.getName(), hostAvailableMem);
            messages.addMessage(vds.getId(), String.format("$availableMem %1$d", hostAvailableMem));
            messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
            continue;
        }
        // * there isn't enough memory for pinned vNode in pNode
        if (vm.getNumaTuneMode() == NumaTuneMode.STRICT && vmNumaPinned && (!vds.isNumaSupport() || !canVmNumaPinnedToVds(vm, vmNumaNodes, vds))) {
            log.debug("Host '{}' cannot accommodate memory of VM's pinned virtual NUMA nodes within host's physical NUMA nodes", vds.getName());
            messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_MEMORY_PINNED_NUMA.toString());
            continue;
        }
        filteredList.add(vds);
    }
    List<VDS> resultList = new ArrayList<>();
    List<VDS> overcommitFailed = new ArrayList<>();
    boolean canDelay = false;
    for (VDS vds : filteredList) {
        // Otherwise, pending memory will not change by waiting.
        if (vds.getPendingVmemSize() > 0) {
            canDelay = true;
        }
        // Check logical memory using overcommit, pending and guaranteed memory rules
        if (slaValidator.hasOvercommitMemoryToRunVM(vds, vm)) {
            resultList.add(vds);
        } else {
            overcommitFailed.add(vds);
        }
    }
    // Wait a while, to see if pending memory was freed on some host
    if (canDelay && resultList.isEmpty()) {
        log.debug("Not enough memory on hosts. Delaying...");
        overcommitFailed.clear();
        runVmDelayer.delay(filteredList.stream().map(VDS::getId).collect(Collectors.toList()));
        for (VDS vds : filteredList) {
            // Refresh pending memory
            int pendingMemory = PendingOvercommitMemory.collectForHost(getPendingResourceManager(), vds.getId());
            vds.setPendingVmemSize(pendingMemory);
            // Check logical memory using overcommit, pending and guaranteed memory rules
            if (slaValidator.hasOvercommitMemoryToRunVM(vds, vm)) {
                resultList.add(vds);
            } else {
                overcommitFailed.add(vds);
            }
        }
    }
    for (VDS vds : overcommitFailed) {
        log.debug("Host '{}' is already too close to the memory overcommitment limit. It can only accept {} MB of additional memory load.", vds.getName(), vds.getMaxSchedulingMemory());
        messages.addMessage(vds.getId(), String.format("$availableMem %1$.0f", vds.getMaxSchedulingMemory()));
        messages.addMessage(vds.getId(), EngineMessage.VAR__DETAIL__NOT_ENOUGH_MEMORY.toString());
    }
    return resultList;
}
#end_block

#method_before
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    if (hosts == null || hosts.isEmpty()) {
        return null;
    }
    List<VDS> toRemoveHostList = new ArrayList<>();
    List<VmNetworkInterface> vmNICs = vmNetworkInterfaceDao.getAllForVm(vm.getId());
    Guid clusterId = hosts.get(0).getClusterId();
    List<Network> clusterNetworks = networkDao.getAllForCluster(clusterId);
    Map<String, Network> networksByName = Entities.entitiesByName(clusterNetworks);
    Map<Guid, List<String>> hostNics = interfaceDao.getHostNetworksByCluster(clusterId);
    Network displayNetwork = NetworkUtils.getDisplayNetwork(clusterNetworks);
    Map<Guid, VdsNetworkInterface> hostDisplayNics = getDisplayNics(displayNetwork);
    for (VDS host : hosts) {
        ValidationResult result = validateRequiredNetworksAvailable(host, vm, vmNICs, displayNetwork, networksByName, hostNics.get(host.getId()), hostDisplayNics.get(host.getId()));
        if (result.isValid()) {
            result = validatePassthroughVnics(vm.getId(), host, vmNICs);
        }
        if (!result.isValid()) {
            toRemoveHostList.add(host);
            messages.addMessages(host.getId(), result.getVariableReplacements());
            messages.addMessages(host.getId(), result.getMessagesAsStrings());
        }
    }
    hosts.removeAll(toRemoveHostList);
    return hosts;
}
#method_after
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    if (hosts == null || hosts.isEmpty()) {
        return Collections.emptyList();
    }
    List<VDS> toRemoveHostList = new ArrayList<>();
    List<VmNetworkInterface> vmNICs = vmNetworkInterfaceDao.getAllForVm(vm.getId());
    Guid clusterId = hosts.get(0).getClusterId();
    List<Network> clusterNetworks = networkDao.getAllForCluster(clusterId);
    Map<String, Network> networksByName = Entities.entitiesByName(clusterNetworks);
    Map<Guid, List<String>> hostNics = interfaceDao.getHostNetworksByCluster(clusterId);
    Network displayNetwork = NetworkUtils.getDisplayNetwork(clusterNetworks);
    Map<Guid, VdsNetworkInterface> hostDisplayNics = getDisplayNics(displayNetwork);
    for (VDS host : hosts) {
        ValidationResult result = validateRequiredNetworksAvailable(host, vm, vmNICs, displayNetwork, networksByName, hostNics.get(host.getId()), hostDisplayNics.get(host.getId()));
        if (result.isValid()) {
            result = validatePassthroughVnics(vm.getId(), host, vmNICs);
        }
        if (!result.isValid()) {
            toRemoveHostList.add(host);
            messages.addMessages(host.getId(), result.getVariableReplacements());
            messages.addMessages(host.getId(), result.getMessagesAsStrings());
        }
    }
    hosts.removeAll(toRemoveHostList);
    return hosts;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (shouldSkipCommandExecutionCached()) {
        setSucceeded(true);
        return;
    }
    executeVmCommand();
    if (shouldUpdateHostedEngineOvf() && getVm().isHostedEngine() && getSucceeded()) {
        updateHeOvf();
    }
}
#method_after
@Override
protected void executeCommand() {
    if (shouldSkipCommandExecutionCached()) {
        setSucceeded(true);
        return;
    }
    executeVmCommand();
    if (shouldUpdateHostedEngineOvf() && getVm() != null && getVm().isHostedEngine() && getSucceeded()) {
        updateHeOvf();
    }
}
#end_block

#method_before
protected List<ActionReturnValue> endActionOnDisks() {
    List<ActionReturnValue> returnValues = new ArrayList<>();
    for (ActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        ActionReturnValue returnValue = getBackend().endAction(p.getCommandType() == ActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        returnValues.add(returnValue);
    }
    return returnValues;
}
#method_after
protected List<ActionReturnValue> endActionOnDisks() {
    List<ActionReturnValue> returnValues = new ArrayList<>();
    for (ActionParametersBase p : getParametersForChildCommand()) {
        if (overrideChildCommandSuccess()) {
            p.setTaskGroupSuccess(getParameters().getTaskGroupSuccess());
        }
        ActionReturnValue returnValue = backend.endAction(p.getCommandType() == ActionType.Unknown ? getChildActionType() : p.getCommandType(), p, getContext().clone().withoutCompensationContext().withoutExecutionContext().withoutLock());
        returnValues.add(returnValue);
    }
    return returnValues;
}
#end_block

#method_before
protected ActionReturnValue attemptRollback(ActionType commandType, ActionParametersBase params, CommandContext context) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return getBackend().runInternalAction(commandType, params, context);
    }
    return new ActionReturnValue();
}
#method_after
protected ActionReturnValue attemptRollback(ActionType commandType, ActionParametersBase params, CommandContext context) {
    if (canPerformRollbackUsingCommand(commandType, params)) {
        params.setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        params.setTransactionScopeOption(TransactionScopeOption.RequiresNew);
        return backend.runInternalAction(commandType, params, context);
    }
    return new ActionReturnValue();
}
#end_block

#method_before
private void executeActionInTransactionScope() {
    registerRollbackHandler((TransactionRollbackListener) () -> {
        log.error("Transaction rolled-back for command '{}'.", CommandBase.this.getClass().getName());
        try {
            if (isQuotaDependant()) {
                rollbackQuota();
            }
        } catch (NullPointerException e) {
            log.error("RollbackQuota: failed (may be because quota is disabled)", e);
        }
        cancelTasks();
    });
    // rollback the transaction.
    if (!executeWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#method_after
private void executeActionInTransactionScope() {
    registerRollbackHandler((TransactionRollbackListener) () -> {
        log.error("Transaction rolled-back for command '{}'.", getClass().getName());
        try {
            if (isQuotaDependant()) {
                rollbackQuota();
            }
        } catch (NullPointerException e) {
            log.error("RollbackQuota: failed (may be because quota is disabled)", e);
        }
        cancelTasks();
    });
    // rollback the transaction.
    if (!executeWithoutTransaction()) {
        if (TransactionSupport.current() == null) {
            cancelTasks();
        }
        // we don't want to commit transaction here
        TransactionSupport.setRollbackOnly();
    }
}
#end_block

#method_before
protected ActionReturnValue runInternalAction(ActionType actionType, ActionParametersBase parameters) {
    return getBackend().runInternalAction(actionType, parameters, context.clone());
}
#method_after
protected ActionReturnValue runInternalAction(ActionType actionType, ActionParametersBase parameters) {
    return backend.runInternalAction(actionType, parameters, context.clone());
}
#end_block

#method_before
protected ActionReturnValue runInternalAction(ActionType actionType, ActionParametersBase parameters, CommandContext internalCommandContext) {
    return getBackend().runInternalAction(actionType, parameters, internalCommandContext);
}
#method_after
protected ActionReturnValue runInternalAction(ActionType actionType, ActionParametersBase parameters, CommandContext internalCommandContext) {
    return backend.runInternalAction(actionType, parameters, internalCommandContext);
}
#end_block

#method_before
protected List<ActionReturnValue> runInternalMultipleActions(ActionType actionType, List<ActionParametersBase> parameters) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone());
}
#method_after
protected List<ActionReturnValue> runInternalMultipleActions(ActionType actionType, List<ActionParametersBase> parameters) {
    return backend.runInternalMultipleActions(actionType, parameters, context.clone());
}
#end_block

#method_before
protected List<ActionReturnValue> runInternalMultipleActions(ActionType actionType, List<ActionParametersBase> parameters, ExecutionContext executionContext) {
    return getBackend().runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#method_after
protected List<ActionReturnValue> runInternalMultipleActions(ActionType actionType, List<ActionParametersBase> parameters, ExecutionContext executionContext) {
    return backend.runInternalMultipleActions(actionType, parameters, context.clone().withExecutionContext(executionContext));
}
#end_block

#method_before
protected QueryReturnValue runInternalQuery(QueryType type, QueryParametersBase queryParams) {
    return getBackend().runInternalQuery(type, queryParams, context.getEngineContext());
}
#method_after
protected QueryReturnValue runInternalQuery(QueryType type, QueryParametersBase queryParams) {
    return backend.runInternalQuery(type, queryParams, context.getEngineContext());
}
#end_block

#method_before
private static boolean canExecute(BusinessEntityWithStatus<?, ?> entity, Class type, ActionType action) {
    Set<ActionType> actions = _matrix.get(type).get(entity.getStatus());
    if (actions != null && actions.contains(action)) {
        return false;
    }
    return true;
}
#method_after
private static boolean canExecute(BusinessEntityWithStatus<?, ?> entity, Class type, ActionType action) {
    Set<ActionType> disallowedActions = _matrix.get(type).get(entity.getStatus());
    return disallowedActions == null || !disallowedActions.contains(action);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getNamesOfVms());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    List<VM> notDownVms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmList) {
        VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(map);
        if (vm != null) {
            vm.setOrigin(getParameters().getOriginType());
            if (vm.getOrigin() == OriginType.KVM) {
                if (!VmDeviceCommonUtils.hasCdDevice(vm.getStaticData())) {
                    VmDeviceCommonUtils.addCdDevice(vm.getStaticData());
                }
            }
            vms.add(vm);
            // identify vms not in Down status
            if (!vm.isDown()) {
                notDownVms.add(vm);
            }
        }
    }
    logNonDownVms(notDownVms);
    setReturnValue(vms);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    vmListReturn = getBroker().getExternalVmList(getParameters().getUrl(), getParameters().getUsername(), getParameters().getPassword(), getParameters().getNamesOfVms());
    proceedProxyReturnValue();
    List<VM> vms = new ArrayList<>();
    List<VM> notDownVms = new ArrayList<>();
    for (Map<String, Object> map : vmListReturn.vmList) {
        VM vm = VdsBrokerObjectsBuilder.buildVmsDataFromExternalProvider(map);
        if (vm != null) {
            vm.setOrigin(getParameters().getOriginType());
            if (vm.getOrigin() == OriginType.KVM) {
                if (VmDeviceCommonUtils.isVirtIoScsiDiskInterfaceExists(vm.getStaticData())) {
                    VmDeviceCommonUtils.addVirtIoScsiDevice(vm.getStaticData());
                }
                if (!VmDeviceCommonUtils.hasCdDevice(vm.getStaticData())) {
                    VmDeviceCommonUtils.addCdDevice(vm.getStaticData());
                }
            } else {
                // set default value in case of non KVM provider type
                // since VirtIO interface doesn't require having an appropriate controller
                // so validation will pass. This will anyway be overridden later by virt-v2v OVF.
                VmDeviceCommonUtils.setDiskInterfaceForVm(vm.getStaticData(), DiskInterface.VirtIO);
            }
            vms.add(vm);
            // identify vms not in Down status
            if (!vm.isDown()) {
                notDownVms.add(vm);
            }
        }
    }
    logNonDownVms(notDownVms);
    setReturnValue(vms);
}
#end_block

#method_before
private long getTransferSize(DiskImage image, Guid domainId) {
    if (getParameters().getTransferType() == TransferType.Download) {
        DiskImage imageInfoFromVdsm = imagesHandler.getVolumeInfoFromVdsm(image.getStoragePoolId(), domainId, image.getId(), image.getImageId());
        return imageInfoFromVdsm.getApparentSizeInBytes();
    } else {
        // Upload
        if (getParameters().getTransferSize() != 0) {
            // TransferSize is only set by the webadmin
            return getParameters().getTransferSize();
        } else {
            boolean isOnBlock = getDiskImage().getStorageTypes().get(0).isBlockDomain();
            return isOnBlock ? getDiskImage().getActualSizeInBytes() : getDiskImage().getSize();
        }
    }
}
#method_after
private long getTransferSize(DiskImage image, Guid domainId) {
    if (getParameters().getTransferType() == TransferType.Download) {
        DiskImage imageInfoFromVdsm = imagesHandler.getVolumeInfoFromVdsm(image.getStoragePoolId(), domainId, image.getId(), image.getImageId());
        return imageInfoFromVdsm.getApparentSizeInBytes();
    }
    // Upload
    if (getParameters().getTransferSize() != 0) {
        // TransferSize is only set by the webadmin
        return getParameters().getTransferSize();
    }
    boolean isBlockDomain = getDiskImage().getStorageTypes().get(0).isBlockDomain();
    return isBlockDomain ? getDiskImage().getActualSizeInBytes() : getDiskImage().getSize();
}
#end_block

#method_before
public static String getDiskLabelList(List<Disk> disks) {
    if (disks.isEmpty()) {
        return null;
    }
    return disks.stream().map(Disk::getDiskAlias).collect(Collectors.joining(", "));
}
#method_after
public static String getDiskLabelList(List<Disk> disks) {
    if (disks.isEmpty()) {
        return null;
    }
    // $NON-NLS-1$
    return disks.stream().map(Disk::getDiskAlias).collect(Collectors.joining(", "));
}
#end_block

#method_before
private FutureVDSCall<VDSReturnValue> invokeSetupNetworksCommand(int timeout) {
    final HostSetupNetworksVdsCommandParameters parameters = createSetupNetworksParameters(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = getVdsBroker().runFutureVdsCommand(FutureVDSCommandType.HostSetupNetworks, parameters);
    if (parameters.isRollbackOnFailure()) {
        PollTechnique pt = FeatureSupported.isConfirmConnectivitySupportedByVdsm(getVds().getClusterCompatibilityVersion()) ? CONFIRM_CONNECTIVITY : POLL;
        HostPoller poller = new HostPoller(new TimeBoundPollVDSCommandParameters(getVdsId(), pt));
        while (!setupNetworksTask.isDone()) {
            poller.poll();
        }
    }
    return setupNetworksTask;
}
#method_after
private FutureVDSCall<VDSReturnValue> invokeSetupNetworksCommand(int timeout) {
    final HostSetupNetworksVdsCommandParameters parameters = createSetupNetworksParameters(timeout);
    FutureVDSCall<VDSReturnValue> setupNetworksTask = getVdsBroker().runFutureVdsCommand(FutureVDSCommandType.HostSetupNetworks, parameters);
    if (parameters.isRollbackOnFailure()) {
        PollTechnique pollTechnique = FeatureSupported.isConfirmConnectivitySupportedByVdsm(getVds().getClusterCompatibilityVersion()) ? CONFIRM_CONNECTIVITY : POLL;
        HostPoller poller = new HostPoller(new TimeBoundPollVDSCommandParameters(getVdsId(), pollTechnique));
        while (!setupNetworksTask.isDone()) {
            poller.poll();
        }
    }
    return setupNetworksTask;
}
#end_block

#method_before
public boolean check(final VDS host) {
    PollTechnique pt = FeatureSupported.isPing2SupportedByVdsm(host.getClusterCompatibilityVersion()) ? POLL2 : POLL;
    HostPoller poller = new HostPoller(new TimeBoundPollVDSCommandParameters(host.getId(), pt));
    final long startTime = System.nanoTime();
    while (System.nanoTime() - startTime < VDSM_RESPONSIVENESS_PERIOD_IN_NANOS) {
        if (poller.poll()) {
            log.info("Engine managed to communicate with VDSM agent on host '{}' with address '{}' ('{}')", host.getName(), host.getHostName(), host.getId());
            return true;
        }
    }
    return false;
}
#method_after
public boolean check(final VDS host) {
    PollTechnique pollTechnique = FeatureSupported.isPing2SupportedByVdsm(host.getClusterCompatibilityVersion()) ? POLL2 : POLL;
    HostPoller poller = new HostPoller(new TimeBoundPollVDSCommandParameters(host.getId(), pollTechnique));
    final long startTime = System.nanoTime();
    while (System.nanoTime() - startTime < VDSM_RESPONSIVENESS_PERIOD_IN_NANOS) {
        if (poller.poll()) {
            log.info("Engine managed to communicate with VDSM agent on host '{}' with address '{}' ('{}')", host.getName(), host.getHostName(), host.getId());
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    final TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.enableColumnResizing();
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(lunIdColumn, constants.lunIdSanStorage(), "250px");
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "60px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "45px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "70px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "70px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "210px");
    if (model.getContainer().isNewStorage() || model.getContainer().getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        if (multiSelection) {
            addAbstractLunActionsColumn(table, model.getContainer().isNewStorage() ? constants.addSanStorage() : constants.actionsSanStorage());
        }
    } else if (model.isReduceDeviceSupported()) {
        AbstractLunRemoveColumn removeColumn = new AbstractLunRemoveColumn(model) {

            @Override
            public LunModel getValue(LunModel object) {
                return object;
            }
        };
        // $NON-NLS-1$
        table.addColumn(removeColumn, constants.removeSanStorage(), "95px");
        model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
            table.redraw();
        });
    }
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        for (LunModel lunModel : items) {
            if (lunModel.getIsSelected()) {
                table.getSelectionModel().setSelected(lunModel, true);
            }
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    item.setWidget(table);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    addOpenHandlerToTree(tree, item, table);
    return item;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected TreeItem createLeafNode(ListModel leafModel) {
    final TreeItem item = new TreeItem();
    List<LunModel> items = (List<LunModel>) leafModel.getItems();
    if (hideLeaf || items.isEmpty()) {
        item.setUserObject(Boolean.TRUE);
        return item;
    }
    final SortedListModel sortedLeafModel = new SortedListModel();
    sortedLeafModel.setItems(items);
    final EntityModelCellTable<ListModel<LunModel>> table = new EntityModelCellTable<>(multiSelection, (Resources) GWT.create(SanStorageListLunTableResources.class));
    table.enableColumnResizing();
    table.initModelSortHandler(sortedLeafModel);
    AbstractLunSelectionColumn lunSelectionColumn = new AbstractLunSelectionColumn(multiSelection) {

        @Override
        public LunModel getValue(LunModel object) {
            return object;
        }
    };
    // $NON-NLS-1$
    table.setCustomSelectionColumn(lunSelectionColumn, "20px");
    AbstractLunTextColumn lunIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getLunId();
        }
    };
    lunIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(lunIdColumn, constants.lunIdSanStorage(), "250px");
    AbstractLunTextColumn devSizeColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return messages.gigabytes(String.valueOf(model.getSize()));
        }
    };
    devSizeColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(devSizeColumn, constants.devSizeSanStorage(), "60px");
    AbstractLunTextColumn path = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return String.valueOf(model.getMultipathing());
        }
    };
    path.makeSortable();
    // $NON-NLS-1$
    table.addColumn(path, constants.pathSanStorage(), "45px");
    AbstractLunTextColumn vendorIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getVendorId();
        }
    };
    vendorIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(vendorIdColumn, constants.vendorIdSanStorage(), "70px");
    AbstractLunTextColumn productIdColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getProductId();
        }
    };
    productIdColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(productIdColumn, constants.productIdSanStorage(), "70px");
    AbstractLunTextColumn serialNumColumn = new AbstractLunTextColumn() {

        @Override
        public String getRawValue(LunModel model) {
            return model.getSerial();
        }
    };
    serialNumColumn.makeSortable();
    // $NON-NLS-1$
    table.addColumn(serialNumColumn, constants.serialSanStorage(), "210px");
    if (model.getContainer().isNewStorage() || model.getContainer().getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        if (multiSelection) {
            addAbstractLunActionsColumn(table, model.getContainer().isNewStorage() ? constants.addSanStorage() : constants.actionsSanStorage());
        }
    } else if (model.isReduceDeviceSupported()) {
        AbstractLunRemoveColumn removeColumn = new AbstractLunRemoveColumn(model) {

            @Override
            public LunModel getValue(LunModel object) {
                return object;
            }
        };
        // $NON-NLS-1$
        table.addColumn(removeColumn, constants.removeSanStorage(), "95px");
        model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
            table.redraw();
        });
    }
    model.getRequireTableRefresh().getEntityChangedEvent().addListener((ev, sender, args) -> {
        if (Boolean.TRUE.equals(model.getRequireTableRefresh().getEntity())) {
            if (!multiSelection) {
                updateLunSelectionModel(table, items);
            }
        }
    });
    table.setRowData(items);
    final Object selectedItem = sortedLeafModel.getSelectedItem();
    sortedLeafModel.setSelectedItem(null);
    table.asEditor().edit(sortedLeafModel);
    sortedLeafModel.setSelectedItem(selectedItem);
    // $NON-NLS-1$
    table.setWidth("100%");
    if (!multiSelection) {
        table.getSelectionModel().addSelectionChangeHandler(event -> {
            SingleSelectionModel SingleSelectionModel = (SingleSelectionModel) event.getSource();
            selectedLunModel = SingleSelectionModel.getSelectedObject() == null ? selectedLunModel : (LunModel) SingleSelectionModel.getSelectedObject();
            if (selectedLunModel != null && !selectedLunModel.getIsGrayedOut()) {
                updateSelectedLunWarning(selectedLunModel);
                sortedLeafModel.setSelectedItem(selectedLunModel);
            }
        });
    } else {
        for (LunModel lunModel : items) {
            table.getSelectionModel().setSelected(lunModel, lunModel.getIsSelected());
        }
        table.getSelectionModel().addSelectionChangeHandler(event -> model.updateLunWarningForDiscardAfterDelete());
    }
    item.setWidget(table);
    // Display LUNs as grayed-out if needed
    for (LunModel lunModel : items) {
        if (lunModel.getIsGrayedOut()) {
            grayOutItem(lunModel.getGrayedOutReasons(), lunModel, table);
        }
    }
    addOpenHandlerToTree(tree, item, table);
    return item;
}
#end_block

#method_before
public void applyData(List<LUNs> source, boolean isIncluded, Collection<EntityModel<?>> selectedItems, boolean isInMaintenance, Set<String> metadataDevices) {
    ArrayList<LunModel> newItems = new ArrayList<>();
    for (LUNs a : source) {
        if (a.getLunType() == getType() || a.getLunType() == StorageType.UNKNOWN) {
            ArrayList<SanTargetModel> targets = createTargetModelList(a);
            LunModel lunModel = new LunModel();
            lunModel.setLunId(a.getLUNId());
            lunModel.setVendorId(a.getVendorId());
            lunModel.setProductId(a.getProductId());
            lunModel.setSerial(a.getSerial());
            lunModel.setMultipathing(a.getPathCount());
            lunModel.setTargets(targets);
            lunModel.setSize(a.getDeviceSize());
            lunModel.setAdditionalAvailableSize(getAdditionalAvailableSize(a));
            lunModel.setAdditionalAvailableSizeSelected(false);
            lunModel.setRemoveLunSelected(false);
            lunModel.setIsAccessible(a.getAccessible());
            lunModel.setStatus(a.getStatus());
            lunModel.setIsIncluded(lunModel.getIsIncluded() || isIncluded);
            lunModel.setIsSelected(containsLun(lunModel, selectedItems, isIncluded));
            lunModel.setEntity(a);
            // Add LunModel
            newItems.add(lunModel);
            // Update isGrayedOut and grayedOutReason properties
            updateGrayedOut(isInMaintenance, metadataDevices, lunModel);
            // Remember included LUNs to prevent their removal while updating items.
            if (isIncluded) {
                includedLUNs.add(lunModel);
            }
        }
    }
    initializeItems(newItems, null);
    proposeDiscover();
    getContainer().stopProgress();
}
#method_after
public void applyData(List<LUNs> source, boolean isIncluded, Collection<EntityModel<?>> selectedItems, boolean isInMaintenance, Set<String> metadataDevices) {
    ArrayList<LunModel> newItems = new ArrayList<>();
    for (LUNs a : source) {
        if (a.getLunType() == getType() || a.getLunType() == StorageType.UNKNOWN) {
            ArrayList<SanTargetModel> targets = createTargetModelList(a);
            LunModel lunModel = new LunModel();
            lunModel.setLunId(a.getLUNId());
            lunModel.setVendorId(a.getVendorId());
            lunModel.setProductId(a.getProductId());
            lunModel.setSerial(a.getSerial());
            lunModel.setMultipathing(a.getPathCount());
            lunModel.setTargets(targets);
            lunModel.setSize(a.getDeviceSize());
            lunModel.setAdditionalAvailableSize(getAdditionalAvailableSize(a));
            lunModel.setAdditionalAvailableSizeSelected(false);
            lunModel.setRemoveLunSelected(false);
            lunModel.setIsAccessible(a.getAccessible());
            lunModel.setStatus(a.getStatus());
            lunModel.setIsIncluded(lunModel.getIsIncluded() || isIncluded);
            lunModel.setIsSelected(containsLun(lunModel, selectedItems, isIncluded));
            lunModel.setEntity(a);
            // Add LunModel
            newItems.add(lunModel);
            // Update isGrayedOut and grayedOutReason properties
            updateGrayedOut(isInMaintenance, metadataDevices, lunModel);
            // Remember included LUNs to prevent their removal while updating items.
            if (isIncluded) {
                includedLUNs.add(lunModel);
            }
        }
    }
    initializeItems(newItems, null);
    proposeDiscover();
    updateRemovableLuns();
    getContainer().stopProgress();
}
#end_block

#method_before
public void updateRemovableLuns(Version dcCompatibilityVersion) {
    setReduceDeviceSupported((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ReduceDeviceFromStorageDomain, dcCompatibilityVersion.toString()));
    int numOfIncludedLuns = getIncludedLuns().size();
    List<LunModel> lunModels = getLuns(false, true);
    lunModels.forEach(lunModel -> lunModel.setIsLunRemovable(isReduceDeviceSupported() && (numOfIncludedLuns != 1 && !getMetadataDevices().contains(lunModel.getLunId()))));
}
#method_after
private void updateRemovableLuns() {
    int numOfIncludedLuns = getIncludedLuns().size();
    List<LunModel> lunModels = getLuns(false, true);
    lunModels.forEach(lunModel -> lunModel.setIsLunRemovable(numOfIncludedLuns != 1 && !getMetadataDevices().contains(lunModel.getLunId())));
}
#end_block

#method_before
private void dataCenter_SelectedItemChanged() {
    if (getCurrentStorageItem() instanceof SanStorageModelBase) {
        SanStorageModelBase sanStorageModel = (SanStorageModelBase) getCurrentStorageItem();
        sanStorageModel.updateRemovableLuns(getDataCenter().getSelectedItem().getCompatibilityVersion());
        sanStorageModel.getRequireTableRefresh().setEntity(null);
        sanStorageModel.getRequireTableRefresh().setEntity(true);
    }
    updateItemsAvailability();
    behavior.updateDataCenterAlert();
}
#method_after
private void dataCenter_SelectedItemChanged() {
    if (getCurrentStorageItem() instanceof SanStorageModelBase) {
        SanStorageModelBase sanStorageModel = (SanStorageModelBase) getCurrentStorageItem();
        sanStorageModel.setReduceDeviceSupported((Boolean) AsyncDataProvider.getInstance().getConfigValuePreConverted(ConfigValues.ReduceDeviceFromStorageDomain, getDataCenter().getSelectedItem().getCompatibilityVersion().toString()));
    }
    updateItemsAvailability();
    behavior.updateDataCenterAlert();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (shouldSkipCommandExecutionCached()) {
        setSucceeded(true);
        return;
    }
    executeVmCommand();
    updateHeOvf();
}
#method_after
@Override
protected void executeCommand() {
    if (shouldSkipCommandExecutionCached()) {
        setSucceeded(true);
        return;
    }
    executeVmCommand();
    if (shouldUpdateHostedEngineOvf() && getVm().isHostedEngine() && getSucceeded()) {
        updateHeOvf();
    }
}
#end_block

#method_before
protected void endVmCommand() {
    if (getVm() != null) {
        vmStaticDao.incrementDbGeneration(getVm().getId());
    }
    endActionOnDisks();
    unlockVm();
    setSucceeded(true);
}
#method_after
protected void endVmCommand() {
    endActionOnDisks();
    if (getVm() != null) {
        vmStaticDao.incrementDbGeneration(getVm().getId());
    }
    unlockVm();
    setSucceeded(true);
}
#end_block

#method_before
protected String cdPathWindowsToLinux(String windowsPath, Guid storagePoolId, Guid vdsId) {
    if (StringUtils.isEmpty(windowsPath)) {
        // empty string is used for 'eject'
        return "";
    }
    return cdPathWindowsToLinux(windowsPath, getIsoPrefix(storagePoolId, vdsId));
}
#method_after
protected String cdPathWindowsToLinux(String windowsPath, Guid storagePoolId, Guid vdsId) {
    if (StringUtils.isEmpty(windowsPath)) {
        // empty string is used for 'eject'
        return "";
    }
    if (windowsPath.matches(ValidationUtils.GUID)) {
        BaseDisk disk = diskDao.get(Guid.createGuidFromString(windowsPath));
        if (disk != null) {
            return vmInfoBuildUtils.getPathToImage((DiskImage) disk);
        }
    }
    return cdPathWindowsToLinux(windowsPath, getIsoPrefix(storagePoolId, vdsId));
}
#end_block

#method_before
protected boolean removeVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    return runInternalActionWithTasksContext(ActionType.RemoveVmLease, new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId)).getSucceeded();
}
#method_after
protected boolean removeVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId);
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.RemoveVmLease, params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
protected boolean addVmLease(Guid leaseStorageDomainId, Guid vmId) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    return runInternalActionWithTasksContext(ActionType.AddVmLease, new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId)).getSucceeded();
}
#method_after
protected boolean addVmLease(Guid leaseStorageDomainId, Guid vmId, boolean hotPlugLease) {
    if (leaseStorageDomainId == null) {
        return true;
    }
    VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), leaseStorageDomainId, vmId);
    if (hotPlugLease) {
        params.setVdsId(getVm().getRunOnVds());
        params.setHotPlugLease(true);
    }
    params.setParentCommand(getActionType());
    params.setParentParameters(getParameters());
    ActionReturnValue returnValue = runInternalActionWithTasksContext(ActionType.AddVmLease, params);
    if (returnValue.getSucceeded()) {
        getTaskIdList().addAll(returnValue.getInternalVdsmTaskIdList());
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
private void updateHeOvf() {
    if (shouldUpdateHostedEngineOvf() && getVm().isHostedEngine() && getSucceeded()) {
        ovfDataUpdater.triggerNow();
    }
}
#method_after
private void updateHeOvf() {
    // If there is no current transaction, trigger ovf update immediately
    if (TransactionSupport.current() == null) {
        ovfDataUpdater.triggerNow();
        return;
    }
    // If there is a transaction, trigger update after it is committed.
    registerRollbackHandler(new TransactionCompletionListener() {

        @Override
        public void onSuccess() {
            ovfDataUpdater.triggerNow();
        }

        @Override
        public void onRollback() {
        // No notification is needed
        }
    });
}
#end_block

#method_before
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Execution);
}
#method_after
@Override
protected LockProperties applyLockProperties(LockProperties lockProperties) {
    return lockProperties.withScope(Scope.Command);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    } else if (!updateVmLease()) {
        return;
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    newVmStatic = getParameters().getVmStaticData();
    if (isRunningConfigurationNeeded()) {
        vmHandler.createNextRunSnapshot(getVm(), getParameters().getVmStaticData(), getParameters(), getCompensationContext());
        vmHandler.setVmDestroyOnReboot(getVm());
    }
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    newVmStatic.setLeaseInfo(oldVm.getStaticData().getLeaseInfo());
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!vmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled(), oldVm.getStatus(), getParameters().isMemoryHotUnplugEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    updateAffinityLabels();
    if (!updateVmLease()) {
        return;
    }
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = iconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    iconUtils.removeUnusedIcons(oldIconIds);
    vmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    getVm().getStaticData().setLeaseInfo(null);
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId())) {
            return false;
        }
    } else {
        if (oldVm.getLeaseStorageDomainId() == null) {
            VmLeaseParameters params = new VmLeaseParameters(getStoragePoolId(), newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId());
            params.setVdsId(getVm().getRunOnVds());
            params.setHotPlugLease(true);
            return runInternalAction(ActionType.AddVmLease, params).getSucceeded();
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#method_after
private boolean updateVmLease() {
    if (Objects.equals(oldVm.getLeaseStorageDomainId(), newVmStatic.getLeaseStorageDomainId())) {
        return true;
    }
    getVm().getStaticData().setLeaseInfo(null);
    if (getVm().isNotRunning()) {
        if (!addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), false)) {
            return false;
        }
    } else if (isHotSetEnabled()) {
        if (oldVm.getLeaseStorageDomainId() == null) {
            return addVmLease(newVmStatic.getLeaseStorageDomainId(), newVmStatic.getId(), true);
        }
        boolean hotUnplugSucceeded = false;
        try {
            hotUnplugSucceeded = runVdsCommand(VDSCommandType.HotUnplugLease, new LeaseVDSParameters(getVm().getRunOnVds(), oldVm.getId(), oldVm.getLeaseStorageDomainId())).getSucceeded();
        } catch (EngineException e) {
            log.error("Failure in hot unplugging a lease to VM {}, message: {}", oldVm.getId(), e.getMessage());
        }
        if (!hotUnplugSucceeded) {
            auditLog(this, AuditLogType.HOT_UNPLUG_LEASE_FAILED);
        }
    }
    // In case of remove lease only, VM lease info should set to null
    if (oldVm.getLeaseStorageDomainId() != null && newVmStatic.getLeaseStorageDomainId() == null) {
        newVmStatic.setLeaseInfo(null);
    }
    // best effort to remove the lease from the previous storage domain
    removeVmLease(oldVm.getLeaseStorageDomainId(), oldVm.getId());
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (Math.abs(vmFromDB.getVmCreationDate().getTime() - vmFromParams.getVmCreationDate().getTime()) > 1000) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INVALID_CREATION_DATE);
    }
    vmFromParams.setVmCreationDate(vmFromDB.getVmCreationDate());
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    Version customCompatibilityVersionFromParams = vmFromParams.getStaticData().getCustomCompatibilityVersion();
    if (customCompatibilityVersionFromParams != null && !isCompatibilityVersionSupportedByCluster(customCompatibilityVersionFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CUSTOM_COMPATIBILITY_VERSION_NOT_SUPPORTED, String.format("$Ccv %s", customCompatibilityVersionFromParams));
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && !FeatureSupported.isHighPerformanceTypeSupported(getEffectiveCompatibilityVersion())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_HIGH_PERFORMANCE_IS_NOT_SUPPORTED, String.format("$Version %s", getEffectiveCompatibilityVersion()));
    }
    if (!validateCustomProperties(vmFromParams.getStaticData())) {
        return false;
    }
    if (!validate(vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture()))) {
        return false;
    }
    if (!validate(vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName()))) {
        return false;
    }
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && vmFromParams.getSingleQxlPci() && !validate(vmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs()))) {
        return false;
    }
    if (!validate(vmHandler.validateSmartCardDevice(getParameters().getVmStaticData()))) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (vmFromParams.getVmType() == VmType.HighPerformance && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGH_PERFORMANCE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (getParameters().getVmStaticData().getDefaultDisplayType() != DisplayType.none && !vmHandler.isNumOfMonitorsLegal(vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors()).isValid()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!validate(vmHandler.isVmPriorityValueLegal(vmFromParams.getPriority()))) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), StandardCharsets.UTF_8));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!validate(vmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration()) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (!VmCpuCountHelper.validateCpuCounts(vmFromParams)) {
        return failValidation(EngineMessage.TOO_MANY_CPU_COMPONENTS);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!validate(vmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion()))) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    if (!validate(vmHandler.validateMaxMemorySize(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion()))) {
        return false;
    }
    if (shouldAddLease(getParameters().getVmStaticData())) {
        if (!canAddLease()) {
            return false;
        }
        if (!getVm().isDown() && getParameters().getVmStaticData().getLeaseStorageDomainId() != null && getVm().getLeaseStorageDomainId() != null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOT_SWAPPING_VM_LEASES_NOT_SUPPORTED);
        }
    }
    List<EngineMessage> msgs = openStackMetadataAdapter.validate(getParameters().getVmStaticData().getVmInit());
    if (!CollectionUtils.isEmpty(msgs)) {
        return failValidation(msgs);
    }
    final boolean isMemoryHotUnplug = vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && isHotSetEnabled() && getParameters().isMemoryHotUnplugEnabled();
    if (isMemoryHotUnplug && !FeatureSupported.hotUnplugMemory(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_UNPLUG_NOT_SUPPORTED_FOR_COMPAT_VERSION_AND_ARCH, ReplacementUtils.createSetVariableString("compatibilityVersion", getVm().getCompatibilityVersion()), ReplacementUtils.createSetVariableString("architecture", getVm().getClusterArch()));
    }
    if (vmFromDB.getMemSizeMb() != vmFromParams.getMemSizeMb() && vmFromDB.isRunning() && isHotSetEnabled() && HugePageUtils.isBackedByHugepages(vmFromDB.getStaticData()) && (vmFromDB.getMemSizeMb() < vmFromParams.getMemSizeMb() || (vmFromDB.getMemSizeMb() > vmFromParams.getMemSizeMb() && getParameters().isMemoryHotUnplugEnabled()))) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MEMORY_HOT_SET_NOT_SUPPORTED_FOR_HUGE_PAGES);
    }
    return true;
}
#end_block

#method_before
public void setGuestCpuType(String value) {
    if (!Objects.equals(createdByUser, value)) {
        guestCpuType = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("GuestCpuType"));
    }
}
#method_after
public void setGuestCpuType(String value) {
    if (!Objects.equals(guestCpuType, value)) {
        guestCpuType = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("GuestCpuType"));
    }
}
#end_block

#method_before
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setOptimizedForSystemProfile(translator.translate(vm.getVmType()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getFqdn());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasCreatedByUser(vm.getCreatedByUserId() != null);
    if (getHasCreatedByUser()) {
        Frontend.getInstance().runQuery(QueryType.GetDbUserByUserId, new IdQueryParameters(vm.getCreatedByUserId()), new AsyncQuery<>(new AsyncCallback<QueryReturnValue>() {

            @Override
            public void onSuccess(QueryReturnValue result) {
                DbUser dbUser = result.getReturnValue();
                if (dbUser != null) {
                    setCreatedByUser(getUserName(dbUser));
                }
            }

            private String getUserName(DbUser dbUser) {
                if (StringHelper.isNotNullOrEmpty(dbUser.getFirstName()) || StringHelper.isNotNullOrEmpty(dbUser.getLastName())) {
                    return messages.userName(nullToEmpty(dbUser.getFirstName()), nullToEmpty(dbUser.getLastName()));
                }
                return dbUser.getLoginName();
            }

            private String nullToEmpty(String val) {
                return val == null ? "" : val;
            }
        }));
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(QueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new AsyncQuery<QueryReturnValue>(returnValue -> {
            // $NON-NLS-1$
            VM localVm = getEntity();
            if (localVm == null) {
                return;
            }
            ArrayList<VDS> hosts = returnValue.getReturnValue();
            if (localVm.getDedicatedVmForVdsList().size() > 0) {
                String defaultHost = "";
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                        if (defaultHost.isEmpty()) {
                            defaultHost = host.getName();
                        } else {
                            // $NON-NLS-1$
                            defaultHost += ", " + host.getName();
                        }
                    }
                }
                setDefaultHost(defaultHost);
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
    final String guestCpuType = vm.getCpuName() != null ? vm.getCpuName() : vm.getClusterCpuName();
    setGuestCpuType(guestCpuType);
}
#method_after
private void updateProperties() {
    VM vm = getEntity();
    super.updateProperties(vm.getId());
    setName(vm.getName());
    setDescription(vm.getVmDescription());
    // $NON-NLS-1$
    setQuotaName(vm.getQuotaName() != null ? vm.getQuotaName() : "");
    setQuotaAvailable(vm.getQuotaEnforcementType() != null && !vm.getQuotaEnforcementType().equals(QuotaEnforcementTypeEnum.DISABLED));
    setTemplate(vmTemplateNameRenderer.render(vm));
    // $NON-NLS-1$
    setDefinedMemory(vm.getVmMemSizeMb() + " MB");
    // $NON-NLS-1$
    setMinAllocatedMemory(vm.getMinAllocatedMem() + " MB");
    if (vm.isRunningOrPaused() && vm.getGuestMemoryBuffered() != null && vm.getGuestMemoryCached() != null && vm.getGuestMemoryFree() != null) {
        setGuestFreeCachedBufferedMemInfo(// $NON-NLS-1$
        (vm.getGuestMemoryFree() / 1024L) + " / " + (vm.getGuestMemoryBuffered() / 1024L) + // $NON-NLS-1$
        " / " + (vm.getGuestMemoryCached() / 1024L) + // $NON-NLS-1$
        " MB");
    } else {
        // Handled in form
        setGuestFreeCachedBufferedMemInfo(null);
    }
    setOS(AsyncDataProvider.getInstance().getOsName(vm.getVmOsId()));
    EnumTranslator translator = EnumTranslator.getInstance();
    setDefaultDisplayType(translator.translate(vm.getDefaultDisplayType()));
    setOrigin(translator.translate(vm.getOrigin()));
    setIsHighlyAvailable(vm.isAutoStartup());
    setPriority(AsyncDataProvider.getInstance().priorityToString(vm.getPriority()));
    setOptimizedForSystemProfile(translator.translate(vm.getVmType()));
    setMonitorCount(vm.getNumOfMonitors());
    setUsbPolicy(translator.translate(vm.getUsbPolicy()));
    setCpuInfo(ConstantsManager.getInstance().getMessages().cpuInfoLabel(vm.getNumOfCpus(), vm.getNumOfSockets(), vm.getCpuPerSocket(), vm.getThreadsPerCpu()));
    setGuestCpuCount(vm.getGuestCpuCount());
    setHasDomain(AsyncDataProvider.getInstance().isWindowsOsType(vm.getVmOsId()));
    if (vm.getVmInit() != null) {
        setDomain(vm.getVmInit().getDomain());
    }
    setHasTimeZone(!StringHelper.isNullOrEmpty(vm.getTimeZone()));
    setTimeZone(vm.getTimeZone());
    setHasCustomProperties(!StringHelper.isNullOrEmpty(vm.getCustomProperties()));
    setCustomProperties(getHasCustomProperties() ? constants.configured() : constants.notConfigured());
    setCompatibilityVersion(vm.getCompatibilityVersion() != null ? vm.getCompatibilityVersion().toString() : // $NON-NLS-1$
    "");
    setVmId(vm.getId().toString());
    setFqdn(vm.getFqdn());
    setHasAlert(vm.getVmPauseStatus() != VmPauseStatus.NONE && vm.getVmPauseStatus() != VmPauseStatus.NOERR);
    if (getHasAlert()) {
        setAlert(translator.translate(vm.getVmPauseStatus()));
    } else {
        setAlert(null);
    }
    setHasCreatedByUser(vm.getCreatedByUserId() != null);
    if (getHasCreatedByUser()) {
        Frontend.getInstance().runQuery(QueryType.GetDbUserByUserId, new IdQueryParameters(vm.getCreatedByUserId()), new AsyncQuery<>(new AsyncCallback<QueryReturnValue>() {

            @Override
            public void onSuccess(QueryReturnValue result) {
                DbUser dbUser = result.getReturnValue();
                if (dbUser != null) {
                    setCreatedByUser(getUserName(dbUser));
                }
            }

            private String getUserName(DbUser dbUser) {
                if (StringHelper.isNotNullOrEmpty(dbUser.getFirstName()) || StringHelper.isNotNullOrEmpty(dbUser.getLastName())) {
                    return messages.userName(nullToEmpty(dbUser.getFirstName()), nullToEmpty(dbUser.getLastName()));
                }
                return dbUser.getLoginName();
            }

            private String nullToEmpty(String val) {
                return val == null ? "" : val;
            }
        }));
    }
    setHasDefaultHost(vm.getDedicatedVmForVdsList().size() > 0);
    if (getHasDefaultHost()) {
        Frontend.getInstance().runQuery(QueryType.Search, new SearchParameters(// $NON-NLS-1$
        "Host: cluster = " + vm.getClusterName() + " sortby name", SearchType.VDS).withoutRefresh(), new AsyncQuery<QueryReturnValue>(returnValue -> {
            // $NON-NLS-1$
            VM localVm = getEntity();
            if (localVm == null) {
                return;
            }
            ArrayList<VDS> hosts = returnValue.getReturnValue();
            if (localVm.getDedicatedVmForVdsList().size() > 0) {
                String defaultHost = "";
                for (VDS host : hosts) {
                    if (localVm.getDedicatedVmForVdsList().contains(host.getId())) {
                        if (defaultHost.isEmpty()) {
                            defaultHost = host.getName();
                        } else {
                            // $NON-NLS-1$
                            defaultHost += ", " + host.getName();
                        }
                    }
                }
                setDefaultHost(defaultHost);
            }
        }));
    } else {
        setDefaultHost(ConstantsManager.getInstance().getConstants().anyHostInCluster());
    }
    final String guestCpuType = vm.getCpuName() != null ? vm.getCpuName() : (vm.getCustomCpuName() != null ? vm.getCustomCpuName() : vm.getClusterCpuName());
    setGuestCpuType(guestCpuType);
}
#end_block

#method_before
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command) throws IOException, InterruptedException {
    return runCommand(command, ANSIBLE_PLAYBOOK_TIMEOUT);
}
#method_after
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command) throws IOException, InterruptedException {
    int timeout = EngineLocalConfig.getInstance().getInteger("ANSIBLE_PLAYBOOK_EXEC_DEFAULT_TIMEOUT");
    return runCommand(command, timeout);
}
#end_block

#method_before
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command, int timeout) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    AnsibleReturnValue returnValue = new AnsibleReturnValue(AnsibleReturnCode.ERROR);
    Path inventoryFile = null;
    Process ansibleProcess = null;
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().command(ansibleCommand).directory(command.playbookDir().toFile());
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        if (command.enableLogging()) {
            ansibleProcessBuilder.environment().put("ANSIBLE_LOG_PATH", command.logFile().toString());
        }
        if (command.stdoutCallback() != null) {
            ansibleProcessBuilder.environment().put(AnsibleEnvironmentConstants.ANSIBLE_STDOUT_CALLBACK, command.stdoutCallback());
        }
        // Execute the command:
        ansibleProcess = ansibleProcessBuilder.start();
        ansibleProcess.waitFor(timeout, TimeUnit.MINUTES);
        returnValue.setAnsibleReturnCode(AnsibleReturnCode.values()[ansibleProcess.exitValue()]);
        if (command.stdoutCallback() != null) {
            returnValue.setStdout(IOUtils.toString(ansibleProcess.getInputStream()));
        }
    } finally {
        if (ansibleProcess != null) {
            ansibleProcess.destroy();
        }
        log.info("Ansible playbook command has exited with value: {}", returnValue.getAnsibleReturnCode());
        removeFile(inventoryFile);
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnValue;
}
#method_after
public AnsibleReturnValue runCommand(AnsibleCommandBuilder command, int timeout) throws IOException, InterruptedException {
    log.trace("Enter AnsibleExecutor::runCommand");
    AnsibleReturnValue returnValue = new AnsibleReturnValue(AnsibleReturnCode.ERROR);
    Path inventoryFile = null;
    Process ansibleProcess = null;
    try {
        // Create a temporary inventory file if user didn't specified it:
        inventoryFile = createInventoryFile(command);
        // Build the command:
        log.info("Executing Ansible command: {}", command);
        List<String> ansibleCommand = command.build();
        ProcessBuilder ansibleProcessBuilder = new ProcessBuilder().command(ansibleCommand).directory(command.playbookDir().toFile());
        // Set environment variables:
        ansibleProcessBuilder.environment().put("ANSIBLE_CONFIG", Paths.get(command.playbookDir().toString(), "ansible.cfg").toString());
        if (command.enableLogging()) {
            ansibleProcessBuilder.environment().put("ANSIBLE_LOG_PATH", command.logFile().toString());
        }
        if (command.stdoutCallback() != null) {
            ansibleProcessBuilder.environment().put(AnsibleEnvironmentConstants.ANSIBLE_STDOUT_CALLBACK, command.stdoutCallback());
        }
        // Execute the command:
        ansibleProcess = ansibleProcessBuilder.start();
        if (!ansibleProcess.waitFor(timeout, TimeUnit.MINUTES)) {
            throw new Exception("Timeout occurred while executing Ansible playbook.");
        }
        returnValue.setAnsibleReturnCode(AnsibleReturnCode.values()[ansibleProcess.exitValue()]);
        if (command.stdoutCallback() != null) {
            returnValue.setStdout(IOUtils.toString(ansibleProcess.getInputStream()));
        }
    } catch (Throwable t) {
        log.error("Ansible playbook execution failed: {}", t.getMessage() != null ? t.getMessage() : t.getClass().getName());
        log.debug("Exception:", t);
    } finally {
        if (ansibleProcess != null) {
            ansibleProcess.destroy();
        }
        log.info("Ansible playbook command has exited with value: {}", returnValue.getAnsibleReturnCode());
        removeFile(inventoryFile);
    }
    log.trace("Exit AnsibleExecutor::runCommand");
    return returnValue;
}
#end_block

#method_before
private static void setVlanSpeeds(VDS vds) {
    List<VdsNetworkInterface> interfaces = vds.getInterfaces();
    List<VdsNetworkInterface> vlans = interfaces.stream().filter(iface -> iface.getVlanId() != null).collect(Collectors.toList());
    for (VdsNetworkInterface vlanIface : vlans) {
        VdsNetworkInterface baseInterface = interfaces.stream().filter(iface -> iface.getName().equals(vlanIface.getBaseInterface())).findFirst().get();
        vlanIface.setSpeed(baseInterface.getSpeed());
    }
}
#method_after
private static void setVlanSpeeds(VDS vds) {
    List<VdsNetworkInterface> interfaces = vds.getInterfaces();
    List<VdsNetworkInterface> vlans = interfaces.stream().filter(iface -> NetworkCommonUtils.isVlan(iface)).collect(Collectors.toList());
    for (VdsNetworkInterface vlanIface : vlans) {
        VdsNetworkInterface baseInterface = interfaces.stream().filter(iface -> iface.getName().equals(vlanIface.getBaseInterface())).findFirst().get();
        vlanIface.setSpeed(baseInterface.getSpeed());
    }
}
#end_block

#method_before
private boolean isRemoveCommandAvailable(List<DiskImage> disks) {
    if (disks.stream().anyMatch(d -> d.getImageStatus() == ImageStatus.LOCKED || (d.isOvfStore() && d.getImageStatus() != ImageStatus.ILLEGAL))) {
        return false;
    }
    return true;
}
#method_after
private boolean isRemoveCommandAvailable(List<DiskImage> disks) {
    return disks.stream().noneMatch(d -> d.getImageStatus() == ImageStatus.LOCKED || (d.isOvfStore() && d.getImageStatus() != ImageStatus.ILLEGAL));
}
#end_block

#method_before
private boolean isRemoveCommandAvailable(List<DiskImage> disks) {
    if (disks.stream().anyMatch(d -> d.getImageStatus() == ImageStatus.LOCKED)) {
        return false;
    }
    return true;
}
#method_after
private boolean isRemoveCommandAvailable(List<DiskImage> disks) {
    return disks.stream().noneMatch(d -> d.getImageStatus() == ImageStatus.LOCKED);
}
#end_block

#method_before
private void finalizeDownloadIfNecessary(final StateContext context, ImageTransfer upToDateImageTransfer) {
    if (getParameters().getTransferSize() != 0 && // Frontend flow (REST API should close the connection on its own).
    getParameters().getTransferSize() == upToDateImageTransfer.getBytesSent() && !upToDateImageTransfer.getActive()) {
        // to decrease the chances that the few last packets are still on the way to the client.
        if (!context.entity.getActive()) {
            // The entity from the previous COCO iteration.
            // This is the second COCO iteration that the transfer is inactive.
            ImageTransfer statusUpdate = new ImageTransfer();
            statusUpdate.setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
            runInternalAction(ActionType.TransferImageStatus, new TransferImageStatusParameters(getCommandId(), statusUpdate));
        }
    }
}
#method_after
private void finalizeDownloadIfNecessary(final StateContext context, ImageTransfer upToDateImageTransfer) {
    if (upToDateImageTransfer.getBytesTotal() != 0 && // Frontend flow (REST API should close the connection on its own).
    getParameters().getTransferSize() == upToDateImageTransfer.getBytesSent() && !upToDateImageTransfer.getActive()) {
        // to decrease the chances that the few last packets are still on the way to the client.
        if (!context.entity.getActive()) {
            // The entity from the previous COCO iteration.
            // This is the second COCO iteration that the transfer is inactive.
            ImageTransfer statusUpdate = new ImageTransfer();
            statusUpdate.setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
            runInternalAction(ActionType.TransferImageStatus, new TransferImageStatusParameters(getCommandId(), statusUpdate));
        }
    }
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    // DEPRECATED
    mandatory(host().rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    mandatory(host().ssh().authenticationMethod());
    mandatory(host().ssh().user().password());
    mandatory(host().ssh().user().userName());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().externalHostProvider().id());
    // DEPRECATED
    optional(host().rootPassword());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(rootPassword());
}
#end_block

#method_before
@InputDetail
default void inputDetail() {
    optional(host().ssh().fingerprint());
    optional(host().ssh().port());
    optional(host().ssh().user().userName());
}
#method_after
@InputDetail
default void inputDetail() {
    optional(ssh().authenticationMethod());
    optional(ssh().fingerprint());
    optional(ssh().port());
    optional(ssh().user().password());
    optional(ssh().user().userName());
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__ADD);
    addValidationMessage(EngineMessage.VAR__TYPE__GLUSTER_WEBHOOK);
}
#method_after
/*    @Override
    protected LockProperties applyLockProperties(LockProperties lockProperties) {
        return lockProperties.withScope(Scope.Execution).withWait(true);
    }*/
@Override
protected void setActionMessageParameters() {
    addValidationMessage(EngineMessage.VAR__ACTION__ADD);
    addValidationMessage(EngineMessage.VAR__TYPE__GLUSTER_WEBHOOK);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!supportedInConfig(ConfigValues.GlusterEventingSupported, getCluster().getCompatibilityVersion())) {
        // if eventing is not supported, we do not want to process further
        return;
    }
    String webhookUrl = getWebhookUrl();
    if (webhookUrl == null) {
        handleVdsError(AuditLogType.GLUSTER_WEBHOOK_ADD_FAILED, "No webhook url");
        setSucceeded(false);
        return;
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterWebhook, new GlusterWebhookVDSParameters(upServer.getId(), webhookUrl));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_WEBHOOK_ADD_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#method_after
@Override
protected void executeCommand() {
    String webhookUrl = getWebhookUrl();
    if (webhookUrl == null) {
        handleVdsError(AuditLogType.GLUSTER_WEBHOOK_ADD_FAILED, "No webhook url");
        setSucceeded(false);
        return;
    }
    // check for a server to run the command on
    VDS upServer = getUpServer();
    if (upServer == null) {
        // there's no other server than the one being activated
        upServer = getVds();
    }
    // TODO: check if the webhook is already added before adding this.
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.AddGlusterWebhook, new GlusterWebhookVDSParameters(upServer.getId(), webhookUrl, null));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_WEBHOOK_ADD_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
}
#end_block

#method_before
public Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage, OvfManager ovfManager) {
    if (snapshot != null) {
        try {
            String snapConfig = snapshot.getVmConfiguration();
            if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
                VM vmSnapshot = new VM();
                FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vmSnapshot);
                ovfManager.importVm(snapConfig, vmSnapshot, fullEntityOvfData);
                // Remove the image from the disk list
                Iterator<DiskImage> diskIter = fullEntityOvfData.getDiskImages().iterator();
                while (diskIter.hasNext()) {
                    DiskImage imageInList = diskIter.next();
                    if (imageInList.getImageId().equals(oldImageId)) {
                        log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                        diskIter.remove();
                        break;
                    }
                }
                if (newImage != null) {
                    log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                    newImage.setDiskVmElements(Collections.singletonList(diskVmElementDao.get(new VmDeviceId(newImage.getId(), vmSnapshot.getId()))));
                    fullEntityOvfData.getDiskImages().add(newImage);
                }
                final Version compatibilityVersion = Optional.ofNullable(vmSnapshot.getStaticData().getClusterCompatibilityVersionOrigin()).orElse(Version.getLowest());
                FullEntityOvfData fullEntityOvfDataForExport = new FullEntityOvfData(vmSnapshot);
                fullEntityOvfDataForExport.setDiskImages(fullEntityOvfData.getDiskImages());
                String newOvf = ovfManager.exportVm(vmSnapshot, fullEntityOvfDataForExport, compatibilityVersion);
                snapshot.setVmConfiguration(newOvf);
            }
        } catch (OvfReaderException e) {
            log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
        }
    }
    return snapshot;
}
#method_after
public Snapshot prepareSnapshotConfigWithAlternateImage(Snapshot snapshot, Guid oldImageId, DiskImage newImage, OvfManager ovfManager) {
    if (snapshot == null) {
        return null;
    }
    try {
        String snapConfig = snapshot.getVmConfiguration();
        if (snapshot.isVmConfigurationAvailable() && snapConfig != null) {
            VM vmSnapshot = new VM();
            FullEntityOvfData fullEntityOvfData = new FullEntityOvfData(vmSnapshot);
            ovfManager.importVm(snapConfig, vmSnapshot, fullEntityOvfData);
            // Remove the image from the disk list
            Iterator<DiskImage> diskIter = fullEntityOvfData.getDiskImages().iterator();
            while (diskIter.hasNext()) {
                DiskImage imageInList = diskIter.next();
                if (imageInList.getImageId().equals(oldImageId)) {
                    log.debug("Recreating vmSnapshot '{}' without the image '{}'", snapshot.getId(), oldImageId);
                    diskIter.remove();
                    break;
                }
            }
            if (newImage != null) {
                log.debug("Adding image '{}' to vmSnapshot '{}'", newImage.getImageId(), snapshot.getId());
                newImage.setDiskVmElements(Collections.singletonList(diskVmElementDao.get(new VmDeviceId(newImage.getId(), vmSnapshot.getId()))));
                fullEntityOvfData.getDiskImages().add(newImage);
            }
            final Version compatibilityVersion = Optional.ofNullable(vmSnapshot.getStaticData().getClusterCompatibilityVersionOrigin()).orElse(Version.getLowest());
            FullEntityOvfData fullEntityOvfDataForExport = new FullEntityOvfData(vmSnapshot);
            fullEntityOvfDataForExport.setDiskImages(fullEntityOvfData.getDiskImages());
            String newOvf = ovfManager.exportVm(vmSnapshot, fullEntityOvfDataForExport, compatibilityVersion);
            snapshot.setVmConfiguration(newOvf);
        }
    } catch (OvfReaderException e) {
        log.error("Can't remove image '{}' from snapshot '{}'", oldImageId, snapshot.getId());
    }
    return snapshot;
}
#end_block

#method_before
protected void displayHighPerformanceConfirmationPopup() {
    final PoolModel model = (PoolModel) getWindow();
    if (model == null || model.getProgress() != null) {
        return;
    }
    VmHighPerformanceConfigurationModel confirmModel = new VmHighPerformanceConfigurationModel();
    // Handle CPU Pinning topology
    final boolean isVmAssignedToSpecificHosts = !model.getIsAutoAssign().getEntity();
    final boolean isVmCpuPinningSet = model.getCpuPinning().getIsChangable() && model.getCpuPinning().getEntity() != null && !model.getCpuPinning().getEntity().isEmpty();
    confirmModel.addRecommendationForCpuPinning(isVmAssignedToSpecificHosts, isVmCpuPinningSet);
    // Handle KSM (Kernel Same Page Merging)
    confirmModel.addRecommendationForKsm(model.getSelectedCluster().isEnableKsm(), model.getSelectedCluster().getName());
    // Handle Huge Pages
    KeyValueModel keyValue = model.getCustomPropertySheet();
    // $NON-NLS-1$
    final boolean isVmHugePagesSet = keyValue != null && keyValue.getUsedKeys().contains("hugepages");
    confirmModel.addRecommendationForHugePages(isVmHugePagesSet);
    if (!confirmModel.getRecommendationsList().isEmpty()) {
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().configurationChangesForHighPerformancePoolTitle());
        confirmModel.setHelpTag(HelpTag.configuration_changes_for_high_performance_pool);
        // $NON-NLS-1$
        confirmModel.setHashName("configuration_changes_for_high_performance_pool");
        confirmModel.getCommands().add(// $NON-NLS-1$
        new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        confirmModel.getCommands().add(// $NON-NLS-1$
        UICommand.createCancelUiCommand("CancelConfirmation", PoolListModel.this));
        setConfirmWindow(null);
        setConfirmWindow(confirmModel);
    } else {
        savePoolPostValidation();
    }
}
#method_after
protected void displayHighPerformanceConfirmationPopup() {
    final PoolModel model = (PoolModel) getWindow();
    if (model == null || model.getProgress() != null) {
        return;
    }
    VmHighPerformanceConfigurationModel confirmModel = new VmHighPerformanceConfigurationModel();
    // Handle CPU Pinning topology
    final boolean isVmAssignedToSpecificHosts = !model.getIsAutoAssign().getEntity();
    final boolean isVmCpuPinningSet = model.getCpuPinning().getIsChangable() && model.getCpuPinning().getEntity() != null && !model.getCpuPinning().getEntity().isEmpty();
    confirmModel.addRecommendationForCpuPinning(isVmAssignedToSpecificHosts, isVmCpuPinningSet);
    // Handle Huge Pages
    KeyValueModel keyValue = model.getCustomPropertySheet();
    // $NON-NLS-1$
    final boolean isVmHugePagesSet = keyValue != null && keyValue.getUsedKeys().contains("hugepages");
    confirmModel.addRecommendationForHugePages(isVmHugePagesSet);
    // Handle KSM (Kernel Same Page Merging)
    confirmModel.addRecommendationForKsm(model.getSelectedCluster().isEnableKsm(), model.getSelectedCluster().getName());
    if (!confirmModel.getRecommendationsList().isEmpty()) {
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().configurationChangesForHighPerformancePoolTitle());
        confirmModel.setHelpTag(HelpTag.configuration_changes_for_high_performance_pool);
        // $NON-NLS-1$
        confirmModel.setHashName("configuration_changes_for_high_performance_pool");
        confirmModel.getCommands().add(// $NON-NLS-1$
        new UICommand("OnSave_Phase2", PoolListModel.this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        confirmModel.getCommands().add(// $NON-NLS-1$
        UICommand.createCancelUiCommand("CancelConfirmation", PoolListModel.this));
        setConfirmWindow(null);
        setConfirmWindow(confirmModel);
    } else {
        savePoolPostValidation();
    }
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    updateSearchStringFromParameters();
    // Notify model provider that the tab has been revealed
    modelProvider.onMainViewSelected();
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    // Notify model provider that the tab has been revealed
    modelProvider.onMainViewSelected();
}
#end_block

#method_before
@Override
protected void onBind() {
    super.onBind();
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
        // quick switch search is run.
        if (isVisible()) {
            handlePlaceTransition(false);
        }
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getNameToken())));
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList);
        }
    }));
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void onBind() {
    super.onBind();
    getView().setPlaceTransitionHandler(this);
    registerHandler(getTable().getSelectionModel().addSelectionChangeHandler(event -> {
        // Update main model selection
        modelProvider.setSelectedItems(getSelectedItems());
        // Let others know that the table selection has changed
        fireTableSelectionChangeEvent();
    }));
    registerHandler(getEventBus().addHandler(ApplySearchStringEvent.getType(), event -> {
        applySearchString(event.getSearchString());
    }));
    getView().setDetailPlaceTransitionHandler(this);
    registerHandler(getView().addWindowResizeHandler(e -> {
        if (!resizing) {
            Scheduler.get().scheduleDeferred(() -> {
                getView().resizeToFullHeight();
                resizing = false;
            });
            resizing = true;
        }
    }));
    String searchString = searchStringCollector.getSearchStringPrefix(modelProvider.getModel().getSearchString());
    if (searchString != null) {
        // Someone set search string before we were instantiated, update the search string.
        applySearchString(searchString);
    }
    Scheduler.get().scheduleDeferred(() -> addPluginActionButtons(actionButtonPluginHandler.getButtons(getProxy().getNameToken())));
    registerHandler(getEventBus().addHandler(AddActionButtonEvent.getType(), event -> {
        if (getProxy().getNameToken().equals(event.getHistoryToken())) {
            List<ActionButtonDefinition<?>> pluginActionButtonList = new ArrayList<>();
            pluginActionButtonList.add(event.getButtonDefinition());
            addPluginActionButtons(pluginActionButtonList);
        }
    }));
    getModel().getItemsChangedEvent().addListener((ev, sender, args) -> {
        if (this.parameterName != null) {
            switchToName(parameterName);
            parameterName = null;
        }
    });
    getModel().getSelectedItemChangedEvent().addListener((ev, sender, args) -> {
        if (switchToItem != null) {
            // This needs to be deferred otherwise the main view will be shown second overriding this one.
            Scheduler.get().scheduleDeferred(() -> {
                handlePlaceTransition(true);
                switchToItem = null;
            });
        }
    });
    if (hasSearchPanelPresenterWidget()) {
        setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    }
    if (hasActionPanelPresenterWidget()) {
        setInSlot(TYPE_SetActionPanel, getActionPanelPresenterWidget());
    }
}
#end_block

#method_before
public void applySearchString(String searchString) {
    if (modelProvider.getModel() instanceof SearchableListModel) {
        @SuppressWarnings("unchecked")
        SearchableListModel<?, ? extends EntityModel<?>> listModel = modelProvider.getModel();
        if (StringHelper.isNotNullOrEmpty(searchString) && searchString.startsWith(listModel.getDefaultSearchString())) {
            // search string for this model found.
            listModel.setSearchString(searchString);
            listModel.getSearchCommand().execute();
            MainModelSelectionChangeEvent.fire((HasHandlers) getEventBus(), listModel);
        }
    }
}
#method_after
public void applySearchString(String searchString) {
    if (modelProvider.getModel() instanceof SearchableListModel) {
        @SuppressWarnings("unchecked")
        SearchableListModel<?, ? extends EntityModel<?>> listModel = modelProvider.getModel();
        if (StringHelper.isNotNullOrEmpty(searchString) && searchString.startsWith(listModel.getDefaultSearchString())) {
            // search string for this model found.
            listModel.setSearchString(searchString);
            listModel.getSearchCommand().execute();
        }
    }
}
#end_block

#method_before
@Override
protected void onReveal() {
    super.onReveal();
    setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    setInSlot(TYPE_SetBreadCrumbs, breadCrumbsPresenterWidget);
    if (hasActionPanelPresenterWidget()) {
        getTable().setActionMenus(getActionPanelPresenterWidget().getActionButtons());
    }
    breadCrumbsPresenterWidget.rebuildBreadCrumbs();
    getView().resizeToFullHeight();
}
#method_after
@Override
protected void onReveal() {
    super.onReveal();
    setInSlot(TYPE_SetSearchPanel, searchPanelPresenterWidget);
    setInSlot(TYPE_SetBreadCrumbs, breadCrumbsPresenterWidget);
    if (hasActionPanelPresenterWidget()) {
        getTable().setActionMenus(getActionPanelPresenterWidget().getActionButtons());
    }
    breadCrumbsPresenterWidget.hideSelectedName();
    breadCrumbsPresenterWidget.rebuildBreadCrumbs();
    getView().resizeToFullHeight();
    PlaceRequest currentPlace = placeManager.getCurrentPlaceRequest();
    Set<FragmentParams> params = FragmentParams.getParams(currentPlace);
    params.forEach(param -> {
        switch(param) {
            case NAME:
                switchToName(currentPlace.getParameter(FragmentParams.NAME.getName(), ""));
                break;
            case SEARCH:
                String search = currentPlace.getParameter(FragmentParams.SEARCH.getName(), "");
                if (!"".equals(search)) {
                    // We have a search parameter. The tokenizer has already run it through URL decode so we should be
                    // able to simply pass it to setSearchString in the model.
                    applySearchString(getModel().getDefaultSearchString() + search);
                }
                break;
            default:
                break;
        }
    });
}
#end_block

#method_before
@Override
public void handlePlaceTransition(boolean linkClicked) {
    if (hasSelection() && hasSelectionDetails() && linkClicked) {
        // Sub tab panel is shown upon revealing the sub tab, in order to avoid
        // the 'flicker' effect due to the panel still showing previous content
        placeManager.revealPlace(getSubTabRequest());
    } else {
        placeManager.revealPlace(getMainViewRequest());
    }
}
#method_after
@Override
public void handlePlaceTransition(String nameToken, Map<String, String> parameters) {
    final Builder builder = new Builder();
    builder.nameToken(nameToken);
    builder.with(parameters);
    placeManager.revealPlace(builder.build());
}
#end_block

