830
#method_before
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = (getStorageDomain().getStorage() != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && addStorageDomainInIrs()) {
        DbFacade.getInstance().getStorageDomainStaticDao().update(getStorageDomain().getStorageStaticData());
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        updateStorageDomainStatic();
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    initializeStorageDomain();
    // save storage if got from parameters in order to save first empty
    // storage in db and use it later
    String storage = (getStorageDomain().getStorage() != null) ? getStorageDomain().getStorage() : "";
    // set domain storage to empty because not nullable in db and for shared
    // status to be locked
    getStorageDomain().setStorage("");
    addStorageDomainInDb();
    if (StringUtils.isEmpty(storage)) {
        storage = createVG();
    }
    getStorageDomain().setStorage(storage);
    if (StringUtils.isNotEmpty(getStorageDomain().getStorage()) && addStorageDomainInIrs()) {
        updateStorageDomainDynamicFromIrs();
        proceedVGLunsInDb();
        blockStorageDomainHelper.fillMetadataDevicesInfo(getStorageDomain().getStorageStaticData(), getVds().getId());
        storageDomainStaticDao.update(getStorageDomain().getStorageStaticData());
        setSucceeded(true);
    }
}
#end_block

#method_before
protected void proceedVGLunsInDb() {
    final ArrayList<LUNs> luns = (ArrayList<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    TransactionSupport.executeInNewTransaction(() -> {
        for (LUNs lun : luns) {
            proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        return null;
    });
}
#method_after
protected void proceedVGLunsInDb() {
    final ArrayList<LUNs> luns = (ArrayList<LUNs>) runVdsCommand(VDSCommandType.GetVGInfo, new GetVGInfoVDSCommandParameters(getVds().getId(), getStorageDomain().getStorage())).getReturnValue();
    TransactionSupport.executeInNewTransaction(() -> {
        for (LUNs lun : luns) {
            lunHelper.proceedLUNInDb(lun, getStorageDomain().getStorageType(), getStorageDomain().getStorage());
        }
        return null;
    });
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    refreshMigrationPolicies();
    updateMigrationRelatedFields();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
    updateBootMenu();
    getInstanceImages().updateActionsAvailability();
    initGraphicsConsoles();
    updateSoundCard();
}
#end_block

#method_before
public void setValue(T value, boolean fireEvents, boolean fromClick) {
    if (changing) {
        return;
    } else if (value == null) {
        updateCurrentValue(null, fireEvents);
    } else {
        boolean found = false;
        for (T listItem : this.valueList) {
            if (listItem == value || (listItem != null && listItem.equals(value))) {
                // Found the value, show the right thing on the button.
                updateCurrentValue(value, fireEvents);
                found = true;
                break;
            }
        }
        if (!found) {
            addValue(value);
            updateCurrentValue(value, fireEvents);
        }
    }
}
#method_after
protected void setValue(T value, boolean fireEvents, boolean fromClick) {
    if (changing) {
        return;
    } else if (value == null) {
        updateCurrentValue(null, fireEvents);
    } else {
        boolean found = false;
        for (T listItem : this.valueList) {
            if (listItem == value || (listItem != null && listItem.equals(value))) {
                // Found the value, show the right thing on the button.
                updateCurrentValue(value, fireEvents);
                found = true;
                break;
            }
        }
        if (!found) {
            addValue(value);
            updateCurrentValue(value, fireEvents);
        }
    }
}
#end_block

#method_before
@Override
public void setValue(List<T> values, boolean fireEvents, boolean fromClick) {
    // Prevent potential event loops, as well as optimize away multiple set values to the same value.
    if (values != null && lastValues != null && lastValues.equals(values)) {
        return;
    }
    if (fromClick) {
        // Click event can only be one value;
        T value = values.get(0);
        if (selectedList.contains(value)) {
            // Can only remove 1 at a time, so if we get more than 1 we shouldn't remove them.
            selectedList.remove(value);
        } else {
            // Shouldn't get a null value, but in case we do, ignore it.
            if (value != null) {
                selectedList.add(value);
            }
        }
    } else {
        // Received a list of selections from some code, we should clear the selected items, and replace them
        // with the ones received.
        selectedList.clear();
        for (T value : values) {
            if (value != null) {
                selectedList.add(value);
            }
        }
    }
    listPanel.setSelected(selectedList);
    updateCurrentValue(selectedList, fireEvents);
}
#method_after
@Override
protected void setValue(List<T> values, boolean fireEvents, boolean fromClick) {
    // Prevent potential event loops, as well as optimize away multiple set values to the same value.
    if (values != null && lastValues != null && lastValues.equals(values)) {
        return;
    }
    if (fromClick) {
        // Click event can only be one value;
        T value = values.get(0);
        if (selectedList.contains(value)) {
            // Can only remove 1 at a time, so if we get more than 1 we shouldn't remove them.
            selectedList.remove(value);
        } else {
            // Shouldn't get a null value, but in case we do, ignore it.
            if (value != null) {
                selectedList.add(value);
            }
        }
    } else {
        // Received a list of selections from some code, we should clear the selected items, and replace them
        // with the ones received.
        selectedList.clear();
        if (values != null) {
            for (T value : values) {
                if (value != null) {
                    selectedList.add(value);
                }
            }
        }
    }
    listPanel.setSelected(selectedList);
    updateCurrentValue(selectedList, fireEvents);
}
#end_block

#method_before
private boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters, cloneContextAndDetachFromParent());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#method_after
protected boolean activateOrDeactivateNic(VmNic nic, PlugAction plugAction, boolean newNic) {
    ActivateDeactivateVmNicParameters parameters = new ActivateDeactivateVmNicParameters(nic, plugAction, newNic);
    parameters.setVmId(getParameters().getVmId());
    VdcReturnValueBase returnValue = runInternalAction(VdcActionType.ActivateDeactivateVmNic, parameters, cloneContextAndDetachFromParent());
    if (!returnValue.getSucceeded()) {
        propagateFailure(returnValue);
    }
    return returnValue.getSucceeded();
}
#end_block

#method_before
public Optional<Guid> schedule(@NotNull Cluster cluster, @NotNull VM vm, @NotNull List<Guid> hostBlackList, @NotNull List<Guid> hostWhiteList, @NotNull List<Guid> destHostIdList, @NotNull List<String> messages, @NotNull VdsFreeMemoryChecker memoryChecker, @NotNull String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList.isEmpty()) {
            return null;
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent()) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#method_after
public Optional<Guid> schedule(@NotNull Cluster cluster, @NotNull VM vm, @NotNull List<Guid> hostBlackList, @NotNull List<Guid> hostWhiteList, @NotNull List<Guid> destHostIdList, @NotNull List<String> messages, @NotNull VdsFreeMemoryChecker memoryChecker, @NotNull String correlationId) {
    prepareClusterLock(cluster.getId());
    try {
        log.debug("Scheduling started, correlation Id: {}", correlationId);
        checkAllowOverbooking(cluster);
        lockCluster(cluster.getId());
        List<VDS> vdsList = getVdsDao().getAllForClusterWithStatus(cluster.getId(), VDSStatus.Up);
        vdsList = removeBlacklistedHosts(vdsList, hostBlackList);
        vdsList = keepOnlyWhitelistedHosts(vdsList, hostWhiteList);
        refreshCachedPendingValues(vdsList);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), cluster, vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList.isEmpty()) {
            return Optional.empty();
        }
        Optional<Guid> bestHost = selectBestHost(cluster, vm, destHostIdList, vdsList, policy, parameters);
        if (bestHost.isPresent()) {
            Guid bestHostId = bestHost.get();
            getPendingResourceManager().addPending(new PendingCpuCores(bestHostId, vm, vm.getNumOfCpus()));
            VDS bestHostEntity = vdsList.stream().filter(vds -> vds.getId().equals(bestHostId)).findFirst().get();
            getPendingResourceManager().addPending(new PendingMemory(bestHostId, vm, bestHostEntity.getGuestOverhead()));
            getPendingResourceManager().addPending(new PendingOvercommitMemory(bestHostId, vm, vm.getMemSizeMb()));
            getPendingResourceManager().addPending(new PendingVM(bestHostId, vm));
            getPendingResourceManager().notifyHostManagers(bestHostId);
            markVfsAsUsedByVm(vm, bestHostId);
        }
        return bestHost;
    } catch (InterruptedException e) {
        log.error("interrupted", e);
        return Optional.empty();
    } finally {
        releaseCluster(cluster.getId());
        log.debug("Scheduling ended, correlation Id: {}", correlationId);
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return false;
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = findFreeVf();
                if (vfToUse == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#method_after
private boolean failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    return failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#end_block

#method_before
private void plugNic() {
    clearAddressIfPciSlotIsDuplicated(vmDevice);
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isPassthrough()) {
                vfToUse = acquireVF();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return;
                }
                vmDevice.setHostDevice(vfToUse);
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                if (isPassthrough()) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
}
#method_after
private void plugNic() {
    clearAddressIfPciSlotIsDuplicated(vmDevice);
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            if (isPassthrough()) {
                vfToUse = acquireVF();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return;
                }
                networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                vmDevice.setHostDevice(vfToUse);
            }
            if (executePlugOrUnplug(PlugAction.PLUG)) {
                if (isPassthrough()) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
}
#end_block

#method_before
private void unplugNic() {
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
        if (returnValue.getSucceeded()) {
            if (isPassthrough()) {
                clearPassthroughData(vmDevice.getHostDevice());
                runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
            }
        }
    }
}
#method_after
private void unplugNic() {
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        if (executePlugOrUnplug(PlugAction.UNPLUG)) {
            if (isPassthrough()) {
                clearPassthroughData(vmDevice.getHostDevice());
                runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
            }
        }
    }
}
#end_block

#method_before
private String acquireVF() {
    try {
        hostDeviceManager.acquireHostDevicesLock(getVdsId());
        String vfToUse = updateFreeVf();
        networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
        return vfToUse;
    } finally {
        hostDeviceManager.releaseHostDevicesLock(getVdsId());
    }
}
#method_after
private String acquireVF() {
    try {
        hostDeviceManager.acquireHostDevicesLock(getVdsId());
        return findFreeVf();
    } finally {
        hostDeviceManager.releaseHostDevicesLock(getVdsId());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = updateFreeVf();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return false;
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getVm() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (getVm().isHostedEngine() && !getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
        return false;
    }
    if (getNetwork() != null && managementNetworkUtil.isManagementNetwork(getNetwork().getId(), getVm().getClusterId()) && getVm().isManagedHostedEngine()) {
        addValidationMessage(EngineMessage.DEACTIVATE_MANAGEMENT_NETWORK_FOR_HOSTED_ENGINE);
        return false;
    }
    if (!activateDeactivateVmNicAllowed(getVm().getStatus())) {
        addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NIC_VM_STATUS_ILLEGAL);
        return false;
    }
    // HotPlug in the host needs to be called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        setVdsId(getVm().getRunOnVds());
        if (!isNicSupportedForPlugUnPlug()) {
            return false;
        }
        // External networks are handled by their provider, so only check if exists on host for internal networks.
        if (getNetwork() != null && !getNetwork().isExternal() && !isPassthrough() && !networkAttachedToVds(getNetwork().getName(), getVdsId())) {
            addValidationMessage(EngineMessage.ACTIVATE_DEACTIVATE_NETWORK_NOT_IN_VDS);
            return false;
        }
        if (isPassthrough()) {
            if (!checkSriovHotPlugSupported()) {
                return false;
            }
            if (getParameters().getAction() == PlugAction.PLUG) {
                String vfToUse = findFreeVf();
                if (vfToUse == null) {
                    return failValidationCannotPlugPassthroughVnicNoSuitableVf();
                }
            }
        }
    }
    vmDevice = vmDeviceDao.get(new VmDeviceId(getParameters().getNic().getId(), getParameters().getVmId()));
    if (vmDevice == null) {
        addValidationMessage(EngineMessage.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (getParameters().getAction() == PlugAction.PLUG && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
private void failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#method_after
private boolean failValidationCannotPlugPassthroughVnicNoSuitableVf() {
    return failValidation(EngineMessage.CANNOT_PLUG_PASSTHROUGH_VNIC_NO_SUITABLE_VF, String.format("$vnicName %1$s", getInterfaceName()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            boolean shouldAcquireVF = isNicToBePlugged && isPassthrough();
            if (shouldAcquireVF) {
                vfToUse = acquireVF();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return;
                } else {
                    vmDevice.setHostDevice(vfToUse);
                }
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                // TODO MMUCHA: Dear code reviewer! this is testing of 'transitive/implied state'. Shoulnd't here be 'boolean passthroughHotPlug = shouldAcquireVF'? Please advise.
                boolean passthroughHotPlug = vfToUse != null;
                boolean passthroughHotUnplug = isPassthrough() && getParameters().getAction() == PlugAction.UNPLUG;
                if (passthroughHotUnplug) {
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                }
                if (passthroughHotPlug || passthroughHotUnplug) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    boolean isNicToBePlugged = getParameters().getAction() == PlugAction.PLUG;
    if (isNicToBePlugged) {
        clearAddressIfPciSlotIsDuplicated(vmDevice);
    }
    // HotPlug in the host is called only if the Vm is UP
    if (hotPlugVmNicRequired(getVm().getStatus())) {
        boolean externalNetworkIsPlugged = isNicToBePlugged && getNetwork() != null && getNetwork().isExternal();
        if (externalNetworkIsPlugged) {
            plugToExternalNetwork();
        }
        String vfToUse = null;
        try {
            boolean shouldAcquireVF = isNicToBePlugged && isPassthrough();
            if (shouldAcquireVF) {
                vfToUse = acquireVF();
                if (vfToUse == null) {
                    failValidationCannotPlugPassthroughVnicNoSuitableVf();
                    return;
                }
                networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
                vmDevice.setHostDevice(vfToUse);
            }
            VDSReturnValue returnValue = runVdsCommand(getParameters().getAction().getCommandType(), new VmNicDeviceVDSParameters(getVdsId(), getVm(), getParameters().getNic(), vmDevice));
            if (returnValue.getSucceeded()) {
                // TODO MMUCHA: Dear code reviewer! this is testing of 'transitive/implied state'. Shoulnd't here be 'boolean passthroughHotPlug = shouldAcquireVF'? Please advise.
                boolean passthroughHotPlug = vfToUse != null;
                boolean passthroughHotUnplug = isPassthrough() && getParameters().getAction() == PlugAction.UNPLUG;
                if (passthroughHotUnplug) {
                    networkDeviceHelper.setVmIdOnVfs(getVdsId(), null, new HashSet<>(Arrays.asList(vmDevice.getHostDevice())));
                }
                if (passthroughHotPlug || passthroughHotUnplug) {
                    runInternalAction(VdcActionType.RefreshHost, new VdsActionParameters(getVdsId()));
                }
            } else {
                clearPassthroughData(vfToUse);
            }
        } catch (EngineException e) {
            if (externalNetworkIsPlugged && getParameters().isNewNic()) {
                unplugFromExternalNetwork();
            }
            clearPassthroughData(vfToUse);
            throw e;
        }
    }
    // In any case, the device is updated
    TransactionSupport.executeInNewTransaction(updateDevice());
    setSucceeded(true);
}
#end_block

#method_before
private String acquireVF() {
    try {
        hostDeviceManager.acquireHostDevicesLock(getVdsId());
        String vfToUse = updateFreeVf();
        networkDeviceHelper.setVmIdOnVfs(getVdsId(), getVmId(), Collections.singleton(vfToUse));
        return vfToUse;
    } finally {
        hostDeviceManager.releaseHostDevicesLock(getVdsId());
    }
}
#method_after
private String acquireVF() {
    try {
        hostDeviceManager.acquireHostDevicesLock(getVdsId());
        return findFreeVf();
    } finally {
        hostDeviceManager.releaseHostDevicesLock(getVdsId());
    }
}
#end_block

#method_before
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = XmlRpcStringUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = XmlRpcStringUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = StringMapUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = StringMapUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public static String getParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : decode(new String(value.getBytes("iso-8859-1")));
}
#method_after
public static String getParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : decode(new String(value.getBytes(StandardCharsets.UTF_8)));
}
#end_block

#method_before
public static String getFormParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : new String(value.getBytes("iso-8859-1"));
}
#method_after
public static String getFormParameter(HttpServletRequest request, String paramName) throws UnsupportedEncodingException {
    String value = request.getParameter(paramName);
    return value == null ? null : new String(value.getBytes(StandardCharsets.ISO_8859_1));
}
#end_block

#method_before
private static void notifyClientOfLogoutEvent(SsoContext ssoContext, String clientId, String token) throws Exception {
    ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
    String url = clientInfo.getClientNotificationCallback();
    if (StringUtils.isNotEmpty(url)) {
        HttpPost request = createPost(url);
        List<BasicNameValuePair> form = new ArrayList<>(3);
        form.add(new BasicNameValuePair("event", "logout"));
        form.add(new BasicNameValuePair("token", token));
        form.add(new BasicNameValuePair("token_type", "bearer"));
        request.setEntity(new UrlEncodedFormEntity(form));
        execute(request, ssoContext, clientId);
    }
}
#method_after
private static void notifyClientOfLogoutEvent(SsoContext ssoContext, String clientId, String token) throws Exception {
    ClientInfo clientInfo = ssoContext.getClienInfo(clientId);
    String url = clientInfo.getClientNotificationCallback();
    if (StringUtils.isNotEmpty(url)) {
        HttpPost request = createPost(url);
        List<BasicNameValuePair> form = new ArrayList<>(3);
        form.add(new BasicNameValuePair("event", "logout"));
        form.add(new BasicNameValuePair("token", token));
        form.add(new BasicNameValuePair("token_type", "bearer"));
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        execute(request, ssoContext, clientId);
    }
}
#end_block

#method_before
private static HttpPost createPost(String url) throws Exception {
    HttpPost request = new HttpPost();
    request.setURI(new URI(url));
    request.setHeader("Accept", "application/json");
    request.setHeader("Content-Type", "application/x-www-form-urlencoded");
    return request;
}
#method_after
private static HttpPost createPost(String url) throws Exception {
    HttpPost request = new HttpPost();
    request.setURI(new URI(url));
    request.setHeader("Accept", "application/json");
    return request;
}
#end_block

#method_before
public static Map<String, Object> authenticate(HttpServletRequest req, String scope) {
    HttpPost request;
    try {
        request = createPost("/oauth/token");
        setClientIdSecretBasicAuthHeader(request);
        String[] credentials = getUserCredentialsFromHeader(req);
        List<BasicNameValuePair> form = new ArrayList<>(4);
        form.add(new BasicNameValuePair("grant_type", "password"));
        form.add(new BasicNameValuePair("username", credentials[0]));
        form.add(new BasicNameValuePair("password", credentials[1]));
        form.add(new BasicNameValuePair("scope", scope));
        request.setEntity(new UrlEncodedFormEntity(form));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
public static Map<String, Object> authenticate(HttpServletRequest req, String scope) {
    try {
        HttpPost request = createPost("/oauth/token");
        setClientIdSecretBasicAuthHeader(request);
        String[] credentials = getUserCredentialsFromHeader(req);
        List<BasicNameValuePair> form = new ArrayList<>(4);
        form.add(new BasicNameValuePair("grant_type", "password"));
        form.add(new BasicNameValuePair("username", credentials[0]));
        form.add(new BasicNameValuePair("password", credentials[1]));
        form.add(new BasicNameValuePair("scope", scope));
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
private static Map<String, Object> loginWithPasswordImpl(String username, String password, String scope, ExtMap authRecord) {
    try {
        HttpPost request = createPost("/oauth/token");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(5);
        form.add(new BasicNameValuePair("grant_type", "password"));
        form.add(new BasicNameValuePair("username", username));
        form.add(new BasicNameValuePair("password", password));
        form.add(new BasicNameValuePair("scope", scope));
        if (authRecord != null) {
            form.add(new BasicNameValuePair("ovirt_auth_record", new JsonObjectSerializer().serialize(authRecord)));
        }
        request.setEntity(new UrlEncodedFormEntity(form));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
private static Map<String, Object> loginWithPasswordImpl(String username, String password, String scope, ExtMap authRecord) {
    try {
        HttpPost request = createPost("/oauth/token");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(5);
        form.add(new BasicNameValuePair("grant_type", "password"));
        form.add(new BasicNameValuePair("username", username));
        form.add(new BasicNameValuePair("password", password));
        form.add(new BasicNameValuePair("scope", scope));
        if (authRecord != null) {
            form.add(new BasicNameValuePair("ovirt_auth_record", serialize(authRecord)));
        }
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
public static Map<String, Object> revoke(String token, String scope) {
    try {
        HttpPost request = createPost("/oauth/revoke");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(2);
        form.add(new BasicNameValuePair("token", token));
        form.add(new BasicNameValuePair("scope", scope));
        request.setEntity(new UrlEncodedFormEntity(form));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
public static Map<String, Object> revoke(String token, String scope) {
    try {
        HttpPost request = createPost("/oauth/revoke");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(2);
        form.add(new BasicNameValuePair("token", token));
        form.add(new BasicNameValuePair("scope", scope));
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
public static Map<String, Object> getToken(String grantType, String code, String scope, String redirectUri) {
    try {
        HttpPost request = createPost("/oauth/token");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(4);
        form.add(new BasicNameValuePair("grant_type", grantType));
        form.add(new BasicNameValuePair("code", code));
        form.add(new BasicNameValuePair("redirect_uri", redirectUri));
        form.add(new BasicNameValuePair("scope", scope));
        request.setEntity(new UrlEncodedFormEntity(form));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
public static Map<String, Object> getToken(String grantType, String code, String scope, String redirectUri) {
    try {
        HttpPost request = createPost("/oauth/token");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(4);
        form.add(new BasicNameValuePair("grant_type", grantType));
        form.add(new BasicNameValuePair("code", code));
        form.add(new BasicNameValuePair("redirect_uri", redirectUri));
        form.add(new BasicNameValuePair("scope", scope));
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
public static Map<String, Object> getTokenInfo(String token, String scope) {
    try {
        HttpPost request = createPost("/oauth/token-info");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(2);
        form.add(new BasicNameValuePair("token", token));
        if (StringUtils.isNotEmpty(scope)) {
            form.add(new BasicNameValuePair("scope", scope));
        }
        request.setEntity(new UrlEncodedFormEntity(form));
        Map<String, Object> jsonData = getResponse(request);
        Map<String, Object> ovirtData = (Map<String, Object>) jsonData.get("ovirt");
        if (ovirtData != null) {
            Collection<ExtMap> groupIds = (Collection<ExtMap>) ovirtData.get("group_ids");
            if (groupIds != null) {
                ovirtData.put("group_ids", SsoOAuthServiceUtils.processGroupMembershipsFromJson(groupIds));
            }
        }
        return jsonData;
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
public static Map<String, Object> getTokenInfo(String token, String scope) {
    try {
        HttpPost request = createPost("/oauth/token-info");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(2);
        form.add(new BasicNameValuePair("token", token));
        if (StringUtils.isNotEmpty(scope)) {
            form.add(new BasicNameValuePair("scope", scope));
        }
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        Map<String, Object> jsonData = getResponse(request);
        Map<String, Object> ovirtData = (Map<String, Object>) jsonData.get("ovirt");
        if (ovirtData != null) {
            Collection<ExtMap> groupIds = (Collection<ExtMap>) ovirtData.get("group_ids");
            if (groupIds != null) {
                ovirtData.put("group_ids", SsoOAuthServiceUtils.processGroupMembershipsFromJson(groupIds));
            }
        }
        return jsonData;
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
public static Map<String, Object> isSsoDeployed() {
    HttpGet request;
    try {
        request = createGet("/status");
        return getResponse(request);
    } catch (FileNotFoundException ex) {
        return buildMapWithError("server_error", "oVirt Engine is initializing.");
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
public static Map<String, Object> isSsoDeployed() {
    try {
        HttpGet request = createGet("/status");
        return getResponse(request);
    } catch (FileNotFoundException ex) {
        return buildMapWithError("server_error", "oVirt Engine is initializing.");
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
private static Map<String, Object> search(String token, Map<String, Object> params, String queryType, String scope) {
    try {
        HttpPost request = createPost("/oauth/token-info");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(4);
        form.add(new BasicNameValuePair("query_type", queryType));
        form.add(new BasicNameValuePair("scope", scope));
        if (StringUtils.isNotEmpty(token)) {
            form.add(new BasicNameValuePair("token", token));
        }
        if (params != null) {
            form.add(new BasicNameValuePair("params", encode(new JsonObjectSerializer().serialize(params))));
        }
        request.setEntity(new UrlEncodedFormEntity(form));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#method_after
private static Map<String, Object> search(String token, Map<String, Object> params, String queryType, String scope) {
    try {
        HttpPost request = createPost("/oauth/token-info");
        setClientIdSecretBasicAuthHeader(request);
        List<BasicNameValuePair> form = new ArrayList<>(4);
        form.add(new BasicNameValuePair("query_type", queryType));
        form.add(new BasicNameValuePair("scope", scope));
        if (StringUtils.isNotEmpty(token)) {
            form.add(new BasicNameValuePair("token", token));
        }
        if (params != null) {
            form.add(new BasicNameValuePair("params", serialize(params)));
        }
        request.setEntity(new UrlEncodedFormEntity(form, StandardCharsets.UTF_8));
        return getResponse(request);
    } catch (Exception ex) {
        return buildMapWithError("server_error", ex.getMessage());
    }
}
#end_block

#method_before
private static HttpPost createPost(String path) throws Exception {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    String base = config.getProperty("ENGINE_SSO_SERVICE_URL");
    HttpPost request = new HttpPost();
    request.setURI(new URI(base + path));
    request.setHeader("Accept", "application/json");
    request.setHeader("Content-Type", "application/x-www-form-urlencoded");
    request.setHeader("Content-Language", "en-US");
    return request;
}
#method_after
private static HttpPost createPost(String path) throws Exception {
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    String base = config.getProperty("ENGINE_SSO_SERVICE_URL");
    HttpPost request = new HttpPost();
    request.setURI(new URI(base + path));
    request.setHeader("Accept", "application/json");
    request.setHeader("Content-Language", "en-US");
    return request;
}
#end_block

#method_before
private static Map<String, Object> getResponse(HttpUriRequest request) throws Exception {
    try (CloseableHttpResponse response = execute(request)) {
        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_NOT_FOUND) {
            throw new FileNotFoundException();
        }
        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
            try (InputStream input = response.getEntity().getContent()) {
                FiltersHelper.copy(input, os);
            }
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            Thread.currentThread().setContextClassLoader(SsoOAuthServiceUtils.class.getClassLoader());
            try {
                return new JsonObjectDeserializer().deserialize(new String(os.toByteArray(), StandardCharsets.UTF_8.name()), HashMap.class);
            } finally {
                Thread.currentThread().setContextClassLoader(loader);
            }
        }
    }
}
#method_after
private static Map<String, Object> getResponse(HttpUriRequest request) throws Exception {
    try (CloseableHttpResponse response = execute(request)) {
        if (response.getStatusLine().getStatusCode() == HttpStatus.SC_NOT_FOUND) {
            throw new FileNotFoundException();
        }
        try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
            try (InputStream input = response.getEntity().getContent()) {
                FiltersHelper.copy(input, os);
            }
            ClassLoader loader = Thread.currentThread().getContextClassLoader();
            Thread.currentThread().setContextClassLoader(SsoOAuthServiceUtils.class.getClassLoader());
            try {
                return deserialize(new String(os.toByteArray(), StandardCharsets.UTF_8.name()), HashMap.class);
            } finally {
                Thread.currentThread().setContextClassLoader(loader);
            }
        }
    }
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, ActionAfterDeleteHandler.fixParameters(new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    } catch (EngineException e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        throw e;
    }
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
    }
    return vdsReturnValue;
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    if (isDataOperationsByHSM()) {
        CopyImageGroupWithDataCommandParameters p = new CopyImageGroupWithDataCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getDestinationStorageDomainId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), newDiskImage.getVolumeFormat(), true);
        p.setParentParameters(getParameters());
        p.setParentCommand(getActionType());
        p.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
        runInternalAction(VdcActionType.CopyImageGroupWithData, p);
        return true;
    } else {
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
        VDSReturnValue vdsReturnValue;
        try {
            vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostDeleteActionHandler.fixParameters(new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
        } catch (EngineException e) {
            log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
            throw e;
        }
        if (vdsReturnValue.getSucceeded()) {
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
        return vdsReturnValue.getSucceeded();
    }
}
#end_block

#method_before
@Override
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.copyImage;
}
#method_after
@Override
protected AsyncTaskType getTaskType() {
    return isDataOperationsByHSM() ? AsyncTaskType.notSupported : AsyncTaskType.copyImage;
}
#end_block

#method_before
private boolean removeImages() {
    Guid imageToRemoveId = findImageForSameDrive(getParameters().getRemovedSnapshotId());
    switch(getParameters().getSnapshot().getType()) {
        case REGULAR:
            removeOtherImageAndParents(imageToRemoveId, getDiskImage().getParentId());
            break;
        case PREVIEW:
        case STATELESS:
            if (imageToRemoveId != null) {
                removeSnapshot(diskImageDao.get(imageToRemoveId));
            }
            break;
    }
    VDSReturnValue vdsReturnValue = performImageVdsmOperation();
    return vdsReturnValue != null && vdsReturnValue.getSucceeded();
}
#method_after
private boolean removeImages() {
    Guid imageToRemoveId = findImageForSameDrive(getParameters().getRemovedSnapshotId());
    switch(getParameters().getSnapshot().getType()) {
        case REGULAR:
            removeOtherImageAndParents(imageToRemoveId, getDiskImage().getParentId());
            break;
        case PREVIEW:
        case STATELESS:
            if (imageToRemoveId != null) {
                removeSnapshot(diskImageDao.get(imageToRemoveId));
            }
            break;
    }
    return performImageVdsmOperation();
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getStorageIds() != null && !getDiskImage().getStorageIds().isEmpty() ? getDiskImage().getStorageIds().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RestoreAllSnapshots);
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, ActionAfterDeleteHandler.fixParameters(new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true)));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (EngineException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new EngineFault(e, e.getVdsError().getCode()));
        log.info("Image '{}' not exist in Irs", getDiskImage().getImageId());
    }
    return vdsReturnValue;
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getStorageIds() != null && !getDiskImage().getStorageIds().isEmpty() ? getDiskImage().getStorageIds().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RestoreAllSnapshots);
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, PostDeleteActionHandler.fixParameters(new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true)));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (EngineException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new EngineFault(e, e.getVdsError().getCode()));
        log.info("Image '{}' not exist in Irs", getDiskImage().getImageId());
    }
    return vdsReturnValue != null ? vdsReturnValue.getSucceeded() : false;
}
#end_block

#method_before
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryImageParams(List<Guid> guids) {
    return ActionAfterDeleteHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(2), isPostZero(), false));
}
#method_after
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryImageParams(List<Guid> guids) {
    return PostDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(2), isPostZero(), false));
}
#end_block

#method_before
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryConfParams(List<Guid> guids) {
    return ActionAfterDeleteHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(4), isPostZero(), false));
}
#method_after
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryConfParams(List<Guid> guids) {
    return PostDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(4), isPostZero(), false));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    if (getParameters().getVolumeFormat() == null || getParameters().getVolumeType() == null) {
        // At least one of the volume arguments should be copied from the ancestral image.
        fillVolumeInformation(newImage);
    }
    if (getParameters().getVolumeFormat() != null) {
        newImage.setVolumeFormat(getParameters().getVolumeFormat());
    }
    if (getParameters().getVolumeType() != null) {
        newImage.setVolumeType(getParameters().getVolumeType());
    }
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, ActionAfterDeleteHandler.fixParameters(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(newImage), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    ImagesHandler.saveImage(newImage);
    baseDiskDao.save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setActualSize(getDiskImage().getActualSizeInBytes());
    diskImageDynamicDao.save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
    Guid snapshotId = getDiskImage().getImageId();
    // Create new image group id and image id:
    Guid destinationImageGroupID = Guid.newGuid();
    setDestinationImageId(Guid.newGuid());
    DiskImage newImage = cloneDiskImage(getDestinationImageId());
    if (getParameters().getVolumeFormat() == null || getParameters().getVolumeType() == null) {
        // At least one of the volume arguments should be copied from the ancestral image.
        fillVolumeInformation(newImage);
    }
    if (getParameters().getVolumeFormat() != null) {
        newImage.setVolumeFormat(getParameters().getVolumeFormat());
    }
    if (getParameters().getVolumeType() != null) {
        newImage.setVolumeType(getParameters().getVolumeType());
    }
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    VolumeFormat targetFormat = getTargetVolumeFormat(newImage.getVolumeFormat(), newImage.getVolumeType(), getParameters().getDestinationStorageDomainId());
    newImage.setDiskAlias(getParameters().getDiskAlias() != null ? getParameters().getDiskAlias() : getDiskImage().getDiskAlias());
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostDeleteActionHandler.fixParameters(new CopyImageVDSCommandParameters(storagePoolId, getParameters().getStorageDomainId(), getParameters().getVmId(), imageGroupId, snapshotId, destinationImageGroupID, getDestinationImageId(), getJsonDiskDescription(newImage), getParameters().getDestinationStorageDomainId(), CopyVolumeType.SharedVol, targetFormat, newImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getParameters().getStorageDomainId(), getParameters().getDestinationStorageDomainId()));
    newImage.setId(destinationImageGroupID);
    newImage.setDiskDescription(getParameters().getDescription() != null ? getParameters().getDescription() : getDiskImage().getDiskDescription());
    newImage.setVmSnapshotId(getParameters().getVmSnapshotId());
    newImage.setQuotaId(getParameters().getQuotaId());
    newImage.setDiskProfileId(getParameters().getDiskProfileId());
    newImage.setParentId(Guid.Empty);
    newImage.setImageTemplateId(Guid.Empty);
    newImage.setStorageIds(new ArrayList<>(Arrays.asList(getParameters().getDestinationStorageDomainId())));
    newImage.setActive(true);
    ImagesHandler.saveImage(newImage);
    baseDiskDao.save(newImage);
    DiskImageDynamic diskDynamic = new DiskImageDynamic();
    diskDynamic.setId(newImage.getImageId());
    diskDynamic.setActualSize(getDiskImage().getActualSizeInBytes());
    diskImageDynamicDao.save(diskDynamic);
    setActionReturnValue(newImage);
    // set source image as locked:
    lockImage();
    setSucceeded(true);
}
#end_block

#method_before
protected VDSReturnValue mergeSnapshots(Guid storagePoolId, Guid storageDomainId) {
    MergeSnapshotsVDSCommandParameters params = new MergeSnapshotsVDSCommandParameters(storagePoolId, storageDomainId, getVmId(), getDiskImage().getId(), getDiskImage().getImageId(), getDestinationDiskImage().getImageId(), getDiskImage().isWipeAfterDelete());
    return runVdsCommand(VDSCommandType.MergeSnapshots, ActionAfterDeleteHandler.fixParameters(params));
}
#method_after
protected VDSReturnValue mergeSnapshots(Guid storagePoolId, Guid storageDomainId) {
    MergeSnapshotsVDSCommandParameters params = new MergeSnapshotsVDSCommandParameters(storagePoolId, storageDomainId, getVmId(), getDiskImage().getId(), getDiskImage().getImageId(), getDestinationDiskImage().getImageId(), getDiskImage().isWipeAfterDelete());
    return runVdsCommand(VDSCommandType.MergeSnapshots, PostDeleteActionHandler.fixParameters(params));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RemoveVmTemplate);
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DeleteImageGroup, ActionAfterDeleteHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getWipeAfterDelete(), false)));
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RemoveVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId()));
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RemoveVmTemplate);
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.DeleteImageGroup, PostDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getWipeAfterDelete(), false)));
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RemoveVmTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId()));
        setSucceeded(true);
    }
}
#end_block

#method_before
private boolean performStorageOperation() {
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId() : getDiskImage().getStorageIds().get(0);
    if (isUsingSPDMFlow()) {
        CopyImageGroupWithDataCommandParameters p = new CopyImageGroupWithDataCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getImageGroupID(), getParameters().getImageId(), getVolumeFormatForDomain(), getParameters().getUseCopyCollapse());
        p.setParentParameters(getParameters());
        p.setParentCommand(getActionType());
        p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        p.setJobWeight(getParameters().getJobWeight());
        runInternalAction(VdcActionType.CopyImageGroupWithData, p);
        return true;
    } else {
        VDSReturnValue vdsReturnValue;
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        if (getParameters().getUseCopyCollapse()) {
            vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, ActionAfterDeleteHandler.fixParameters(new CopyImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getVolumeFormatForDomain(), getParameters().getVolumeType(), isWipeAfterDelete(), getParameters().getForceOverride())));
        } else {
            vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, ActionAfterDeleteHandler.fixParameters(new MoveImageGroupVDSCommandParameters(getDiskImage() != null ? getDiskImage().getStoragePoolId() : getStorageDomain().getStoragePoolId(), sourceDomainId, getDiskImage() != null ? getDiskImage().getId() : getParameters().getImageGroupID(), getParameters().getStorageDomainId(), getParameters().getContainerId(), ImageOperation.Copy, isWipeAfterDelete(), getParameters().getForceOverride())));
        }
        if (vdsReturnValue.getSucceeded()) {
            AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
            getTaskIdList().add(createTask(taskId, taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        }
        return vdsReturnValue.getSucceeded();
    }
}
#method_after
private boolean performStorageOperation() {
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId() : getDiskImage().getStorageIds().get(0);
    if (isUsingSPDMFlow()) {
        CopyImageGroupWithDataCommandParameters p = new CopyImageGroupWithDataCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getImageGroupID(), getParameters().getImageId(), getVolumeFormatForDomain(), getParameters().getUseCopyCollapse());
        p.setParentParameters(getParameters());
        p.setParentCommand(getActionType());
        p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
        p.setJobWeight(getParameters().getJobWeight());
        runInternalAction(VdcActionType.CopyImageGroupWithData, p);
        return true;
    } else {
        VDSReturnValue vdsReturnValue;
        Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
        if (getParameters().getUseCopyCollapse()) {
            vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostDeleteActionHandler.fixParameters(new CopyImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getVolumeFormatForDomain(), getParameters().getVolumeType(), isWipeAfterDelete(), getParameters().getForceOverride())));
        } else {
            vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, PostDeleteActionHandler.fixParameters(new MoveImageGroupVDSCommandParameters(getDiskImage() != null ? getDiskImage().getStoragePoolId() : getStorageDomain().getStoragePoolId(), sourceDomainId, getDiskImage() != null ? getDiskImage().getId() : getParameters().getImageGroupID(), getParameters().getStorageDomainId(), getParameters().getContainerId(), ImageOperation.Copy, isWipeAfterDelete(), getParameters().getForceOverride())));
        }
        if (vdsReturnValue.getSucceeded()) {
            AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
            getTaskIdList().add(createTask(taskId, taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        }
        return vdsReturnValue.getSucceeded();
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        try {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            VDSReturnValue vdsReturnValue = performImageVdsmOperation();
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getStorageDomainId()));
        } catch (EngineException e) {
            if (e.getErrorCode() == EngineError.ImageDoesNotExistInDomainError) {
                log.info("Disk '{}' doesn't exist on storage domain '{}', rolling forward", getDiskImage().getId(), getStorageDomainId());
            } else // In this case, Engine has to check whether image still exists on the storage or not.
            if (e.getErrorCode() == EngineError.ImageDeleteError && isImageRemovedFromStorage()) {
                log.info("Disk '{}' was deleted from storage domain '{}'", getDiskImage().getId(), getStorageDomainId());
            } else {
                throw e;
            }
        }
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
            performImageDbOperations();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        try {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            VDSReturnValue vdsReturnValue = performDeleteImageVdsmOperation();
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getStorageDomainId()));
        } catch (EngineException e) {
            if (e.getErrorCode() == EngineError.ImageDoesNotExistInDomainError) {
                log.info("Disk '{}' doesn't exist on storage domain '{}', rolling forward", getDiskImage().getId(), getStorageDomainId());
            } else // In this case, Engine has to check whether image still exists on the storage or not.
            if (e.getErrorCode() == EngineError.ImageDeleteError && isImageRemovedFromStorage()) {
                log.info("Disk '{}' was deleted from storage domain '{}'", getDiskImage().getId(), getStorageDomainId());
            } else {
                throw e;
            }
        }
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
            performImageDbOperations();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
private VDSParametersBase createVDSParameters() {
    return ActionAfterDeleteHandler.fixParameters(new DestroyImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageList(), getParameters().isPostZero(), getParameters().isForce()));
}
#method_after
private VDSParametersBase createVDSParameters() {
    return PostDeleteActionHandler.fixParameters(new DestroyImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupId(), getParameters().getImageList(), getParameters().isPostZero(), getParameters().isForce()));
}
#end_block

#method_before
private boolean removeImages() {
    Guid imageToRemoveId = findImageForSameDrive(getParameters().getRemovedSnapshotId());
    switch(getParameters().getSnapshot().getType()) {
        case REGULAR:
            removeOtherImageAndParents(imageToRemoveId, getDiskImage().getParentId());
            break;
        case PREVIEW:
        case STATELESS:
            if (imageToRemoveId != null) {
                removeSnapshot(diskImageDao.get(imageToRemoveId));
            }
            break;
    }
    VDSReturnValue vdsReturnValue = performImageVdsmOperation();
    return vdsReturnValue != null && vdsReturnValue.getSucceeded();
}
#method_after
private boolean removeImages() {
    Guid imageToRemoveId = findImageForSameDrive(getParameters().getRemovedSnapshotId());
    switch(getParameters().getSnapshot().getType()) {
        case REGULAR:
            removeOtherImageAndParents(imageToRemoveId, getDiskImage().getParentId());
            break;
        case PREVIEW:
        case STATELESS:
            if (imageToRemoveId != null) {
                removeSnapshot(diskImageDao.get(imageToRemoveId));
            }
            break;
    }
    return performImageVdsmOperation();
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getStorageIds() != null && !getDiskImage().getStorageIds().isEmpty() ? getDiskImage().getStorageIds().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RestoreAllSnapshots);
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, postDeleteActionHandler.fixParameters(new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true)));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (EngineException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new EngineFault(e, e.getVdsError().getCode()));
        log.info("Image '{}' not exist in Irs", getDiskImage().getImageId());
    }
    return vdsReturnValue;
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    VDSReturnValue vdsReturnValue = null;
    try {
        Guid storagePoolId = getDiskImage().getStoragePoolId() != null ? getDiskImage().getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getDiskImage().getStorageIds() != null && !getDiskImage().getStorageIds().isEmpty() ? getDiskImage().getStorageIds().get(0) : Guid.Empty;
        Guid imageGroupId = getDiskImage().getId() != null ? getDiskImage().getId() : Guid.Empty;
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RestoreAllSnapshots);
        vdsReturnValue = runVdsCommand(VDSCommandType.DestroyImage, postDeleteActionHandler.fixParameters(new DestroyImageVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, _imagesToDelete, getDiskImage().isWipeAfterDelete(), true)));
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RestoreAllSnapshots, VdcObjectType.Storage, storageDomainId));
        }
    }// Don't throw an exception when cannot destroy image in the VDSM.
     catch (EngineException e) {
        // Set fault for parent command RestoreAllSnapshotCommand to use, if decided to fail the command.
        getReturnValue().setFault(new EngineFault(e, e.getVdsError().getCode()));
        log.info("Image '{}' not exist in Irs", getDiskImage().getImageId());
    }
    return vdsReturnValue != null ? vdsReturnValue.getSucceeded() : false;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        try {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            VDSReturnValue vdsReturnValue = performImageVdsmOperation();
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getStorageDomainId()));
        } catch (EngineException e) {
            if (e.getErrorCode() == EngineError.ImageDoesNotExistInDomainError) {
                log.info("Disk '{}' doesn't exist on storage domain '{}', rolling forward", getDiskImage().getId(), getStorageDomainId());
            } else // In this case, Engine has to check whether image still exists on the storage or not.
            if (e.getErrorCode() == EngineError.ImageDeleteError && isImageRemovedFromStorage()) {
                log.info("Disk '{}' was deleted from storage domain '{}'", getDiskImage().getId(), getStorageDomainId());
            } else {
                throw e;
            }
        }
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
            performImageDbOperations();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        try {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            VDSReturnValue vdsReturnValue = performDeleteImageVdsmOperation();
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getStorageDomainId()));
        } catch (EngineException e) {
            if (e.getErrorCode() == EngineError.ImageDoesNotExistInDomainError) {
                log.info("Disk '{}' doesn't exist on storage domain '{}', rolling forward", getDiskImage().getId(), getStorageDomainId());
            } else // In this case, Engine has to check whether image still exists on the storage or not.
            if (e.getErrorCode() == EngineError.ImageDeleteError && isImageRemovedFromStorage()) {
                log.info("Disk '{}' was deleted from storage domain '{}'", getDiskImage().getId(), getStorageDomainId());
            } else {
                throw e;
            }
        }
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
            performImageDbOperations();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
    try {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, postDeleteActionHandler.fixParameters(new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
    } catch (EngineException e) {
        log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
        throw e;
    }
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
    }
    return vdsReturnValue;
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    if (isDataOperationsByHSM()) {
        CopyImageGroupWithDataCommandParameters p = new CopyImageGroupWithDataCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getDestinationStorageDomainId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), newDiskImage.getVolumeFormat(), true);
        p.setParentParameters(getParameters());
        p.setParentCommand(getActionType());
        p.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
        runInternalAction(VdcActionType.CopyImageGroupWithData, p);
        return true;
    } else {
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
        VDSReturnValue vdsReturnValue;
        try {
            vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, postDeleteActionHandler.fixParameters(new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
        } catch (EngineException e) {
            log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
            throw e;
        }
        if (vdsReturnValue.getSucceeded()) {
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
        return vdsReturnValue.getSucceeded();
    }
}
#end_block

#method_before
@Override
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.copyImage;
}
#method_after
@Override
protected AsyncTaskType getTaskType() {
    return isDataOperationsByHSM() ? AsyncTaskType.notSupported : AsyncTaskType.copyImage;
}
#end_block

#method_before
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryImageParams(List<Guid> guids) {
    return Injector.get(PostDeleteActionHandler.class).fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(2), isPostZero(), false));
}
#method_after
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryImageParams(List<Guid> guids) {
    return postDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(2), isPostZero(), false));
}
#end_block

#method_before
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryConfParams(List<Guid> guids) {
    return Injector.get(PostDeleteActionHandler.class).fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(4), isPostZero(), false));
}
#method_after
@Override
protected DeleteImageGroupVDSCommandParameters buildDeleteMemoryConfParams(List<Guid> guids) {
    return postDeleteActionHandler.fixParameters(new DeleteImageGroupVDSCommandParameters(guids.get(1), guids.get(0), guids.get(4), isPostZero(), false));
}
#end_block

#method_before
private static void mapDiskToDiskImageProperties(Disk disk, DiskImage diskImage) {
    if (disk.isSetImageId()) {
        diskImage.setImageId(GuidUtils.asGuid(disk.getImageId()));
    }
    if (disk.isSetProvisionedSize()) {
        diskImage.setSize(disk.getProvisionedSize());
    }
    if (disk.isSetFormat()) {
        diskImage.setVolumeFormat(map(disk.getFormat(), null));
    }
    if (disk.isSetQcowVersion()) {
        diskImage.setQcowCompat(map(disk.getQcowVersion(), null));
    }
    if (disk.isSetStatus()) {
        diskImage.setImageStatus(mapDiskStatus(disk.getStatus()));
    }
    if (disk.isSetSnapshot() && disk.getSnapshot().isSetId()) {
        diskImage.setVmSnapshotId(GuidUtils.asGuid(disk.getSnapshot().getId()));
    }
    if (disk.isSetSparse()) {
        diskImage.setVolumeType(disk.isSparse() ? VolumeType.Sparse : VolumeType.Preallocated);
    }
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        diskImage.setStorageIds(new ArrayList<>());
        diskImage.getStorageIds().add(Guid.createGuidFromStringDefaultEmpty(storageDomain.getId()));
    }
    if (disk.isSetQuota() && disk.getQuota().isSetId()) {
        diskImage.setQuotaId(GuidUtils.asGuid(disk.getQuota().getId()));
    }
    if (disk.isSetDiskProfile() && disk.getDiskProfile().isSetId()) {
        diskImage.setDiskProfileId(GuidUtils.asGuid(disk.getDiskProfile().getId()));
    }
    if (disk.isSetOpenstackVolumeType() && disk.getOpenstackVolumeType().isSetName()) {
        diskImage.setCinderVolumeType(disk.getOpenstackVolumeType().getName());
    }
}
#method_after
private static void mapDiskToDiskImageProperties(Disk disk, DiskImage diskImage) {
    if (disk.isSetImageId()) {
        diskImage.setImageId(GuidUtils.asGuid(disk.getImageId()));
    }
    if (disk.isSetProvisionedSize()) {
        diskImage.setSize(disk.getProvisionedSize());
    }
    if (disk.isSetFormat()) {
        diskImage.setVolumeFormat(map(disk.getFormat(), null));
    }
    if (disk.isSetQcowVersion()) {
        diskImage.setQcowCompat(mapQcowVersion(disk.getQcowVersion()));
    }
    if (disk.isSetStatus()) {
        diskImage.setImageStatus(mapDiskStatus(disk.getStatus()));
    }
    if (disk.isSetSnapshot() && disk.getSnapshot().isSetId()) {
        diskImage.setVmSnapshotId(GuidUtils.asGuid(disk.getSnapshot().getId()));
    }
    if (disk.isSetSparse()) {
        diskImage.setVolumeType(disk.isSparse() ? VolumeType.Sparse : VolumeType.Preallocated);
    }
    if (disk.isSetStorageDomains() && disk.getStorageDomains().isSetStorageDomains() && disk.getStorageDomains().getStorageDomains().get(0).isSetId()) {
        StorageDomain storageDomain = disk.getStorageDomains().getStorageDomains().get(0);
        diskImage.setStorageIds(new ArrayList<>());
        diskImage.getStorageIds().add(Guid.createGuidFromStringDefaultEmpty(storageDomain.getId()));
    }
    if (disk.isSetQuota() && disk.getQuota().isSetId()) {
        diskImage.setQuotaId(GuidUtils.asGuid(disk.getQuota().getId()));
    }
    if (disk.isSetDiskProfile() && disk.getDiskProfile().isSetId()) {
        diskImage.setDiskProfileId(GuidUtils.asGuid(disk.getDiskProfile().getId()));
    }
    if (disk.isSetOpenstackVolumeType() && disk.getOpenstackVolumeType().isSetName()) {
        diskImage.setCinderVolumeType(disk.getOpenstackVolumeType().getName());
    }
}
#end_block

#method_before
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setProvisionedSize(entity.getSize());
    if (entity.hasActualSize()) {
        model.setActualSize(entity.getActualSizeInBytes());
    }
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getQcowCompat() != null) {
        model.setQcowVersion(map(entity.getQcowCompat(), null));
    }
    if (entity.getImageStatus() != null) {
        model.setStatus(mapDiskStatus(entity.getImageStatus()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#method_after
private static void mapDiskImageToDiskFields(DiskImage entity, Disk model) {
    if (entity.getImageId() != null) {
        model.setImageId(entity.getImageId().toString());
    }
    model.setProvisionedSize(entity.getSize());
    if (entity.hasActualSize()) {
        model.setActualSize(entity.getActualSizeInBytes());
    }
    if (entity.getSnapshotId() != null) {
        model.setSnapshot(new Snapshot());
        model.getSnapshot().setId(entity.getSnapshotId().toString());
    }
    if (entity.getVolumeFormat() != null) {
        model.setFormat(map(entity.getVolumeFormat(), null));
    }
    if (entity.getQcowCompat() != null) {
        model.setQcowVersion(mapQcowCompat(entity.getQcowCompat()));
    }
    if (entity.getImageStatus() != null) {
        model.setStatus(mapDiskStatus(entity.getImageStatus()));
    }
    model.setSparse(VolumeType.Sparse == entity.getVolumeType());
    if (entity.getStorageIds() != null && entity.getStorageIds().size() > 0) {
        if (!model.isSetStorageDomains()) {
            model.setStorageDomains(new StorageDomains());
        }
        for (Guid id : entity.getStorageIds()) {
            StorageDomain storageDomain = new StorageDomain();
            storageDomain.setId(id.toString());
            model.getStorageDomains().getStorageDomains().add(storageDomain);
        }
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    if (entity.getDiskProfileId() != null) {
        DiskProfile diskProfile = new DiskProfile();
        diskProfile.setId(entity.getDiskProfileId().toString());
        model.setDiskProfile(diskProfile);
    }
    if (entity.getCinderVolumeType() != null) {
        OpenStackVolumeType volumeType = model.getOpenstackVolumeType();
        if (volumeType == null) {
            volumeType = new OpenStackVolumeType();
            model.setOpenstackVolumeType(volumeType);
        }
        volumeType.setName(entity.getCinderVolumeType());
    }
}
#end_block

#method_before
@Override
public void close() {
    XmlRpcUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#method_after
@Override
public void close() {
    HttpUtils.shutDownConnection(this.httpClient);
    this.client.close();
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public OneVmReturnForXmlRpc create(Map createInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.create").withParameter("vmID", getVmId(createInfo)).withParameter("vmParams", createInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public OneVmReturn create(Map createInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.create").withParameter("vmID", getVmId(createInfo)).withParameter("vmParams", createInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc allocateVolume(String spUUID, String sdUUID, String imgGUID, String volUUID, String size) {
    JsonRpcRequest request = new RequestBuilder("Volume.allocate").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn allocateVolume(String spUUID, String sdUUID, String imgGUID, String volUUID, String size) {
    JsonRpcRequest request = new RequestBuilder("Volume.allocate").withParameter("volumeID", volUUID).withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgGUID).withParameter("size", size).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
@SuppressWarnings("rawtypes")
public StatusOnlyReturn copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createVolumeContainer(String jobId, Map<String, Object> createVolumeInfo) {
    JsonRpcRequest request = new RequestBuilder("SDM.create_volume").withParameter("job_id", jobId).withParameter("vol_info", createVolumeInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc destroy(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.destroy").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn destroy(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.destroy").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn shutdown(String vmId, String timeout, String message) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc shutdown(String vmId, String timeout, String message, boolean reboot) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).withParameter("reboot", reboot).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn shutdown(String vmId, String timeout, String message, boolean reboot) {
    JsonRpcRequest request = new RequestBuilder("VM.shutdown").withParameter("vmID", vmId).withOptionalParameter("delay", timeout).withOptionalParameter("message", message).withParameter("reboot", reboot).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc pause(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.pause").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn pause(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.pause").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hibernate(String vmId, String hiberVolHandle) {
    JsonRpcRequest request = new RequestBuilder("VM.hibernate").withParameter("vmID", vmId).withParameter("hibernationVolHandle", hiberVolHandle).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn hibernate(String vmId, String hiberVolHandle) {
    JsonRpcRequest request = new RequestBuilder("VM.hibernate").withParameter("vmID", vmId).withParameter("hibernationVolHandle", hiberVolHandle).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc resume(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.cont").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn resume(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.cont").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn list() {
    JsonRpcRequest request = new RequestBuilder("Host.getVMList").withOptionalParameterAsList("vmList", new ArrayList<>(Arrays.asList(new String[] {}))).withParameter("onlyUUID", false).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc fullList(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn fullList(List<String> vmIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getVMFullList").withOptionalParameterAsList("vmList", vmIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getCapabilities() {
    JsonRpcRequest request = new RequestBuilder("Host.getCapabilities").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getHardwareInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getHardwareInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public VDSInfoReturnForXmlRpc getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VDSInfoReturn getVdsStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new VDSInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setMOMPolicyParameters(Map<String, Object> values) {
    JsonRpcRequest request = new RequestBuilder("Host.setMOMPolicyParameters").withParameter("key_value_store", values).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setMOMPolicyParameters(Map<String, Object> values) {
    JsonRpcRequest request = new RequestBuilder("Host.setMOMPolicyParameters").withParameter("key_value_store", values).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc desktopLogin(String vmId, String domain, String user, String password) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogin").withParameter("vmID", vmId).withParameter("domain", domain).withParameter("username", user).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn desktopLogin(String vmId, String domain, String user, String password) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogin").withParameter("vmID", vmId).withParameter("domain", domain).withParameter("username", user).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc desktopLogoff(String vmId, String force) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogoff").withParameter("vmID", vmId).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn desktopLogoff(String vmId, String force) {
    JsonRpcRequest request = new RequestBuilder("VM.desktopLogoff").withParameter("vmID", vmId).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public VMInfoListReturnForXmlRpc getVmStats(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getStats").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList");
    return new VMInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public VMInfoListReturn getVmStats(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getStats").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList");
    return new VMInfoListReturn(response);
}
#end_block

#method_before
@Override
public VMInfoListReturnForXmlRpc getAllVmStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllVmStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList").withResponseType(Object[].class);
    return new VMInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public VMInfoListReturn getAllVmStats() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllVmStats").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsList").withResponseType(Object[].class);
    return new VMInfoListReturn(response);
}
#end_block

#method_before
@Override
public HostDevListReturnForXmlRpc hostDevListByCaps() {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevListByCaps").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("deviceList");
    return new HostDevListReturnForXmlRpc(response);
}
#method_after
@Override
public HostDevListReturn hostDevListByCaps() {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevListByCaps").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("deviceList");
    return new HostDevListReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn migrate(Map<String, Object> migrationInfo) {
    JsonRpcRequest request = new RequestBuilder("VM.migrate").withParameter("vmID", getVmId(migrationInfo)).withParameter("params", migrationInfo).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public MigrateStatusReturnForXmlRpc migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturnForXmlRpc(response);
}
#method_after
@Override
public MigrateStatusReturn migrateStatus(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.getMigrationStatus").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("response").withResponseType(Long.class);
    return new MigrateStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc migrateCancel(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.migrateCancel").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn migrateCancel(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.migrateCancel").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeDisk(String vmId, String imageLocation) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeDisk(String vmId, Map<String, Object> driveSpec) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", driveSpec).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeDisk(String vmId, Map<String, Object> driveSpec) {
    JsonRpcRequest request = new RequestBuilder("VM.changeCD").withParameter("vmID", vmId).withParameter("driveSpec", driveSpec).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn changeFloppy(String vmId, String imageLocation) {
    // TODO DriveSpec should be used instead of imageLocation
    JsonRpcRequest request = new RequestBuilder("VM.changeFloppy").withParameter("vmID", vmId).withParameter("driveSpec", imageLocation).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList");
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn addNetwork(String bridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.addNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn delNetwork(String bridge, String vlan, String bond, String[] nics) {
    // No options params (do we need it during this operation)
    JsonRpcRequest request = new RequestBuilder("Host.delNetwork").withParameter("bridge", bridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn editNetwork(String oldBridge, String newBridge, String vlan, String bond, String[] nics, Map<String, String> options) {
    JsonRpcRequest request = new RequestBuilder("Host.editNetwork").withParameter("oldBridge", oldBridge).withParameter("newBridge", newBridge).withOptionalParameter("vlan", vlan).withOptionalParameter("bond", bond).withOptionalParameterAsList("nics", new ArrayList<>(Arrays.asList(nics))).withOptionalParameterAsMap("options", options).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setSafeNetworkConfig() {
    JsonRpcRequest request = new RequestBuilder("Host.setSafeNetworkConfig").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setSafeNetworkConfig() {
    JsonRpcRequest request = new RequestBuilder("Host.setSafeNetworkConfig").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public FenceStatusReturnForXmlRpc fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturnForXmlRpc(response);
}
#method_after
@Override
public FenceStatusReturn fenceNode(String ip, String port, String type, String user, String password, String action, String secured, String options, Map<String, Object> fencingPolicy) {
    JsonRpcRequest request = new RequestBuilder("Host.fenceNode").withParameter("addr", ip).withParameter("port", port).withParameter("agent", type).withParameter("username", user).withParameter("password", password).withParameter("action", action).withOptionalParameter("secure", secured).withOptionalParameter("options", options).withOptionalParameterAsMap("policy", fencingPolicy).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new FenceStatusReturn(response);
}
#end_block

#method_before
@Override
public ServerConnectionStatusReturnForXmlRpc connectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturnForXmlRpc(response);
}
#method_after
@Override
public ServerConnectionStatusReturn connectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturn(response);
}
#end_block

#method_before
@Override
public ServerConnectionStatusReturnForXmlRpc disconnectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturnForXmlRpc(response);
}
#method_after
@Override
public ServerConnectionStatusReturn disconnectStorageServer(int serverType, String spUUID, Map<String, String>[] args) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnectStorageServer").withParameter("storagepoolID", spUUID).withParameter("domainType", serverType).withParameter("connectionParams", args).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statuslist").withResponseType(Object[].class);
    return new ServerConnectionStatusReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createStorageDomain(int domainType, String sdUUID, String domainName, String arg, int storageType, String storageFormatType) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.create").withParameter("storagedomainID", sdUUID).withParameter("domainType", domainType).withParameter("typeArgs", arg).withParameter("name", domainName).withParameter("domainClass", storageType).withOptionalParameter("version", storageFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc formatStorageDomain(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.format").withParameter("storagedomainID", sdUUID).withParameter("autoDetach", false).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn formatStorageDomain(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.format").withParameter("storagedomainID", sdUUID).withParameter("autoDetach", false).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn connectStoragePool(String spUUID, int hostSpmId, String SCSIKey, String masterdomainId, int masterVersion, Map<String, String> storageDomains) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.connect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).withParameter("masterSdUUID", masterdomainId).withParameter("masterVersion", masterVersion).withOptionalParameterAsMap("domainDict", storageDomains).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc disconnectStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn disconnectStoragePool(String spUUID, int hostSpmId, String SCSIKey) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.disconnect").withParameter("storagepoolID", spUUID).withParameter("hostID", hostSpmId).withParameter("scsiKey", SCSIKey).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn createStoragePool(int poolType, String spUUID, String poolName, String msdUUID, String[] domList, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries) {
    // poolType and lockPolicy not used in vdsm. We can remove from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.create").withParameter("storagepoolID", spUUID).withParameter("name", poolName).withParameter("masterSdUUID", msdUUID).withParameter("masterVersion", masterVersion).withParameter("domainList", new ArrayList<>(Arrays.asList(domList))).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    // no lockPolicy and hostSpmId not needed can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.reconstructMaster").withParameter("storagepoolID", spUUID).withParameter("hostId", hostSpmId).withParameter("name", poolName).withParameter("masterSdUUID", masterDom).withParameter("masterVersion", masterVersion).withParameter("domainDict", domDict).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn reconstructMaster(String spUUID, String poolName, String masterDom, Map<String, String> domDict, int masterVersion, String lockPolicy, int lockRenewalIntervalSec, int leaseTimeSec, int ioOpTimeoutSec, int leaseRetries, int hostSpmId) {
    // no lockPolicy and hostSpmId not needed can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.reconstructMaster").withParameter("storagepoolID", spUUID).withParameter("hostId", hostSpmId).withParameter("name", poolName).withParameter("masterSdUUID", masterDom).withParameter("masterVersion", masterVersion).withParameter("domainDict", domDict).withParameter("lockRenewalIntervalSec", lockRenewalIntervalSec).withParameter("leaseTimeSec", leaseTimeSec).withParameter("ioOpTimeoutSec", ioOpTimeoutSec).withParameter("leaseRetries", leaseRetries).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDomainStatsReturnForXmlRpc getStorageDomainStats(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getStats").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new OneStorageDomainStatsReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDomainStatsReturn getStorageDomainStats(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getStats").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("stats");
    return new OneStorageDomainStatsReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDomainInfoReturnForXmlRpc getStorageDomainInfo(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getInfo").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneStorageDomainInfoReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDomainInfoReturn getStorageDomainInfo(String sdUUID) {
    JsonRpcRequest request = new RequestBuilder("StorageDomain.getInfo").withParameter("storagedomainID", sdUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneStorageDomainInfoReturn(response);
}
#end_block

#method_before
@Override
public StorageDomainListReturnForXmlRpc getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDomainListReturn getStorageDomainsList(String spUUID, int domainType, String poolType, String path) {
    JsonRpcRequest request = new RequestBuilder("Host.getStorageDomains").withParameter("storagepoolID", spUUID).withParameter("domainClass", domainType).withParameter("storageType", poolType).withParameter("remotePath", path).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("domlist").withResponseType(Object[].class);
    return new StorageDomainListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn createVG(String sdUUID, String[] deviceList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.create").withParameter("name", sdUUID).withParameter("devlist", new ArrayList<>(Arrays.asList(deviceList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid");
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public OneVGReturnForXmlRpc getVGInfo(String vgUUID) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.getInfo").withParameter("lvmvolumegroupID", vgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneVGReturnForXmlRpc(response);
}
#method_after
@Override
public OneVGReturn getVGInfo(String vgUUID) {
    JsonRpcRequest request = new RequestBuilder("LVMVolumeGroup.getInfo").withParameter("lvmvolumegroupID", vgUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("info");
    return new OneVGReturn(response);
}
#end_block

#method_before
@Override
public LUNListReturnForXmlRpc getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturnForXmlRpc(response);
}
#method_after
@Override
public LUNListReturn getDeviceList(int storageType, String[] devicesList, boolean checkStatus) {
    ArrayList<String> devicesListArray = devicesList != null ? new ArrayList<>(Arrays.asList(devicesList)) : null;
    JsonRpcRequest request = new RequestBuilder("Host.getDeviceList").withParameter("storageType", storageType).withOptionalParameterAsList("guids", devicesListArray).withParameter("checkStatus", checkStatus).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseType(Object[].class).withResponseKey("devList");
    return new LUNListReturn(response);
}
#end_block

#method_before
@Override
public DevicesVisibilityMapReturnForXmlRpc getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturnForXmlRpc(response);
}
#method_after
@Override
public DevicesVisibilityMapReturn getDevicesVisibility(String[] devicesList) {
    JsonRpcRequest request = new RequestBuilder("Host.getDevicesVisibility").withParameter("guidList", new ArrayList<>(Arrays.asList(devicesList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("visible");
    return new DevicesVisibilityMapReturn(response);
}
#end_block

#method_before
@Override
public IQNListReturnForXmlRpc discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturnForXmlRpc(response);
}
#method_after
@Override
public IQNListReturn discoverSendTargets(Map<String, String> args) {
    JsonRpcRequest request = new RequestBuilder("ISCSIConnection.discoverSendTargets").withParameter("host", args.get("connection")).withParameter("port", args.get("port")).withOptionalParameter("user", args.get("user")).withOptionalParameter("password", args.get("password")).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("fullTargets");
    return new IQNListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn spmStart(String spUUID, int prevID, String prevLVER, int recoveryMode, String SCSIFencing, int maxHostId, String storagePoolFormatType) {
    // storagePoolFormatType not used and can be removed from the interface
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStart").withParameter("storagepoolID", spUUID).withParameter("prevID", prevID).withParameter("prevLver", prevLVER).withParameter("enableScsiFencing", SCSIFencing).withParameter("maxHostID", maxHostId).withOptionalParameter("domVersion", storagePoolFormatType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("uuid").withResponseType(String.class);
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc spmStop(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStop").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn spmStop(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.spmStop").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public SpmStatusReturnForXmlRpc spmStatus(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getSpmStatus").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("spm_st");
    return new SpmStatusReturnForXmlRpc(response);
}
#method_after
@Override
public SpmStatusReturn spmStatus(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getSpmStatus").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("spm_st");
    return new SpmStatusReturn(response);
}
#end_block

#method_before
@Override
public HostJobsReturnForXmlRpc getHostJobs(String jobType, List<String> jobIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getJobs").withOptionalParameter("job_type", jobType).withOptionalParameterAsList("job_ids", jobIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("jobs");
    return new HostJobsReturnForXmlRpc(response);
}
#method_after
@Override
public HostJobsReturn getHostJobs(String jobType, List<String> jobIds) {
    JsonRpcRequest request = new RequestBuilder("Host.getJobs").withOptionalParameter("job_type", jobType).withOptionalParameterAsList("job_ids", jobIds).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("jobs");
    return new HostJobsReturn(response);
}
#end_block

#method_before
@Override
public TaskStatusReturnForXmlRpc getTaskStatus(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.getStatus").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("taskStatus");
    return new TaskStatusReturnForXmlRpc(response);
}
#method_after
@Override
public TaskStatusReturn getTaskStatus(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.getStatus").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("taskStatus");
    return new TaskStatusReturn(response);
}
#end_block

#method_before
@Override
public TaskStatusListReturnForXmlRpc getAllTasksStatuses() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksStatuses").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksStatus");
    return new TaskStatusListReturnForXmlRpc(response);
}
#method_after
@Override
public TaskStatusListReturn getAllTasksStatuses() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksStatuses").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksStatus");
    return new TaskStatusListReturn(response);
}
#end_block

#method_before
@Override
public TaskInfoListReturnForXmlRpc getAllTasksInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksInfo");
    return new TaskInfoListReturnForXmlRpc(response);
}
#method_after
@Override
public TaskInfoListReturn getAllTasksInfo() {
    JsonRpcRequest request = new RequestBuilder("Host.getAllTasksInfo").build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("allTasksInfo");
    return new TaskInfoListReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc stopTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.stop").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn stopTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.stop").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc clearTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.clear").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn clearTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.clear").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc revertTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.revert").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn revertTask(String taskUUID) {
    JsonRpcRequest request = new RequestBuilder("Task.revert").withParameter("taskID", taskUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotunplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotunplugDisk(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugDisk").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotPlugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotPlugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc hotUnplugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn hotUnplugNic(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotunplugNic").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc vmUpdateDevice(String vmId, Map device) {
    JsonRpcRequest request = new RequestBuilder("VM.updateDevice").withParameter("vmID", vmId).withParameter("params", device).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn vmUpdateDevice(String vmId, Map device) {
    JsonRpcRequest request = new RequestBuilder("VM.updateDevice").withParameter("vmID", vmId).withParameter("params", device).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks) {
    return snapshot(vmId, disks, null, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks, String memory) {
    return snapshot(vmId, disks, memory, false);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn snapshot(String vmId, Map<String, String>[] disks, String memory, boolean frozen) {
    JsonRpcRequest request = new RequestBuilder("VM.snapshot").withParameter("vmID", vmId).withParameter("snapDrives", new ArrayList<>(Arrays.asList(disks))).withOptionalParameter("snapMemory", memory).withParameter("frozen", frozen).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public AlignmentScanReturnForXmlRpc getDiskAlignment(String vmId, Map<String, String> driveSpecs) {
    JsonRpcRequest request = new RequestBuilder("VM.getDiskAlignment").withParameter("vmID", vmId).withParameter("disk", driveSpecs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("alignment");
    return new AlignmentScanReturnForXmlRpc(response);
}
#method_after
@Override
public AlignmentScanReturn getDiskAlignment(String vmId, Map<String, String> driveSpecs) {
    JsonRpcRequest request = new RequestBuilder("VM.getDiskAlignment").withParameter("vmID", vmId).withParameter("disk", driveSpecs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("alignment");
    return new AlignmentScanReturn(response);
}
#end_block

#method_before
@Override
public ImageSizeReturnForXmlRpc diskSizeExtend(String vmId, Map<String, String> diskParams, String newSize) {
    JsonRpcRequest request = new RequestBuilder("VM.diskSizeExtend").withParameter("vmID", vmId).withParameter("driveSpecs", diskParams).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ImageSizeReturnForXmlRpc(response);
}
#method_after
@Override
public ImageSizeReturn diskSizeExtend(String vmId, Map<String, String> diskParams, String newSize) {
    JsonRpcRequest request = new RequestBuilder("VM.diskSizeExtend").withParameter("vmID", vmId).withParameter("driveSpecs", diskParams).withParameter("newSize", newSize).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("size");
    return new ImageSizeReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc merge(String vmId, Map<String, String> drive, String baseVolUUID, String topVolUUID, String bandwidth, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("VM.merge").withParameter("vmID", vmId).withParameter("drive", drive).withParameter("baseVolUUID", baseVolUUID).withParameter("topVolUUID", topVolUUID).withParameter("bandwidth", bandwidth).withParameter("jobUUID", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn merge(String vmId, Map<String, String> drive, String baseVolUUID, String topVolUUID, String bandwidth, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("VM.merge").withParameter("vmID", vmId).withParameter("drive", drive).withParameter("baseVolUUID", baseVolUUID).withParameter("topVolUUID", topVolUUID).withParameter("bandwidth", bandwidth).withParameter("jobUUID", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withParameter("arbiter", isArbiter).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSet(String volumeName, String key, String value) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.set").withParameter("volumeName", volumeName).withParameter("option", key).withParameter("value", value).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSet(String volumeName, String key, String value) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.set").withParameter("volumeName", volumeName).withParameter("option", key).withParameter("value", value).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStart(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.start").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeStart(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.start").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeStop(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.stop").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeStop(String volumeName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.stop").withParameter("volumeName", volumeName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.delete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeDelete(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.delete").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeReset(String volumeName, String volumeOption, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.reset").withParameter("volumeName", volumeName).withParameter("option", volumeOption).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeReset(String volumeName, String volumeOption, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.reset").withParameter("volumeName", volumeName).withParameter("option", volumeOption).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeOptionsInfoReturnForXmlRpc glusterVolumeSetOptionsList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.setOptionsList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeOptionsInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeOptionsInfoReturn glusterVolumeSetOptionsList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.setOptionsList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeOptionsInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturn glusterVolumeRemoveBricksStart(String volumeName, String[] brickList, int replicaCount, Boolean forceRemove) {
    String command = "GlusterVolume.removeBrickStart";
    if (forceRemove) {
        command = "GlusterVolume.removeBrickForce";
    }
    JsonRpcRequest request = new RequestBuilder(command).withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRemoveBricksStop(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStop").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeRemoveBricksCommit(String volumeName, String[] brickList, int replicaCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickCommit").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeBrickAdd(String volumeName, String[] bricks, int replicaCount, int stripeCount, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.addBrick").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricks))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStart").withParameter("volumeName", volumeName).withParameter("rebalanceType", fixLayoutOnly).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTaskInfoReturn glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStart").withParameter("volumeName", volumeName).withParameter("rebalanceType", fixLayoutOnly).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTaskInfoReturn(response);
}
#end_block

#method_before
@Override
public BooleanReturnForXmlRpc glusterVolumeEmptyCheck(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.volumeEmptyCheck").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new BooleanReturnForXmlRpc(response, "volumeEmptyCheck");
}
#method_after
@Override
public BooleanReturn glusterVolumeEmptyCheck(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.volumeEmptyCheck").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new BooleanReturn(response, "volumeEmptyCheck");
}
#end_block

#method_before
@Override
public GlusterHostsPubKeyReturnForXmlRpc glusterGeoRepKeysGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysGet").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterHostsPubKeyReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHostsPubKeyReturn glusterGeoRepKeysGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysGet").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterHostsPubKeyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterGeoRepKeysUpdate(List<String> geoRepPubKeys, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepKeysUpdate").withParameter("geoRepPubKeys", geoRepPubKeys).withOptionalParameter("userName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterGeoRepMountBrokerSetup(String remoteVolumeName, String userName, String remoteGroupName, Boolean partial) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepMountBrokerSetup").withParameter("remoteVolumeName", remoteVolumeName).withParameter("partial", partial).withOptionalParameter("remoteUserName", userName).withOptionalParameter("remoteGroupName", remoteGroupName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionCreate(String volumeName, String remoteHost, String remotVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionCreate").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remotVolumeName).withParameter("force", force).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionResume(String volumeName, String slaveHostName, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionResume").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHostName).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRebalanceStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeReplaceBrickCommitForce(String volumeName, String existingBrickDir, String newBrickDir) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.replaceBrickCommitForce").withParameter("volumeName", volumeName).withParameter("existingBrick", existingBrickDir).withParameter("newBrick", newBrickDir).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeReplaceBrickCommitForce(String volumeName, String existingBrickDir, String newBrickDir) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.replaceBrickCommitForce").withParameter("volumeName", volumeName).withParameter("existingBrick", existingBrickDir).withParameter("newBrick", newBrickDir).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHostRemove(String hostName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.remove").withParameter("hostName", hostName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHostRemove(String hostName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.remove").withParameter("hostName", hostName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHostAdd(String hostName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.add").withParameter("hostName", hostName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHostAdd(String hostName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.add").withParameter("hostName", hostName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionDelete(String volumeName, String remoteHost, String remoteVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionDelete").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionStop(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStop").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterServersListReturnForXmlRpc glusterServersList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServersListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterServersListReturn glusterServersList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServersListReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateStart").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn diskReplicateStart(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateStart").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateFinish").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn diskReplicateFinish(String vmUUID, Map srcDisk, Map dstDisk) {
    JsonRpcRequest request = new RequestBuilder("VM.diskReplicateFinish").withParameter("vmID", vmUUID).withParameter("srcDisk", srcDisk).withParameter("dstDisk", dstDisk).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeProfileStart(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStart").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeProfileStart(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStart").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeProfileStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeProfileStop(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileStop").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionPause(String masterVolumeName, String slaveHost, String slaveVolumeName, String userName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionPause").withParameter("volumeName", masterVolumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepSessionStart(String volumeName, String remoteHost, String remoteVolumeName, String userName, Boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStart").withParameter("volumeName", volumeName).withParameter("remoteHost", remoteHost).withParameter("remoteVolumeName", remoteVolumeName).withOptionalParameter("remoteUserName", userName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepConfigSet(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String configValue, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigSet").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withParameter("optionValue", configValue).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeGeoRepConfigReset(String volumeName, String slaveHost, String slaveVolumeName, String configKey, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigReset").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withParameter("optionName", configKey).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepConfigListXmlRpc glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigListXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepConfigList glusterVolumeGeoRepConfigList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepConfigList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new GlusterVolumeGeoRepConfigList(response);
}
#end_block

#method_before
@Override
public GlusterVolumeStatusReturnForXmlRpc glusterVolumeStatus(Guid clusterId, String volumeName, String brickName, String volumeStatusOption) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.status").withParameter("volumeName", volumeName).withParameter("brick", brickName).withParameter("statusOption", volumeStatusOption).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeStatusReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeStatusReturn glusterVolumeStatus(Guid clusterId, String volumeName, String brickName, String volumeStatusOption) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.status").withParameter("volumeName", volumeName).withParameter("brick", brickName).withParameter("statusOption", volumeStatusOption).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeStatusReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesListReturnForXmlRpc glusterVolumesList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumesListReturn glusterVolumesList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesListReturnForXmlRpc glusterVolumeInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumesListReturn glusterVolumeInfo(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.list").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesListReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumesHealInfoReturnForXmlRpc glusterVolumeHealInfo(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.healInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesHealInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumesHealInfoReturn glusterVolumeHealInfo(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.healInfo").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumesHealInfoReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeProfileInfoReturnForXmlRpc glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeProfileInfoReturn glusterVolumeProfileInfo(Guid clusterId, String volumeName, boolean nfs) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.profileInfo").withParameter("volumeName", volumeName).withParameter("nfs", nfs).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeProfileInfoReturn(clusterId, response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookEnable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.enable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookEnable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.enable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookDisable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.disable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookDisable(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.disable").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterHooksListReturnForXmlRpc glusterHooksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHooksListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHooksListReturn glusterHooksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHooksListReturn(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterHostUUIDGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.uuid").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturn glusterHostUUIDGet() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.uuid").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturn(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturn glusterServicesList(Guid serverId, String[] serviceNames) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.get").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceNames))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturn(serverId, response);
}
#end_block

#method_before
@Override
public GlusterHookContentInfoReturnForXmlRpc glusterHookRead(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.read").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHookContentInfoReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterHookContentInfoReturn glusterHookRead(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.read").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterHookContentInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookUpdate(String glusterCommand, String stage, String hookName, String content, String checksum) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.update").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookUpdate(String glusterCommand, String stage, String hookName, String content, String checksum) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.update").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookAdd(String glusterCommand, String stage, String hookName, String content, String checksum, Boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.add").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).withParameter("enable", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookAdd(String glusterCommand, String stage, String hookName, String content, String checksum, Boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.add").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).withParameter("hookData", content).withParameter("hookMd5Sum", checksum).withParameter("enable", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterHookRemove(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.remove").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterHookRemove(String glusterCommand, String stage, String hookName) {
    JsonRpcRequest request = new RequestBuilder("GlusterHook.remove").withParameter("glusterCmd", glusterCommand).withParameter("hookLevel", stage).withParameter("hookName", hookName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterServicesReturnForXmlRpc glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturnForXmlRpc(serverId, response);
}
#method_after
@Override
public GlusterServicesReturn glusterServicesAction(Guid serverId, String[] serviceList, String actionType) {
    JsonRpcRequest request = new RequestBuilder("GlusterService.action").withParameter("serviceNames", new ArrayList<>(Arrays.asList(serviceList))).withParameter("action", actionType).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterServicesReturn(serverId, response);
}
#end_block

#method_before
@Override
public StoragePoolInfoReturnForXmlRpc getStoragePoolInfo(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfoReturnForXmlRpc(response);
}
#method_after
@Override
public StoragePoolInfo getStoragePoolInfo(String spUUID) {
    JsonRpcRequest request = new RequestBuilder("StoragePool.getInfo").withParameter("storagepoolID", spUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StoragePoolInfo(response);
}
#end_block

#method_before
@Override
public GlusterTasksListReturnForXmlRpc glusterTasksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterTask.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTasksListReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterTasksListReturn glusterTasksList() {
    JsonRpcRequest request = new RequestBuilder("GlusterTask.list").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterTasksListReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStatus(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStatus").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRebalanceStatus(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.rebalanceStatus").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusForXmlRpc glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatus glusterVolumeGeoRepSessionList(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionList").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatus(response);
}
#end_block

#method_before
@Override
public GlusterVolumeGeoRepStatusDetailForXmlRpc glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetailForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeGeoRepStatusDetail glusterVolumeGeoRepSessionStatus(String volumeName, String slaveHost, String slaveVolumeName, String userName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.geoRepSessionStatus").withParameter("volumeName", volumeName).withParameter("remoteHost", slaveHost).withParameter("remoteVolumeName", slaveVolumeName).withOptionalParameter("remoteUserName", userName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeGeoRepStatusDetail(response);
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeTaskReturn glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.removeBrickStatus").withParameter("volumeName", volumeName).withParameter("brickList", new ArrayList<>(Arrays.asList(bricksList))).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeTaskReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setNumberOfCpus(String vmId, String numberOfCpus) {
    JsonRpcRequest request = new RequestBuilder("VM.setNumberOfCpus").withParameter("vmID", vmId).withParameter("numberOfCpus", numberOfCpus).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setNumberOfCpus(String vmId, String numberOfCpus) {
    JsonRpcRequest request = new RequestBuilder("VM.setNumberOfCpus").withParameter("vmID", vmId).withParameter("numberOfCpus", numberOfCpus).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hotplugMemory(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugMemory").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
@SuppressWarnings("rawtypes")
public StatusOnlyReturn hotplugMemory(Map info) {
    JsonRpcRequest request = new RequestBuilder("VM.hotplugMemory").withParameter("vmID", getVmId(info)).withParameter("params", info).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturnForXmlRpc updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public StatusOnlyReturn updateVmPolicy(Map params) {
    JsonRpcRequest request = new RequestBuilder("VM.updateVmPolicy").withParameter("vmID", (String) params.get("vmId")).withParameter("params", params).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc setHaMaintenanceMode(String mode, boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("Host.setHaMaintenanceMode").withParameter("mode", mode).withParameter("enabled", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn setHaMaintenanceMode(String mode, boolean enabled) {
    JsonRpcRequest request = new RequestBuilder("Host.setHaMaintenanceMode").withParameter("mode", mode).withParameter("enabled", enabled).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn add_image_ticket(String ticketId, String[] ops, long timeout, long size, String url) {
    HashMap<String, Object> ticketDict = new HashMap<>();
    ticketDict.put("uuid", ticketId);
    ticketDict.put("timeout", timeout);
    ticketDict.put("ops", ops);
    ticketDict.put("size", size);
    ticketDict.put("url", url);
    JsonRpcRequest request = new RequestBuilder("Host.add_image_ticket").withParameter("ticket", ticketDict).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc remove_image_ticket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.remove_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn remove_image_ticket(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.remove_image_ticket").withParameter("uuid", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc extend_image_ticket(String ticketId, long timeout) {
    JsonRpcRequest request = new RequestBuilder("Host.extend_image_ticket").withParameter("uuid", ticketId).withParameter("timeout", timeout).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn extend_image_ticket(String ticketId, long timeout) {
    JsonRpcRequest request = new RequestBuilder("Host.extend_image_ticket").withParameter("uuid", ticketId).withParameter("timeout", timeout).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneMapReturnForXmlRpc get_image_transfer_session_stats(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_transfer_session_stats").withParameter("ticketUUID", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsMap");
    return new OneMapReturnForXmlRpc(response);
}
#method_after
@Override
public OneMapReturn get_image_transfer_session_stats(String ticketId) {
    JsonRpcRequest request = new RequestBuilder("Host.get_image_transfer_session_stats").withParameter("ticketUUID", ticketId).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("statsMap");
    return new OneMapReturn(response);
}
#end_block

#method_before
@Override
public PrepareImageReturnForXmlRpc prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturnForXmlRpc(response);
}
#method_after
@Override
public PrepareImageReturn prepareImage(String spID, String sdID, String imageID, String volumeID, boolean allowIllegal) {
    JsonRpcRequest request = new RequestBuilder("Image.prepare").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).withParameter("allowIllegal", allowIllegal).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new PrepareImageReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc teardownImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.teardown").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("leafVolID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn teardownImage(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Image.teardown").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("leafVolID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public StatusReturnForXmlRpc verifyUntrustedVolume(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Volume.verify_untrusted").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturnForXmlRpc(response);
}
#method_after
@Override
public StatusReturn verifyUntrustedVolume(String spID, String sdID, String imageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("Volume.verify_untrusted").withParameter("storagepoolID", spID).withParameter("storagedomainID", sdID).withParameter("imageID", imageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusReturn(response);
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturn getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturn(response);
}
#end_block

#method_before
@Override
public VMNamesListReturnForXmlRpc getExternalVmNamesList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMNames").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmNames").withResponseType(Object[].class);
    return new VMNamesListReturnForXmlRpc(response);
}
#method_after
@Override
public VMNamesListReturn getExternalVmNamesList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMNames").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmNames").withResponseType(Object[].class);
    return new VMNamesListReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotInfoReturnForXmlRpc glusterVolumeSnapshotList(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotList").withOptionalParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotInfoReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeSnapshotInfoReturn glusterVolumeSnapshotList(Guid clusterId, String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotList").withOptionalParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotInfoReturn(clusterId, response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotConfigReturnForXmlRpc glusterSnapshotConfigList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotConfigReturnForXmlRpc(clusterId, response);
}
#method_after
@Override
public GlusterVolumeSnapshotConfigReturn glusterSnapshotConfigList(Guid clusterId) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotConfigReturn(clusterId, response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotDelete(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.delete").withOptionalParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotDelete(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.delete").withOptionalParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotDeleteAll(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSnapshotDeleteAll(String volumeName) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotDeleteAll").withParameter("volumeName", volumeName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotActivate(String snapshotName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.activate").withParameter("snapName", snapshotName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotActivate(String snapshotName, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.activate").withParameter("snapName", snapshotName).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotDeactivate(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.deactivate").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotDeactivate(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.deactivate").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotRestore(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.restore").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotRestore(String snapshotName) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.restore").withParameter("snapName", snapshotName).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public GlusterVolumeSnapshotCreateReturnForXmlRpc glusterVolumeSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturnForXmlRpc(response);
}
#method_after
@Override
public GlusterVolumeSnapshotCreateReturn glusterVolumeSnapshotCreate(String volumeName, String snapshotName, String description, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotCreate").withParameter("volumeName", volumeName).withParameter("snapName", snapshotName).withOptionalParameter("snapDescription", description).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new GlusterVolumeSnapshotCreateReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterVolumeSnapshotConfigSet(String volumeName, String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotConfigSet").withParameter("volumeName", volumeName).withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotConfigSet(String configName, String configValue) {
    JsonRpcRequest request = new RequestBuilder("GlusterSnapshot.configSet").withParameter("optionName", configName).withParameter("optionValue", configValue).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StorageDeviceListReturnForXmlRpc glusterStorageDeviceList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.storageDevicesList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StorageDeviceListReturnForXmlRpc(response);
}
#method_after
@Override
public StorageDeviceListReturn glusterStorageDeviceList() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.storageDevicesList").build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StorageDeviceListReturn(response);
}
#end_block

#method_before
@Override
public OneStorageDeviceReturnForXmlRpc glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturnForXmlRpc(response);
}
#method_after
@Override
public OneStorageDeviceReturn glusterCreateBrick(String lvName, String mountPoint, Map<String, Object> raidParams, String fsType, String[] storageDevices) {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.createBrick").withParameter("name", lvName).withParameter("mountPoint", mountPoint).withParameter("devList", storageDevices).withParameter("fsType", fsType).withOptionalParameterAsMap("raidParams", raidParams).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneStorageDeviceReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc hostdevChangeNumvfs(String deviceName, int numOfVfs) {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevChangeNumvfs").withParameter("deviceName", deviceName).withParameter("numvfs", numOfVfs).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn hostdevChangeNumvfs(String deviceName, int numOfVfs) {
    JsonRpcRequest request = new RequestBuilder("Host.hostdevChangeNumvfs").withParameter("deviceName", deviceName).withParameter("numvfs", numOfVfs).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn convertVmFromExternalSystem(String uri, String username, String password, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVm").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc convertVmFromOva(String ovaPath, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVmFromOva").withParameter("ova_path", ovaPath).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn convertVmFromOva(String ovaPath, Map<String, Object> vm, String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.convertExternalVmFromOva").withParameter("ova_path", ovaPath).withParameter("vminfo", vm).withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OvfReturnForXmlRpc getConvertedVm(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.getConvertedVm").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ovf").withResponseType(String.class);
    return new OvfReturnForXmlRpc(response);
}
#method_after
@Override
public OvfReturn getConvertedVm(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.getConvertedVm").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("ovf").withResponseType(String.class);
    return new OvfReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc deleteV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.deleteV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn deleteV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.deleteV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc abortV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.abortV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn abortV2VJob(String jobUUID) {
    JsonRpcRequest request = new RequestBuilder("Host.abortV2VJob").withParameter("jobid", jobUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotScheduleOverride(boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleOverride").withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotScheduleOverride(boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleOverride").withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterSnapshotScheduleReset() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleReset").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterSnapshotScheduleReset() {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.snapshotScheduleReset").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
public StatusOnlyReturnForXmlRpc registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
public StatusOnlyReturn registerSecrets(Map<String, String>[] libvirtSecrets, boolean clearUnusedSecrets) {
    JsonRpcRequest request = new RequestBuilder("Host.registerSecrets").withParameter("secrets", libvirtSecrets).withParameter("clear", clearUnusedSecrets).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc unregisterSecrets(String[] libvirtSecretsUuids) {
    JsonRpcRequest request = new RequestBuilder("Host.unregisterSecrets").withParameter("uuids", libvirtSecretsUuids).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn unregisterSecrets(String[] libvirtSecretsUuids) {
    JsonRpcRequest request = new RequestBuilder("Host.unregisterSecrets").withParameter("uuids", libvirtSecretsUuids).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc freeze(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.freeze").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn freeze(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.freeze").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc thaw(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.thaw").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn thaw(String vmId) {
    JsonRpcRequest request = new RequestBuilder("VM.thaw").withParameter("vmID", vmId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc isolateVolume(String sdUUID, String srcImageID, String dstImageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("SDM.isolateVolume").withParameter("storagedomainID", sdUUID).withParameter("srcImageID", srcImageID).withParameter("dstImageID", dstImageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn isolateVolume(String sdUUID, String srcImageID, String dstImageID, String volumeID) {
    JsonRpcRequest request = new RequestBuilder("SDM.isolateVolume").withParameter("storagedomainID", sdUUID).withParameter("srcImageID", srcImageID).withParameter("dstImageID", dstImageID).withParameter("volumeID", volumeID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc wipeVolume(String sdUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.wipeVolume").withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn wipeVolume(String sdUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("SDM.wipeVolume").withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public OneVmReturnForXmlRpc getExternalVmFromOva(String ovaPath) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVmFromOva").withParameter("ova_path", ovaPath).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new OneVmReturnForXmlRpc(response);
}
#method_after
@Override
public OneVmReturn getExternalVmFromOva(String ovaPath) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVmFromOva").withParameter("ova_path", ovaPath).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new OneVmReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc refreshVolume(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.refresh").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn refreshVolume(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.refresh").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public VolumeInfoReturnForXmlRpc getVolumeInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new VolumeInfoReturnForXmlRpc(response);
}
#method_after
@Override
public VolumeInfoReturn getVolumeInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new VolumeInfoReturn(response);
}
#end_block

#method_before
@Override
public QemuImageInfoReturnForXmlRpc getQemuImageInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getQemuImageInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new QemuImageInfoReturnForXmlRpc(response);
}
#method_after
@Override
public QemuImageInfoReturn getQemuImageInfo(String sdUUID, String spUUID, String imgUUID, String volUUID) {
    JsonRpcRequest request = new RequestBuilder("Volume.getQemuImageInfo").withParameter("storagepoolID", spUUID).withParameter("storagedomainID", sdUUID).withParameter("imageID", imgUUID).withParameter("volumeID", volUUID).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new QemuImageInfoReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn glusterStopProcesses() {
    JsonRpcRequest request = new RequestBuilder("GlusterHost.processesStop").build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc sparsifyVolume(String jobId, Map<String, Object> volumeAddress) {
    JsonRpcRequest request = new RequestBuilder("SDM.sparsify_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeAddress).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn sparsifyVolume(String jobId, Map<String, Object> volumeAddress) {
    JsonRpcRequest request = new RequestBuilder("SDM.sparsify_volume").withParameter("job_id", jobId).withParameter("vol_info", volumeAddress).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc amendVolume(String jobId, Map<String, Object> imgInfo, Map<String, Object> volAttr) {
    JsonRpcRequest request = new RequestBuilder("SDM.amend_volume").withParameter("job_id", jobId).withParameter("img_info", imgInfo).withParameter("vol_attr", volAttr).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturn amendVolume(String jobId, Map<String, Object> volInfo, Map<String, Object> volAttr) {
    JsonRpcRequest request = new RequestBuilder("SDM.amend_volume").withParameter("job_id", jobId).withParameter("vol_info", volInfo).withParameter("vol_attr", volAttr).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturn(response);
}
#end_block

#method_before
@Override
public Disk update(Disk incoming) {
    if (!incoming.isSetQcowVersion()) {
        throw new WebFaultException(null, "QCOW version does not exist.", Response.Status.BAD_REQUEST);
    }
    QcowCompat qcowCompat = getMapper(QcowVersion.class, org.ovirt.engine.core.common.businessentities.storage.QcowCompat.class).map(incoming.getQcowVersion(), null);
    performAction(VdcActionType.AmendImageGroupVolumes, new AmendImageGroupVolumesCommandParameters(guid, qcowCompat));
    return performGet(VdcQueryType.GetDiskByDiskId, new IdQueryParameters(guid));
}
#method_after
public Response update(Action action) {
    validateParameters(action, "disk.qcowVersion");
    QcowCompat qcowCompat = getMapper(QcowVersion.class, org.ovirt.engine.core.common.businessentities.storage.QcowCompat.class).map(action.getDisk().getQcowVersion(), null);
    return doAction(VdcActionType.AmendImageGroupVolumes, new AmendImageGroupVolumesCommandParameters(guid, qcowCompat), action);
}
#end_block

#method_before
public static boolean haveHostsAvailableforHE(final VdsDao vdsDao, final VDS vds, final Iterable<Guid> vdsesInBatch) {
    // It is really hard to query Iterable
    // especially when you have old commons-collections
    // So let's convert it to the set.
    Set<Guid> vdsIds = new HashSet<>();
    vdsesInBatch.forEach(vdsIds::add);
    return vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up).stream().filter(// Remove current host
    v -> !v.getId().equals(vds.getId())).filter(// Remove other hosts in batch
    v -> !vdsIds.contains(v)).filter(// Remove non HE hosts
    VDS::getHighlyAvailableIsConfigured).filter(// Remove non-active HE hosts
    VDS::getHighlyAvailableIsActive).filter(// Remove HE hosts under maintenance
    v -> !v.getHighlyAvailableLocalMaintenance()).filter(// Remove HE hosts not suitable for the engine VM
    v -> v.getHighlyAvailableScore() > 0).findAny().isPresent();
}
#method_after
public static boolean haveHostsAvailableforHE(Collection<VDS> clusterVdses, final Iterable<Guid> vdses) {
    // It is really hard to query Iterable
    // especially when you have old commons-collections
    // So let's convert it to the set.
    Set<Guid> vdsIds = new HashSet<>();
    vdses.forEach(vdsIds::add);
    return clusterVdses.stream().filter(// Remove other hosts in batch
    v -> !vdsIds.contains(v.getId())).filter(// Remove non HE hosts
    VDS::getHighlyAvailableIsConfigured).filter(// Remove non-active HE hosts
    VDS::getHighlyAvailableIsActive).filter(// Remove HE hosts under maintenance
    v -> !v.getHighlyAvailableLocalMaintenance()).filter(// Remove HE hosts not suitable for the engine VM
    v -> v.getHighlyAvailableScore() > 0).findAny().isPresent();
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            if (!HostedEngineHelper.haveHostsAvailableforHE(vdsDao, vds, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#method_after
@Override
protected boolean validate() {
    boolean result = true;
    Map<Guid, Cluster> clusters = new HashMap<>();
    Set<Guid> clustersAsSet = new HashSet<>();
    Set<Guid> vdsWithRunningVMs = new HashSet<>();
    List<String> hostNotRespondingList = new ArrayList<>();
    List<String> hostsWithNonMigratableVms = new ArrayList<>();
    List<String> hostsWithVmsWithPluggedDiskSnapshots = new ArrayList<>();
    List<String> nonMigratableVms = new ArrayList<>();
    for (Guid vdsId : getParameters().getVdsIdList()) {
        VDS vds = vdsDao.get(vdsId);
        if (vds == null) {
            log.error("ResourceManager::vdsMaintenance could not find VDS '{}'", vdsId);
            result = failValidation(EngineMessage.VDS_INVALID_SERVER_ID);
            continue;
        }
        // TODO make a more efficient call but normally the command just loads one cluster anyway
        if (!clusters.containsKey(vds.getClusterId())) {
            final Cluster cluster = clusterDao.get(vds.getClusterId());
            clusters.put(cluster.getId(), cluster);
        }
        if (!vdssToMaintenance.containsKey(vdsId)) {
            vdssToMaintenance.put(vdsId, vds);
            if (vds.getSpmStatus() == VdsSpmStatus.SPM) {
                addSharedLockEntry(vds);
            }
        }
        if (getParameters().isStopGlusterService() && !vds.getClusterSupportsGlusterService()) {
            result = failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_SERVICE_MAINTENANCE_NOT_SUPPORTED_FOR_CLUSTER);
            break;
        }
    }
    result = result && acquireLockInternal();
    if (result) {
        // tasks running
        for (Guid vdsId : getParameters().getVdsIdList()) {
            VDS vds = vdssToMaintenance.get(vdsId);
            if (vds != null) {
                if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down) && (vds.getStatus() != VDSStatus.NonOperational && (vds.getStatus() != VDSStatus.InstallFailed))) {
                    result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL);
                } else {
                    List<VM> vms = vmDao.getAllRunningForVds(vdsId);
                    if (!vms.isEmpty()) {
                        vdsWithRunningVMs.add(vdsId);
                    }
                    clustersAsSet.add(vds.getClusterId());
                    List<String> nonMigratableVmDescriptionsToFrontEnd = new ArrayList<>();
                    for (VM vm : vms) {
                        // And they need safe place for migration
                        if (vm.isHostedEngine()) {
                            List<VDS> clusterVdses = vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up);
                            if (!HostedEngineHelper.haveHostsAvailableforHE(clusterVdses, getParameters().getVdsIdList())) {
                                failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE);
                                return false;
                            }
                        }
                        // other non-migratable VMs are reported
                        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE && !vm.isHostedEngine()) {
                            nonMigratableVmDescriptionsToFrontEnd.add(vm.getName());
                        }
                    }
                    if (nonMigratableVmDescriptionsToFrontEnd.size() > 0) {
                        hostsWithNonMigratableVms.add(vds.getName());
                        nonMigratableVms.addAll(nonMigratableVmDescriptionsToFrontEnd);
                        // The non migratable VM names will be comma separated
                        log.error("VDS '{}' contains non migratable VMs", vdsId);
                        result = false;
                    } else if (!validate(new MultipleVmsValidator(vms).vmNotHavingPluggedDiskSnapshots(EngineMessage.VDS_CANNOT_MAINTENANCE_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
                        hostsWithVmsWithPluggedDiskSnapshots.add(vds.getName());
                        result = false;
                    } else if (vds.getStatus() == VDSStatus.Maintenance) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_IN_MAINTENANCE);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.Contending) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_CONTENDING);
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getVmCount() > 0) {
                        result = false;
                        hostNotRespondingList.add(vds.getName());
                    } else if (vds.getStatus() == VDSStatus.NonResponsive && vds.getSpmStatus() != VdsSpmStatus.None) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_RESPONDING_AND_IS_SPM);
                    } else if (vds.getSpmStatus() == VdsSpmStatus.SPM && vds.getStatus() == VDSStatus.Up && asyncTaskDao.getAsyncTaskIdsByStoragePoolId(vds.getStoragePoolId()).size() > 0) {
                        result = failValidation(EngineMessage.VDS_CANNOT_MAINTENANCE_SPM_WITH_RUNNING_TASKS);
                    } else if (!clusters.get(vds.getClusterId()).isInUpgradeMode()) {
                        result = handlePositiveEnforcingAffinityGroup(vdsId, vms);
                    }
                }
            }
        }
        // If one of the host is non responsive with running VM's, add a Validate message.
        handleNonResponsiveHosts(hostNotRespondingList);
        // If one of the vms is non migratable, add a Validate message.
        handleNonMigratableVms(hostsWithNonMigratableVms, nonMigratableVms);
        handleHostsWithVmsWithPluggedDiskSnapshots(hostsWithVmsWithPluggedDiskSnapshots);
        if (result) {
            // Remove all redundant clusters in clusters list, by adding it to a
            // set.
            // For each cluster check for each host that belongs to it, if its a
            // part of the parameters and
            // if there are running hosts for it - if it is up and is not in the
            // parameters -migration will be possible
            // to be performed, and there is no point to continue the check for
            // the given cluster - otherwise,
            // if the host is up and in the parameters - it may be that the
            // cluster is problematic (no hosts in up
            // state that we will be able to migrate VMs to)
            // In the end - if the clusters list is not empty - this is an
            // error, use the "problematic clusters list" to format an error to
            // the client
            List<String> problematicClusters = new ArrayList<>();
            List<String> allHostsWithRunningVms = new ArrayList<>();
            for (Guid clusterID : clustersAsSet) {
                List<VDS> vdsList = vdsDao.getAllForCluster(clusterID);
                boolean vdsForMigrationExists = checkIfThereIsVDSToHoldMigratedVMs(getParameters().getVdsIdList(), vdsList);
                if (!vdsForMigrationExists) {
                    List<String> candidateHostsWithRunningVms = new ArrayList<>();
                    for (VDS vdsInCluster : vdsList) {
                        if (vdsWithRunningVMs.contains(vdsInCluster.getId())) {
                            candidateHostsWithRunningVms.add(vdsInCluster.getName());
                        }
                    }
                    // cluster
                    if (!candidateHostsWithRunningVms.isEmpty()) {
                        addClusterDetails(clusterID, problematicClusters);
                        allHostsWithRunningVms.addAll(candidateHostsWithRunningVms);
                    }
                }
            }
            // If there are problematic clusters
            result = problematicClusters.isEmpty();
            if (!result) {
                addValidationMessage(EngineMessage.CANNOT_MAINTENANCE_VDS_RUN_VMS_NO_OTHER_RUNNING_VDS);
                String commaDelimitedClusters = StringUtils.join(problematicClusters, ",");
                getReturnValue().getValidationMessages().add(String.format("$ClustersList %1$s", commaDelimitedClusters));
                getReturnValue().getValidationMessages().add(String.format("$HostsList %1$s", StringUtils.join(allHostsWithRunningVms, ",")));
            }
        }
        if (result && !getParameters().isForceMaintenance()) {
            result = validateGlusterParams(clustersAsSet);
        }
    }
    return result;
}
#end_block

#method_before
public boolean canMaintenanceVds(Guid vdsId, ArrayList<String> reasons) {
    boolean returnValue = true;
    // VDS vds = ResourceManager.Instance.getVds(vdsId);
    VDS vds = vdsDao.get(vdsId);
    // we can get here when vds status was set already to Maintenance
    if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down && (vds.getStatus() != VDSStatus.InstallFailed))) {
        returnValue = false;
        reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
    }
    orderListOfRunningVmsOnVds(vdsId);
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // Check if there are available Hosted Engine hosts for that VM
            if (HostedEngineHelper.haveHostsAvailableforHE(vdsDao, vds)) {
                reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE.toString());
                return false;
            }
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
            reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM.toString());
            return false;
        }
    }
    return returnValue;
}
#method_after
public boolean canMaintenanceVds(Guid vdsId, ArrayList<String> reasons) {
    boolean returnValue = true;
    // VDS vds = ResourceManager.Instance.getVds(vdsId);
    VDS vds = vdsDao.get(vdsId);
    // we can get here when vds status was set already to Maintenance
    if ((vds.getStatus() != VDSStatus.Maintenance) && (vds.getStatus() != VDSStatus.NonResponsive) && (vds.getStatus() != VDSStatus.Up) && (vds.getStatus() != VDSStatus.Error) && (vds.getStatus() != VDSStatus.PreparingForMaintenance) && (vds.getStatus() != VDSStatus.Down && (vds.getStatus() != VDSStatus.InstallFailed))) {
        returnValue = false;
        reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_VDS_IS_NOT_OPERATIONAL.toString());
    }
    orderListOfRunningVmsOnVds(vdsId);
    for (VM vm : vms) {
        if (vm.isHostedEngine()) {
            // Check if there are available Hosted Engine hosts for that VM
            if (!HostedEngineHelper.haveHostsAvailableforHE(vdsDao.getAllForClusterWithStatus(vds.getClusterId(), VDSStatus.Up), Collections.singletonList(vds.getId()))) {
                reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_NO_ALTERNATE_HOST_FOR_HOSTED_ENGINE.toString());
                return false;
            }
            // The Hosted Engine vm is migrated by the HA agent
            continue;
        }
        if (vm.getMigrationSupport() != MigrationSupport.MIGRATABLE) {
            reasons.add(EngineMessage.VDS_CANNOT_MAINTENANCE_IT_INCLUDES_NON_MIGRATABLE_VM.toString());
            return false;
        }
    }
    return returnValue;
}
#end_block

#method_before
public static void setTooltipOnElement(String tooltip, Element element) {
    if (tooltip != null) {
        element.setTitle(tooltip);
    }
}
#method_after
public static void setTooltipOnElement(String tooltip, Element element) {
    if (tooltip != null) {
        element.setTitle(tooltip);
    } else {
        // $NON-NLS-1$
        element.setTitle("");
    }
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(getVmTemplate().getDiskTemplateMap().values());
    parameters.setUseCinderCommandCallback(!cinderDisks.isEmpty());
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(getVmTemplate().getDiskTemplateMap().values());
    parameters.setUseCinderCommandCallback(!cinderDisks.isEmpty());
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    super.executeVmCommand();
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    getVm().getStaticData().setQuotaId(getParameters().getVmStaticData().getQuotaId());
    vmStaticDao.update(getVm().getStaticData());
    // if there are no tasks, we can end the command right away.
    if (getTaskIdList().isEmpty()) {
        endSuccessfully();
    }
    checkTrustedService();
}
#method_after
@Override
protected void executeVmCommand() {
    super.executeVmCommand();
    getVm().setVmtGuid(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    getVm().getStaticData().setQuotaId(getParameters().getVmStaticData().getQuotaId());
    vmStaticDao.update(getVm().getStaticData());
    checkTrustedService();
    logIfDisksHaveIllegalPassDiscard();
}
#end_block

#method_before
@Override
protected void lockVM() {
    VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
}
#method_after
@Override
protected void lockVM() {
    vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    return getParameters().isUseCinderCommandCallback() || FeatureSupported.dataOperationsByHSM(getStoragePool().getCompatibilityVersion()) ? new ConcurrentChildCommandsExecutionCallback() : null;
}
#method_after
@Override
public CommandCallback getCallback() {
    return new ConcurrentChildCommandsExecutionCallback();
}
#end_block

#method_before
@Override
protected VDSReturnValue performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    VDSReturnValue vdsReturnValue = null;
    if (isDataOperationsByHSM()) {
        CopyImageGroupWithDataCommandParameters p = new CopyImageGroupWithDataCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getDestinationStorageDomainId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), newDiskImage.getVolumeFormat(), true);
        p.setParentParameters(getParameters());
        p.setParentCommand(getActionType());
        p.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
        runInternalAction(VdcActionType.CopyImageGroupWithData, p);
        vdsReturnValue = new VDSReturnValue();
        vdsReturnValue.setSucceeded(true);
        return vdsReturnValue;
    } else {
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
        try {
            vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
        } catch (EngineException e) {
            log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
            throw e;
        }
        if (vdsReturnValue.getSucceeded()) {
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
        return vdsReturnValue;
    }
}
#method_after
@Override
protected boolean performImageVdsmOperation() {
    setDestinationImageId(Guid.newGuid());
    newDiskImage = cloneDiskImage(getDestinationImageId());
    newDiskImage.setId(Guid.newGuid());
    Guid storagePoolID = newDiskImage.getStoragePoolId() != null ? newDiskImage.getStoragePoolId() : Guid.Empty;
    if (isDataOperationsByHSM()) {
        CopyImageGroupWithDataCommandParameters p = new CopyImageGroupWithDataCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getDestinationStorageDomainId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), newDiskImage.getVolumeFormat(), true);
        p.setParentParameters(getParameters());
        p.setParentCommand(getActionType());
        p.setEndProcedure(VdcActionParametersBase.EndProcedure.COMMAND_MANAGED);
        runInternalAction(VdcActionType.CopyImageGroupWithData, p);
        return true;
    } else {
        Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.AddVmFromTemplate);
        VDSReturnValue vdsReturnValue;
        try {
            vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, PostZeroHandler.fixParametersWithPostZero(new CopyImageVDSCommandParameters(storagePoolID, getParameters().getStorageDomainId(), getVmTemplateId(), getDiskImage().getId(), getImage().getImageId(), newDiskImage.getId(), getDestinationImageId(), "", getDestinationStorageDomainId(), CopyVolumeType.LeafVol, newDiskImage.getVolumeFormat(), newDiskImage.getVolumeType(), getDiskImage().isWipeAfterDelete(), false)));
        } catch (EngineException e) {
            log.error("Failed creating snapshot from image id '{}'", getImage().getImageId());
            throw e;
        }
        if (vdsReturnValue.getSucceeded()) {
            getTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.AddVmFromTemplate, VdcObjectType.Storage, getParameters().getStorageDomainId(), getDestinationStorageDomainId()));
        }
        return vdsReturnValue.getSucceeded();
    }
}
#end_block

#method_before
@Override
protected AsyncTaskType getTaskType() {
    return AsyncTaskType.copyImage;
}
#method_after
@Override
protected AsyncTaskType getTaskType() {
    return isDataOperationsByHSM() ? AsyncTaskType.notSupported : AsyncTaskType.copyImage;
}
#end_block

#method_before
@Override
public CommandCallback getCallback() {
    if (isDataOperationsByHSM()) {
        return new ConcurrentChildCommandsExecutionCallback();
    }
    return null;
}
#method_after
@Override
public CommandCallback getCallback() {
    return isDataOperationsByHSM() ? new ConcurrentChildCommandsExecutionCallback() : null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().isCollapse()) {
        createVolume();
    } else {
        cloneStructureNotCollapsed();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    prepareParameters();
    persistCommandIfNeeded();
    if (getParameters().isCollapse()) {
        createVolume();
    } else {
        cloneStructureNotCollapsed();
    }
    setSucceeded(true);
}
#end_block

#method_before
private void cloneStructureNotCollapsed() {
    CloneImageGroupVolumesStructureCommandParameters p = new CloneImageGroupVolumesStructureCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getDestinationFormat(), getActionType(), getParameters());
    p.setParentParameters(getParameters());
    p.setParentCommand(getActionType());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CloneImageGroupVolumesStructure, p);
}
#method_after
private void cloneStructureNotCollapsed() {
    CloneImageGroupVolumesStructureCommandParameters p = new CloneImageGroupVolumesStructureCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getDestinationFormat(), getActionType(), getParameters());
    p.setParentParameters(getParameters());
    p.setParentCommand(getActionType());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    p.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    runInternalAction(VdcActionType.CloneImageGroupVolumesStructure, p);
}
#end_block

#method_before
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), ImagesHandler.determineImageInitialSize(getDiskImage().getImage(), getParameters().getDestinationFormat(), getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID()));
    parameters.setCreateImage(true);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), Guid.Empty, Guid.Empty, getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), ImagesHandler.determineTotalImageInitialSize(getDiskImage(), getParameters().getDestinationFormat(), getParameters().getDestDomain()));
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == CopyStage.DEST_CREATION) {
        updateStage(CopyStage.DATA_COPY);
        if (getParameters().isCollapse()) {
            CopyDataCommandParameters parameters = new CopyDataCommandParameters(getParameters().getStoragePoolId(), buildImageLocationInfo(getParameters().getDestDomain(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId()), buildImageLocationInfo(getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getImageId()), true);
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            runInternalAction(VdcActionType.CopyData, parameters);
        } else {
            CopyImageGroupVolumesDataCommandParameters p = new CopyImageGroupVolumesDataCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getDestDomain(), getActionType(), getParameters());
            p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            runInternalAction(VdcActionType.CopyImageGroupVolumesData, p);
        }
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == CopyStage.DEST_CREATION) {
        updateStage(CopyStage.DATA_COPY);
        Integer weight = getParameters().getOperationsJobWeight().get(CopyStage.DATA_COPY.name());
        if (getParameters().isCollapse()) {
            CopyDataCommandParameters parameters = new CopyDataCommandParameters(getParameters().getStoragePoolId(), buildImageLocationInfo(getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getImageId()), buildImageLocationInfo(getParameters().getDestDomain(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId()), true);
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setJobWeight(weight);
            runInternalAction(VdcActionType.CopyData, parameters);
        } else {
            CopyImageGroupVolumesDataCommandParameters p = new CopyImageGroupVolumesDataCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getDestDomain(), getActionType(), getParameters());
            p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            p.setJobWeight(weight);
            runInternalAction(VdcActionType.CopyImageGroupVolumesData, p);
        }
        return true;
    }
    return false;
}
#end_block

#method_before
private LocationInfo buildImageLocationInfo(Guid domId, Guid imageGroupId, Guid imageId) {
    return new VdsmImageLocationInfo(domId, imageGroupId, imageId);
}
#method_after
private LocationInfo buildImageLocationInfo(Guid domId, Guid imageGroupId, Guid imageId) {
    return new VdsmImageLocationInfo(domId, imageGroupId, imageId, null);
}
#end_block

#method_before
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getInstance().getAAAProfilesList(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> domains) {
            String oldDomain = getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrNull(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }));
}
#method_after
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getInstance().getAuthzExtensionsNames(new AsyncQuery<>(new AsyncCallback<List<String>>() {

        @Override
        public void onSuccess(List<String> domains) {
            String oldDomain = getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrNull(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }));
}
#end_block

#method_before
@Override
public void edit(final RunOnceModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    runOnceModel = object;
    // Update Linux options panel
    final EntityModel<Boolean> isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isLinux = isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(isLinux);
        }
    });
    object.getIsSysprepEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateSysprepVisibility(object);
            autoSetVmHostname(object);
        }
    });
    object.getIsCloudInitPossible().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCloudInitVisibility(object);
            updateInitialRunTabVisibility(object);
        }
    });
    object.getIsCloudInitEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCloudInitVisibility(object);
            autoSetVmHostname(object);
        }
    });
    object.getIsSysprepPossible().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateSysprepVisibility(object);
            updateInitialRunTabVisibility(object);
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind tloudInitSubo the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue()) {
                specificHost.setValue(true, true);
            }
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            } else if ("IsCustomPropertiesSheetVisible".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesPanel.setVisible(object.getIsCustomPropertiesSheetVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    updateBootSequenceListBox();
    vmInitWidget.edit(object.getVmInitModel());
}
#method_after
@Override
public void edit(final RunOnceModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    runOnceModel = object;
    // Update Linux options panel
    final EntityModel<Boolean> isLinuxOptionsAvailable = object.getIsLinuxOptionsAvailable();
    object.getIsLinuxOptionsAvailable().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            boolean isLinux = isLinuxOptionsAvailable.getEntity();
            linuxBootOptionsPanel.setVisible(isLinux);
        }
    });
    object.getIsSysprepEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateSysprepVisibility(object);
            if (Boolean.TRUE.equals(object.getIsSysprepEnabled().getEntity())) {
                runOnceModel.autoSetVmHostname();
            }
        }
    });
    object.getIsCloudInitPossible().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCloudInitVisibility(object);
            updateInitialRunTabVisibility(object);
        }
    });
    object.getIsCloudInitEnabled().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateCloudInitVisibility(object);
            if (Boolean.TRUE.equals(object.getIsCloudInitEnabled().getEntity())) {
                runOnceModel.autoSetVmHostname();
            }
        }
    });
    object.getIsSysprepPossible().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            updateSysprepVisibility(object);
            updateInitialRunTabVisibility(object);
        }
    });
    // Update Host combo
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind tloudInitSubo the model, so needs to
            // listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    specificHost.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            defaultHostEditor.setEnabled(specificHost.getValue());
            ValueChangeEvent.fire(isAutoAssignEditor.asRadioButton(), false);
        }
    });
    isAutoAssignEditor.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            defaultHostEditor.setEnabled(false);
        }
    }, ClickEvent.getType());
    object.getIsAutoAssign().getEntityChangedEvent().addListener(new IEventListener<EventArgs>() {

        @Override
        public void eventRaised(Event<? extends EventArgs> ev, Object sender, EventArgs args) {
            if (!isAutoAssignEditor.asRadioButton().getValue()) {
                specificHost.setValue(true, true);
            }
        }
    });
    object.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if ("IsHostTabVisible".equals(propName)) {
                // $NON-NLS-1$
                hostPanel.setVisible(object.getIsHostTabVisible());
            } else if ("IsCustomPropertiesSheetVisible".equals(propName)) {
                // $NON-NLS-1$
                customPropertiesPanel.setVisible(object.getIsCustomPropertiesSheetVisible());
            }
        }
    });
    // Update BootSequence ListBox
    bootSequenceModel = object.getBootSequence();
    updateBootSequenceListBox();
    vmInitWidget.edit(object.getVmInitModel());
}
#end_block

#method_before
@PostConstruct
private void initCache() {
    dashboardCache = cacheContainer.getCache(DASHBOARD);
    inventoryCache = cacheContainer.getCache(INVENTORY);
    /*
         * Update the dashboard cache now and then every 5 minutes, but never run 2 updates simultaneously.
         */
    dashboardCacheUpdate = scheduledExecutor.scheduleAtFixedRate(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger("org.ovirt.engine.ui.frontend.server.dashboard.DashboardDataServlet.CacheUpdate.Dashboard");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.debug("Attempting to update the Dashboard cache");
            try {
                populateDashboardCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Dashboard Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, DASHBOARD_CACHE_UPDATE_INTERVAL, DASHBOARD_CACHE_UPDATE_UNIT);
    /*
         * Update the inventory cache now and then every 15 seconds, but never run 2 updates simultaneously.
         */
    inventoryCacheUpdate = scheduledExecutor.scheduleAtFixedRate(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger("org.ovirt.engine.ui.frontend.server.dashboard.DashboardDataServlet.CacheUpdate.Inventory");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.debug("Attempting to update the Inventory cache");
            try {
                populateInventoryCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Inventory Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, INVENTORY_CACHE_UPDATE_INTERVAL, INVENTORY_CACHE_UPDATE_UNIT);
}
#method_after
@PostConstruct
private void initCache() {
    dashboardCache = cacheContainer.getCache(DASHBOARD);
    inventoryCache = cacheContainer.getCache(INVENTORY);
    EngineLocalConfig config = EngineLocalConfig.getInstance();
    boolean enableBackground;
    try {
        enableBackground = config.getBoolean(ENABLE_CACHE_UPDATE_KEY, Boolean.FALSE);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 'false'", ENABLE_CACHE_UPDATE_KEY, e);
        enableBackground = false;
    }
    if (!enableBackground) {
        // $NON-NLS-1$
        log.info("Dashboard DB query cache has been disabled.");
        return;
    }
    /*
         * Update the utilization cache now and every 5 minutes (by default) thereafter, but never run 2 updates simultaneously.
         */
    try {
        UTILIZATION_CACHE_UPDATE_INTERVAL = config.getLong(UTILIZATION_CACHE_UPDATE_INTERVAL_KEY);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 300", UTILIZATION_CACHE_UPDATE_INTERVAL_KEY, e);
        UTILIZATION_CACHE_UPDATE_INTERVAL = 300;
    }
    utilizationCacheUpdate = scheduledExecutor.scheduleAtFixedRate(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger(DashboardDataServlet.class.getName() + ".CacheUpdate.Utilization");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.trace("Attempting to update the Utilization cache");
            try {
                populateUtilizationCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Utilization Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, UTILIZATION_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    /*
         * Update the inventory cache now and every 60 seconds (by default) thereafter, but never run 2 updates simultaneously.
         */
    try {
        INVENTORY_CACHE_UPDATE_INTERVAL = config.getLong(INVENTORY_CACHE_UPDATE_INTERVAL_KEY);
    } catch (IllegalArgumentException e) {
        // $NON-NLS-1$
        log.error("Missing/Invalid key \"{}\", using default value of 60", INVENTORY_CACHE_UPDATE_INTERVAL_KEY, e);
        INVENTORY_CACHE_UPDATE_INTERVAL = 60;
    }
    inventoryCacheUpdate = scheduledExecutor.scheduleAtFixedRate(new Runnable() {

        // $NON-NLS-1$
        Logger log = LoggerFactory.getLogger(DashboardDataServlet.class.getName() + ".CacheUpdate.Inventory");

        @Override
        public void run() {
            // $NON-NLS-1$
            log.trace("Attempting to update the Inventory cache");
            try {
                populateInventoryCache();
            } catch (DashboardDataException e) {
                // $NON-NLS-1$
                log.error("Could not update the Inventory Cache: {}", e.getMessage(), e);
            }
        }
    }, 0, INVENTORY_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
}
#end_block

#method_before
@PreDestroy
private void stopScheduledTasks() {
    dashboardCacheUpdate.cancel(true);
    inventoryCacheUpdate.cancel(true);
}
#method_after
@PreDestroy
private void stopScheduledTasks() {
    if (utilizationCacheUpdate != null) {
        utilizationCacheUpdate.cancel(true);
    }
    if (inventoryCacheUpdate != null) {
        inventoryCacheUpdate.cancel(true);
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    Dashboard dashboard;
    response.setContentType(CONTENT_TYPE);
    response.setCharacterEncoding(ENCODING);
    try {
        // Check if the browser wants fake data, non-cached data or standard cached data
        if (FakeDataGenerator.headerWantsFakeData(request)) {
            dashboard = getFakeDashboard();
        } else if ("nocache".equals(request.getHeader("Prefer"))) {
            // $NON-NLS-1$ $NON-NLS-2$
            dashboard = getDashboard();
            dashboard.setInventory(lookupInventory());
        } else {
            dashboard = getDashboardFromCache();
        }
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), dashboard);
    } catch (final DashboardDataException se) {
        // $NON-NLS-1$
        log.error("Unable to retrieve dashboard data", se);
        response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), // $NON-NLS-1$
        new DashboardError("Unable to retrieve dashboard data"));
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    Dashboard dashboard;
    response.setContentType(CONTENT_TYPE);
    response.setCharacterEncoding(ENCODING);
    try {
        // Check if the browser wants a forced error, fake data, non-cached data or standard cached data
        boolean preferFake = false;
        boolean preferError = false;
        boolean preferNoCache = false;
        String preferHeader = request.getHeader(PREFER_HEADER);
        // $NON-NLS-1$
        String[] preferOptions = preferHeader == null ? new String[0] : preferHeader.trim().split("\\s*,\\s*");
        for (String option : preferOptions) {
            switch(option) {
                case PREFER_FAKE_DATA:
                    preferFake = true;
                    break;
                case PREFER_ERROR:
                    preferError = true;
                    break;
                case PREFER_NO_CACHE:
                    preferNoCache = true;
                    break;
            }
        }
        // Respond to the client based on the preferred method
        if (preferError) {
            // $NON-NLS-1$
            log.debug("client requested an error condition");
            // $NON-NLS-1$
            throw new ServletException("An error condition was requested.");
        } else if (preferFake) {
            // $NON-NLS-1$
            log.debug("client requested fake data");
            dashboard = getFakeDashboard();
        } else if (preferNoCache) {
            // $NON-NLS-1$
            log.debug("client requested non-cache direct query data");
            dashboard = getDashboard();
            dashboard.setInventory(lookupInventory());
        } else {
            dashboard = getDashboardFromCache();
        }
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), dashboard);
    } catch (final DashboardDataException se) {
        // $NON-NLS-1$
        log.error("Unable to retrieve dashboard data", se);
        response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), // $NON-NLS-1$
        new DashboardError("Unable to retrieve dashboard data"));
    }
}
#end_block

#method_before
private Dashboard getDashboardFromCache() throws DashboardDataException {
    Dashboard dashboard;
    Inventory inventory;
    synchronized (UTILIZATION_LOCK) {
        // Get the dashboard from the cache if we can. If not, query the database.
        dashboard = dashboardCache.get(UTILIZATION_KEY);
        if (dashboard == null) {
            // $NON-NLS-1$
            log.debug("Dashboard cache is empty, querying dashboard data directly");
            dashboard = getDashboard();
        }
        // Inventory is in a different cache. Get the data from the cache if we can. If not, query
        // the database. Since this is potentially modifying the dashboard object, we need to have
        // this inside the synchronized block of the dashboard.
        inventory = inventoryCache.get(INVENTORY_KEY);
        if (inventory == null) {
            // $NON-NLS-1$
            log.debug("Inventory cache is empty, querying inventory data directly");
            inventory = lookupInventory();
        }
    }
    dashboard.setInventory(inventory);
    return dashboard;
}
#method_after
private Dashboard getDashboardFromCache() throws DashboardDataException {
    Dashboard dashboard;
    Inventory inventory;
    synchronized (UTILIZATION_LOCK) {
        // Get the dashboard from the cache if we can. If not, query the database.
        dashboard = dashboardCache.get(UTILIZATION_KEY);
        if (dashboard == null) {
            dashboard = populateUtilizationCache();
        }
        // Inventory is in a different cache. Get the data from the cache if we can. If not, query
        // the database. Since this is potentially modifying the dashboard object, we need to have
        // this inside the synchronized block of the dashboard.
        inventory = inventoryCache.get(INVENTORY_KEY);
        if (inventory == null) {
            inventory = populateInventoryCache();
        }
    }
    dashboard.setInventory(inventory);
    return dashboard;
}
#end_block

#method_before
private void populateInventoryCache() throws DashboardDataException {
    long startTime = System.currentTimeMillis();
    Inventory inventory = lookupInventory();
    long endTime = System.currentTimeMillis();
    // Put the inventory in the cache for 15 seconds, after 15 seconds it is evicted and the
    // next request will populate it again.
    inventoryCache.put(INVENTORY_KEY, inventory, 15, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.debug("Inventoy cache updated in {}ms", endTime - startTime);
}
#method_after
private Inventory populateInventoryCache() throws DashboardDataException {
    long startTime = System.currentTimeMillis();
    Inventory inventory = lookupInventory();
    long endTime = System.currentTimeMillis();
    // Put the inventory in the cache for a default of 60 seconds, after 60 seconds it is evicted and the
    // next request will populate it again.
    inventoryCache.put(INVENTORY_KEY, inventory, INVENTORY_CACHE_UPDATE_INTERVAL, TimeUnit.SECONDS);
    // $NON-NLS-1$
    log.debug("Dashboard inventoy cache updated in {}ms", endTime - startTime);
    return inventory;
}
#end_block

#method_before
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    return getAcceptableHosts(true, hosts, vm, messages, getPendingResourceManager());
}
#method_after
@Override
public List<VDS> filter(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters, PerHostMessages messages) {
    return getAffinityHostsResult(true, hosts, vm, messages).getAcceptableHosts();
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    // reuse filter functionality with soft constraint
    List<VDS> acceptableHostsList = vmToHostAffinityFilterPolicyUnit.getAcceptableHosts(false, hosts, vm, new PerHostMessages(), getPendingResourceManager());
    Map<Guid, VDS> acceptableHostsMap = new HashMap<>();
    if (acceptableHostsList != null) {
        acceptableHostsMap = acceptableHostsList.stream().collect(Collectors.toMap(VDS::getId, h -> h));
    }
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    int score;
    for (VDS host : hosts) {
        score = DEFAULT_SCORE;
        if (!acceptableHostsMap.containsKey(host.getId())) {
            score = MaxSchedulerWeight;
        }
        retList.add(new Pair<>(host.getId(), score));
    }
    return retList;
}
#method_after
@Override
public List<Pair<Guid, Integer>> score(Cluster cluster, List<VDS> hosts, VM vm, Map<String, String> parameters) {
    Map<Guid, Integer> hostViolations = getAffinityHostsResult(false, hosts, vm, new PerHostMessages()).getHostViolations();
    List<Pair<Guid, Integer>> retList = new ArrayList<>();
    int score;
    for (VDS host : hosts) {
        score = hostViolations.containsKey(host.getId()) ? hostViolations.get(host.getId()) : DEFAULT_SCORE;
        retList.add(new Pair<>(host.getId(), score));
    }
    return retList;
}
#end_block

#method_before
@Test
public void testWithAffinityIntersection() throws Exception {
    AffinityGroup positiveCollisionGroup = new AffinityGroup();
    positiveCollisionGroup.setVdsIds(Arrays.asList(host_negative_enforcing.getId()));
    positiveCollisionGroup.setVdsPositive(true);
    positiveCollisionGroup.setVdsEnforcing(true);
    hosts = Arrays.asList(host_positive_enforcing, host_negative_enforcing, host_not_in_affinity_group);
    List<AffinityGroup> affinityGroups = Arrays.asList(positiveCollisionGroup, negative_enforcing_group);
    doReturn(affinityGroups).when(affinityGroupDao).getAllAffinityGroupsByVmId(any());
    assertThat(unit.filter(cluster, hosts, vm, new HashMap<>(), new PerHostMessages())).isEmpty();
}
#method_after
@Test
public void testWithAffinityIntersection() throws Exception {
    AffinityGroup positiveCollisionGroup = new AffinityGroup();
    positiveCollisionGroup.setVdsIds(Arrays.asList(host_negative_enforcing.getId()));
    positiveCollisionGroup.setVdsAffinityRule(EntityAffinityRule.POSITIVE);
    positiveCollisionGroup.setVdsEnforcing(true);
    hosts = Arrays.asList(host_positive_enforcing, host_negative_enforcing, host_not_in_affinity_group);
    List<AffinityGroup> affinityGroups = Arrays.asList(positiveCollisionGroup, negative_enforcing_group);
    doReturn(affinityGroups).when(affinityGroupDao).getAllAffinityGroupsByVmId(any());
    assertThat(unit.filter(cluster, hosts, vm, new HashMap<>(), new PerHostMessages())).isEmpty();
}
#end_block

#method_before
private Collection<Disk> getDisksForDiskProfileValidation() {
    Collection<Disk> disks = getParameters().getVm().getDiskMap().values();
    if (getParameters().getAllowPartialImport()) {
        disks = disks.stream().filter(disk -> getImages().stream().anyMatch(image -> image.getId().equals(disk.getId()))).collect(Collectors.toList());
    }
    return disks;
}
#method_after
private Collection<Disk> getDisksForDiskProfileValidation() {
    Collection<Disk> disks = getParameters().getVm().getDiskMap().values();
    if (getParameters().getAllowPartialImport()) {
        disks = disks.stream().filter(disk -> getImages().stream().anyMatch(diskFromImagesList -> diskFromImagesList.getId().equals(disk.getId()))).collect(Collectors.toList());
    }
    return disks;
}
#end_block

#method_before
@Override
public void init() {
    // No need to filter the images for partial preview as being done in the execute phase since the callback can
    // also support no child commands, this should be changed once all commands will facilitate the CoCo
    // infrastructure.
    getParameters().setUseCinderCommandCallback(!ImagesHandler.filterDisksBasedOnCinder(getImagesToPreview()).isEmpty());
}
#method_after
@Override
public void init() {
    // No need to filter the images for partial preview as being done in the execute phase since the callback can
    // also support no child commands, this should be changed once all commands will facilitate the CoCo
    // infrastructure.
    getParameters().setUseCinderCommandCallback(!DisksFilter.filterCinderDisks(getImagesToPreview()).isEmpty());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    Snapshot previouslyActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED);
    getSnapshotDao().remove(previouslyActiveSnapshot.getId());
    getSnapshotDao().remove(getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE));
    getSnapshotsManager().addActiveSnapshot(previouslyActiveSnapshot.getId(), getVm(), previouslyActiveSnapshot.getMemoryVolume(), getCompensationContext());
    super.endWithFailure();
}
#method_after
@Override
protected void endWithFailure() {
    Snapshot previouslyActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED);
    snapshotDao.remove(previouslyActiveSnapshot.getId());
    snapshotDao.remove(snapshotDao.getId(getVmId(), SnapshotType.ACTIVE));
    getSnapshotsManager().addActiveSnapshot(previouslyActiveSnapshot.getId(), getVm(), previouslyActiveSnapshot.getMemoryVolume(), getCompensationContext());
    super.endWithFailure();
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    getVmStaticDao().incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    if (getVm() != null) {
        VmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
        updateClusterCompatibilityVersionToOldCluster(false);
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing endAction on Vm");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    vmStaticDao.incrementDbGeneration(getVm().getId());
    endActionOnDisks();
    if (getVm() != null) {
        vmHandler.unlockVm(getVm(), getCompensationContext());
        restoreVmConfigFromSnapshot();
        // disks and configuration is restored, let's set CCV if the snapshot originates in older Cluster version
        if (!updateClusterCompatibilityVersionToOldCluster(false)) {
            log.warn("Failed to set the Cluster Compatibility Version to the cluster version the snapshot originates from.");
        }
    } else {
        setCommandShouldBeLogged(false);
        log.warn("VmCommand::EndVmCommand: Vm is null - not performing endAction on Vm");
    }
    setSucceeded(true);
}
#end_block

#method_before
private void restoreVmConfigFromSnapshot() {
    getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    getSnapshotDao().updateStatus(getSnapshotDao().getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), getSnapshotDao().getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()));
}
#method_after
private void restoreVmConfigFromSnapshot() {
    snapshotDao.updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.IN_PREVIEW);
    snapshotDao.updateStatus(snapshotDao.getId(getVm().getId(), SnapshotType.PREVIEW, SnapshotStatus.LOCKED), SnapshotStatus.OK);
    getSnapshotsManager().attempToRestoreVmConfigurationFromSnapshot(getVm(), getDstSnapshot(), snapshotDao.getId(getVm().getId(), SnapshotType.ACTIVE), getImagesToPreview(), getCompensationContext(), getCurrentUser(), new VmInterfaceManager(getMacPool()));
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = getSnapshotDao().get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        getSnapshotDao().remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        VmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and
        // the VM Configuration (incl. clusterCompatibilityVersionOrigin) is already restored at this point.
        // Otherwise, if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    final boolean restoreMemory = isRestoreMemory();
    final Guid newActiveSnapshotId = Guid.newGuid();
    final Snapshot snapshotToBePreviewed = getDstSnapshot();
    final Snapshot previousActiveSnapshot = snapshotDao.get(getVmId(), SnapshotType.ACTIVE);
    final Guid previousActiveSnapshotId = previousActiveSnapshot.getId();
    final List<DiskImage> images = getImagesToPreview();
    // Images list without those that are excluded from preview
    final List<DiskImage> filteredImages = (List<DiskImage>) CollectionUtils.subtract(images, getImagesExcludedFromPreview(images, previousActiveSnapshotId, newActiveSnapshotId));
    final List<CinderDisk> cinderDisks = new ArrayList<>();
    TransactionSupport.executeInNewTransaction(() -> {
        getCompensationContext().snapshotEntity(previousActiveSnapshot);
        snapshotDao.remove(previousActiveSnapshotId);
        getSnapshotsManager().addSnapshot(previousActiveSnapshotId, "Active VM before the preview", SnapshotType.PREVIEW, getVm(), previousActiveSnapshot.getMemoryVolume(), getCompensationContext());
        getSnapshotsManager().addActiveSnapshot(newActiveSnapshotId, getVm(), restoreMemory ? snapshotToBePreviewed.getMemoryVolume() : StringUtils.EMPTY, images, getCompensationContext());
        // being executed in the same transaction so we can restore the vm config and end the command.
        if (!filteredImages.isEmpty()) {
            getCompensationContext().stateChanged();
        } else {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            restoreVmConfigFromSnapshot();
        }
        return null;
    });
    if (!filteredImages.isEmpty()) {
        vmHandler.lockVm(getVm().getDynamicData(), getCompensationContext());
        freeLock();
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                for (DiskImage image : filteredImages) {
                    if (image.getDiskStorageType() == DiskStorageType.CINDER) {
                        cinderDisks.add((CinderDisk) image);
                        continue;
                    }
                    VdcReturnValueBase vdcReturnValue = runInternalActionWithTasksContext(VdcActionType.TryBackToSnapshot, buildTryBackToSnapshotParameters(newActiveSnapshotId, image));
                    if (vdcReturnValue.getSucceeded()) {
                        getTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
                    } else if (vdcReturnValue.getFault() != null) {
                        // if we have a fault, forward it to the user
                        throw new EngineException(vdcReturnValue.getFault().getError(), vdcReturnValue.getFault().getMessage());
                    } else {
                        log.error("Cannot create snapshot");
                        throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
                    }
                }
                if (!cinderDisks.isEmpty() && !tryBackAllCinderDisks(cinderDisks, newActiveSnapshotId)) {
                    throw new EngineException(EngineError.CINDER_ERROR, "Failed to preview a snapshot!");
                }
                return null;
            }

            private ImagesContainterParametersBase buildTryBackToSnapshotParameters(final Guid newActiveSnapshotId, DiskImage image) {
                ImagesContainterParametersBase params = new ImagesContainterParametersBase(image.getImageId());
                params.setParentCommand(VdcActionType.TryBackToAllSnapshotsOfVm);
                params.setVmSnapshotId(newActiveSnapshotId);
                params.setEntityInfo(getParameters().getEntityInfo());
                params.setParentParameters(getParameters());
                params.setQuotaId(image.getQuotaId());
                return params;
            }
        });
    } else {
        // if there are no disks to restore, no compensation context is saved and
        // the VM Configuration (incl. clusterCompatibilityVersionOrigin) is already restored at this point.
        // Otherwise, if disks are being restored, the VM Configuration is restored later in endSuccessfully()
        updateClusterCompatibilityVersionToOldCluster(true);
    }
    setSucceeded(true);
}
#end_block

#method_before
private void updateClusterCompatibilityVersionToOldCluster(boolean disableLock) {
    Version oldClusterVersion = getVm().getClusterCompatibilityVersionOrigin();
    // if snapshot is taken in pre-3.6, set to to oldest supported (3.6)
    oldClusterVersion = oldClusterVersion == null ? Version.v3_6 : oldClusterVersion;
    if (isRestoreMemory() && getVm().getCustomCompatibilityVersion() == null && oldClusterVersion.less(getVm().getClusterCompatibilityVersion())) {
        // the snapshot was taken before cluster version change, call the UpdateVmCommand
        // vm_static of the getVm() is just updated by the previewed OVF config, so reload before UpdateVmCommand
        VM vmFromDb = getVmDao().get(getVmId());
        if (!updateVm(vmFromDb, oldClusterVersion, disableLock)) {
            return;
        }
    }
}
#method_after
private boolean updateClusterCompatibilityVersionToOldCluster(boolean disableLock) {
    Version oldClusterVersion = getVm().getClusterCompatibilityVersionOrigin();
    // if snapshot is taken in pre-3.6, set to to oldest supported (3.6)
    oldClusterVersion = oldClusterVersion == null ? Version.v3_6 : oldClusterVersion;
    if (isRestoreMemory() && getVm().getCustomCompatibilityVersion() == null && oldClusterVersion.less(getVm().getClusterCompatibilityVersion())) {
        // the snapshot was taken before cluster version change, call the UpdateVmCommand
        // vm_static of the getVm() is just updated by the previewed OVF config, so reload before UpdateVmCommand
        VmStatic vmFromDb = vmStaticDao.get(getVmId());
        return updateVm(vmFromDb, oldClusterVersion, disableLock);
    }
    return true;
}
#end_block

#method_before
private boolean updateVm(VM vm, Version oldClusterVersion, boolean disableLock) {
    VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
    if (disableLock) {
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
    }
    updateParams.setClusterLevelChangeFromVersion(oldClusterVersion);
    VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
    if (!result.getSucceeded()) {
        getReturnValue().setFault(result.getFault());
        return false;
    }
    return true;
}
#method_after
private boolean updateVm(VmStatic vm, Version oldClusterVersion, boolean disableLock) {
    VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
    updateParams.setClusterLevelChangeFromVersion(oldClusterVersion);
    CommandContext context;
    if (disableLock) {
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        context = cloneContextAndDetachFromParent();
    } else {
        // Wait for VM lock
        EngineLock updateVmLock = createUpdateVmLock();
        // will be released by UpdateVmCommand
        lockManager.acquireLockWait(updateVmLock);
        context = ExecutionHandler.createInternalJobContext(updateVmLock);
    }
    VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, context);
    if (!result.getSucceeded()) {
        getReturnValue().setFault(result.getFault());
        return false;
    }
    return true;
}
#end_block

#method_before
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : getDbFacade().getDiskImageDao().getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = ImagesHandler.filterDisksBasedOnCinder(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#method_after
private List<DiskImage> getImagesToPreview() {
    if (imagesToPreview == null) {
        imagesToPreview = getParameters().getDisks() != null ? getParameters().getDisks() : diskImageDao.getAllSnapshotsForVmSnapshot(getDstSnapshot().getId());
        // Filter out shareable/nonsnapable disks
        List<CinderDisk> CinderImagesToPreview = DisksFilter.filterCinderDisks(imagesToPreview);
        imagesToPreview = DisksFilter.filterImageDisks(imagesToPreview, ONLY_NOT_SHAREABLE, ONLY_SNAPABLE);
        imagesToPreview.addAll(CinderImagesToPreview);
    }
    return imagesToPreview;
}
#end_block

#method_before
private List<DiskImage> getImagesExcludedFromPreview(List<DiskImage> images, Guid previousActiveSnapshotId, Guid newActiveSnapshotId) {
    List<DiskImage> excludedImages = new ArrayList<>();
    for (DiskImage image : images) {
        if (image.getDiskStorageType().isInternal() && image.getVmSnapshotId().equals(previousActiveSnapshotId)) {
            // Image is already active, hence only update snapshot ID.
            getImageDao().updateImageVmSnapshotId(image.getImageId(), newActiveSnapshotId);
            excludedImages.add(image);
        }
    }
    return excludedImages;
}
#method_after
private List<DiskImage> getImagesExcludedFromPreview(List<DiskImage> images, Guid previousActiveSnapshotId, Guid newActiveSnapshotId) {
    List<DiskImage> excludedImages = new ArrayList<>();
    for (DiskImage image : images) {
        if (image.getDiskStorageType().isInternal() && image.getVmSnapshotId().equals(previousActiveSnapshotId)) {
            // Image is already active, hence only update snapshot ID.
            imageDao.updateImageVmSnapshotId(image.getImageId(), newActiveSnapshotId);
            excludedImages.add(image);
        }
    }
    return excludedImages;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(ImagesHandler.filterDisksBasedOnCinder(getVm().getDiskMap().values(), true));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (Guid.Empty.equals(getParameters().getDstSnapshotId())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    VmValidator vmValidator = new VmValidator(getVm());
    if (!validate(vmValidator.vmDown()) || !validate(snapshotsValidator.snapshotExists(getVmId(), getParameters().getDstSnapshotId())) || !validate(snapshotsValidator.vmNotDuringSnapshot(getVmId())) || !validate(snapshotsValidator.vmNotInPreview(getVmId()))) {
        return false;
    }
    updateVmDisksFromDb();
    List<DiskImage> diskImages = DisksFilter.filterImageDisks(getVm().getDiskMap().values(), ONLY_NOT_SHAREABLE, ONLY_SNAPABLE, ONLY_ACTIVE);
    diskImages.addAll(DisksFilter.filterCinderDisks(getVm().getDiskMap().values(), ONLY_PLUGGED));
    if (!diskImages.isEmpty()) {
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImages);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        DiskImagesValidator diskImagesToPreviewValidator = new DiskImagesValidator(getImagesToPreview());
        if (!validate(diskImagesToPreviewValidator.diskImagesNotIllegal()) || !validate(diskImagesToPreviewValidator.diskImagesNotLocked())) {
            return false;
        }
        Set<Guid> storageIds = ImagesHandler.getAllStorageIdsForImageIds(diskImages);
        MultipleStorageDomainsValidator storageValidator = new MultipleStorageDomainsValidator(getVm().getStoragePoolId(), storageIds);
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp()) || !validate(storageValidator.allDomainsExistAndActive()) || !validate(storageValidator.allDomainsWithinThresholds()) || !validateCinder()) {
            return false;
        }
    }
    DiskSnapshotsValidator diskSnapshotsValidator = new DiskSnapshotsValidator(getParameters().getDisks());
    if (!validate(diskSnapshotsValidator.canDiskSnapshotsBePreviewed(getParameters().getDstSnapshotId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean validateCinder() {
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()));
    if (!cinderDisks.isEmpty()) {
        CinderDisksValidator cinderDisksValidator = getCinderDisksValidator(cinderDisks);
        return validate(cinderDisksValidator.validateCinderDiskLimits());
    }
    return true;
}
#method_after
public boolean validateCinder() {
    List<CinderDisk> cinderDisks = DisksFilter.filterCinderDisks(diskDao.getAllForVm(getVmId()));
    if (!cinderDisks.isEmpty()) {
        CinderDisksValidator cinderDisksValidator = getCinderDisksValidator(cinderDisks);
        return validate(cinderDisksValidator.validateCinderDiskLimits());
    }
    return true;
}
#end_block

#method_before
private Snapshot getDstSnapshot() {
    if (cachedSnapshot == null) {
        cachedSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    }
    return cachedSnapshot;
}
#method_after
private Snapshot getDstSnapshot() {
    if (cachedSnapshot == null) {
        cachedSnapshot = snapshotDao.get(getParameters().getDstSnapshotId());
    }
    return cachedSnapshot;
}
#end_block

#method_before
protected void updateVmDisksFromDb() {
    VmHandler.updateDisksFromDb(getVm());
}
#method_after
protected void updateVmDisksFromDb() {
    vmHandler.updateDisksFromDb(getVm());
}
#end_block

#method_before
@Test
public void testIsHostedEngineStorage() {
    // create hosted engine vm
    VmStatic vm = new VmStatic();
    vm.setId(Guid.newGuid());
    vm.setOrigin(OriginType.HOSTED_ENGINE);
    dbFacade.getVmStaticDao().save(vm);
    // create disk for HE
    DiskImage disk = new DiskImage();
    disk.setId(Guid.newGuid());
    disk.setImageId(Guid.newGuid());
    disk.setVolumeType(VolumeType.Preallocated);
    disk.setVolumeFormat(VolumeFormat.RAW);
    dbFacade.getImageDao().save(disk.getImage());
    dbFacade.getBaseDiskDao().save(disk);
    ImageStorageDomainMap map = new ImageStorageDomainMap(disk.getImageId(), existingDomain.getId(), null, null);
    dbFacade.getImageStorageDomainMapDao().save(map);
    // attach disk
    VmDevice device = new VmDevice(new VmDeviceId(disk.getId(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, false, false, "", null, null, null);
    dbFacade.getVmDeviceDao().save(device);
    DiskVmElement diskVmElement = new DiskVmElement(device.getId());
    diskVmElement.setDiskInterface(DiskInterface.IDE);
    dbFacade.getDiskVmElementDao().save(diskVmElement);
    // run test
    StorageDomain domain = dao.get(existingDomain.getId());
    assertTrue(domain.isHostedEngineStorage());
}
#method_after
@Test
public void testIsHostedEngineStorage() {
    // create hosted engine vm
    VmStatic vm = new VmStatic();
    vm.setId(Guid.newGuid());
    vm.setOrigin(OriginType.HOSTED_ENGINE);
    dbFacade.getVmStaticDao().save(vm);
    // create disk for HE
    DiskImage disk = new DiskImage();
    disk.setId(Guid.newGuid());
    disk.setImageId(Guid.newGuid());
    disk.setActive(true);
    disk.setVolumeType(VolumeType.Preallocated);
    disk.setVolumeFormat(VolumeFormat.RAW);
    dbFacade.getImageDao().save(disk.getImage());
    dbFacade.getBaseDiskDao().save(disk);
    ImageStorageDomainMap map = new ImageStorageDomainMap(disk.getImageId(), existingDomain.getId(), null, null);
    dbFacade.getImageStorageDomainMapDao().save(map);
    // attach disk
    VmDevice device = new VmDevice(new VmDeviceId(disk.getId(), vm.getId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, false, false, "", null, null, null);
    dbFacade.getVmDeviceDao().save(device);
    DiskVmElement diskVmElement = new DiskVmElement(device.getId());
    diskVmElement.setDiskInterface(DiskInterface.IDE);
    dbFacade.getDiskVmElementDao().save(diskVmElement);
    // run test
    StorageDomain domain = dao.get(existingDomain.getId());
    assertTrue(domain.isHostedEngineStorage());
    // change origin
    vm.setOrigin(OriginType.MANAGED_HOSTED_ENGINE);
    dbFacade.getVmStaticDao().update(vm);
    // run test again
    domain = dao.get(existingDomain.getId());
    assertTrue(domain.isHostedEngineStorage());
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getId(), committedDiskSize, dynamicData, staticData, storageDomainSharedStatus, storageDomainOverCommitPercent, storagePoolIsoMapData, totalDiskSize);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getId(), committedDiskSize, dynamicData, staticData, storageDomainSharedStatus, storageDomainOverCommitPercent, storagePoolIsoMapData, totalDiskSize, supportsDiscard, supportsDiscardZeroesData, hostedEngineStorage);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageDomain)) {
        return false;
    }
    StorageDomain other = (StorageDomain) obj;
    return Objects.equals(getId(), other.getId()) && committedDiskSize == other.committedDiskSize && storageDomainSharedStatus == other.storageDomainSharedStatus && storageDomainOverCommitPercent == other.storageDomainOverCommitPercent && Objects.equals(totalDiskSize, other.totalDiskSize);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageDomain)) {
        return false;
    }
    StorageDomain other = (StorageDomain) obj;
    return Objects.equals(getId(), other.getId()) && committedDiskSize == other.committedDiskSize && storageDomainSharedStatus == other.storageDomainSharedStatus && storageDomainOverCommitPercent == other.storageDomainOverCommitPercent && Objects.equals(totalDiskSize, other.totalDiskSize) && Objects.equals(supportsDiscard, other.supportsDiscard) && Objects.equals(supportsDiscardZeroesData, other.supportsDiscardZeroesData) && hostedEngineStorage == other.hostedEngineStorage;
}
#end_block

#method_before
@Override
public boolean test(Disk disk) {
    return diskStorageType == disk.getDiskStorageType();
}
#method_after
@Override
public boolean test(Disk disk) {
    return DiskStorageType.forClass(implementingDiskType) == disk.getDiskStorageType();
}
#end_block

#method_before
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, VmStatic vmStatic, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(vmStatic.getOsId(), cluster.getCompatibilityVersion()), templateId, instanceTypeId)) {
        // it is not defined on the template
        params.setBalloonEnabled(instanceTypeId != null ? !VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId) : null);
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setConsoleEnabled(instanceTypeId != null ? !getConsoleDevicesForEntity(instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        List<VmRngDevice> devices = VmHelper.getRngDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId);
        if (devices != null && !devices.isEmpty()) {
            final VmRngDevice rngDevice = devices.get(0);
            final Version effectiveVersion = CommonCompatibilityVersionUtils.getEffective(vmStatic.getCustomCompatibilityVersion(), cluster.getCompatibilityVersion(), null);
            rngDevice.updateSourceByVersion(effectiveVersion);
            boolean supported = EnumSet.of(RngUtils.RngValidationResult.VALID, RngUtils.RngValidationResult.UNSUPPORTED_URANDOM_OR_RANDOM).contains(RngUtils.validate(cluster, rngDevice, effectiveVersion));
            if (shouldCopyDevice(supported, templateId, instanceTypeId)) {
                params.setUpdateRngDevice(true);
                params.setRngDevice(rngDevice);
            }
        }
    }
}
#method_after
private void addDevicesToParams(AddVmParameters params, Vm vm, VmTemplate template, InstanceType instanceType, VmStatic vmStatic, Cluster cluster) {
    Guid templateId = template != null ? template.getId() : null;
    Guid instanceTypeId = instanceType != null ? instanceType.getId() : null;
    if (vm.isSetVirtioScsi()) {
        params.setVirtioScsiEnabled(vm.getVirtioScsi().isEnabled());
    } else {
        // it is not defined on the template
        params.setVirtioScsiEnabled(instanceTypeId != null ? !VmHelper.getVirtioScsiControllersForEntity(this, instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetSoundcardEnabled()) {
        params.setSoundDeviceEnabled(vm.isSoundcardEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setSoundDeviceEnabled(!VmHelper.getSoundDevicesForEntity(this, instanceTypeId != null ? instanceTypeId : templateId).isEmpty());
    }
    if (vm.isSetMemoryPolicy()) {
        params.setBalloonEnabled(vm.getMemoryPolicy().isBallooning());
    } else if (shouldCopyDevice(SimpleDependencyInjector.getInstance().get(OsRepository.class).isBalloonEnabled(vmStatic.getOsId(), cluster.getCompatibilityVersion()), templateId, instanceTypeId)) {
        // it is not defined on the template
        params.setBalloonEnabled(instanceTypeId != null ? !VmHelper.isMemoryBalloonEnabledForEntity(this, instanceTypeId) : null);
    }
    if (vm.isSetConsole()) {
        params.setConsoleEnabled(vm.getConsole().isEnabled());
    } else if (instanceTypeId != null || templateId != null) {
        params.setConsoleEnabled(instanceTypeId != null ? !getConsoleDevicesForEntity(instanceTypeId).isEmpty() : null);
    }
    if (vm.isSetRngDevice()) {
        params.setUpdateRngDevice(true);
        params.setRngDevice(RngDeviceMapper.map(vm.getRngDevice(), null));
    } else if (instanceTypeId != null || templateId != null) {
        copyRngDeviceFromTemplateOrInstanceType(params, vmStatic, cluster, templateId, instanceTypeId);
    }
}
#end_block

#method_before
/*
     * VirtIO-SCSI controller
     */
public void updateVirtioScsiController(Guid vmId, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    if (isVirtioScsiEnabled) {
        if (!hasVirtioScsiController(vmId)) {
            addVirtioScsiController(vmId);
        }
    } else {
        removeVirtioScsiControllers(vmId);
    }
}
#method_after
/*
     * VirtIO-SCSI controller
     */
public void updateVirtioScsiController(VmBase vm, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    removeVirtioScsiControllers(vm.getId());
    if (isVirtioScsiEnabled) {
        addVirtioScsiController(vm, getVmCompatibilityVersion(vm));
    }
}
#end_block

#method_before
public VmDevice addVirtioScsiController(Guid vmId) {
    return addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, Collections.emptyMap(), true, false);
}
#method_after
public void addVirtioScsiController(VmBase vm, Version version) {
    boolean hasIoThreads = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(version);
    int numOfScsiControllers = hasIoThreads ? vm.getNumOfIoThreads() : 1;
    for (int i = 0; i < numOfScsiControllers; i++) {
        Map<String, Object> specParams = new HashMap<>();
        if (hasIoThreads) {
            specParams.put(VdsProperties.ioThreadId, i);
        }
        VmDevice device = addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, specParams, true, false);
    }
}
#end_block

#method_before
public void updateBootOrder(Guid vmId) {
    VM vm = vmDao.get(vmId);
    if (vm != null) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vmId);
        // Reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VmHandler.updateDisksForVm(vm, diskDao.getAllForVm(vmId));
        VmHandler.updateDisksVmDataForVm(vm);
        VmHandler.updateNetworkInterfacesFromDb(vm);
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices);
        vmDeviceDao.updateBootOrderInBatch(devices);
    }
}
#method_after
public void updateBootOrder(Guid vmId) {
    VM vm = vmDao.get(vmId);
    if (vm != null) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vmId);
        // Reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        vmHandler.updateDisksForVm(vm, diskDao.getAllForVm(vmId));
        vmHandler.updateDisksVmDataForVm(vm);
        vmHandler.updateNetworkInterfacesFromDb(vm);
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices);
        vmDeviceDao.updateBootOrderInBatch(devices);
    }
}
#end_block

#method_before
public void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase newVmBase = params.getVmStaticData();
    if (newVmBase == null) {
        return;
    }
    updateCdPath(oldVmBase, newVmBase);
    updateBootOrder(oldVmBase, newVmBase);
    updateVideoDevices(oldVmBase, newVmBase);
    updateUsbSlots(oldVmBase, newVmBase);
    updateMemoryBalloon(newVmBase.getId(), params.isBalloonEnabled());
    updateSoundDevice(oldVmBase, newVmBase, oldVm.getCompatibilityVersion(), params.isSoundDeviceEnabled());
    updateSmartcardDevice(oldVm, newVmBase);
    updateConsoleDevice(newVmBase.getId(), params.isConsoleEnabled());
    updateVirtioScsiController(newVmBase.getId(), params.isVirtioScsiEnabled());
}
#method_after
public void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase newVmBase = params.getVmStaticData();
    if (newVmBase == null) {
        return;
    }
    updateCdPath(oldVmBase, newVmBase);
    updateBootOrder(oldVmBase, newVmBase);
    updateVideoDevices(oldVmBase, newVmBase);
    updateUsbSlots(oldVmBase, newVmBase);
    updateMemoryBalloon(newVmBase.getId(), params.isBalloonEnabled());
    updateSoundDevice(oldVmBase, newVmBase, oldVm.getCompatibilityVersion(), params.isSoundDeviceEnabled());
    updateSmartcardDevice(oldVm, newVmBase);
    updateConsoleDevice(newVmBase.getId(), params.isConsoleEnabled());
    updateVirtioScsiController(newVmBase, params.isVirtioScsiEnabled());
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices, Version versionToUpdateRndDeviceWith) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device), dstVmBase.getCustomCompatibilityVersion()).isValid()) {
                    continue;
                }
                final VmRngDevice rngDevice = new VmRngDevice(device);
                if (versionToUpdateRndDeviceWith != null) {
                    rngDevice.updateSourceByVersion(versionToUpdateRndDeviceWith);
                }
                specParams.putAll(rngDevice.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices, Version versionToUpdateRngDeviceWith) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device), dstVmBase.getCustomCompatibilityVersion()).isValid()) {
                    continue;
                }
                final VmRngDevice rngDevice = new VmRngDevice(device);
                if (versionToUpdateRngDeviceWith != null) {
                    rngDevice.updateSourceByVersion(versionToUpdateRngDeviceWith);
                }
                specParams.putAll(rngDevice.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstVmBase, getVmCompatibilityVersion(dstVmBase));
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    return vmManagedDeviceMap;
}
#method_after
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = vmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        VmHandler.updateDefaultTimeZone(parameterMasterVm);
        VmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        VmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        VmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#method_after
@Override
protected void init() {
    T parameters = getParameters();
    super.setVmTemplateName(parameters.getName());
    VmStatic parameterMasterVm = parameters.getMasterVm();
    if (parameterMasterVm != null) {
        super.setVmId(parameterMasterVm.getId());
        setClusterId(parameterMasterVm.getClusterId());
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getMasterVm(), getMasterVmCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (getParameters().isSoundDeviceEnabled() == null) {
            parameters.setSoundDeviceEnabled(false);
        }
        if (getParameters().isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmHandler.updateDefaultTimeZone(parameterMasterVm);
        vmHandler.autoSelectUsbPolicy(getParameters().getMasterVm());
        vmHandler.autoSelectDefaultDisplayType(getVmId(), getParameters().getMasterVm(), getCluster(), getParameters().getGraphicsDevices());
        vmHandler.autoSelectGraphicsDevice(getVmId(), parameterMasterVm, getCluster(), getParameters().getGraphicsDevices(), getMasterVmCompatibilityVersion());
        separateCustomProperties(parameterMasterVm);
    }
    if (getVm() != null) {
        updateVmDevices();
        images.addAll(getVmDisksFromDB());
        setStoragePoolId(getVm().getStoragePoolId());
        isVmInDb = true;
    } else if (getCluster() != null && parameterMasterVm != null) {
        VM vm = new VM(parameterMasterVm, new VmDynamic(), null);
        vm.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        setVm(vm);
        setStoragePoolId(getCluster().getStoragePoolId());
    }
    updateDiskInfoDestinationMap();
    parameters.setUseCinderCommandCallback(!getCinderDisks().isEmpty());
}
#end_block

#method_before
protected List<DiskImage> getVmDisksFromDB() {
    VmHandler.updateDisksFromDb(getVm());
    VmHandler.filterImageDisksForVM(getVm());
    return getVm().getDiskList();
}
#method_after
protected List<DiskImage> getVmDisksFromDB() {
    vmHandler.updateDisksFromDb(getVm());
    vmHandler.filterImageDisksForVM(getVm());
    return getVm().getDiskList();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
        // Error cloning Cinder disks for template
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        VmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = vmDynamicDao.get(getVmId());
        if (!isVmStatusValid(vmDynamic.getStatus())) {
            throw new EngineException(EngineError.IRS_IMAGE_STATUS_ILLEGAL);
        }
        vmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    // set template id as base for new templates
    if (!isTemplateVersion()) {
        getParameters().setBaseTemplateId(getVmTemplateId());
        if (StringUtils.isEmpty(getParameters().getTemplateVersionName())) {
            getParameters().setTemplateVersionName(BASE_TEMPLATE_VERSION_NAME);
        }
    } else {
        // template version name should be the same as the base template name
        setVmTemplateName(getBaseTemplate().getName());
        String jobId = updateVmsJobIdMap.remove(getParameters().getBaseTemplateId());
        if (!StringUtils.isEmpty(jobId)) {
            log.info("Cancelling current running update for vms for base template id '{}'", getParameters().getBaseTemplateId());
            try {
                getSchedulUtil().deleteJob(jobId);
            } catch (Exception e) {
                log.warn("Failed deleting job '{}' at cancelRecoveryJob", jobId);
            }
        }
    }
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(() -> {
        addVmTemplateToDb();
        getCompensationContext().stateChanged();
        return null;
    });
    if (getVm() != null && !addVmTemplateCinderDisks(srcDeviceIdToTargetDeviceIdMapping)) {
        // Error cloning Cinder disks for template
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addPermission();
        addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
        addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
        Set<GraphicsType> graphicsToSkip = getParameters().getGraphicsDevices().keySet();
        if (isVmInDb) {
            getVmDeviceUtils().copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), getVmDeviceUtils().hasMemoryBalloon(getVmId()), graphicsToSkip, false, getEffectiveVersion());
        } else {
            // for instance type and new template without a VM
            getVmDeviceUtils().copyVmDevices(VmTemplateHandler.BLANK_VM_TEMPLATE_ID, getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled(), Boolean.TRUE.equals(getParameters().isBalloonEnabled()), graphicsToSkip, false, getEffectiveVersion());
        }
        updateWatchdog(getVmTemplateId());
        updateRngDevice(getVmTemplateId());
        addGraphicsDevice();
        setSucceeded(true);
        return null;
    });
    if (getParameters().getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        vmHandler.warnMemorySizeLegal(getVmTemplate(), getVm().getCompatibilityVersion());
    }
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty() || !CommandCoordinatorUtil.getChildCommandIds(getCommandId()).isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!VmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return imagesRelatedChecks() && validate(VmValidator.validateCpuSockets(getParameters().getMasterVm(), getVm().getCompatibilityVersion().toString()));
}
#method_after
private boolean doClusterRelatedChecks() {
    // A Template cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (!vmHandler.isOsTypeSupported(getParameters().getMasterVm().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the display type is supported
    Guid srcId = isVmInDb ? getVmId() : VmTemplateHandler.BLANK_VM_TEMPLATE_ID;
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getMasterVm().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(srcId), getParameters().getGraphicsDevices()), getParameters().getMasterVm().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVm().getCompatibilityVersion())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !vmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the watchdog model is supported
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getMasterVm().getOsId(), getParameters().getWatchdog(), getVm().getCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Disallow cross-DC template creation
    if (!getStoragePoolId().equals(getCluster().getStoragePoolId())) {
        addValidationMessage(EngineMessage.VDS_CLUSTER_ON_DIFFERENT_STORAGE_POOL);
        return false;
    }
    if (!VmPropertiesUtils.getInstance().validateVmProperties(getVm().getCompatibilityVersion(), getParameters().getMasterVm().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    return imagesRelatedChecks() && validate(VmValidator.validateCpuSockets(getParameters().getMasterVm(), getVm().getCompatibilityVersion().toString()));
}
#end_block

#method_before
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!images.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = getCinderDisks();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = DisksFilter.filterImageDisks(images, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = storageDomainDao.getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (storageDomainStaticDao.get(destImageDomain) == null) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
        }
        return validateSpaceRequirements();
    }
    return true;
}
#method_after
protected boolean imagesRelatedChecks() {
    // images related checks
    if (!images.isEmpty()) {
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<CinderDisk> cinderDisks = getCinderDisks();
        CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
        if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
            return false;
        }
        if (!validate(isPassDiscardSupportedForImagesDestSds())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = DisksFilter.filterImageDisks(images, ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        diskImagesToCheck.addAll(cinderDisks);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = getStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = storageDomainDao.getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (storageDomainStaticDao.get(destImageDomain) == null) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST);
                } else {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL);
                return false;
            }
            if (storage.getStorageDomainType().isIsoOrImportExportDomain()) {
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
        }
        return validateSpaceRequirements();
    }
    return true;
}
#end_block

#method_before
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId()));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    VmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    VmHandler.addVmInitToDB(getVmTemplate());
}
#method_after
protected void addVmTemplateToDb() {
    // TODO: add timezone handling
    setVmTemplate(new VmTemplate(0, new Date(), getParameters().getDescription(), getParameters().getMasterVm().getComment(), getParameters().getMasterVm().getMemSizeMb(), getVmTemplateName(), getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getParameters().getMasterVm().getThreadsPerCpu(), getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getClusterId(), getVmTemplateId(), getParameters().getMasterVm().getNumOfMonitors(), getParameters().getMasterVm().getSingleQxlPci(), VmTemplateStatus.Locked.getValue(), getParameters().getMasterVm().getUsbPolicy().getValue(), getParameters().getMasterVm().getTimeZone(), getParameters().getMasterVm().getNiceLevel(), getParameters().getMasterVm().getCpuShares(), getParameters().getMasterVm().isFailBack(), getParameters().getMasterVm().getDefaultBootSequence(), getParameters().getMasterVm().getVmType(), getParameters().getMasterVm().isSmartcardEnabled(), getParameters().getMasterVm().isDeleteProtected(), getParameters().getMasterVm().getSsoMethod(), getParameters().getMasterVm().getTunnelMigration(), getParameters().getMasterVm().getVncKeyboardLayout(), getParameters().getMasterVm().getMinAllocatedMem(), getParameters().getMasterVm().isStateless(), getParameters().getMasterVm().isRunAndPause(), getUserId(), getParameters().getTemplateType(), getParameters().getMasterVm().isAutoStartup(), getParameters().getMasterVm().getPriority(), getParameters().getMasterVm().getDefaultDisplayType(), getParameters().getMasterVm().getInitrdUrl(), getParameters().getMasterVm().getKernelUrl(), getParameters().getMasterVm().getKernelParams(), getParameters().getMasterVm().getQuotaId(), getParameters().getMasterVm().getDedicatedVmForVdsList(), getParameters().getMasterVm().getMigrationSupport(), getParameters().getMasterVm().isAllowConsoleReconnect(), getParameters().getMasterVm().getIsoPath(), getParameters().getMasterVm().getMigrationDowntime(), getParameters().getBaseTemplateId(), getParameters().getTemplateVersionName(), getParameters().getMasterVm().getSerialNumberPolicy(), getParameters().getMasterVm().getCustomSerialNumber(), getParameters().getMasterVm().isBootMenuEnabled(), getParameters().getMasterVm().isSpiceFileTransferEnabled(), getParameters().getMasterVm().isSpiceCopyPasteEnabled(), getParameters().getMasterVm().getCpuProfileId(), getParameters().getMasterVm().getNumaTuneMode(), getParameters().getMasterVm().getAutoConverge(), getParameters().getMasterVm().getMigrateCompressed(), getParameters().getMasterVm().getUserDefinedProperties(), getParameters().getMasterVm().getPredefinedProperties(), getParameters().getMasterVm().getCustomProperties(), getParameters().getMasterVm().getCustomEmulatedMachine(), getParameters().getMasterVm().getCustomCpuName(), getParameters().getMasterVm().getSmallIconId(), getParameters().getMasterVm().getLargeIconId(), getParameters().getMasterVm().getNumOfIoThreads(), getParameters().getMasterVm().getConsoleDisconnectAction(), getParameters().getMasterVm().getCustomCompatibilityVersion(), getParameters().getMasterVm().getMigrationPolicyId()));
    updateVmIcons();
    vmTemplateDao.save(getVmTemplate());
    getCompensationContext().snapshotNewEntity(getVmTemplate());
    setActionReturnValue(getVmTemplate().getId());
    // Load Vm Init from DB and set it to the template
    vmHandler.updateVmInitFromDB(getParameters().getMasterVm(), false);
    getVmTemplate().setVmInit(getParameters().getMasterVm().getVmInit());
    vmHandler.addVmInitToDB(getVmTemplate());
}
#end_block

#method_before
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.unLockVm(getVm());
    }
    VmTemplateHandler.unlockVmTemplate(getVmTemplateId());
}
#method_after
private void endUnlockOps() {
    if (isVmInDb) {
        vmHandler.unLockVm(getVm());
    }
    vmTemplateHandler.unlockVmTemplate(getVmTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(p.getCommandType(), p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            vmTemplateDao.remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().endAction(p.getCommandType(), p, cloneContextAndDetachFromParent());
    }
    if (CommandCoordinatorUtil.getCommandExecutionStatus(getParameters().getCommandId()) == CommandExecutionStatus.EXECUTED) {
        // if template exist in db remove it
        if (getVmTemplate() != null) {
            vmTemplateDao.remove(getVmTemplateId());
            removeNetwork();
        }
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        vmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    VmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#method_after
@Override
protected void init() {
    super.init();
    T parameters = getParameters();
    if (parameters.getVmStaticData() != null) {
        Guid templateIdToUse = getParameters().getVmStaticData().getVmtGuid();
        if (parameters.getVmStaticData().isUseLatestVersion()) {
            VmTemplate latest = vmTemplateDao.getTemplateWithLatestVersionInChain(templateIdToUse);
            if (latest != null) {
                // as it may have different set of disks
                if (!templateIdToUse.equals(latest.getId())) {
                    getParameters().setDiskInfoDestinationMap(new HashMap<>());
                }
                setVmTemplate(latest);
                templateIdToUse = latest.getId();
                getParameters().getVmStaticData().setVmtGuid(templateIdToUse);
            }
        }
        setVmTemplateId(templateIdToUse);
        // API backward compatibility
        if (getVmDeviceUtils().shouldOverrideSoundDevice(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion(), getParameters().isSoundDeviceEnabled())) {
            parameters.setSoundDeviceEnabled(true);
        }
        if (parameters.isConsoleEnabled() == null) {
            parameters.setConsoleEnabled(false);
        }
        vmDevicesSourceId = (getInstanceTypeId() != null) ? getInstanceTypeId() : parameters.getVmStaticData().getVmtGuid();
        imageTypeId = parameters.getVmStaticData().getImageTypeId();
        vmInterfacesSourceId = parameters.getVmStaticData().getVmtGuid();
        vmDisksSource = getVmTemplate();
    }
    parameters.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    // override values here for validate to run with correct values, has to come before init-disks
    updateVmObject();
    initTemplateDisks();
    initStoragePoolId();
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<>();
    }
    vmHandler.updateDefaultTimeZone(parameters.getVmStaticData());
    // Fill the migration policy if it was omitted
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getMigrationSupport() == null) {
        setDefaultMigrationPolicy();
    }
    if (vmDisksSource != null) {
        parameters.setUseCinderCommandCallback(!vmDisksSource.getDiskTemplateMap().isEmpty());
    }
}
#end_block

#method_before
protected void initTemplateDisks() {
    if (vmDisksSource != null) {
        VmTemplateHandler.updateDisksFromDb(vmDisksSource);
    }
}
#method_after
protected void initTemplateDisks() {
    if (vmDisksSource != null) {
        vmTemplateHandler.updateDisksFromDb(vmDisksSource);
    }
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return VmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getValidationMessages());
}
#method_after
protected boolean canAddVm(List<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    if (!canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority())) {
        return false;
    }
    if (!validateCustomProperties(vmStaticFromParams, reasons)) {
        return false;
    }
    // check that template image and vm are on the same storage pool
    if (shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            return false;
        }
        for (StorageDomain domain : destStorages) {
            StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
            if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                return false;
            }
        }
        if (!validateSpaceRequirements()) {
            return false;
        }
    }
    return vmHandler.validateDedicatedVdsExistOnSameCluster(vmStaticFromParams, getReturnValue().getValidationMessages());
}
#end_block

#method_before
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages());
}
#method_after
protected boolean checkSingleQxlDisplay() {
    if (!getParameters().getVmStaticData().getSingleQxlPci()) {
        return true;
    }
    return vmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getCluster() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
    }
    if (getVmTemplate() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (getStoragePool() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_EXIST);
    }
    if (!isExternalVM() && getStoragePool().getStatus() != StoragePoolStatus.Up) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
    }
    if (!isTemplateInValidDc()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_NOT_EXISTS_IN_CURRENT_DC);
    }
    if (!isDisksVolumeFormatValid()) {
        return false;
    }
    // A VM cannot be added in a cluster without a defined architecture
    if (getCluster().getArchitecture() == ArchitectureType.undefined) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
    }
    if (verifySourceDomains() && buildAndCheckDestStorageDomains()) {
        chooseDisksSourceDomains();
    } else {
        return false;
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!validateAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    // check if the selected template is compatible with Cluster architecture.
    if (!getVmTemplate().getId().equals(VmTemplateHandler.BLANK_VM_TEMPLATE_ID) && getCluster().getArchitecture() != getVmTemplate().getClusterArch()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_INCOMPATIBLE);
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // check if the OS type is supported
    if (!vmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!vmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!vmHandler.isGraphicsAndDisplaySupported(getParameters().getVmStaticData().getOsId(), vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning if the check haven't failed yet
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (getInstanceTypeId() != null && getInstanceType() == null) {
        // invalid instance type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!validate(VmValidator.validateCpuSockets(getParameters().getVmStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled())) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getVmId() != null && vmStaticDao.get(getVmId()) != null) {
        return failValidation(EngineMessage.VM_ID_EXISTS);
    }
    List<CinderDisk> cinderDisks = ImagesHandler.filterDisksBasedOnCinder(diskInfoDestinationMap.values());
    CinderDisksValidator cinderDisksValidator = new CinderDisksValidator(cinderDisks);
    if (!validate(cinderDisksValidator.validateCinderDiskLimits())) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getSmallIconId(), "Small"))) {
        return false;
    }
    if (getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getLargeIconId(), "Large"))) {
        return false;
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(VmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkTemplateImages(List<String> reasons) {
    if (getParameters().getParentCommand() == VdcActionType.AddVmPool) {
        return true;
    }
    for (StorageDomain storage : destStorages.values()) {
        if (!validate(vmTemplateHandler.isVmTemplateImagesReady(vmDisksSource, storage.getId(), false, false, true, true, storageToDisksMap.get(storage.getId())))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
}
#method_after
@Override
protected void executeVmCommand() {
    vmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    List<String> errorMessages = new ArrayList<>();
    if (!canAddVm(errorMessages, destStorages.values())) {
        log.error("Failed to add VM. The reasons are: {}", String.join(",", errorMessages));
        return;
    }
    TransactionSupport.executeInNewTransaction(() -> {
        addVmStatic();
        addVmDynamic();
        addVmNetwork();
        addVmNumaNodes();
        addVmStatistics();
        addActiveSnapshot();
        addVmPermission();
        addVmInit();
        addVmRngDevice();
        getCompensationContext().stateChanged();
        return null;
    });
    if (addVmImages()) {
        TransactionSupport.executeInNewTransaction(() -> {
            copyDiskVmElements();
            copyVmDevices();
            addDiskPermissions();
            addVmPayload();
            updateSmartCardDevices();
            addVmWatchdog();
            addGraphicsDevice();
            setActionReturnValue(getVm().getId());
            setSucceeded(true);
            return null;
        });
    }
    if (getParameters().getPoolId() != null) {
        addVmToPool();
    }
}
#end_block

#method_before
private void addVmInit() {
    VmHandler.addVmInitToDB(getParameters().getVmStaticData());
}
#method_after
private void addVmInit() {
    vmHandler.addVmInitToDB(getParameters().getVmStaticData());
}
#end_block

#method_before
protected void lockVM() {
    VmHandler.lockVm(getVmId());
}
#method_after
protected void lockVM() {
    vmHandler.lockVm(getVmId());
}
#end_block

#method_before
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getCluster().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getCluster().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    VmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    // Choose a proper default display type according to the cluster architecture
    VmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    VmHandler.autoSelectGraphicsDevice(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices(), getEffectiveCompatibilityVersion());
}
#method_after
private void updateVmObject() {
    updateParametersVmFromInstanceType();
    // set vm interface source id to be the instance type, vm interface are taken from it
    if (getInstanceType() != null) {
        vmInterfacesSourceId = getInstanceTypeId();
    }
    VmStatic vmStatic = getParameters().getVmStaticData();
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
    // Choose a proper default OS according to the cluster architecture
    if (getParameters().getVmStaticData().getOsId() == OsRepository.AUTO_SELECT_OS) {
        if (getCluster().getArchitecture() != ArchitectureType.undefined) {
            Integer defaultOs = osRepository.getDefaultOSes().get(getCluster().getArchitecture());
            getParameters().getVmStaticData().setOsId(defaultOs);
        }
    }
    vmHandler.autoSelectUsbPolicy(getParameters().getVmStaticData());
    // Choose a proper default display type according to the cluster architecture
    vmHandler.autoSelectDefaultDisplayType(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices());
    // If not set by user, choose proper graphics device according to the cluster architecture
    vmHandler.autoSelectGraphicsDevice(vmDevicesSourceId, getParameters().getVmStaticData(), getCluster(), getParameters().getGraphicsDevices(), getEffectiveCompatibilityVersion());
}
#end_block

#method_before
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return VmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#method_after
protected boolean checkNumberOfMonitors() {
    Collection<GraphicsType> graphicsTypes = vmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices());
    int numOfMonitors = getParameters().getVmStaticData().getNumOfMonitors();
    return vmHandler.isNumOfMonitorsLegal(graphicsTypes, numOfMonitors, getReturnValue().getValidationMessages());
}
#end_block

#method_before
protected void updateCurrentCd(String cdPath) {
    cdPath = StringUtils.isEmpty(cdPath) ? null : cdPath;
    VmHandler.updateCurrentCd(getVdsId(), getVm(), cdPath);
}
#method_after
protected void updateCurrentCd(String cdPath) {
    cdPath = StringUtils.isEmpty(cdPath) ? null : cdPath;
    vmHandler.updateCurrentCd(getVdsId(), getVm(), cdPath);
}
#end_block

#method_before
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getCluster().getEmulatedMachine());
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    getVmDeviceUtils().updateVmDevicesOnRun(getVm().getStaticData());
    updateGraphicsInfos();
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    if (getParameters().getBootMenuEnabled() != null) {
        getVm().setBootMenuEnabled(getParameters().getBootMenuEnabled());
    }
    if (getParameters().getSpiceFileTransferEnabled() != null) {
        getVm().setSpiceFileTransferEnabled(getParameters().getSpiceFileTransferEnabled());
    }
    if (getParameters().getSpiceCopyPasteEnabled() != null) {
        getVm().setSpiceCopyPasteEnabled(getParameters().getSpiceCopyPasteEnabled());
    }
    // Clear the first user:
    getVm().setConsoleUserId(null);
    if (getParameters().getInitializationType() == null) {
        vmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
        if (!getVm().isInitialized() && getVm().getVmInit() != null) {
            getVm().setInitializationType(InitializationType.None);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                if (!isPayloadExists(VmDeviceType.FLOPPY)) {
                    getVm().setInitializationType(InitializationType.Sysprep);
                }
            } else if (getVm().getVmInit() != null) {
                if (!isPayloadExists(VmDeviceType.CDROM)) {
                    getVm().setInitializationType(InitializationType.CloudInit);
                }
            }
        }
    } else if (getParameters().getInitializationType() != InitializationType.None) {
        getVm().setInitializationType(getParameters().getInitializationType());
        // the payload since we can only have one media (Floppy/CDROM) per payload.
        if (getParameters().getInitializationType() == InitializationType.Sysprep && isPayloadExists(VmDeviceType.FLOPPY)) {
            getVm().setVmPayload(null);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && isPayloadExists(VmDeviceType.CDROM)) {
            getVm().setVmPayload(null);
        }
    }
    // have floppy payload since we are limited to only one floppy device
    if (!StringUtils.isEmpty(getParameters().getFloppyPath()) && isPayloadExists(VmDeviceType.FLOPPY)) {
        getVm().setVmPayload(null);
    }
    vmHandler.updateVmGuestAgentVersion(getVm());
    // update dynamic cluster-parameters
    if (getVm().getCpuName() == null) {
        // no run-once data -> use static field or inherit from cluster
        if (getVm().getCustomCpuName() != null) {
            getVm().setCpuName(getVm().getCustomCpuName());
        } else {
            // get what cpu flags should be passed to vdsm according to the cluster
            getVm().setCpuName(getCpuFlagsManagerHandler().getCpuId(getVm().getClusterCpuName(), getVm().getCompatibilityVersion()));
        }
    }
    if (getVm().getEmulatedMachine() == null) {
        getVm().setEmulatedMachine(getVm().getCustomEmulatedMachine() != null ? getVm().getCustomEmulatedMachine() : getCluster().getEmulatedMachine());
    }
    getVm().setHibernationVolHandle(getMemoryFromActiveSnapshot());
}
#end_block

#method_before
protected void fetchVmDisksFromDb() {
    if (getVm().getDiskMap().isEmpty()) {
        VmHandler.updateDisksFromDb(getVm());
    }
}
#method_after
protected void fetchVmDisksFromDb() {
    if (getVm().getDiskMap().isEmpty()) {
        vmHandler.updateDisksFromDb(getVm());
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getValidationMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), getCluster())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failValidation(EngineMessage.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    boolean isWindowsOs = osRepository.isWindows(getVm().getVmOsId());
    boolean isCloudInitEnabled = (!getVm().isInitialized() && getVm().getVmInit() != null && !isWindowsOs) || (getParameters().getInitializationType() == InitializationType.CloudInit);
    boolean hasCdromPayload = getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    if ((hasCdromPayload || isCloudInitEnabled) && hasMaximumNumberOfDisks()) {
        return failValidation(EngineMessage.VMPAYLOAD_CDROM_OR_CLOUD_INIT_MAXIMUM_DEVICES);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failValidation(EngineMessage.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failValidation(EngineMessage.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (!VmHandler.isCpuSupported(getVm().getVmOsId(), getVm().getCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    try {
        acquireHostDevicesLock();
        if (!checkRequiredHostDevicesAvailability()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
        }
    } finally {
        releaseHostDevicesLock();
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validateObject(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    RunVmValidator runVmValidator = getRunVmValidator();
    if (!runVmValidator.canRunVm(getReturnValue().getValidationMessages(), getStoragePool(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), getCluster())) {
        return false;
    }
    if (!validate(runVmValidator.validateNetworkInterfaces())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failValidation(EngineMessage.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    if (!checkRngDeviceClusterCompatibility()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_SOURCE_NOT_SUPPORTED);
    }
    boolean isWindowsOs = osRepository.isWindows(getVm().getVmOsId());
    boolean isCloudInitEnabled = (!getVm().isInitialized() && getVm().getVmInit() != null && !isWindowsOs) || (getParameters().getInitializationType() == InitializationType.CloudInit);
    boolean hasCdromPayload = getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM;
    if ((hasCdromPayload || isCloudInitEnabled) && hasMaximumNumberOfDisks()) {
        return failValidation(EngineMessage.VMPAYLOAD_CDROM_OR_CLOUD_INIT_MAXIMUM_DEVICES);
    }
    // Currently we cannot use two payloads in the same media (cdrom/floppy)
    if (getParameters().getInitializationType() != null) {
        if (getParameters().getInitializationType() == InitializationType.Sysprep && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.FLOPPY) {
            return failValidation(EngineMessage.VMPAYLOAD_FLOPPY_WITH_SYSPREP);
        } else if (getParameters().getInitializationType() == InitializationType.CloudInit && getParameters().getVmPayload() != null && getParameters().getVmPayload().getDeviceType() == VmDeviceType.CDROM) {
            return failValidation(EngineMessage.VMPAYLOAD_CDROM_WITH_CLOUD_INIT);
        }
    }
    if (!vmHandler.isCpuSupported(getVm().getVmOsId(), getVm().getCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    try {
        acquireHostDevicesLock();
        if (!checkRequiredHostDevicesAvailability()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_DEVICE_NOT_AVAILABLE);
        }
    } finally {
        releaseHostDevicesLock();
    }
    return true;
}
#end_block

#method_before
protected void loadVmInit() {
    if (getVm().getVmInit() == null) {
        VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
    }
}
#method_after
protected void loadVmInit() {
    if (getVm().getVmInit() == null) {
        vmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, supportedClusterVersionsSet, supportedEngineVersionsSet, buildName, cpuCores, cpuThreads, cpuFlags, cpuModel, cpuSockets, cpuSpeedMh, onlineCpus, guestOverhead, hooksStr, hostOs, iScsiInitiatorName, ifTotalSpeed, kernelVersion, kvmEnabled, kvmVersion, libvirtVersion, rpmVersion, memCommited, netConfigDirty, nonOperationalReason, pendingVcpusCount, pendingVmemSize, physicalMemMb, previousStatus, reservedMem, softwareVersion, spiceVersion, glusterVersion, status, supportedClusterLevels, supportedEngines, transparentHugePagesState, versionName, vmActive, vmCount, supportedRngSources, vmMigrating, incomingMigrations, outgoingMigrations, vmsCoresCount, hwManufacturer, hwProductName, hwVersion, hwSerialNumber, hwUUID, hwFamily, HBAs, powerManagementControlledByPolicy, kdumpStatus, selinuxEnforceMode, numaNodeList, autoNumaBalancing, numaSupport, additionalFeatures, maintenanceReason, updateAvailable, hostDevicePassthroughEnabled, kernelArgs, prettyName);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, supportedClusterVersionsSet, supportedEngineVersionsSet, buildName, cpuCores, cpuThreads, cpuFlags, cpuModel, cpuSockets, cpuSpeedMh, onlineCpus, guestOverhead, hooksStr, hostOs, iScsiInitiatorName, ifTotalSpeed, kernelVersion, kvmEnabled, kvmVersion, libvirtVersion, rpmVersion, memCommited, netConfigDirty, nonOperationalReason, pendingVcpusCount, pendingVmemSize, physicalMemMb, previousStatus, reservedMem, softwareVersion, spiceVersion, glusterVersion, status, supportedClusterLevels, supportedEngines, transparentHugePagesState, versionName, vmActive, vmCount, supportedRngSources, vmMigrating, incomingMigrations, outgoingMigrations, vmsCoresCount, hwManufacturer, hwProductName, hwVersion, hwSerialNumber, hwUUID, hwFamily, HBAs, powerManagementControlledByPolicy, kdumpStatus, selinuxEnforceMode, autoNumaBalancing, numaSupport, additionalFeatures, maintenanceReason, updateAvailable, hostDevicePassthroughEnabled, kernelArgs, prettyName);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsDynamic)) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return dbEquals(other) && Objects.equals(numaNodeList, other.numaNodeList);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VdsDynamic)) {
        return false;
    }
    VdsDynamic other = (VdsDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(getSupportedClusterVersionsSet(), other.getSupportedClusterVersionsSet()) && Objects.equals(supportedEngineVersionsSet, other.supportedEngineVersionsSet) && Objects.equals(buildName, other.buildName) && Objects.equals(cpuCores, other.cpuCores) && Objects.equals(cpuThreads, other.cpuThreads) && Objects.equals(cpuFlags, other.cpuFlags) && Objects.equals(cpuModel, other.cpuModel) && Objects.equals(cpuSockets, other.cpuSockets) && Objects.equals(cpuSpeedMh, other.cpuSpeedMh) && Objects.equals(onlineCpus, other.onlineCpus) && Objects.equals(guestOverhead, other.guestOverhead) && Objects.equals(hooksStr, other.hooksStr) && Objects.equals(hostOs, other.hostOs) && Objects.equals(iScsiInitiatorName, other.iScsiInitiatorName) && Objects.equals(ifTotalSpeed, other.ifTotalSpeed) && Objects.equals(kernelVersion, other.kernelVersion) && Objects.equals(kvmEnabled, other.kvmEnabled) && Objects.equals(kvmVersion, other.kvmVersion) && Objects.equals(libvirtVersion, other.libvirtVersion) && Objects.equals(rpmVersion, other.rpmVersion) && Objects.equals(memCommited, other.memCommited) && Objects.equals(netConfigDirty, other.netConfigDirty) && nonOperationalReason == other.nonOperationalReason && Objects.equals(pendingVcpusCount, other.pendingVcpusCount) && Objects.equals(pendingVmemSize, other.pendingVmemSize) && Objects.equals(physicalMemMb, other.physicalMemMb) && previousStatus == other.previousStatus && Objects.equals(reservedMem, other.reservedMem) && Objects.equals(getSoftwareVersion(), other.getSoftwareVersion()) && Objects.equals(spiceVersion, other.spiceVersion) && Objects.equals(glusterVersion, other.glusterVersion) && status == other.status && Objects.equals(supportedClusterLevels, other.supportedClusterLevels) && Objects.equals(supportedEngines, other.supportedEngines) && transparentHugePagesState == other.transparentHugePagesState && Objects.equals(versionName, other.versionName) && Objects.equals(vmActive, other.vmActive) && vmCount == other.vmCount && Objects.equals(vmMigrating, other.vmMigrating) && incomingMigrations == other.incomingMigrations && outgoingMigrations == other.outgoingMigrations && Objects.equals(vmsCoresCount, other.vmsCoresCount) && Objects.equals(hwManufacturer, other.hwManufacturer) && Objects.equals(hwProductName, other.hwProductName) && Objects.equals(hwVersion, other.hwVersion) && Objects.equals(hwSerialNumber, other.hwSerialNumber) && Objects.equals(hwUUID, other.hwUUID) && Objects.equals(hwFamily, other.hwFamily) && Objects.equals(HBAs, other.HBAs) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && kdumpStatus == other.kdumpStatus && Objects.equals(selinuxEnforceMode, other.selinuxEnforceMode) && autoNumaBalancing.getValue() == other.autoNumaBalancing.getValue() && numaSupport == other.numaSupport && Objects.equals(supportedEmulatedMachines, other.supportedEmulatedMachines) && powerManagementControlledByPolicy == other.powerManagementControlledByPolicy && Objects.equals(supportedRngSources, other.supportedRngSources) && Objects.equals(maintenanceReason, other.maintenanceReason) && updateAvailable == other.updateAvailable && Objects.equals(additionalFeatures, other.additionalFeatures) && Objects.equals(kernelArgs, other.kernelArgs) && Objects.equals(hostDevicePassthroughEnabled, other.hostDevicePassthroughEnabled) && Objects.equals(prettyName, other.prettyName);
}
#end_block

#method_before
@Test
public void testCreateDecoratedPoolWhenNoDecoratorsAreRequested() {
    doAnswer(invocation -> invocation.getArguments()[0]).when(lockedObjectFactoryMock).createLockingInstance(any(), eq(MacPool.class), any());
    MacPool decoratedPool = decoratePoolWhileNotUsingLocking(Collections.emptyList());
    assertThat(decoratedPool, is(macPool));
}
#method_after
@Test
public void testCreateDecoratedPoolWhenNoDecoratorsAreRequested() {
    MacPool decoratedPool = decoratePoolWhileNotUsingLocking(Collections.emptyList());
    assertThat(decoratedPool, is(macPool));
}
#end_block

#method_before
private DecoratedMacPoolFactory createDecoratedMacPoolFactoryWithDisabledLocking() {
    doAnswer(invocation -> invocation.getArguments()[0]).when(lockedObjectFactoryMock).createLockingInstance(any(), eq(MacPool.class), any());
    return new DecoratedMacPoolFactory(lockedObjectFactoryMock);
}
#method_after
private DecoratedMacPoolFactory createDecoratedMacPoolFactoryWithDisabledLocking() {
    doAnswer(invocation -> invocation.getArguments()[0]).when(lockedObjectFactory).createLockingInstance(any(), eq(MacPool.class), any());
    return new DecoratedMacPoolFactory(lockedObjectFactory);
}
#end_block

#method_before
protected void initTooltip() {
    tooltip = new WidgetTooltip(getContents());
    tooltip.setPlacement(Placement.BOTTOM);
    String tooltipContent = infoPopup.getTooltipContent(item, this);
    if (tooltipContent != null) {
        tooltip.setHtml(SafeHtmlUtils.fromTrustedString(tooltipContent));
    }
}
#method_after
protected void initTooltip() {
    tooltip = new WidgetTooltip(getContents());
    tooltip.setPlacement(Placement.BOTTOM);
    SafeHtml tooltipContent = infoPopup.getTooltipContent(item);
    if (tooltipContent != null) {
        tooltip.setHtml(tooltipContent);
    }
}
#end_block

#method_before
protected Object runQuery(VdcQueryType queryType, VdcQueryParametersBase queryParams, String sessionId, InitialContext ctx) {
    initQueryParams(queryParams, sessionId);
    VdcQueryReturnValue result = FiltersHelper.getBackend(ctx).runQuery(queryType, queryParams);
    return result != null && result.getSucceeded() ? result.getReturnValue() : null;
}
#method_after
protected Object runQuery(VdcQueryType queryType, String sessionId, InitialContext ctx) {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(sessionId);
    queryParams.setFiltered(FILTER_QUERIES);
    VdcQueryReturnValue result = FiltersHelper.getBackend(ctx).runQuery(queryType, queryParams);
    return result != null && result.getSucceeded() ? result.getReturnValue() : null;
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.debug("Entered SsoPostLoginFilter");
    HttpServletRequest req = (HttpServletRequest) request;
    try {
        String engineSessionId = (String) req.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (StringUtils.isEmpty(engineSessionId) && req.getSession(false) != null) {
            engineSessionId = (String) req.getSession(false).getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        }
        if (StringUtils.isNotEmpty(engineSessionId)) {
            InitialContext ctx = new InitialContext();
            try {
                String ssoToken = getSsoToken(engineSessionId, ctx);
                log.debug("Adding userInfo to session");
                req.getSession(true).setAttribute(ATTR_USER_INFO, getUserInfoObject(getLoggedInUser(engineSessionId, ctx), ssoToken));
                chain.doFilter(request, response);
            } finally {
                ctx.close();
            }
        } else {
            log.info("No sessionId in request or session");
        }
    } catch (Exception ex) {
        log.error("Unable to get token for engine session {}", ex.getMessage());
    }
    log.debug("Exiting SsoPostLoginFilter");
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    log.debug("Entered SsoPostLoginFilter");
    HttpServletRequest req = (HttpServletRequest) request;
    try {
        String engineSessionId = (String) req.getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        if (StringUtils.isEmpty(engineSessionId) && req.getSession(false) != null) {
            engineSessionId = (String) req.getSession(false).getAttribute(SessionConstants.HTTP_SESSION_ENGINE_SESSION_ID_KEY);
        }
        if (StringUtils.isNotEmpty(engineSessionId)) {
            InitialContext ctx = new InitialContext();
            try {
                String ssoToken = (String) runQuery(VdcQueryType.GetEngineSessionIdToken, engineSessionId, ctx);
                log.debug("Adding userInfo to session");
                DbUser loggedInUser = (DbUser) runQuery(VdcQueryType.GetUserBySessionId, engineSessionId, ctx);
                req.getSession(true).setAttribute(ATTR_USER_INFO, getUserInfoObject(loggedInUser, ssoToken));
                chain.doFilter(request, response);
            } finally {
                ctx.close();
            }
        } else {
            log.warn("Missing sessionId in either request or session scope. " + "Please configure SSO properly with SsoPostLoginServlet.");
        }
    } catch (Exception ex) {
        log.error("Unable to get token for engine session {}", ex.getMessage());
        log.debug("Exception", ex);
    }
    log.debug("Exiting SsoPostLoginFilter");
}
#end_block

#method_before
public static IVdsServer createVdsServer(String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    HttpClient client = HttpUtils.getConnection(clientTimeOut, connectionTimeOut, clientRetries, Config.getValue(ConfigValues.VdsMaxConnectionsPerHost), Config.getValue(ConfigValues.MaxTotalConnections));
    String eventQueue = Config.getValue(ConfigValues.EventQueueName);
    return new JsonRpcVdsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.getValue(ConfigValues.EncryptHostCommunication), Config.getValue(ConfigValues.VdsmSSLProtocol), Config.getValue(ConfigValues.EventProcessingPoolSize), Config.getValue(ConfigValues.VdsRequestQueueName), Config.getValue(ConfigValues.VdsResponseQueueName), eventQueue), client);
}
#method_after
public static IVdsServer createVdsServer(String hostname, int port, int clientTimeOut, int connectionTimeOut, int clientRetries, int heartbeat) {
    HttpClient client = HttpUtils.getConnection(connectionTimeOut, clientRetries, Config.getValue(ConfigValues.VdsMaxConnectionsPerHost), Config.getValue(ConfigValues.MaxTotalConnections));
    String eventQueue = Config.getValue(ConfigValues.EventQueueName);
    return new JsonRpcVdsServer(JsonRpcUtils.createStompClient(hostname, port, connectionTimeOut, clientTimeOut, clientRetries, heartbeat, Config.getValue(ConfigValues.EncryptHostCommunication), Config.getValue(ConfigValues.VdsmSSLProtocol), Config.getValue(ConfigValues.EventProcessingPoolSize), Config.getValue(ConfigValues.VdsRequestQueueName), Config.getValue(ConfigValues.VdsResponseQueueName), eventQueue), client);
}
#end_block

#method_before
private Map<VmDevice, Integer> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringHelper.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstTwoLuns);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#method_after
private Map<VmDevice, Integer> getVmDeviceUnitMapForScsiDisks(VM vm, DiskInterface scsiInterface, boolean reserveFirstTwoLuns) {
    List<Disk> disks = new ArrayList<>(vm.getDiskMap().values());
    Map<VmDevice, Integer> vmDeviceUnitMap = new HashMap<>();
    Map<VmDevice, Disk> vmDeviceDiskMap = new HashMap<>();
    for (Disk disk : disks) {
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        if (dve.getDiskInterface() == scsiInterface) {
            VmDevice vmDevice = getVmDeviceByDiskId(disk.getId(), vm.getId());
            Map<String, String> address = StringMapUtils.string2Map(vmDevice.getAddress());
            String unitStr = address.get(VdsProperties.Unit);
            // Otherwise, adding to 'vmDeviceDiskMap' for setting the unit property later.
            if (StringUtils.isNotEmpty(unitStr)) {
                vmDeviceUnitMap.put(vmDevice, Integer.valueOf(unitStr));
            } else {
                vmDeviceDiskMap.put(vmDevice, disk);
            }
        }
    }
    // Find available unit (disk's index in VirtIO-SCSI controller) for disks with empty address
    for (Entry<VmDevice, Disk> entry : vmDeviceDiskMap.entrySet()) {
        int unit = getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstTwoLuns);
        vmDeviceUnitMap.put(entry.getKey(), unit);
    }
    return vmDeviceUnitMap;
}
#end_block

#method_before
void addAddress(VmDevice vmDevice, Map<String, Object> struct) {
    Map<String, String> addressMap = StringHelper.string2Map(vmDevice.getAddress());
    if (!addressMap.isEmpty()) {
        struct.put(VdsProperties.Address, addressMap);
    }
}
#method_after
void addAddress(VmDevice vmDevice, Map<String, Object> struct) {
    Map<String, String> addressMap = StringMapUtils.string2Map(vmDevice.getAddress());
    if (!addressMap.isEmpty()) {
        struct.put(VdsProperties.Address, addressMap);
    }
}
#end_block

#method_before
protected ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getStorageType() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = StringHelper.string2Map(mountOptions);
    Set<String> optionsKeys = new HashSet<>();
    for (String option : optionsMap.keySet()) {
        optionsKeys.add(option.toLowerCase());
    }
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addValidationMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(EngineMessage.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#method_after
protected ValidationResult validateMountOptions() {
    String mountOptions = getConnection().getMountOptions();
    if (StringUtils.isBlank(mountOptions)) {
        return ValidationResult.VALID;
    }
    List<String> disallowedOptions = getConnection().getStorageType() == StorageType.POSIXFS ? POSIX_MANAGED_OPTIONS : NFS_MANAGED_OPTIONS;
    Map<String, String> optionsMap = StringMapUtils.string2Map(mountOptions);
    Set<String> optionsKeys = new HashSet<>();
    for (String option : optionsMap.keySet()) {
        optionsKeys.add(option.toLowerCase());
    }
    optionsKeys.retainAll(disallowedOptions);
    if (!optionsKeys.isEmpty()) {
        addValidationMessageVariable("invalidOptions", StringUtils.join(optionsKeys, ", "));
        return new ValidationResult(EngineMessage.VALIDATION_STORAGE_CONNECTION_MOUNT_OPTIONS_CONTAINS_MANAGED_PROPERTY);
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(status);
    if (entity.getExternalStatus() != null) {
        ExternalStatus externalStatus = ExternalStatusMapper.map(entity.getExternalStatus());
        model.setExternalStatus(externalStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.setStatusDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.setStatusDetail(entity.getMaintenanceReason());
    }
    Spm spm = new Spm();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(mapSpmStatus(entity.getSpmStatus()));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(mapOperatingSystem(entity));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSeLinux(map(entity, (SeLinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    if (entity.getHostName() != null) {
        String subject = CertificateSubjectHelper.getCertificateSubject(entity.getHostName());
        model.setCertificate(new Certificate());
        model.getCertificate().setSubject(subject);
        model.getCertificate().setOrganization(subject.split(",")[0].replace("O=", ""));
    }
    return model;
}
#method_after
@Mapping(from = VDS.class, to = Host.class)
public static Host map(VDS entity, Host template) {
    Host model = template != null ? template : new Host();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setComment(entity.getComment());
    if (entity.getClusterId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getClusterId().toString());
        model.setCluster(cluster);
    }
    model.setAddress(entity.getHostName());
    if (entity.getPort() > 0) {
        model.setPort(entity.getPort());
    }
    // We return always STOMP because support for XML-RPC was removed in version 4.1 of the engine.
    model.setProtocol(HostProtocol.STOMP);
    HostStatus status = map(entity.getStatus(), null);
    model.setStatus(status);
    if (entity.getExternalStatus() != null) {
        ExternalStatus externalStatus = ExternalStatusMapper.map(entity.getExternalStatus());
        model.setExternalStatus(externalStatus);
    }
    if (status == HostStatus.NON_OPERATIONAL) {
        model.setStatusDetail(entity.getNonOperationalReason().name().toLowerCase());
    } else if (status == HostStatus.MAINTENANCE || status == HostStatus.PREPARING_FOR_MAINTENANCE) {
        model.setStatusDetail(entity.getMaintenanceReason());
    }
    Spm spm = new Spm();
    spm.setPriority(entity.getVdsSpmPriority());
    if (entity.getSpmStatus() != null) {
        spm.setStatus(mapSpmStatus(entity.getSpmStatus()));
    }
    model.setSpm(spm);
    if (entity.getVersion() != null && entity.getVersion().getMajor() != -1 && entity.getVersion().getMinor() != -1 && entity.getVersion().getRevision() != -1 && entity.getVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getVersion().getMajor());
        version.setMinor(entity.getVersion().getMinor());
        version.setRevision(entity.getVersion().getRevision());
        version.setBuild(entity.getVersion().getBuild());
        version.setFullVersion(entity.getVersion().getRpmName());
        model.setVersion(version);
    }
    model.setOs(mapOperatingSystem(entity));
    model.setKsm(new Ksm());
    model.getKsm().setEnabled(Boolean.TRUE.equals(entity.getKsmState()));
    model.setTransparentHugepages(new TransparentHugePages());
    model.getTransparentHugepages().setEnabled(!(entity.getTransparentHugePagesState() == null || entity.getTransparentHugePagesState() == VdsTransparentHugePagesState.Never));
    if (entity.getIScsiInitiatorName() != null) {
        model.setIscsi(new IscsiDetails());
        model.getIscsi().setInitiator(entity.getIScsiInitiatorName());
    }
    model.setPowerManagement(map(entity, (PowerManagement) null));
    model.setHardwareInformation(map(entity, (HardwareInformation) null));
    model.setSsh(map(entity.getStaticData(), null));
    Cpu cpu = new Cpu();
    CpuTopology cpuTopology = new CpuTopology();
    if (entity.getCpuSockets() != null) {
        cpuTopology.setSockets(entity.getCpuSockets());
        if (entity.getCpuCores() != null) {
            cpuTopology.setCores(entity.getCpuCores() / entity.getCpuSockets());
            if (entity.getCpuThreads() != null) {
                cpuTopology.setThreads(entity.getCpuThreads() / entity.getCpuCores());
            }
        }
    }
    cpu.setTopology(cpuTopology);
    cpu.setName(entity.getCpuModel());
    if (entity.getCpuSpeedMh() != null) {
        cpu.setSpeed(new BigDecimal(entity.getCpuSpeedMh()));
    }
    model.setCpu(cpu);
    VmSummary vmSummary = new VmSummary();
    vmSummary.setActive(entity.getVmActive());
    vmSummary.setMigrating(entity.getVmMigrating());
    vmSummary.setTotal(entity.getVmCount());
    model.setSummary(vmSummary);
    if (entity.getVdsType() != null) {
        HostType type = map(entity.getVdsType(), null);
        model.setType(type);
    }
    model.setMemory(Long.valueOf(entity.getPhysicalMemMb() == null ? 0 : entity.getPhysicalMemMb() * BYTES_IN_MEGABYTE));
    model.setMaxSchedulingMemory((int) entity.getMaxSchedulingMemory() * BYTES_IN_MEGABYTE);
    if (entity.getLibvirtVersion() != null && entity.getLibvirtVersion().getMajor() != -1 && entity.getLibvirtVersion().getMinor() != -1 && entity.getLibvirtVersion().getRevision() != -1 && entity.getLibvirtVersion().getBuild() != -1) {
        Version version = new Version();
        version.setMajor(entity.getLibvirtVersion().getMajor());
        version.setMinor(entity.getLibvirtVersion().getMinor());
        version.setRevision(entity.getLibvirtVersion().getRevision());
        version.setBuild(entity.getLibvirtVersion().getBuild());
        version.setFullVersion(entity.getLibvirtVersion().getRpmName());
        model.setLibvirtVersion(version);
    }
    if (entity.getConsoleAddress() != null && !"".equals(entity.getConsoleAddress())) {
        model.setDisplay(new Display());
        model.getDisplay().setAddress(entity.getConsoleAddress());
    }
    model.setKdumpStatus(map(entity.getKdumpStatus(), null));
    model.setSeLinux(map(entity, (SeLinux) null));
    model.setAutoNumaStatus(map(entity.getAutoNumaBalancing(), null));
    model.setNumaSupported(entity.isNumaSupport());
    if (entity.getHostProviderId() != null) {
        model.setExternalHostProvider(new ExternalHostProvider());
        model.getExternalHostProvider().setId(entity.getHostProviderId().toString());
    }
    model.setUpdateAvailable(entity.isUpdateAvailable());
    HostDevicePassthrough devicePassthrough = model.getDevicePassthrough();
    if (devicePassthrough == null) {
        devicePassthrough = new HostDevicePassthrough();
        model.setDevicePassthrough(devicePassthrough);
    }
    devicePassthrough.setEnabled(entity.isHostDevicePassthroughEnabled());
    if (entity.getHostName() != null) {
        String subject = CertificateSubjectHelper.getCertificateSubject(entity.getHostName());
        model.setCertificate(new Certificate());
        model.getCertificate().setSubject(subject);
        model.getCertificate().setOrganization(subject.split(",")[0].replace("O=", ""));
    }
    return model;
}
#end_block

#method_before
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = StringHelper.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = StringHelper.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean searchForDuplicatesWithExistingVmDevices(VmDevice vmDeviceToHotplug) {
    String deviceAddress = vmDeviceToHotplug.getAddress();
    if (StringUtils.isEmpty(deviceAddress)) {
        return false;
    }
    Map<String, String> addressMapToHotplug = StringMapUtils.string2Map(deviceAddress);
    List<VmDevice> allVmDevices = vmDeviceDao.getVmDeviceByVmId(getVm().getId());
    for (VmDevice vmDevice : allVmDevices) {
        if (!vmDeviceToHotplug.getId().equals(vmDevice.getId())) {
            Map<String, String> deviceAddressMap = StringMapUtils.string2Map(vmDevice.getAddress());
            if (deviceAddressMap.equals(addressMapToHotplug)) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
public static HttpClient getConnection(int clientTimeOut, int connectionTimeOut, int clientRetries, int maxConnectionsPerHost, int maxTotalConnections) {
    HttpConnectionManagerParams params = new HttpConnectionManagerParams();
    params.setConnectionTimeout(connectionTimeOut);
    params.setDefaultMaxConnectionsPerHost(maxConnectionsPerHost);
    params.setMaxTotalConnections(maxTotalConnections);
    MultiThreadedHttpConnectionManager httpConnectionManager = new MultiThreadedHttpConnectionManager();
    httpConnectionManager.setParams(params);
    // Create the client:
    HttpClient client = new HttpClient(httpConnectionManager);
    // Configure the HTTP client so it will retry the execution of
    // methods when there are IO errors:
    int retries = Config.getValue(ConfigValues.vdsRetries);
    HttpMethodRetryHandler handler = new DefaultHttpMethodRetryHandler(retries, false);
    HttpClientParams parameters = client.getParams();
    parameters.setParameter(HttpMethodParams.RETRY_HANDLER, handler);
    // Done:
    return client;
}
#method_after
public static HttpClient getConnection(int connectionTimeOut, int clientRetries, int maxConnectionsPerHost, int maxTotalConnections) {
    HttpConnectionManagerParams params = new HttpConnectionManagerParams();
    params.setConnectionTimeout(connectionTimeOut);
    params.setDefaultMaxConnectionsPerHost(maxConnectionsPerHost);
    params.setMaxTotalConnections(maxTotalConnections);
    MultiThreadedHttpConnectionManager httpConnectionManager = new MultiThreadedHttpConnectionManager();
    httpConnectionManager.setParams(params);
    // Create the client:
    HttpClient client = new HttpClient(httpConnectionManager);
    // Configure the HTTP client so it will retry the execution of
    // methods when there are IO errors:
    int retries = Config.getValue(ConfigValues.vdsRetries);
    HttpMethodRetryHandler handler = new DefaultHttpMethodRetryHandler(retries, false);
    HttpClientParams parameters = client.getParams();
    parameters.setParameter(HttpMethodParams.RETRY_HANDLER, handler);
    // Done:
    return client;
}
#end_block

#method_before
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new EngineException(EngineError.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        getCinderBroker().updateConnectionInfoForDisk(cinderDisk);
    }
    Map<String, String> diskAddressMap = getDiskAddressMap(vmDevice, getDiskVmElement().getDiskInterface());
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice, diskAddressMap, getDiskVmElement().getDiskInterface()));
}
#method_after
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new EngineException(EngineError.StorageServerConnectionError);
                }
            }
        }
    } else if (disk.getDiskStorageType() == DiskStorageType.CINDER) {
        CinderDisk cinderDisk = (CinderDisk) disk;
        setStorageDomainId(cinderDisk.getStorageIds().get(0));
        getCinderBroker().updateConnectionInfoForDisk(cinderDisk);
    }
    Map<String, String> diskAddressMap = getDiskAddressMap(vmDevice, getDiskVmElement().getDiskInterface());
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice, diskAddressMap, getDiskVmElement().getDiskInterface(), getDiskVmElement().isPassDiscard()));
}
#end_block

#method_before
protected void updateDisksFromDb() {
    VmHandler.updateDisksFromDb(getVm());
}
#method_after
protected void updateDisksFromDb() {
    vmHandler.updateDisksFromDb(getVm());
}
#end_block

#method_before
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return StringHelper.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            lockManager.releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#method_after
public Map<String, String> getDiskAddressMap(VmDevice vmDevice, DiskInterface diskInterface) {
    String address = vmDevice.getAddress();
    if (diskInterface != DiskInterface.VirtIO_SCSI && diskInterface != DiskInterface.SPAPR_VSCSI) {
        if (StringUtils.isNotBlank(address)) {
            return StringMapUtils.string2Map(address);
        }
    } else {
        EngineLock vmDiskHotPlugEngineLock = null;
        try {
            vmDiskHotPlugEngineLock = lockVmDiskHotPlugWithWait();
            VM vm = vmDao.get(getParameters().getVmId());
            Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
            int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
            int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
            if (diskInterface == DiskInterface.VirtIO_SCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, virtioScsiIndex, false);
            } else if (diskInterface == DiskInterface.SPAPR_VSCSI) {
                Map<VmDevice, Integer> vmDeviceUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(getVm());
                return getAddressMapForScsiDisk(address, vmDeviceUnitMap, vmDevice, sPaprVscsiIndex, true);
            }
        } finally {
            lockManager.releaseLock(vmDiskHotPlugEngineLock);
        }
    }
    return null;
}
#end_block

#method_before
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = StringHelper.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#method_after
private Map<String, String> getAddressMapForScsiDisk(String address, Map<VmDevice, Integer> vmDeviceUnitMap, VmDevice vmDevice, int controllerIndex, boolean reserveFirstAddress) {
    Map<String, String> addressMap;
    int availableUnit = vmInfoBuildUtils.getAvailableUnitForScsiDisk(vmDeviceUnitMap, reserveFirstAddress);
    // Otherwise, set address according to the next available unit.
    if (StringUtils.isNotBlank(address)) {
        addressMap = StringMapUtils.string2Map(address);
        int unit = Integer.parseInt(addressMap.get(VdsProperties.Unit));
        if (vmDeviceUnitMap.containsValue(unit)) {
            addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
        }
    } else {
        addressMap = vmInfoBuildUtils.createAddressForScsiDisk(controllerIndex, availableUnit);
    }
    // Updating device's address immediately (instead of waiting to VmsMonitoring)
    // to prevent a duplicate unit value (i.e. ensuring a unique unit value).
    updateVmDeviceAddress(addressMap.toString(), vmDevice);
    return addressMap;
}
#end_block

#method_before
private Map<String, Object> buildData() {
    Map<String, Object> data = new HashMap<>();
    Map<String, Object> memDeviceData = new HashMap<>();
    VmDevice vmDevice = getParameters().getMemoryDevice();
    data.put("vmId", getParameters().getVmId().toString());
    memDeviceData.put(VdsProperties.Type, vmDevice.getType().getValue());
    memDeviceData.put(VdsProperties.Device, vmDevice.getDevice());
    if (StringUtils.isNotBlank(vmDevice.getAddress())) {
        memDeviceData.put(VdsProperties.Address, StringHelper.string2Map(vmDevice.getAddress()));
    }
    memDeviceData.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    memDeviceData.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    memDeviceData.put("size", vmDevice.getSpecParams().get("size"));
    memDeviceData.put("node", vmDevice.getSpecParams().get("node"));
    data.put("memory", memDeviceData);
    return data;
}
#method_after
private Map<String, Object> buildData() {
    Map<String, Object> data = new HashMap<>();
    Map<String, Object> memDeviceData = new HashMap<>();
    VmDevice vmDevice = getParameters().getMemoryDevice();
    data.put("vmId", getParameters().getVmId().toString());
    memDeviceData.put(VdsProperties.Type, vmDevice.getType().getValue());
    memDeviceData.put(VdsProperties.Device, vmDevice.getDevice());
    if (StringUtils.isNotBlank(vmDevice.getAddress())) {
        memDeviceData.put(VdsProperties.Address, StringMapUtils.string2Map(vmDevice.getAddress()));
    }
    memDeviceData.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
    memDeviceData.put(VdsProperties.DeviceId, vmDevice.getId().getDeviceId().toString());
    memDeviceData.put("size", vmDevice.getSpecParams().get("size"));
    memDeviceData.put("node", vmDevice.getSpecParams().get("node"));
    data.put("memory", memDeviceData);
    return data;
}
#end_block

#method_before
@Override
protected void executeVDSCommand() {
    try {
        executeVdsBrokerCommand();
    } catch (UndeclaredThrowableException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, ex.getMessage()));
        if (ExceptionUtils.getRootCause(ex) != null) {
            logException(ExceptionUtils.getRootCause(ex));
        } else {
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
        }
    } catch (IRSUnicodeArgumentException ex) {
        throw new IRSGenericException("UNICODE characters are not supported.", ex);
    } catch (IRSStoragePoolStatusException | IrsOperationFailedNoFailoverException ex) {
        throw ex;
    } catch (IRSNonOperationalException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        getVDSReturnValue().setVdsError(ex.getVdsError());
        logException(ex);
        getVDSReturnValue().setCanTryOnDifferentVds(true);
    } catch (IRSErrorException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        getVDSReturnValue().setVdsError(ex.getVdsError());
        logException(ex);
        if (log.isDebugEnabled()) {
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
        }
        getVDSReturnValue().setCanTryOnDifferentVds(true);
    } catch (RuntimeException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        if (ex instanceof VDSExceptionBase) {
            getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
        }
        if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
            logException(ExceptionUtils.getRootCause(ex));
        } else {
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
        }
        // always failover because of changes in vdsm error, until we
        // realize what to do in each case:
        getVDSReturnValue().setCanTryOnDifferentVds(true);
    }
}
#method_after
@Override
protected void executeVDSCommand() {
    try {
        executeVdsBrokerCommand();
    } catch (UndeclaredThrowableException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        getVDSReturnValue().setVdsError(new VDSError(EngineError.VDS_NETWORK_ERROR, ex.getMessage()));
        if (ExceptionUtils.getRootCause(ex) != null) {
            logException(ExceptionUtils.getRootCause(ex));
        } else {
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
        }
    } catch (TransportRunTimeException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        if (ex.isNetworkError()) {
            log.error("StorageJobCommand::Failed::{} - network exception.", getCommandName());
            getVDSReturnValue().setSucceeded(false);
        } else {
            log.error("StorageJobCommand::Failed::{}", getCommandName());
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            throw new IRSProtocolException(ex);
        }
    } catch (IRSUnicodeArgumentException ex) {
        throw new IRSGenericException("UNICODE characters are not supported.", ex);
    } catch (IRSStoragePoolStatusException | IrsOperationFailedNoFailoverException ex) {
        throw ex;
    } catch (IRSNonOperationalException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        getVDSReturnValue().setVdsError(ex.getVdsError());
        logException(ex);
        getVDSReturnValue().setCanTryOnDifferentVds(true);
    } catch (IRSErrorException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        getVDSReturnValue().setVdsError(ex.getVdsError());
        logException(ex);
        if (log.isDebugEnabled()) {
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
        }
        getVDSReturnValue().setCanTryOnDifferentVds(true);
    } catch (RuntimeException ex) {
        getVDSReturnValue().setExceptionString(ex.toString());
        getVDSReturnValue().setExceptionObject(ex);
        if (ex instanceof VDSExceptionBase) {
            getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
        }
        if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
            logException(ExceptionUtils.getRootCause(ex));
        } else {
            LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
        }
        // always failover because of changes in vdsm error, until we
        // realize what to do in each case:
        getVDSReturnValue().setCanTryOnDifferentVds(true);
    }
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withParameter("arbiter", isArbiter).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#end_block

#method_before
private void addAddress(Map<String, Object> map, String address) {
    if (StringUtils.isNotBlank(address)) {
        map.put(VdsProperties.Address, StringHelper.string2Map(getParameters().getVmDevice().getAddress()));
    }
}
#method_after
private void addAddress(Map<String, Object> map, String address) {
    if (StringUtils.isNotBlank(address)) {
        map.put(VdsProperties.Address, StringMapUtils.string2Map(getParameters().getVmDevice().getAddress()));
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getCompensationContext().snapshotEntityStatus(getVds().getDynamicData(), getParameters().getInitialStatus());
    getCompensationContext().stateChanged();
    VDSType vdsType = getVds().getVdsType();
    if (vdsType == VDSType.VDS || vdsType == VDSType.oVirtNode) {
        try {
            setVdsStatus(VDSStatus.Installing);
            Updateable upgradeManager = new HostUpgradeManager();
            upgradeManager.update(getVds());
            if (vdsType == VDSType.oVirtNode) {
                VdsActionParameters params = new VdsActionParameters(getVds().getId());
                params.setPrevVdsStatus(getVds().getStatus());
                setVdsStatus(VDSStatus.Reboot);
                runInternalAction(VdcActionType.SshHostReboot, params, ExecutionHandler.createInternalJobContext());
            }
        } catch (Exception e) {
            setVdsStatus(VDSStatus.InstallFailed);
            return;
        }
    } else if (getVds().isOvirtVintageNode()) {
        InstallVdsParameters parameters = new InstallVdsParameters(getVdsId());
        parameters.setIsReinstallOrUpgrade(true);
        parameters.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        parameters.setActivateHost(getParameters().getInitialStatus() == VDSStatus.Up);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpgradeOvirtNodeInternal, parameters);
        if (!result.getSucceeded()) {
            setVdsStatus(VDSStatus.InstallFailed);
            propagateFailure(result);
            return;
        }
    }
    try {
        updateHostStatusAfterSuccessfulUpgrade();
        setSucceeded(true);
    } catch (Exception e) {
        log.error("Failed to set new status for host '{}' after upgrade has ended.", getVdsName());
        log.error("Exception", e);
        setVdsStatus(VDSStatus.InstallFailed);
    }
}
#method_after
@Override
protected void executeCommand() {
    getCompensationContext().snapshotEntityStatus(getVds().getDynamicData(), getParameters().getInitialStatus());
    getCompensationContext().stateChanged();
    VDSType vdsType = getVds().getVdsType();
    if (vdsType == VDSType.VDS || vdsType == VDSType.oVirtNode) {
        try {
            setVdsStatus(VDSStatus.Installing);
            Updateable upgradeManager = new HostUpgradeManager();
            upgradeManager.update(getVds());
            if (vdsType == VDSType.oVirtNode) {
                VdsActionParameters params = new VdsActionParameters(getVds().getId());
                params.setPrevVdsStatus(getVds().getStatus());
                setVdsStatus(VDSStatus.Reboot);
                runInternalAction(VdcActionType.SshHostReboot, params, ExecutionHandler.createInternalJobContext());
            } else {
                // letting the host a chance to recover from restarting the VDSM service after the upgrade
                if (!new HostConnectivityChecker().check(getVds())) {
                    log.warn("Engine failed to communicate with VDSM agent on host '{}' with address '{}' ('{}') " + "after upgrade", getVds().getName(), getVds().getHostName(), getVds().getId());
                }
            }
        } catch (Exception e) {
            setVdsStatus(VDSStatus.InstallFailed);
            return;
        }
    } else if (getVds().isOvirtVintageNode()) {
        InstallVdsParameters parameters = new InstallVdsParameters(getVdsId());
        parameters.setIsReinstallOrUpgrade(true);
        parameters.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        parameters.setActivateHost(getParameters().getInitialStatus() == VDSStatus.Up);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpgradeOvirtNodeInternal, parameters);
        if (!result.getSucceeded()) {
            setVdsStatus(VDSStatus.InstallFailed);
            propagateFailure(result);
            return;
        }
    }
    try {
        updateHostStatusAfterSuccessfulUpgrade();
        setSucceeded(true);
    } catch (Exception e) {
        log.error("Failed to set new status for host '{}' after upgrade has ended.", getVdsName());
        log.error("Exception", e);
        setVdsStatus(VDSStatus.InstallFailed);
    }
}
#end_block

#method_before
void init(M model) {
    windowPropertyNames.addAll(model.getWindowProperties().keySet());
    confirmWindowPropertyNames.addAll(model.getConfirmWindowProperties().keySet());
    for (String propName : windowPropertyNames) {
        windowPopupInstances.put(propName, null);
    }
    for (String propName : confirmWindowPropertyNames) {
        confirmWindowPopupInstances.put(propName, null);
    }
}
#method_after
void init() {
    windowPropertyNames.addAll(Arrays.asList(popupResolver.getWindowPropertyNames()));
    confirmWindowPropertyNames.addAll(Arrays.asList(popupResolver.getConfirmWindowPropertyNames()));
    for (String propName : windowPropertyNames) {
        windowPopupInstances.put(propName, null);
    }
    for (String propName : confirmWindowPropertyNames) {
        confirmWindowPopupInstances.put(propName, null);
    }
}
#end_block

#method_before
public void addDialogModelListener(final M model) {
    init(model);
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if (windowPropertyNames.contains(propName)) {
                handleWindowModelChange(model, propName, windowPopupInstances.get(propName), false);
            } else if (confirmWindowPropertyNames.contains(propName)) {
                handleWindowModelChange(model, propName, confirmWindowPopupInstances.get(propName), true);
            }
        }
    });
}
#method_after
public void addDialogModelListener(final M model) {
    hideAndClearAllPopups();
    model.getPropertyChangedEvent().addListener(new IEventListener<PropertyChangedEventArgs>() {

        @Override
        public void eventRaised(Event<? extends PropertyChangedEventArgs> ev, Object sender, PropertyChangedEventArgs args) {
            String propName = args.propertyName;
            if (windowPropertyNames.contains(propName)) {
                handleWindowModelChange(model, propName, windowPopupInstances.get(propName), false);
            } else if (confirmWindowPropertyNames.contains(propName)) {
                handleWindowModelChange(model, propName, confirmWindowPopupInstances.get(propName), true);
            }
        }
    });
}
#end_block

#method_before
@SuppressWarnings("unchecked")
void handleWindowModelChange(M sourceModel, String propertyName, AbstractModelBoundPopupPresenterWidget<?, ?> currentPopup, boolean isConfirmation) {
    Model windowModel = isConfirmation ? sourceModel.getConfirmWindowProperties().get(propertyName) : sourceModel.getWindowProperties().get(propertyName);
    // Reveal new popup
    if (windowModel != null && currentPopup == null) {
        // 1. Resolve
        AbstractModelBoundPopupPresenterWidget<?, ?> newPopup = null;
        UICommand lastExecutedCommand = sourceModel.getLastExecutedCommand();
        if (windowModel instanceof ConfirmationModel) {
            // Resolve confirmation popup
            newPopup = popupResolver.getConfirmModelPopup(sourceModel, lastExecutedCommand);
            if (newPopup == null && defaultConfirmPopupProvider != null) {
                // Fall back to basic confirmation popup
                newPopup = defaultConfirmPopupProvider.get();
            }
        } else {
            // Resolve main popup
            newPopup = popupResolver.getModelPopup(sourceModel, lastExecutedCommand, windowModel);
        }
        // 2. Reveal
        if (newPopup != null) {
            revealAndAssignPopup(windowModel, propertyName, (AbstractModelBoundPopupPresenterWidget<Model, ?>) newPopup, isConfirmation);
        } else {
            if (isConfirmation) {
                sourceModel.setConfirmWindowProperty(propertyName, null);
            } else {
                sourceModel.setWindowProperty(propertyName, null);
            }
        }
    } else if (windowModel == null && currentPopup != null) {
        hideAndClearPopup(propertyName, currentPopup, isConfirmation);
    }
}
#method_after
@SuppressWarnings("unchecked")
void handleWindowModelChange(M sourceModel, String propertyName, AbstractModelBoundPopupPresenterWidget<?, ?> currentPopup, boolean isConfirmation) {
    Model windowModel = isConfirmation ? popupResolver.getConfirmWindowModel(sourceModel, propertyName) : popupResolver.getWindowModel(sourceModel, propertyName);
    // Reveal new popup
    if (windowModel != null && currentPopup == null) {
        // 1. Resolve
        AbstractModelBoundPopupPresenterWidget<?, ?> newPopup = null;
        UICommand lastExecutedCommand = sourceModel.getLastExecutedCommand();
        if (windowModel instanceof ConfirmationModel) {
            // Resolve confirmation popup
            newPopup = popupResolver.getConfirmModelPopup(sourceModel, lastExecutedCommand);
            if (newPopup == null && defaultConfirmPopupProvider != null) {
                // Fall back to basic confirmation popup
                newPopup = defaultConfirmPopupProvider.get();
            }
        } else {
            // Resolve main popup
            newPopup = popupResolver.getModelPopup(sourceModel, lastExecutedCommand, windowModel);
        }
        // 2. Reveal
        if (newPopup != null) {
            revealAndAssignPopup(windowModel, propertyName, (AbstractModelBoundPopupPresenterWidget<Model, ?>) newPopup, isConfirmation);
        } else {
            if (isConfirmation) {
                popupResolver.clearConfirmWindowModel(sourceModel, propertyName);
            } else {
                popupResolver.clearWindowModel(sourceModel, propertyName);
            }
        }
    } else if (windowModel == null && currentPopup != null) {
        hideAndClearPopup(propertyName, currentPopup, isConfirmation);
    }
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        if (volume != null) {
            jobProperties.put(GlusterConstants.VOLUME, volume.getName());
        }
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        if (getVolume() != null) {
            jobProperties.put(GlusterConstants.VOLUME, getVolume().getName());
        }
    }
    return jobProperties;
}
#end_block

#method_before
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(CreateEntity.class);
    if (volume.getVolumeType().isReplicatedType()) {
        addValidationGroup(CreateReplicatedVolume.class);
    }
    if (volume.getVolumeType().isStripedType()) {
        addValidationGroup(CreateStripedVolume.class);
    }
    return super.getValidationGroups();
}
#method_after
@Override
protected List<Class<?>> getValidationGroups() {
    addValidationGroup(CreateEntity.class);
    if (getVolume().getVolumeType().isReplicatedType()) {
        addValidationGroup(CreateReplicatedVolume.class);
    }
    if (getVolume().getVolumeType().isStripedType()) {
        addValidationGroup(CreateStripedVolume.class);
    }
    return super.getValidationGroups();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    Cluster cluster = getCluster();
    if (cluster == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (volume.getVolumeType().isDispersedType()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CREATION_OF_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    if (volumeNameExists(volume.getName())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
        addValidationMessageVariable("volumeName", volume.getName());
        return false;
    }
    if (volume.getArbiterCount() != 0) {
        if (!GlusterFeatureSupported.glusterArbiterVolumeSupported(getCluster().getCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_NOT_SUPPORTED);
        }
        if (!volume.getVolumeType().isReplicatedType() || volume.getReplicaCount() != 3) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_SHOULD_BE_REPLICA_3_VOLUME);
        }
    }
    return validateBricks(volume);
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    Cluster cluster = getCluster();
    if (cluster == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!cluster.supportsGlusterService()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
        return false;
    }
    if (getVolume().getVolumeType().isDispersedType()) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CREATION_OF_DISPERSE_VOLUME_NOT_SUPPORTED);
        return false;
    }
    if (volumeNameExists(getVolume().getName())) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
        addValidationMessageVariable("volumeName", getVolume().getName());
        return false;
    }
    if (getVolume().getIsArbiter()) {
        if (!GlusterFeatureSupported.glusterArbiterVolumeSupported(getCluster().getCompatibilityVersion())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_NOT_SUPPORTED);
        }
        if (!getVolume().getVolumeType().isReplicatedType() || getVolume().getReplicaCount() != 3) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_SHOULD_BE_REPLICA_3_VOLUME);
        }
    }
    return validateBricks(getVolume());
}
#end_block

#method_before
private boolean volumeNameExists(String volumeName) {
    GlusterVolumeEntity volumeEntity = getGlusterVolumeDao().getByName(getClusterId(), volumeName);
    return (volumeEntity == null) ? false : true;
}
#method_after
private boolean volumeNameExists(String volumeName) {
    return glusterVolumeDao.getByName(getClusterId(), volumeName) != null;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(volume.getName());
    if (volume.getTransportTypes() == null || volume.getTransportTypes().isEmpty()) {
        volume.addTransportType(TransportType.TCP);
    }
    // GLUSTER access protocol is enabled by default
    volume.addAccessProtocol(AccessProtocol.GLUSTER);
    if (!volume.getAccessProtocols().contains(AccessProtocol.NFS)) {
        volume.disableNFS();
    }
    if (volume.getAccessProtocols().contains(AccessProtocol.CIFS)) {
        volume.enableCifs();
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(upServer.getId(), volume, upServer.getClusterCompatibilityVersion(), getParameters().isForce()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    setVolumeType(createdVolume);
    setBrickOrder(createdVolume.getBricks());
    addVolumeToDb(createdVolume);
    // If we log successful volume creation at the end of this command,
    // the messages from SetGlusterVolumeOptionCommand appear first,
    // making it look like options were set before volume was created.
    // Hence we explicitly log the volume creation before setting the options.
    auditLogDirector.log(this, AuditLogType.GLUSTER_VOLUME_CREATE);
    // And don't log it at the end
    setCommandShouldBeLogged(false);
    // set all options of the volume
    setVolumeOptions(createdVolume);
    getReturnValue().setActionReturnValue(createdVolume.getId());
}
#method_after
@Override
protected void executeCommand() {
    // set the gluster volume name for audit purpose
    setGlusterVolumeName(getVolume().getName());
    if (getVolume().getTransportTypes() == null || getVolume().getTransportTypes().isEmpty()) {
        getVolume().addTransportType(TransportType.TCP);
    }
    // GLUSTER access protocol is enabled by default
    getVolume().addAccessProtocol(AccessProtocol.GLUSTER);
    if (!getVolume().getAccessProtocols().contains(AccessProtocol.NFS)) {
        getVolume().disableNFS();
    }
    if (getVolume().getAccessProtocols().contains(AccessProtocol.CIFS)) {
        getVolume().enableCifs();
    }
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CreateGlusterVolume, new CreateGlusterVolumeVDSParameters(upServer.getId(), getVolume(), upServer.getClusterCompatibilityVersion(), getParameters().isForce()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_CREATE_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    // Volume created successfully. Insert it to database.
    GlusterVolumeEntity createdVolume = (GlusterVolumeEntity) returnValue.getReturnValue();
    setVolumeType(createdVolume);
    setBrickOrder(createdVolume.getBricks());
    addVolumeToDb(createdVolume);
    // If we log successful volume creation at the end of this command,
    // the messages from SetGlusterVolumeOptionCommand appear first,
    // making it look like options were set before volume was created.
    // Hence we explicitly log the volume creation before setting the options.
    auditLogDirector.log(this, AuditLogType.GLUSTER_VOLUME_CREATE);
    // And don't log it at the end
    setCommandShouldBeLogged(false);
    // set all options of the volume
    setVolumeOptions(createdVolume);
    getReturnValue().setActionReturnValue(createdVolume.getId());
}
#end_block

#method_before
private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
    // volume fetched from VDSM doesn't contain cluster id as
    // GlusterFS is not aware of multiple clusters
    createdVolume.setClusterId(getClusterId());
    getGlusterVolumeDao().save(createdVolume);
}
#method_after
private void addVolumeToDb(final GlusterVolumeEntity createdVolume) {
    // volume fetched from VDSM doesn't contain cluster id as
    // GlusterFS is not aware of multiple clusters
    createdVolume.setClusterId(getClusterId());
    glusterVolumeDao.save(createdVolume);
}
#end_block

#method_before
private Cluster getCluster(boolean glusterEnabled, Version clusterVersion) {
    Cluster cluster = new Cluster();
    cluster.setId(clusterId);
    cluster.setVirtService(false);
    cluster.setGlusterService(glusterEnabled);
    cluster.setCompatibilityVersion(clusterVersion);
    return cluster;
}
#method_after
private Cluster getCluster(boolean glusterEnabled, Version clusterVersion) {
    Cluster cluster = new Cluster();
    cluster.setId(clusterId);
    cluster.setCompatibilityVersion(clusterVersion);
    cluster.setVirtService(false);
    cluster.setGlusterService(glusterEnabled);
    return cluster;
}
#end_block

#method_before
private void prepareMocks(CreateGlusterVolumeCommand command, Version clusterVersion) {
    doReturn(clusterDao).when(command).getClusterDao();
    doReturn(volumeDao).when(command).getGlusterVolumeDao();
    doReturn(vdsStaticDao).when(command).getVdsStaticDao();
    doReturn(brickDao).when(command).getGlusterBrickDao();
    doReturn(networkDao).when(command).getNetworkDao();
    doReturn(interfaceDao).when(command).getInterfaceDao();
    doReturn(getVds(VDSStatus.Up)).when(command).getUpServer();
    doReturn(getVdsStatic()).when(vdsStaticDao).get(serverId);
    doReturn(getCluster(true, clusterVersion)).when(clusterDao).get(any(Guid.class));
}
#method_after
@Before
public void prepareMocks() {
    doReturn(getVds(VDSStatus.Up)).when(cmd).getUpServer();
    doReturn(getVdsStatic()).when(vdsStaticDao).get(serverId);
    doReturn(getCluster(true, Version.v4_1)).when(clusterDao).get(any(Guid.class));
}
#end_block

#method_before
private GlusterVolumeEntity getVolume(int brickCount, boolean withDuplicateBricks) {
    return getVolume(brickCount, withDuplicateBricks, GlusterVolumeType.DISTRIBUTE);
}
#method_after
private GlusterVolumeEntity getVolume(int brickCount, boolean withDuplicateBricks) {
    return getVolume(brickCount, withDuplicateBricks, GlusterVolumeType.DISTRIBUTE, 0, false);
}
#end_block

#method_before
private GlusterVolumeEntity getVolume(int brickCount, boolean withDuplicateBricks, GlusterVolumeType volumeType) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(Guid.newGuid());
    volumeEntity.setClusterId(clusterId);
    volumeEntity.setName("vol1");
    volumeEntity.setVolumeType(volumeType);
    volumeEntity.setBricks(getBricks(volumeEntity.getId(), brickCount, withDuplicateBricks));
    return volumeEntity;
}
#method_after
private GlusterVolumeEntity getVolume(int brickCount, boolean withDuplicateBricks, GlusterVolumeType volumeType, int replicaCount, boolean isArbiter) {
    GlusterVolumeEntity volumeEntity = new GlusterVolumeEntity();
    volumeEntity.setId(Guid.newGuid());
    volumeEntity.setClusterId(clusterId);
    volumeEntity.setName("vol1");
    volumeEntity.setVolumeType(volumeType);
    volumeEntity.setBricks(getBricks(volumeEntity.getId(), brickCount, withDuplicateBricks));
    volumeEntity.setReplicaCount(replicaCount);
    volumeEntity.setIsArbiter(isArbiter);
    return volumeEntity;
}
#end_block

#method_before
@Test
public void validateSucceeds() {
    cmd = spy(createTestCommand(getVolume(2, false)));
    prepareMocks(cmd);
    assertTrue(cmd.validate());
}
#method_after
@Test
public void validateSucceeds() {
    assertTrue(cmd.validate());
}
#end_block

#method_before
@Test
public void validateSucceedsWithArbiter() {
    GlusterVolumeEntity volume = getVolume(3, false, GlusterVolumeType.REPLICATE);
    volume.setReplicaCount(3);
    volume.setArbiterCount(1);
    cmd = spy(createTestCommand(volume));
    prepareMocks(cmd, Version.v4_1);
    assertTrue(cmd.validate());
}
#method_after
@Test
public void validateSucceedsWithArbiter() {
    setVolume(getVolume(3, false, GlusterVolumeType.REPLICATE, 3, true));
    assertTrue(cmd.validate());
}
#end_block

#method_before
@Test
public void validateFailsWithArbiterAndInvalidReplica() {
    GlusterVolumeEntity volume = getVolume(2, false, GlusterVolumeType.REPLICATE);
    volume.setReplicaCount(2);
    volume.setArbiterCount(1);
    cmd = spy(createTestCommand(volume));
    prepareMocks(cmd, Version.v4_1);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_SHOULD_BE_REPLICA_3_VOLUME);
}
#method_after
@Test
public void validateFailsWithArbiterAndInvalidReplica() {
    setVolume(getVolume(2, false, GlusterVolumeType.REPLICATE, 2, true));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_SHOULD_BE_REPLICA_3_VOLUME);
}
#end_block

#method_before
@Test
public void validateFailsWithArbiterWithClusterDoesNotArbiterVolume() {
    GlusterVolumeEntity volume = getVolume(3, false, GlusterVolumeType.REPLICATE);
    volume.setReplicaCount(3);
    volume.setArbiterCount(1);
    cmd = spy(createTestCommand(volume));
    prepareMocks(cmd);
}
#method_after
@Test
public void validateFailsWithArbiterWithClusterDoesNotArbiterVolume() {
    setVolume(getVolume(3, false, GlusterVolumeType.REPLICATE, 3, true));
    doReturn(getCluster(true, Version.v4_0)).when(clusterDao).get(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_GLUSTER_ARBITER_VOLUME_NOT_SUPPORTED);
}
#end_block

#method_before
@Test
public void validateFailsWithClusterDoesNotSupportGluster() {
    cmd = spy(createTestCommand(getVolume(2, false)));
    prepareMocks(cmd);
    doReturn(getCluster(false, Version.v4_0)).when(clusterDao).get(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
}
#method_after
@Test
public void validateFailsWithClusterDoesNotSupportGluster() {
    doReturn(getCluster(false, Version.v4_1)).when(clusterDao).get(any(Guid.class));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_CLUSTER_DOES_NOT_SUPPORT_GLUSTER);
}
#end_block

#method_before
@Test
public void validateFailsWithDuplicateVolumeName() {
    cmd = spy(createTestCommand(getVolume(2, false)));
    prepareMocks(cmd);
    doReturn(getVolume(2, false)).when(volumeDao).getByName(clusterId, "vol1");
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
}
#method_after
@Test
public void validateFailsWithDuplicateVolumeName() {
    doReturn(getVolume(2, false)).when(volumeDao).getByName(clusterId, "vol1");
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_GLUSTER_VOLUME_NAME_ALREADY_EXISTS);
}
#end_block

#method_before
@Test
public void validateFailsWithEmptyBricks() {
    cmd = spy(createTestCommand(getVolume(0, false)));
    prepareMocks(cmd);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
}
#method_after
@Test
public void validateFailsWithEmptyBricks() {
    setVolume(getVolume(0, false));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
}
#end_block

#method_before
@Test
public void validateFailsWithDuplicateBricks() {
    cmd = spy(createTestCommand(getVolume(2, true)));
    prepareMocks(cmd);
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DUPLICATE_BRICKS);
}
#method_after
@Test
public void validateFailsWithDuplicateBricks() {
    setVolume(getVolume(2, true));
    ValidateTestUtils.runAndAssertValidateFailure(cmd, EngineMessage.ACTION_TYPE_FAILED_DUPLICATE_BRICKS);
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    GlusterVolumeEntity volume = getParameters().getVolume();
    boolean isForce = getParameters().isForce();
    uuidReturn = getBroker().glusterVolumeCreate(volume.getName(), volume.getBrickDirectories().toArray(new String[0]), volume.getReplicaCount(), volume.getStripeCount(), getTransportTypeArr(volume), isForce, volume.getArbiterCount());
    // Handle errors if any
    proceedProxyReturnValue();
    if (getVDSReturnValue().getSucceeded()) {
        // set the volume updated with id as the return value
        volume.setId(Guid.createGuidFromStringDefaultEmpty(uuidReturn.uuid));
        setReturnValue(volume);
    }
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    GlusterVolumeEntity volume = getParameters().getVolume();
    boolean isForce = getParameters().isForce();
    uuidReturn = getBroker().glusterVolumeCreate(volume.getName(), volume.getBrickDirectories().toArray(new String[0]), volume.getReplicaCount(), volume.getStripeCount(), getTransportTypeArr(volume), isForce, volume.getIsArbiter());
    // Handle errors if any
    proceedProxyReturnValue();
    if (getVDSReturnValue().getSucceeded()) {
        // set the volume updated with id as the return value
        volume.setId(Guid.createGuidFromStringDefaultEmpty(uuidReturn.uuid));
        setReturnValue(volume);
    }
}
#end_block

#method_before
@SuppressWarnings({ "unchecked", "incomplete-switch" })
private GlusterVolumeEntity getVolume(Map<String, Object> map) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setId(Guid.createGuidFromStringDefaultEmpty((String) map.get(UUID)));
    volume.setName((String) map.get(VOLUME_NAME));
    volume.setVolumeType((String) map.get(VOLUME_TYPE));
    if (volume.getVolumeType() != null) {
        if (volume.getVolumeType().isReplicatedType()) {
            volume.setReplicaCount(Integer.valueOf((String) map.get(REPLICA_COUNT)));
        }
        if (volume.getVolumeType().isStripedType()) {
            volume.setStripeCount(Integer.valueOf((String) map.get(STRIPE_COUNT)));
        }
        if (volume.getVolumeType().isDispersedType()) {
            volume.setDisperseCount(Integer.valueOf((String) map.get(DISPERSE_COUNT)));
            volume.setRedundancyCount(Integer.valueOf((String) map.get(REDUNDANCY_COUNT)));
        }
    }
    for (Object transportType : (Object[]) map.get(TRANSPORT_TYPE)) {
        volume.addTransportType(TransportType.valueOf((String) transportType));
    }
    String volStatus = (String) map.get(VOLUME_STATUS);
    if (volStatus.toUpperCase().equals(VOLUME_STATUS_ONLINE)) {
        volume.setStatus(GlusterStatus.UP);
    } else {
        volume.setStatus(GlusterStatus.DOWN);
    }
    try {
        if (map.get(BRICKS_INFO) != null && ((Object[]) map.get(BRICKS_INFO)).length > 0) {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS_INFO), true));
        } else {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS), false));
        }
    } catch (Exception e) {
        log.error("Could not populate bricks of volume '{}' on cluster '{}': {}", volume.getName(), clusterId, e.getMessage());
        log.debug("Exception", e);
    }
    volume.setOptions(getOptions((Map<String, Object>) map.get(OPTIONS)));
    return volume;
}
#method_after
@SuppressWarnings({ "unchecked", "incomplete-switch" })
private GlusterVolumeEntity getVolume(Map<String, Object> map) {
    GlusterVolumeEntity volume = new GlusterVolumeEntity();
    volume.setClusterId(clusterId);
    volume.setId(Guid.createGuidFromStringDefaultEmpty((String) map.get(UUID)));
    volume.setName((String) map.get(VOLUME_NAME));
    volume.setVolumeType((String) map.get(VOLUME_TYPE));
    if (volume.getVolumeType() != null) {
        if (volume.getVolumeType().isReplicatedType()) {
            volume.setReplicaCount(Integer.valueOf((String) map.get(REPLICA_COUNT)));
            boolean isArbiter = map.containsKey(IS_ARBITER) ? Boolean.valueOf(map.get(IS_ARBITER).toString()) : Boolean.FALSE;
            volume.setIsArbiter(isArbiter);
        }
        if (volume.getVolumeType().isStripedType()) {
            volume.setStripeCount(Integer.valueOf((String) map.get(STRIPE_COUNT)));
        }
        if (volume.getVolumeType().isDispersedType()) {
            volume.setDisperseCount(Integer.valueOf((String) map.get(DISPERSE_COUNT)));
            volume.setRedundancyCount(Integer.valueOf((String) map.get(REDUNDANCY_COUNT)));
        }
    }
    for (Object transportType : (Object[]) map.get(TRANSPORT_TYPE)) {
        volume.addTransportType(TransportType.valueOf((String) transportType));
    }
    String volStatus = (String) map.get(VOLUME_STATUS);
    if (volStatus.toUpperCase().equals(VOLUME_STATUS_ONLINE)) {
        volume.setStatus(GlusterStatus.UP);
    } else {
        volume.setStatus(GlusterStatus.DOWN);
    }
    try {
        if (map.get(BRICKS_INFO) != null && ((Object[]) map.get(BRICKS_INFO)).length > 0) {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS_INFO), true));
        } else {
            volume.setBricks(getBricks(volume.getId(), (Object[]) map.get(BRICKS), false));
        }
    } catch (Exception e) {
        log.error("Could not populate bricks of volume '{}' on cluster '{}': {}", volume.getName(), clusterId, e.getMessage());
        log.debug("Exception", e);
    }
    volume.setOptions(getOptions((Map<String, Object>) map.get(OPTIONS)));
    return volume;
}
#end_block

#method_before
private Boolean isSameNetworkAddress(Guid hostId, String glusterNetworkName, String networkAddress) {
    final List<VdsNetworkInterface> nics = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (glusterNetworkName.equals(nic.getNetworkName())) {
            return networkAddress.equals(nic.getIpv4Address());
        }
    }
    return false;
}
#method_after
private Boolean isSameNetworkAddress(Guid hostId, String glusterNetworkName, String networkAddress) {
    final List<VdsNetworkInterface> nics = DbFacade.getInstance().getInterfaceDao().getAllInterfacesForVds(hostId);
    String brickAddress = null;
    try {
        brickAddress = InetAddress.getByName(networkAddress).getHostAddress();
    } catch (UnknownHostException e) {
        return false;
    }
    for (VdsNetworkInterface nic : nics) {
        if (glusterNetworkName.equals(nic.getNetworkName())) {
            return brickAddress.equals(nic.getIpv4Address());
        }
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            int connectionId = client.getConnectionId();
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed() && client.getConnectionId() == connectionId) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, int arbiterCount) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withOptionalParameter("arbiterCount", arbiterCount).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    JsonRpcRequest request = new RequestBuilder("GlusterVolume.create").withParameter("volumeName", volumeName).withParameter("bricklist", new ArrayList<>(Arrays.asList(brickList))).withParameter("replicaCount", replicaCount).withParameter("stripeCount", stripeCount).withParameter("transportList", new ArrayList<>(Arrays.asList(transportList))).withParameter("force", force).withParameter("arbiter", isArbiter).build();
    Map<String, Object> response = new FutureMap(this.client, request).withIgnoreResponseKey();
    return new OneUuidReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, int arbiterCount) {
    try {
        if (arbiterCount == 0) {
            return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList, force));
        } else {
            return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList, force, arbiterCount));
        }
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public OneUuidReturnForXmlRpc glusterVolumeCreate(String volumeName, String[] brickList, int replicaCount, int stripeCount, String[] transportList, boolean force, boolean isArbiter) {
    try {
        if (isArbiter) {
            return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList, force, isArbiter));
        } else {
            return new OneUuidReturnForXmlRpc(vdsServer.glusterVolumeCreate(volumeName, brickList, replicaCount, stripeCount, transportList, force));
        }
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    int scsiControllerId = 0;
    int scsiUnitId = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(getVirtioScsiControllerId(virtioScsiIndex), unit).toString());
                    }
                    if (FeatureSupported.virtioScsiIoThread(vm.getCompatibilityVersion()) && vm.getNumOfIoThreads() > 0) {
                        vmDevice.getSpecParams().put(VdsProperties.Controller, scsiControllerId);
                        vmDevice.getSpecParams().put(VdsProperties.Unit, scsiUnitId);
                        scsiControllerId++;
                        if (scsiControllerId >= vm.getNumOfIoThreads() + 1) {
                            scsiControllerId = 0;
                            scsiUnitId++;
                        }
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#method_after
@Override
public void buildVmDrives() {
    boolean bootDiskFound = false;
    List<Disk> disks = getSortedDisks();
    Map<VmDevice, Integer> vmDeviceVirtioScsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForVirtioScsiDisks(vm);
    Map<VmDevice, Integer> vmDeviceSpaprVscsiUnitMap = vmInfoBuildUtils.getVmDeviceUnitMapForSpaprScsiDisks(vm);
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    int sPaprVscsiIndex = controllerIndexMap.get(DiskInterface.SPAPR_VSCSI);
    Map<Guid, StorageQos> qosCache = new HashMap<>();
    int pinnedDriveIndex = 0;
    for (Disk disk : disks) {
        Map<String, Object> struct = new HashMap<>();
        // get vm device for this disk from DB
        VmDevice vmDevice = vmInfoBuildUtils.getVmDeviceByDiskId(disk.getId(), vm.getId());
        DiskVmElement dve = disk.getDiskVmElementForVm(vm.getId());
        // skip unmanaged devices (handled separately)
        if (!vmDevice.getIsManaged()) {
            continue;
        }
        if (vmDevice.getIsPlugged()) {
            struct.put(VdsProperties.Type, vmDevice.getType().getValue());
            struct.put(VdsProperties.Device, vmDevice.getDevice());
            switch(dve.getDiskInterface()) {
                case IDE:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Ide);
                    break;
                case VirtIO:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Virtio);
                    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                    }
                    pinnedDriveIndex = pinToIoThreads(vmDevice, pinnedDriveIndex);
                    break;
                case VirtIO_SCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    // set device type as 'lun' (instead of 'disk') and set the specified SGIO.
                    if (disk.getDiskStorageType() == DiskStorageType.LUN && disk.isScsiPassthrough()) {
                        struct.put(VdsProperties.Device, VmDeviceType.LUN.getName());
                        struct.put(VdsProperties.Sgio, disk.getSgio().toString().toLowerCase());
                    }
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceVirtioScsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(virtioScsiIndex, unit).toString());
                    }
                    break;
                case SPAPR_VSCSI:
                    struct.put(VdsProperties.INTERFACE, VdsProperties.Scsi);
                    if (StringUtils.isEmpty(vmDevice.getAddress())) {
                        // Explicitly define device's address if missing
                        int unit = vmDeviceSpaprVscsiUnitMap.get(vmDevice);
                        vmDevice.setAddress(vmInfoBuildUtils.createAddressForScsiDisk(sPaprVscsiIndex, unit).toString());
                    }
                    break;
                default:
                    logUnsupportedInterfaceType();
                    break;
            }
            // Insure that boot disk is created first
            if (!bootDiskFound && dve.isBoot()) {
                bootDiskFound = true;
                struct.put(VdsProperties.Index, getBootableDiskIndex(disk));
            }
            if (FeatureSupported.passDiscardSupported(vm.getCompatibilityVersion())) {
                struct.put(VdsProperties.DISCARD, dve.isPassDiscard());
            }
            vmInfoBuildUtils.addAddress(vmDevice, struct);
            switch(disk.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) disk;
                    struct.put(VdsProperties.PoolId, diskImage.getStoragePoolId().toString());
                    struct.put(VdsProperties.DomainId, diskImage.getStorageIds().get(0).toString());
                    struct.put(VdsProperties.ImageId, diskImage.getId().toString());
                    struct.put(VdsProperties.VolumeId, diskImage.getImageId().toString());
                    struct.put(VdsProperties.Format, diskImage.getVolumeFormat().toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, disk.getPropagateErrors().toString().toLowerCase());
                    if (!qosCache.containsKey(diskImage.getDiskProfileId())) {
                        qosCache.put(diskImage.getDiskProfileId(), vmInfoBuildUtils.loadStorageQos(diskImage));
                    }
                    vmInfoBuildUtils.handleIoTune(vmDevice, qosCache.get(diskImage.getDiskProfileId()));
                    break;
                case LUN:
                    LunDisk lunDisk = (LunDisk) disk;
                    struct.put(VdsProperties.Guid, lunDisk.getLun().getLUNId());
                    struct.put(VdsProperties.Format, VolumeFormat.RAW.toString().toLowerCase());
                    struct.put(VdsProperties.PropagateErrors, PropagateErrors.Off.toString().toLowerCase());
                    break;
                case CINDER:
                    vmInfoBuildUtils.buildCinderDisk((CinderDisk) disk, struct);
                    break;
            }
            vmInfoBuildUtils.addBootOrder(vmDevice, struct);
            struct.put(VdsProperties.Shareable, (vmDevice.getSnapshotId() != null) ? VdsProperties.Transient : String.valueOf(disk.isShareable()));
            struct.put(VdsProperties.Optional, Boolean.FALSE.toString());
            struct.put(VdsProperties.ReadOnly, String.valueOf(vmDevice.getIsReadOnly()));
            struct.put(VdsProperties.SpecParams, vmDevice.getSpecParams());
            struct.put(VdsProperties.DeviceId, String.valueOf(vmDevice.getId().getDeviceId()));
            devices.add(struct);
            addToManagedDevices(vmDevice);
        }
    }
    ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new CreateAdditionalControllers(devices));
}
#end_block

#method_before
@Override
public void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        if (vm.getNumOfIoThreads() > 0) {
            struct.put(VdsProperties.ioTrheadId, Integer.toString(virtioScsiIndex));
            virtioScsiIndex++;
        }
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#method_after
@Override
public void buildVmVirtioScsi() {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(vm.getId(), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName());
    Map<DiskInterface, Integer> controllerIndexMap = ArchStrategyFactory.getStrategy(vm.getClusterArch()).run(new GetControllerIndices()).returnValue();
    int virtioScsiIndex = controllerIndexMap.get(DiskInterface.VirtIO_SCSI);
    for (VmDevice vmDevice : vmDevices) {
        Map<String, Object> struct = new HashMap<>();
        struct.put(VdsProperties.Type, VmDeviceGeneralType.CONTROLLER.getValue());
        struct.put(VdsProperties.Device, VdsProperties.Scsi);
        struct.put(VdsProperties.Model, VdsProperties.VirtioScsi);
        struct.put(VdsProperties.Index, Integer.toString(virtioScsiIndex));
        vmInfoBuildUtils.addAddress(vmDevice, struct);
        virtioScsiIndex++;
        addDevice(struct, vmDevice, null);
    }
}
#end_block

#method_before
@Override
public void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        createInfo.put(VdsProperties.maxMemSize, VmCommonUtils.maxMemorySizeWithHotplugInMb(vm));
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    addCpuPinning();
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, vm.getKvmEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#method_after
@Override
public void buildVmProperties() {
    createInfo.put(VdsProperties.vm_guid, vm.getId().toString());
    createInfo.put(VdsProperties.vm_name, vm.getName());
    createInfo.put(VdsProperties.mem_size_mb, vm.getVmMemSizeMb());
    if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
        createInfo.put(VdsProperties.maxMemSize, VmCommonUtils.maxMemorySizeWithHotplugInMb(vm));
        createInfo.put(VdsProperties.maxMemSlots, Config.getValue(ConfigValues.MaxMemorySlots));
    }
    createInfo.put(VdsProperties.mem_guaranteed_size_mb, vm.getMinAllocatedMem());
    createInfo.put(VdsProperties.smartcardEnabled, Boolean.toString(vm.isSmartcardEnabled()));
    createInfo.put(VdsProperties.num_of_cpus, String.valueOf(vm.getNumOfCpus()));
    if (vm.getNumOfIoThreads() != 0) {
        createInfo.put(VdsProperties.numOfIoThreads, vm.getNumOfIoThreads());
    }
    if (Config.getValue(ConfigValues.SendSMPOnRunVm)) {
        createInfo.put(VdsProperties.cores_per_socket, Integer.toString(vm.getCpuPerSocket()));
        createInfo.put(VdsProperties.threads_per_core, Integer.toString(vm.getThreadsPerCpu()));
        if (FeatureSupported.supportedInConfig(ConfigValues.HotPlugCpuSupported, vm.getCompatibilityVersion(), vm.getClusterArch())) {
            createInfo.put(VdsProperties.max_number_of_cpus, calcMaxVCpu().toString());
        }
    }
    addCpuPinning();
    if (vm.getEmulatedMachine() != null) {
        createInfo.put(VdsProperties.emulatedMachine, vm.getEmulatedMachine());
    }
    createInfo.put(VdsProperties.kvmEnable, "true");
    createInfo.put(VdsProperties.acpiEnable, vm.getAcpiEnable().toString().toLowerCase());
    createInfo.put(VdsProperties.BOOT_MENU_ENABLE, Boolean.toString(vm.isBootMenuEnabled()));
    createInfo.put(VdsProperties.Custom, VmPropertiesUtils.getInstance().getVMProperties(vm.getCompatibilityVersion(), vm.getStaticData()));
    // "qemu", "kvm"
    createInfo.put(VdsProperties.vm_type, "kvm");
    if (vm.isRunAndPause()) {
        createInfo.put(VdsProperties.launch_paused_param, "true");
    }
    if (vm.isUseHostCpuFlags()) {
        createInfo.put(VdsProperties.cpuType, "hostPassthrough");
    } else if (vm.getCpuName() != null) {
        // uses dynamic vm data which was already updated by runVmCommand
        createInfo.put(VdsProperties.cpuType, vm.getCpuName());
    }
    createInfo.put(VdsProperties.niceLevel, String.valueOf(vm.getNiceLevel()));
    if (vm.getCpuShares() > 0) {
        createInfo.put(VdsProperties.cpuShares, String.valueOf(vm.getCpuShares()));
    }
    if (!StringUtils.isEmpty(vm.getHibernationVolHandle())) {
        createInfo.put(VdsProperties.hiberVolHandle, vm.getHibernationVolHandle());
    }
    if (osRepository.isLinux(vm.getVmOsId())) {
        createInfo.put(VdsProperties.PitReinjection, "false");
    }
    if (vm.getGraphicsInfos().size() == 1 && vm.getGraphicsInfos().containsKey(GraphicsType.VNC)) {
        createInfo.put(VdsProperties.TabletEnable, "true");
    }
    createInfo.put(VdsProperties.transparent_huge_pages, vm.isTransparentHugePages() ? "true" : "false");
    if (osRepository.isHypervEnabled(vm.getVmOsId(), vm.getCompatibilityVersion())) {
        createInfo.put(VdsProperties.hypervEnable, "true");
    }
}
#end_block

#method_before
private void addNumaSetting() {
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#method_after
private void addNumaSetting() {
    List<VmNumaNode> vmNumaNodes = vmNumaNodeDao.getAllVmNumaNodeByVmId(vm.getId());
    List<VdsNumaNode> totalVdsNumaNodes = vdsNumaNodeDao.getAllVdsNumaNodeByVdsId(vdsId);
    if (totalVdsNumaNodes.isEmpty()) {
        log.warn("No NUMA nodes found for host {} for vm {} {}", vdsId, vm.getName(), vm.getId());
        return;
    }
    // create a default one with one guest numa node
    if (vmNumaNodes.isEmpty()) {
        if (FeatureSupported.hotPlugMemory(vm.getCompatibilityVersion(), vm.getClusterArch())) {
            VmNumaNode vmNode = new VmNumaNode();
            vmNode.setIndex(0);
            vmNode.setMemTotal(vm.getMemSizeMb());
            for (int i = 0; i < vm.getNumOfCpus(); i++) {
                vmNode.getCpuIds().add(i);
            }
            vmNumaNodes.add(vmNode);
        } else {
            // no need to send numa if memory hotplug not supported
            return;
        }
    }
    NumaTuneMode numaTune = vm.getNumaTuneMode();
    if (numaTune != null) {
        Map<String, Object> numaTuneSetting = NumaSettingFactory.buildVmNumatuneSetting(numaTune, vmNumaNodes, totalVdsNumaNodes);
        if (!numaTuneSetting.isEmpty()) {
            createInfo.put(VdsProperties.NUMA_TUNE, numaTuneSetting);
        }
    }
    List<Map<String, Object>> createVmNumaNodes = NumaSettingFactory.buildVmNumaNodeSetting(vmNumaNodes);
    if (!createVmNumaNodes.isEmpty()) {
        createInfo.put(VdsProperties.VM_NUMA_NODES, createVmNumaNodes);
    }
    if (StringUtils.isEmpty(vm.getCpuPinning())) {
        Map<String, Object> cpuPinDict = NumaSettingFactory.buildCpuPinningWithNumaSetting(vmNumaNodes, totalVdsNumaNodes);
        if (!cpuPinDict.isEmpty()) {
            createInfo.put(VdsProperties.cpuPinning, cpuPinDict);
        }
    }
}
#end_block

#method_before
private void addVmGraphicsOptions(Map<GraphicsType, GraphicsInfo> infos, Map<String, Object> params) {
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        params.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        params.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
        if (Config.getValue(ConfigValues.SSLEnabled)) {
            params.put(VdsProperties.spiceSslCipherSuite, Config.getValue(ConfigValues.CipherSuite));
            params.put(VdsProperties.SpiceSecureChannels, Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString()));
        }
    }
    if (infos != null && infos.containsKey(GraphicsType.VNC)) {
        String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = vm.getDefaultVncKeyboardLayout();
            if (keyboardLayout == null) {
                keyboardLayout = Config.getValue(ConfigValues.VncKeyboardLayout);
            }
        }
        params.put(VdsProperties.KeyboardMap, keyboardLayout);
    }
}
#method_after
private void addVmGraphicsOptions(Map<GraphicsType, GraphicsInfo> infos, Map<String, Object> params) {
    if (infos != null && infos.containsKey(GraphicsType.SPICE)) {
        params.put(VdsProperties.spiceFileTransferEnable, Boolean.toString(vm.isSpiceFileTransferEnabled()));
        params.put(VdsProperties.spiceCopyPasteEnable, Boolean.toString(vm.isSpiceCopyPasteEnabled()));
        if (Config.getValue(ConfigValues.SSLEnabled)) {
            params.put(VdsProperties.SpiceSecureChannels, Config.getValue(ConfigValues.SpiceSecureChannels, vm.getCompatibilityVersion().toString()));
        }
    }
    if (infos != null && infos.containsKey(GraphicsType.VNC)) {
        String keyboardLayout = vm.getDynamicData().getVncKeyboardLayout();
        if (keyboardLayout == null) {
            keyboardLayout = vm.getDefaultVncKeyboardLayout();
            if (keyboardLayout == null) {
                keyboardLayout = Config.getValue(ConfigValues.VncKeyboardLayout);
            }
        }
        params.put(VdsProperties.KeyboardMap, keyboardLayout);
    }
}
#end_block

#method_before
/*
     * VirtIO-SCSI controller
     */
public void updateVirtioScsiController(Guid vmId, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    if (isVirtioScsiEnabled) {
        if (!hasVirtioScsiController(vmId)) {
            addVirtioScsiController(vmId);
        }
    } else {
        removeVirtioScsiControllers(vmId);
    }
}
#method_after
/*
     * VirtIO-SCSI controller
     */
public void updateVirtioScsiController(VmBase vm, Boolean isVirtioScsiEnabled) {
    if (isVirtioScsiEnabled == null) {
        // we don't want to update the device
        return;
    }
    removeVirtioScsiControllers(vm.getId());
    if (isVirtioScsiEnabled) {
        addVirtioScsiController(vm, getVmCompatibilityVersion(vm));
    }
}
#end_block

#method_before
public VmDevice addVirtioScsiController(Guid vmId) {
    return addManagedDevice(new VmDeviceId(Guid.newGuid(), vmId), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, Collections.emptyMap(), true, false);
}
#method_after
public void addVirtioScsiController(VmBase vm, Version version) {
    boolean hasIoThreads = vm.getNumOfIoThreads() > 0 && FeatureSupported.virtioScsiIoThread(version);
    int numOfScsiControllers = hasIoThreads ? vm.getNumOfIoThreads() : 1;
    for (int i = 0; i < numOfScsiControllers; i++) {
        Map<String, Object> specParams = new HashMap<>();
        if (hasIoThreads) {
            specParams.put(VdsProperties.ioThreadId, i);
        }
        VmDevice device = addManagedDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI, specParams, true, false);
    }
}
#end_block

#method_before
public VmDevice addInterface(Guid vmId, Guid deviceId, boolean plugged, boolean hostDev, String address) {
    return addManagedDevice(new VmDeviceId(deviceId, vmId), VmDeviceGeneralType.INTERFACE, hostDev ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, Collections.emptyMap(), plugged, false, address, null, false);
}
#method_after
public VmDevice addInterface(Guid vmId, Guid deviceId, boolean plugged, boolean hostDev, String address) {
    return addManagedDevice(new VmDeviceId(deviceId, vmId), VmDeviceGeneralType.INTERFACE, hostDev ? VmDeviceType.HOST_DEVICE : VmDeviceType.BRIDGE, Collections.emptyMap(), plugged, false, address, null);
}
#end_block

#method_before
/*
     * USB slot
     */
private void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int currentNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        currentNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    }
    final int usbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    // We add USB slots if they are disabled in oldVm configuration, but enabled in newVm
    if (!oldUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE) && newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (usbSlots > 0) {
            removeUsbControllers(newVm.getId());
            addUsbControllers(newVm.getId(), getNeededNumberOfUsbControllers(usbSlots));
            addUsbSlots(newVm.getId(), usbSlots);
        }
    // Remove USB slots and controllers if the policy is to disable or legacy one
    } else if (newUsbPolicy.equals(UsbPolicy.DISABLED) || newUsbPolicy.equals(UsbPolicy.ENABLED_LEGACY)) {
        removeUsbControllers(newVm.getId());
        removeUsbSlots(newVm.getId());
    // If the USB policy is to enable (and was enabled before), we need to update the number of slots
    } else if (newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (currentNumberOfSlots < usbSlots) {
            // Add slots and controllers
            if (currentNumberOfSlots == 0) {
                addUsbControllers(newVm.getId(), getNeededNumberOfUsbControllers(usbSlots));
            }
            addUsbSlots(newVm.getId(), usbSlots - currentNumberOfSlots);
        } else if (currentNumberOfSlots > usbSlots) {
            // Remove slots and controllers
            removeUsbSlots(newVm.getId(), currentNumberOfSlots - usbSlots);
            if (usbSlots == 0) {
                removeUsbControllers(newVm.getId());
            }
        }
    }
}
#method_after
/*
     * USB slot
     */
private void updateUsbSlots(VmBase oldVm, VmBase newVm) {
    UsbPolicy oldUsbPolicy = UsbPolicy.DISABLED;
    UsbPolicy newUsbPolicy = newVm.getUsbPolicy();
    int currentNumberOfSlots = 0;
    if (oldVm != null) {
        oldUsbPolicy = oldVm.getUsbPolicy();
        currentNumberOfSlots = getUsbSlots(oldVm.getId()).size();
    }
    final int usbSlots = Config.<Integer>getValue(ConfigValues.NumberOfUSBSlots);
    // We add USB slots if they are disabled in oldVm configuration, but enabled in newVm
    if (!oldUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE) && newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (usbSlots > 0) {
            removeUsbControllers(newVm.getId());
            addUsbControllers(newVm.getId(), getNeededNumberOfUsbControllers(usbSlots));
            addUsbSlots(newVm.getId(), usbSlots);
        }
    // Remove USB slots and controllers if the policy is to disable
    } else if (newUsbPolicy.equals(UsbPolicy.DISABLED)) {
        removeUsbControllers(newVm.getId());
        removeUsbSlots(newVm.getId());
    // If the USB policy is to enable (and was enabled before), we need to update the number of slots
    } else if (newUsbPolicy.equals(UsbPolicy.ENABLED_NATIVE)) {
        if (currentNumberOfSlots < usbSlots) {
            // Add slots and controllers
            if (currentNumberOfSlots == 0) {
                addUsbControllers(newVm.getId(), getNeededNumberOfUsbControllers(usbSlots));
            }
            addUsbSlots(newVm.getId(), usbSlots - currentNumberOfSlots);
        } else if (currentNumberOfSlots > usbSlots) {
            // Remove slots and controllers
            removeUsbSlots(newVm.getId(), currentNumberOfSlots - usbSlots);
            if (usbSlots == 0) {
                removeUsbControllers(newVm.getId());
            }
        }
    }
}
#end_block

#method_before
public VmDevice addDiskDevice(Guid vmId, Guid deviceId) {
    return addDiskDevice(vmId, deviceId, true, false, "", false);
}
#method_after
public VmDevice addDiskDevice(Guid vmId, Guid deviceId) {
    return addDiskDevice(vmId, deviceId, true, false, "");
}
#end_block

#method_before
public VmDevice addDiskDevice(Guid vmId, Guid deviceId, String address) {
    return addDiskDevice(vmId, deviceId, true, false, address, false);
}
#method_after
public VmDevice addDiskDevice(Guid vmId, Guid deviceId, String address) {
    return addDiskDevice(vmId, deviceId, true, false, address);
}
#end_block

#method_before
public VmDevice addDiskDevice(Guid vmId, Guid deviceId, Boolean isPlugged, Boolean isReadOnly, String address, boolean isUsingScsiReservation) {
    return addManagedDevice(new VmDeviceId(deviceId, vmId), VmDeviceGeneralType.DISK, VmDeviceType.DISK, Collections.emptyMap(), isPlugged, isReadOnly, address, null, isUsingScsiReservation);
}
#method_after
public VmDevice addDiskDevice(Guid vmId, Guid deviceId, Boolean isPlugged, Boolean isReadOnly) {
    return addDiskDevice(vmId, deviceId, isPlugged, isReadOnly, "");
}
#end_block

#method_before
public void updateBootOrder(Guid vmId) {
    VM vm = vmDao.get(vmId);
    if (vm != null) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vmId);
        // Reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        VmHandler.updateDisksForVm(vm, diskDao.getAllForVm(vmId));
        VmHandler.updateDisksVmDataForVm(vm);
        VmHandler.updateNetworkInterfacesFromDb(vm);
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices);
        vmDeviceDao.updateBootOrderInBatch(devices);
    }
}
#method_after
public void updateBootOrder(Guid vmId) {
    VM vm = vmDao.get(vmId);
    if (vm != null) {
        // Returns the devices sorted in ascending order
        List<VmDevice> devices = vmDeviceDao.getVmDeviceByVmId(vmId);
        // Reset current boot order
        for (VmDevice device : devices) {
            device.setBootOrder(0);
        }
        vmHandler.updateDisksForVm(vm, diskDao.getAllForVm(vmId));
        vmHandler.updateDisksVmDataForVm(vm);
        vmHandler.updateNetworkInterfacesFromDb(vm);
        VmDeviceCommonUtils.updateVmDevicesBootOrder(vm, devices);
        vmDeviceDao.updateBootOrderInBatch(devices);
    }
}
#end_block

#method_before
public void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase newVmBase = params.getVmStaticData();
    if (newVmBase == null) {
        return;
    }
    updateCdPath(oldVmBase, newVmBase);
    updateBootOrder(oldVmBase, newVmBase);
    updateVideoDevices(oldVmBase, newVmBase);
    updateUsbSlots(oldVmBase, newVmBase);
    updateMemoryBalloon(newVmBase.getId(), params.isBalloonEnabled());
    updateSoundDevice(oldVmBase, newVmBase, oldVm.getCompatibilityVersion(), params.isSoundDeviceEnabled());
    updateSmartcardDevice(oldVm, newVmBase);
    updateConsoleDevice(newVmBase.getId(), params.isConsoleEnabled());
    int scsiControllers = (newVmBase.getNumOfIoThreads() > 1 && params.isVirtioScsiEnabled()) ? newVmBase.getNumOfIoThreads() : 1;
    for (int i = 1; i <= scsiControllers; i++) {
        updateVirtioScsiController(newVmBase.getId(), params.isVirtioScsiEnabled());
    }
}
#method_after
public void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase newVmBase = params.getVmStaticData();
    if (newVmBase == null) {
        return;
    }
    updateCdPath(oldVmBase, newVmBase);
    updateBootOrder(oldVmBase, newVmBase);
    updateVideoDevices(oldVmBase, newVmBase);
    updateUsbSlots(oldVmBase, newVmBase);
    updateMemoryBalloon(newVmBase.getId(), params.isBalloonEnabled());
    updateSoundDevice(oldVmBase, newVmBase, oldVm.getCompatibilityVersion(), params.isSoundDeviceEnabled());
    updateSmartcardDevice(oldVm, newVmBase);
    updateConsoleDevice(newVmBase.getId(), params.isConsoleEnabled());
    updateVirtioScsiController(newVmBase, params.isVirtioScsiEnabled());
}
#end_block

#method_before
public void copyVmDevices(Guid srcId, Guid dstId, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device)).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstId);
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#method_after
public void copyVmDevices(Guid srcId, Guid dstId, VmBase dstVmBase, List<VmDevice> srcDevices, Map<Guid, Guid> srcDeviceIdToDstDeviceIdMapping, boolean isSoundEnabled, boolean isConsoleEnabled, Boolean isVirtioScsiEnabled, boolean isBalloonEnabled, Set<GraphicsType> graphicsToSkip, boolean copySnapshotDevices, boolean copyHostDevices) {
    if (graphicsToSkip == null) {
        graphicsToSkip = Collections.emptySet();
    }
    String dstCdPath = dstVmBase.getIsoPath();
    boolean dstIsVm = !(dstVmBase instanceof VmTemplate);
    boolean hasCd = hasCdDevice(dstVmBase.getId());
    boolean hasSound = false;
    boolean hasConsole = false;
    boolean hasVirtioScsi = false;
    boolean hasBalloon = false;
    boolean hasRng = hasRngDevice(dstId);
    Cluster cluster = null;
    if (dstVmBase.getClusterId() != null) {
        cluster = clusterDao.get(dstVmBase.getClusterId());
    }
    for (VmDevice device : srcDevices) {
        if (device.getSnapshotId() != null && !copySnapshotDevices) {
            continue;
        }
        Guid deviceId = Guid.newGuid();
        Map<String, Object> specParams = new HashMap<>();
        switch(device.getType()) {
            case DISK:
                if (VmDeviceType.DISK.getName().equals(device.getDevice())) {
                    if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                        deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                    }
                } else if (VmDeviceType.CDROM.getName().equals(device.getDevice())) {
                    if (!hasCd) {
                        hasCd = true;
                        // check here is source VM had CD (VM from snapshot)
                        String srcCdPath = (String) device.getSpecParams().get(VdsProperties.Path);
                        specParams.putAll(getCdDeviceSpecParams(srcCdPath, dstCdPath));
                    } else {
                        // CD already exists
                        continue;
                    }
                }
                break;
            case INTERFACE:
                if (srcDeviceIdToDstDeviceIdMapping.containsKey(device.getDeviceId())) {
                    deviceId = srcDeviceIdToDstDeviceIdMapping.get(device.getDeviceId());
                }
                break;
            case CONTROLLER:
                if (VmDeviceType.USB.getName().equals(device.getDevice())) {
                    specParams = device.getSpecParams();
                } else if (VmDeviceType.VIRTIOSCSI.getName().equals(device.getDevice())) {
                    hasVirtioScsi = true;
                    if (Boolean.FALSE.equals(isVirtioScsiEnabled)) {
                        continue;
                    }
                }
                break;
            case VIDEO:
                if (dstIsVm) {
                    // to the new Vm params.
                    continue;
                }
                specParams.putAll(getVideoDeviceSpecParams(dstVmBase));
                break;
            case BALLOON:
                if (!isBalloonEnabled) {
                    continue;
                }
                hasBalloon = true;
                specParams.putAll(getMemoryBalloonSpecParams());
                break;
            case SMARTCARD:
                specParams.putAll(getSmartcardDeviceSpecParams());
                break;
            case WATCHDOG:
                specParams.putAll(device.getSpecParams());
                break;
            case RNG:
                if (hasRng) {
                    continue;
                }
                if (!new VirtIoRngValidator().canAddRngDevice(cluster, new VmRngDevice(device), dstVmBase.getCustomCompatibilityVersion()).isValid()) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            case CONSOLE:
                if (!isConsoleEnabled) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                hasConsole = true;
                break;
            case SOUND:
                if (!isSoundEnabled) {
                    continue;
                }
                hasSound = true;
                break;
            case GRAPHICS:
                GraphicsType type = GraphicsType.fromVmDeviceType(VmDeviceType.getByName(device.getDevice()));
                // OR if we already have it
                if (graphicsToSkip.contains(type) || hasGraphicsDevice(dstId, GraphicsType.fromString(device.getDevice()))) {
                    continue;
                }
                break;
            case HOSTDEV:
                if (!copyHostDevices) {
                    continue;
                }
                specParams.putAll(device.getSpecParams());
                break;
            default:
                break;
        }
        device.setId(new VmDeviceId(deviceId, dstId));
        device.setSpecParams(specParams);
        vmDeviceDao.save(device);
    }
    if (!hasCd) {
        addCdDevice(dstId, dstCdPath);
    }
    // according to the destination USB policy
    if (srcId.equals(Guid.Empty)) {
        updateUsbSlots(null, dstVmBase);
    }
    if (isSoundEnabled && !hasSound) {
        if (dstIsVm) {
            addSoundDevice(dstVmBase);
        } else {
            addSoundDevice(dstVmBase.getId(), dstVmBase.getOsId(), cluster != null ? cluster.getCompatibilityVersion() : null);
        }
    }
    if (isConsoleEnabled && !hasConsole) {
        addConsoleDevice(dstId);
    }
    if (Boolean.TRUE.equals(isVirtioScsiEnabled) && !hasVirtioScsi) {
        addVirtioScsiController(dstVmBase, getVmCompatibilityVersion(dstVmBase));
    }
    if (isBalloonEnabled && !hasBalloon) {
        addMemoryBalloon(dstId);
    }
    if (dstIsVm) {
        updateBootOrder(dstVmBase.getId());
        addVideoDevices(dstVmBase, getNeededNumberOfVideoDevices(dstVmBase));
    }
}
#end_block

#method_before
public VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, boolean isPlugged, Boolean isReadOnly) {
    return addManagedDevice(id, generalType, type, specParams, isPlugged, isReadOnly, "", null, false);
}
#method_after
public VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, boolean isPlugged, Boolean isReadOnly) {
    return addManagedDevice(id, generalType, type, specParams, isPlugged, isReadOnly, "", null);
}
#end_block

#method_before
public VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, Boolean isPlugged, Boolean isReadOnly, String address, Map<String, String> customProps, boolean isUsingScsiReservation) {
    VmDevice managedDevice = new VmDevice(id, generalType, type.getName(), StringUtils.isNotBlank(address) ? address : "", 0, specParams, true, isPlugged, isReadOnly, "", customProps, null, null, isUsingScsiReservation);
    vmDeviceDao.save(managedDevice);
    // If we've added Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (generalType == VmDeviceGeneralType.DISK || generalType == VmDeviceGeneralType.INTERFACE) {
        updateBootOrder(id.getVmId());
    }
    return managedDevice;
}
#method_after
public VmDevice addManagedDevice(VmDeviceId id, VmDeviceGeneralType generalType, VmDeviceType type, Map<String, Object> specParams, Boolean isPlugged, Boolean isReadOnly, String address, Map<String, String> customProps) {
    VmDevice managedDevice = new VmDevice(id, generalType, type.getName(), StringUtils.isNotBlank(address) ? address : "", 0, specParams, true, isPlugged, isReadOnly, "", customProps, null, null);
    vmDeviceDao.save(managedDevice);
    // If we've added Disk/Interface/CD/Floppy, we have to recalculate boot order
    if (generalType == VmDeviceGeneralType.DISK || generalType == VmDeviceGeneralType.INTERFACE) {
        updateBootOrder(id.getVmId());
    }
    return managedDevice;
}
#end_block

#method_before
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = VmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    return vmManagedDeviceMap;
}
#method_after
public Map<Guid, VmDevice> getVmDevicesForNextRun(VM vm, Object objectWithEditableDeviceFields) {
    setVmDevices(vm.getStaticData());
    Map<Guid, VmDevice> vmManagedDeviceMap = vm.getManagedVmDeviceMap();
    List<VmDeviceUpdate> fieldList = vmHandler.getVmDevicesFieldsToUpdateOnNextRun(vm.getId(), vm.getStatus(), objectWithEditableDeviceFields);
    // Add the enabled devices and remove the disabled ones
    for (VmDeviceUpdate update : fieldList) {
        if (update.isEnable()) {
            VmDevice device;
            if (update.getDevice() == null) {
                device = new VmDevice(new VmDeviceId(Guid.newGuid(), vm.getId()), update.getGeneralType(), update.getType().getName(), "", 0, Collections.emptyMap(), true, true, update.isReadOnly(), "", null, null, null);
            } else {
                device = update.getDevice();
                if (device.getVmId() == null) {
                    device.setVmId(vm.getId());
                }
                if (device.getDeviceId() == null) {
                    device.setDeviceId(Guid.newGuid());
                }
            }
            vmManagedDeviceMap.put(device.getDeviceId(), device);
        } else {
            VmDevice device;
            if (update.getType() != VmDeviceType.UNKNOWN) {
                device = VmDeviceCommonUtils.findVmDeviceByType(vmManagedDeviceMap, update.getType());
            } else {
                device = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmManagedDeviceMap, update.getGeneralType());
            }
            if (device != null) {
                vmManagedDeviceMap.remove(device.getDeviceId());
            }
        }
    }
    return vmManagedDeviceMap;
}
#end_block

#method_before
@Override
public boolean equals(Object o) {
    if (o instanceof PermissionSubject) {
        PermissionSubject other = (PermissionSubject) o;
        return other.objectId.equals(objectId) && other.ObjectType.equals(ObjectType) && other.actionGroup.equals(actionGroup);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object o) {
    if (o == this) {
        return true;
    }
    if (o instanceof PermissionSubject) {
        PermissionSubject other = (PermissionSubject) o;
        return Objects.equals(other.objectId, objectId) && Objects.equals(other.ObjectType, ObjectType) && Objects.equals(other.actionGroup, actionGroup);
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(name, clusterId, volumeType, status, replicaCount, stripeCount, disperseCount, redundancyCount, arbiterCount, options, accessProtocols, transportTypes, bricks, asyncTask, advancedDetails, snapshotsCount, snapMaxLimit, snapshotScheduled);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(name, clusterId, volumeType, status, replicaCount, stripeCount, disperseCount, redundancyCount, isArbiter, options, accessProtocols, transportTypes, bricks, asyncTask, advancedDetails, snapshotsCount, snapMaxLimit, snapshotScheduled);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity other = (GlusterVolumeEntity) obj;
    return Objects.equals(name, other.getName()) && Objects.equals(clusterId, other.clusterId) && volumeType == other.volumeType && status == other.status && Objects.equals(replicaCount, other.replicaCount) && Objects.equals(stripeCount, other.stripeCount) && Objects.equals(disperseCount, other.disperseCount) && Objects.equals(redundancyCount, other.redundancyCount) && Objects.equals(arbiterCount, other.arbiterCount) && ObjectUtils.haveSameElements(getOptions(), other.getOptions()) && ObjectUtils.haveSameElements(accessProtocols, other.accessProtocols) && ObjectUtils.haveSameElements(transportTypes, other.transportTypes) && ObjectUtils.haveSameElements(bricks, other.bricks) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(advancedDetails, other.advancedDetails) && Objects.equals(snapshotsCount, other.snapshotsCount) && Objects.equals(snapMaxLimit, other.snapMaxLimit) && Objects.equals(snapshotScheduled, other.snapshotScheduled);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterVolumeEntity)) {
        return false;
    }
    GlusterVolumeEntity other = (GlusterVolumeEntity) obj;
    return Objects.equals(name, other.getName()) && Objects.equals(clusterId, other.clusterId) && volumeType == other.volumeType && status == other.status && Objects.equals(replicaCount, other.replicaCount) && Objects.equals(stripeCount, other.stripeCount) && Objects.equals(disperseCount, other.disperseCount) && Objects.equals(redundancyCount, other.redundancyCount) && Objects.equals(isArbiter, other.isArbiter) && ObjectUtils.haveSameElements(getOptions(), other.getOptions()) && ObjectUtils.haveSameElements(accessProtocols, other.accessProtocols) && ObjectUtils.haveSameElements(transportTypes, other.transportTypes) && ObjectUtils.haveSameElements(bricks, other.bricks) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(advancedDetails, other.advancedDetails) && Objects.equals(snapshotsCount, other.snapshotsCount) && Objects.equals(snapMaxLimit, other.snapMaxLimit) && Objects.equals(snapshotScheduled, other.snapshotScheduled);
}
#end_block

#method_before
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()).addValue("arbiter_count", volume.getArbiterCount()));
}
#method_after
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()).addValue("is_arbiter", volume.getIsArbiter()));
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(GlusterVolumeEntity volume) {
    return getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()).addValue("arbiter_count", volume.getArbiterCount());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(GlusterVolumeEntity volume) {
    return getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("disperse_count", volume.getDisperseCount()).addValue("redundancy_count", volume.getRedundancyCount()).addValue("is_arbiter", volume.getIsArbiter());
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity other = (GlusterBrickEntity) obj;
    return Objects.equals(id, other.id) && Objects.equals(volumeId, other.volumeId) && Objects.equals(serverId, other.serverId) && Objects.equals(brickDirectory, other.brickDirectory) && Objects.equals(brickOrder, other.brickOrder) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(unSyncedEntries, other.unSyncedEntries) && Objects.equals(unSyncedEntriesTrend, other.unSyncedEntriesTrend) && Objects.equals(selfHealEta, other.selfHealEta) && status == other.status && (Objects.equals(isArbiter, other.isArbiter));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof GlusterBrickEntity)) {
        return false;
    }
    GlusterBrickEntity other = (GlusterBrickEntity) obj;
    return Objects.equals(id, other.id) && Objects.equals(volumeId, other.volumeId) && Objects.equals(serverId, other.serverId) && Objects.equals(brickDirectory, other.brickDirectory) && Objects.equals(brickOrder, other.brickOrder) && Objects.equals(asyncTask, other.asyncTask) && Objects.equals(unSyncedEntries, other.unSyncedEntries) && Objects.equals(unSyncedEntriesTrend, other.unSyncedEntriesTrend) && Objects.equals(selfHealEta, other.selfHealEta) && status == other.status && Objects.equals(isArbiter, other.isArbiter);
}
#end_block

#method_before
protected boolean validate() {
    VM vm = parentCommand.getVm();
    if (vm == null) {
        parentCommand.addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    } else {
        targetCluster = clusterDao.get(targetClusterId);
        if (targetCluster == null) {
            parentCommand.addValidationMessage(EngineMessage.VM_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // Check that the target cluster is in the same data center.
        if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
            parentCommand.addValidationMessage(EngineMessage.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
            return false;
        }
        if (vmCompatibilityVersion == null) {
            vmCompatibilityVersion = targetCluster.getCompatibilityVersion();
        }
        List<VmNic> interfaces = vmNicDao.getAllForVm(vm.getId());
        if (!validateDestinationClusterContainsNetworks(interfaces)) {
            return false;
        }
        // Check if VM static parameters are compatible for new cluster.
        ValidationResult isCpuSocketsValid = VmValidator.validateCpuSockets(vm.getStaticData(), vmCompatibilityVersion.getValue());
        if (!isCpuSocketsValid.isValid()) {
            return parentCommand.validate(isCpuSocketsValid);
        }
        // Check that the USB policy is legal
        if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), parentCommand.getReturnValue().getValidationMessages())) {
            return false;
        }
        // Check if the display type is supported
        if (!VmHandler.isGraphicsAndDisplaySupported(vm.getOs(), vmDeviceUtils.getGraphicsTypesOfEntity(vm.getId()), vm.getDefaultDisplayType(), parentCommand.getReturnValue().getValidationMessages(), vmCompatibilityVersion)) {
            return false;
        }
        if (vmDeviceUtils.hasVirtioScsiController(vm.getId())) {
            // Verify OS compatibility
            if (!VmHandler.isOsTypeSupportedForVirtioScsi(vm.getOs(), vmCompatibilityVersion, parentCommand.getReturnValue().getValidationMessages())) {
                return false;
            }
        }
        // A existing VM cannot be changed into a cluster without a defined architecture
        if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
            return parentCommand.failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
            return parentCommand.failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
        // Cluster must have a cpu profile
        List<CpuProfile> cpuProfiles = cpuProfileDao.getAllForCluster(targetClusterId, parentCommand.getUserId(), true, ActionGroup.ASSIGN_CPU_PROFILE);
        if (cpuProfiles.isEmpty()) {
            return parentCommand.failValidation(EngineMessage.ACTION_TYPE_CPU_PROFILE_EMPTY);
        }
    }
    return true;
}
#method_after
protected boolean validate() {
    VM vm = parentCommand.getVm();
    if (vm == null) {
        parentCommand.addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    } else {
        targetCluster = clusterDao.get(targetClusterId);
        if (targetCluster == null) {
            parentCommand.addValidationMessage(EngineMessage.VM_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // Check that the target cluster is in the same data center.
        if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
            parentCommand.addValidationMessage(EngineMessage.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
            return false;
        }
        if (vmCompatibilityVersion == null) {
            vmCompatibilityVersion = targetCluster.getCompatibilityVersion();
        }
        List<VmNic> interfaces = vmNicDao.getAllForVm(vm.getId());
        if (!validateDestinationClusterContainsNetworks(interfaces)) {
            return false;
        }
        // Check if VM static parameters are compatible for new cluster.
        ValidationResult isCpuSocketsValid = VmValidator.validateCpuSockets(vm.getStaticData(), vmCompatibilityVersion.getValue());
        if (!isCpuSocketsValid.isValid()) {
            return parentCommand.validate(isCpuSocketsValid);
        }
        // Check if the display type is supported
        if (!VmHandler.isGraphicsAndDisplaySupported(vm.getOs(), vmDeviceUtils.getGraphicsTypesOfEntity(vm.getId()), vm.getDefaultDisplayType(), parentCommand.getReturnValue().getValidationMessages(), vmCompatibilityVersion)) {
            return false;
        }
        if (vmDeviceUtils.hasVirtioScsiController(vm.getId())) {
            // Verify OS compatibility
            if (!VmHandler.isOsTypeSupportedForVirtioScsi(vm.getOs(), vmCompatibilityVersion, parentCommand.getReturnValue().getValidationMessages())) {
                return false;
            }
        }
        // A existing VM cannot be changed into a cluster without a defined architecture
        if (targetCluster.getArchitecture() == ArchitectureType.undefined) {
            return parentCommand.failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        } else if (targetCluster.getArchitecture() != vm.getClusterArch()) {
            return parentCommand.failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
        // Cluster must have a cpu profile
        List<CpuProfile> cpuProfiles = cpuProfileDao.getAllForCluster(targetClusterId, parentCommand.getUserId(), true, ActionGroup.ASSIGN_CPU_PROFILE);
        if (cpuProfiles.isEmpty()) {
            return parentCommand.failValidation(EngineMessage.ACTION_TYPE_CPU_PROFILE_EMPTY);
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = getVmValidator();
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = Injector.injectMembers(new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion(), getVmDeviceUtils()));
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    if (isInternalExecution() && getVm().getMigrationSupport() != MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#method_after
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = getVmValidator();
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = ChangeVmClusterValidator.create(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    if (isInternalExecution() && getVm().getMigrationSupport() != MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) {
        addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = Injector.injectMembers(new ChangeVmClusterValidator(this, getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion(), getVmDeviceUtils()));
    return validator.validate();
}
#method_after
@Override
protected boolean validate() {
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!isInternalExecution() && !ObjectIdentityChecker.canUpdateField(getVm(), "clusterId", getVm().getStatus())) {
        addValidationMessage(EngineMessage.VM_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    ChangeVmClusterValidator validator = ChangeVmClusterValidator.create(this, getParameters().getClusterId(), getParameters().getVmCustomCompatibilityVersion());
    return validator.validate();
}
#end_block

#method_before
private static TemplateWithVersion computeTemplateWithVersionToSelect(List<TemplateWithVersion> newItems, Guid previousTemplateId, boolean useLatest, boolean addLatest) {
    if (previousTemplateId == null) {
        return computeNewTemplateWithVersionToSelect(newItems, addLatest);
    }
    TemplateWithVersion oldTemplateToSelect = Linq.firstOrNull(newItems, new Linq.TemplateWithVersionPredicate(previousTemplateId, useLatest));
    return oldTemplateToSelect != null ? oldTemplateToSelect : computeNewTemplateWithVersionToSelect(newItems, addLatest);
}
#method_after
protected TemplateWithVersion computeTemplateWithVersionToSelect(List<TemplateWithVersion> newItems, Guid previousTemplateId, boolean useLatest, boolean addLatest) {
    if (previousTemplateId == null) {
        return computeNewTemplateWithVersionToSelect(newItems, addLatest);
    }
    TemplateWithVersion oldTemplateToSelect = Linq.firstOrNull(newItems, new Linq.TemplateWithVersionPredicate(previousTemplateId, useLatest));
    return oldTemplateToSelect != null ? oldTemplateToSelect : computeNewTemplateWithVersionToSelect(newItems, addLatest);
}
#end_block

#method_before
private static TemplateWithVersion computeNewTemplateWithVersionToSelect(List<TemplateWithVersion> newItems, boolean addLatest) {
    if (newItems.isEmpty()) {
        return null;
    }
    if (addLatest) {
        return newItems.size() >= 2 ? newItems.get(1) : newItems.get(0);
    }
    return newItems.get(0);
}
#method_after
protected static TemplateWithVersion computeNewTemplateWithVersionToSelect(List<TemplateWithVersion> newItems, boolean addLatest) {
    if (newItems.isEmpty()) {
        return null;
    }
    if (addLatest) {
        return newItems.size() >= 2 ? newItems.get(1) : newItems.get(0);
    }
    return newItems.get(0);
}
#end_block

#method_before
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            final Version clusterVersion = getModel().getSelectedCluster().getCompatibilityVersion();
            List<VmRngDevice> devs = returnValue.getReturnValue();
            getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
            final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
            rngDevice.setSource(VmRngDevice.Source.getValidForVersion(rngDevice.getSource(), clusterVersion));
            getModel().setRngDevice(rngDevice);
        }
    }));
}
#method_after
protected void updateRngDevice(Guid templateId) {
    if (!getModel().getIsRngEnabled().getIsChangable()) {
        return;
    }
    Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(templateId), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

        @Override
        public void onSuccess(VdcQueryReturnValue returnValue) {
            List<VmRngDevice> devs = returnValue.getReturnValue();
            getModel().getIsRngEnabled().setEntity(!devs.isEmpty());
            final VmRngDevice rngDevice = devs.isEmpty() ? new VmRngDevice() : devs.get(0);
            rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
            getModel().setRngDevice(rngDevice);
        }
    }));
}
#end_block

#method_before
protected void updateRngDevice(final VmBase vmBase) {
    if (model.getIsRngEnabled().getIsChangable() && model.getIsRngEnabled().getIsAvailable()) {
        if (!isNextRunConfigurationExists()) {
            Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    deactivate();
                    List<VmDevice> rngDevices = returnValue.getReturnValue();
                    getModel().getIsRngEnabled().setEntity(!rngDevices.isEmpty());
                    if (!rngDevices.isEmpty()) {
                        final Version clusterVersion = getModel().getSelectedCluster().getCompatibilityVersion();
                        VmRngDevice rngDevice = new VmRngDevice(rngDevices.get(0));
                        rngDevice.setSource(VmRngDevice.Source.getValidForVersion(rngDevice.getSource(), clusterVersion));
                        getModel().setRngDevice(rngDevice);
                    }
                    activate();
                    updateVirtioScsi(vmBase);
                }
            }));
        } else {
            deactivate();
            VmDevice rngDevice = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmBase.getManagedDeviceMap(), VmDeviceGeneralType.RNG);
            getModel().getIsRngEnabled().setEntity(rngDevice != null);
            if (rngDevice != null) {
                getModel().setRngDevice(new VmRngDevice(rngDevice));
            }
            activate();
            updateVirtioScsi(vmBase);
        }
    } else {
        updateVirtioScsi(vmBase);
    }
}
#method_after
protected void updateRngDevice(final VmBase vmBase) {
    if (model.getIsRngEnabled().getIsChangable() && model.getIsRngEnabled().getIsAvailable()) {
        if (!isNextRunConfigurationExists()) {
            Frontend.getInstance().runQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBase.getId()), new AsyncQuery<>(new AsyncCallback<VdcQueryReturnValue>() {

                @Override
                public void onSuccess(VdcQueryReturnValue returnValue) {
                    deactivate();
                    List<VmDevice> rngDevices = returnValue.getReturnValue();
                    getModel().getIsRngEnabled().setEntity(!rngDevices.isEmpty());
                    if (!rngDevices.isEmpty()) {
                        VmRngDevice rngDevice = new VmRngDevice(rngDevices.get(0));
                        rngDevice.updateSourceByVersion(getModel().getCompatibilityVersion());
                        getModel().setRngDevice(rngDevice);
                    }
                    activate();
                    updateVirtioScsi(vmBase);
                }
            }));
        } else {
            deactivate();
            VmDevice rngDevice = VmDeviceCommonUtils.findVmDeviceByGeneralType(vmBase.getManagedDeviceMap(), VmDeviceGeneralType.RNG);
            getModel().getIsRngEnabled().setEntity(rngDevice != null);
            if (rngDevice != null) {
                getModel().setRngDevice(new VmRngDevice(rngDevice));
            }
            activate();
            updateVirtioScsi(vmBase);
        }
    } else {
        updateVirtioScsi(vmBase);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (!oldNumaNodeIds.isEmpty()) {
        getVmNumaNodeDao().massRemoveNumaNodeByNumaNodeId(oldNumaNodeIds);
    }
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    vmNumaNodes.stream().forEach(node -> node.setId(Guid.newGuid()));
    getVmNumaNodeDao().massSaveNumaNode(vmNumaNodes, getVm().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (!oldNumaNodeIds.isEmpty()) {
        vmNumaNodeDao.massRemoveNumaNodeByNumaNodeId(oldNumaNodeIds);
    }
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    vmNumaNodes.stream().forEach(node -> node.setId(Guid.newGuid()));
    vmNumaNodeDao.massSaveNumaNode(vmNumaNodes, getVm().getId());
    setSucceeded(true);
}
#end_block

#method_before
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, cachedVds);
            updateDynamicData(cachedVds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = new AuditLogableBase(vdsId);
        auditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#method_after
public void handleSecureSetup() {
    // if ssl is on and no certificate file
    if (Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication) && !EngineEncryptionUtils.haveKey()) {
        if (cachedVds.getStatus() != VDSStatus.Maintenance && cachedVds.getStatus() != VDSStatus.InstallFailed) {
            setStatus(VDSStatus.NonResponsive, cachedVds);
            updateDynamicData(cachedVds.getDynamicData());
        }
        log.error("Could not find VDC Certificate file.");
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vdsId));
        auditLogDirector.log(logable, AuditLogType.CERTIFICATE_FILE_NOT_FOUND);
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (lockManager.acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        unrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            lockManager.releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    if (lockManager.acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (this) {
                refreshCachedVds();
                if (cachedVds == null) {
                    log.error("VdsManager::refreshVdsRunTimeInfo - onTimer is NULL for '{}'", getVdsId());
                    return;
                }
                try {
                    updateIteration();
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        hostMonitoring = new HostMonitoring(this, cachedVds, monitoringStrategy, resourceManager, dbFacade, auditLogDirector);
                        hostMonitoring.refresh();
                        unrespondedAttempts.set(0);
                        setLastUpdate();
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    handleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (hostMonitoring != null) {
                        hostMonitoring.afterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (cachedVds != null && cachedVds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = cachedVds.getStoragePoolId();
                            domainsList = cachedVds.getDomains();
                        }
                    }
                    hostMonitoring = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                updateVdsDomainsData(cachedVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtime info failed. Exception:", e);
        } finally {
            lockManager.releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    boolean updateAvailable;
    try {
        updateAvailable = resourceManager.isUpdateAvailable(cachedVds);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}' with exception '{}'", cachedVds.getName(), StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        log.debug("Exception", e);
        AuditLogableBase auditLog = new AuditLogableBase();
        auditLog.setVds(cachedVds);
        auditLog.addCustomValue("Message", StringUtils.defaultString(e.getMessage(), e.getCause().toString()));
        auditLogDirector.log(auditLog, AuditLogType.HOST_AVAILABLE_UPDATES_FAILED);
        return;
    }
    synchronized (getLockObj()) {
        if (updateAvailable != cachedVds.isUpdateAvailable()) {
            cachedVds.getDynamicData().setUpdateAvailable(updateAvailable);
            vdsDynamicDao.updateUpdateAvailable(cachedVds.getId(), updateAvailable);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("availableUpdates")
public void availableUpdates() {
    if (cachedVds.getStatus() != VDSStatus.Up && cachedVds.getStatus() != VDSStatus.NonOperational) {
        log.warn("Check for available updates is skipped for host '{}' due to unsupported host status '{}' ", cachedVds.getName(), cachedVds.getStatus());
        return;
    }
    checkForUpdates(cachedVds);
}
#end_block

#method_before
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        vdsDynamicDao.updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = new AuditLogableBase(cachedVds.getId());
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        auditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#method_after
private void handleVdsRecoveringException(VDSRecoveringException ex) {
    if (cachedVds.getStatus() != VDSStatus.Initializing && cachedVds.getStatus() != VDSStatus.NonOperational) {
        setStatus(VDSStatus.Initializing, cachedVds);
        vdsDynamicDao.updateStatus(cachedVds.getId(), VDSStatus.Initializing);
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(cachedVds.getId()));
        logable.addCustomValue("ErrorMessage", ex.getMessage());
        logable.updateCallStackFromThrowable(ex);
        auditLogDirector.log(logable, AuditLogType.VDS_INITIALIZING);
        log.warn("Failed to refresh VDS, continuing, vds='{}'({}): {}", cachedVds.getName(), cachedVds.getId(), ex.getMessage());
        log.debug("Exception", ex);
        final int VDS_RECOVERY_TIMEOUT_IN_MINUTES = Config.<Integer>getValue(ConfigValues.VdsRecoveryTimeoutInMinutes);
        String jobId = getSchedulUtil().scheduleAOneTimeJob(this, "onTimerHandleVdsRecovering", new Class[0], new Object[0], VDS_RECOVERY_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        recoveringJobIdMap.put(cachedVds.getId(), jobId);
    }
}
#end_block

#method_before
public void updatePendingData(int pendingMemory, int pendingCpuCount) {
    synchronized (getLockObj()) {
        cachedVds.setPendingVcpusCount(pendingCpuCount);
        cachedVds.setPendingVmemSize(pendingMemory);
        HostMonitoring.refreshCommitedMemory(cachedVds, getVmDynamicDao().getAllRunningForVds(getVdsId()), resourceManager);
        updateDynamicData(cachedVds.getDynamicData());
    }
}
#method_after
public void updatePendingData(int pendingMemory, int pendingCpuCount) {
    synchronized (this) {
        cachedVds.setPendingVcpusCount(pendingCpuCount);
        cachedVds.setPendingVmemSize(pendingMemory);
        HostMonitoring.refreshCommitedMemory(cachedVds, getVmDynamicDao().getAllRunningForVds(getVdsId()), resourceManager);
        updateDynamicData(cachedVds.getDynamicData());
    }
}
#end_block

#method_before
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (getLockObj()) {
        // non-responsive event during moving host to maintenance should be ignored
        if (isNetworkExceptionDuringMaintenance(status)) {
            return;
        }
        if (vds == null) {
            vds = vdsDao.get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.cachedVds != null) {
                this.cachedVds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.cachedVds != null) {
            this.cachedVds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.cachedVds != null) {
                    this.cachedVds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.cachedVds != null) {
                    this.cachedVds.setCpuSys(Double.valueOf(0));
                    this.cachedVds.setCpuUser(Double.valueOf(0));
                    this.cachedVds.setCpuIdle(Double.valueOf(0));
                    this.cachedVds.setCpuLoad(Double.valueOf(0));
                    this.cachedVds.setUsageCpuPercent(0);
                    this.cachedVds.setUsageMemPercent(0);
                    this.cachedVds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#method_after
public void setStatus(VDSStatus status, VDS vds) {
    synchronized (this) {
        // non-responsive event during moving host to maintenance should be ignored
        if (isNetworkExceptionDuringMaintenance(status)) {
            return;
        }
        if (vds == null) {
            vds = vdsDao.get(getVdsId());
        }
        if (vds.getStatus() != status) {
            if (status == VDSStatus.PreparingForMaintenance) {
                calculateNextMaintenanceAttemptTime();
            }
            vds.setPreviousStatus(vds.getStatus());
            if (this.cachedVds != null) {
                this.cachedVds.setPreviousStatus(vds.getStatus());
            }
        }
        // update to new status
        vds.setStatus(status);
        if (this.cachedVds != null) {
            this.cachedVds.setStatus(status);
        }
        switch(status) {
            case NonOperational:
                if (this.cachedVds != null) {
                    this.cachedVds.setNonOperationalReason(vds.getNonOperationalReason());
                }
                if (vds.getVmCount() > 0) {
                    break;
                }
            case NonResponsive:
            case Down:
            case Maintenance:
                vds.setCpuSys(Double.valueOf(0));
                vds.setCpuUser(Double.valueOf(0));
                vds.setCpuIdle(Double.valueOf(0));
                vds.setCpuLoad(Double.valueOf(0));
                vds.setUsageCpuPercent(0);
                vds.setUsageMemPercent(0);
                vds.setUsageNetworkPercent(0);
                if (this.cachedVds != null) {
                    this.cachedVds.setCpuSys(Double.valueOf(0));
                    this.cachedVds.setCpuUser(Double.valueOf(0));
                    this.cachedVds.setCpuIdle(Double.valueOf(0));
                    this.cachedVds.setCpuLoad(Double.valueOf(0));
                    this.cachedVds.setUsageCpuPercent(0);
                    this.cachedVds.setUsageMemPercent(0);
                    this.cachedVds.setUsageNetworkPercent(0);
                }
            default:
                break;
        }
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (failedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && failedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = getSchedulUtil();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), failedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (failedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && failedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        resourceManager.runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = getSchedulUtil();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes), TimeUnit.MINUTES);
        auditLogDirector.log(Injector.injectMembers(new AuditLogableBase(vds.getId())).addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString()), AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.info("Vds '{}' moved to Error mode after {} attempts. Time: {}", vds.getName(), failedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getClusterCompatibilityVersion();
        if (// host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        // hence warning in case of permissive as well.
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getClusterSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(new AuditLogableBase(vds.getId()).addCustomValue("Mode", vds.getSELinuxEnforceMode() == null ? "UNKNOWN" : vds.getSELinuxEnforceMode().name()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            vdsDynamicDao.updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#method_after
public VDSStatus refreshCapabilities(AtomicBoolean processHardwareCapsNeeded, VDS vds) {
    log.debug("monitoring: refresh '{}' capabilities", vds);
    VDS oldVDS = vds.clone();
    VDSReturnValue caps = resourceManager.runVdsCommand(VDSCommandType.GetCapabilities, new VdsIdAndVdsVDSCommandParametersBase(vds));
    if (caps.getSucceeded()) {
        // Verify version capabilities
        HashSet<Version> hostVersions = null;
        Version clusterCompatibility = vds.getClusterCompatibilityVersion();
        if (// host and an exception will be raised by VDSM.
        (hostVersions = vds.getSupportedClusterVersionsSet()) != null && hostVersions.contains(clusterCompatibility)) {
            VDSReturnValue ret = resourceManager.runVdsCommand(VDSCommandType.GetHardwareInfo, new VdsIdAndVdsVDSCommandParametersBase(vds));
            if (!ret.getSucceeded()) {
                AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
                logable.updateCallStackFromThrowable(ret.getExceptionObject());
                auditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO);
            }
        }
        // hence warning in case of permissive as well.
        if (vds.getSELinuxEnforceMode() == null || vds.getSELinuxEnforceMode().equals(SELinuxMode.DISABLED) || (vds.getClusterSupportsGlusterService() && vds.getSELinuxEnforceMode().equals(SELinuxMode.PERMISSIVE))) {
            auditLogDirector.log(Injector.injectMembers(new AuditLogableBase(vds.getId())).addCustomValue("Mode", vds.getSELinuxEnforceMode() == null ? "UNKNOWN" : vds.getSELinuxEnforceMode().name()), AuditLogType.VDS_NO_SELINUX_ENFORCEMENT);
            if (vds.getSELinuxEnforceMode() != null) {
                log.warn("Host '{}' is running with SELinux in '{}' mode", vds.getName(), vds.getSELinuxEnforceMode());
            } else {
                log.warn("Host '{}' does not report SELinux enforcement information.", vds.getName());
            }
        }
        VDSStatus returnStatus = vds.getStatus();
        NonOperationalReason nonOperationalReason = getHostNetworkTopologyPersister().persistAndEnforceNetworkCompliance(vds);
        if (nonOperationalReason != NonOperationalReason.NONE) {
            setIsSetNonOperationalExecuted(true);
            if (returnStatus != VDSStatus.NonOperational) {
                log.debug("monitoring: vds '{}' networks do not match its cluster networks, vds will be moved to NonOperational", vds);
                vds.setStatus(VDSStatus.NonOperational);
                vds.setNonOperationalReason(nonOperationalReason);
            }
        }
        // We process the software capabilities.
        VDSStatus oldStatus = vds.getStatus();
        if (oldStatus != VDSStatus.Up) {
            // persist to db the host's cpu_flags.
            // TODO this needs to be revisited - either all the logic is in-memory or based on db
            vdsDynamicDao.updateCpuFlags(vds.getId(), vds.getCpuFlags());
            processHostFeaturesReported(vds);
            monitoringStrategy.processHardwareCapabilities(vds);
        }
        monitoringStrategy.processSoftwareCapabilities(vds);
        returnStatus = vds.getStatus();
        if (returnStatus != oldStatus && returnStatus == VDSStatus.NonOperational) {
            setIsSetNonOperationalExecuted(true);
        }
        processHardwareCapsNeeded.set(monitoringStrategy.processHardwareCapabilitiesNeeded(oldVDS, vds));
        return returnStatus;
    } else if (caps.getExceptionObject() != null) {
        throw caps.getExceptionObject();
    } else {
        log.error("refreshCapabilities:GetCapabilitiesVDSCommand failed with no exception!");
        throw new RuntimeException(caps.getExceptionString());
    }
}
#end_block

#method_before
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = new AuditLogableBase(cachedVds.getId());
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#method_after
private void logHostFailToRespond(VDSNetworkException ex, long timeoutToFence) {
    log.info("Server failed to respond, vds_id='{}', vds_name='{}', vm_count={}, " + "spm_status='{}', non-responsive_timeout (seconds)={}, error: {}", cachedVds.getId(), cachedVds.getName(), cachedVds.getVmCount(), cachedVds.getSpmStatus(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence), ex.getMessage());
    AuditLogableBase logable;
    logable = Injector.injectMembers(new AuditLogableBase(cachedVds.getId()));
    logable.updateCallStackFromThrowable(ex);
    if (ex.getCause() instanceof java.net.UnknownHostException) {
        auditLogDirector.log(logable, AuditLogType.VDS_UNKNOWN_HOST);
    } else {
        auditLogDirector.log(logable, AuditLogType.VDS_FAILURE);
    }
}
#end_block

#method_before
private void logChangeStatusToConnecting(long timeoutToFence) {
    String msg;
    AuditLogType auditLogType;
    if (cachedVds.isPmEnabled()) {
        msg = "Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING;
        log.warn(msg, cachedVds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
    } else {
        msg = "Host '{}' is not responding.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING;
        log.warn(msg, cachedVds.getName());
    }
    AuditLogableBase logable = new AuditLogableBase();
    logable.setVdsId(cachedVds.getId());
    logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
    auditLogDirector.log(logable, auditLogType);
}
#method_after
private void logChangeStatusToConnecting(long timeoutToFence) {
    String msg;
    AuditLogType auditLogType;
    if (cachedVds.isPmEnabled()) {
        msg = "Host '{}' is not responding. It will stay in Connecting state for a grace period " + "of {} seconds and after that an attempt to fence the host will be issued.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING_CONNECTING;
        log.warn(msg, cachedVds.getName(), TimeUnit.MILLISECONDS.toSeconds(timeoutToFence));
    } else {
        msg = "Host '{}' is not responding.";
        auditLogType = AuditLogType.VDS_HOST_NOT_RESPONDING;
        log.warn(msg, cachedVds.getName());
    }
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
    logable.setVdsId(cachedVds.getId());
    logable.addCustomValue("Seconds", Long.toString(TimeUnit.MILLISECONDS.toSeconds(timeoutToFence)));
    auditLogDirector.log(logable, auditLogType);
}
#end_block

#method_before
private void moveVmsToUnknown() {
    List<VmDynamic> vms = getVmsToMoveToUnknown();
    for (VmDynamic vm : vms) {
        destroyVmOnDestination(vm);
        resourceManager.removeAsyncRunningVm(vm.getId());
    }
    List<Guid> vmIds = vms.stream().map(VmDynamic::getId).collect(Collectors.toList());
    getVmDynamicDao().updateVmsToUnknown(vmIds);
    vmIds.forEach(vmId -> {
        // log VM transition to unknown status
        AuditLogableBase logable = new AuditLogableBase();
        logable.setVmId(vmId);
        auditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    });
}
#method_after
private void moveVmsToUnknown() {
    List<VmDynamic> vms = getVmsToMoveToUnknown();
    for (VmDynamic vm : vms) {
        destroyVmOnDestination(vm);
        resourceManager.removeAsyncRunningVm(vm.getId());
    }
    List<Guid> vmIds = vms.stream().map(VmDynamic::getId).collect(Collectors.toList());
    getVmDynamicDao().updateVmsToUnknown(vmIds);
    vmIds.forEach(vmId -> {
        // log VM transition to unknown status
        AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase());
        logable.setVmId(vmId);
        auditLogDirector.log(logable, AuditLogType.VM_SET_TO_UNKNOWN_STATUS);
    });
}
#end_block

#method_before
protected boolean validateClusterPolicy(Cluster oldCluster) {
    Cluster newCluster = getCluster();
    boolean alreadyInUpgradeMode = oldCluster != null && oldCluster.isInUpgradeMode();
    ClusterPolicy clusterPolicy = getClusterPolicy(newCluster);
    if (clusterPolicy == null) {
        return false;
    }
    newCluster.setClusterPolicyId(clusterPolicy.getId());
    if (alreadyInUpgradeMode && !newCluster.isInUpgradeMode()) {
        // Check if we can safely stop the cluster upgrade
        final List<VDS> hosts = getVdsDao().getAllForCluster(getClusterId());
        if (!validate(getUpgradeValidator().isUpgradeDone(hosts))) {
            return false;
        }
    } else if (!alreadyInUpgradeMode && newCluster.isInUpgradeMode()) {
        final List<VDS> hosts = getVdsDao().getAllForCluster(getClusterId());
        final List<VM> vms = getVmDao().getAllForCluster(getClusterId());
        populateVMNUMAInfo(vms);
        if (!validate(getUpgradeValidator().isUpgradePossible(hosts, vms))) {
            return false;
        }
    }
    Map<String, String> customPropertiesRegexMap = getSchedulingManager().getCustomPropertiesRegexMap(clusterPolicy);
    updateClusterPolicyProperties(getCluster(), clusterPolicy, customPropertiesRegexMap);
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(customPropertiesRegexMap, getCluster().getClusterPolicyProperties());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getValidationMessages());
        return false;
    }
    return true;
}
#method_after
protected boolean validateClusterPolicy(Cluster oldCluster) {
    Cluster newCluster = getCluster();
    boolean alreadyInUpgradeMode = oldCluster != null && oldCluster.isInUpgradeMode();
    ClusterPolicy clusterPolicy = getClusterPolicy(newCluster);
    if (clusterPolicy == null) {
        return false;
    }
    newCluster.setClusterPolicyId(clusterPolicy.getId());
    if (alreadyInUpgradeMode && !newCluster.isInUpgradeMode()) {
        // Check if we can safely stop the cluster upgrade
        final List<VDS> hosts = vdsDao.getAllForCluster(getClusterId());
        if (!validate(getUpgradeValidator().isUpgradeDone(hosts))) {
            return false;
        }
    } else if (!alreadyInUpgradeMode && newCluster.isInUpgradeMode()) {
        final List<VDS> hosts = vdsDao.getAllForCluster(getClusterId());
        final List<VM> vms = vmDao.getAllForCluster(getClusterId());
        populateVMNUMAInfo(vms);
        if (!validate(getUpgradeValidator().isUpgradePossible(hosts, vms))) {
            return false;
        }
    }
    Map<String, String> customPropertiesRegexMap = getSchedulingManager().getCustomPropertiesRegexMap(clusterPolicy);
    updateClusterPolicyProperties(getCluster(), clusterPolicy, customPropertiesRegexMap);
    List<ValidationError> validationErrors = SimpleCustomPropertiesUtil.getInstance().validateProperties(customPropertiesRegexMap, getCluster().getClusterPolicyProperties());
    if (!validationErrors.isEmpty()) {
        SimpleCustomPropertiesUtil.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getValidationMessages());
        return false;
    }
    return true;
}
#end_block

#method_before
private void populateVMNUMAInfo(final List<VM> vms) {
    // Populate numa nodes with a mass update
    final Map<Guid, List<VmNumaNode>> numaNodes = getVmNumaNodeDao().getVmNumaNodeInfoByClusterId(getClusterId());
    for (final VM vm : vms) {
        if (numaNodes.containsKey(vm.getId())) {
            vm.setvNumaNodeList(numaNodes.get(vm.getId()));
        }
    }
}
#method_after
private void populateVMNUMAInfo(final List<VM> vms) {
    // Populate numa nodes with a mass update
    final Map<Guid, List<VmNumaNode>> numaNodes = vmNumaNodeDao.getVmNumaNodeInfoByClusterId(getClusterId());
    for (final VM vm : vms) {
        if (numaNodes.containsKey(vm.getId())) {
            vm.setvNumaNodeList(numaNodes.get(vm.getId()));
        }
    }
}
#end_block

#method_before
protected boolean isClusterUnique(String clusterName) {
    ClusterDao clusterDao = getClusterDao();
    List<Cluster> clusters = clusterDao.getByName(clusterName, true);
    return clusters == null || clusters.isEmpty();
}
#method_after
protected boolean isClusterUnique(String clusterName) {
    List<Cluster> clusters = clusterDao.getByName(clusterName, true);
    return clusters == null || clusters.isEmpty();
}
#end_block

#method_before
protected void alertIfFencingDisabled() {
    if (!getCluster().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = new AuditLogableBase();
        alb.setClusterId(getCluster().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.FENCE_DISABLED_IN_CLUSTER_POLICY);
    }
}
#method_after
protected void alertIfFencingDisabled() {
    if (!getCluster().getFencingPolicy().isFencingEnabled()) {
        AuditLogableBase alb = Injector.injectMembers(new AuditLogableBase());
        alb.setClusterId(getCluster().getId());
        alb.setRepeatable(true);
        auditLogDirector.log(alb, AuditLogType.FENCE_DISABLED_IN_CLUSTER_POLICY);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    vmNumaNodes.stream().forEach(node -> node.setId(Guid.newGuid()));
    getVmNumaNodeDao().massSaveNumaNode(vmNumaNodes, getVm().getId());
    // Used for restful API for reture first NUMA node GUID
    setActionReturnValue(vmNumaNodes.get(0).getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<VmNumaNode> vmNumaNodes = getParameters().getVmNumaNodeList();
    vmNumaNodes.stream().forEach(node -> node.setId(Guid.newGuid()));
    vmNumaNodeDao.massSaveNumaNode(vmNumaNodes, getVm().getId());
    // Used for restful API for reture first NUMA node GUID
    setActionReturnValue(vmNumaNodes.get(0).getId());
    setSucceeded(true);
}
#end_block

#method_before
@Test
public void canSetNumaConfigurationWithVmFromParams() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massSaveNumaNode(eq(newNumaNodes), any(Guid.class));
}
#method_after
@Test
public void canSetNumaConfigurationWithVmFromParams() {
    mockCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massSaveNumaNode(eq(paramNumaNodes), any(Guid.class));
}
#end_block

#method_before
@Test
public void canSetNumaConfigurationWithVmFromDb() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    command.executeCommand();
    verify(vmNumaNodeDao).massSaveNumaNode(eq(newNumaNodes), any(Guid.class));
}
#method_after
@Test
public void canSetNumaConfigurationWithVmFromDb() {
    mockCommandWithVmFromDb();
    command.executeCommand();
    verify(vmNumaNodeDao).massSaveNumaNode(eq(paramNumaNodes), any(Guid.class));
}
#end_block

#method_before
@Test
public void canSetNumaPinning() {
    newNumaNodes = Collections.singletonList(createVmNumaNode(1, vdsNumaNodes));
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massSaveNumaNode(eq(newNumaNodes), any(Guid.class));
}
#method_after
@Test
public void canSetNumaPinning() {
    paramNumaNodes.clear();
    paramNumaNodes.add(createVmNumaNode(1, vdsNumaNodes));
    mockCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massSaveNumaNode(eq(paramNumaNodes), any(Guid.class));
}
#end_block

#method_before
@Test
public void canDetectMissingVM() {
    when(vmDao.get(eq(vm.getId()))).thenReturn(null);
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
}
#method_after
@Test
public void canDetectMissingVM() {
    when(vmDao.get(eq(vm.getId()))).thenReturn(null);
    mockCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
}
#end_block

#method_before
@Test
public void canDetectZeroHostNodesWithVmFromParams() {
    vdsNumaNodes.clear();
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#method_after
@Test
public void canDetectZeroHostNodesWithVmFromParams() {
    vdsNumaNodes.clear();
    mockCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#end_block

#method_before
@Test
public void canDetectMissingRequiredHostNumaNodes() {
    existingNumaNodes.set(0, createVmNumaNode(0, vdsNumaNodes));
    vdsNumaNodes.remove(0);
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_HOST_NODE_INVALID_INDEX);
}
#method_after
@Test
public void canDetectMissingRequiredHostNumaNodes() {
    existingNumaNodes.set(0, createVmNumaNode(0, vdsNumaNodes));
    vdsNumaNodes.remove(0);
    mockCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_HOST_NODE_INVALID_INDEX);
}
#end_block

#method_before
@Test
public void canDetectZeroHostNodesWithVmFromDb() {
    vdsNumaNodes.clear();
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#method_after
@Test
public void canDetectZeroHostNodesWithVmFromDb() {
    vdsNumaNodes.clear();
    mockCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#end_block

#method_before
@Test
public void validateWithPinnedHostOnVm() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    assertThat(command.validate()).isTrue();
}
#method_after
@Test
public void validateWithPinnedHostOnVm() {
    mockCommandWithVmFromDb();
    assertThat(command.validate()).isTrue();
}
#end_block

#method_before
@Test
public void canOnlyDoWithPinnedToHostPolicy() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#method_after
@Test
public void canOnlyDoWithPinnedToHostPolicy() {
    mockCommandWithVmFromDb();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#end_block

#method_before
@Test
public void canNotDoWithoutPinnedHost() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setDedicatedVmForVdsList(new ArrayList<>());
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#method_after
@Test
public void canNotDoWithoutPinnedHost() {
    mockCommandWithVmFromDb();
    vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
    vm.setDedicatedVmForVdsList(new ArrayList<>());
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_PINNED_TO_HOST);
}
#end_block

#method_before
@Test
public void canNotDoWithTwoPinnedHost() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    vm.setDedicatedVmForVdsList(Arrays.asList(Guid.newGuid(), Guid.newGuid()));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_PINNED_TO_MULTIPLE_HOSTS);
}
#method_after
@Test
public void canNotDoWithTwoPinnedHost() {
    mockCommandWithVmFromDb();
    vm.setDedicatedVmForVdsList(Arrays.asList(Guid.newGuid(), Guid.newGuid()));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_PINNED_TO_MULTIPLE_HOSTS);
}
#end_block

#method_before
@Test
public void canCreateAsMuchNumaNodesAsVirtualCores() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(4);
    assertThat(command.validate()).isTrue();
}
#method_after
@Test
public void canCreateAsMuchNumaNodesAsVirtualCores() {
    mockCommandWithVmFromDb();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(4);
    assertThat(command.validate()).isTrue();
}
#end_block

#method_before
@Test
public void canCreateLessNumaNodesAsVirtualCores() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(5);
    assertThat(command.validate()).isTrue();
}
#method_after
@Test
public void canCreateLessNumaNodesAsVirtualCores() {
    mockCommandWithVmFromDb();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(5);
    assertThat(command.validate()).isTrue();
}
#end_block

#method_before
@Test
public void failCreateMoreNumaNodesThanVirtualCoresWithVmFromDb() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(3);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_MORE_NODES_THAN_CPUS);
}
#method_after
@Test
public void failCreateMoreNumaNodesThanVirtualCoresWithVmFromDb() {
    mockCommandWithVmFromDb();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(3);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_MORE_NODES_THAN_CPUS);
}
#end_block

#method_before
@Test
public void failCreateMoreNumaNodesThanVirtualCoresWithVmFromParams() {
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(3);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_MORE_NODES_THAN_CPUS);
}
#method_after
@Test
public void failCreateMoreNumaNodesThanVirtualCoresWithVmFromParams() {
    mockCommandWithVmFromParams();
    vm.setNumOfSockets(1);
    vm.setCpuPerSocket(3);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_MORE_NODES_THAN_CPUS);
}
#end_block

#method_before
@Test
public void canDetectDuplicateNumaNodes() {
    newNumaNodes = Arrays.asList(createVmNumaNode(10), createVmNumaNode(10));
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_INDEX_DUPLICATE);
}
#method_after
@Test
public void canDetectDuplicateNumaNodes() {
    paramNumaNodes.clear();
    paramNumaNodes.addAll(Arrays.asList(createVmNumaNode(10), createVmNumaNode(10)));
    mockCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_INDEX_DUPLICATE);
}
#end_block

#method_before
@Test
public void canDetectNonContinuousNumaNodeIndices() {
    newNumaNodes = Arrays.asList(createVmNumaNode(2), createVmNumaNode(4));
    final AddVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_NON_CONTINUOUS_INDEX);
}
#method_after
@Test
public void canDetectNonContinuousNumaNodeIndices() {
    paramNumaNodes.clear();
    paramNumaNodes.addAll(Arrays.asList(createVmNumaNode(2), createVmNumaNode(4)));
    mockCommandWithVmFromParams();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_NODE_NON_CONTINUOUS_INDEX);
}
#end_block

#method_before
@Test
public void versionDecreaseWithHost() {
    createCommandWithOlderVersion(true, false);
    setupCpu();
    vdsExist();
    validateFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
}
#method_after
@Test
public void versionDecreaseWithHost() {
    createCommandWithOlderVersion();
    setupCpu();
    vdsExist();
    validateFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_CLUSTER_WITH_HOSTS_COMPATIBILITY_VERSION);
}
#end_block

#method_before
@Test
public void versionDecreaseNoHostsOrNetwork() {
    createCommandWithOlderVersion(true, false);
    setupCpu();
    StoragePoolDao storagePoolDao2 = mock(StoragePoolDao.class);
    when(storagePoolDao2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFS());
    doReturn(storagePoolDao2).when(cmd).getStoragePoolDao();
    initAndAssertValidation(true);
}
#method_after
@Test
public void versionDecreaseNoHostsOrNetwork() {
    createCommandWithOlderVersion();
    setupCpu();
    when(storagePoolDao.get(any(Guid.class))).thenReturn(createStoragePoolLocalFS());
    initAndAssertValidation(true);
}
#end_block

#method_before
@Test
public void versionDecreaseLowerVersionThanDC() {
    createCommandWithOlderVersion(true, false);
    StoragePoolDao storagePoolDao2 = mock(StoragePoolDao.class);
    when(storagePoolDao2.get(any(Guid.class))).thenReturn(createStoragePoolLocalFSOldVersion());
    doReturn(storagePoolDao2).when(cmd).getStoragePoolDao();
    doReturn(storagePoolDao2).when(dbFacadeMock).getStoragePoolDao();
    setupCpu();
    validateFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
}
#method_after
@Test
public void versionDecreaseLowerVersionThanDC() {
    createCommandWithOlderVersion();
    when(storagePoolDao.get(any(Guid.class))).thenReturn(createStoragePoolLocalFSOldVersion());
    setupCpu();
    validateFailedWithReason(EngineMessage.ACTION_TYPE_FAILED_CANNOT_DECREASE_COMPATIBILITY_VERSION_UNDER_DC);
}
#end_block

#method_before
@Test
public void vmsAreUpdatedByTheOrderOfTheirIds() {
    createSimpleCommand();
    VmStatic vm1 = new VmStatic();
    vm1.setId(VM_ID1);
    VmStatic vm2 = new VmStatic();
    vm2.setId(VM_ID2);
    VmStatic vm3 = new VmStatic();
    vm3.setId(VM_ID3);
    when(vmStaticDao.getAllByCluster(any())).thenReturn(Arrays.asList(vm1, vm2, vm3));
    // the VMs ordered by Guids: v2, v3, v1
    assertEquals(Arrays.asList(vm2, vm3, vm1), cmd.filterVmsInClusterNeedUpdate());
}
#method_after
@Test
public void vmsAreUpdatedByTheOrderOfTheirIds() {
    final Cluster newerCluster = createDefaultCluster();
    newerCluster.setCompatibilityVersion(new Version(1, 2));
    createCommand(newerCluster);
    cmd.init();
    VmStatic vm1 = new VmStatic();
    vm1.setId(VM_ID1);
    VmStatic vm2 = new VmStatic();
    vm2.setId(VM_ID2);
    VmStatic vm3 = new VmStatic();
    vm3.setId(VM_ID3);
    when(vmStaticDao.getAllByCluster(any())).thenReturn(Arrays.asList(vm1, vm2, vm3));
    // the VMs ordered by Guids: v2, v3, v1
    assertEquals(Arrays.asList(vm2, vm3, vm1), cmd.filterVmsInClusterNeedUpdate());
}
#end_block

#method_before
private void createCommandWithOlderVersion(boolean supportsVirtService, boolean supportsGlusterService) {
    createCommand(createClusterWithOlderVersion(true, false));
}
#method_after
private void createCommandWithOlderVersion() {
    createCommand(createClusterWithOlderVersion(true, false));
}
#end_block

#method_before
private void createCommand(final Cluster group) {
    setValidCpuVersionMap();
    final ManagementNetworkOnClusterOperationParameters param;
    if (managementNetworkId == null) {
        param = new ManagementNetworkOnClusterOperationParameters(group);
    } else {
        param = new ManagementNetworkOnClusterOperationParameters(group, managementNetworkId);
    }
    injectorRule.bind(CpuFlagsManagerHandler.class, cpuFlagsManagerHandler);
    cmd = spy(new UpdateClusterCommand<ManagementNetworkOnClusterOperationParameters>(param, null) {

        @Override
        protected void initUser() {
        // Stub for testing
        }
    });
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(vmStaticDao).when(cmd).getVmStaticDao();
    doReturn(cpuFlagsManagerHandler).when(cmd).getCpuFlagsManagerHandler();
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(cmd).getClusterDao();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(vdsDao).when(cmd).getVdsDao();
    doReturn(storagePoolDao).when(cmd).getStoragePoolDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(glusterVolumeDao).when(cmd).getGlusterVolumeDao();
    doReturn(vmDao).when(cmd).getVmDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(defaultManagementNetworkFinder).when(cmd).getDefaultManagementNetworkFinder();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(schedulingManager).when(cmd).getSchedulingManager();
    doReturn(vmNumaNodeDao).when(cmd).getVmNumaNodeDao();
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterId(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#method_after
private void createCommand(final Cluster group) {
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterId(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#end_block

#method_before
protected MapSqlParameterSource createVnodeToPnodeParametersMapper(Integer pinnedIndex, Guid vNodeId) {
    return getCustomMapSqlParameterSource().addValue("id", Guid.newGuid()).addValue("vm_numa_node_id", vNodeId).addValue("vds_numa_node_index", pinnedIndex);
}
#method_after
private MapSqlParameterSource createVnodeToPnodeParametersMapper(Integer pinnedIndex, Guid vNodeId) {
    return getCustomMapSqlParameterSource().addValue("id", Guid.newGuid()).addValue("vm_numa_node_id", vNodeId).addValue("vds_numa_node_index", pinnedIndex);
}
#end_block

#method_before
@Test
public void canSetNumaConfigurationWithVmFromParams() {
    final SetVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massRemoveNumaNodeByNumaNodeId(eq(existingNumaNodeIds));
    verify(vmNumaNodeDao).massSaveNumaNode(eq(newNumaNodes), any(Guid.class));
}
#method_after
@Test
public void canSetNumaConfigurationWithVmFromParams() {
    mockCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massRemoveNumaNodeByNumaNodeId(eq(existingNumaNodeIds));
    verify(vmNumaNodeDao).massSaveNumaNode(eq(paramNumaNodes), any(Guid.class));
}
#end_block

#method_before
@Test
public void canSetNumaConfigurationWithVmFromDb() {
    final SetVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    command.executeCommand();
    verify(vmNumaNodeDao).massRemoveNumaNodeByNumaNodeId(eq(existingNumaNodeIds));
    verify(vmNumaNodeDao).massSaveNumaNode(eq(newNumaNodes), any(Guid.class));
}
#method_after
@Test
public void canSetNumaConfigurationWithVmFromDb() {
    mockCommandWithVmFromDb();
    command.executeCommand();
    verify(vmNumaNodeDao).massRemoveNumaNodeByNumaNodeId(eq(existingNumaNodeIds));
    verify(vmNumaNodeDao).massSaveNumaNode(eq(paramNumaNodes), any(Guid.class));
}
#end_block

#method_before
@Test
public void canSetNumaPinning() {
    newNumaNodes = Collections.singletonList(createVmNumaNode(1, vdsNumaNodes));
    final SetVmNumaNodesCommand command = mockedCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massRemoveNumaNodeByNumaNodeId(eq(existingNumaNodeIds));
    verify(vmNumaNodeDao).massSaveNumaNode(eq(newNumaNodes), any(Guid.class));
}
#method_after
@Test
public void canSetNumaPinning() {
    paramNumaNodes.clear();
    paramNumaNodes.add(createVmNumaNode(1, vdsNumaNodes));
    mockCommandWithVmFromParams();
    command.executeCommand();
    verify(vmNumaNodeDao).massRemoveNumaNodeByNumaNodeId(eq(existingNumaNodeIds));
    verify(vmNumaNodeDao).massSaveNumaNode(eq(paramNumaNodes), any(Guid.class));
}
#end_block

#method_before
@Test
public void canDetectMissingVM() {
    when(vmDao.get(eq(vm.getId()))).thenReturn(null);
    final SetVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
}
#method_after
@Test
public void canDetectMissingVM() {
    when(vmDao.get(eq(vm.getId()))).thenReturn(null);
    mockCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
}
#end_block

#method_before
@Test
public void shouldRunValidation() {
    vdsNumaNodes.clear();
    final SetVmNumaNodesCommand command = mockedCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#method_after
@Test
public void shouldRunValidation() {
    vdsNumaNodes.clear();
    mockCommandWithVmFromDb();
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.VM_NUMA_PINNED_VDS_NODE_EMPTY);
}
#end_block

#method_before
private List<VDS> uniteAgentsPreserveSpmPrioritySorting(List<VDS> vdsList) {
    List<VDS> results = uniteAgents(vdsList);
    // ensure that list is ordered according to SPM priority DESC
    Collections.sort(results, new HostSpmPriorityComparator());
    return results;
}
#method_after
private List<VDS> uniteAgentsPreserveSpmPrioritySorting(List<VDS> vdsList) {
    List<VDS> results = uniteAgents(vdsList);
    // Ensure that the list is ordered according to SPM priority DESC
    Collections.sort(results, new HostSpmPriorityComparator());
    return results;
}
#end_block

#method_before
protected static QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, boolean shouldPrepareAndTeardown) {
    Guid vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.debug("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#method_after
protected static QemuImageInfo getQemuImageInfoFromVdsm(Guid storagePoolId, Guid newStorageDomainID, Guid newImageGroupId, Guid newImageId, boolean shouldPrepareAndTeardown) {
    Guid vdsId = VdsCommandsHelper.getHostForExecution(storagePoolId, Collections.emptyList());
    QemuImageInfo qemuImageInfo = null;
    if (shouldPrepareAndTeardown) {
        prepareImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
    }
    try {
        qemuImageInfo = (QemuImageInfo) Backend.getInstance().getResourceManager().runVdsCommand(VDSCommandType.GetQemuImageInfo, new GetVolumeInfoVDSCommandParameters(vdsId, storagePoolId, newStorageDomainID, newImageGroupId, newImageId)).getReturnValue();
    } catch (Exception e) {
        log.error("Unable to get qemu image info from storage", e);
    } finally {
        if (shouldPrepareAndTeardown) {
            teardownImage(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, vdsId);
        }
    }
    return qemuImageInfo;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        setStoragePoolId(storagePoolId);
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = getVolumeInfo(storagePoolId, newStorageDomainID, newImageGroupId, newImageId);
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
                if (getStoragePool().getCompatibilityVersion().greaterOrEquals(Version.v4_1) && newImageIRS.getVolumeFormat().equals(VolumeFormat.COW)) {
                    QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, true);
                    if (qemuImageInfo != null) {
                        getDestinationDiskImage().getImage().setQcowCompat(qemuImageInfo.getQcowCompat());
                    }
                }
            }
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            imageDao.update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    if (getDestinationDiskImage() != null) {
        Guid storagePoolId = getDestinationDiskImage().getStoragePoolId() != null ? getDestinationDiskImage().getStoragePoolId() : Guid.Empty;
        setStoragePoolId(storagePoolId);
        Guid newImageGroupId = getDestinationDiskImage().getId() != null ? getDestinationDiskImage().getId() : Guid.Empty;
        Guid newImageId = getDestinationDiskImage().getImageId();
        Guid newStorageDomainID = getDestinationDiskImage().getStorageIds().get(0);
        // complete IRS data to DB disk image:
        try {
            DiskImage newImageIRS = getVolumeInfo(storagePoolId, newStorageDomainID, newImageGroupId, newImageId);
            if (newImageIRS != null) {
                completeImageData(newImageIRS);
                // Set volume type/format before updating DB in the 'finally' branch
                getDestinationDiskImage().getImage().setVolumeType(newImageIRS.getVolumeType());
                getDestinationDiskImage().getImage().setVolumeFormat(newImageIRS.getVolumeFormat());
                if (FeatureSupported.qcowCompatSupported(getStoragePool().getCompatibilityVersion()) && newImageIRS.getVolumeFormat().equals(VolumeFormat.COW)) {
                    QemuImageInfo qemuImageInfo = ImagesHandler.getQemuImageInfoFromVdsm(storagePoolId, newStorageDomainID, newImageGroupId, newImageId, true);
                    if (qemuImageInfo != null) {
                        getDestinationDiskImage().getImage().setQcowCompat(qemuImageInfo.getQcowCompat());
                    }
                }
            }
        } catch (EngineException e) {
            // Logging only
            log.error("Unable to update the image info for image '{}' (image group: '{}') on domain '{}'", newImageId, newImageGroupId, newStorageDomainID);
        } finally {
            if (!getParameters().isLeaveLocked()) {
                getDestinationDiskImage().setImageStatus(ImageStatus.OK);
            }
            imageDao.update(getDestinationDiskImage().getImage());
        }
    }
    if (!getParameters().isLeaveLocked()) {
        unLockImage();
    }
    setSucceeded(true);
}
#end_block

#method_before
public void setQemuVolumeFormat(QemuVolumeFormat volumeFormat) {
    this.qemuVolumeFormat = qemuVolumeFormat;
}
#method_after
public void setQemuVolumeFormat(QemuVolumeFormat qemuVolumeFormat) {
    this.qemuVolumeFormat = qemuVolumeFormat;
}
#end_block

#method_before
public QemuImageInfo buildImageEntity(Map<String, Object> xmlRpcStruct) {
    QemuImageInfo qemuImageInfo = new QemuImageInfo();
    try {
        qemuImageInfo.setImageId(getParameters().getImageId());
        qemuImageInfo.setImageGroupId(getParameters().getImageGroupId());
        qemuImageInfo.setSotrageDomainId(getParameters().getStorageDomainId());
        qemuImageInfo.setSotragePoolId(getParameters().getStoragePoolId());
        if (xmlRpcStruct.containsKey("compat")) {
            qemuImageInfo.setCompat(QcowCompat.forCompatValue(xmlRpcStruct.get("compat").toString()));
        }
        if (xmlRpcStruct.containsKey("format")) {
            qemuImageInfo.setQemuVolumeFormat(EnumUtils.valueOf(QemuVolumeFormat.class, xmlRpcStruct.get("format").toString(), true));
        }
        if (xmlRpcStruct.containsKey("backingfile")) {
            qemuImageInfo.setBackingFile(xmlRpcStruct.get("backingfile").toString());
        }
        if (xmlRpcStruct.containsKey("virtualsize")) {
            qemuImageInfo.setSize(Long.parseLong(xmlRpcStruct.get("virtualsize").toString()));
        }
        if (xmlRpcStruct.containsKey("clustersize")) {
            qemuImageInfo.setClusterSize(Long.parseLong(xmlRpcStruct.get("clustersize").toString()));
        }
    } catch (RuntimeException ex) {
        log.error("Failed building Qemu image: {}", ex.getMessage());
        printReturnValue();
        log.debug("Exception", ex);
        qemuImageInfo = null;
    }
    return qemuImageInfo;
}
#method_after
public QemuImageInfo buildImageEntity(Map<String, Object> xmlRpcStruct) {
    QemuImageInfo qemuImageInfo = new QemuImageInfo();
    try {
        qemuImageInfo.setImageId(getParameters().getImageId());
        qemuImageInfo.setImageGroupId(getParameters().getImageGroupId());
        qemuImageInfo.setStorageDomainId(getParameters().getStorageDomainId());
        qemuImageInfo.setStoragePoolId(getParameters().getStoragePoolId());
        if (xmlRpcStruct.containsKey("compat")) {
            qemuImageInfo.setQcowCompat(QcowCompat.forCompatValue(xmlRpcStruct.get("compat").toString()));
        }
        if (xmlRpcStruct.containsKey("format")) {
            qemuImageInfo.setQemuVolumeFormat(EnumUtils.valueOf(QemuVolumeFormat.class, xmlRpcStruct.get("format").toString(), true));
        }
        if (xmlRpcStruct.containsKey("backingfile")) {
            qemuImageInfo.setBackingFile(xmlRpcStruct.get("backingfile").toString());
        }
        if (xmlRpcStruct.containsKey("virtualsize")) {
            qemuImageInfo.setSize(Long.parseLong(xmlRpcStruct.get("virtualsize").toString()));
        }
        if (xmlRpcStruct.containsKey("clustersize")) {
            qemuImageInfo.setClusterSize(Long.parseLong(xmlRpcStruct.get("clustersize").toString()));
        }
    } catch (RuntimeException ex) {
        log.error("Failed building Qemu image: {}", ex.getMessage());
        printReturnValue();
        log.debug("Exception", ex);
        qemuImageInfo = null;
    }
    return qemuImageInfo;
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    bindPresenterWidget(ManagePolicyUnitPopupPresenterWidget.class, ManagePolicyUnitPopupPresenterWidget.ViewDef.class, ManagePolicyUnitPopupView.class);
    bindPresenterWidget(SharedMacPoolPopupPresenterWidget.class, SharedMacPoolPopupPresenterWidget.ViewDef.class, SharedMacPoolPopupView.class);
    bindPresenterWidget(AffinityGroupPopupPresenterWidget.class, AffinityGroupPopupPresenterWidget.ViewDef.class, AffinityGroupPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabEngineErrataPresenter.class, MainTabEngineErrataPresenter.ViewDef.class, MainTabEngineErrataView.class, MainTabEngineErrataPresenter.ProxyDef.class);
    bindPresenter(MainTabSessionPresenter.class, MainTabSessionPresenter.ViewDef.class, MainTabSessionView.class, MainTabSessionPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(DataCenterQosSubTabPanelPresenter.class, DataCenterQosSubTabPanelPresenter.ViewDef.class, DataCenterQosSubTabPanelView.class, DataCenterQosSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterIscsiBondPresenter.class, SubTabDataCenterIscsiBondPresenter.ViewDef.class, SubTabDataCenterIscsiBondView.class, SubTabDataCenterIscsiBondPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStorageQosPresenter.class, SubTabDataCenterStorageQosPresenter.ViewDef.class, SubTabDataCenterStorageQosView.class, SubTabDataCenterStorageQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterCpuQosPresenter.class, SubTabDataCenterCpuQosPresenter.ViewDef.class, SubTabDataCenterCpuQosView.class, SubTabDataCenterCpuQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterHostNetworkQosPresenter.class, SubTabDataCenterHostNetworkQosPresenter.ViewDef.class, SubTabDataCenterHostNetworkQosView.class, SubTabDataCenterHostNetworkQosPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterVmPresenter.class, SubTabStorageRegisterVmPresenter.ViewDef.class, SubTabStorageRegisterVmView.class, SubTabStorageRegisterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterTemplatePresenter.class, SubTabStorageRegisterTemplatePresenter.ViewDef.class, SubTabStorageRegisterTemplateView.class, SubTabStorageRegisterTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskPresenter.class, SubTabStorageRegisterDiskPresenter.ViewDef.class, SubTabStorageRegisterDiskView.class, SubTabStorageRegisterDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageRegisterDiskImagePresenter.class, SubTabStorageRegisterDiskImagePresenter.ViewDef.class, SubTabStorageRegisterDiskImageView.class, SubTabStorageRegisterDiskImagePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageSnapshotPresenter.class, SubTabStorageSnapshotPresenter.ViewDef.class, SubTabStorageSnapshotView.class, SubTabStorageSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskProfilePresenter.class, SubTabStorageDiskProfilePresenter.ViewDef.class, SubTabStorageDiskProfileView.class, SubTabStorageDiskProfilePresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterAffinityGroupPresenter.class, SubTabClusterAffinityGroupPresenter.ViewDef.class, SubTabClusterAffinityGroupView.class, SubTabClusterAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterCpuProfilePresenter.class, SubTabClusterCpuProfilePresenter.ViewDef.class, SubTabClusterCpuProfileView.class, SubTabClusterCpuProfilePresenter.ProxyDef.class);
    bindPresenterWidget(GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterVolumeSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.class, GlusterClusterSnapshotConfigureOptionsPopupPresenterWidget.ViewDef.class, GlusterClusterSnapshotConfigureOptionsPopupView.class);
    bindPresenterWidget(GlusterVolumeSnapshotCreatePopupPresenterWidget.class, GlusterVolumeSnapshotCreatePopupPresenterWidget.ViewDef.class, GlusterVolumeSnapshotCreatePopupView.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(HostGeneralSubTabPanelPresenter.class, HostGeneralSubTabPanelPresenter.ViewDef.class, HostGeneralSubTabPanelView.class, HostGeneralSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralSoftwarePresenter.class, SubTabHostGeneralSoftwarePresenter.ViewDef.class, SubTabHostGeneralSoftwareView.class, SubTabHostGeneralSoftwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralInfoPresenter.class, SubTabHostGeneralInfoPresenter.ViewDef.class, SubTabHostGeneralInfoView.class, SubTabHostGeneralInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHardwarePresenter.class, SubTabHostGeneralHardwarePresenter.ViewDef.class, SubTabHostGeneralHardwareView.class, SubTabHostGeneralHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralHostErrataPresenter.class, SubTabHostGeneralHostErrataPresenter.ViewDef.class, SubTabHostGeneralHostErrataView.class, SubTabHostGeneralHostErrataPresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostDevicePresenter.class, SubTabHostDevicePresenter.ViewDef.class, SubTabHostDeviceView.class, SubTabHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    bindPresenter(SubTabHostBrickPresenter.class, SubTabHostBrickPresenter.ViewDef.class, SubTabHostBrickView.class, SubTabHostBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterStorageDevicesPresenter.class, SubTabHostGlusterStorageDevicesPresenter.ViewDef.class, SubTabHostGlusterStorageDevicesView.class, SubTabHostGlusterStorageDevicesPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestContainerPresenter.class, SubTabVirtualMachineGuestContainerPresenter.ViewDef.class, SubTabVirtualMachineGuestContainerView.class, SubTabVirtualMachineGuestContainerPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVmDevicePresenter.class, SubTabVirtualMachineVmDevicePresenter.ViewDef.class, SubTabVirtualMachineVmDevicesView.class, SubTabVirtualMachineVmDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineAffinityGroupPresenter.class, SubTabVirtualMachineAffinityGroupPresenter.ViewDef.class, SubTabVirtualMachineAffinityGroupView.class, SubTabVirtualMachineAffinityGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGuestInfoPresenter.class, SubTabVirtualMachineGuestInfoPresenter.ViewDef.class, SubTabVirtualMachineGuestInfoView.class, SubTabVirtualMachineGuestInfoPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineHostDevicePresenter.class, SubTabVirtualMachineHostDevicePresenter.ViewDef.class, SubTabVirtualMachineHostDeviceView.class, SubTabVirtualMachineHostDevicePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineErrataPresenter.class, SubTabVirtualMachineErrataPresenter.ViewDef.class, SubTabVirtualMachineErrataView.class, SubTabVirtualMachineErrataPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkExternalSubnetPresenter.class, SubTabNetworkExternalSubnetPresenter.ViewDef.class, SubTabNetworkExternalSubnetView.class, SubTabNetworkExternalSubnetPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderSecretPresenter.class, SubTabProviderSecretPresenter.ViewDef.class, SubTabProviderSecretView.class, SubTabProviderSecretPresenter.ProxyDef.class);
    // Errata
    bindPresenter(ErrataSubTabPanelPresenter.class, ErrataSubTabPanelPresenter.ViewDef.class, ErrataSubTabPanelView.class, ErrataSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabEngineErrataDetailsPresenter.class, SubTabEngineErrataDetailsPresenter.ViewDef.class, SubTabEngineErrataDetailsView.class, SubTabEngineErrataDetailsPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    bindPresenterWidget(VmNextRunConfigurationPresenterWidget.class, VmNextRunConfigurationPresenterWidget.ViewDef.class, VmNextRunConfigurationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(ClusterWarningsPopupPresenterWidget.class, ClusterWarningsPopupPresenterWidget.ViewDef.class, ClusterWarningsPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.class, GlusterVolumeGeoRepActionConfirmPopUpViewPresenterWidget.ViewDef.class, GeoRepActionConfirmPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.class, GlusterVolumeGeoReplicationSessionConfigPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoReplicationSessionConfigPopupView.class);
    bindPresenterWidget(VolumeGeoRepSessionDetailsPopUpPresenterWidget.class, VolumeGeoRepSessionDetailsPopUpPresenterWidget.ViewDef.class, VolumeGeoRepSessionDetailsPopUpView.class);
    bindPresenterWidget(GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.class, GlusterVolumeGeoRepCreateSessionPopupPresenterWidget.ViewDef.class, GlusterVolumeGeoRepCreateSessionPopupView.class);
    bindPresenterWidget(RemoveBrickStatusPopupPresenterWidget.class, RemoveBrickStatusPopupPresenterWidget.ViewDef.class, RemoveBrickStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    bindPresenterWidget(VolumeProfileStatisticsPopupPresenterWidget.class, VolumeProfileStatisticsPopupPresenterWidget.ViewDef.class, VolumeProfileStatisticsPopupView.class);
    bindPresenterWidget(AddDataCenterClusterPopupPresenterWidget.class, AddDataCenterClusterPopupPresenterWidget.ViewDef.class, AddDataCenterClusterPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(NetworkAttachmentPopupPresenterWidget.class, NetworkAttachmentPopupPresenterWidget.ViewDef.class, NetworkAttachmentPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(VfsConfigPopupPresenterWidget.class, VfsConfigPopupPresenterWidget.ViewDef.class, VfsConfigPopupView.class);
    bindPresenterWidget(SetupNetworksLabelPopupPresenterWidget.class, SetupNetworksLabelPopupPresenterWidget.ViewDef.class, SetupNetworksLabelPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    bindPresenterWidget(HostFenceAgentPopupPresenterWidget.class, HostFenceAgentPopupPresenterWidget.ViewDef.class, HostFenceAgentPopupView.class);
    bindPresenterWidget(HostFenceProxyPopupPresenterWidget.class, HostFenceProxyPopupPresenterWidget.ViewDef.class, HostFenceProxyPopupView.class);
    bindPresenterWidget(HostMaintenanceConfirmationPopupPresenterWidget.class, HostMaintenanceConfirmationPopupPresenterWidget.ViewDef.class, HostMaintenanceConfirmationPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmFromExportDomainPopupPresenterWidget.class, ImportVmFromExportDomainPopupPresenterWidget.ViewDef.class, ImportVmFromExportDomainPopupView.class);
    bindPresenterWidget(ImportVmFromExternalProviderPopupPresenterWidget.class, ImportVmFromExternalProviderPopupPresenterWidget.ViewDef.class, ImportVmFromExternalProviderPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(RegisterVmPopupPresenterWidget.class, RegisterVmPopupPresenterWidget.ViewDef.class, RegisterVmPopupView.class);
    bindPresenterWidget(RegisterTemplatePopupPresenterWidget.class, RegisterTemplatePopupPresenterWidget.ViewDef.class, RegisterTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    bindPresenterWidget(UploadImagePopupPresenterWidget.class, UploadImagePopupPresenterWidget.ViewDef.class, UploadImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    bindPresenterWidget(VmSnapshotCustomPreviewPopupPresenterWidget.class, VmSnapshotCustomPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotCustomPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // Clone VM
    bindPresenterWidget(CloneVmPopupPresenterWidget.class, CloneVmPopupPresenterWidget.ViewDef.class, CloneVmPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Attach Disk
    bindPresenterWidget(VmDiskAttachPopupPresenterWidget.class, VmDiskAttachPopupPresenterWidget.ViewDef.class, VmDiskAttachPopupView.class);
    bindPresenterWidget(SingleSelectionVmDiskAttachPopupPresenterWidget.class, SingleSelectionVmDiskAttachPopupPresenterWidget.ViewDef.class, SingleSelectionVmDiskAttachPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // VM Sparsify Disk
    bindPresenterWidget(VmDiskSparsifyPopupPresenterWidget.class, VmDiskSparsifyPopupPresenterWidget.ViewDef.class, VmDiskSparsifyPopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateEditPresenterWidget.class, TemplateEditPresenterWidget.ViewDef.class, TemplateEditPopupView.class);
    // Instance Types
    bindPresenterWidget(InstanceTypesPopupPresenterWidget.class, InstanceTypesPopupPresenterWidget.ViewDef.class, InstanceTypesPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    // Storage QoS
    bindPresenterWidget(StorageQosPopupPresenterWidget.class, StorageQosPopupPresenterWidget.ViewDef.class, StorageQosPopupView.class);
    bindPresenterWidget(StorageQosRemovePopupPresenterWidget.class, StorageQosRemovePopupPresenterWidget.ViewDef.class, StorageQosRemovePopupView.class);
    // Cpu QoS
    bindPresenterWidget(CpuQosPopupPresenterWidget.class, CpuQosPopupPresenterWidget.ViewDef.class, CpuQosPopupView.class);
    // Host Network QoS
    bindPresenterWidget(HostNetworkQosPopupPresenterWidget.class, HostNetworkQosPopupPresenterWidget.ViewDef.class, HostNetworkQosPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    bindPresenterWidget(ImportVmsPopupPresenterWidget.class, ImportVmsPopupPresenterWidget.ViewDef.class, ImportVmsPopupView.class);
    // Host Devices
    bindPresenterWidget(AddVmHostDevicePopupPresenterWidget.class, AddVmHostDevicePopupPresenterWidget.ViewDef.class, AddVmHostDevicePopupView.class);
    bindPresenterWidget(VmRepinHostPopupPresenterWidget.class, VmRepinHostPopupPresenterWidget.ViewDef.class, VmRepinHostPopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeoRepPresenter.class, SubTabVolumeGeoRepPresenter.ViewDef.class, SubTabVolumeGeoRepView.class, SubTabVolumeGeoRepPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenter(SubTabGlusterVolumeSnapshotPresenter.class, SubTabGlusterVolumeSnapshotPresenter.ViewDef.class, SubTabGlusterVolumeSnapshotView.class, SubTabGlusterVolumeSnapshotPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(CreateBrickPopupPresenterWidget.class, CreateBrickPopupPresenterWidget.ViewDef.class, CreateBrickPopupView.class);
    bindPresenterWidget(RemoveBrickPopupPresenterWidget.class, RemoveBrickPopupPresenterWidget.ViewDef.class, RemoveBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    bindPresenterWidget(ProviderSecretPopupPresenterWidget.class, ProviderSecretPopupPresenterWidget.ViewDef.class, ProviderSecretPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
    bindPresenterWidget(DiskProfilePopupPresenterWidget.class, DiskProfilePopupPresenterWidget.ViewDef.class, DiskProfilePopupView.class);
    bindPresenterWidget(CpuProfilePopupPresenterWidget.class, CpuProfilePopupPresenterWidget.ViewDef.class, CpuProfilePopupView.class);
    // External Subnet
    bindPresenterWidget(ExternalSubnetPopupPresenterWidget.class, ExternalSubnetPopupPresenterWidget.ViewDef.class, ExternalSubnetPopupView.class);
    // ISCSI Bond
    bindPresenterWidget(IscsiBondPopupPresenterWidget.class, IscsiBondPopupPresenterWidget.ViewDef.class, IscsiBondPopupView.class);
    // Errata details
    bindPresenterWidget(HostErrataListWithDetailsPopupPresenterWidget.class, HostErrataListWithDetailsPopupPresenterWidget.ViewDef.class, HostErrataListWithDetailsPopupView.class);
    bindPresenterWidget(VmErrataListWithDetailsPopupPresenterWidget.class, VmErrataListWithDetailsPopupPresenterWidget.ViewDef.class, VmErrataListWithDetailsPopupView.class);
}
#end_block

#method_before
private void move() {
    ArrayList<DiskImage> disks = (ArrayList) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    VM vm = getEntity();
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    if (vm.isRunningAndQualifyForDisksMigration()) {
        model.setWarningAvailable(true);
        model.setMessage(ConstantsManager.getInstance().getConstants().liveStorageMigrationWarning());
    }
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disk);
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress();
}
#method_after
private void move() {
    ArrayList<DiskImage> disks = (ArrayList) getSelectedItems();
    if (disks == null) {
        return;
    }
    if (getWindow() != null) {
        return;
    }
    MoveDiskModel model = new MoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().moveDisksTitle());
    model.setHelpTag(HelpTag.move_disk);
    // $NON-NLS-1$
    model.setHashName("move_disk");
    model.setIsSourceStorageDomainNameAvailable(true);
    model.setEntity(this);
    model.init(disks);
    model.startProgress();
}
#end_block

#method_before
private boolean isSparsifyCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (isDiskLocked(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isSparsifyCommandAvailable() {
    List<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (isDiskLocked(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
public void initialize(VM vm, List<Disk> disksToSparsify, ICommandTarget target) {
    this.disksToSparsify = disksToSparsify;
    UIConstants uiConstants = ConstantsManager.getInstance().getConstants();
    setTitle(uiConstants.sparsifyDisksTitle());
    setMessage(uiConstants.sparsifyConfirmationPopupMessage());
    setHelpTag(HelpTag.sparsify_disk);
    // $NON-NLS-1$
    setHashName("sparsify_disk");
    getLatch().setEntity(false);
    List<DiskModel> items = new ArrayList<>();
    for (Disk disk : disksToSparsify) {
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(vm);
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            getLatch().setIsChangeable(false);
        }
    }
    setItems(items);
    UICommand okCommand = UICommand.createDefaultOkUiCommand(ON_SPARSIFY, target);
    getCommands().add(okCommand);
    cancelCommand = UICommand.createCancelUiCommand(CANCEL_SPARSIFY, target);
    getCommands().add(cancelCommand);
}
#method_after
public void initialize(VM vm, List<Disk> disksToSparsify, ICommandTarget target) {
    this.disksToSparsify = disksToSparsify;
    UIConstants uiConstants = ConstantsManager.getInstance().getConstants();
    setTitle(uiConstants.sparsifyDisksTitle());
    setMessage(uiConstants.sparsifyConfirmationPopupMessage());
    setHelpTag(HelpTag.sparsify_disk);
    // $NON-NLS-1$
    setHashName("sparsify_disk");
    List<DiskModel> items = new ArrayList<>();
    for (Disk disk : disksToSparsify) {
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(vm);
        items.add(diskModel);
    }
    setItems(items);
    UICommand okCommand = UICommand.createDefaultOkUiCommand(ON_SPARSIFY, target);
    getCommands().add(okCommand);
    cancelCommand = UICommand.createCancelUiCommand(CANCEL_SPARSIFY, target);
    getCommands().add(cancelCommand);
}
#end_block

#method_before
public void onSparsify(final ICommandTarget target) {
    List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (Disk disk : disksToSparsify) {
        VdcActionParametersBase parameters = new ImagesActionsParametersBase(disk.getId());
        parameterList.add(parameters);
    }
    startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.SparsifyImage, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            stopProgress();
            target.executeCommand(cancelCommand);
        }
    }, this);
}
#method_after
public void onSparsify(final ICommandTarget target) {
    List<VdcActionParametersBase> parameterList = new ArrayList<>();
    for (Disk disk : disksToSparsify) {
        VdcActionParametersBase parameters = new StorageJobCommandParameters(((DiskImage) disk).getImageId());
        parameterList.add(parameters);
    }
    startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.SparsifyImage, parameterList, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            stopProgress();
            target.executeCommand(cancelCommand);
        }
    }, this);
}
#end_block

#method_before
public void handleUrandomRandomChange(Version oldClusterVersion, Version newClusterVersion, Guid vmBaseId, CommandContext commandContext, boolean isVm) {
    if (oldClusterVersion == null) {
        return;
    }
    final boolean updatePotentiallyRequired = VmRngDevice.Source.urandomRandomUpdateRequired(oldClusterVersion, newClusterVersion);
    if (!updatePotentiallyRequired) {
        return;
    }
    final List<VmRngDevice> rngDevices = backend.runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBaseId), commandContext.getEngineContext()).getReturnValue();
    if (rngDevices.isEmpty()) {
        return;
    }
    final VmRngDevice rngDevice = rngDevices.get(0);
    if (!Arrays.asList(VmRngDevice.Source.RANDOM, VmRngDevice.Source.URANDOM).contains(rngDevice.getSource())) {
        return;
    }
    rngDevice.setSource(VmRngDevice.Source.getUrandomOrRandomFor(newClusterVersion));
    final RngDeviceParameters params = new RngDeviceParameters(rngDevice, isVm);
    backend.runInternalAction(VdcActionType.UpdateRngDevice, params, commandContext);
}
#method_after
public void handleUrandomRandomChange(Version oldClusterVersion, Version newClusterVersion, Guid vmBaseId, CommandContext commandContext, boolean isVm) {
    if (oldClusterVersion == null) {
        return;
    }
    final boolean updatePotentiallyRequired = VmRngDevice.Source.urandomRandomUpdateRequired(oldClusterVersion, newClusterVersion);
    if (!updatePotentiallyRequired) {
        return;
    }
    final List<VmRngDevice> rngDevices = backend.runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(vmBaseId), commandContext.getEngineContext()).getReturnValue();
    if (rngDevices.isEmpty()) {
        return;
    }
    final VmRngDevice rngDevice = rngDevices.get(0);
    final VmRngDevice.Source oldSource = rngDevice.getSource();
    rngDevice.updateSourceByVersion(newClusterVersion);
    if (rngDevice.getSource().equals(oldSource)) {
        return;
    }
    final RngDeviceParameters params = new RngDeviceParameters(rngDevice, isVm);
    backend.runInternalAction(VdcActionType.UpdateRngDevice, params, commandContext);
}
#end_block

#method_before
@Override
protected void init() {
    updateMigrateOnError();
    oldCluster = clusterDao.get(getCluster().getId());
    if (oldCluster != null) {
        vmsLockedForUpdate = filterVmsInClusterNeedUpdate();
        templatesLockedForUpdate = filterTemplatesInClusterNeedUpdate();
    }
}
#method_after
@Override
protected void init() {
    updateMigrateOnError();
    oldCluster = clusterDao.get(getCluster().getId());
    if (oldCluster != null && !Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        vmsLockedForUpdate = filterVmsInClusterNeedUpdate();
        templatesLockedForUpdate = filterTemplatesInClusterNeedUpdate();
    }
}
#end_block

#method_before
protected List<VmStatic> filterVmsInClusterNeedUpdate() {
    if (Objects.equals(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        return Collections.emptyList();
    }
    final boolean rngUpdateRequired = VmRngDevice.Source.urandomRandomUpdateRequired(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion());
    return vmStaticDao.getAllByCluster(getCluster().getId()).stream().filter(vm -> vm.getOrigin() != OriginType.EXTERNAL && !vm.isHostedEngine()).filter(vm -> vm.getCustomCompatibilityVersion() == null || rngUpdateRequired).sorted().collect(Collectors.toList());
}
#method_after
protected List<VmStatic> filterVmsInClusterNeedUpdate() {
    return vmStaticDao.getAllByCluster(getCluster().getId()).stream().filter(vm -> vm.getOrigin() != OriginType.EXTERNAL && !vm.isHostedEngine()).filter(vm -> vm.getCustomCompatibilityVersion() == null).sorted().collect(Collectors.toList());
}
#end_block

#method_before
protected List<VmTemplate> filterTemplatesInClusterNeedUpdate() {
    if (!VmRngDevice.Source.urandomRandomUpdateRequired(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        return Collections.emptyList();
    }
    return vmTemplateDao.getAllForCluster(getCluster().getId()).stream().sorted().collect(Collectors.toList());
}
#method_after
protected List<VmTemplate> filterTemplatesInClusterNeedUpdate() {
    if (!VmRngDevice.Source.urandomRandomUpdateRequired(oldCluster.getCompatibilityVersion(), getCluster().getCompatibilityVersion())) {
        return Collections.emptyList();
    }
    return vmTemplateDao.getAllForCluster(getCluster().getId()).stream().filter(template -> template.getCustomCompatibilityVersion() == null).sorted().collect(Collectors.toList());
}
#end_block

#method_before
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateVms() {
    for (VmStatic vm : vmsLockedForUpdate) {
        VmManagementParametersBase updateParams = new VmManagementParametersBase(vm);
        /*
            Locking by UpdateVmCommand is disabled since VMs are already locked in #getExclusiveLocks method.
            This logic relies on assumption that UpdateVmCommand locks exactly only updated VM.
             */
        updateParams.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        updateParams.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        upgradeGraphicsDevices(vm, updateParams);
        VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, updateParams, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            propagateFailure(result);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        final UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since VMs are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        final VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            getReturnValue().setFault(result.getFault());
            return false;
        }
    }
    return true;
}
#method_after
private boolean updateTemplates() {
    for (VmTemplate template : templatesLockedForUpdate) {
        // the object was loaded in before command execution started and thus the value may be outdated
        template.setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        final UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
        // Locking by UpdateVmTemplate is disabled since templates are already locked in #getExclusiveLocks method.
        parameters.setLockProperties(LockProperties.create(LockProperties.Scope.None));
        parameters.setClusterLevelChangeFromVersion(oldCluster.getCompatibilityVersion());
        final VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVmTemplate, parameters, cloneContextAndDetachFromParent());
        if (!result.getSucceeded()) {
            propagateFailure(result);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void addOrUpdateAddtionalClusterFeatures() {
    Set<SupportedAdditionalClusterFeature> featuresInDb = getClusterFeatureDao().getSupportedFeaturesByClusterId(getCluster().getId());
    Map<Guid, SupportedAdditionalClusterFeature> featuresEnabled = new HashMap<>();
    for (SupportedAdditionalClusterFeature feature : getCluster().getAddtionalFeaturesSupported()) {
        featuresEnabled.put(feature.getFeature().getId(), feature);
    }
    for (SupportedAdditionalClusterFeature featureInDb : featuresInDb) {
        if (featureInDb.isEnabled() && !featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Disable the features which are not selected in update cluster
            featureInDb.setEnabled(false);
            getClusterFeatureDao().updateSupportedClusterFeature(featureInDb);
        } else if (!featureInDb.isEnabled() && featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Enable the features which are selected in update cluster
            featureInDb.setEnabled(true);
            getClusterFeatureDao().updateSupportedClusterFeature(featureInDb);
        }
        featuresEnabled.remove(featureInDb.getFeature().getId());
    }
    // Add the newly add cluster features
    if (CollectionUtils.isNotEmpty(featuresEnabled.values())) {
        getClusterFeatureDao().addAllSupportedClusterFeature(featuresEnabled.values());
    }
}
#method_after
private void addOrUpdateAddtionalClusterFeatures() {
    Set<SupportedAdditionalClusterFeature> featuresInDb = clusterFeatureDao.getSupportedFeaturesByClusterId(getCluster().getId());
    Map<Guid, SupportedAdditionalClusterFeature> featuresEnabled = new HashMap<>();
    for (SupportedAdditionalClusterFeature feature : getCluster().getAddtionalFeaturesSupported()) {
        featuresEnabled.put(feature.getFeature().getId(), feature);
    }
    for (SupportedAdditionalClusterFeature featureInDb : featuresInDb) {
        if (featureInDb.isEnabled() && !featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Disable the features which are not selected in update cluster
            featureInDb.setEnabled(false);
            clusterFeatureDao.updateSupportedClusterFeature(featureInDb);
        } else if (!featureInDb.isEnabled() && featuresEnabled.containsKey(featureInDb.getFeature().getId())) {
            // Enable the features which are selected in update cluster
            featureInDb.setEnabled(true);
            clusterFeatureDao.updateSupportedClusterFeature(featureInDb);
        }
        featuresEnabled.remove(featureInDb.getFeature().getId());
    }
    // Add the newly add cluster features
    if (CollectionUtils.isNotEmpty(featuresEnabled.values())) {
        clusterFeatureDao.addAllSupportedClusterFeature(featuresEnabled.values());
    }
}
#end_block

#method_before
private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() {
    // Lets not modify the existing collection. Hence creating a new hashset.
    Set<SupportedAdditionalClusterFeature> featuresSupported = new HashSet<>(getCluster().getAddtionalFeaturesSupported());
    featuresSupported.removeAll(getClusterFeatureDao().getSupportedFeaturesByClusterId(getCluster().getId()));
    return featuresSupported;
}
#method_after
private Set<SupportedAdditionalClusterFeature> getAdditionalClusterFeaturesAdded() {
    // Lets not modify the existing collection. Hence creating a new hashset.
    Set<SupportedAdditionalClusterFeature> featuresSupported = new HashSet<>(getCluster().getAddtionalFeaturesSupported());
    featuresSupported.removeAll(clusterFeatureDao.getSupportedFeaturesByClusterId(getCluster().getId()));
    return featuresSupported;
}
#end_block

#method_before
private boolean checkClusterFeaturesSupported(List<VDS> vdss, Set<SupportedAdditionalClusterFeature> newFeaturesEnabled) {
    Set<String> featuresNamesEnabled = new HashSet<>();
    for (SupportedAdditionalClusterFeature feature : newFeaturesEnabled) {
        featuresNamesEnabled.add(feature.getFeature().getName());
    }
    for (VDS vds : vdss) {
        Set<String> featuresSupportedByVds = getHostFeatureDao().getSupportedHostFeaturesByHostId(vds.getId());
        if (!featuresSupportedByVds.containsAll(featuresNamesEnabled)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean checkClusterFeaturesSupported(List<VDS> vdss, Set<SupportedAdditionalClusterFeature> newFeaturesEnabled) {
    Set<String> featuresNamesEnabled = new HashSet<>();
    for (SupportedAdditionalClusterFeature feature : newFeaturesEnabled) {
        featuresNamesEnabled.add(feature.getFeature().getName());
    }
    for (VDS vds : vdss) {
        Set<String> featuresSupportedByVds = hostFeatureDao.getSupportedHostFeaturesByHostId(vds.getId());
        if (!featuresSupportedByVds.containsAll(featuresNamesEnabled)) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE && !isBlankTemplate()) {
        if (!validate(getVirtioRngValidator().canAddRngDevice(getCluster(), getParameters().getRngDevice()))) {
            return false;
        }
    }
    if (!getRngDevices().isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE && !isBlankTemplate()) {
        if (!validate(getVirtioRngValidator().canAddRngDevice(getCluster(), getParameters().getRngDevice(), getCachedEntity().getCustomCompatibilityVersion()))) {
            return false;
        }
    }
    if (!getRngDevices().isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_ALREADY_EXISTS);
    }
    return true;
}
#end_block

#method_before
private boolean updateRngDevice() {
    // if rng is not updated, check random <-> urandom change
    if (!getParameters().isUpdateRngDevice()) {
        rngDeviceUtils.handleUrandomRandomChange(getParameters().getClusterLevelChangeFromVersion(), getCluster().getCompatibilityVersion(), getVmId(), cloneContextAndDetachFromParent(), true);
        return true;
    }
    VdcQueryReturnValue query = runInternalQuery(VdcQueryType.GetRngDevice, new IdQueryParameters(getParameters().getVmId()));
    List<VmRngDevice> rngDevs = query.getReturnValue();
    VdcReturnValueBase rngCommandResult = null;
    if (rngDevs.isEmpty()) {
        if (getParameters().getRngDevice() != null) {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            rngCommandResult = runInternalAction(VdcActionType.AddRngDevice, params, cloneContextAndDetachFromParent());
        }
    } else {
        if (getParameters().getRngDevice() == null) {
            RngDeviceParameters params = new RngDeviceParameters(rngDevs.get(0), true);
            rngCommandResult = runInternalAction(VdcActionType.RemoveRngDevice, params, cloneContextAndDetachFromParent());
        } else {
            RngDeviceParameters params = new RngDeviceParameters(getParameters().getRngDevice(), true);
            params.getRngDevice().setDeviceId(rngDevs.get(0).getDeviceId());
            rngCommandResult = runInternalAction(VdcActionType.UpdateRngDevice, params, cloneContextAndDetachFromParent());
        }
    }
    if (rngCommandResult != null && !rngCommandResult.getSucceeded()) {
        return false;
    }
    return true;
}
#method_after
private boolean updateRngDevice() {
    if (getParameters().isUpdateRngDevice()) {
        return changeRngDevice();
    }
    // if rng is not updated, check random <-> urandom change
    rngDeviceUtils.handleUrandomRandomChange(getParameters().getClusterLevelChangeFromVersion(), getEffectiveCompatibilityVersion(), getVmId(), cloneContextAndDetachFromParent(), true);
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    // check if VM was changed to use latest
    if (vmFromDB.isUseLatestVersion() != vmFromParams.isUseLatestVersion() && vmFromParams.isUseLatestVersion()) {
        // check if a version change is actually required or just let the local command to update this field
        vmFromParams.setVmtGuid(vmTemplateDao.getTemplateWithLatestVersionInChain(getVm().getVmtGuid()).getId());
    }
    // It is not allowed to edit hosted engine VM until it is imported to the engine properly
    if (vmFromDB.isHostedEngine() && !vmFromDB.isManagedHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_UNMANAGED_HOSTED_ENGINE);
    }
    // pool VMs are allowed to change template id, this verifies that the change is only between template versions.
    if (!vmFromDB.getVmtGuid().equals(vmFromParams.getVmtGuid())) {
        VmTemplate origTemplate = vmTemplateDao.get(vmFromDB.getVmtGuid());
        VmTemplate newTemplate = vmTemplateDao.get(vmFromParams.getVmtGuid());
        if (newTemplate == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        } else if (origTemplate != null && !origTemplate.getBaseTemplateId().equals(newTemplate.getBaseTemplateId())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_IS_ON_DIFFERENT_CHAIN);
        } else if (vmFromDB.getVmPoolId() != null) {
            isUpdateVmTemplateVersion = true;
            // no more tests are needed because no more changes are allowed in this state
            return true;
        } else {
            // template id can be changed for pool VMs only
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_ID_CANT_BE_CHANGED);
        }
    }
    if (getCluster() == null) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (vmFromDB.getClusterId() == null) {
        failValidation(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    if (!isVmExist()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName(), getStoragePoolId());
        if (exists) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    if (!validateCustomProperties(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getCluster().getArchitecture(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!VmHandler.isCpuSupported(vmFromParams.getVmOsId(), getEffectiveCompatibilityVersion(), getCluster().getCpuName(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (vmFromParams.isAutoStartup() && vmFromDB.isHostedEngine()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_HOSTED_ENGINE);
    }
    if (!areUpdatedFieldsLegal()) {
        return failValidation(vmFromDB.isHostedEngine() ? EngineMessage.VM_CANNOT_UPDATE_HOSTED_ENGINE_FIELD : EngineMessage.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getClusterId().equals(vmFromParams.getClusterId())) {
        return failValidation(EngineMessage.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsExistOnSameCluster(vmFromParams.getStaticData(), getReturnValue().getValidationMessages())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), getParameters().getVmStaticData().getNumOfMonitors(), getReturnValue().getValidationMessages())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_ILLEGAL_NUM_OF_MONITORS);
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmHandler.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (!validate(VmValidator.validateCpuSockets(vmFromParams.getStaticData(), getEffectiveCompatibilityVersion().toString()))) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(new String(BASE_64.encode(entry.getValue().getBytes()), Charset.forName(CharEncoding.UTF_8)));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate(new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getEffectiveCompatibilityVersion()).isValid())) {
            return false;
        }
    }
    // Check if the graphics and display from parameters are supported
    if (!VmHandler.isGraphicsAndDisplaySupported(vmFromParams.getOs(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmId()), getParameters().getGraphicsDevices()), vmFromParams.getDefaultDisplayType(), getReturnValue().getValidationMessages(), getEffectiveCompatibilityVersion())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getEffectiveCompatibilityVersion()) && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_MIGRATION_IS_NOT_SUPPORTED);
    }
    // check cpuPinning
    if (!validate(isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData()))) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getValidationMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failValidation(EngineMessage.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (vmFromParams.isUseHostCpuFlags() && (ArchitectureType.ppc == getCluster().getArchitecture().getFamily())) {
        return failValidation(EngineMessage.USE_HOST_CPU_REQUESTED_ON_UNSUPPORTED_ARCH);
    }
    if (!validateCPUHotplug(getParameters().getVmStaticData())) {
        return failValidation(EngineMessage.CPU_HOTPLUG_TOPOLOGY_INVALID);
    }
    if (!validateMemoryAlignment(getParameters().getVmStaticData())) {
        return false;
    }
    if (isVirtioScsiEnabled()) {
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getEffectiveCompatibilityVersion(), getReturnValue().getValidationMessages())) {
            return false;
        }
    }
    VmValidator vmValidator = createVmValidator(vmFromParams);
    // A pinned VM, must run on one of its hosts
    if (!validate(vmValidator.isPinnedVmRunningOnDedicatedHost(vmFromDB, vmFromParams.getStaticData()))) {
        return false;
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled()) && !validate(vmValidator.canDisableVirtioScsi(null))) {
        return false;
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (vmFromParams.getCpuProfileId() == null || !Objects.equals(vmFromDB.getCpuProfileId(), vmFromParams.getCpuProfileId())) {
        if (!setAndValidateCpuProfile()) {
            return false;
        }
    }
    if (isBalloonEnabled() && !osRepository.isBalloonEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (isSoundDeviceEnabled() && !osRepository.isSoundDeviceEnabled(getParameters().getVmStaticData().getOsId(), getEffectiveCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    if (!validate(getNumaValidator().checkVmNumaNodesIntegrity(getParameters().getVm(), getParameters().getVm().getvNumaNodeList()))) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmStaticData() != null && getParameters().getVmStaticData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmStaticData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (vmFromParams.getProviderId() != null) {
        Provider<?> provider = providerDao.get(vmFromParams.getProviderId());
        if (provider == null) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_PROVIDER_DOESNT_EXIST);
        }
        if (provider.getType() != ProviderType.FOREMAN) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_HOST_PROVIDER_TYPE_MISMATCH);
        }
    }
    if (getCluster().isInUpgradeMode()) {
        getParameters().getVm().setClusterCompatibilityVersion(getCluster().getCompatibilityVersion());
        if (!validate(getClusterUpgradeValidator().isVmReadyForUpgrade(getParameters().getVm()))) {
            return false;
        }
    }
    if (!validateQuota(getParameters().getVmStaticData().getQuotaId())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(oldTemplate);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemlateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getValidationMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#method_after
@Override
protected boolean validate() {
    boolean isInstanceType = isInstanceType();
    boolean isBlankTemplate = isBlankTemplate();
    if (getCluster() == null && !(isInstanceType || isBlankTemplate)) {
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_CLUSTER_CAN_NOT_BE_EMPTY);
        return false;
    }
    boolean returnValue = false;
    if (oldTemplate == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (!isInstanceType && !isBlankTemplate) {
        VmTemplateHandler.updateDisksFromDb(oldTemplate);
    }
    if (!StringUtils.equals(oldTemplate.getName(), getVmTemplate().getName())) {
        if (!getVmTemplate().isBaseTemplate()) {
            // template version should always have the name of the base template
            return failValidation(EngineMessage.VMT_CANNOT_UPDATE_VERSION_NAME);
        } else {
            // must be unique also across datacenters.
            if (isInstanceType) {
                if (isInstanceWithSameNameExists(getVmTemplateName())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            } else {
                if (isVmTemplateWithSameNameExist(getVmTemplateName(), isBlankTemplate ? null : getCluster().getStoragePoolId())) {
                    return failValidation(EngineMessage.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
                }
            }
        }
    }
    if (VmHandler.isVmPriorityValueLegal(getParameters().getVmTemplateData().getPriority(), getReturnValue().getValidationMessages()) && checkDomain()) {
        returnValue = VmTemplateHandler.isUpdateValid(oldTemplate, getVmTemplate());
        if (!returnValue) {
            addValidationMessage(EngineMessage.VMT_CANNOT_UPDATE_ILLEGAL_FIELD);
        }
    }
    if (!setAndValidateCpuProfile()) {
        return false;
    }
    if (getParameters().getVmLargeIcon() != null && !validate(IconValidator.validate(IconValidator.DimensionsType.LARGE_CUSTOM_ICON, getParameters().getVmLargeIcon()))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getSmallIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getSmallIconId(), "Small"))) {
        return false;
    }
    if (getParameters().getVmTemplateData() != null && getParameters().getVmTemplateData().getLargeIconId() != null && // icon id is ignored if large icon is sent
    getParameters().getVmLargeIcon() == null && !validate(IconValidator.validateIconId(getParameters().getVmTemplateData().getLargeIconId(), "Large"))) {
        return false;
    }
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterIndependentValidator(getParameters().getWatchdog()).isValid());
    }
    if (!isInstanceType && !isBlankTemplate && returnValue) {
        return doClusterRelatedChecks();
    } else {
        return returnValue;
    }
}
#end_block

#method_before
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check that the USB policy is legal
    boolean returnValue = VmHandler.isUsbPolicyLegal(getParameters().getVmTemplateData().getUsbPolicy(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages());
    // Check if the OS type is supported
    if (returnValue) {
        returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    }
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = validate(VmValidator.validateCpuSockets(getParameters().getVmTemplateData(), getVmTemplate().getCompatibilityVersion().toString()));
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = vmNicDao.getAllForTemplate(getParameters().getVmTemplateData().getId());
        List<DiskVmElement> diskVmElements = diskVmElementDao.getAllForVm(getVmTemplateId());
        if (!validate(VmValidator.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getVmDeviceUtils().hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled()))) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#method_after
private boolean doClusterRelatedChecks() {
    if (oldTemplate.getStatus() == VmTemplateStatus.Locked) {
        return failValidation(EngineMessage.VM_TEMPLATE_IS_LOCKED);
    }
    // Check if the OS type is supported
    boolean returnValue = VmHandler.isOsTypeSupported(getParameters().getVmTemplateData().getOsId(), getCluster().getArchitecture(), getReturnValue().getValidationMessages());
    // Check if the watchdog model is supported
    if (returnValue && getParameters().getWatchdog() != null) {
        returnValue = validate(new VmWatchdogValidator.VmWatchdogClusterDependentValidator(getParameters().getVmTemplateData().getOsId(), getParameters().getWatchdog(), getVmTemplate().getCompatibilityVersion()).isValid());
    }
    // Check if the display type is supported
    if (returnValue) {
        returnValue = VmHandler.isGraphicsAndDisplaySupported(getParameters().getVmTemplateData().getOsId(), VmHandler.getResultingVmGraphics(getVmDeviceUtils().getGraphicsTypesOfEntity(getVmTemplateId()), getParameters().getGraphicsDevices()), getParameters().getVmTemplateData().getDefaultDisplayType(), getReturnValue().getValidationMessages(), getVmTemplate().getCompatibilityVersion());
    }
    if (returnValue) {
        returnValue = validate(VmValidator.validateCpuSockets(getParameters().getVmTemplateData(), getVmTemplate().getCompatibilityVersion().toString()));
    }
    if (returnValue && getParameters().getVmTemplateData().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVmTemplateData().getDefaultDisplayType(), getParameters().getVmTemplateData().getOsId(), getReturnValue().getValidationMessages())) {
        returnValue = false;
    }
    // Check PCI and IDE limits are ok
    if (returnValue) {
        List<VmNic> interfaces = vmNicDao.getAllForTemplate(getParameters().getVmTemplateData().getId());
        List<DiskVmElement> diskVmElements = diskVmElementDao.getAllForVm(getVmTemplateId());
        if (!validate(VmValidator.checkPciAndIdeLimit(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getNumOfMonitors(), interfaces, diskVmElements, getVmDeviceUtils().hasVirtioScsiController(getParameters().getVmTemplateData().getId()), hasWatchdog(getParameters().getVmTemplateData().getId()), getVmDeviceUtils().hasMemoryBalloon(getParameters().getVmTemplateData().getId()), isSoundDeviceEnabled()))) {
            returnValue = false;
        }
    }
    if (getParameters().getVmTemplateData().getMinAllocatedMem() > getParameters().getVmTemplateData().getMemSizeMb()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    if (!getVmPropertiesUtils().validateVmProperties(getVmTemplate().getCompatibilityVersion(), getParameters().getVmTemplateData().getCustomProperties(), getReturnValue().getValidationMessages())) {
        return false;
    }
    if (returnValue) {
        boolean balloonEnabled = Boolean.TRUE.equals(getParameters().isBalloonEnabled());
        if (balloonEnabled && !osRepository.isBalloonEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
            addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
            return failValidation(EngineMessage.BALLOON_REQUESTED_ON_NOT_SUPPORTED_ARCH);
        }
    }
    boolean soundDeviceEnabled = Boolean.TRUE.equals(getParameters().isSoundDeviceEnabled());
    if (soundDeviceEnabled && !osRepository.isSoundDeviceEnabled(getParameters().getVmTemplateData().getOsId(), getVmTemplate().getCompatibilityVersion())) {
        addValidationMessageVariable("clusterArch", getCluster().getArchitecture());
        return failValidation(EngineMessage.SOUND_DEVICE_REQUESTED_ON_NOT_SUPPORTED_ARCH);
    }
    return returnValue;
}
#end_block

#method_before
@Override
protected void updateRngDevice(Guid templateId) {
    if (!getParameters().isUpdateRngDevice()) {
        rngDeviceUtils.handleUrandomRandomChange(getParameters().getClusterLevelChangeFromVersion(), getCluster().getCompatibilityVersion(), templateId, cloneContextAndDetachFromParent(), false);
        return;
    }
    super.updateRngDevice(templateId);
}
#method_after
@Override
protected void updateRngDevice(Guid templateId) {
    if (!getParameters().isUpdateRngDevice()) {
        final Version newClusterVersion = getEffectiveCompatibilityVersion() != null ? getEffectiveCompatibilityVersion() : Version.getLast();
        rngDeviceUtils.handleUrandomRandomChange(getParameters().getClusterLevelChangeFromVersion(), newClusterVersion, templateId, cloneContextAndDetachFromParent(), false);
        return;
    }
    super.updateRngDevice(templateId);
}
#end_block

#method_before
private void createCommand(final Cluster group) {
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterIdAsMap(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#method_after
private void createCommand(final Cluster group) {
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterIdAsMap(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE && !isBlankTemplate()) {
        if (!validate(getVirtioRngValidator().canAddRngDevice(getCluster(), getParameters().getRngDevice()))) {
            return false;
        }
    }
    if (getRngDevices().isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!super.validate()) {
        return false;
    }
    if (getTemplateType() != VmEntityType.INSTANCE_TYPE && !isBlankTemplate()) {
        if (!validate(getVirtioRngValidator().canAddRngDevice(getCluster(), getParameters().getRngDevice(), getCachedEntity().getCustomCompatibilityVersion()))) {
            return false;
        }
    }
    if (getRngDevices().isEmpty()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_RNG_NOT_FOUND);
    }
    return true;
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getId(), committedDiskSize, dynamicData, staticData, storageDomainSharedStatus, storageDomainOverCommitPercent, storagePoolIsoMapData, totalDiskSize);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getId(), committedDiskSize, dynamicData, staticData, storageDomainSharedStatus, storageDomainOverCommitPercent, storagePoolIsoMapData, totalDiskSize, supportsDiscard, supportsDiscardZeroesData);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageDomain)) {
        return false;
    }
    StorageDomain other = (StorageDomain) obj;
    return Objects.equals(getId(), other.getId()) && committedDiskSize == other.committedDiskSize && storageDomainSharedStatus == other.storageDomainSharedStatus && storageDomainOverCommitPercent == other.storageDomainOverCommitPercent && Objects.equals(totalDiskSize, other.totalDiskSize);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof StorageDomain)) {
        return false;
    }
    StorageDomain other = (StorageDomain) obj;
    return Objects.equals(getId(), other.getId()) && committedDiskSize == other.committedDiskSize && storageDomainSharedStatus == other.storageDomainSharedStatus && storageDomainOverCommitPercent == other.storageDomainOverCommitPercent && Objects.equals(totalDiskSize, other.totalDiskSize) && Objects.equals(supportsDiscard, other.supportsDiscard) && Objects.equals(supportsDiscardZeroesData, other.supportsDiscardZeroesData);
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, _lunConnections, lunMapping, physicalVolumeId, deviceSize, pvSize, lunType, pathsDictionary, pathsCapacity, vendorName, productId, serial, vendorId, volumeGroupId, status, diskId, diskAlias, storageDomainId, storageDomainName);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, _lunConnections, lunMapping, physicalVolumeId, deviceSize, pvSize, discardMaxSize, discardZeroesData, lunType, pathsDictionary, pathsCapacity, vendorName, productId, serial, vendorId, volumeGroupId, status, diskId, diskAlias, storageDomainId, storageDomainName);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().getVGInfo(getParameters().getVGID());
    proceedProxyReturnValue();
    // build temp data
    String vgName = (String) _result.vgInfo.get("name");
    Object[] temp = (Object[]) _result.vgInfo.get("pvlist");
    Map<String, Object>[] pvList = new Map[0];
    if (temp != null) {
        pvList = new Map[temp.length];
        for (int i = 0; i < temp.length; i++) {
            pvList[i] = (Map<String, Object>) temp[i];
            pvList[i].put("vgName", vgName);
        }
    }
    Version compatibilityVersion = DbFacade.getInstance().getStoragePoolDao().getForVds(getParameters().getVdsId()).getCompatibilityVersion();
    setReturnValue(GetDeviceListVDSCommand.parseLUNList(pvList, compatibilityVersion));
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected void executeVdsBrokerCommand() {
    _result = getBroker().getVGInfo(getParameters().getVGID());
    proceedProxyReturnValue();
    // build temp data
    String vgName = (String) _result.vgInfo.get("name");
    Object[] temp = (Object[]) _result.vgInfo.get("pvlist");
    Map<String, Object>[] pvList = new Map[0];
    if (temp != null) {
        pvList = new Map[temp.length];
        for (int i = 0; i < temp.length; i++) {
            pvList[i] = (Map<String, Object>) temp[i];
            pvList[i].put("vgName", vgName);
        }
    }
    Version compatibilityVersion = storagePoolDao.getForVds(getParameters().getVdsId()).getCompatibilityVersion();
    setReturnValue(GetDeviceListVDSCommand.parseLUNList(pvList, compatibilityVersion));
}
#end_block

#method_before
private void processStorageOnVdsInactive(final VDS vds) {
    // anymore.
    if (!Guid.Empty.equals(vds.getStoragePoolId())) {
        // when vds is being moved to maintenance, this is the part in which we disconnect it from the pool
        // and the storage server. it should be synced with the host autorecovery mechanism to try to avoid
        // leaving the host with storage/pool connection when it's on maintenance.
        EngineLock lock = new EngineLock(Collections.singletonMap(vds.getId().toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString())), null);
        try {
            LockManagerFactory.getLockManager().acquireLockWait(lock);
            clearDomainCache(vds);
            StoragePool storage_pool = storagePoolDao.get(vds.getStoragePoolId());
            if (StoragePoolStatus.Uninitialized != storage_pool.getStatus()) {
                vdsBroker.runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getVdsSpmId()));
                HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(storage_pool, vds);
                backend.runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, params);
            }
        } finally {
            LockManagerFactory.getLockManager().releaseLock(lock);
        }
    }
}
#method_after
private void processStorageOnVdsInactive(final VDS vds) {
    // anymore.
    if (!Guid.Empty.equals(vds.getStoragePoolId())) {
        // when vds is being moved to maintenance, this is the part in which we disconnect it from the pool
        // and the storage server. it should be synced with the host autorecovery mechanism to try to avoid
        // leaving the host with storage/pool connection when it's on maintenance.
        EngineLock lock = new EngineLock(Collections.singletonMap(vds.getId().toString(), new Pair<>(LockingGroup.VDS_POOL_AND_STORAGE_CONNECTIONS.toString(), EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED.toString())), null);
        try {
            lockManager.acquireLockWait(lock);
            clearDomainCache(vds);
            StoragePool storage_pool = storagePoolDao.get(vds.getStoragePoolId());
            if (StoragePoolStatus.Uninitialized != storage_pool.getStatus()) {
                vdsBroker.runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(vds.getId(), vds.getStoragePoolId(), vds.getVdsSpmId()));
                HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(storage_pool, vds);
                backend.runInternalAction(VdcActionType.DisconnectHostFromStoragePoolServers, params);
            }
        } finally {
            lockManager.releaseLock(lock);
        }
    }
}
#end_block

#method_before
private void clearDomainCache(final VDS vds) {
    eventQueue.submitEventSync(new Event(vds.getStoragePoolId(), null, vds.getId(), EventType.VDSCLEARCACHE, ""), () -> {
        IrsBrokerCommand.clearVdsFromCache(vds.getStoragePoolId(), vds.getId(), vds.getName());
        return new EventResult(true, EventType.VDSCLEARCACHE);
    });
}
#method_after
private void clearDomainCache(final VDS vds) {
    eventQueue.submitEventSync(new Event(vds.getStoragePoolId(), null, vds.getId(), EventType.VDSCLEARCACHE, ""), () -> {
        clearVdsFromCache(vds.getStoragePoolId(), vds.getId(), vds.getName());
        return new EventResult(true, EventType.VDSCLEARCACHE);
    });
}
#end_block

#method_before
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(() -> {
            try {
                // migrate vms that its their default vds and failback
                // is on
                List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                if (!vmsToMigrate.isEmpty()) {
                    CommandContext ctx = new CommandContext(new EngineContext());
                    ctx.getExecutionContext().setMonitored(true);
                    backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx);
                }
            } catch (RuntimeException e) {
                log.error("Failed to initialize Vds on up: {}", e.getMessage());
                log.error("Exception", e);
            }
        });
    }
    return isSucceeded;
}
#method_after
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(() -> {
            try {
                // migrate vms that its their default vds and failback
                // is on
                List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                if (!vmsToMigrate.isEmpty()) {
                    CommandContext ctx = new CommandContext(new EngineContext());
                    ctx.getExecutionContext().setMonitored(true);
                    backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds, null)), ctx);
                }
            } catch (RuntimeException e) {
                log.error("Failed to initialize Vds on up: {}", e.getMessage());
                log.error("Exception", e);
            }
        });
    }
    return isSucceeded;
}
#end_block

#method_before
private List<VdcActionParametersBase> createMigrateVmToServerParametersList(List<VmStatic> vmsToMigrate, final VDS vds) {
    return vmsToMigrate.stream().map(vm -> {
        MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
        parameters.setShouldBeLogged(false);
        return parameters;
    }).collect(Collectors.toList());
}
#method_after
private List<VdcActionParametersBase> createMigrateVmToServerParametersList(List<VmStatic> vmsToMigrate, final VDS vds, String reason) {
    return vmsToMigrate.stream().map(vm -> {
        MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
        parameters.setReason(reason);
        parameters.setShouldBeLogged(false);
        return parameters;
    }).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void runFailedAutoStartVMs(List<Guid> vmIds) {
    for (Guid vmId : vmIds) {
        // Alert that the virtual machine failed:
        AuditLogableBase event = new AuditLogableBase();
        event.setVmId(vmId);
        auditLogDirector.log(event, AuditLogType.HA_VM_FAILED);
        log.info("Highly Available VM went down. Attempting to restart. VM Name '{}', VM Id '{}'", event.getVmName(), vmId);
    }
    haAutoStartVmsRunner.addVmsToRun(vmIds);
}
#method_after
@Override
public void runFailedAutoStartVMs(List<Guid> vmIds) {
    for (Guid vmId : vmIds) {
        // Alert that the virtual machine failed:
        AuditLogableBase event = Injector.injectMembers(new AuditLogableBase());
        event.setVmId(vmId);
        auditLogDirector.log(event, AuditLogType.HA_VM_FAILED);
        log.info("Highly Available VM went down. Attempting to restart. VM Name '{}', VM Id '{}'", event.getVmName(), vmId);
    }
    haAutoStartVmsRunner.addVmsToRun(vmIds);
}
#end_block

#method_before
@Override
public void runColdRebootVms(List<Guid> vmIds) {
    for (Guid vmId : vmIds) {
        AuditLogableBase event = new AuditLogableBase();
        event.setVmId(vmId);
        auditLogDirector.log(event, AuditLogType.COLD_REBOOT_VM_DOWN);
        log.info("VM is down as a part of cold reboot process. Attempting to restart. VM Name '{}', VM Id '{}", event.getVmName(), vmId);
    }
    coldRebootAutoStartVmsRunner.addVmsToRun(vmIds);
}
#method_after
@Override
public void runColdRebootVms(List<Guid> vmIds) {
    for (Guid vmId : vmIds) {
        AuditLogableBase event = Injector.injectMembers(new AuditLogableBase());
        event.setVmId(vmId);
        auditLogDirector.log(event, AuditLogType.COLD_REBOOT_VM_DOWN);
        log.info("VM is down as a part of cold reboot process. Attempting to restart. VM Name '{}', VM Id '{}", event.getVmName(), vmId);
    }
    coldRebootAutoStartVmsRunner.addVmsToRun(vmIds);
}
#end_block

#method_before
private Guid findChildCommandByActionType(VdcActionType commandType, List<Guid> childCmdIds) {
    for (Guid cmdId : childCmdIds) {
        CommandEntity commandEntity = CommandCoordinatorUtil.getCommandEntity(cmdId);
        if (commandEntity.getCommandType() == commandType) {
            return cmdId;
        }
    }
    return null;
}
#method_after
private Guid findChildCommandByActionType(VdcActionType commandType, List<Guid> childCmdIds) {
    return childCmdIds.stream().filter(cmdId -> CommandCoordinatorUtil.getCommandEntity(cmdId).getCommandType() == commandType).findFirst().orElse(null);
}
#end_block

#method_before
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    Collections.sort(getSelectedItems(), new Linq.VdsSPMPriorityComparer());
    for (VDS vds : getSelectedItems()) {
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    Collections.sort(getSelectedItems(), new HostSpmPriorityComparator());
    for (VDS vds : getSelectedItems()) {
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void maintenance(boolean isMaintenanceReasonVisible, boolean isStopGlusterServiceRequired) {
    if (getConfirmWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (isStopGlusterServiceRequired) {
        model.getForce().setIsAvailable(true);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().stopGlusterServices());
        model.getForce().setEntity(false);
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    ArrayList<String> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getName());
    }
    model.setItems(vdss);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
}
#method_after
private void maintenance(boolean isMaintenanceReasonVisible, boolean supportsGlusterService) {
    if (getConfirmWindow() != null) {
        return;
    }
    HostMaintenanceConfirmationModel model = new HostMaintenanceConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().maintenanceHostsTitle());
    model.setHelpTag(HelpTag.maintenance_host);
    // $NON-NLS-1$
    model.setHashName("maintenance_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToPlaceFollowingHostsIntoMaintenanceModeMsg());
    model.setReasonVisible(isMaintenanceReasonVisible);
    if (supportsGlusterService) {
        model.getStopGlusterServices().setIsAvailable(true);
        model.getStopGlusterServices().setEntity(false);
        model.getForce().setIsAvailable(true);
        model.getForce().setEntity(false);
        model.setForceLabel(ConstantsManager.getInstance().getConstants().ignoreGlusterQuorumChecks());
    }
    // model.Items = SelectedItems.Cast<VDS>().Select(a => a.vds_name);
    ArrayList<String> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getName());
    }
    model.setItems(vdss);
    // $NON-NLS-1$
    UICommand tempVar = UICommand.createDefaultOkUiCommand("OnMaintenance", this);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = UICommand.createCancelUiCommand("CancelConfirm", this);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void onMaintenance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    ArrayList<Guid> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getId());
    }
    list.add(new MaintenanceNumberOfVdssParameters(vdss, false, model.getReason().getEntity(), model.getForce().getEntity()));
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.MaintenanceNumberOfVdss, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#method_after
public void onMaintenance() {
    HostMaintenanceConfirmationModel model = (HostMaintenanceConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<Guid> vdss = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        vdss.add(vds.getId());
    }
    MaintenanceNumberOfVdssParameters params = new MaintenanceNumberOfVdssParameters(vdss, false, model.getReason().getEntity(), model.getStopGlusterServices().getEntity(), model.getForce().getEntity());
    model.startProgress();
    Frontend.getInstance().runAction(VdcActionType.MaintenanceNumberOfVdss, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                cancelConfirm();
            }
        }
    }, model);
}
#end_block

#method_before
public void onSshRestart() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new VdsActionParameters(vds.getId()));
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.SshHostReboot, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#method_after
public void onSshRestart() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        VdsActionParameters params = new VdsActionParameters(vds.getId());
        params.setPrevVdsStatus(vds.getStatus());
        list.add(params);
    }
    model.startProgress();
    Frontend.getInstance().runMultipleAction(VdcActionType.SshHostReboot, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancelConfirm();
        }
    }, model);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS vds = vdsDao.get(getVdsId());
    HostUpgradeManagerResult hostUpgradeManagerResult;
    try {
        hostUpgradeManagerResult = availableUpdatesFinder.isUpdateAvailable(vds);
        if (hostUpgradeManagerResult.isUpdatesAvailable()) {
            String message = hostUpgradeManagerResult.getAvailablePackages() == null ? "found updates." : String.format("found updates for packages %s", StringUtils.join(hostUpgradeManagerResult.getAvailablePackages(), ", "));
            addCustomValue("Message", message);
            vds.getDynamicData().setUpdateAvailable(hostUpgradeManagerResult.isUpdatesAvailable());
            vdsDynamicDao.updateUpdateAvailable(vds.getId(), hostUpgradeManagerResult.isUpdatesAvailable());
        } else {
            addCustomValue("Message", "no updates found.");
        }
        getReturnValue().setActionReturnValue(hostUpgradeManagerResult);
        setSucceeded(true);
        setCommandStatus(CommandStatus.SUCCEEDED);
    } catch (Exception e) {
        log.error("Failed to check if updates are available for host '{}'", vds.getName());
        setSucceeded(false);
        setCommandStatus(CommandStatus.FAILED);
    }
}
#method_after
@Override
protected void executeCommand() {
    HostUpgradeManagerResult hostUpgradeManagerResult = resourceManager.getVdsManager(getVdsId()).checkForUpdates(vdsDao.get(getVdsId()));
    getReturnValue().setActionReturnValue(hostUpgradeManagerResult);
    setSucceeded(hostUpgradeManagerResult != null);
    setCommandStatus(hostUpgradeManagerResult != null ? CommandStatus.SUCCEEDED : CommandStatus.FAILED);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? AuditLogType.HOST_AVAILABLE_UPDATES_FINISHED : AuditLogType.HOST_AVAILABLE_UPDATES_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return AuditLogType.UNASSIGNED;
}
#end_block

#method_before
private Map<String, Object> buildResponse(SsoSession ssoSession, String password) {
    Map<String, Object> payload = new HashMap<>();
    payload.put(SsoConstants.JSON_ACTIVE, ssoSession.isActive());
    payload.put(SsoConstants.JSON_TOKEN_TYPE, "bearer");
    payload.put(SsoConstants.JSON_CLIENT_ID, ssoSession.getClientId());
    payload.put(SsoConstants.JSON_USER_ID, String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile()));
    payload.put(SsoConstants.JSON_SCOPE, StringUtils.isEmpty(ssoSession.getScope()) ? "" : ssoSession.getScope());
    payload.put(SsoConstants.JSON_EXPIRES_IN, ssoSession.getValidTo());
    Map<String, Object> ovirt = new HashMap<>();
    ovirt.put("version", SsoConstants.OVIRT_SSO_VERSION);
    ovirt.put("principal_id", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.ID));
    ovirt.put("email", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.EMAIL));
    ovirt.put("namespace", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.NAMESPACE));
    ovirt.put("first_name", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.FIRST_NAME));
    ovirt.put("last_name", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.LAST_NAME));
    ovirt.put("group_ids", ssoSession.getPrincipalRecord().<Collection>get(Authz.PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList()));
    if (password != null) {
        ovirt.put("password", password);
    }
    ovirt.put("capability_credentials_change", ssoContext.getSsoProfilesSupportingPasswdChange().contains(ssoSession.getProfile()));
    payload.put("ovirt", ovirt);
    return payload;
}
#method_after
private Map<String, Object> buildResponse(SsoSession ssoSession, String password) {
    Map<String, Object> payload = new HashMap<>();
    payload.put(SsoConstants.JSON_ACTIVE, ssoSession.isActive());
    payload.put(SsoConstants.JSON_TOKEN_TYPE, "bearer");
    payload.put(SsoConstants.JSON_CLIENT_ID, ssoSession.getClientId());
    payload.put(SsoConstants.JSON_USER_ID, String.format("%s@%s", ssoSession.getUserId(), ssoSession.getProfile()));
    payload.put(SsoConstants.JSON_SCOPE, StringUtils.isEmpty(ssoSession.getScope()) ? "" : ssoSession.getScope());
    payload.put(SsoConstants.JSON_EXPIRES_IN, ssoSession.getValidTo().toString());
    Map<String, Object> ovirt = new HashMap<>();
    ovirt.put("version", SsoConstants.OVIRT_SSO_VERSION);
    ovirt.put("principal_id", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.ID));
    ovirt.put("email", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.EMAIL));
    ovirt.put("namespace", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.NAMESPACE));
    ovirt.put("first_name", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.FIRST_NAME));
    ovirt.put("last_name", ssoSession.getPrincipalRecord().<String>get(Authz.PrincipalRecord.LAST_NAME));
    ovirt.put("group_ids", ssoSession.getPrincipalRecord().<Collection>get(Authz.PrincipalRecord.GROUPS, Collections.<ExtMap>emptyList()));
    if (password != null) {
        ovirt.put("password", password);
    }
    ovirt.put("capability_credentials_change", ssoContext.getSsoProfilesSupportingPasswdChange().contains(ssoSession.getProfile()));
    payload.put("ovirt", ovirt);
    return payload;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DbUser)) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return Objects.equals(externalId, other.externalId) && Objects.equals(department, other.department) && Objects.equals(domain, other.domain) && Objects.equals(namespace, other.namespace) && Objects.equals(email, other.email) && Objects.equals(firstName, other.firstName) && Objects.equals(note, other.note) && Objects.equals(lastName, other.lastName) && Objects.equals(loginName, other.loginName);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof DbUser)) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return Objects.equals(externalId, other.externalId) && Objects.equals(department, other.department) && Objects.equals(domain, other.domain) && Objects.equals(namespace, other.namespace) && Objects.equals(email, other.email) && Objects.equals(firstName, other.firstName) && Objects.equals(note, other.note) && Objects.equals(lastName, other.lastName) && Objects.equals(loginName, other.loginName) && Objects.equals(isAdmin, other.isAdmin);
}
#end_block

#method_before
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    List<String> groupRecordIds = new ArrayList<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecordIds);
    for (String groupId : groupRecordIds) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, groupId);
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#method_after
private DbUser buildUser(T params, String authzName) {
    DbUser dbUser = dbUserDao.getByExternalId(authzName, params.getPrincipalId());
    DbUser user = new DbUser(dbUser);
    user.setId(dbUser == null ? Guid.newGuid() : dbUser.getId());
    user.setExternalId(params.getPrincipalId());
    user.setDomain(authzName);
    user.setEmail(params.getEmail());
    user.setFirstName(params.getFirstName());
    user.setLastName(params.getLastName());
    user.setNamespace(params.getNamespace());
    user.setLoginName(params.getPrincipalName());
    List<Guid> groupIds = new ArrayList<>();
    List<String> groupRecordIds = new ArrayList<>();
    flatGroups((Collection<ExtMap>) params.getGroupIds(), groupRecordIds);
    for (String groupId : groupRecordIds) {
        DbGroup dbGroup = dbGroupDao.getByExternalId(authzName, groupId);
        if (dbGroup != null) {
            groupIds.add(dbGroup.getId());
        }
    }
    user.setGroupIds(groupIds);
    user.setAdmin(!roleDao.getAnyAdminRoleForUserAndGroups(user.getId(), StringUtils.join(user.getGroupIds(), ",")).isEmpty());
    if (dbUser == null) {
        dbUserDao.save(user);
    } else if (!dbUser.equals(user)) {
        dbUserDao.update(user);
    }
    return user;
}
#end_block

#method_before
public Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.getInstance().addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description, command.getCommandStepSubjectEntities());
    command.getExecutionContext().setStep(taskStep);
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.getInstance().updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#method_after
public Guid createTask(Guid taskId, CommandBase<?> command, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, Map<Guid, VdcObjectType> entitiesMap) {
    Step taskStep = ExecutionHandler.getInstance().addTaskStep(command.getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description, Collections.emptyList());
    if (taskStep != null) {
        asyncTaskCreationInfo.setStepId(taskStep.getId());
    }
    SPMAsyncTask task = concreteCreateTask(taskId, command, asyncTaskCreationInfo, parentCommand);
    task.setEntitiesMap(entitiesMap);
    AsyncTaskUtils.addOrUpdateTaskInDB(task);
    getAsyncTaskManager().lockAndAddTaskToManager(task);
    Guid vdsmTaskId = task.getVdsmTaskId();
    ExecutionHandler.getInstance().updateStepExternalId(taskStep, vdsmTaskId, ExternalSystemType.VDSM);
    return vdsmTaskId;
}
#end_block

#method_before
private void handleCommandStepAndEntities() {
    if (getCommandStep() != null) {
        Step taskStep = executionHandler.addTaskStep(getExecutionContext(), getCommandStep(), null, getCommandStepSubjectEntities());
        if (taskStep != null) {
            getExecutionContext().setStep(taskStep);
            persistCommandIfNeeded();
        }
    }
}
#method_after
private void handleCommandStepAndEntities() {
    if (getCommandStep() != null) {
        Step taskStep = executionHandler.addTaskStep(getExecutionContext(), getCommandStep(), null, getCommandStepSubjectEntities());
        if (taskStep != null) {
            if (shouldUpdateStepProgress()) {
                stepDao.updateStepProgress(taskStep.getId(), 0);
            }
            getExecutionContext().setStep(taskStep);
            persistCommandIfNeeded();
        }
    }
}
#end_block

#method_before
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = getLockManager().acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.info("Lock Acquired to object '{}'", lock);
                context.withLock(lock);
            } else {
                log.info("Failed to Acquire Lock to object '{}'", lock);
                getReturnValue().getValidationMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean acquireLockInternal() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        EngineLock lock = buildLock();
        if (lock != null) {
            Pair<Boolean, Set<String>> lockAcquireResult = lockManager.acquireLock(lock);
            if (lockAcquireResult.getFirst()) {
                log.info("Lock Acquired to object '{}'", lock);
                context.withLock(lock);
            } else {
                log.info("Failed to Acquire Lock to object '{}'", lock);
                getReturnValue().getValidationMessages().addAll(extractVariableDeclarations(lockAcquireResult.getSecond()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            log.info("Before acquiring and wait lock '{}'", lock);
            getLockManager().acquireLockWait(lock);
            context.withLock(lock);
            log.info("Lock-wait acquired to object '{}'", lock);
        }
    }
}
#method_after
private void acquireLockAndWait() {
    // if commandLock is null then we acquire new lock, otherwise probably we got lock from caller command.
    if (context.getLock() == null) {
        Map<String, Pair<String, String>> exclusiveLocks = getExclusiveLocks();
        if (exclusiveLocks != null) {
            EngineLock lock = new EngineLock(exclusiveLocks, null);
            log.info("Before acquiring and wait lock '{}'", lock);
            lockManager.acquireLockWait(lock);
            context.withLock(lock);
            log.info("Lock-wait acquired to object '{}'", lock);
        }
    }
}
#end_block

#method_before
protected void freeLock() {
    if (context.getLock() != null) {
        getLockManager().releaseLock(context.getLock());
        log.info("Lock freed to object '{}'", context.getLock());
        context.withLock(null);
        // free other locks here to guarantee they will be freed only once
        freeCustomLocks();
    }
}
#method_after
protected void freeLock() {
    if (context.getLock() != null) {
        lockManager.releaseLock(context.getLock());
        log.info("Lock freed to object '{}'", context.getLock());
        context.withLock(null);
        // free other locks here to guarantee they will be freed only once
        freeCustomLocks();
    }
}
#end_block

#method_before
public void endTaskStep(Guid stepId, JobExecutionStatus exitStatus) {
    try {
        if (stepId != null) {
            Step step = jobRepository.getStep(stepId);
            if (step != null) {
                step.setProgress(100);
                step.markStepEnded(exitStatus);
                jobRepository.updateStep(step);
            }
        }
    } catch (Exception e) {
        log.error("Failed to terminate step '{}' with status '{}': {}", stepId, exitStatus, e.getMessage());
        log.debug("Exception", e);
    }
}
#method_after
public void endTaskStep(Guid stepId, JobExecutionStatus exitStatus) {
    try {
        if (stepId != null) {
            Step step = jobRepository.getStep(stepId);
            if (step != null) {
                step.markStepEnded(exitStatus);
                jobRepository.updateStep(step);
            }
        }
    } catch (Exception e) {
        log.error("Failed to terminate step '{}' with status '{}': {}", stepId, exitStatus, e.getMessage());
        log.debug("Exception", e);
    }
}
#end_block

#method_before
public Step addStep(ExecutionContext context, StepEnum stepName, String description, boolean isExternal) {
    if (context == null) {
        return null;
    }
    Step step = null;
    if (context.isMonitored()) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        try {
            Job job = context.getJob();
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                step = job.addStep(stepName, description);
                try {
                    step.setExternal(isExternal);
                    jobRepository.saveStep(step);
                } catch (Exception e) {
                    log.error("Failed to save new step '{}' for job '{}', '{}': {}", stepName.name(), job.getId(), job.getActionType().name(), e.getMessage());
                    log.debug("Exception", e);
                    job.getSteps().remove(step);
                    step = null;
                }
            } else {
                Step contextStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && contextStep != null) {
                    step = addSubStep(contextStep, stepName, description, Collections.emptyList(), false);
                    step.setExternal(isExternal);
                }
            }
        } catch (Exception e) {
            log.error("Exception", e);
        }
    }
    return step;
}
#method_after
public Step addStep(ExecutionContext context, StepEnum stepName, String description, boolean isExternal) {
    if (context == null) {
        return null;
    }
    Step step = null;
    if (context.isMonitored()) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        try {
            Job job = context.getJob();
            if (context.getExecutionMethod() == ExecutionMethod.AsJob && job != null) {
                step = job.addStep(stepName, description);
                try {
                    step.setExternal(isExternal);
                    jobRepository.saveStep(step);
                } catch (Exception e) {
                    log.error("Failed to save new step '{}' for job '{}', '{}': {}", stepName.name(), job.getId(), job.getActionType().name(), e.getMessage());
                    log.debug("Exception", e);
                    job.getSteps().remove(step);
                    step = null;
                }
            } else {
                Step contextStep = context.getStep();
                if (context.getExecutionMethod() == ExecutionMethod.AsStep && contextStep != null) {
                    step = addSubStep(contextStep, stepName, description, Collections.emptyList());
                    step.setExternal(isExternal);
                }
            }
        } catch (Exception e) {
            log.error("Exception", e);
        }
    }
    return step;
}
#end_block

#method_before
public Step addTaskStep(ExecutionContext context, StepEnum stepName, String description, Collection<StepSubjectEntity> stepSubjectEntities) {
    if (context == null) {
        return null;
    }
    Step step = null;
    if (context.isTasksMonitored()) {
        Step parentTaskStep = context.getParentTasksStep();
        if (parentTaskStep != null) {
            step = addSubStep(parentTaskStep, stepName, description, stepSubjectEntities, true);
        }
    }
    return step;
}
#method_after
public Step addTaskStep(ExecutionContext context, StepEnum stepName, String description, Collection<StepSubjectEntity> stepSubjectEntities) {
    if (context == null) {
        return null;
    }
    Step step = null;
    if (context.isTasksMonitored()) {
        Step parentTaskStep = context.getParentTasksStep();
        if (parentTaskStep != null) {
            step = addSubStep(parentTaskStep, stepName, description, stepSubjectEntities);
        }
    }
    return step;
}
#end_block

#method_before
public Step addSubStep(ExecutionContext context, Step parentStep, StepEnum newStepName, String description, boolean isExternal) {
    Step step = null;
    if (context == null || parentStep == null) {
        return null;
    }
    try {
        if (context.isMonitored()) {
            if (description == null) {
                description = ExecutionMessageDirector.getInstance().getStepMessage(newStepName);
            }
            if (context.getExecutionMethod() == ExecutionMethod.AsJob) {
                if (stepDao.exists(parentStep.getId())) {
                    if (parentStep.getJobId().equals(context.getJob().getId())) {
                        step = parentStep.addStep(newStepName, description);
                    }
                }
            } else if (context.getExecutionMethod() == ExecutionMethod.AsStep) {
                step = parentStep.addStep(newStepName, description);
            }
        }
        if (step != null) {
            step.setExternal(isExternal);
            jobRepository.saveStep(step);
        }
    } catch (Exception e) {
        log.error("Exception", e);
    }
    return step;
}
#method_after
private Step addSubStep(Step parentStep, StepEnum stepName, String description, Collection<StepSubjectEntity> stepSubjectEntities) {
    Step step = null;
    if (parentStep != null) {
        if (description == null) {
            description = ExecutionMessageDirector.getInstance().getStepMessage(stepName);
        }
        step = parentStep.addStep(stepName, description);
        try {
            jobRepository.saveStep(step, stepSubjectEntities);
        } catch (Exception e) {
            log.error("Failed to save new step '{}' for step '{}', '{}': {}", stepName.name(), parentStep.getId(), parentStep.getStepType().name(), e.getMessage());
            log.debug("Exception", e);
            parentStep.getSteps().remove(step);
            step = null;
        }
    }
    return step;
}
#end_block

#method_before
public static VdcReturnValueBase evaluateCorrelationId(VdcActionParametersBase parameters) {
    VdcReturnValueBase returnValue = null;
    String correlationId = parameters.getCorrelationId();
    if (StringUtils.isEmpty(correlationId)) {
        correlationId = CorrelationIdTracker.getCorrelationId();
        if (StringUtils.isEmpty(correlationId)) {
            correlationId = LoggedUtils.getObjectId(parameters);
        }
        parameters.setCorrelationId(correlationId);
    } else {
        List<String> messages = ValidationUtils.validateInputs(validationGroups, parameters);
        if (!messages.isEmpty()) {
            VdcReturnValueBase returnErrorValue = new VdcReturnValueBase();
            returnErrorValue.setValid(false);
            returnErrorValue.getValidationMessages().addAll(messages);
            return returnErrorValue;
        }
    }
    return returnValue;
}
#method_after
public static VdcReturnValueBase evaluateCorrelationId(HasCorrelationId parameters) {
    VdcReturnValueBase returnValue = null;
    String correlationId = parameters.getCorrelationId();
    if (StringUtils.isEmpty(correlationId)) {
        correlationId = CorrelationIdTracker.getCorrelationId();
        if (StringUtils.isEmpty(correlationId)) {
            correlationId = LoggedUtils.getObjectId(parameters);
        }
        parameters.setCorrelationId(correlationId);
    } else {
        List<String> messages = ValidationUtils.validateInputs(validationGroups, parameters);
        if (!messages.isEmpty()) {
            VdcReturnValueBase returnErrorValue = new VdcReturnValueBase();
            returnErrorValue.setValid(false);
            returnErrorValue.getValidationMessages().addAll(messages);
            return returnErrorValue;
        }
    }
    return returnValue;
}
#end_block

#method_before
public void endFinalizingStepAndCurrentStep(ExecutionContext context, boolean exitStatus) {
    if (context == null) {
        return;
    }
    try {
        Step parentStep = context.getStep();
        if (context.getExecutionMethod() == ExecutionMethod.AsStep && parentStep != null) {
            Step finalizingStep = parentStep.getStep(StepEnum.FINALIZING);
            if (finalizingStep != null) {
                finalizingStep.markStepEnded(exitStatus);
                jobRepository.updateStep(finalizingStep);
            }
            parentStep.setProgress(100);
            parentStep.markStepEnded(exitStatus);
            jobRepository.updateStep(parentStep);
        }
    } catch (RuntimeException e) {
        log.error("Exception", e);
    }
}
#method_after
public void endFinalizingStepAndCurrentStep(ExecutionContext context, boolean exitStatus) {
    if (context == null) {
        return;
    }
    try {
        Step parentStep = context.getStep();
        if (context.getExecutionMethod() == ExecutionMethod.AsStep && parentStep != null) {
            Step finalizingStep = parentStep.getStep(StepEnum.FINALIZING);
            if (finalizingStep != null) {
                finalizingStep.markStepEnded(exitStatus);
                jobRepository.updateStep(finalizingStep);
            }
            parentStep.markStepEnded(exitStatus);
            jobRepository.updateStep(parentStep);
        }
    } catch (RuntimeException e) {
        log.error("Exception", e);
    }
}
#end_block

#method_before
private void prepareParameters() {
    Map<Object, Integer> weights = new HashMap();
    getParameters().setOperationsJobWeight(weights);
    int createWeight = Long.valueOf(Math.round(getParameters().getJobWeight() / 10d)).intValue();
    weights.put(CopyStage.DEST_CREATION, createWeight);
    weights.put(CopyStage.DATA_COPY, getParameters().getJobWeight() - createWeight);
}
#method_after
private void prepareParameters() {
    if (getParameters().getJobWeight() != null) {
        Map<String, Integer> weights = new HashMap<>();
        int createWeight = Long.valueOf(Math.round(getParameters().getJobWeight() / 10d)).intValue();
        weights.put(CopyStage.DEST_CREATION.name(), createWeight);
        weights.put(CopyStage.DATA_COPY.name(), getParameters().getJobWeight() - createWeight);
        getParameters().setOperationsJobWeight(weights);
    }
}
#end_block

#method_before
private void cloneStructureNotCollapsed() {
    CloneImageGroupVolumesStructureCommandParameters p = new CloneImageGroupVolumesStructureCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getDestinationFormat(), getActionType(), getParameters());
    p.setParentParameters(getParameters());
    p.setParentCommand(getActionType());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    p.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION));
    runInternalAction(VdcActionType.CloneImageGroupVolumesStructure, p);
}
#method_after
private void cloneStructureNotCollapsed() {
    CloneImageGroupVolumesStructureCommandParameters p = new CloneImageGroupVolumesStructureCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getDestinationFormat(), getActionType(), getParameters());
    p.setParentParameters(getParameters());
    p.setParentCommand(getActionType());
    p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    p.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    runInternalAction(VdcActionType.CloneImageGroupVolumesStructure, p);
}
#end_block

#method_before
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), Double.valueOf(Math.ceil(ImagesHandler.getTotalSizeForClonedDisk(getDiskImage(), getStorageDomain().getStorageStaticData())) / StorageConstants.QCOW_OVERHEAD_FACTOR).longValue());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createVolume() {
    populateDiskSnapshotsInfoFromStorage();
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), getParameters().getDestinationFormat(), getParameters().getDescription(), getDiskImage().getSize(), Double.valueOf(Math.ceil(ImagesHandler.getTotalSizeForClonedDisk(getDiskImage(), getStorageDomain().getStorageStaticData())) / StorageConstants.QCOW_OVERHEAD_FACTOR).longValue());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(CopyStage.DEST_CREATION.name()));
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    runInternalAction(VdcActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == CopyStage.DEST_CREATION) {
        updateStage(CopyStage.DATA_COPY);
        Integer weight = getParameters().getOperationsJobWeight().get(CopyStage.DATA_COPY);
        if (getParameters().isCollapse()) {
            CopyDataCommandParameters parameters = new CopyDataCommandParameters(getParameters().getStoragePoolId(), buildImageLocationInfo(getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getImageId()), buildImageLocationInfo(getParameters().getDestDomain(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId()), true);
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setJobWeight(weight);
            runInternalAction(VdcActionType.CopyData, parameters);
        } else {
            CopyImageGroupVolumesDataCommandParameters p = new CopyImageGroupVolumesDataCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getDestDomain(), getActionType(), getParameters());
            p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            p.setJobWeight(weight);
            runInternalAction(VdcActionType.CopyImageGroupVolumesData, p);
        }
        return true;
    }
    return false;
}
#method_after
@Override
public boolean performNextOperation(int completedChildCount) {
    if (getParameters().getStage() == CopyStage.DEST_CREATION) {
        updateStage(CopyStage.DATA_COPY);
        Integer weight = getParameters().getOperationsJobWeight().get(CopyStage.DATA_COPY.name());
        if (getParameters().isCollapse()) {
            CopyDataCommandParameters parameters = new CopyDataCommandParameters(getParameters().getStoragePoolId(), buildImageLocationInfo(getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getImageId()), buildImageLocationInfo(getParameters().getDestDomain(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId()), true);
            parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            parameters.setParentCommand(getActionType());
            parameters.setParentParameters(getParameters());
            parameters.setJobWeight(weight);
            runInternalAction(VdcActionType.CopyData, parameters);
        } else {
            CopyImageGroupVolumesDataCommandParameters p = new CopyImageGroupVolumesDataCommandParameters(getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getImageGroupID(), getParameters().getDestDomain(), getActionType(), getParameters());
            p.setEndProcedure(EndProcedure.COMMAND_MANAGED);
            p.setJobWeight(weight);
            runInternalAction(VdcActionType.CopyImageGroupVolumesData, p);
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public List<StepSubjectEntity> getCommandStepSubjectEntities() {
    if (getParameters().getDstInfo() instanceof VdsmImageLocationInfo) {
        return Collections.singletonList(new StepSubjectEntity(VdcObjectType.Disk, ((VdsmImageLocationInfo) getParameters().getDstInfo()).getImageGroupId(), getParameters().getJobWeight()));
    }
    return null;
}
#method_after
@Override
public List<StepSubjectEntity> getCommandStepSubjectEntities() {
    if (getParameters().getJobWeight() != null && getParameters().getDstInfo() instanceof VdsmImageLocationInfo) {
        return Collections.singletonList(new StepSubjectEntity(VdcObjectType.Disk, ((VdsmImageLocationInfo) getParameters().getDstInfo()).getImageGroupId(), getParameters().getJobWeight()));
    }
    return super.getCommandStepSubjectEntities();
}
#end_block

#method_before
@Override
public List<StepSubjectEntity> getCommandStepSubjectEntities() {
    if (getParameters().getJobWeight() != null) {
        return Collections.singletonList(new StepSubjectEntity(VdcObjectType.Disk, getParameters().getImageGroupID(), getParameters().getJobWeight()));
    }
    return null;
}
#method_after
@Override
public List<StepSubjectEntity> getCommandStepSubjectEntities() {
    if (getParameters().getJobWeight() != null) {
        return Collections.singletonList(new StepSubjectEntity(VdcObjectType.Disk, getParameters().getImageGroupID(), getParameters().getJobWeight()));
    }
    return super.getCommandStepSubjectEntities();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    ImagesHandler.sortImageList(images);
    getParameters().setImageIds(ImagesHandler.getDiskImageIds(images));
    double totalSize = images.stream().mapToDouble(DiskImage::getActualSize).sum();
    Map<Object, Double> weightDivision = images.stream().collect(Collectors.toMap(DiskImage::getImageId, x -> calculateImageWeight(totalSize, x)));
    getParameters().setOperationsJobWeight(CommandsHelper.calculateWeights(weightDivision, getParameters().getJobWeight()));
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    List<DiskImage> images = diskImageDao.getAllSnapshotsForImageGroup(getParameters().getImageGroupID());
    ImagesHandler.sortImageList(images);
    getParameters().setImageIds(ImagesHandler.getDiskImageIds(images));
    prepareWeights(images);
    persistCommand(getParameters().getParentCommand(), getCallback() != null);
    setSucceeded(true);
}
#end_block

#method_before
private void copyVolumeData(Guid image) {
    CopyDataCommandParameters parameters = new CopyDataCommandParameters(getParameters().getStoragePoolId(), buildImageLocationInfo(getParameters().getSrcDomain(), getParameters().getImageGroupID(), image), buildImageLocationInfo(getParameters().getDestDomain(), getParameters().getImageGroupID(), image), false);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image));
    runInternalActionWithTasksContext(VdcActionType.CopyData, parameters);
}
#method_after
private void copyVolumeData(Guid image) {
    CopyDataCommandParameters parameters = new CopyDataCommandParameters(getParameters().getStoragePoolId(), buildImageLocationInfo(getParameters().getSrcDomain(), getParameters().getImageGroupID(), image), buildImageLocationInfo(getParameters().getDestDomain(), getParameters().getImageGroupID(), image), false);
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.toString()));
    runInternalActionWithTasksContext(VdcActionType.CopyData, parameters);
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters prepareChildParameters() {
    MoveOrCopyImageGroupParameters parameters = new MoveOrCopyImageGroupParameters(getParameters());
    if (parameters.getOperation() == ImageOperation.Copy) {
        parameters.setUseCopyCollapse(true);
        parameters.setAddImageDomainMapping(true);
        parameters.setShouldLockImageOnRevert(false);
        if (!isTemplate()) {
            prepareCopyNotTemplate(parameters);
            parameters.setShouldLockImageOnRevert(true);
            parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
        }
    } else {
        parameters.setUseCopyCollapse(false);
    }
    if (parameters.getOperation() == ImageOperation.Move || isTemplate()) {
        parameters.setDestinationImageId(getImageId());
        parameters.setImageGroupID(getImageGroupId());
        parameters.setDestImageGroupId(getImageGroupId());
    }
    parameters.setVolumeFormat(getDiskImage().getVolumeFormat());
    parameters.setVolumeType(getDiskImage().getVolumeType());
    if (isTemplate()) {
        parameters.setCopyVolumeType(CopyVolumeType.SharedVol);
    } else {
        parameters.setCopyVolumeType(CopyVolumeType.LeafVol);
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setDiskProfileId(getImage().getDiskProfileId());
    parameters.setJobWeight(100);
    return parameters;
}
#method_after
private MoveOrCopyImageGroupParameters prepareChildParameters() {
    MoveOrCopyImageGroupParameters parameters = new MoveOrCopyImageGroupParameters(getParameters());
    if (parameters.getOperation() == ImageOperation.Copy) {
        parameters.setUseCopyCollapse(true);
        parameters.setAddImageDomainMapping(true);
        parameters.setShouldLockImageOnRevert(false);
        if (!isTemplate()) {
            prepareCopyNotTemplate(parameters);
            parameters.setShouldLockImageOnRevert(true);
            parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
        }
    } else {
        parameters.setUseCopyCollapse(false);
    }
    if (parameters.getOperation() == ImageOperation.Move || isTemplate()) {
        parameters.setDestinationImageId(getImageId());
        parameters.setImageGroupID(getImageGroupId());
        parameters.setDestImageGroupId(getImageGroupId());
    }
    parameters.setVolumeFormat(getDiskImage().getVolumeFormat());
    parameters.setVolumeType(getDiskImage().getVolumeType());
    if (isTemplate()) {
        parameters.setCopyVolumeType(CopyVolumeType.SharedVol);
    } else {
        parameters.setCopyVolumeType(CopyVolumeType.LeafVol);
    }
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setDiskProfileId(getImage().getDiskProfileId());
    parameters.setJobWeight(Job.MAX_WEIGHT);
    return parameters;
}
#end_block

#method_before
private void prepareWeights() {
    if (getParameters().getJobWeight() == null) {
        return;
    }
    Double imageWeight = 1d / getParameters().getImageIds().size();
    Map<Object, Double> weightDivision = getParameters().getImageIds().stream().collect(Collectors.toMap(x -> x, z -> imageWeight));
    getParameters().setOperationsJobWeight(CommandsHelper.calculateWeights(weightDivision, getParameters().getJobWeight()));
}
#method_after
private void prepareWeights() {
    if (getParameters().getJobWeight() == null) {
        return;
    }
    Double imageWeight = 1d / getParameters().getImageIds().size();
    Map<String, Double> weightDivision = getParameters().getImageIds().stream().collect(Collectors.toMap(Guid::toString, z -> imageWeight));
    getParameters().setOperationsJobWeight(commandsWeightsUtils.adjust(weightDivision, getParameters().getJobWeight()));
}
#end_block

#method_before
private void createImage(DiskImage image) {
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), getParameters().getImageGroupID(), image.getImageId(), determineSourceImageGroup(image), image.getParentId(), getParameters().getDestFormat(), getParameters().getDescription(), image.getSize(), determineImageInitialSize(image.getImage()));
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.getImageId()));
    runInternalActionWithTasksContext(VdcActionType.CreateVolumeContainer, parameters);
}
#method_after
private void createImage(DiskImage image) {
    CreateVolumeContainerCommandParameters parameters = new CreateVolumeContainerCommandParameters(getParameters().getStoragePoolId(), getParameters().getDestDomain(), determineSourceImageGroup(image), image.getParentId(), getParameters().getImageGroupID(), image.getImageId(), getParameters().getDestFormat(), getParameters().getDescription(), image.getSize(), ImagesHandler.determineImageInitialSize(image.getImage(), getParameters().getDestFormat(), getParameters().getStoragePoolId(), getParameters().getSrcDomain(), getParameters().getDestDomain(), getParameters().getImageGroupID()));
    parameters.setEndProcedure(EndProcedure.COMMAND_MANAGED);
    parameters.setParentCommand(getActionType());
    parameters.setParentParameters(getParameters());
    parameters.setJobWeight(getParameters().getOperationsJobWeight().get(image.getImageId().toString()));
    runInternalActionWithTasksContext(VdcActionType.CreateVolumeContainer, parameters);
}
#end_block

#method_before
public Map<?, Integer> getOperationsJobWeight() {
    return operationsJobWeight;
}
#method_after
public Map<String, Integer> getOperationsJobWeight() {
    return operationsJobWeight;
}
#end_block

#method_before
public void setOperationsJobWeight(Map<Object, Integer> operationsJobWeight) {
    this.operationsJobWeight = operationsJobWeight;
}
#method_after
public void setOperationsJobWeight(Map<String, Integer> operationsJobWeight) {
    this.operationsJobWeight = operationsJobWeight;
}
#end_block

#method_before
protected List<OvfEntityData> getOvfEntityList(VmEntityType vmEntityType) {
    List<OvfEntityData> entityList = unregisteredOVFDataDao.getAllForStorageDomainByEntityType(getParameters().getId(), vmEntityType);
    return entityList;
}
#method_after
protected List<OvfEntityData> getOvfEntityList(VmEntityType vmEntityType) {
    return unregisteredOVFDataDao.getAllForStorageDomainByEntityType(getParameters().getId(), vmEntityType);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    log.info("Creating {} image", getImageType());
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        createImage();
    } else {
        handleImageIsReadyForTransfer(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        log.info("Creating {} image", getImageType());
        createImage();
    } else {
        handleImageIsReadyForTransfer(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
private void initiateNewUpload() {
    startProgress(null);
    // $NON-NLS-1$
    setProgressStr("Initiating new upload");
    final UploadDiskImageParameters parameters = createInitParams();
    Frontend.getInstance().runAction(VdcActionType.UploadDiskImage, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            UploadImageModel model = (UploadImageModel) result.getState();
            if (result.getReturnValue().getSucceeded()) {
                setCommandId((Guid) result.getReturnValue().getActionReturnValue());
                setBytesSent(0);
                startStatusPolling();
                // The dialog will be closed, but the model's upload code will continue in the background
                model.stopProgress();
                model.getCancelCommand().execute();
            } else {
                setProgressStr(messages.uploadImageFailedToStartMessage(result.getReturnValue().getDescription()));
                model.stopProgress();
            }
        }
    }, this);
}
#method_after
private void initiateNewUpload() {
    startProgress(null);
    // $NON-NLS-1$
    setProgressStr("Initiating new upload");
    final TransferDiskImageParameters parameters = createInitParams();
    Frontend.getInstance().runAction(VdcActionType.TransferDiskImage, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            UploadImageModel model = (UploadImageModel) result.getState();
            if (result.getReturnValue().getSucceeded()) {
                setCommandId((Guid) result.getReturnValue().getActionReturnValue());
                setBytesSent(0);
                startStatusPolling();
                // The dialog will be closed, but the model's upload code will continue in the background
                model.stopProgress();
                model.getCancelCommand().execute();
            } else {
                setProgressStr(messages.uploadImageFailedToStartMessage(result.getReturnValue().getDescription()));
                model.stopProgress();
            }
        }
    }, this);
}
#end_block

#method_before
private UploadDiskImageParameters createInitParams() {
    Disk newDisk = diskModel.getDisk();
    AddDiskParameters diskParameters = new AddDiskParameters(newDisk);
    if (diskModel.getDiskStorageType().getEntity() == DiskStorageType.IMAGE || diskModel.getDiskStorageType().getEntity() == DiskStorageType.CINDER) {
        diskParameters.setStorageDomainId(getDiskModel().getStorageDomain().getSelectedItem().getId());
    }
    UploadDiskImageParameters parameters = new UploadDiskImageParameters(diskParameters.getStorageDomainId(), AsyncDataProvider.getInstance().getUploadImageUiInactivityTimeoutInSeconds(), diskParameters);
    parameters.setUploadSize(getImageSize());
    return parameters;
}
#method_after
private TransferDiskImageParameters createInitParams() {
    Disk newDisk = diskModel.getDisk();
    AddDiskParameters diskParameters = new AddDiskParameters(newDisk);
    if (diskModel.getDiskStorageType().getEntity() == DiskStorageType.IMAGE || diskModel.getDiskStorageType().getEntity() == DiskStorageType.CINDER) {
        diskParameters.setStorageDomainId(getDiskModel().getStorageDomain().getSelectedItem().getId());
    }
    TransferDiskImageParameters parameters = new TransferDiskImageParameters(diskParameters.getStorageDomainId(), AsyncDataProvider.getInstance().getUploadImageUiInactivityTimeoutInSeconds(), diskParameters);
    parameters.setTransferSize(getImageSize());
    return parameters;
}
#end_block

#method_before
private void initiateResumeUpload() {
    startProgress(null);
    // $NON-NLS-1$
    setProgressStr("Resuming upload");
    final UploadImageStatusParameters parameters = new UploadImageStatusParameters();
    parameters.setDiskId(getDiskModel().getDisk().getId());
    Frontend.getInstance().runAction(VdcActionType.UploadImageStatus, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            initiateResumeUploadCheckStatus(result);
        }
    }, this);
}
#method_after
private void initiateResumeUpload() {
    startProgress(null);
    // $NON-NLS-1$
    setProgressStr("Resuming upload");
    final TransferImageStatusParameters parameters = new TransferImageStatusParameters();
    parameters.setDiskId(getDiskModel().getDisk().getId());
    Frontend.getInstance().runAction(VdcActionType.TransferImageStatus, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            initiateResumeUploadCheckStatus(result);
        }
    }, this);
}
#end_block

#method_before
private void initiateResumeUploadCheckStatus(FrontendActionAsyncResult result) {
    UploadImageModel model = (UploadImageModel) result.getState();
    if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
        ImageTransfer rv = result.getReturnValue().getActionReturnValue();
        if (rv.getBytesTotal() != getImageSize()) {
            setProgressStr(messages.uploadImageFailedToResumeSizeMessage(rv.getBytesTotal(), getImageSize()));
            model.stopProgress();
            return;
        }
        // Resumable uploads already have a command running on engine, so get its id and resume it.
        ImageTransferUpdates updates = new ImageTransferUpdates();
        updates.setPhase(ImageTransferPhase.RESUMING);
        final UploadImageStatusParameters parameters = new UploadImageStatusParameters(rv.getId());
        parameters.setUpdates(updates);
        Frontend.getInstance().runAction(VdcActionType.UploadImageStatus, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                initiateResumeUploadStartTransfer(result);
            }
        }, model);
    } else {
        setProgressStr(messages.uploadImageFailedToResumeMessage(result.getReturnValue().getDescription()));
        model.stopProgress();
    }
}
#method_after
private void initiateResumeUploadCheckStatus(FrontendActionAsyncResult result) {
    UploadImageModel model = (UploadImageModel) result.getState();
    if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
        ImageTransfer rv = result.getReturnValue().getActionReturnValue();
        if (rv.getBytesTotal() != getImageSize()) {
            if (rv.getBytesTotal() == 0) {
                // This upload was generated by the API.
                setProgressStr(messages.uploadImageFailedToResumeUploadOriginatedInAPI());
            } else {
                setProgressStr(messages.uploadImageFailedToResumeSizeMessage(rv.getBytesTotal(), getImageSize()));
            }
            model.stopProgress();
            return;
        }
        // Resumable uploads already have a command running on engine, so get its id and resume it.
        ImageTransfer updates = new ImageTransfer();
        updates.setPhase(ImageTransferPhase.RESUMING);
        final TransferImageStatusParameters parameters = new TransferImageStatusParameters(rv.getId());
        parameters.setUpdates(updates);
        Frontend.getInstance().runAction(VdcActionType.TransferImageStatus, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                initiateResumeUploadStartTransfer(result);
            }
        }, model);
    } else {
        setProgressStr(messages.uploadImageFailedToResumeMessage(result.getReturnValue().getDescription()));
        model.stopProgress();
    }
}
#end_block

#method_before
private void startStatusPolling() {
    setContinuePolling(true);
    manageWindowClosingHandler(true);
    Scheduler.get().scheduleFixedDelay(new Scheduler.RepeatingCommand() {

        @Override
        public boolean execute() {
            // $NON-NLS-1$
            log.info("Polling for status");
            UploadImageStatusParameters statusParameters = new UploadImageStatusParameters(getCommandId());
            // TODO: temp updates from UI until updates from VDSM are implemented
            ImageTransferUpdates updates = new ImageTransferUpdates();
            updates.setBytesSent(getBytesSent());
            updates.setMessage(getMessage() != null ? getMessage() : getProgressStr());
            statusParameters.setUpdates(updates);
            Frontend.getInstance().runAction(VdcActionType.UploadImageStatus, statusParameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    respondToPollStatus(result);
                }
            });
            if (!getContinuePolling()) {
                manageWindowClosingHandler(false);
            }
            return getContinuePolling();
        }
    }, POLLING_DELAY_MS);
}
#method_after
private void startStatusPolling() {
    setContinuePolling(true);
    manageWindowClosingHandler(true);
    Scheduler.get().scheduleFixedDelay(new Scheduler.RepeatingCommand() {

        @Override
        public boolean execute() {
            // $NON-NLS-1$
            log.info("Polling for status");
            TransferImageStatusParameters statusParameters = new TransferImageStatusParameters(getCommandId());
            // TODO: temp updates from UI until updates from VDSM are implemented
            ImageTransfer updates = new ImageTransfer();
            updates.setBytesSent(getBytesSent());
            updates.setMessage(getMessage() != null ? getMessage() : getProgressStr());
            statusParameters.setUpdates(updates);
            Frontend.getInstance().runAction(VdcActionType.TransferImageStatus, statusParameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    respondToPollStatus(result);
                }
            });
            if (!getContinuePolling()) {
                manageWindowClosingHandler(false);
            }
            return getContinuePolling();
        }
    }, POLLING_DELAY_MS);
}
#end_block

#method_before
private void finalizeImageUpload() {
    if (getUploadState() == UploadState.ENGINE_PAUSE) {
        // $NON-NLS-1$
        log.info("Upload paused; stopping model execution");
        return;
    }
    ImageTransferUpdates updates = new ImageTransferUpdates();
    UploadImageStatusParameters statusParameters = new UploadImageStatusParameters(getCommandId(), updates);
    if (getUploadState() == UploadState.SUCCESS) {
        // $NON-NLS-1$
        setProgressStr("Finalizing success...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
    } else if (getUploadState() == UploadState.CLIENT_ERROR) {
        // $NON-NLS-1$
        setProgressStr("Pausing due to client error");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.PAUSED_SYSTEM);
        statusParameters.setDiskId(getImageId());
        statusParameters.setAuditLogType(auditLogType);
    } else {
        // $NON-NLS-1$
        setProgressStr("Finalizing failure...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_FAILURE);
    }
    // $NON-NLS-1$
    log.info("Updating status to {}", statusParameters.getUpdates().getPhase());
    Frontend.getInstance().runAction(VdcActionType.UploadImageStatus, statusParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                if (++failedFinalizationAttempts < MAX_FAILED_POLL_ATTEMPTS) {
                    finalizeImageUpload();
                } else {
                    setContinuePolling(false);
                    // $NON-NLS-1$
                    setProgressStr("Failed to update upload status on engine");
                }
            }
        }
    });
}
#method_after
private void finalizeImageUpload() {
    if (getUploadState() == UploadState.ENGINE_PAUSE) {
        // $NON-NLS-1$
        log.info("Upload paused; stopping model execution");
        return;
    }
    ImageTransfer updates = new ImageTransfer();
    TransferImageStatusParameters statusParameters = new TransferImageStatusParameters(getCommandId(), updates);
    if (getUploadState() == UploadState.SUCCESS) {
        // $NON-NLS-1$
        setProgressStr("Finalizing success...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_SUCCESS);
    } else if (getUploadState() == UploadState.CLIENT_ERROR) {
        // $NON-NLS-1$
        setProgressStr("Pausing due to client error");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.PAUSED_SYSTEM);
        statusParameters.setDiskId(getImageId());
        statusParameters.setAuditLogType(auditLogType);
    } else {
        // $NON-NLS-1$
        setProgressStr("Finalizing failure...");
        statusParameters.getUpdates().setPhase(ImageTransferPhase.FINALIZING_FAILURE);
    }
    // $NON-NLS-1$
    log.info("Updating status to {}", statusParameters.getUpdates().getPhase());
    Frontend.getInstance().runAction(VdcActionType.TransferImageStatus, statusParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                if (++failedFinalizationAttempts < MAX_FAILED_POLL_ATTEMPTS) {
                    finalizeImageUpload();
                } else {
                    setContinuePolling(false);
                    // $NON-NLS-1$
                    setProgressStr("Failed to update upload status on engine");
                }
            }
        }
    });
}
#end_block

#method_before
public static void onCancelUpload(ConfirmationModel model, List<DiskImage> images) {
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (DiskImage image : images) {
        ImageTransferUpdates updates = new ImageTransferUpdates();
        updates.setPhase(ImageTransferPhase.CANCELLED);
        UploadImageStatusParameters parameters = new UploadImageStatusParameters();
        parameters.setUpdates(updates);
        parameters.setDiskId(image.getId());
        list.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.UploadImageStatus, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            // parent.cancel();
            localModel.getCancelCommand().execute();
        }
    }, model);
}
#method_after
public static void onCancelUpload(ConfirmationModel model, List<DiskImage> images) {
    if (model.getProgress() != null) {
        return;
    }
    model.startProgress(null);
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (DiskImage image : images) {
        ImageTransfer updates = new ImageTransfer();
        updates.setPhase(ImageTransferPhase.CANCELLED);
        TransferImageStatusParameters parameters = new TransferImageStatusParameters();
        parameters.setUpdates(updates);
        parameters.setDiskId(image.getId());
        list.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.TransferImageStatus, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            // parent.cancel();
            localModel.getCancelCommand().execute();
        }
    }, model);
}
#end_block

#method_before
public static void pauseUploads(List<DiskImage> images) {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (DiskImage image : images) {
        ImageTransferUpdates updates = new ImageTransferUpdates();
        updates.setPhase(ImageTransferPhase.PAUSED_USER);
        UploadImageStatusParameters parameters = new UploadImageStatusParameters();
        parameters.setUpdates(updates);
        parameters.setDiskId(image.getId());
        list.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.UploadImageStatus, list);
}
#method_after
public static void pauseUploads(List<DiskImage> images) {
    ArrayList<VdcActionParametersBase> list = new ArrayList<>();
    for (DiskImage image : images) {
        ImageTransfer updates = new ImageTransfer();
        updates.setPhase(ImageTransferPhase.PAUSED_USER);
        TransferImageStatusParameters parameters = new TransferImageStatusParameters();
        parameters.setUpdates(updates);
        parameters.setDiskId(image.getId());
        list.add(parameters);
    }
    Frontend.getInstance().runMultipleAction(VdcActionType.TransferImageStatus, list);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        if (getParameters().isDownloading()) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    } else {
        handleImageIsReadyForTransfer(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getTransferSize());
    imageTransferDao.save(entity);
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        if (getParameters().getTransferType() == TransferType.Download) {
            failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
            setSucceeded(false);
            return;
        }
        log.info("Creating {} image", getImageType());
        createImage();
    } else {
        handleImageIsReadyForTransfer(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, getOperationsByTransferType(), timeout, getParameters().getTransferSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    String[] transferOps = new String[] { getParameters().getTransferType().getOp() };
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, transferOps, timeout, getParameters().getTransferSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
@Override
protected boolean validate() {
    Guid imageId = getParameters().getImageId();
    if (!Guid.isNullOrEmpty(imageId)) {
        return validateImageTransfer(imageId);
    } else {
        if (!getParameters().isDownloading()) {
            return validateCreateImage();
        } else {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
        }
    }
}
#method_after
@Override
protected boolean validate() {
    Guid imageId = getParameters().getImageId();
    if (!Guid.isNullOrEmpty(imageId)) {
        return validateImageTransfer(imageId);
    } else if (getParameters().getTransferType() == TransferType.Download) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
    }
    return validateCreateImage();
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("DiskAlias", getImageAlias());
    return getActionState() == CommandActionState.EXECUTE ? AuditLogType.TRANSFER_IMAGE_INITIATED : getParameters().getAuditLogType();
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    addCustomValue("DiskAlias", getImageAlias());
    addCustomValue("TransferType", getParameters().getTransferType().name());
    return getActionState() == CommandActionState.EXECUTE ? AuditLogType.TRANSFER_IMAGE_INITIATED : getParameters().getAuditLogType();
}
#end_block

#method_before
// Return a string describing the transfer, safe for use before the new image
protected String getTransferDescription() {
    return String.format("%s %s '%s' (id '%s')", getTransferType(), getImageType(), getImageAlias(), getImageIdNullSafe());
}
#method_after
// Return a string describing the transfer, safe for use before the new image
protected String getTransferDescription() {
    return String.format("%s %s '%s' (id '%s')", getParameters().getTransferType().name(), getImageType(), getImageAlias(), getImageIdNullSafe());
}
#end_block

#method_before
@Test
public void testFailOnDownloadWithoutImage() {
    transferImageCommand.getParameters().setIsDownloading(true);
    assertFalse(transferImageCommand.validate());
    assertThat(transferImageCommand.getReturnValue().getValidationMessages(), contains(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD.name()));
}
#method_after
@Test
public void testFailOnDownloadWithoutImage() {
    transferImageCommand.getParameters().setTransferType(TransferType.Download);
    ValidateTestUtils.runAndAssertValidateFailure(transferImageCommand, EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
}
#end_block

#method_before
@Test
public void testFailsDownloadExecutionWithoutImage() {
    transferImageCommand.getParameters().setIsDownloading(true);
    transferImageCommand.executeCommand();
    assertFalse(transferImageCommand.getReturnValue().getSucceeded());
    assertThat(transferImageCommand.getReturnValue().getValidationMessages(), contains(EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD.name()));
}
#method_after
@Test
public void testFailsDownloadExecutionWithoutImage() {
    transferImageCommand.getParameters().setTransferType(TransferType.Download);
    transferImageCommand.executeCommand();
    ValidateTestUtils.runAndAssertValidateFailure(transferImageCommand, EngineMessage.ACTION_TYPE_FAILED_IMAGE_NOT_SPECIFIED_FOR_DOWNLOAD);
}
#end_block

#method_before
@Test
public void testCommandPersistedWithParamUpdates() {
    DiskImage readyImage = initReadyImageForUpload();
    TransferDiskImageParameters params = mock(TransferDiskImageParameters.class);
    doReturn(params).when(transferImageCommand).getParameters();
    transferImageCommand.handleImageIsReadyForTransfer(readyImage.getImageId());
    // Verify that persistCommand is being called after each of the params changes.
    InOrder inOrder = inOrder(params, transferImageCommand);
    inOrder.verify(params).setStorageDomainId(any());
    inOrder.verify(transferImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, transferImageCommand);
    inOrder.verify(params).setImageId(any());
    inOrder.verify(transferImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, transferImageCommand);
    inOrder.verify(params).setTransferSize(anyLong());
    inOrder.verify(transferImageCommand).persistCommand(any(), anyBoolean());
}
#method_after
@Test
public void testCommandPersistedWithParamUpdates() {
    DiskImage readyImage = initReadyImageForUpload();
    TransferDiskImageParameters params = spy(new TransferDiskImageParameters());
    doReturn(params).when(transferImageCommand).getParameters();
    transferImageCommand.handleImageIsReadyForTransfer(readyImage.getImageId());
    // Verify that persistCommand is being called after each of the params changes.
    InOrder inOrder = inOrder(params, transferImageCommand);
    inOrder.verify(params).setStorageDomainId(any());
    inOrder.verify(transferImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, transferImageCommand);
    inOrder.verify(params).setImageId(any());
    inOrder.verify(transferImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, transferImageCommand);
    inOrder.verify(params).setTransferSize(anyLong());
    inOrder.verify(transferImageCommand).persistCommand(any(), anyBoolean());
}
#end_block

#method_before
@Test
public void testUploadIsDefaultTransferType() {
    assertEquals(transferImageCommand.getTransferType(), transferImageCommand.UPLOAD);
}
#method_after
@Test
public void testUploadIsDefaultTransferType() {
    assertEquals(transferImageCommand.getParameters().getTransferType(), TransferType.Upload);
}
#end_block

#method_before
@Override
public Response add(ImageTransfer imageTransfer) {
    TransferDiskImageParameters params = new TransferDiskImageParameters();
    if (imageTransfer.getDirection() != null && imageTransfer.getDirection().equals(ImageTransferDirection.DOWNLOAD)) {
        params.setIsDownloading(true);
    }
    params.setImageId(GuidUtils.asGuid(imageTransfer.getImage().getId()));
    params.setKeepaliveInterval(ConfigurationValues.UploadImageUiInactivityTimeoutInSeconds.getValue());
    return performCreate(VdcActionType.TransferDiskImage, params, new QueryIdResolver<Guid>(VdcQueryType.GetImageTransferById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(ImageTransfer imageTransfer) {
    TransferDiskImageParameters params = new TransferDiskImageParameters();
    if (imageTransfer.isSetDirection() && imageTransfer.getDirection() == ImageTransferDirection.DOWNLOAD) {
        // Upload is the default direction, so we set the transfer type only if download was explicitly specified.
        params.setTransferType(TransferType.Download);
    }
    params.setImageId(GuidUtils.asGuid(imageTransfer.getImage().getId()));
    params.setKeepaliveInterval(ConfigurationValues.UploadImageUiInactivityTimeoutInSeconds.getValue());
    return performCreate(VdcActionType.TransferDiskImage, params, new QueryIdResolver<Guid>(VdcQueryType.GetImageTransferById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(Map src, Map dst, boolean collapse) {
    JsonRpcRequest request = new RequestBuilder("SDM.copyData").withParameter("srcImage", src).withParameter("dstImage", dst).withParameter("collapse", collapse).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    JsonRpcRequest request = new RequestBuilder("SDM.copy_data").withParameter("source", src).withParameter("destination", dst).withParameter("job_id", jobId).build();
    Map<String, Object> response = new FutureMap(this.client, request);
    return new StatusOnlyReturnForXmlRpc(response);
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            int connectionId = client.getConnectionId();
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed() && client.getConnectionId() == connectionId) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password) {
    JsonRpcRequest request = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#method_after
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    RequestBuilder requestBuilder = new RequestBuilder("Host.getExternalVMs").withParameter("uri", uri).withParameter("username", username).withParameter("password", password).withOptionalParameterAsList("vm_names", vmsNames);
    JsonRpcRequest request = requestBuilder.build();
    Map<String, Object> response = new FutureMap(this.client, request).withResponseKey("vmList").withResponseType(Object[].class);
    return new VMListReturnForXmlRpc(response);
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc copyData(Map src, Map dst, boolean collapse) {
    Map<String, Object> xmlRpcReturnValue = vdsServer.copyData(src, dst, collapse);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#method_after
@Override
public StatusOnlyReturnForXmlRpc copyData(String jobId, Map src, Map dst) {
    Map<String, Object> xmlRpcReturnValue = vdsServer.copyData(jobId, src, dst);
    StatusOnlyReturnForXmlRpc wrapper = new StatusOnlyReturnForXmlRpc(xmlRpcReturnValue);
    return wrapper;
}
#end_block

#method_before
@Override
public List<Certificate> getPeerCertificates() {
    try {
        Pair<String, URL> connectionUrl = XmlRpcUtils.getConnectionUrl(httpClient.getHostConfiguration().getHost(), httpClient.getHostConfiguration().getPort(), null, Config.<Boolean>getValue(ConfigValues.EncryptHostCommunication));
        return CertificateChain.getSSLPeerCertificates(connectionUrl.getSecond());
    } catch (GeneralSecurityException | IOException e) {
        logger.error("Failed to get peer certification for host '{}': {}", httpClient.getHostConfiguration().getHost(), e.getMessage());
        logger.debug("Exception", e);
        return null;
    }
}
#method_after
@Override
public List<Certificate> getPeerCertificates() {
    try {
        Pair<String, URL> connectionUrl = XmlRpcUtils.getConnectionUrl(httpClient.getHostConfiguration().getHost(), httpClient.getHostConfiguration().getPort(), null, Config.getValue(ConfigValues.EncryptHostCommunication));
        return CertificateChain.getSSLPeerCertificates(connectionUrl.getSecond());
    } catch (GeneralSecurityException | IOException e) {
        logger.error("Failed to get peer certification for host '{}': {}", httpClient.getHostConfiguration().getHost(), e.getMessage());
        logger.debug("Exception", e);
        return null;
    }
}
#end_block

#method_before
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getExternalVMs(uri, username, password);
        VMListReturnForXmlRpc wrapper = new VMListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public VMListReturnForXmlRpc getExternalVmList(String uri, String username, String password, List<String> vmsNames) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.getExternalVMs(uri, username, password, vmsNames);
        VMListReturnForXmlRpc wrapper = new VMListReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void init() {
    setImageId(((DiskImage) getDisk()).getImageId());
}
#method_after
@Override
protected void init() {
    super.init();
    if (getDiskImage().getVmEntityType().isTemplateType()) {
        initVmTemplateId();
    }
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getVds() == null && !selectProxyHost()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    DiskValidator diskValidator = new DiskValidator(getDiskImage());
    if (!validate(diskValidator.isDiskExists()) || !validate(diskValidator.isDiskPluggedToVmsThatAreNotDown(false, vmsForDisk))) {
        return false;
    }
    if (diskImageDao.getAllSnapshotsForImageGroup(getDiskImage().getId()).size() > 1) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_HAS_SNAPSHOTS);
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(getDiskImage()));
    return validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesHaveNoDerivedDisks(null));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    runVdsCommand(VDSCommandType.SparsifyImage, new SparsifyImageVDSCommandParameters(getVds().getId(), getDiskImage().getStorageIds().get(0), getDiskImage().getImageId(), getDiskImage().getId()));
}
#method_after
@Override
protected void executeCommand() {
    lockImageInDb();
    VDSReturnValue vdsReturnValue = VdsCommandsHelper.runVdsCommandWithFailover(VDSCommandType.SparsifyImage, new SparsifyImageVDSCommandParameters(getParameters().getStorageJobId(), getDiskImage().getStorageIds().get(0), getDiskImage().getId(), getDiskImage().getImageId()), getDiskImage().getStoragePoolId(), this);
    if (!vdsReturnValue.getSucceeded()) {
        setCommandStatus(CommandStatus.FAILED);
        unlockImageInDb();
    }
    setSucceeded(vdsReturnValue.getSucceeded());
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permsList = new ArrayList<>();
    Disk disk = getDisk();
    if (disk != null) {
        permsList.add(new PermissionSubject(disk.getId(), VdcObjectType.Disk, ActionGroup.SPARSIFY_DISK));
    }
    return permsList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    DiskImage diskImage = getDiskImage();
    if (diskImage == null) {
        return Collections.emptyList();
    }
    return Collections.singletonList(new PermissionSubject(diskImage.getId(), VdcObjectType.Disk, getActionType().getActionGroup()));
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    Map<String, Object> volumeAddress = new HashMap<>();
    volumeAddress.put("sd_id", getParameters().getStorageId());
    volumeAddress.put("img_id", getParameters().getImageId());
    volumeAddress.put("vol_id", getParameters().getVolumeId());
    result = getBroker().sparsifyInplace(jobId, volumeAddress);
    proceedProxyReturnValue();
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    Map<String, Object> volumeAddress = new HashMap<>();
    volumeAddress.put("sd_id", getParameters().getStorageDomainId().toString());
    volumeAddress.put("img_id", getParameters().getImageId().toString());
    volumeAddress.put("vol_id", getParameters().getVolumeId().toString());
    result = getBroker().sparsifyVolume(getParameters().getJobId().toString(), volumeAddress);
    proceedProxyReturnValue();
}
#end_block

#method_before
@Override
protected boolean validate() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !checkImagesStatus() || !validateSpaceRequirements() || !performVmRelatedChecks()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setValid(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && performStorageDomainsChecks(parameters) && isSameSourceAndDest(parameters));
        if (!getReturnValue().isValid()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand();
}
#method_after
@Override
protected boolean validate() {
    setStoragePoolId(getVm().getStoragePoolId());
    if (!isValidParametersList() || !validateDestDomainsSpaceRequirements()) {
        return false;
    }
    for (LiveMigrateDiskParameters parameters : getParameters().getParametersList()) {
        getReturnValue().setValid(isDiskNotShareable(parameters.getImageId()) && isDiskSnapshotNotPluggedToOtherVmsThatAreNotDown(parameters.getImageId()) && isTemplateInDestStorageDomain(parameters.getImageId(), parameters.getTargetStorageDomainId()) && validateDestStorage(getStorageDomainById(parameters.getTargetStorageDomainId(), getStoragePoolId())) && isSameSourceAndDest(parameters));
        if (!getReturnValue().isValid()) {
            return false;
        }
    }
    if (!setAndValidateDiskProfiles()) {
        return false;
    }
    return validateCreateAllSnapshotsFromVmCommand();
}
#end_block

#method_before
private void initSpyCommand() {
    doReturn(true).when(command).validateSpaceRequirements();
    doReturn(true).when(command).checkImagesStatus();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateCreateAllSnapshotsFromVmCommand();
}
#method_after
private void initSpyCommand() {
    doReturn(true).when(command).validateDestDomainsSpaceRequirements();
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateCreateAllSnapshotsFromVmCommand();
}
#end_block

#method_before
@Mapping(from = FencingPolicy.class, to = org.ovirt.engine.core.common.businessentities.FencingPolicy.class)
public static org.ovirt.engine.core.common.businessentities.FencingPolicy map(FencingPolicy model, org.ovirt.engine.core.common.businessentities.FencingPolicy template) {
    org.ovirt.engine.core.common.businessentities.FencingPolicy entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.FencingPolicy();
    entity.setFencingEnabled(model.isEnabled());
    if (model.isSetSkipIfSdActive()) {
        entity.setSkipFencingIfSDActive(model.getSkipIfSdActive().isEnabled());
    }
    if (model.isSetSkipIfConnectivityBroken()) {
        entity.setSkipFencingIfConnectivityBroken(model.getSkipIfConnectivityBroken().isEnabled());
        if (model.getSkipIfConnectivityBroken().getThreshold() != null) {
            entity.setHostsWithBrokenConnectivityThreshold(model.getSkipIfConnectivityBroken().getThreshold());
        } else {
            entity.setHostsWithBrokenConnectivityThreshold(50);
        }
    }
    entity.setSkipFencingIfGlusterBricksUp(model.isSkipIfGlusterBricksUp());
    entity.setSkipFencingIfGlusterQuorumNotMet(model.isSkipIfGlusterQuorumNotMet().isEnabled());
    return entity;
}
#method_after
@Mapping(from = FencingPolicy.class, to = org.ovirt.engine.core.common.businessentities.FencingPolicy.class)
public static org.ovirt.engine.core.common.businessentities.FencingPolicy map(FencingPolicy model, org.ovirt.engine.core.common.businessentities.FencingPolicy template) {
    org.ovirt.engine.core.common.businessentities.FencingPolicy entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.FencingPolicy();
    entity.setFencingEnabled(model.isEnabled());
    if (model.isSetSkipIfSdActive()) {
        entity.setSkipFencingIfSDActive(model.getSkipIfSdActive().isEnabled());
    }
    if (model.isSetSkipIfConnectivityBroken()) {
        entity.setSkipFencingIfConnectivityBroken(model.getSkipIfConnectivityBroken().isEnabled());
        if (model.getSkipIfConnectivityBroken().getThreshold() != null) {
            entity.setHostsWithBrokenConnectivityThreshold(model.getSkipIfConnectivityBroken().getThreshold());
        } else {
            entity.setHostsWithBrokenConnectivityThreshold(50);
        }
    }
    if (model.isSetSkipIfGlusterBricksUp()) {
        entity.setSkipFencingIfGlusterBricksUp(model.isSkipIfGlusterBricksUp());
    }
    if (model.isSetSkipIfGlusterQuorumNotMet()) {
        entity.setSkipFencingIfGlusterQuorumNotMet(model.isSkipIfGlusterQuorumNotMet());
    }
    return entity;
}
#end_block

#method_before
protected void writeGeneralData() {
    if (vmBase.getDescription() != null) {
        _writer.writeStartElement(OvfProperties.DESCRIPTION);
        _writer.writeRaw(vmBase.getDescription());
        _writer.writeEndElement();
    }
    if (vmBase.getComment() != null) {
        _writer.writeStartElement(OvfProperties.COMMENT);
        _writer.writeRaw(vmBase.getComment());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CREATION_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.EXPORT_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DELETE_PROTECTED);
    _writer.writeRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.writeEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.writeStartElement(OvfProperties.SSO_METHOD);
        _writer.writeRaw(vmBase.getSsoMethod().toString());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_SMARTCARD_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.writeEndElement();
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeStartElement(OvfProperties.NUM_OF_IOTHREADS);
        _writer.writeRaw(String.valueOf(vmBase.getNumOfIoThreads()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.TIMEZONE);
    _writer.writeRaw(vmBase.getTimeZone());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    _writer.writeRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.writeEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeStartElement(OvfProperties.INITRD_URL);
        _writer.writeRaw(vmBase.getInitrdUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeStartElement(OvfProperties.KERNEL_URL);
        _writer.writeRaw(vmBase.getKernelUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeStartElement(OvfProperties.KERNEL_PARAMS);
        _writer.writeRaw(vmBase.getKernelParams());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.GENERATION);
    _writer.writeRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.writeEndElement();
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
        _writer.writeRaw(String.valueOf(vmBase.getCustomCompatibilityVersion()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    // cluster version the VM/Snapshot originates from
    _writer.writeRaw(String.valueOf(version));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.VM_TYPE);
    _writer.writeRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.writeEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeStartElement(OvfProperties.TUNNEL_MIGRATION);
        _writer.writeRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.writeEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeStartElement(OvfProperties.VNC_KEYBOARD_LAYOUT);
        _writer.writeRaw(vmBase.getVncKeyboardLayout());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.MIN_ALLOCATED_MEMORY);
    _writer.writeRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_STATELESS);
    _writer.writeRaw(String.valueOf(vmBase.isStateless()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_RUN_AND_PAUSE);
    _writer.writeRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.AUTO_STARTUP);
    _writer.writeRaw(String.valueOf(vmBase.isAutoStartup()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.PRIORITY);
    _writer.writeRaw(String.valueOf(vmBase.getPriority()));
    _writer.writeEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeStartElement(OvfProperties.CREATED_BY_USER_ID);
        _writer.writeRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_DOWNTIME);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationDowntime()));
        _writer.writeEndElement();
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_SUPPORT);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationSupport().getValue()));
        _writer.writeEndElement();
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    if (vmBase.getDedicatedVmForVdsList().size() > 0) {
        for (Guid hostId : vmBase.getDedicatedVmForVdsList()) {
            _writer.writeStartElement(OvfProperties.DEDICATED_VM_FOR_VDS);
            _writer.writeRaw(String.valueOf(hostId));
            _writer.writeEndElement();
        }
    }
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeStartElement(OvfProperties.SERIAL_NUMBER_POLICY);
        _writer.writeRaw(String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
        _writer.writeEndElement();
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_SERIAL_NUMBER);
        _writer.writeRaw(vmBase.getCustomSerialNumber());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_BOOT_MENU_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeEndElement();
    if (vmBase.getAutoConverge() != null) {
        _writer.writeStartElement(OvfProperties.IS_AUTO_CONVERGE);
        _writer.writeRaw(String.valueOf(vmBase.getAutoConverge()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeStartElement(OvfProperties.IS_MIGRATE_COMPRESSED);
        _writer.writeRaw(String.valueOf(vmBase.getMigrateCompressed()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrationPolicyId() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_POLICY_ID);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationPolicyId()));
        _writer.writeEndElement();
    }
    writeCustomEmulatedMachine();
    writeCustomCpuName();
    _writer.writeStartElement(OvfProperties.PREDEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getPredefinedProperties());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.USER_DEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getUserDefinedProperties());
    _writer.writeEndElement();
}
#method_after
protected void writeGeneralData() {
    if (vmBase.getDescription() != null) {
        _writer.writeStartElement(OvfProperties.DESCRIPTION);
        _writer.writeRaw(vmBase.getDescription());
        _writer.writeEndElement();
    }
    if (vmBase.getComment() != null) {
        _writer.writeStartElement(OvfProperties.COMMENT);
        _writer.writeRaw(vmBase.getComment());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CREATION_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(vmBase.getCreationDate()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.EXPORT_DATE);
    _writer.writeRaw(OvfParser.localDateToUtcDateString(new Date()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DELETE_PROTECTED);
    _writer.writeRaw(String.valueOf(vmBase.isDeleteProtected()));
    _writer.writeEndElement();
    if (vmBase.getSsoMethod() != null) {
        _writer.writeStartElement(OvfProperties.SSO_METHOD);
        _writer.writeRaw(vmBase.getSsoMethod().toString());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_SMARTCARD_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSmartcardEnabled()));
    _writer.writeEndElement();
    if (vmBase.getNumOfIoThreads() != 0) {
        _writer.writeStartElement(OvfProperties.NUM_OF_IOTHREADS);
        _writer.writeRaw(String.valueOf(vmBase.getNumOfIoThreads()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.TIMEZONE);
    _writer.writeRaw(vmBase.getTimeZone());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.DEFAULT_BOOT_SEQUENCE);
    _writer.writeRaw(String.valueOf(vmBase.getDefaultBootSequence().getValue()));
    _writer.writeEndElement();
    if (!StringUtils.isBlank(vmBase.getInitrdUrl())) {
        _writer.writeStartElement(OvfProperties.INITRD_URL);
        _writer.writeRaw(vmBase.getInitrdUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelUrl())) {
        _writer.writeStartElement(OvfProperties.KERNEL_URL);
        _writer.writeRaw(vmBase.getKernelUrl());
        _writer.writeEndElement();
    }
    if (!StringUtils.isBlank(vmBase.getKernelParams())) {
        _writer.writeStartElement(OvfProperties.KERNEL_PARAMS);
        _writer.writeRaw(vmBase.getKernelParams());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.GENERATION);
    _writer.writeRaw(String.valueOf(vmBase.getDbGeneration()));
    _writer.writeEndElement();
    if (vmBase.getCustomCompatibilityVersion() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_COMPATIBILITY_VERSION);
        _writer.writeRaw(String.valueOf(vmBase.getCustomCompatibilityVersion()));
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.CLUSTER_COMPATIBILITY_VERSION);
    // cluster version the VM/Snapshot originates from
    _writer.writeRaw(String.valueOf(version));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.VM_TYPE);
    _writer.writeRaw(String.valueOf(vmBase.getVmType().getValue()));
    _writer.writeEndElement();
    if (vmBase.getTunnelMigration() != null) {
        _writer.writeStartElement(OvfProperties.TUNNEL_MIGRATION);
        _writer.writeRaw(String.valueOf(vmBase.getTunnelMigration()));
        _writer.writeEndElement();
    }
    if (vmBase.getVncKeyboardLayout() != null) {
        _writer.writeStartElement(OvfProperties.VNC_KEYBOARD_LAYOUT);
        _writer.writeRaw(vmBase.getVncKeyboardLayout());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.MIN_ALLOCATED_MEMORY);
    _writer.writeRaw(String.valueOf(vmBase.getMinAllocatedMem()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_STATELESS);
    _writer.writeRaw(String.valueOf(vmBase.isStateless()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_RUN_AND_PAUSE);
    _writer.writeRaw(String.valueOf(vmBase.isRunAndPause()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.AUTO_STARTUP);
    _writer.writeRaw(String.valueOf(vmBase.isAutoStartup()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.PRIORITY);
    _writer.writeRaw(String.valueOf(vmBase.getPriority()));
    _writer.writeEndElement();
    if (vmBase.getCreatedByUserId() != null) {
        _writer.writeStartElement(OvfProperties.CREATED_BY_USER_ID);
        _writer.writeRaw(String.valueOf(vmBase.getCreatedByUserId()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrationDowntime() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_DOWNTIME);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationDowntime()));
        _writer.writeEndElement();
    }
    writeVmInit();
    if (vmBase.getMigrationSupport() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_SUPPORT);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationSupport().getValue()));
        _writer.writeEndElement();
    }
    // TODO dedicated to multiple hosts - are we breaking any standard here?
    if (vmBase.getDedicatedVmForVdsList().size() > 0) {
        for (Guid hostId : vmBase.getDedicatedVmForVdsList()) {
            _writer.writeStartElement(OvfProperties.DEDICATED_VM_FOR_VDS);
            _writer.writeRaw(String.valueOf(hostId));
            _writer.writeEndElement();
        }
    }
    if (vmBase.getSerialNumberPolicy() != null) {
        _writer.writeStartElement(OvfProperties.SERIAL_NUMBER_POLICY);
        _writer.writeRaw(String.valueOf(vmBase.getSerialNumberPolicy().getValue()));
        _writer.writeEndElement();
    }
    if (vmBase.getCustomSerialNumber() != null) {
        _writer.writeStartElement(OvfProperties.CUSTOM_SERIAL_NUMBER);
        _writer.writeRaw(vmBase.getCustomSerialNumber());
        _writer.writeEndElement();
    }
    _writer.writeStartElement(OvfProperties.IS_BOOT_MENU_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isBootMenuEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_FILE_TRANSFER_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceFileTransferEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.IS_SPICE_COPY_PASTE_ENABLED);
    _writer.writeRaw(String.valueOf(vmBase.isSpiceCopyPasteEnabled()));
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.ALLOW_CONSOLE_RECONNECT);
    _writer.writeRaw(String.valueOf(vmBase.isAllowConsoleReconnect()));
    _writer.writeEndElement();
    if (vmBase.getAutoConverge() != null) {
        _writer.writeStartElement(OvfProperties.IS_AUTO_CONVERGE);
        _writer.writeRaw(String.valueOf(vmBase.getAutoConverge()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrateCompressed() != null) {
        _writer.writeStartElement(OvfProperties.IS_MIGRATE_COMPRESSED);
        _writer.writeRaw(String.valueOf(vmBase.getMigrateCompressed()));
        _writer.writeEndElement();
    }
    if (vmBase.getMigrationPolicyId() != null) {
        _writer.writeStartElement(OvfProperties.MIGRATION_POLICY_ID);
        _writer.writeRaw(String.valueOf(vmBase.getMigrationPolicyId()));
        _writer.writeEndElement();
    }
    writeCustomEmulatedMachine();
    writeCustomCpuName();
    _writer.writeStartElement(OvfProperties.PREDEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getPredefinedProperties());
    _writer.writeEndElement();
    _writer.writeStartElement(OvfProperties.USER_DEFINED_PROPERTIES);
    _writer.writeRaw(vmBase.getUserDefinedProperties());
    _writer.writeEndElement();
}
#end_block

#method_before
private void setUpQueryEntities() throws OvfReaderException {
    // Set up the expected result
    VM vmReturnForOvf = new VM();
    vmReturnForOvf.setId(newVmGuid);
    vmReturnForOvf.setName("Name");
    String ovfData = new String("OVF data for the first VM");
    OvfEntityData ovfEntityData = new OvfEntityData(vmReturnForOvf.getId(), vmReturnForOvf.getName(), VmEntityType.VM, null, null, storageDomainId, ovfData, null);
    List<OvfEntityData> expectedResultQuery1 = new ArrayList<>();
    expectedResultQuery1.add(ovfEntityData);
    List<OvfEntityData> expectedResult = new ArrayList<>();
    expectedResult.add(ovfEntityData);
    VM vmReturnForOvf2 = new VM();
    vmReturnForOvf2.setId(newVmGuid2);
    vmReturnForOvf2.setName("Name2");
    String ovfData2 = new String("OVF data for the second VM");
    OvfEntityData ovfEntityData2 = new OvfEntityData(vmReturnForOvf2.getId(), vmReturnForOvf2.getName(), VmEntityType.VM, null, null, storageDomainId, ovfData2, null);
    expectedResult.add(ovfEntityData2);
    List<OvfEntityData> expectedResultQuery2 = new ArrayList<>();
    expectedResultQuery2.add(ovfEntityData);
    // Mock the Daos
    UnregisteredOVFDataDao unregisteredOVFDataDaoMock = mock(UnregisteredOVFDataDao.class);
    when(getDbFacadeMockInstance().getUnregisteredOVFDataDao()).thenReturn(unregisteredOVFDataDaoMock);
    when(unregisteredOVFDataDaoMock.getAllForStorageDomainByEntityType(storageDomainId, entityType)).thenReturn(expectedResult);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmGuid2, storageDomainId)).thenReturn(expectedResultQuery2);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmGuid, storageDomainId)).thenReturn(expectedResultQuery1);
    // Mock OVF
    OvfHelper ovfHelperMock = mock(OvfHelper.class);
    doReturn(ovfHelperMock).when(getQuery()).getOvfHelper();
    when(ovfHelperMock.readVmFromOvf(ovfData)).thenReturn(vmReturnForOvf);
    when(ovfHelperMock.readVmFromOvf(ovfData2)).thenReturn(vmReturnForOvf2);
}
#method_after
private void setUpQueryEntities() throws OvfReaderException {
    // Set up the expected result
    VM vmReturnForOvf = new VM();
    vmReturnForOvf.setId(newVmGuid);
    vmReturnForOvf.setName("Name");
    String ovfData = new String("OVF data for the first VM");
    OvfEntityData ovfEntityData = new OvfEntityData(vmReturnForOvf.getId(), vmReturnForOvf.getName(), VmEntityType.VM, null, null, storageDomainId, ovfData, null);
    List<OvfEntityData> expectedResultQuery1 = new ArrayList<>();
    expectedResultQuery1.add(ovfEntityData);
    List<OvfEntityData> expectedResult = new ArrayList<>();
    expectedResult.add(ovfEntityData);
    VM vmReturnForOvf2 = new VM();
    vmReturnForOvf2.setId(newVmGuid2);
    vmReturnForOvf2.setName("Name2");
    String ovfData2 = new String("OVF data for the second VM");
    OvfEntityData ovfEntityData2 = new OvfEntityData(vmReturnForOvf2.getId(), vmReturnForOvf2.getName(), VmEntityType.VM, null, null, storageDomainId, ovfData2, null);
    expectedResult.add(ovfEntityData2);
    List<OvfEntityData> expectedResultQuery2 = new ArrayList<>();
    expectedResultQuery2.add(ovfEntityData);
    // Mock the Daos
    when(unregisteredOVFDataDaoMock.getAllForStorageDomainByEntityType(storageDomainId, entityType)).thenReturn(expectedResult);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmGuid2, storageDomainId)).thenReturn(expectedResultQuery2);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmGuid, storageDomainId)).thenReturn(expectedResultQuery1);
    // Mock OVF
    OvfHelper ovfHelperMock = mock(OvfHelper.class);
    doReturn(ovfHelperMock).when(getQuery()).getOvfHelper();
    when(ovfHelperMock.readVmFromOvf(ovfData)).thenReturn(vmReturnForOvf);
    when(ovfHelperMock.readVmFromOvf(ovfData2)).thenReturn(vmReturnForOvf2);
}
#end_block

#method_before
private void setUpQueryEntities() throws OvfReaderException {
    // Set up the expected result
    VmTemplate VmTemplateReturnForOvf = new VmTemplate();
    VmTemplateReturnForOvf.setId(newVmTemplateGuid);
    VmTemplateReturnForOvf.setName("Name");
    String ovfData = new String("OVF data for the first Template");
    OvfEntityData ovfEntityData = new OvfEntityData(VmTemplateReturnForOvf.getId(), VmTemplateReturnForOvf.getName(), VmEntityType.TEMPLATE, null, null, storageDomainId, ovfData, null);
    List<OvfEntityData> expectedResult = new ArrayList<>();
    List<OvfEntityData> expectedResultQuery1 = new ArrayList<>();
    expectedResultQuery1.add(ovfEntityData);
    expectedResult.add(ovfEntityData);
    VmTemplate VmTemplateReturnForOvf2 = new VmTemplate();
    VmTemplateReturnForOvf2.setId(newVmTemplateGuid2);
    VmTemplateReturnForOvf2.setName("Name2");
    String ovfData2 = new String("OVF data for the second Template");
    OvfEntityData ovfEntityData2 = new OvfEntityData(VmTemplateReturnForOvf2.getId(), VmTemplateReturnForOvf2.getName(), VmEntityType.TEMPLATE, null, null, storageDomainId, ovfData2, null);
    expectedResult.add(ovfEntityData2);
    List<OvfEntityData> expectedResultQuery2 = new ArrayList<>();
    expectedResultQuery2.add(ovfEntityData);
    // Mock the Daos
    UnregisteredOVFDataDao unregisteredOVFDataDaoMock = mock(UnregisteredOVFDataDao.class);
    when(getDbFacadeMockInstance().getUnregisteredOVFDataDao()).thenReturn(unregisteredOVFDataDaoMock);
    when(unregisteredOVFDataDaoMock.getAllForStorageDomainByEntityType(storageDomainId, entityType)).thenReturn(expectedResult);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmTemplateGuid, storageDomainId)).thenReturn(expectedResultQuery1);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmTemplateGuid2, storageDomainId)).thenReturn(expectedResultQuery2);
    // Mock OVF
    OvfHelper ovfHelperMock = mock(OvfHelper.class);
    doReturn(ovfHelperMock).when(getQuery()).getOvfHelper();
    when(ovfHelperMock.readVmTemplateFromOvf(ovfData)).thenReturn(VmTemplateReturnForOvf);
    when(ovfHelperMock.readVmTemplateFromOvf(ovfData2)).thenReturn(VmTemplateReturnForOvf2);
}
#method_after
private void setUpQueryEntities() throws OvfReaderException {
    // Set up the expected result
    VmTemplate VmTemplateReturnForOvf = new VmTemplate();
    VmTemplateReturnForOvf.setId(newVmTemplateGuid);
    VmTemplateReturnForOvf.setName("Name");
    String ovfData = new String("OVF data for the first Template");
    OvfEntityData ovfEntityData = new OvfEntityData(VmTemplateReturnForOvf.getId(), VmTemplateReturnForOvf.getName(), VmEntityType.TEMPLATE, null, null, storageDomainId, ovfData, null);
    List<OvfEntityData> expectedResult = new ArrayList<>();
    List<OvfEntityData> expectedResultQuery1 = new ArrayList<>();
    expectedResultQuery1.add(ovfEntityData);
    expectedResult.add(ovfEntityData);
    VmTemplate VmTemplateReturnForOvf2 = new VmTemplate();
    VmTemplateReturnForOvf2.setId(newVmTemplateGuid2);
    VmTemplateReturnForOvf2.setName("Name2");
    String ovfData2 = new String("OVF data for the second Template");
    OvfEntityData ovfEntityData2 = new OvfEntityData(VmTemplateReturnForOvf2.getId(), VmTemplateReturnForOvf2.getName(), VmEntityType.TEMPLATE, null, null, storageDomainId, ovfData2, null);
    expectedResult.add(ovfEntityData2);
    List<OvfEntityData> expectedResultQuery2 = new ArrayList<>();
    expectedResultQuery2.add(ovfEntityData);
    // Mock the Daos
    when(unregisteredOVFDataDaoMock.getAllForStorageDomainByEntityType(storageDomainId, entityType)).thenReturn(expectedResult);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmTemplateGuid, storageDomainId)).thenReturn(expectedResultQuery1);
    when(unregisteredOVFDataDaoMock.getByEntityIdAndStorageDomain(newVmTemplateGuid2, storageDomainId)).thenReturn(expectedResultQuery2);
    // Mock OVF
    OvfHelper ovfHelperMock = mock(OvfHelper.class);
    doReturn(ovfHelperMock).when(getQuery()).getOvfHelper();
    when(ovfHelperMock.readVmTemplateFromOvf(ovfData)).thenReturn(VmTemplateReturnForOvf);
    when(ovfHelperMock.readVmTemplateFromOvf(ovfData2)).thenReturn(VmTemplateReturnForOvf2);
}
#end_block

#method_before
@Before
public void setUp() {
    doReturn(new ArrayList<DiskImage>()).when(ovfUpdateProcessHelper).getAllImageSnapshots(any(DiskImage.class));
    // init members
    initMembers();
    // mock ovf data updater methods
    doNothing().when(ovfUpdateProcessHelper).loadTemplateData(any(VmTemplate.class));
    doNothing().when(ovfUpdateProcessHelper).loadVmData(any(VM.class));
    doNothing().when(command).updateVmDisksFromDb(any(VM.class));
    doNothing().when(command).updateTemplateDisksFromDb(any(VmTemplate.class));
    // dao related mocks.
    doReturn(1L).when(vmStaticDao).getDbGeneration(any(Guid.class));
    doReturn(pool1).when(command).getStoragePool();
    List<Snapshot> snapshots = new ArrayList<>();
    doReturn(snapshots).when(snapshotDao).getAllWithConfiguration(any(Guid.class));
    mockAnswers();
}
#method_after
@Before
public void setUp() {
    doReturn(new ArrayList<DiskImage>()).when(ovfUpdateProcessHelper).getAllImageSnapshots(any(DiskImage.class));
    // init members
    initMembers();
    // mock ovf data updater methods
    doNothing().when(ovfUpdateProcessHelper).loadTemplateData(any(VmTemplate.class));
    doNothing().when(ovfUpdateProcessHelper).loadVmData(any(VM.class));
    doNothing().when(command).updateVmDisksFromDb(any(VM.class));
    doNothing().when(command).updateTemplateDisksFromDb(any(VmTemplate.class));
    // dao related mocks.
    doReturn(1L).when(vmStaticDao).getDbGeneration(any(Guid.class));
    doReturn(pool1).when(command).getStoragePool();
    List<Snapshot> snapshots = new ArrayList<>();
    doReturn(snapshots).when(snapshotDao).getAllWithConfiguration(any(Guid.class));
    // needed for ovf writer utility
    injectorRule.bind(ClusterDao.class, clusterDao);
    mockAnswers();
}
#end_block

#method_before
public static void setTooltipOnElement(Element e, SafeHtml tooltip) {
    setTooltipOnElement(e, tooltip, TooltipConfig.PLACEMENT);
}
#method_after
public static void setTooltipOnElement(Element e, SafeHtml tooltip) {
    setTooltipOnElement(e, tooltip, new TooltipConfig());
}
#end_block

#method_before
public static void setTooltipOnElement(Element e, SafeHtml tooltip, Placement placement) {
    setTooltipOnElement(e, tooltip, placement, getTooltipTemplate(null));
}
#method_after
public static void setTooltipOnElement(Element e, SafeHtml tooltip, Placement placement) {
    setTooltipOnElement(e, tooltip, new TooltipConfig().setPlacement(placement));
}
#end_block

#method_before
public static void setTooltipOnElement(Element e, SafeHtml tooltip, Placement placement, String template) {
    String tooltipHtmlString = "";
    if (tooltip != null) {
        tooltipHtmlString = tooltip.asString().trim();
    }
    boolean destroyFirst = TOOLTIP_REL_VALUE.equals(e.getAttribute(REL_ATTR));
    if (destroyFirst) {
        e.removeAttribute(TITLE_ATTR);
        e.removeAttribute(REL_ATTR);
        destroyTooltip(e);
    }
    boolean tooltipValid = !tooltipHtmlString.isEmpty();
    if (tooltipValid) {
        e.setTitle(tooltipHtmlString);
        e.setAttribute(REL_ATTR, TOOLTIP_REL_VALUE);
        createTooltip(e, placement.getCssName(), template);
    }
}
#method_after
public static void setTooltipOnElement(Element e, SafeHtml tooltip, TooltipConfig config) {
    // Try not to set (destroy & create) the same tooltip again.
    if (sameTooltipOnElement(e, tooltip)) {
        return;
    }
    // Destroy existing tooltip first.
    destroyTooltip(e);
    // Create new tooltip.
    String tooltipHtmlString = getTooltipHtmlString(tooltip);
    if (!tooltipHtmlString.isEmpty()) {
        createTooltipImpl(e, tooltipHtmlString, config.getPlacement().getCssName(), config.getTooltipTemplate(), config.isForceShow());
        // Update reaper lists.
        if (config.isForCellWidgetElement()) {
            cellWidgetElementReapList.add(e);
        } else if (isPopupContentElement(e)) {
            popupContentElementReapList.add(e);
        }
    }
}
#end_block

#method_before
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>();
}
#method_after
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>(ElementTooltipUtils.HANDLED_CELL_EVENTS);
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, C value, NativeEvent event, ValueUpdater<C> valueUpdater) {
    ElementTooltipUtils.setTooltipOnElement(parent, getTooltip(value));
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, C value, NativeEvent event, ValueUpdater<C> valueUpdater) {
    ElementTooltipUtils.handleCellEvent(event, parent, getTooltip(value));
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#end_block

#method_before
public SafeHtml getTooltip(C value) {
    return null;
}
#method_after
public SafeHtml getTooltip(C value) {
    return tooltipFallback;
}
#end_block

#method_before
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>();
}
#method_after
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>(ElementTooltipUtils.HANDLED_CELL_EVENTS);
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, C value, NativeEvent event, ValueUpdater<C> valueUpdater) {
    ElementTooltipUtils.setTooltipOnElement(parent, getTooltip(value));
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, C value, NativeEvent event, ValueUpdater<C> valueUpdater) {
    ElementTooltipUtils.handleCellEvent(event, parent, getTooltip(value));
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#end_block

#method_before
public SafeHtml getTooltip(C value) {
    return null;
}
#method_after
public SafeHtml getTooltip(C value) {
    return tooltipFallback;
}
#end_block

#method_before
private void applyTooltip() {
    if (getWidget() != null && tooltip != null) {
        String template = ElementTooltipUtils.getTooltipTemplate(extraTooltipClassNames.trim());
        ElementTooltipUtils.setTooltipOnElement(getWidget().getElement(), tooltip, placement, template);
    }
}
#method_after
private void applyTooltip() {
    if (getWidget() == null) {
        return;
    }
    // Apply tooltip if the widget is attached to live DOM.
    if (widgetAttached && tooltip != null) {
        ElementTooltipUtils.setTooltipOnElement(getWidget().getElement(), tooltip, tooltipConfig);
    } else // Destroy tooltip if the widget is detached from live DOM.
    if (!widgetAttached) {
        ElementTooltipUtils.destroyTooltip(getWidget().getElement());
    }
}
#end_block

#method_before
public void setHtml(SafeHtml html) {
    // $NON-NLS-1$
    assert html != null : "Tooltip HTML content cannot be null";
    if (tooltip == null || !tooltip.asString().equals(html.asString())) {
        tooltip = html;
        applyTooltip();
    }
}
#method_after
public void setHtml(SafeHtml html) {
    // $NON-NLS-1$
    assert html != null : "Tooltip HTML content cannot be null";
    if (tooltip == null || !tooltip.asString().equals(html.asString())) {
        tooltip = html;
        scheduleTooltipUpdate();
    }
}
#end_block

#method_before
public void setPlacement(Placement placement) {
    this.placement = placement;
}
#method_after
public void setPlacement(Placement placement) {
    tooltipConfig.setPlacement(placement);
}
#end_block

#method_before
public void setMaxWidth(Width width) {
    // $NON-NLS-1$
    extraTooltipClassNames += " " + width.getClassName();
}
#method_after
public void setMaxWidth(TooltipWidth width) {
    tooltipConfig.addTooltipClassName(width.getClassName());
}
#end_block

#method_before
public void setText(SafeHtml text) {
    setTooltipText(text.asString());
}
#method_after
public void setText(SafeHtml text) {
    // "text" can actually contain HTML markup.
    tooltip.setHtml(useItalic ? wrapItalic(text) : text);
}
#end_block

#method_before
private String wrapItalic(String text) {
    if (text == null || text.isEmpty() || text.contains("<i>")) {
        // $NON-NLS-1$
        return text;
    }
    // $NON-NLS-1$ //$NON-NLS-2$
    return text = "<i>" + text + "</i>";
}
#method_after
private SafeHtml wrapItalic(SafeHtml text) {
    if (text.asString().startsWith("<i>")) {
        // already wrapped in italic
        return text;
    }
    return new SafeHtmlBuilder().appendHtmlConstant(// $NON-NLS-1$
    "<i>").append(text).appendHtmlConstant(// $NON-NLS-1$
    "</i>").toSafeHtml();
}
#end_block

#method_before
public void setTooltipMaxWidth(Width width) {
    tooltip.setMaxWidth(width);
}
#method_after
public void setTooltipMaxWidth(TooltipWidth width) {
    tooltip.setMaxWidth(width);
}
#end_block

#method_before
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>(super.getConsumedEvents());
}
#method_after
@Override
public Set<String> getConsumedEvents() {
    HashSet<String> set = new HashSet<>(super.getConsumedEvents());
    set.addAll(ElementTooltipUtils.HANDLED_CELL_EVENTS);
    return set;
}
#end_block

#method_before
@Override
public void onBrowserEvent(com.google.gwt.cell.client.Cell.Context context, Element parent, Boolean value, NativeEvent event, ValueUpdater<Boolean> valueUpdater) {
    ElementTooltipUtils.setTooltipOnElement(parent, getTooltip());
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, Boolean value, NativeEvent event, ValueUpdater<Boolean> valueUpdater) {
    ElementTooltipUtils.handleCellEvent(event, parent, getTooltip(value));
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#end_block

#method_before
public SafeHtml getTooltip() {
    return tooltip;
}
#method_after
public SafeHtml getTooltip(Boolean value) {
    return tooltipFallback;
}
#end_block

#method_before
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>();
}
#method_after
@Override
public Set<String> getConsumedEvents() {
    return new HashSet<>(ElementTooltipUtils.HANDLED_CELL_EVENTS);
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, C value, NativeEvent event, ValueUpdater<C> valueUpdater) {
    SafeHtml tooltip = getTooltip(value);
    if (tooltip == null) {
        tooltip = getTooltip(value, parent);
    }
    ElementTooltipUtils.setTooltipOnElement(parent, tooltip);
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, C value, NativeEvent event, ValueUpdater<C> valueUpdater) {
    SafeHtml tooltip = getTooltip(value);
    if (tooltip == null) {
        tooltip = getTooltip(value, parent);
    }
    ElementTooltipUtils.handleCellEvent(event, parent, tooltip);
    super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#end_block

#method_before
public SafeHtml getTooltip(C value) {
    return null;
}
#method_after
public SafeHtml getTooltip(C value) {
    return tooltipFallback;
}
#end_block

#method_before
public SafeHtml getTooltip(C value, Element parent) {
    return null;
}
#method_after
public SafeHtml getTooltip(C value, Element parent) {
    return getTooltip(value);
}
#end_block

#method_before
@Override
public void onBrowserEvent(Context context, Element parent, Boolean value, NativeEvent event, ValueUpdater<Boolean> valueUpdater) {
    String type = event.getType();
    boolean enterPressed = BrowserEvents.KEYDOWN.equals(type) && event.getKeyCode() == KeyCodes.KEY_ENTER;
    if (BrowserEvents.CHANGE.equals(type) || enterPressed) {
        InputElement input = parent.getFirstChild().cast();
        boolean isChecked = input.isChecked();
        /*
             * Toggle the value if the enter key was pressed and the cell handles selection or doesn't depend on
             * selection. If the cell depends on selection but doesn't handle selection, then ignore the enter key and
             * let the SelectionEventManager determine which keys will trigger a change.
             */
        if (enterPressed && (handlesSelection() || !dependsOnSelection())) {
            isChecked = !isChecked;
            input.setChecked(isChecked);
        }
        if (value.booleanValue() != isChecked && !dependsOnSelection()) {
            setViewData(context.getKey(), isChecked);
        } else {
            clearViewData(context.getKey());
        }
        if (valueUpdater != null) {
            valueUpdater.update(isChecked);
        }
    }
// super.onBrowserEvent(context, parent, value, event, valueUpdater);
}
#method_after
@Override
public void onBrowserEvent(Context context, Element parent, Boolean value, NativeEvent event, ValueUpdater<Boolean> valueUpdater) {
    String type = event.getType();
    boolean enterPressed = BrowserEvents.KEYDOWN.equals(type) && event.getKeyCode() == KeyCodes.KEY_ENTER;
    if (BrowserEvents.CHANGE.equals(type) || enterPressed) {
        InputElement input = parent.getFirstChild().cast();
        boolean isChecked = input.isChecked();
        /*
             * Toggle the value if the enter key was pressed and the cell handles selection or doesn't depend on
             * selection. If the cell depends on selection but doesn't handle selection, then ignore the enter key and
             * let the SelectionEventManager determine which keys will trigger a change.
             */
        if (enterPressed && (handlesSelection() || !dependsOnSelection())) {
            isChecked = !isChecked;
            input.setChecked(isChecked);
        }
        if (value.booleanValue() != isChecked && !dependsOnSelection()) {
            setViewData(context.getKey(), isChecked);
        } else {
            clearViewData(context.getKey());
        }
        if (valueUpdater != null) {
            valueUpdater.update(isChecked);
        }
    }
}
#end_block

#method_before
public void onBrowserEvent(Context context, Element elem, final T object, NativeEvent event) {
    final int index = context.getIndex();
    ValueUpdater<C> valueUpdater = (getFieldUpdater() == null) ? null : new ValueUpdater<C>() {

        @Override
        public void update(C value) {
            getFieldUpdater().update(index, object, value);
        }
    };
    getCell().onBrowserEvent(context, elem, getValue(object), event, valueUpdater);
}
#method_after
@Override
public void onBrowserEvent(Context context, Element elem, T object, NativeEvent event) {
    getCell().setTooltipFallback(getTooltip(object));
    super.onBrowserEvent(context, elem, object, event);
}
#end_block

#method_before
protected void grayOutItem(ArrayList<String> grayOutReasons, LunModel model, EntityModelCellTable<ListModel<LunModel>> table) {
    for (int row = 0; row < table.getRowCount(); row++) {
        if (table.getVisibleItem(row).equals(model)) {
            TableRowElement tableRowElement = table.getRowElement(row);
            // $NON-NLS-1$
            tableRowElement.setPropertyBoolean("disabled", true);
            updateInputTitle(grayOutReasons, tableRowElement);
        }
    }
}
#method_after
protected void grayOutItem(ArrayList<String> grayOutReasons, LunModel model, EntityModelCellTable<ListModel<LunModel>> table) {
    for (int row = 0; row < table.getRowCount(); row++) {
        TableRowElement tableRowElement = table.getRowElement(row);
        if (table.getVisibleItem(row).equals(model)) {
            // $NON-NLS-1$
            tableRowElement.setPropertyBoolean("disabled", true);
            updateInputTitle(grayOutReasons, tableRowElement);
        } else {
            ElementTooltipUtils.destroyTooltip(tableRowElement);
        }
    }
}
#end_block

#method_before
private void updateBadge() {
    badge.setVisible(count != 1);
    badgeText.setText(String.valueOf(count));
    if (badge.isVisible()) {
        SafeHtmlBuilder builder = new SafeHtmlBuilder();
        for (SafeHtml message : messagesList) {
            builder.append(message);
        }
        ElementTooltipUtils.setTooltipOnElement(getElement(), builder.toSafeHtml());
    }
}
#method_after
private void updateBadge() {
    badge.setVisible(count != 1);
    badgeText.setText(String.valueOf(count));
    if (badge.isVisible()) {
        SafeHtmlBuilder builder = new SafeHtmlBuilder();
        for (SafeHtml message : messagesList) {
            builder.append(message);
        }
        alertTooltip.setHtml(builder.toSafeHtml());
    }
}
#end_block

#method_before
@Override
public void setTooltip(SafeHtml tooltip) {
    ElementTooltipUtils.setTooltipOnElement(getElement(), tooltip);
}
#method_after
@Override
public void setTooltip(SafeHtml tooltip) {
    buttonTooltip.setHtml(tooltip);
}
#end_block

#method_before
@Override
public void setTooltip(SafeHtml tooltip, Placement placement) {
    ElementTooltipUtils.setTooltipOnElement(getElement(), tooltip, placement);
}
#method_after
@Override
public void setTooltip(SafeHtml tooltip, Placement placement) {
    buttonTooltip.setHtml(tooltip);
    buttonTooltip.setPlacement(placement);
}
#end_block

#method_before
private void updateKeyTitle(KeyValueLineModel object) {
    String selectedKey = object.getKeys().getSelectedItem();
    if (selectedKey != null) {
        ElementTooltipUtils.setTooltipOnElement(keyField.getElement(), SafeHtmlUtils.fromString(selectedKey));
    }
}
#method_after
private void updateKeyTitle(KeyValueLineModel object) {
    String selectedKey = object.getKeys().getSelectedItem();
    if (selectedKey != null) {
        keyField.setWidgetTooltip(selectedKey);
    }
}
#end_block

#method_before
void attachAlert(AlertPanel alertPanel) {
    // Add widget's DOM element straight into HTML body
    RootPanel.get().add(alertPanel);
    // Use tool tip in case the textual content overflows
    Element messageDivElement = alertPanel.getMessageAt(0).getElement();
    if (ElementUtils.detectHorizontalOverflow(messageDivElement)) {
        SafeHtml tooltipContent = SafeHtmlUtils.fromString(messageDivElement.getInnerText());
        ElementTooltipUtils.setTooltipOnElement(alertPanel.getElement(), tooltipContent, Placement.BOTTOM);
    }
}
#method_after
void attachAlert(AlertPanel alertPanel) {
    // Add widget's DOM element straight into HTML body
    RootPanel.get().add(alertPanel);
    // Use tool tip in case the textual content overflows
    Element messageDivElement = alertPanel.getMessageAt(0).getElement();
    if (ElementUtils.detectHorizontalOverflow(messageDivElement)) {
        alertPanel.getAlertTooltip().setText(messageDivElement.getInnerText());
        alertPanel.getAlertTooltip().setPlacement(Placement.BOTTOM);
    }
}
#end_block

#method_before
MenuBar updateContextMenu(MenuBar menuBar, List<ActionButtonDefinition<T>> actions, final PopupPanel popupPanel, boolean removeOldItems) {
    if (removeOldItems) {
        menuBar.clearItems();
    }
    for (final ActionButtonDefinition<T> buttonDef : actions) {
        if (buttonDef instanceof UiMenuBarButtonDefinition) {
            UiMenuBarButtonDefinition<T> menuBarDef = (UiMenuBarButtonDefinition<T>) buttonDef;
            if (menuBarDef.isAsTitle()) {
                MenuItemSeparator titleItem = new TitleMenuItemSeparator(buttonDef.getText());
                menuBar.addSeparator(titleItem);
                titleItem.setVisible(buttonDef.isVisible(getSelectedItems()));
                updateContextMenu(menuBar, menuBarDef.getSubActions(), popupPanel, false);
            } else {
                MenuItem newMenu = new MenuItem(buttonDef.getText(), updateContextMenu(new MenuBar(true), menuBarDef.getSubActions(), popupPanel));
                updateMenuItem(newMenu, buttonDef);
                menuBar.addItem(newMenu);
            }
        } else {
            MenuItem item = new MenuItem(buttonDef.getText(), new Command() {

                @Override
                public void execute() {
                    popupPanel.hide();
                    buttonDef.onClick(getSelectedItems());
                }
            });
            updateMenuItem(item, buttonDef);
            menuBar.addItem(item);
        }
    }
    return menuBar;
}
#method_after
MenuBar updateContextMenu(MenuBar menuBar, List<ActionButtonDefinition<T>> actions, final PopupPanel popupPanel, boolean removeOldItems) {
    if (removeOldItems) {
        ElementTooltipUtils.destroyMenuItemTooltips(menuBar);
        menuBar.clearItems();
    }
    for (final ActionButtonDefinition<T> buttonDef : actions) {
        if (buttonDef instanceof UiMenuBarButtonDefinition) {
            UiMenuBarButtonDefinition<T> menuBarDef = (UiMenuBarButtonDefinition<T>) buttonDef;
            if (menuBarDef.isAsTitle()) {
                MenuItemSeparator titleItem = new TitleMenuItemSeparator(buttonDef.getText());
                menuBar.addSeparator(titleItem);
                titleItem.setVisible(buttonDef.isVisible(getSelectedItems()));
                updateContextMenu(menuBar, menuBarDef.getSubActions(), popupPanel, false);
            } else {
                MenuItem newMenu = new MenuItem(buttonDef.getText(), updateContextMenu(new MenuBar(true), menuBarDef.getSubActions(), popupPanel));
                updateMenuItem(newMenu, buttonDef);
                menuBar.addItem(newMenu);
            }
        } else {
            MenuItem item = new MenuItem(buttonDef.getText(), new Command() {

                @Override
                public void execute() {
                    popupPanel.hide();
                    buttonDef.onClick(getSelectedItems());
                }
            });
            updateMenuItem(item, buttonDef);
            menuBar.addItem(item);
        }
    }
    return menuBar;
}
#end_block

#method_before
public void validate(List<String> errors) {
    int rowCount = getRowCount();
    // $NON-NLS-1$
    assert errors != null && errors.size() == rowCount : "errors must be the same size as the contents of the table!";
    for (int i = 0; i < rowCount; ++i) {
        Element element = getRowElement(i);
        // $NON-NLS-1$
        assert element != null : "element shouldn't be null if errors is the same size as the contents of the table!";
        String error = errors.get(i);
        boolean valid = StringUtils.isEmpty(error);
        if (!valid) {
            ElementTooltipUtils.setTooltipOnElement(element, SafeHtmlUtils.fromString(error));
            element.addClassName(style.invalidRow());
        } else {
            element.removeClassName(style.invalidRow());
        }
    }
}
#method_after
public void validate(List<String> errors) {
    int rowCount = getRowCount();
    // $NON-NLS-1$
    assert errors != null && errors.size() == rowCount : "errors must be the same size as the contents of the table!";
    for (int i = 0; i < rowCount; ++i) {
        Element element = getRowElement(i);
        // $NON-NLS-1$
        assert element != null : "element shouldn't be null if errors is the same size as the contents of the table!";
        String error = errors.get(i);
        boolean valid = StringUtils.isEmpty(error);
        if (!valid) {
            ElementTooltipUtils.setTooltipOnElement(element, SafeHtmlUtils.fromString(error));
            element.addClassName(style.invalidRow());
        } else {
            ElementTooltipUtils.destroyTooltip(element);
            element.removeClassName(style.invalidRow());
        }
    }
}
#end_block

#method_before
protected void styleItem(TreeItem item, boolean enabled) {
    Element tableElm = DOM.getFirstChild(item.getElement());
    // $NON-NLS-1$ //$NON-NLS-2$
    tableElm.setAttribute("width", "100%");
    // $NON-NLS-1$
    Element col = tableElm.getElementsByTagName("td").getItem(0);
    // $NON-NLS-1$ //$NON-NLS-2$
    col.setAttribute("width", "20px");
    if (!enabled) {
        // $NON-NLS-1$
        NodeList<Element> inputs = item.getElement().getElementsByTagName("input");
        for (int i = 0; i < inputs.getLength(); i++) {
            disableElement(inputs.getItem(i));
        }
        // $NON-NLS-1$
        NodeList<Element> spans = item.getElement().getElementsByTagName("span");
        for (int i = 0; i < spans.getLength(); i++) {
            disableElement(spans.getItem(i));
        }
    }
    boolean isLeafEmpty = item.getUserObject() != null && item.getUserObject().equals(true);
    if (isLeafEmpty) {
        // $NON-NLS-1$
        item.getElement().getElementsByTagName("td").getItem(0).getStyle().setVisibility(Visibility.HIDDEN);
    }
}
#method_after
protected void styleItem(TreeItem item, boolean enabled) {
    Element tableElm = DOM.getFirstChild(item.getElement());
    // $NON-NLS-1$ //$NON-NLS-2$
    tableElm.setAttribute("width", "100%");
    // $NON-NLS-1$
    Element col = tableElm.getElementsByTagName("td").getItem(0);
    // $NON-NLS-1$ //$NON-NLS-2$
    col.setAttribute("width", "20px");
    // $NON-NLS-1$
    NodeList<Element> inputs = item.getElement().getElementsByTagName("input");
    for (int i = 0; i < inputs.getLength(); i++) {
        if (!enabled) {
            disableElement(inputs.getItem(i));
        } else {
            ElementTooltipUtils.destroyTooltip(inputs.getItem(i));
        }
    }
    // $NON-NLS-1$
    NodeList<Element> spans = item.getElement().getElementsByTagName("span");
    for (int i = 0; i < spans.getLength(); i++) {
        if (!enabled) {
            disableElement(spans.getItem(i));
        } else {
            ElementTooltipUtils.destroyTooltip(spans.getItem(i));
        }
    }
    boolean isLeafEmpty = item.getUserObject() != null && item.getUserObject().equals(true);
    if (isLeafEmpty) {
        // $NON-NLS-1$
        item.getElement().getElementsByTagName("td").getItem(0).getStyle().setVisibility(Visibility.HIDDEN);
    }
}
#end_block

#method_before
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> retrieveCommand(x.getId()).reacquireLocks());
}
#method_after
@PostConstruct
private void handleUnmanagedCommands() {
    List<AsyncTask> asyncTasks = asyncTaskDao.getAll();
    Set<Guid> asyncTaskManagerManagedCommands = asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getRootCommandId()).collect(Collectors.toSet());
    asyncTaskManagerManagedCommands.addAll(asyncTasks.stream().filter(x -> x.getVdsmTaskId() != null).map(x -> x.getCommandId()).collect(Collectors.toSet()));
    // this will update all the commands that aren't managed by callback/async task manager and are active
    // and will set their status to ENDED_WITH_FAILURE.
    getCommands(false).stream().filter(x -> !x.isCallbackEnabled()).filter(x -> x.getCommandStatus() == CommandStatus.ACTIVE).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).forEach(x -> commandsCache.updateCommandStatus(x.getId(), CommandStatus.ENDED_WITH_FAILURE));
    // active commands managed by callbacks and not managed by async task manager need to reacquire locks
    // on engine restart
    getCommands(false).stream().filter(x -> x.isCallbackEnabled()).filter(x -> !x.isCallbackNotified()).filter(x -> x.getCommandStatus().isDuringExecution()).filter(x -> !asyncTaskManagerManagedCommands.contains(x.getId())).map(x -> retrieveCommand(x.getId())).filter(Objects::nonNull).forEach(CommandBase::reacquireLocks);
}
#end_block

#method_before
private CommandBase<?> retrieveCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        command.setCommandStatus(cmdEntity.getCommandStatus(), false);
        command.setCommandData(cmdEntity.getData());
        command.setReturnValue(cmdEntity.getReturnValue());
        if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
            CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
            if (parentCommand != null) {
                command.getParameters().setParentParameters(parentCommand.getParameters());
            }
        }
    }
    return command;
}
#method_after
private CommandBase<?> retrieveCommand(CommandEntity cmdEntity, CommandContext cmdContext) {
    CommandBase<?> command = null;
    if (cmdEntity != null) {
        if (cmdContext == null) {
            cmdContext = new CommandContext(new EngineContext()).withExecutionContext(new ExecutionContext());
        }
        command = CommandsFactory.createCommand(cmdEntity.getCommandType(), cmdEntity.getCommandParameters(), cmdContext);
        if (command != null) {
            command.setCommandStatus(cmdEntity.getCommandStatus(), false);
            command.setCommandData(cmdEntity.getData());
            command.setReturnValue(cmdEntity.getReturnValue());
            if (!Guid.isNullOrEmpty(cmdEntity.getParentCommandId()) && !cmdEntity.getParentCommandId().equals(cmdEntity.getId()) && command.getParameters().getParentParameters() == null) {
                CommandBase<?> parentCommand = retrieveCommand(cmdEntity.getParentCommandId());
                if (parentCommand != null) {
                    command.getParameters().setParentParameters(parentCommand.getParameters());
                }
            }
        }
    }
    return command;
}
#end_block

#method_before
public VdcReturnValueBase endAction(SPMTask task) {
    AsyncTask dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandHelper.buildCommand(actionType, parameters, coco.retrieveCommandContext(dbAsyncTask.getCommandId()).getExecutionContext(), coco.getCommandStatus(dbAsyncTask.getCommandId()));
    return new DecoratedCommand<>(command).endAction();
}
#method_after
public VdcReturnValueBase endAction(SPMTask task) {
    AsyncTask dbAsyncTask = task.getParameters().getDbAsyncTask();
    VdcActionType actionType = getEndActionType(dbAsyncTask);
    VdcActionParametersBase parameters = dbAsyncTask.getActionParameters();
    CommandBase<?> command = CommandHelper.buildCommand(actionType, parameters, coco.retrieveCommandContext(dbAsyncTask.getRootCommandId()).getExecutionContext(), coco.getCommandStatus(dbAsyncTask.getCommandId()));
    return new DecoratedCommand<>(command).endAction();
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean valid = true;
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        valid = failVmStatusIllegal();
    }
    if (getParameters().getVm().getCpuPerSocket() > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET);
    }
    if (getParameters().getVm().getThreadsPerCpu() > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, getVm().getClusterCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU);
    }
    if (getParameters().getVm().getNumOfSockets() > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS);
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
            valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        } else {
            OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
            if (!osRepository.isCpuHotplugSupported(getVm().getVmOsId())) {
                valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED_FOR_GUEST_OS);
            }
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        valid = failValidation(EngineMessage.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    } else {
        OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
        if (!osRepository.isCpuHotunplugSupported(getVm().getVmOsId())) {
            valid = failValidation(EngineMessage.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED_FOR_GUEST_OS);
        }
    }
    return valid;
}
#method_after
@Override
protected boolean validate() {
    boolean valid = true;
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        valid = failVmStatusIllegal();
    }
    if (getParameters().getVm().getCpuPerSocket() > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET);
    }
    if (getParameters().getVm().getThreadsPerCpu() > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, getVm().getClusterCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU);
    }
    if (getParameters().getVm().getNumOfSockets() > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS);
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
            valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        } else if (!osRepository.isCpuHotplugSupported(getVm().getVmOsId())) {
            valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED_FOR_GUEST_OS, String.format("$guestOS %1$s", osRepository.getOsName(getVm().getVmOsId())), String.format("$architecture %1$s", getVm().getClusterArch()));
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        valid = failValidation(EngineMessage.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    } else if (!osRepository.isCpuHotunplugSupported(getVm().getVmOsId())) {
        valid = failValidation(EngineMessage.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED_FOR_GUEST_OS, String.format("$guestOS %1$s", osRepository.getOsName(getVm().getVmOsId())), String.format("$architecture %1$s", getVm().getClusterArch()));
    }
    return valid;
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean valid = true;
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        valid = failVmStatusIllegal();
    }
    if (getParameters().getVm().getCpuPerSocket() > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET);
    }
    if (getParameters().getVm().getThreadsPerCpu() > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, getVm().getClusterCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU);
    }
    if (getParameters().getVm().getNumOfSockets() > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS);
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
            valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        } else {
            OsRepository osRepository = SimpleDependencyInjector.getInstance().get(OsRepository.class);
            if (!osRepository.isCpuHotplugSupported(getVm().getVmOsId())) {
                valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED_FOR_GUEST_OS);
            }
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        valid = failValidation(EngineMessage.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    }
    return valid;
}
#method_after
@Override
protected boolean validate() {
    boolean valid = true;
    if (getVm() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        valid = failVmStatusIllegal();
    }
    if (getParameters().getVm().getCpuPerSocket() > Config.<Integer>getValue(ConfigValues.MaxNumOfCpuPerSocket, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET);
    }
    if (getParameters().getVm().getThreadsPerCpu() > Config.<Integer>getValue(ConfigValues.MaxNumOfThreadsPerCpu, getVm().getClusterCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU);
    }
    if (getParameters().getVm().getNumOfSockets() > Config.<Integer>getValue(ConfigValues.MaxNumOfVmSockets, getVm().getCompatibilityVersion().getValue())) {
        valid = failValidation(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS);
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
            valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        } else if (!osRepository.isCpuHotplugSupported(getVm().getVmOsId())) {
            valid = failValidation(EngineMessage.HOT_PLUG_CPU_IS_NOT_SUPPORTED_FOR_GUEST_OS, String.format("$guestOS %1$s", osRepository.getOsName(getVm().getVmOsId())), String.format("$architecture %1$s", getVm().getClusterArch()));
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getCompatibilityVersion(), getVm().getClusterArch())) {
        valid = failValidation(EngineMessage.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    }
    return valid;
}
#end_block

#method_before
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId) {
    return isImagesExists(images, storagePoolId, new ArrayList<>());
}
#method_after
public static boolean isImagesExists(Iterable<DiskImage> images, Guid storagePoolId) {
    for (DiskImage image : images) {
        DiskImage fromIrs = isImageExist(storagePoolId, image);
        if (fromIrs == null) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = macPool.allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    } else {
        if (isExternalMacsToBeReported()) {
            reportExternalMacs();
        } else {
            reassignBadMacs(nics);
        }
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getEffectiveCompatibilityVersion());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager(macPool);
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getClusterId(), getStoragePoolId(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    List<VmNetworkInterface> nics = getVm().getInterfaces();
    vmInterfaceManager.sortVmNics(nics, getVm().getStaticData().getManagedDeviceMap());
    // If we import it as a new entity, then we allocate all MAC addresses in advance
    if (getParameters().isImportAsNewEntity()) {
        List<String> macAddresses = macPool.allocateMacAddresses(nics.size());
        for (int i = 0; i < nics.size(); ++i) {
            nics.get(i).setMacAddress(macAddresses.get(i));
        }
    } else {
        if (isExternalMacsToBeReported()) {
            reportExternalMacs();
        }
    }
    if (getParameters().isReassignBadMacs()) {
        reassignBadMacs(nics);
    }
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser());
        vmInterfaceManager.add(iface, getCompensationContext(), !getParameters().isImportAsNewEntity(), getVm().getOs(), getEffectiveCompatibilityVersion());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
private boolean validateExternalVnicProfileMapping() {
    final Set<EngineMessage> externalVnicProfileMappingValidationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId());
    if (externalVnicProfileMappingValidationResult.isEmpty()) {
        return true;
    } else {
        return failValidation(new ArrayList<>(externalVnicProfileMappingValidationResult));
    }
}
#method_after
private boolean validateExternalVnicProfileMapping() {
    final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId());
    return validate(validationResult);
}
#end_block

#method_before
private boolean validateMacs(VM vm) {
    if (!getParameters().isReassignBadMacs()) {
        return true;
    }
    final List<VmNetworkInterface> vnics = vm.getInterfaces();
    return reportDuplicateMacs(vnics);
}
#method_after
private boolean validateMacs(VM vm) {
    if (getParameters().isReassignBadMacs()) {
        return true;
    }
    final List<VmNetworkInterface> vnics = vm.getInterfaces();
    return reportDuplicateMacs(vnics);
}
#end_block

#method_before
private boolean reportDuplicateMacs(List<VmNetworkInterface> vnics) {
    final MacPool macPool = getMacPool();
    if (!macPool.isDuplicateMacAddressesAllowed() && foundBadMacs(vnics, macPool::isMacInUse)) {
        return failValidation(EngineMessage.NETWORK_MAC_ADDRESS_IN_USE);
    }
    return true;
}
#method_after
private boolean reportDuplicateMacs(List<VmNetworkInterface> vnics) {
    final MacPool macPool = getMacPool();
    return macPool.isDuplicateMacAddressesAllowed() || validate(validateForMacsInUse(vnics, macPool));
}
#end_block

#method_before
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    externalVnicProfileMappings = new ArrayList<>();
    VnicProfile vnicProfile = new VnicProfile();
    vnicProfile.setId(VNIC_PROFILE_ID);
    vnicProfile.setName(VNIC_PROFILE_NAME);
    vnicProfile.setNetworkId(TARGET_NETWORK_ID);
    optionalVnicProfile = Optional.of(vnicProfile);
    targetNetwork = new Network();
    targetNetwork.setName(TARGET_NETWORK_NAME);
    when(mockVmNetworkInterface.getNetworkName()).thenReturn(EXTERNAL_NETWORK_NAME);
    when(mockVmNetworkInterface.getVnicProfileName()).thenReturn(VNIC_PROFILE_NAME);
}
#method_after
@Before
public void setUp() {
    externalVnicProfileMappings = new ArrayList<>();
    VnicProfile vnicProfile = new VnicProfile();
    vnicProfile.setId(VNIC_PROFILE_ID);
    vnicProfile.setName(VNIC_PROFILE_NAME);
    vnicProfile.setNetworkId(TARGET_NETWORK_ID);
    targetNetwork = new Network();
    targetNetwork.setName(TARGET_NETWORK_NAME);
    when(mockVmNetworkInterface.getNetworkName()).thenReturn(EXTERNAL_NETWORK_NAME);
    when(mockVmNetworkInterface.getVnicProfileName()).thenReturn(VNIC_PROFILE_NAME);
    when(mockVnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
}
#end_block

#method_before
@Test
public void testUpdateNetworkInfoMappingNotFound() {
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface, never()).setVnicProfileId(any());
    verify(mockVmNetworkInterface, never()).setNetworkName(any());
    verify(mockVmNetworkInterface, never()).setVnicProfileName(any());
}
#method_after
@Test
public void testUpdateNetworkInfoMappingNotFound() {
    when(mockExternalVnicProfileMappingFinder.findMappingEntry(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(Optional.empty());
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockExternalVnicProfileMappingFinder).findMappingEntry(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface, never()).setVnicProfileId(any());
    verify(mockVmNetworkInterface, never()).setNetworkName(any());
    verify(mockVmNetworkInterface, never()).setVnicProfileName(any());
}
#end_block

#method_before
@Test
public void testUpdateNetworkInfo() {
    when(mockTargetVnicProfileFinder.findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(optionalVnicProfile);
    when(mockNetworkDao.get(TARGET_NETWORK_ID)).thenReturn(targetNetwork);
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface).setVnicProfileId(VNIC_PROFILE_ID);
    verify(mockVmNetworkInterface).setVnicProfileName(VNIC_PROFILE_NAME);
    verify(mockVmNetworkInterface).setNetworkName(TARGET_NETWORK_NAME);
}
#method_after
@Test
public void testUpdateNetworkInfo() {
    when(mockExternalVnicProfileMappingFinder.findMappingEntry(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(Optional.of(createMappingEntry(VNIC_PROFILE_ID)));
    when(mockNetworkDao.get(TARGET_NETWORK_ID)).thenReturn(targetNetwork);
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockExternalVnicProfileMappingFinder).findMappingEntry(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface).setVnicProfileId(VNIC_PROFILE_ID);
    verify(mockVmNetworkInterface).setVnicProfileName(VNIC_PROFILE_NAME);
    verify(mockVmNetworkInterface).setNetworkName(TARGET_NETWORK_NAME);
}
#end_block

#method_before
@Test
public void testUpdateNetworkInfoMappedToEmpty() {
    when(mockTargetVnicProfileFinder.findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(Optional.empty());
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface).setVnicProfileId(null);
    verify(mockVmNetworkInterface).setVnicProfileName(null);
    verify(mockVmNetworkInterface).setNetworkName(null);
}
#method_after
@Test
public void testUpdateNetworkInfoMappedToEmpty() {
    when(mockExternalVnicProfileMappingFinder.findMappingEntry(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(Optional.of(createMappingEntry(null)));
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockExternalVnicProfileMappingFinder).findMappingEntry(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface).setVnicProfileId(null);
    verify(mockVmNetworkInterface).setVnicProfileName(null);
    verify(mockVmNetworkInterface).setNetworkName(null);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        if (!validateMacs(vmFromConfiguration)) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData, getImages()))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    if (isImagesAlreadyOnTarget()) {
        if (!validateExternalVnicProfileMapping()) {
            return false;
        }
        ImportValidator importValidator = getImportValidator();
        if (!validate(importValidator.validateUnregisteredEntity(vmFromConfiguration, ovfEntityData, getImages()))) {
            return false;
        }
        setImagesWithStoragePoolId(getParameters().getStoragePoolId(), getVm().getImages());
    }
    return super.validate();
}
#end_block

#method_before
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
public void updateNetworkInfo(VmNetworkInterface vnic, Collection<ExternalVnicProfileMapping> externalVnicProfileMappings) {
    Optional<VnicProfile> targetVnicProfile = targetVnicProfileFinder.findTargetVnicProfile(vnic.getNetworkName(), vnic.getVnicProfileName(), externalVnicProfileMappings);
    if (targetVnicProfile != null) {
        if (targetVnicProfile.isPresent()) {
            final VnicProfile vnicProfile = targetVnicProfile.get();
            setTargetVnicProfile(vnic, vnicProfile.getId(), vnicProfile.getName(), getVnicProfileNetworkName(vnicProfile.getNetworkId()));
        } else {
            setTargetVnicProfile(vnic, null, null, null);
        }
    }
}
#method_after
public void updateNetworkInfo(VmNetworkInterface vnic, Collection<ExternalVnicProfileMapping> externalVnicProfileMappings) {
    final Optional<ExternalVnicProfileMapping> mappingEntry = externalVnicProfileMappingFinder.findMappingEntry(vnic.getNetworkName(), vnic.getVnicProfileName(), externalVnicProfileMappings);
    if (mappingEntry.isPresent()) {
        final Guid vnicProfileId = mappingEntry.get().getVnicProfileId();
        if (vnicProfileId == null) {
            setTargetVnicProfile(vnic, null, null, null);
        } else {
            final VnicProfile vnicProfile = vnicProfileDao.get(vnicProfileId);
            setTargetVnicProfile(vnic, vnicProfile.getId(), vnicProfile.getName(), getVnicProfileNetworkName(vnicProfile.getNetworkId()));
        }
    }
}
#end_block

#method_before
public void init(Map<String, String> paramMap) {
    constantDelay = Utils.getLong(paramMap.get("constantDelay"));
    randomDelay = Utils.getLong(paramMap.get("randomDelay"));
    networkLoad = Utils.splitString(paramMap.get("networkLoad"));
    cpuLoadList = Utils.splitString(paramMap.get("cpuLoad"));
    memLoad = Utils.splitString(paramMap.get("memLoad"));
    storageDelay = Utils.splitString(paramMap.get("storageDelay"));
    networkBridgeName = paramMap.get("networkBridgeName");
    cacheDir = paramMap.get("cacheDir");
    // Each run will store its logs separately
    logDir = paramMap.get("logDir") + "/" + System.currentTimeMillis();
    forwardVdsmServer = paramMap.get("forwardVdsmServer");
    vdsmPort = paramMap.get("vdsmPort");
    vmConfAndStatsConstants = paramMap.get("vmConfAndStatsConstants");
    vmConfAndStatsUpdateIntervals = paramMap.get("vmConfAndStatsUpdateIntervals");
    jsonHandlersThreadsPool = Integer.valueOf(paramMap.get("jsonHandlersThreadsPool"));
    architectureType = ArchitectureType.valueOf(paramMap.get("architectureType").toUpperCase());
    jsonEvents = Boolean.valueOf(paramMap.get("jsonEvents"));
    eventSupportedMethods = Utils.splitString(paramMap.get("eventSupportedMethods"));
    eventsThreadPool = Integer.valueOf(paramMap.get("eventsThreadPool"));
    jsonThreadPool = Integer.valueOf(paramMap.get("jsonThreadPool"));
    final String notLoggedMethods = paramMap.get("notLoggedMethods");
    if (notLoggedMethods != null && notLoggedMethods.trim().length() > 0) {
        final String[] methodNames = notLoggedMethods.split(",");
        for (String methodName : methodNames) {
            notLoggedMethodSet.add(methodName.trim());
        }
    }
    makeDir(cacheDir);
    makeDir(logDir);
    if (isProxyActive()) {
        targetServerUrl = getForwardVdsmServer() + ":" + getVdsmPort() + "/";
    }
}
#method_after
public void init(Map<String, String> paramMap) {
    constantDelay = Utils.getLong(paramMap.get("constantDelay"));
    randomDelay = Utils.getLong(paramMap.get("randomDelay"));
    networkLoad = Utils.splitString(paramMap.get("networkLoad"));
    cpuLoadList = Utils.splitString(paramMap.get("cpuLoad"));
    memLoad = Utils.splitString(paramMap.get("memLoad"));
    storageDelay = Utils.splitString(paramMap.get("storageDelay"));
    networkBridgeName = paramMap.get("networkBridgeName");
    cacheDir = paramMap.get("cacheDir");
    // Each run will store its logs separately
    logDir = paramMap.get("logDir") + "/" + System.currentTimeMillis();
    forwardVdsmServer = paramMap.get("forwardVdsmServer");
    vdsmPort = paramMap.get("vdsmPort");
    vmConfAndStatsConstants = paramMap.get("vmConfAndStatsConstants");
    vmConfAndStatsUpdateIntervals = paramMap.get("vmConfAndStatsUpdateIntervals");
    jsonHandlersThreadsPool = Integer.valueOf(paramMap.get("jsonHandlersThreadsPool"));
    architectureType = ArchitectureType.valueOf(paramMap.get("architectureType").toUpperCase());
    jsonEvents = Boolean.valueOf(paramMap.get("jsonEvents"));
    eventSupportedMethods = Utils.splitString(paramMap.get("eventSupportedMethods"));
    eventsThreadPoolSize = Integer.valueOf(paramMap.get("eventsThreadPoolSize"));
    jsonThreadPoolSize = Integer.valueOf(paramMap.get("jsonThreadPoolSize"));
    final String notLoggedMethods = paramMap.get("notLoggedMethods");
    if (notLoggedMethods != null && notLoggedMethods.trim().length() > 0) {
        final String[] methodNames = notLoggedMethods.split(",");
        for (String methodName : methodNames) {
            notLoggedMethodSet.add(methodName.trim());
        }
    }
    makeDir(cacheDir);
    makeDir(logDir);
    if (isProxyActive()) {
        targetServerUrl = getForwardVdsmServer() + ":" + getVdsmPort() + "/";
    }
}
#end_block

#method_before
public Map getAllVmStats() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    // iterate vms
    List statusList = new ArrayList();
    for (VM vm : host.getRunningVMs().values()) {
        VdsmManager vdsmManager = VdsmManager.getInstance();
        if (!vdsmManager.allRunningVms.contains(vm.getId())) {
            vdsmManager.allRunningVms.add(vm.getId());
        }
        statusList.add(fillVmStatsMap(vm));
    }
    resultMap.put("statsList", statusList);
    return resultMap;
}
#method_after
public Map getAllVmStats() {
    final Host host = getActiveHost();
    Map resultMap = getDoneStatus();
    // iterate vms
    List statusList = host.getRunningVMs().values().stream().map(this::fillVmStatsMap).collect(Collectors.toList());
    resultMap.put("statsList", statusList);
    return resultMap;
}
#end_block

#method_before
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientsMap().get(vmID);
        // send message
        client.sendMessage(message.getBytes());
        log.debug("sending events message {}", message);
    } catch (ClientConnectionException e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeReactorsMap(vmID);
    }
}
#method_after
private void send(String message, String vmID, boolean removeClient) throws ClientConnectionException {
    ReactorClient client = null;
    try {
        // get client
        client = JsonRpcServer.getClientByVmId(vmID);
        // send message
        client.sendMessage(message.getBytes());
        log.debug("sending events message {}", message);
    } catch (ClientConnectionException e) {
        log.error("Host {}, failed to send event message {}", client.getHostname(), e);
    }
    // remove client from the map in case the operation completed \ last event was sent.
    if (removeClient) {
        JsonRpcServer.removeClientByVmId(vmID);
    }
}
#end_block

#method_before
private boolean isUpdateRequired(VM.VMStatus status) {
    // list of stattus which required vdsm update {up, prowerdown, paused}
    return status == VM.VMStatus.Up ? true : status == VM.VMStatus.PoweredDown ? true : status == VM.VMStatus.Paused ? true : false;
}
#method_after
private boolean isUpdateRequired(VM.VMStatus status) {
    // list of statuses which required vdsm update {up, prowerdown, paused}
    return status == VM.VMStatus.Up ? true : status == VM.VMStatus.PoweredDown ? true : status == VM.VMStatus.Paused ? true : false;
}
#end_block

#method_before
public Collection<ExternalVnicProfileMapping> mapFromModel(VnicProfileMappings vnicProfileMappings) {
    return vnicProfileMappings != null && vnicProfileMappings.isSetVnicProfileMappings() ? vnicProfileMappings.getVnicProfileMappings().stream().map(this::mapSingleMappingEntry).collect(Collectors.toList()) : Collections.emptyList();
}
#method_after
public static Collection<ExternalVnicProfileMapping> mapFromModel(VnicProfileMappings vnicProfileMappings) {
    return isVnicProfileMappingSupplied(vnicProfileMappings) ? mapVnicProfileMappings(vnicProfileMappings) : Collections.emptyList();
}
#end_block

#method_before
private ExternalVnicProfileMapping mapSingleMappingEntry(VnicProfileMapping model) {
    return new ExternalVnicProfileMapping(model.getSourceNetworkName(), model.getSourceNetworkProfileName(), Guid.createGuidFromString(model.getTargetVnicProfile().getId()));
}
#method_after
private static ExternalVnicProfileMapping mapSingleMappingEntry(VnicProfileMapping model) {
    return new ExternalVnicProfileMapping(model.getSourceNetworkName(), model.getSourceNetworkProfileName(), Guid.createGuidFromString(model.getTargetVnicProfile().getId()));
}
#end_block

#method_before
private void validateVnicMappings(Action action) {
    if (!(action.isSetVnicProfileMappings() && action.getVnicProfileMappings().isSetVnicProfileMappings())) {
        return;
    }
    action.getVnicProfileMappings().getVnicProfileMappings().forEach(this::validateVnicProfileMapping);
}
#method_after
private void validateVnicMappings(Action action) {
    if (action.isSetVnicProfileMappings() && action.getVnicProfileMappings().isSetVnicProfileMappings()) {
        action.getVnicProfileMappings().getVnicProfileMappings().forEach(this::validateVnicProfileMapping);
    }
}
#end_block

#method_before
private Collection<ExternalVnicProfileMapping> getVnicProfileMappings(Action action) {
    return new ExternalVnicProfileMappingMapper().mapFromModel(action.getVnicProfileMappings());
}
#method_after
private Collection<ExternalVnicProfileMapping> getVnicProfileMappings(Action action) {
    return ExternalVnicProfileMappingMapper.mapFromModel(action.getVnicProfileMappings());
}
#end_block

#method_before
public void updateNetworkInfo(VmNetworkInterface vnic, Collection<ExternalVnicProfileMapping> externalVnicProfileMappings) {
    VnicProfile targetVnicProfile = targetVnicProfileFinder.findTargetVnicProfile(vnic.getNetworkName(), vnic.getVnicProfileName(), externalVnicProfileMappings);
    if (targetVnicProfile != null) {
        vnic.setVnicProfileId(targetVnicProfile.getId());
        vnic.setNetworkName(null);
        vnic.setVnicProfileName(targetVnicProfile.getName());
    }
}
#method_after
public void updateNetworkInfo(VmNetworkInterface vnic, Collection<ExternalVnicProfileMapping> externalVnicProfileMappings) {
    VnicProfile targetVnicProfile = targetVnicProfileFinder.findTargetVnicProfile(vnic.getNetworkName(), vnic.getVnicProfileName(), externalVnicProfileMappings);
    if (targetVnicProfile != null) {
        vnic.setVnicProfileId(targetVnicProfile.getId());
        vnic.setNetworkName(getVnicProfileNetworkName(targetVnicProfile.getNetworkId()));
        vnic.setVnicProfileName(targetVnicProfile.getName());
    }
}
#end_block

#method_before
private boolean validateExternalVnicProfileMapping() {
    final Set<EngineMessage> externalVnicProfileMappingValidationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId());
    if (externalVnicProfileMappingValidationResult.isEmpty()) {
        return true;
    } else {
        return failValidation(new ArrayList<>(externalVnicProfileMappingValidationResult));
    }
}
#method_after
private boolean validateExternalVnicProfileMapping() {
    final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId());
    return validate(validationResult);
}
#end_block

#method_before
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            mapVnicProfiles(vmFromConfiguration.getInterfaces());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Before
public void setUp() {
    externalVnicProfileMappings = new ArrayList<>();
    vnicProfile = new VnicProfile();
    vnicProfile.setId(VNIC_PROFILE_ID);
    vnicProfile.setName(VNIC_PROFILE_NAME);
    when(mockVmNetworkInterface.getNetworkName()).thenReturn(NETWORK_NAME);
    when(mockVmNetworkInterface.getVnicProfileName()).thenReturn(VNIC_PROFILE_NAME);
}
#method_after
@Before
public void setUp() {
    externalVnicProfileMappings = new ArrayList<>();
    vnicProfile = new VnicProfile();
    vnicProfile.setId(VNIC_PROFILE_ID);
    vnicProfile.setName(VNIC_PROFILE_NAME);
    vnicProfile.setNetworkId(TARGET_NETWORK_ID);
    targetNetwork = new Network();
    targetNetwork.setName(TARGET_NETWORK_NAME);
    when(mockVmNetworkInterface.getNetworkName()).thenReturn(EXTERNAL_NETWORK_NAME);
    when(mockVmNetworkInterface.getVnicProfileName()).thenReturn(VNIC_PROFILE_NAME);
}
#end_block

#method_before
@Test
public void testUpdateNetworkInfoMappingNotFound() {
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface, never()).setVnicProfileId(any());
    verify(mockVmNetworkInterface, never()).setNetworkName(any());
    verify(mockVmNetworkInterface, never()).setVnicProfileName(any());
}
#method_after
@Test
public void testUpdateNetworkInfoMappingNotFound() {
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface, never()).setVnicProfileId(any());
    verify(mockVmNetworkInterface, never()).setNetworkName(any());
    verify(mockVmNetworkInterface, never()).setVnicProfileName(any());
}
#end_block

#method_before
@Test
public void testUpdateNetworkInfo() {
    when(mockTargetVnicProfileFinder.findTargetVnicProfile(NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(vnicProfile);
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface).setVnicProfileId(VNIC_PROFILE_ID);
    verify(mockVmNetworkInterface).setVnicProfileName(VNIC_PROFILE_NAME);
    verify(mockVmNetworkInterface).setNetworkName(null);
}
#method_after
@Test
public void testUpdateNetworkInfo() {
    when(mockTargetVnicProfileFinder.findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings)).thenReturn(vnicProfile);
    when(mockNetworkDao.get(TARGET_NETWORK_ID)).thenReturn(targetNetwork);
    underTest.updateNetworkInfo(mockVmNetworkInterface, externalVnicProfileMappings);
    verify(mockTargetVnicProfileFinder).findTargetVnicProfile(EXTERNAL_NETWORK_NAME, VNIC_PROFILE_NAME, externalVnicProfileMappings);
    verify(mockVmNetworkInterface).setVnicProfileId(VNIC_PROFILE_ID);
    verify(mockVmNetworkInterface).setVnicProfileName(VNIC_PROFILE_NAME);
    verify(mockVmNetworkInterface).setNetworkName(TARGET_NETWORK_NAME);
}
#end_block

#method_before
private boolean validateExternalVnicProfileMapping() {
    final Set<EngineMessage> externalVnicProfileMappingValidationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId());
    if (externalVnicProfileMappingValidationResult.isEmpty()) {
        return true;
    } else {
        return failValidation(new ArrayList<>(externalVnicProfileMappingValidationResult));
    }
}
#method_after
private boolean validateExternalVnicProfileMapping() {
    final ValidationResult validationResult = externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(getParameters().getExternalVnicProfileMappings(), getParameters().getClusterId());
    return validate(validationResult);
}
#end_block

#method_before
private void initUnregisteredVM() {
    OvfHelper ovfHelper = new OvfHelper();
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#method_after
private void initUnregisteredVM() {
    List<OvfEntityData> ovfEntityDataList = unregisteredOVFDataDao.getByEntityIdAndStorageDomain(getParameters().getContainerId(), getParameters().getStorageDomainId());
    if (!ovfEntityDataList.isEmpty()) {
        try {
            // We should get only one entity, since we fetched the entity with a specific Storage Domain
            ovfEntityData = ovfEntityDataList.get(0);
            vmFromConfiguration = ovfHelper.readVmFromOvf(ovfEntityData.getOvfData());
            vmFromConfiguration.setClusterId(getParameters().getClusterId());
            getParameters().setVm(vmFromConfiguration);
            getParameters().setDestDomainId(ovfEntityData.getStorageDomainId());
            getParameters().setSourceDomainId(ovfEntityData.getStorageDomainId());
            // For quota, update disks when required
            if (getParameters().getDiskMap() != null) {
                vmFromConfiguration.setDiskMap(getParameters().getDiskMap());
                vmFromConfiguration.setImages(getDiskImageListFromDiskMap(getParameters().getDiskMap()));
            }
        } catch (OvfReaderException e) {
            log.error("Failed to parse a given ovf configuration: {}:\n{}", e.getMessage(), ovfEntityData.getOvfData());
            log.debug("Exception", e);
        }
    }
}
#end_block

#method_before
@Test
public void testValidateExternalVnicProfileMappingEmptyInputIsValid() {
    final List<ExternalVnicProfileMapping> vnicProfileMappings = Collections.emptyList();
    final Set<EngineMessage> actual = underTest.validateExternalVnicProfileMapping(vnicProfileMappings, CLUSTER_ID);
    assertThat(actual, empty());
}
#method_after
@Test
public void testValidateExternalVnicProfileMappingEmptyInputIsValid() {
    testListOfMappings(emptyList(), isValid());
}
#end_block

#method_before
@Test
public void testValidateExternalVnicProfileMappingNullTargetProfileIsValid() {
    final List<ExternalVnicProfileMapping> vnicProfileMappings = Arrays.asList(createMapping(VNIC_PROFILE_ID), createMapping(null));
    when(mockVnicProfileValidator.vnicProfileBelongsToCluster(VNIC_PROFILE_ID, CLUSTER_ID)).thenReturn(true);
    final Set<EngineMessage> actual = underTest.validateExternalVnicProfileMapping(vnicProfileMappings, CLUSTER_ID);
    assertThat(actual, empty());
}
#method_after
@Test
public void testValidateExternalVnicProfileMappingNullTargetProfileIsValid() {
    testListOfMappings(createMappings(VNIC_PROFILE_ID, null), isValid());
}
#end_block

#method_before
@Before
public void setUp() throws IOException {
    storagePoolId = Guid.newGuid();
    clusterId = Guid.newGuid();
    doReturn(cluster).when(cmd).getCluster();
    doReturn(Collections.emptyList()).when(cmd).getImages();
    mockCluster();
    setXmlOvfData();
}
#method_after
@Before
public void setUp() throws IOException {
    doReturn(cluster).when(cmd).getCluster();
    doReturn(Collections.emptyList()).when(cmd).getImages();
    when(externalVnicProfileMappingValidator.validateExternalVnicProfileMapping(new ArrayList<>(), clusterId)).thenReturn(ValidationResult.VALID);
    mockCluster();
    setXmlOvfData();
}
#end_block

#method_before
public Set<EngineMessage> validateExternalVnicProfileMapping(Collection<ExternalVnicProfileMapping> externalVnicProfileMappings, Guid clusterId) {
    if (CollectionUtils.isEmpty(externalVnicProfileMappings)) {
        return Collections.emptySet();
    }
    return externalVnicProfileMappings.stream().map(externalVnicProfileMapping -> isVnicProfileValid(externalVnicProfileMapping.getVnicProfileId(), clusterId)).filter(Objects::nonNull).collect(Collectors.toSet());
}
#method_after
public ValidationResult validateExternalVnicProfileMapping(Collection<ExternalVnicProfileMapping> externalVnicProfileMappings, Guid clusterId) {
    return externalVnicProfileMappings.stream().map(ExternalVnicProfileMapping::getVnicProfileId).filter(Objects::nonNull).map(vnicProfileId -> vnicProfileValidator.validateTargetVnicProfileId(vnicProfileId, clusterId)).filter(((Predicate<ValidationResult>) ValidationResult::isValid).negate()).findFirst().orElse(ValidationResult.VALID);
}
#end_block

#method_before
@Test
public void testVnicProfileBelongsToClusterPositive() {
    when(mockVnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
    when(mockNetworkClusterDao.getAllForCluster(CLUSTER_ID)).thenReturn(targetClusterNetworks);
    targetClusterNetworks.addAll(Arrays.asList(networkCluster1, networkCluster2));
    assertTrue(underTest.vnicProfileBelongsToCluster(VNIC_PROFILE_ID, CLUSTER_ID));
}
#method_after
@Test
public void testVnicProfileBelongsToClusterPositive() {
    when(mockVnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
    when(mockNetworkClusterDao.getAllForCluster(CLUSTER_ID)).thenReturn(targetClusterNetworks);
    targetClusterNetworks.addAll(Arrays.asList(networkCluster1, networkCluster2));
    final ValidationResult actual = underTest.validateTargetVnicProfileId(VNIC_PROFILE_ID, CLUSTER_ID);
    assertThat(actual, isValid());
}
#end_block

#method_before
@Test
public void testVnicProfileBelongsToClusterUnknownVnicProfileId() {
    assertFalse(underTest.vnicProfileBelongsToCluster(VNIC_PROFILE_ID, CLUSTER_ID));
}
#method_after
@Test
public void testVnicProfileBelongsToClusterUnknownVnicProfileId() {
    final ValidationResult actual = underTest.validateTargetVnicProfileId(VNIC_PROFILE_ID, CLUSTER_ID);
    assertThat(actual, failsWith(EngineMessage.ACTION_TYPE_FAILED_VNIC_PROFILE_NOT_EXISTS));
}
#end_block

#method_before
@Test
public void testVnicProfileBelongsToClusterNegative() {
    when(mockVnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
    targetClusterNetworks.add(networkCluster1);
    assertFalse(underTest.vnicProfileBelongsToCluster(VNIC_PROFILE_ID, CLUSTER_ID));
}
#method_after
@Test
public void testVnicProfileBelongsToClusterNegative() {
    when(mockVnicProfileDao.get(VNIC_PROFILE_ID)).thenReturn(vnicProfile);
    targetClusterNetworks.add(networkCluster1);
    final ValidationResult actual = underTest.validateTargetVnicProfileId(VNIC_PROFILE_ID, CLUSTER_ID);
    assertThat(actual, failsWith(EngineMessage.NETWORK_NOT_EXISTS_IN_CURRENT_CLUSTER));
}
#end_block

#method_before
private LockManager getLockManager() {
    try {
        return (LockManager) new InitialContext().lookup("java:global/engine/bll/LockManager");
    } catch (NamingException e) {
        return null;
    }
}
#method_after
private LockManager getLockManager() {
    try {
        return (LockManager) new InitialContext().lookup("java:global/engine/bll/LockManager");
    } catch (NamingException e) {
        throw new RuntimeException("Could not find LockManager via JNDI lookup", e);
    }
}
#end_block

#method_before
private void setCorrelationId(HasCorrelationId params) {
    if (httpHeaders == null) {
        return;
    }
    List<String> correlationIds = httpHeaders.getRequestHeader(CORRELATION_ID);
    if (correlationIds != null && correlationIds.size() > 0) {
        params.setCorrelationId(correlationIds.get(0));
    }
}
#method_after
private void setCorrelationId(HasCorrelationId params) {
    String correlationId = getCurrent().getParameters().get(CORRELATION_ID);
    if (correlationId != null) {
        params.setCorrelationId(correlationId);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getRefresh()) {
        getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    }
    if (validatePermissions()) {
        if (validateInputs()) {
            long start = System.currentTimeMillis();
            try {
                returnValue.setSucceeded(true);
                executeQueryCommand();
            } catch (RuntimeException ex) {
                returnValue.setSucceeded(false);
                Throwable th = ex instanceof EngineException ? ex : ex.getCause();
                if (th instanceof EngineException) {
                    EngineException vdcExc = (EngineException) th;
                    if (vdcExc.getErrorCode() != null) {
                        returnValue.setExceptionString(vdcExc.getErrorCode().toString());
                    } else {
                        returnValue.setExceptionString(vdcExc.getMessage());
                    }
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), vdcExc.getMessage());
                    log.error("Exception", vdcExc);
                } else {
                    returnValue.setExceptionString(ex.getMessage());
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), ex.getMessage());
                    log.error("Exception", ex);
                }
            } finally {
                long duration = System.currentTimeMillis() - start;
                String correlationId = getParameters().getCorrelationId();
                if (correlationId == null) {
                    correlationId = "N/A";
                }
                log.info("Query {} took {} ms CorrelationId: {}", getCommandName(), duration, correlationId);
            }
        } else {
            log.error("Query execution failed due to invalid inputs: {}", returnValue.getExceptionString());
        }
    } else {
        String errMessage = "Query execution failed due to insufficient permissions.";
        log.error(errMessage);
        returnValue.setExceptionString(errMessage);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getRefresh()) {
        getSessionDataContainer().updateSessionLastActiveTime(getParameters().getSessionId());
    }
    if (validatePermissions()) {
        if (validateInputs()) {
            long start = System.currentTimeMillis();
            try {
                returnValue.setSucceeded(true);
                executeQueryCommand();
            } catch (RuntimeException ex) {
                returnValue.setSucceeded(false);
                Throwable th = ex instanceof EngineException ? ex : ex.getCause();
                if (th instanceof EngineException) {
                    EngineException vdcExc = (EngineException) th;
                    if (vdcExc.getErrorCode() != null) {
                        returnValue.setExceptionString(vdcExc.getErrorCode().toString());
                    } else {
                        returnValue.setExceptionString(vdcExc.getMessage());
                    }
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), vdcExc.getMessage());
                    log.error("Exception", vdcExc);
                } else {
                    returnValue.setExceptionString(ex.getMessage());
                    log.error("Query '{}' failed: {}", getClass().getSimpleName(), ex.getMessage());
                    log.error("Exception", ex);
                }
            } finally {
                log.debug("Query {} took {} ms", getCommandName(), System.currentTimeMillis() - start);
            }
        } else {
            log.error("Query execution failed due to invalid inputs: {}", returnValue.getExceptionString());
        }
    } else {
        String errMessage = "Query execution failed due to insufficient permissions.";
        log.error(errMessage);
        returnValue.setExceptionString(errMessage);
    }
}
#end_block

#method_before
private void initHandlers() {
    tagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = tagsHandler;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    BaseConditionFieldAutoCompleter.tagsHandler = tagsDirector;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    loadService(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    loadService(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    loadService(CpuFlagsManagerHandler.class);
    loadService(AuditLogCleanupManager.class);
    loadService(CommandEntityCleanupManager.class);
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    loadService(JobRepositoryCleanupManager.class);
    loadService(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    loadService(VmsMonitoring.class);
    loadService(VmDevicesMonitoring.class);
    loadService(VmPoolHandler.class);
    loadService(VmPoolMonitor.class);
    loadService(HaAutoStartVmsRunner.class);
    loadService(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
@Override
protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    // $NON-NLS-1$
    String correlationId = filterCorrelationId(req.getHeader("Correlation-Id"));
    if (correlationId == null) {
        correlationId = Integer.toHexString(Objects.hash(req.getRemoteAddr(), req.getRemotePort(), System.currentTimeMillis()));
    }
    CorrelationIdTracker.setCorrelationId(correlationId);
    // $NON-NLS-1$
    resp.addHeader("Correlation-Id", correlationId);
    super.service(req, resp);
}
#method_after
@Override
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String correlationId = getCorrelationId(request);
    CorrelationIdTracker.setCorrelationId(correlationId);
    response.addHeader(CORRELATION_ID_HEADER, correlationId);
    super.service(request, response);
}
#end_block

#method_before
@Override
public VdcReturnValueBase runAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getEngineSessionId());
    if (params.getCorrelationId() == null) {
        params.setCorrelationId(CorrelationIdTracker.getCorrelationId());
    }
    if (noBackend) {
        VdcReturnValueBase rValue = new VdcReturnValueBase();
        rValue.setSucceeded(true);
        return rValue;
    }
    return getBackend().runAction(actionType, params);
}
#method_after
@Override
public VdcReturnValueBase runAction(VdcActionType actionType, VdcActionParametersBase params) {
    // $NON-NLS-1$
    log.debug("Server: RunAction invoked!");
    debugAction(actionType, params);
    params.setSessionId(getEngineSessionId());
    if (params.getCorrelationId() == null) {
        params.setCorrelationId(CorrelationIdTracker.getCorrelationId());
    }
    return getBackend().runAction(actionType, params);
}
#end_block

#method_before
private Inventory lookupInventory() throws DashboardDataException {
    Inventory inventory = new Inventory();
    inventory.setDc(InventoryHelper.getDcInventoryStatus(engineDataSource));
    inventory.setCluster(InventoryHelper.getClusterInventoryStatus(engineDataSource));
    inventory.setHost(InventoryHelper.getHostInventoryStatus(engineDataSource));
    inventory.setStorage(InventoryHelper.getStorageInventoryStatus(engineDataSource));
    inventory.setVm(InventoryHelper.getVmInventorySummary(engineDataSource));
    inventory.setGlusterVolume(InventoryHelper.getGlusterVolumeInventorySummary(engineDataSource));
    inventory.setEvent(EventHelper.getEventStatus(engineDataSource));
    return inventory;
}
#method_after
private Inventory lookupInventory() throws DashboardDataException {
    Inventory inventory = new Inventory();
    inventory.setDc(InventoryHelper.getDcInventoryStatus(engineDataSource));
    inventory.setCluster(InventoryHelper.getClusterInventoryStatus(engineDataSource));
    inventory.setHost(InventoryHelper.getHostInventoryStatus(engineDataSource));
    inventory.setStorage(InventoryHelper.getStorageInventoryStatus(engineDataSource));
    inventory.setVm(InventoryHelper.getVmInventorySummary(engineDataSource));
    inventory.setVolume(InventoryHelper.getGlusterVolumeInventorySummary(engineDataSource));
    inventory.setEvent(EventHelper.getEventStatus(engineDataSource));
    return inventory;
}
#end_block

#method_before
public InventoryStatus getVolumeInventoryStatus() throws DashboardDataException {
    final InventoryStatus result = new InventoryStatus();
    runQuery(GLUSTER_VOLUME_INVENTORY, new QueryResultCallback() {

        @Override
        public void onResult(ResultSet rs) throws SQLException {
            processVolumeStatus(result, rs.getString(STATUS));
        }
    });
    return result;
}
#method_after
public InventoryStatus getVolumeInventoryStatus() throws DashboardDataException {
    final InventoryStatus result = new InventoryStatus();
    runQuery(GLUSTER_VOLUME_INVENTORY, new QueryResultCallback() {

        @Override
        public void onResult(ResultSet rs) throws SQLException {
            processVolumeStatus(result, rs.getString(STATUS), rs.getInt(BRICKS_NOT_UP));
        }
    });
    return result;
}
#end_block

#method_before
private InventoryStatus processVolumeStatus(InventoryStatus summary, String status) {
    summary.addCount();
    // TODO: Need to identify the brick status and classify the volumes to Warning ( Up Degraded and UP Partial)
    // status
    summary.addStatus(GlusterStatus.valueOf(status).name().toLowerCase());
    return summary;
}
#method_after
private InventoryStatus processVolumeStatus(InventoryStatus summary, String status, int bricksNotUp) {
    summary.addCount();
    GlusterStatus volumeStatus = GlusterStatus.valueOf(status);
    if (GlusterStatus.UP == volumeStatus && bricksNotUp > 0) {
        summary.addStatus(GlusterStatus.WARNING.name().toLowerCase());
    } else {
        summary.addStatus(volumeStatus.name().toLowerCase());
    }
    return summary;
}
#end_block

#method_before
public static Inventory fakeInventory(Random random) {
    Inventory result = new Inventory();
    result.setCluster(new InventoryStatus());
    result.getCluster().setTotalCount(25);
    result.setDc(new InventoryStatus());
    createFakeValuesUpDownError(result.getDc(), 22, random);
    result.setHost(new InventoryStatus());
    createFakeValuesUpDownError(result.getHost(), 125, random);
    result.setStorage(new InventoryStatus());
    createFakeValuesUpDownError(result.getStorage(), 10, random);
    result.setVm(new InventoryStatus());
    createFakeValuesUpDownError(result.getVm(), 253, random);
    result.setEvent(new InventoryStatus());
    createFakeValuesAlertErrorWarning(result.getEvent(), 169, random);
    result.setGlusterVolume(new InventoryStatus());
    createFakeValuesUpDownError(result.getGlusterVolume(), 95, random);
    return result;
}
#method_after
public static Inventory fakeInventory(Random random) {
    Inventory result = new Inventory();
    result.setCluster(new InventoryStatus());
    result.getCluster().setTotalCount(25);
    result.setDc(new InventoryStatus());
    createFakeValuesUpDownError(result.getDc(), 22, random);
    result.setHost(new InventoryStatus());
    createFakeValuesUpDownError(result.getHost(), 125, random);
    result.setStorage(new InventoryStatus());
    createFakeValuesUpDownError(result.getStorage(), 10, random);
    result.setVm(new InventoryStatus());
    createFakeValuesUpDownError(result.getVm(), 253, random);
    result.setEvent(new InventoryStatus());
    createFakeValuesAlertErrorWarning(result.getEvent(), 169, random);
    result.setVolume(new InventoryStatus());
    createFakeValuesUpDownError(result.getVolume(), 95, random);
    return result;
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVdsList(instance.getDedicatedVmForVdsList());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setClusterCompatibilityVersion(instance.getClusterCompatibilityVersion());
    vm.setClusterId(instance.getClusterId());
    vm.setClusterName(instance.getClusterName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setCustomCompatibilityVersion(instance.getCustomCompatibilityVersion());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setIp(instance.getIp());
    vm.setFqdn(instance.getFqdn());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setPid(instance.getPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    vm.setGuestOsArch(instance.getGuestOsArch());
    vm.setGuestOsCodename(instance.getGuestOsCodename());
    vm.setGuestOsDistribution(instance.getGuestOsDistribution());
    vm.setGuestOsKernelVersion(instance.getGuestOsKernelVersion());
    vm.setGuestOsType(instance.getGuestOsType());
    vm.setGuestOsVersion(instance.getGuestOsVersion());
    vm.setGuestOsTimezoneName(instance.getGuestOsTimezoneName());
    vm.setGuestOsTimezoneOffset(instance.getGuestOsTimezoneOffset());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVdsList(instance.getDedicatedVmForVdsList());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setClusterCompatibilityVersion(instance.getClusterCompatibilityVersion());
    vm.setClusterId(instance.getClusterId());
    vm.setClusterName(instance.getClusterName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setCustomCompatibilityVersion(instance.getCustomCompatibilityVersion());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setIp(instance.getIp());
    vm.setFqdn(instance.getFqdn());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    vm.setGuestOsArch(instance.getGuestOsArch());
    vm.setGuestOsCodename(instance.getGuestOsCodename());
    vm.setGuestOsDistribution(instance.getGuestOsDistribution());
    vm.setGuestOsKernelVersion(instance.getGuestOsKernelVersion());
    vm.setGuestOsType(instance.getGuestOsType());
    vm.setGuestOsVersion(instance.getGuestOsVersion());
    vm.setGuestOsTimezoneName(instance.getGuestOsTimezoneName());
    vm.setGuestOsTimezoneOffset(instance.getGuestOsTimezoneOffset());
    return vm;
}
#end_block

#method_before
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVdsList(instance.getDedicatedVmForVdsList());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    vm.setKvmEnable(instance.getKvmEnable());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setLastVdsRunOn(instance.getLastVdsRunOn());
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setClusterCompatibilityVersion(instance.getClusterCompatibilityVersion());
    vm.setClusterId(instance.getClusterId());
    vm.setClusterName(instance.getClusterName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setCustomCompatibilityVersion(instance.getCustomCompatibilityVersion());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setIp(instance.getIp());
    vm.setFqdn(instance.getFqdn());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setPid(instance.getPid());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    vm.setGuestOsArch(instance.getGuestOsArch());
    vm.setGuestOsCodename(instance.getGuestOsCodename());
    vm.setGuestOsDistribution(instance.getGuestOsDistribution());
    vm.setGuestOsKernelVersion(instance.getGuestOsKernelVersion());
    vm.setGuestOsType(instance.getGuestOsType());
    vm.setGuestOsVersion(instance.getGuestOsVersion());
    vm.setGuestOsTimezoneName(instance.getGuestOsTimezoneName());
    vm.setGuestOsTimezoneOffset(instance.getGuestOsTimezoneOffset());
    return vm;
}
#method_after
private static Object cloneVM(VM instance) {
    if (instance == null) {
        return null;
    }
    VM vm = new VM();
    vm.setAcpiEnable(instance.getAcpiEnable());
    // TODO: this field is read only in serialization - not sure why it is cloned
    // vm.ActualDiskWithSnapshotsSize = instance.ActualDiskWithSnapshotsSize;
    vm.setAppList(instance.getAppList());
    vm.setAutoStartup(instance.isAutoStartup());
    vm.setBootSequence(instance.getBootSequence());
    vm.setClientIp(instance.getClientIp());
    vm.setCpuPerSocket(instance.getCpuPerSocket());
    vm.setCpuSys(instance.getCpuSys());
    vm.setCpuUser(instance.getCpuUser());
    vm.setDedicatedVmForVdsList(instance.getDedicatedVmForVdsList());
    vm.setDefaultBootSequence(instance.getDefaultBootSequence());
    vm.setDefaultDisplayType(instance.getDefaultDisplayType());
    // TODO: 1. DiskList is an array - CopyTo should be considered (if it can be converted to java, otherwise a
    // simple loop is needed)
    // TODO: 2. it is also read only in serialization, so not sure why it is cloned. it is manipulated via
    // addDriveToImageMap
    // vm.DiskList = instance.DiskList;
    vm.setDiskSize(instance.getDiskSize());
    // TODO: this is also an object, so needs to be cloned as well. while it is only accessed via VM.DiskMap, which
    // creates a dictionary
    // from it - actually the DiskImage's themselves are probably sharing the same reference...
    vm.getGraphicsInfos().putAll(instance.getGraphicsInfos());
    vm.getDynamicData().setVncKeyboardLayout(instance.getDynamicData().getVncKeyboardLayout());
    vm.setElapsedTime(instance.getElapsedTime());
    vm.setRoundedElapsedTime(instance.getRoundedElapsedTime());
    vm.setExitMessage(instance.getExitMessage());
    vm.setExitStatus(instance.getExitStatus());
    vm.setExitReason(instance.getExitReason());
    vm.setFailBack(instance.isFailBack());
    vm.setConsoleCurrentUserName(instance.getConsoleCurentUserName());
    vm.setGuestCurrentUserName(instance.getGuestCurentUserName());
    vm.setConsoleUserId(instance.getConsoleUserId());
    vm.setGuestOs(instance.getGuestOs());
    vm.setGuestRequestedMemory(instance.getGuestRequestedMemory());
    // TODO: Object, should be "cloned" (probably easiest via new Version(instance.GuestAgentVersion.ToString())
    // pay attention NOT to use lower case version in UICommon code.
    vm.setGuestAgentVersion(instance.getGuestAgentVersion());
    vm.setInitrdUrl(instance.getInitrdUrl());
    // TODO: array - need to consider cloning of array, and of actual interfaces
    vm.setInterfaces(instance.getInterfaces());
    vm.setInitialized(instance.isInitialized());
    vm.setStateless(instance.isStateless());
    vm.setRunAndPause(instance.isRunAndPause());
    vm.setIsoPath(instance.getIsoPath());
    vm.setKernelParams(instance.getKernelParams());
    vm.setKernelUrl(instance.getKernelUrl());
    // TODO: Guid is an object, but code should treat it as immutable, and not change it's uuid directly.
    // (quick skim of code shows this should be safe with current code)
    vm.setMigratingToVds(instance.getMigratingToVds());
    vm.setMigrationSupport(instance.getMigrationSupport());
    vm.setNiceLevel(instance.getNiceLevel());
    vm.setUseHostCpuFlags(instance.isUseHostCpuFlags());
    // TODO: this is readonly in java, since it is computed.
    // options: use calculation here in cloner, or still wrap this in VM instead of serializing it
    // vm.num_of_cpus = instance.num_of_cpus;
    vm.setNumOfMonitors(instance.getNumOfMonitors());
    vm.setAllowConsoleReconnect(instance.getAllowConsoleReconnect());
    vm.setNumOfSockets(instance.getNumOfSockets());
    vm.setOrigin(instance.getOrigin());
    vm.setVmPauseStatus(instance.getVmPauseStatus());
    vm.setPriority(instance.getPriority());
    vm.setRunOnVds(instance.getRunOnVds());
    vm.setRunOnVdsName(instance.getRunOnVdsName());
    vm.setSession(instance.getSession());
    // TODO: see version comment above
    vm.setSpiceDriverVersion(instance.getSpiceDriverVersion());
    vm.setStatus(instance.getStatus());
    vm.setStoragePoolId(instance.getStoragePoolId());
    vm.setStoragePoolName(instance.getStoragePoolName());
    vm.setTimeZone(instance.getTimeZone());
    vm.setTransparentHugePages(instance.isTransparentHugePages());
    vm.setUsageCpuPercent(instance.getUsageCpuPercent());
    vm.setUsageMemPercent(instance.getUsageMemPercent());
    vm.setUsageNetworkPercent(instance.getUsageNetworkPercent());
    vm.setUsbPolicy(instance.getUsbPolicy());
    vm.setUtcDiff(instance.getUtcDiff());
    vm.setClusterCompatibilityVersion(instance.getClusterCompatibilityVersion());
    vm.setClusterId(instance.getClusterId());
    vm.setClusterName(instance.getClusterName());
    vm.setVmCreationDate(instance.getVmCreationDate());
    vm.setVmDescription(instance.getVmDescription());
    vm.setComment(instance.getComment());
    vm.setCustomEmulatedMachine(instance.getCustomEmulatedMachine());
    vm.setCustomCpuName(instance.getCustomCpuName());
    vm.setCustomCompatibilityVersion(instance.getCustomCompatibilityVersion());
    vm.setId(instance.getId());
    vm.setVmHost(instance.getVmHost());
    vm.setIp(instance.getIp());
    vm.setFqdn(instance.getFqdn());
    vm.setLastStartTime(instance.getLastStartTime());
    vm.setVmMemSizeMb(instance.getVmMemSizeMb());
    vm.setName(instance.getName());
    vm.setVmOs(instance.getVmOsId());
    vm.setVmType(instance.getVmType());
    vm.setVmPoolId(instance.getVmPoolId());
    vm.setVmPoolName(instance.getVmPoolName());
    vm.setVmtGuid(instance.getVmtGuid());
    vm.setVmtName(instance.getVmtName());
    vm.setCreatedByUserId(instance.getCreatedByUserId());
    vm.setClusterArch(instance.getClusterArch());
    vm.setOriginalTemplateGuid(instance.getOriginalTemplateGuid());
    vm.setOriginalTemplateName(instance.getOriginalTemplateName());
    vm.setMigrationDowntime(instance.getMigrationDowntime());
    vm.setUseLatestVersion(instance.isUseLatestVersion());
    vm.setSerialNumberPolicy(instance.getSerialNumberPolicy());
    vm.setCustomSerialNumber(instance.getCustomSerialNumber());
    vm.setBootMenuEnabled(instance.isBootMenuEnabled());
    vm.setSpiceFileTransferEnabled(instance.isSpiceFileTransferEnabled());
    vm.setSpiceCopyPasteEnabled(instance.isSpiceCopyPasteEnabled());
    vm.setCpuProfileId(instance.getCpuProfileId());
    vm.setAutoConverge(instance.getAutoConverge());
    vm.setMigrateCompressed(instance.getMigrateCompressed());
    vm.setPredefinedProperties(instance.getPredefinedProperties());
    vm.setUserDefinedProperties(instance.getUserDefinedProperties());
    vm.setCustomProperties(instance.getCustomProperties());
    vm.setSingleQxlPci(instance.getSingleQxlPci());
    vm.setMinAllocatedMem(instance.getMinAllocatedMem());
    vm.setGuestOsArch(instance.getGuestOsArch());
    vm.setGuestOsCodename(instance.getGuestOsCodename());
    vm.setGuestOsDistribution(instance.getGuestOsDistribution());
    vm.setGuestOsKernelVersion(instance.getGuestOsKernelVersion());
    vm.setGuestOsType(instance.getGuestOsType());
    vm.setGuestOsVersion(instance.getGuestOsVersion());
    vm.setGuestOsTimezoneName(instance.getGuestOsTimezoneName());
    vm.setGuestOsTimezoneOffset(instance.getGuestOsTimezoneOffset());
    return vm;
}
#end_block

#method_before
private void initHandlers() {
    tagsHandler = HandlersFactory.createTagsHandler();
    BaseConditionFieldAutoCompleter.tagsHandler = tagsHandler;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#method_after
private void initHandlers() {
    BaseConditionFieldAutoCompleter.tagsHandler = tagsDirector;
    VmHandler.init();
    VdsHandler.init();
    VmTemplateHandler.init();
    log.info("Completed initializing handlers");
}
#end_block

#method_before
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    TagsDirector.getInstance().init();
    IsoDomainListSyncronizer.getInstance();
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#method_after
private void initialize() {
    log.info("Start initializing {}", getClass().getSimpleName());
    // save host that HE VM was running on prior to engine startup
    serviceLoader.load(PreviousHostedEngineHost.class);
    // start task schedulers
    for (SchedulerUtil taskScheduler : taskSchedulers) {
        log.info("Started task scheduler {}", taskScheduler);
    }
    // initialize CDI services
    serviceLoader.load(CacheManager.class);
    // initialize configuration utils to use DB
    Config.setConfigUtils(new DBConfigUtils());
    // we need to initialize os-info before the compensations take place because of VmPoolCommandBase#osRepository
    initOsRepository();
    // makes sure that initialization occurs only once per class (which is ok, as this is a @Service)
    if (firstInitialization) {
        // In case of a server termination that had uncompleted compensation-aware related commands
        // we have to get all those commands and call compensate on each
        compensate();
        firstInitialization = false;
    }
    log.info("Running ovirt-engine {}", Config.<String>getValue(ConfigValues.ProductRPMVersion));
    serviceLoader.load(CpuFlagsManagerHandler.class);
    serviceLoader.load(AuditLogCleanupManager.class);
    serviceLoader.load(CommandEntityCleanupManager.class);
    serviceLoader.load(TagsDirector.class);
    serviceLoader.load(IsoDomainListSynchronizer.class);
    initSearchDependencies();
    initHandlers();
    initVmPropertiesUtils();
    final String AppErrorsFileName = "bundles/AppErrors.properties";
    final String VdsErrorsFileName = "bundles/VdsmErrors.properties";
    errorsTranslator = new ErrorTranslatorImpl(AppErrorsFileName, VdsErrorsFileName);
    vdsErrorsTranslator = new ErrorTranslatorImpl(VdsErrorsFileName);
    // initialize the JobRepository object and finalize non-terminated jobs
    log.info("Mark incomplete jobs as {}", JobExecutionStatus.UNKNOWN.name());
    initJobRepository();
    serviceLoader.load(JobRepositoryCleanupManager.class);
    serviceLoader.load(AutoRecoveryManager.class);
    initExecutionMessageDirector();
    taskSchedulers.select(SchedulerUtilQuartzImpl.class).get().scheduleAFixedDelayJob(sessionDataContainer, "cleanExpiredUsersSessions", new Class[] {}, new Object[] {}, 1, 1, TimeUnit.MINUTES);
    // Set start-up time
    _startedAt = DateTime.getNow();
    serviceLoader.load(VmsMonitoring.class);
    serviceLoader.load(VmDevicesMonitoring.class);
    serviceLoader.load(VmPoolHandler.class);
    serviceLoader.load(VmPoolMonitor.class);
    serviceLoader.load(HaAutoStartVmsRunner.class);
    serviceLoader.load(QuotaManager.class);
    // initializes attestation
    initAttestation();
    updatePredefinedIcons();
    iconCleanup();
    registerIconDefaultsProvider();
    EngineExtensionsManager.getInstance().engineInitialize();
    AuthenticationProfileRepository.getInstance();
    AcctUtils.reportReason(Acct.ReportReason.STARTUP, "Starting up engine");
}
#end_block

#method_before
void storeObject(BaseObject baseObject) {
    final File f = new File(AppConfig.getInstance().getCacheDir(), baseObject.getClass().getSimpleName() + "_" + baseObject.getId());
    PersistUtils.store(baseObject, f);
}
#method_after
// TODO: caching and stored cached files needs a rework, when the app started, and when stored the files
void storeObject(BaseObject baseObject) {
    final File f = new File(AppConfig.getInstance().getCacheDir(), baseObject.getClass().getSimpleName() + "_" + baseObject.getId());
    PersistUtils.store(baseObject, f);
}
#end_block

#method_before
public synchronized Host getHostByName(String serverName) {
    Host host = null;
    if (hostMap.containsKey(serverName)) {
        return hostMap.get(serverName);
    }
    host = (Host) loadObject(Host.class, serverName);
    if (host == null) {
        host = new Host();
        host.setName(serverName);
        host.setId(serverName);
        // generate IP, MAC, ...
        host.initializeHost();
        // save to the cache
        storeObject(host);
    } else {
        log.info("Host restored from file, name: {}", serverName);
    }
    hostMap.put(serverName, host);
    return host;
}
#method_after
public Host getHostByName(String serverName) {
    Host host = null;
    if (hostMap.containsKey(serverName)) {
        return hostMap.get(serverName);
    }
    host = (Host) loadObject(Host.class, serverName);
    if (host == null) {
        host = new Host();
        host.setName(serverName);
        host.setId(serverName);
        // generate IP, MAC, ...
        host.initializeHost();
        // save to the cache
        storeObject(host);
    } else {
        log.info("Host restored from file, name: {}", serverName);
    }
    hostMap.put(serverName, host);
    return host;
}
#end_block

#method_before
public synchronized void updateHost(Host host) {
    if (!hostMap.containsKey(host.getId())) {
        hostMap.put(host.getId(), host);
    }
    log.info("Storing host: {}", host.getName());
    // save to the cache
    storeObject(host);
}
#method_after
public void updateHost(Host host) {
    hostMap.put(host.getId(), host);
    log.info("Storing host: {}", host.getName());
    // save to the cache
    storeObject(host);
}
#end_block

#method_before
public synchronized DataCenter getDataCenterById(String id) {
    DataCenter dataCenter = null;
    if (dataCenterMap.containsKey(id)) {
        return dataCenterMap.get(id);
    }
    try {
        dataCenter = (DataCenter) loadObject(DataCenter.class, id);
        if (dataCenter == null) {
            // setup a new one
            dataCenter = new DataCenter();
            dataCenter.setId(id);
            updateDataCenter(dataCenter);
        } else {
            log.info("Data center restored from file, id: {}", id);
        }
    } catch (RuntimeException e) {
        log.error("failed to load dataCenter object");
        return dataCenter;
    }
    dataCenterMap.put(id, dataCenter);
    return dataCenter;
}
#method_after
public DataCenter getDataCenterById(String id) {
    DataCenter dataCenter = null;
    if (dataCenterMap.containsKey(id)) {
        return dataCenterMap.get(id);
    }
    // read cache from stored file
    dataCenter = (DataCenter) loadObject(DataCenter.class, id);
    if (dataCenter == null) {
        dataCenter = reInitializeDataCenter(id);
    } else {
        dataCenterMap.put(id, dataCenter);
    }
    return dataCenter;
}
#end_block

#method_before
public synchronized void updateDataCenter(DataCenter dataCenter) {
    // save to the cache
    try {
        storeObject(dataCenter);
    } catch (RuntimeException e) {
        log.error("failed to create new dataCenter");
        return;
    }
    if (!dataCenterMap.containsKey(dataCenter.getId())) {
        dataCenterMap.put(dataCenter.getId(), dataCenter);
    }
    log.info("Data center {} stored", dataCenter.getId());
}
#method_after
public void updateDataCenter(DataCenter dataCenter) {
    // save to the cache
    try {
        storeObject(dataCenter);
    } catch (Exception e) {
        log.error("failed to store object {}", e.getStackTrace());
    }
    dataCenterMap.put(dataCenter.getId(), dataCenter);
    log.info("Data center {} restored", dataCenter.getId());
}
#end_block

#method_before
public synchronized StorageDomain getStorageDomainById(String id) {
    StorageDomain storageDomain = null;
    if (storageDomainMap.containsKey(id)) {
        return storageDomainMap.get(id);
    }
    storageDomain = (StorageDomain) loadObject(StorageDomain.class, id);
    if (storageDomain == null) {
        storageDomain = new StorageDomain();
        storageDomain.setId(id);
    } else {
        log.info("Data center restored from file, id: {}", id);
    }
    storageDomainMap.put(id, storageDomain);
    return storageDomain;
}
#method_after
public StorageDomain getStorageDomainById(String id) {
    StorageDomain storageDomain = null;
    if (storageDomainMap.containsKey(id)) {
        return storageDomainMap.get(id);
    }
    // read cache from stored file
    storageDomain = (StorageDomain) loadObject(StorageDomain.class, id);
    if (storageDomain == null) {
        storageDomain = recoverStorageDomain(id);
    } else {
        storageDomainMap.put(id, storageDomain);
    }
    return storageDomain;
}
#end_block

#method_before
public synchronized void removeStorageDomain(StorageDomain storageDomain) {
    storageDomainMap.remove(storageDomain.getId());
    log.info("Removing storage domain: {}", storageDomain.getId());
    // remove from the cache
    removeObject(storageDomain);
}
#method_after
public void removeStorageDomain(StorageDomain storageDomain) {
    storageDomainMap.remove(storageDomain.getId());
    log.info("Removing storage domain: {}", storageDomain.getId());
    // remove from the cache
    removeObject(storageDomain);
}
#end_block

#method_before
public synchronized void updateStorageDomain(StorageDomain storageDomain) {
    log.info("Updating storage domain: {}", storageDomain.getId());
    if (!storageDomainMap.containsKey(storageDomain.getId())) {
        storageDomainMap.put(storageDomain.getId(), storageDomain);
    }
    // save to the cache
    storeObject(storageDomain);
}
#method_after
public void updateStorageDomain(StorageDomain storageDomain) {
    log.info("Updating storage domain: {}", storageDomain.getId());
    storageDomainMap.put(storageDomain.getId(), storageDomain);
    // save to the cache
    storeObject(storageDomain);
}
#end_block

#method_before
public synchronized void setMasterDomain(String spUuid, String masterSdUuid) {
    log.info("Setting master domain, sp: {}, master sd: {}: ", spUuid, masterSdUuid);
    if (masterSdUuid == null) {
        return;
    }
    final DataCenter dataCenter = getDataCenterById(spUuid);
    for (StorageDomain storageDomain : dataCenter.getStorageDomainMap().values()) {
        if (masterSdUuid.equals(storageDomain.getId())) {
            storageDomain.setDomainRole(DomainRole.MASTER);
        } else {
            storageDomain.setDomainRole(DomainRole.REGULAR);
        }
    }
    updateDataCenter(dataCenter);
}
#method_after
public void setMasterDomain(String spUuid, String masterSdUuid) {
    log.info("Setting master domain, sp: {}, master sd: {}: ", spUuid, masterSdUuid);
    if (masterSdUuid == null) {
        return;
    }
    final DataCenter dataCenter = getDataCenterById(spUuid);
    for (StorageDomain storageDomain : dataCenter.getStorageDomainMap().values()) {
        if (masterSdUuid.equals(storageDomain.getId())) {
            storageDomain.setDomainRole(DomainRole.MASTER);
        } else {
            storageDomain.setDomainRole(DomainRole.REGULAR);
        }
    }
    updateDataCenter(dataCenter);
}
#end_block

#method_before
public static void store(BaseObject baseObject, File f) {
    if (baseObject.getName().contains("?") && baseObject instanceof DataCenter) {
        baseObject.setName(baseObject.getId());
    }
    ObjectOutputStream oos = null;
    try {
        oos = new ObjectOutputStream(new FileOutputStream(f));
        oos.writeObject(baseObject);
    } catch (Exception e) {
        log.error("Cannot save object", e);
        throw new RuntimeException("Cannot save object", e);
    } finally {
        IOUtils.closeQuietly(oos);
        baseObject.setLastUpdate(f.lastModified());
    }
}
#method_after
public static void store(BaseObject baseObject, File f) {
    if (baseObject instanceof DataCenter && baseObject.getName().contains("?")) {
        baseObject.setName(baseObject.getId());
    }
    ObjectOutputStream oos = null;
    try {
        oos = new ObjectOutputStream(new FileOutputStream(f));
        oos.writeObject(baseObject);
    } catch (Exception e) {
        log.error("Cannot save object", e);
        throw new RuntimeException("Cannot save object", e);
    } finally {
        IOUtils.closeQuietly(oos);
        baseObject.setLastUpdate(f.lastModified());
    }
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_pid)) {
        vm.setPid(assignIntValue(xmlRpcStruct, VdsProperties.vm_pid));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    initGuestContainers(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setFqdn(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getFqdn().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setFqdn(null);
        } else {
            vm.setFqdn(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getIp() != null) {
        if (vm.getIp().startsWith("127.0.")) {
            vm.setIp(null);
        } else {
            vm.setIp(vm.getIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct, VDS host) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.error("Illegal vm session '{}'.", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.vm_pid)) {
        vm.setPid(assignIntValue(xmlRpcStruct, VdsProperties.vm_pid));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    boolean hasGraphicsInfo = updateGraphicsInfo(vm, xmlRpcStruct);
    if (!hasGraphicsInfo) {
        updateGraphicsInfoFromConf(vm, xmlRpcStruct);
    }
    adjustDisplayIp(vm.getGraphicsInfos(), host);
    if (xmlRpcStruct.containsKey(VdsProperties.utc_diff)) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.error("Illegal vm offset (utc_diff) '{}'.", utc_diff);
        }
    }
    // ------------- vm internal agent data
    if (xmlRpcStruct.containsKey(VdsProperties.vm_host)) {
        vm.setVmHost(assignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.guest_cur_user_name)) {
        vm.setGuestCurrentUserName(assignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name));
    }
    initAppsList(xmlRpcStruct, vm);
    initGuestContainers(xmlRpcStruct, vm);
    if (xmlRpcStruct.containsKey(VdsProperties.guest_os)) {
        vm.setGuestOs(assignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setFqdn(assignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getFqdn().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setFqdn(null);
        } else {
            vm.setFqdn(fqdn);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.VM_IP)) {
        vm.setIp(assignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    }
    if (vm.getIp() != null) {
        if (vm.getIp().startsWith("127.0.")) {
            vm.setIp(null);
        } else {
            vm.setIp(vm.getIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_reason)) {
        String exitReasonStr = xmlRpcStruct.get(VdsProperties.exit_reason).toString();
        vm.setExitReason(VmExitReason.forValue(Integer.parseInt(exitReasonStr)));
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            vm.setPauseStatus(VmPauseStatus.valueOf(pauseCodeStr));
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        Path fileName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName();
        if (fileName != null) {
            String isoName = fileName.toString();
            vm.setCurrentCd(isoName);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_CPU_COUNT)) {
        vm.setGuestCpuCount(assignIntValue(xmlRpcStruct, VdsProperties.GUEST_CPU_COUNT));
    }
    // Guest OS Info
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_OS_INFO)) {
        updateGuestOsInfo(vm, xmlRpcStruct);
    }
    // Guest Timezone
    if (xmlRpcStruct.containsKey(VdsProperties.GUEST_TIMEZONE)) {
        Map<String, Object> guestTimeZoneStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.GUEST_TIMEZONE);
        vm.setGuestOsTimezoneName(assignStringValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_ZONE));
        vm.setGuestOsTimezoneOffset(assignIntValue(guestTimeZoneStruct, VdsProperties.GUEST_TIMEZONE_OFFSET));
    }
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
private static Date assignDatetimeValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Date) {
            return (Date) input.get(name);
        }
        DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        try {
            String dateStr = input.get(name).toString().replaceFirst("T", " ").trim();
            return formatter.parse(dateStr);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
    return null;
}
#method_after
private static Date assignDatetimeValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Date) {
            return (Date) input.get(name);
        }
        DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        String dateStr = input.get(name).toString().replaceFirst("T", " ").trim();
        try {
            return formatter.parse(dateStr);
        } catch (ParseException e) {
            log.error("Failed parsing {}", dateStr, e);
        }
    }
    return null;
}
#end_block

#method_before
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#method_after
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void init() {
    super.init();
    if (getVm() != null) {
        // Load payload from Database (only if none was sent via the parameters)
        loadPayloadDevice();
        needsHostDevices = hostDeviceManager.checkVmNeedsDirectPassthrough(getVm());
        loadVmInit();
        fetchVmDisksFromDb();
    }
}
#method_after
@Override
protected void init() {
    super.init();
    if (getVm() != null) {
        setStoragePoolId(getVm().getStoragePoolId());
        // Load payload from Database (only if none was sent via the parameters)
        loadPayloadDevice();
        needsHostDevices = hostDeviceManager.checkVmNeedsDirectPassthrough(getVm());
        loadVmInit();
        fetchVmDisksFromDb();
    }
}
#end_block

#method_before
protected boolean isStatelessSnapshotExistsForVm() {
    if (cachedStatelessSnapshotExistsForVm == null) {
        cachedStatelessSnapshotExistsForVm = getSnapshotDao().exists(getVm().getId(), SnapshotType.STATELESS);
    }
    return cachedStatelessSnapshotExistsForVm;
}
#method_after
protected boolean isStatelessSnapshotExistsForVm() {
    if (cachedStatelessSnapshotExistsForVm == null) {
        cachedStatelessSnapshotExistsForVm = snapshotDao.exists(getVm().getId(), SnapshotType.STATELESS);
    }
    return cachedStatelessSnapshotExistsForVm;
}
#end_block

#method_before
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = getDbFacade().getVnicProfileDao().get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks() {
    if (getVm().getInterfaces().isEmpty()) {
        return;
    }
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        VnicProfile vnicProfile = vnicProfileDao.get(iface.getVnicProfileId());
        Network network = NetworkHelper.getNetworkByVnicProfile(vnicProfile);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = providerDao.get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, vnicProfile, iface, getVds());
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice.getId(), deviceProperties);
        }
    }
}
#end_block

#method_before
protected void updateGraphicsInfos() {
    for (VmDevice vmDevice : getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.GRAPHICS)) {
        getVm().getGraphicsInfos().put(GraphicsType.fromString(vmDevice.getDevice()), new GraphicsInfo());
    }
}
#method_after
protected void updateGraphicsInfos() {
    for (VmDevice vmDevice : vmDeviceDao.getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.GRAPHICS)) {
        getVm().getGraphicsInfos().put(GraphicsType.fromString(vmDevice.getDevice()), new GraphicsInfo());
    }
}
#end_block

#method_before
protected VmPayload getVmPayloadByDeviceType(VmDeviceType deviceType) {
    List<VmDevice> vmDevices = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getVm().getId(), VmDeviceGeneralType.DISK, deviceType.getName());
    for (VmDevice vmDevice : vmDevices) {
        if (vmDevice.getIsManaged() && VmPayload.isPayload(vmDevice.getSpecParams())) {
            return new VmPayload(vmDevice);
        }
    }
    return null;
}
#method_after
protected VmPayload getVmPayloadByDeviceType(VmDeviceType deviceType) {
    List<VmDevice> vmDevices = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVm().getId(), VmDeviceGeneralType.DISK, deviceType.getName());
    for (VmDevice vmDevice : vmDevices) {
        if (vmDevice.getIsManaged() && VmPayload.isPayload(vmDevice.getSpecParams())) {
            return new VmPayload(vmDevice);
        }
    }
    return null;
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Optional<Guid> vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdListToRunOn(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.error("Can't find VDS to run the VM '{}' on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        EngineException outEx = new EngineException(EngineError.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error("VmHandler::{}: {}", getClass().getName(), outEx.getMessage());
        return false;
    }
    return true;
}
#end_block

#method_before
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = getVmDeviceDao().getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    if (!rngDevs.isEmpty()) {
        VmRngDevice rngDev = new VmRngDevice(rngDevs.get(0));
        if (!getCluster().getRequiredRngSources().contains(rngDev.getSource())) {
            return false;
        }
    }
    return true;
}
#method_after
boolean checkRngDeviceClusterCompatibility() {
    List<VmDevice> rngDevs = vmDeviceDao.getVmDeviceByVmIdTypeAndDevice(getVmId(), VmDeviceGeneralType.RNG, VmDeviceType.VIRTIO.getName());
    if (!rngDevs.isEmpty()) {
        VmRngDevice rngDev = new VmRngDevice(rngDevs.get(0));
        if (!getCluster().getRequiredRngSources().contains(rngDev.getSource())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
    // If the memory volumes are not used by any other snapshot, we can remove them
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryDisks(memory);
    }
}
#method_after
private void removeMemoryFromActiveSnapshot() {
    String memory = getActiveSnapshot().getMemoryVolume();
    if (StringUtils.isEmpty(memory)) {
        return;
    }
    snapshotDao.removeMemoryFromActiveSnapshot(getVmId());
    // If the memory volumes are not used by any other snapshot, we can remove them
    if (snapshotDao.getNumOfSnapshotsByMemory(memory) == 0) {
        removeMemoryDisks(memory);
    }
}
#end_block

#method_before
protected boolean isVmPartOfManualPool() {
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    final VmPool vmPool = getDbFacade().getVmPoolDao().get(getVm().getVmPoolId());
    return vmPool.getVmPoolType().equals(VmPoolType.MANUAL);
}
#method_after
protected boolean isVmPartOfManualPool() {
    if (getVm().getVmPoolId() == null) {
        return false;
    }
    final VmPool vmPool = vmPoolDao.get(getVm().getVmPoolId());
    return vmPool.getVmPoolType().equals(VmPoolType.MANUAL);
}
#end_block

#method_before
@Override
protected void endExecutionMonitoring() {
    if (getVm().isRunAndPause() && getVmDynamicDao().get(getVmId()).getStatus() == VMStatus.Paused) {
        final ExecutionContext executionContext = getExecutionContext();
        executionContext.setShouldEndJob(true);
        executionHandler.endJob(executionContext, true);
    } else {
        super.endExecutionMonitoring();
    }
}
#method_after
@Override
protected void endExecutionMonitoring() {
    if (getVm().isRunAndPause() && vmDynamicDao.get(getVmId()).getStatus() == VMStatus.Paused) {
        final ExecutionContext executionContext = getExecutionContext();
        executionContext.setShouldEndJob(true);
        executionHandler.endJob(executionContext, true);
    } else {
        super.endExecutionMonitoring();
    }
}
#end_block

#method_before
@Override
public void onPowerringUp() {
    decreasePendingVm(getVmStaticDao().get(getVmId()));
}
#method_after
@Override
public void onPowerringUp() {
    decreasePendingVm(vmStaticDao.get(getVmId()));
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(id, acpiEnabled, appList, bootSequence, clientIp, vncKeyboardLayout, consoleCurrentUserName, guestCurUserName, consoleUserId, guestOs, guestRequestedMemory, lastVdsRunOn, exitMessage, exitStatus, win2kHackEnabled, migratingToVds, pauseStatus, runOnVds, session, status, utcDiff, vmHost, ip, fqdn, lastStartTime, lastStopTime, pid, lastWatchdogEvent, lastWatchdogAction, runOnce, cpuName, guestAgentStatus, currentCd, stopReason, exitReason, emulatedMachine, graphicsInfos, guestOsTimezoneName, guestOsTimezoneOffset, guestOsArch, guestOsCodename, guestOsDistribution, guestOsKernelVersion, guestOsVersion, guestOsType, guestContainers);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(id, acpiEnabled, appList, bootSequence, clientIp, vncKeyboardLayout, consoleCurrentUserName, guestCurUserName, consoleUserId, guestOs, guestRequestedMemory, lastVdsRunOn, exitMessage, exitStatus, migratingToVds, pauseStatus, runOnVds, session, status, utcDiff, vmHost, ip, fqdn, lastStartTime, lastStopTime, pid, lastWatchdogEvent, lastWatchdogAction, runOnce, cpuName, guestAgentStatus, currentCd, stopReason, exitReason, emulatedMachine, graphicsInfos, guestOsTimezoneName, guestOsTimezoneOffset, guestOsArch, guestOsCodename, guestOsDistribution, guestOsKernelVersion, guestOsVersion, guestOsType, guestContainers);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmDynamic)) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(acpiEnabled, other.acpiEnabled) && Objects.equals(appList, other.appList) && bootSequence == other.bootSequence && Objects.equals(clientIp, other.clientIp) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(consoleCurrentUserName, other.consoleCurrentUserName) && Objects.equals(guestCurUserName, other.guestCurUserName) && Objects.equals(consoleUserId, other.consoleUserId) && Objects.equals(guestOs, other.guestOs) && Objects.equals(guestRequestedMemory, other.guestRequestedMemory) && Objects.equals(lastVdsRunOn, other.lastVdsRunOn) && Objects.equals(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && win2kHackEnabled == other.win2kHackEnabled && Objects.equals(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && Objects.equals(runOnVds, other.runOnVds) && session == other.session && status == other.status && Objects.equals(utcDiff, other.utcDiff) && Objects.equals(vmHost, other.vmHost) && Objects.equals(ip, other.ip) && Objects.equals(fqdn, other.fqdn) && Objects.equals(lastStartTime, other.lastStartTime) && Objects.equals(lastStopTime, other.lastStopTime) && Objects.equals(pid, other.pid) && Objects.equals(lastWatchdogEvent, other.lastWatchdogEvent) && Objects.equals(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && Objects.equals(cpuName, other.cpuName) && Objects.equals(guestAgentStatus, other.guestAgentStatus) && Objects.equals(currentCd, other.currentCd) && Objects.equals(stopReason, other.stopReason) && exitReason == other.exitReason && Objects.equals(emulatedMachine, other.emulatedMachine) && Objects.equals(graphicsInfos, other.getGraphicsInfos()) && Objects.equals(guestOsTimezoneName, other.guestOsTimezoneName) && guestOsTimezoneOffset == other.guestOsTimezoneOffset && Objects.equals(guestOsVersion, other.guestOsVersion) && Objects.equals(guestOsDistribution, other.guestOsDistribution) && Objects.equals(guestOsCodename, other.guestOsCodename) && Objects.equals(guestOsKernelVersion, other.guestOsKernelVersion) && Objects.equals(guestOsArch, other.guestOsArch) && Objects.equals(guestOsType, other.guestOsType) && Objects.equals(guestContainers, other.guestContainers);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof VmDynamic)) {
        return false;
    }
    VmDynamic other = (VmDynamic) obj;
    return Objects.equals(id, other.id) && Objects.equals(acpiEnabled, other.acpiEnabled) && Objects.equals(appList, other.appList) && bootSequence == other.bootSequence && Objects.equals(clientIp, other.clientIp) && Objects.equals(vncKeyboardLayout, other.vncKeyboardLayout) && Objects.equals(consoleCurrentUserName, other.consoleCurrentUserName) && Objects.equals(guestCurUserName, other.guestCurUserName) && Objects.equals(consoleUserId, other.consoleUserId) && Objects.equals(guestOs, other.guestOs) && Objects.equals(guestRequestedMemory, other.guestRequestedMemory) && Objects.equals(lastVdsRunOn, other.lastVdsRunOn) && Objects.equals(exitMessage, other.exitMessage) && exitStatus == other.exitStatus && Objects.equals(migratingToVds, other.migratingToVds) && pauseStatus == other.pauseStatus && Objects.equals(runOnVds, other.runOnVds) && session == other.session && status == other.status && Objects.equals(utcDiff, other.utcDiff) && Objects.equals(vmHost, other.vmHost) && Objects.equals(ip, other.ip) && Objects.equals(fqdn, other.fqdn) && Objects.equals(lastStartTime, other.lastStartTime) && Objects.equals(lastStopTime, other.lastStopTime) && Objects.equals(pid, other.pid) && Objects.equals(lastWatchdogEvent, other.lastWatchdogEvent) && Objects.equals(lastWatchdogAction, other.lastWatchdogAction) && runOnce == other.runOnce && Objects.equals(cpuName, other.cpuName) && Objects.equals(guestAgentStatus, other.guestAgentStatus) && Objects.equals(currentCd, other.currentCd) && Objects.equals(stopReason, other.stopReason) && exitReason == other.exitReason && Objects.equals(emulatedMachine, other.emulatedMachine) && Objects.equals(graphicsInfos, other.getGraphicsInfos()) && Objects.equals(guestOsTimezoneName, other.guestOsTimezoneName) && guestOsTimezoneOffset == other.guestOsTimezoneOffset && Objects.equals(guestOsVersion, other.guestOsVersion) && Objects.equals(guestOsDistribution, other.guestOsDistribution) && Objects.equals(guestOsCodename, other.guestOsCodename) && Objects.equals(guestOsKernelVersion, other.guestOsKernelVersion) && Objects.equals(guestOsArch, other.guestOsArch) && Objects.equals(guestOsType, other.guestOsType) && Objects.equals(guestContainers, other.guestContainers);
}
#end_block

#method_before
public void updateRuntimeData(VmDynamic vm, Guid vdsId) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setVmHost(vm.getVmHost());
    setIp(vm.getIp());
    setFqdn(vm.getFqdn());
    setPid(vm.getPid());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    setAppList(vm.getAppList());
    setGuestOs(vm.getGuestOs());
    setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(new HashMap<>(vm.getGraphicsInfos()));
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
    setGuestContainers(vm.getGuestContainers());
}
#method_after
public void updateRuntimeData(VmDynamic vm, Guid vdsId) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setVmHost(vm.getVmHost());
    setIp(vm.getIp());
    setFqdn(vm.getFqdn());
    setPid(vm.getPid());
    // update only if vdsm actually provides some value, otherwise engine has more information
    if (vm.getCurrentCd() != null) {
        setCurrentCd(vm.getCurrentCd());
    }
    setAppList(vm.getAppList());
    setGuestOs(vm.getGuestOs());
    setVncKeyboardLayout(vm.getVncKeyboardLayout());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setExitReason(vm.getExitReason());
    setClientIp(vm.getClientIp());
    setPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
    setGuestCpuCount(vm.getGuestCpuCount());
    setGraphicsInfos(new HashMap<>(vm.getGraphicsInfos()));
    setGuestOsArch(vm.getGuestOsArch());
    setGuestOsCodename(vm.getGuestOsCodename());
    setGuestOsDistribution(vm.getGuestOsDistribution());
    setGuestOsKernelVersion(vm.getGuestOsKernelVersion());
    setGuestOsType(vm.getGuestOsType());
    setGuestOsVersion(vm.getGuestOsVersion());
    setGuestOsTimezoneName(vm.getGuestOsTimezoneName());
    setGuestOsTimezoneOffset(vm.getGuestOsTimezoneOffset());
    setGuestContainers(vm.getGuestContainers());
}
#end_block

#method_before
@Test
public void testVmPassesCpuSocketValidation() {
    setVmCpuValues(1, 1, 1);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), isValid());
}
#method_after
@Test
public void testVmPassesCpuSocketValidation() {
    setVmCpuValues(1, 1, 1);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), isValid());
}
#end_block

#method_before
@Test
public void testVmExceedsMaxNumOfVmCpus() {
    setVmCpuValues(2, 3, 3);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU));
}
#method_after
@Test
public void testVmExceedsMaxNumOfVmCpus() {
    setVmCpuValues(2, 3, 3);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_CPU));
}
#end_block

#method_before
@Test
public void testVmExceedsMaxNumOfSockets() {
    setVmCpuValues(MAX_NUM_SOCKETS + 1, 1, 1);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS));
}
#method_after
@Test
public void testVmExceedsMaxNumOfSockets() {
    setVmCpuValues(MAX_NUM_SOCKETS + 1, 1, 1);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS));
}
#end_block

#method_before
@Test
public void testVmExceedsMaxNumOfCpusPerSocket() {
    setVmCpuValues(1, MAX_NUM_CPUS_PER_SOCKET + 1, 1);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET));
}
#method_after
@Test
public void testVmExceedsMaxNumOfCpusPerSocket() {
    setVmCpuValues(1, MAX_NUM_CPUS_PER_SOCKET + 1, 1);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET));
}
#end_block

#method_before
@Test
public void testVmExceedsMaxThreadsPerCpu() {
    setVmCpuValues(1, 1, MAX_NUM_THREADS_PER_CPU + 1);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU));
}
#method_after
@Test
public void testVmExceedsMaxThreadsPerCpu() {
    setVmCpuValues(1, 1, MAX_NUM_THREADS_PER_CPU + 1);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MAX_THREADS_PER_CPU));
}
#end_block

#method_before
@Test
public void testVmUnderMinNumOfSockets() {
    setVmCpuValues(1, -2, 1);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET));
}
#method_after
@Test
public void testVmUnderMinNumOfSockets() {
    setVmCpuValues(1, -2, 1);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET));
}
#end_block

#method_before
@Test
public void testVmUnderMinNumOfCpusPerSocket() {
    setVmCpuValues(-2, 1, 1);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS));
}
#method_after
@Test
public void testVmUnderMinNumOfCpusPerSocket() {
    setVmCpuValues(-2, 1, 1);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS));
}
#end_block

#method_before
@Test
public void testVmUnderMinNumOfThreadsPerCpu() {
    setVmCpuValues(1, 1, -2);
    assertThat(validator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MIN_THREADS_PER_CPU));
}
#method_after
@Test
public void testVmUnderMinNumOfThreadsPerCpu() {
    setVmCpuValues(1, 1, -2);
    assertThat(VmValidator.validateCpuSockets(vm.getStaticData(), COMPAT_VERSION_FOR_CPU_SOCKET_TEST), failsWith(EngineMessage.ACTION_TYPE_FAILED_MIN_THREADS_PER_CPU));
}
#end_block

#method_before
public void validate() {
    if (!StompClientPolicy.class.isInstance(this.policy)) {
        throw new IllegalStateException("Wrong policy type");
    }
}
#method_after
public void validate(ClientPolicy policy) {
    if (!StompClientPolicy.class.isInstance(policy)) {
        throw new IllegalStateException("Wrong policy type");
    }
}
#end_block

#method_before
private void processChannels() {
    for (final SelectionKey key : this.selector.selectedKeys()) {
        if (!key.isValid()) {
            continue;
        }
        if (key.isAcceptable()) {
            final ReactorListener obj = (ReactorListener) key.attachment();
            final ReactorClient client = obj.accept();
            if (client == null) {
                continue;
            }
        }
        if (key.isValid() && (key.isReadable() || key.isWritable())) {
            final ReactorClient client = (ReactorClient) key.attachment();
            try {
                client.process();
            } catch (IOException | ClientConnectionException ex) {
                logException(LOG, "Unable to process messages: " + ex.getMessage(), ex);
                client.disconnect(ex.getMessage() != null ? ex.getMessage() : "Unable to process messages");
                key.cancel();
            } catch (Throwable e) {
                logException(LOG, "Internal server error: " + e.getMessage(), e);
                client.disconnect(e.getMessage() != null ? e.getMessage() : "Internal server error");
                key.cancel();
            }
        }
        checkActions(this.selector.keys());
        if (!key.channel().isOpen()) {
            key.cancel();
        }
    }
}
#method_after
private void processChannels() {
    this.selector.selectedKeys().stream().filter(key -> key.isValid()).filter(key -> !(key.isAcceptable() && ((ReactorListener) key.attachment()).accept() == null)).forEach(key -> {
        if (key.isReadable() || key.isWritable()) {
            final ReactorClient client = (ReactorClient) key.attachment();
            try {
                client.process();
            } catch (IOException | ClientConnectionException ex) {
                logException(LOG, "Unable to process messages: " + ex.getMessage(), ex);
                client.disconnect(ex.getMessage() != null ? ex.getMessage() : "Unable to process messages");
                key.cancel();
            } catch (Throwable e) {
                logException(LOG, "Internal server error: " + e.getMessage(), e);
                client.disconnect(e.getMessage() != null ? e.getMessage() : "Internal server error");
                key.cancel();
            }
        }
        checkActions(this.selector.keys());
        if (!key.channel().isOpen()) {
            key.cancel();
        }
    });
}
#end_block

#method_before
public void processIssue(JsonRpcResponse response) {
    JsonNode error = response.getError();
    Map<String, Object> map = mapValues(error);
    String code = (String) map.get("code");
    String message = (String) map.get("message");
    JsonRpcResponse errorResponse = buildErrorResponse(null, 5022, message);
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (ReactorClient.CLIENT_CLOSED.equals(message)) {
            removeNodes(this.hostToId.get(code), errorResponse);
        } else {
            String hostname = code.substring(0, code.indexOf(":"));
            Set<String> keys = this.hostToId.keySet();
            for (String key : keys) {
                if (key.startsWith(hostname)) {
                    removeNodes(this.hostToId.get(key), errorResponse);
                }
            }
        }
    }
}
#method_after
public void processIssue(JsonRpcResponse response) {
    JsonNode error = response.getError();
    Map<String, Object> map = mapValues(error);
    String code = (String) map.get("code");
    String message = (String) map.get("message");
    JsonRpcResponse errorResponse = buildErrorResponse(null, 5022, message);
    try (LockWrapper wrapper = new LockWrapper(this.lock)) {
        if (ReactorClient.CLIENT_CLOSED.equals(message)) {
            removeNodes(this.hostToId.get(code), errorResponse);
        } else {
            String hostname = code.substring(0, code.indexOf(":"));
            this.hostToId.keySet().stream().filter(key -> key.startsWith(hostname)).forEach(key -> removeNodes(this.hostToId.get(key), errorResponse));
        }
    }
}
#end_block

#method_before
private SafeHtml createBondTooltipMessage(HostInterfaceLineModel lineModel, InterfaceStatus interfaceStatus) {
    Bond bond = (Bond) lineModel.getInterface();
    StringBuilder bondProperties = new StringBuilder(messages.bondStatus(interfaceStatus.toString()));
    boolean isBond4 = BondMode.BOND4.equals(BondMode.parseBondMode(bond.getBondOptions()));
    if (InterfaceStatus.UP.equals(interfaceStatus) && isBond4) {
        // $NON-NLS-1$
        bondProperties.append("\n").append(createActiveBondTooltipMessage(bond, lineModel));
    }
    if ((bond.getActiveSlave() != null) && (bond.getActiveSlave().length() > 0)) {
        // $NON-NLS-1$
        bondProperties.append("\n");
        bondProperties.append(messages.bondActiveSlave(bond.getActiveSlave()));
    }
    return new SafeHtmlBuilder().appendEscapedLines(bondProperties.toString()).toSafeHtml();
}
#method_after
private SafeHtml createBondTooltipMessage(HostInterfaceLineModel lineModel, InterfaceStatus interfaceStatus) {
    Bond bond = (Bond) lineModel.getInterface();
    StringBuilder bondProperties = new StringBuilder(messages.bondStatus(interfaceStatus.toString()));
    boolean isBond4 = BondMode.BOND4.equals(BondMode.parseBondMode(bond.getBondOptions()));
    if (InterfaceStatus.UP.equals(interfaceStatus) && isBond4) {
        // $NON-NLS-1$
        bondProperties.append("\n").append(createActiveBondTooltipMessage(bond, lineModel));
    }
    if ((bond.getActiveSlave() != null) && (bond.getActiveSlave().length() > 0)) {
        // $NON-NLS-1$
        bondProperties.append("\n").append(messages.bondActiveSlave(bond.getActiveSlave()));
    }
    return new SafeHtmlBuilder().appendEscapedLines(bondProperties.toString()).toSafeHtml();
}
#end_block

#method_before
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = new AuditLogableBase(vds.getId());
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#method_after
public static void checkTimeDrift(VDS vds, Map<String, Object> xmlRpcStruct) {
    Boolean isHostTimeDriftEnabled = Config.getValue(ConfigValues.EnableHostTimeDrift);
    if (isHostTimeDriftEnabled) {
        Integer maxTimeDriftAllowed = Config.getValue(ConfigValues.HostTimeDriftInSec);
        Date hostDate = assignDatetimeValue(xmlRpcStruct, VdsProperties.hostDatetime);
        if (hostDate != null) {
            Long timeDrift = TimeUnit.MILLISECONDS.toSeconds(Math.abs(hostDate.getTime() - System.currentTimeMillis()));
            if (timeDrift > maxTimeDriftAllowed) {
                AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
                logable.addCustomValue("Actual", timeDrift.toString());
                logable.addCustomValue("Max", maxTimeDriftAllowed.toString());
                auditLogDirector.log(logable, AuditLogType.VDS_TIME_DRIFT_ALERT);
            }
        } else {
            log.error("Time Drift validation: failed to get Host or Engine time.");
        }
    }
}
#end_block

#method_before
private static Date assignDatetimeValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Date) {
            return (Date) input.get(name);
        }
        DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        try {
            String dateStr = input.get(name).toString().replaceFirst("T", " ").trim();
            return formatter.parse(dateStr);
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
    return null;
}
#method_after
private static Date assignDatetimeValue(Map<String, Object> input, String name) {
    if (input.containsKey(name)) {
        if (input.get(name) instanceof Date) {
            return (Date) input.get(name);
        }
        DateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z");
        String dateStr = input.get(name).toString().replaceFirst("T", " ").trim();
        try {
            return formatter.parse(dateStr);
        } catch (ParseException e) {
            log.error("Failed parsing {}", dateStr, e);
        }
    }
    return null;
}
#end_block

#method_before
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = new AuditLogableBase(vds.getId());
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#method_after
protected static AuditLogableBase createHostNetworkAuditLog(String networkName, VDS vds) {
    AuditLogableBase logable = Injector.injectMembers(new AuditLogableBase(vds.getId()));
    logable.addCustomValue("NetworkName", networkName);
    return logable;
}
#end_block

#method_before
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            VdsNetworkInterface bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setBondActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#method_after
private static void addHostBondDevices(VDS vds, Map<String, Object> xmlRpcStruct) {
    Map<String, Map<String, Object>> bonds = (Map<String, Map<String, Object>>) xmlRpcStruct.get(VdsProperties.NETWORK_BONDINGS);
    if (bonds != null) {
        for (Entry<String, Map<String, Object>> entry : bonds.entrySet()) {
            Bond bond = new Bond();
            updateCommonInterfaceData(bond, vds, entry);
            bond.setBonded(true);
            Map<String, Object> bondProperties = entry.getValue();
            if (bondProperties != null) {
                bond.setMacAddress((String) bondProperties.get("hwaddr"));
                if (bondProperties.get("slaves") != null) {
                    addBondDeviceToHost(vds, bond, (Object[]) bondProperties.get("slaves"));
                }
                Object bondOptions = null;
                Map<String, Object> bondOptionsMap = new HashMap<>();
                Map<String, Object> bondOpts = (Map<String, Object>) bondProperties.get("opts");
                if (bondOpts != null) {
                    bondOptionsMap.putAll(bondOpts);
                }
                String bondOptionsString = "";
                String mode = (String) bondOptionsMap.get("mode");
                String miimon = (String) bondOptionsMap.get("miimon");
                if (mode != null && miimon != null) {
                    bondOptionsString = String.format("mode=%s miimon=%s", mode, miimon);
                    bondOptionsMap.remove("mode");
                    bondOptionsMap.remove("miimon");
                }
                for (Entry<String, Object> optionEntry : bondOptionsMap.entrySet()) {
                    bondOptionsString = String.format("%s %s=%s", bondOptionsString, optionEntry.getKey(), optionEntry.getValue());
                }
                bondOptions = bondOptionsString.isEmpty() ? null : bondOptionsString;
                if (bondOptions != null) {
                    bondOptions = normalizeBondOptions(bondOptions.toString());
                    bond.setBondOptions(bondOptions.toString());
                }
                bond.setAdPartnerMac((String) bondProperties.get("ad_partner_mac"));
                bond.setActiveSlave((String) bondProperties.get("active_slave"));
            }
        }
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new HostedEngineEditNotifier(getVm()));
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    // needs to be here for post-actions
    oldVm = getVm();
    if (isUpdateVmTemplateVersion) {
        updateVmTemplateVersion();
        // template version was changed, no more work is required
        return;
    }
    if (isRunningConfigurationNeeded()) {
        createNextRunSnapshot();
    }
    VmHandler.warnMemorySizeLegal(getParameters().getVm().getStaticData(), getEffectiveCompatibilityVersion());
    vmStaticDao.incrementDbGeneration(getVm().getId());
    newVmStatic = getParameters().getVmStaticData();
    newVmStatic.setCreationDate(oldVm.getStaticData().getCreationDate());
    newVmStatic.setQuotaId(getQuotaId());
    // Trigger OVF update for hosted engine VM only
    if (getVm().isHostedEngine()) {
        registerRollbackHandler(new TransactionCompletionListener() {

            @Override
            public void onSuccess() {
                OvfDataUpdater.getInstance().triggerNow();
            }

            @Override
            public void onRollback() {
            // No notification is needed
            }
        });
    }
    // save user selected value for hotplug before overriding with db values (when updating running vm)
    VM userVm = new VM();
    userVm.setStaticData(new VmStatic(newVmStatic));
    if (newVmStatic.getCreationDate().equals(DateTime.getMinValue())) {
        newVmStatic.setCreationDate(new Date());
    }
    if (getVm().isRunningOrPaused() && !getVm().isHostedEngine()) {
        if (!VmHandler.copyNonEditableFieldsToDestination(oldVm.getStaticData(), newVmStatic, isHotSetEnabled())) {
            // fail update vm if some fields could not be copied
            throw new EngineException(EngineError.FAILED_UPDATE_RUNNING_VM);
        }
    }
    if ((getVm().isRunningOrPaused() || getVm().isPreviewSnapshot() || getVm().isSuspended()) && !getVm().isHostedEngine()) {
        if (getVm().getCustomCompatibilityVersion() == null && getParameters().getClusterLevelChangeFromVersion() != null) {
            // For backward compatibility after cluster version change
            // When running/paused: Set temporary custom compatibility version till the NextRun is applied (VM cold reboot)
            // When snapshot in preview: keep the custom compatibility version even after commit or roll back by undo
            newVmStatic.setCustomCompatibilityVersion(getParameters().getClusterLevelChangeFromVersion());
        }
    }
    updateVmNetworks();
    updateVmNumaNodes();
    if (isHotSetEnabled()) {
        hotSetCpus(userVm);
        updateCurrentMemory(userVm);
    }
    final List<Guid> oldIconIds = IconUtils.updateVmIcon(oldVm.getStaticData(), newVmStatic, getParameters().getVmLargeIcon());
    resourceManager.getVmManager(getVmId()).update(newVmStatic);
    if (getVm().isNotRunning()) {
        updateVmPayload();
        getVmDeviceUtils().updateVmDevices(getParameters(), oldVm);
        updateWatchdog();
        updateRngDevice();
        updateGraphicsDevices();
        updateVmHostDevices();
        updateDeviceAddresses();
    }
    IconUtils.removeUnusedIcons(oldIconIds);
    VmHandler.updateVmInitToDB(getParameters().getVmStaticData());
    checkTrustedService();
    liveUpdateCpuProfile();
    setSucceeded(true);
}
#end_block

#method_before
private void applyNextRunConfiguration() {
    // Remove snpashot first, in case other update is in progress, it will block this one with exclusive lock
    // and any newer update should be preffered to this one.
    Snapshot runSnap = snapshotDao.get(getVmId(), SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        log.debug("Attempt to apply NEXT_RUN snapshot for VM '{}'", getVmId());
        EngineLock updateVmLock = createUpdateVmLock();
        if (lockManager.acquireLock(updateVmLock).getFirst()) {
            try {
                snapshotDao.remove(runSnap.getId());
                Date originalCreationDate = getVm().getVmCreationDate();
                snapshotsManager.updateVmFromConfiguration(getVm(), runSnap.getVmConfiguration());
                // override creation date because the value in the config is the creation date of the config, not the vm
                getVm().setVmCreationDate(originalCreationDate);
                VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, createUpdateVmParameters(), ExecutionHandler.createInternalJobContext(updateVmLock));
                if (result.getActionReturnValue() != null && result.getActionReturnValue().equals(VdcActionType.UpdateVmVersion)) {
                    // Template-version changed
                    templateVersionChanged = true;
                }
            } finally {
                lockManager.releaseLock(updateVmLock);
            }
        } else {
            log.warn("Could not acquire lock for UpdateVmCommand to apply Next Run Config of VM '{}'", getVmId());
        }
    }
}
#method_after
private void applyNextRunConfiguration() {
    // Remove snpashot first, in case other update is in progress, it will block this one with exclusive lock
    // and any newer update should be preffered to this one.
    Snapshot runSnap = snapshotDao.get(getVmId(), SnapshotType.NEXT_RUN);
    if (runSnap != null) {
        log.debug("Attempt to apply NEXT_RUN snapshot for VM '{}'", getVmId());
        EngineLock updateVmLock = createUpdateVmLock();
        if (lockManager.acquireLock(updateVmLock).getFirst()) {
            snapshotDao.remove(runSnap.getId());
            Date originalCreationDate = getVm().getVmCreationDate();
            snapshotsManager.updateVmFromConfiguration(getVm(), runSnap.getVmConfiguration());
            // override creation date because the value in the config is the creation date of the config, not the vm
            getVm().setVmCreationDate(originalCreationDate);
            VdcReturnValueBase result = runInternalAction(VdcActionType.UpdateVm, createUpdateVmParameters(), ExecutionHandler.createInternalJobContext(updateVmLock));
            if (result.getActionReturnValue() != null && result.getActionReturnValue().equals(VdcActionType.UpdateVmVersion)) {
                // Template-version changed
                templateVersionChanged = true;
            }
        } else {
            log.warn("Could not acquire lock for UpdateVmCommand to apply Next Run Config of VM '{}'", getVmId());
        }
    }
}
#end_block

#method_before
private List<Provider> getBackendCollection() {
    if (isFiltered()) {
        return getBackendCollection(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK));
    } else {
        return getBackendCollection(SearchType.Provider, getConstraint());
    }
}
#method_after
private List<Provider> getBackendCollection() {
    if (isFiltered()) {
        return getBackendCollection(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(ProviderType.OPENSTACK_NETWORK, ProviderType.EXTERNAL_NETWORK));
    } else {
        List<Provider> openstackCollection = getBackendCollection(SearchType.Provider, getConstraint(ProviderType.OPENSTACK_NETWORK.name()));
        List<Provider> externalCollection = getBackendCollection(SearchType.Provider, getConstraint(ProviderType.EXTERNAL_NETWORK.name()));
        openstackCollection.addAll(externalCollection);
        return openstackCollection;
    }
}
#end_block

#method_before
private String getConstraint() {
    StringBuilder buffer = new StringBuilder();
    buffer.append("Providers: type=");
    buffer.append(ProviderType.OPENSTACK_NETWORK.name());
    buffer.append(" or type=");
    buffer.append(ProviderType.EXTERNAL_NETWORK.name());
    String query = QueryHelper.getConstraint(httpHeaders, uriInfo, null, modelType, false);
    if (StringUtils.isNotBlank(query)) {
        buffer.append(" AND (");
        buffer.append(query);
        buffer.append(")");
    }
    return buffer.toString();
}
#method_after
private String getConstraint(String providerType) {
    StringBuilder buffer = new StringBuilder();
    buffer.append("Providers: type=");
    buffer.append(providerType);
    String query = QueryHelper.getConstraint(httpHeaders, uriInfo, null, modelType, false);
    if (StringUtils.isNotBlank(query)) {
        buffer.append(" AND (");
        buffer.append(query);
        buffer.append(")");
    }
    return buffer.toString();
}
#end_block

#method_before
private static AddDiskParameters createParameters() {
    DiskImage image = new DiskImage();
    DiskVmElement dve = new DiskVmElement(null, vmId);
    dve.setDiskInterface(DiskInterface.IDE);
    dve.setUsingScsiReservation(true);
    return new AddDiskParameters(dve, image);
}
#method_after
private static AddDiskParameters createParameters() {
    DiskImage image = new DiskImage();
    DiskVmElement dve = new DiskVmElement(null, vmId);
    dve.setDiskInterface(DiskInterface.IDE);
    return new AddDiskParameters(dve, image);
}
#end_block

#method_before
@Test
public void testIscsiLunCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    DiskVmElement dve = new DiskVmElement();
    command.getParameters().getDiskVmElement().setUsingScsiReservation(false);
    assertTrue("checkIfLunDiskCanBeAdded() failed for valid iscsi lun", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
}
#method_after
@Test
public void testIscsiLunCanBeAdded() {
    LunDisk disk = createISCSILunDisk();
    command.getParameters().setDiskInfo(disk);
    command.getParameters().getDiskVmElement().setUsingScsiReservation(false);
    assertTrue("checkIfLunDiskCanBeAdded() failed for valid iscsi lun", command.checkIfLunDiskCanBeAdded(spyDiskValidator(disk)));
}
#end_block

#method_before
@Test
public void canDisableVirtioScsiFail() {
    Disk disk = new DiskImage();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vm.getId());
    dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setDiskVmElements(Collections.singletonList(dve));
    when(DbFacade.getInstance().getVmNetworkInterfaceDao()).thenReturn(vmNetworkInterfaceDao);
    assertThat(validator.canDisableVirtioScsi(Collections.singletonList(disk)), failsWith(EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS));
}
#method_after
@Test
public void canDisableVirtioScsiFail() {
    Disk disk = new DiskImage();
    DiskVmElement dve = new DiskVmElement(disk.getId(), vm.getId());
    dve.setDiskInterface(DiskInterface.VirtIO_SCSI);
    disk.setDiskVmElements(Collections.singletonList(dve));
    assertThat(validator.canDisableVirtioScsi(Collections.singletonList(disk)), failsWith(EngineMessage.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS));
}
#end_block

#method_before
@Before
public void setUp() {
    createVm();
    MigrateVmParameters params = new MigrateVmParameters(false, vm.getId());
    command = spy(new MigrateVmCommand<>(params, null));
    doReturn(vm).when(command).getVm();
}
#method_after
@Before
public void setUp() {
    VM vm = new VM();
    vm.setId(vmId);
    command.setVm(vm);
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator(Collections.singletonList((DiskImage) getOldDisk())).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
private void auditLogForNoMetadataDescriptionUpdate(AuditLogType auditLogType, StorageDomain storageDomain, DiskImage diskImage) {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
    auditLogableBase.addCustomValue("StorageDomainName", storageDomain.getName());
    auditLogableBase.addCustomValue("DiskName", diskImage.getDiskAlias());
    auditLogDirector.log(auditLogableBase, auditLogType);
}
#method_after
private void auditLogForNoMetadataDescriptionUpdate(AuditLogType auditLogType, StorageDomain storageDomain, DiskImage diskImage) {
    addCustomValue("DataCenterName", getStoragePool().getName());
    addCustomValue("StorageDomainName", storageDomain.getName());
    addCustomValue("DiskName", diskImage.getDiskAlias());
    auditLogDirector.log(this, auditLogType);
}
#end_block

#method_before
// I fail to understand the logic of this test, by its name it seems that it's supposed to check whether migration
// can be set when scsi reservation is on but:
// 1. Scsi reservation in the test is set to false
// 2. Nothin in UpdateVmCommand test or ever refers in any way to the scsi reservation value
// so unless someone can tell me why this test is needed I'm gonna remove it
// 
// @Test
// public void testMigratoinCanBeSetWhenVMUsesScsiReservation() {
// prepareVmToPassValidate();
// vm.setMigrationSupport(MigrationSupport.MIGRATABLE);
// VmDevice device = createVmDevice();
// device.setUsingScsiReservation(false);
// 
// mockVmDevice(device);
// mockVmValidator();
// 
// command.initEffectiveCompatibilityVersion();
// ValidateTestUtils.runAndAssertValidateSuccess(command);
// }
@Test
public void testBlockingHostedEngineEditing() {
    // given
    mcr.mockConfigValue(ConfigValues.AllowEditingHostedEngine, false);
    vmStatic.setOrigin(OriginType.MANAGED_HOSTED_ENGINE);
    // when
    boolean validInput = command.validateInputs();
    // then
    assertThat(validInput, is(false));
    assertTrue(command.getReturnValue().getValidationMessages().contains(ACTION_TYPE_FAILED_EDITING_HOSTED_ENGINE_IS_DISABLED.name()));
}
#method_after
@Test
public void testBlockingHostedEngineEditing() {
    // given
    mcr.mockConfigValue(ConfigValues.AllowEditingHostedEngine, false);
    vmStatic.setOrigin(OriginType.MANAGED_HOSTED_ENGINE);
    // when
    boolean validInput = command.validateInputs();
    // then
    assertThat(validInput, is(false));
    assertTrue(command.getReturnValue().getValidationMessages().contains(ACTION_TYPE_FAILED_EDITING_HOSTED_ENGINE_IS_DISABLED.name()));
}
#end_block

#method_before
private void mockVmValidator() {
    VmValidator vmValidator = spy(new VmValidator(vm));
    doReturn(vmValidator).when(command).createVmValidator(vm);
    doReturn(dbFacade).when(vmValidator).getDbFacade();
    doReturn(diskDao).when(vmValidator).getDiskDao();
    doReturn(getNoVirtioScsiDiskElement()).when(diskVmElementDao).get(any(VmDeviceId.class));
    doReturn(diskVmElementDao).when(vmValidator).getDiskVmElementDao();
}
#method_after
private void mockVmValidator() {
    VmValidator vmValidator = spy(new VmValidator(vm));
    doReturn(vmValidator).when(command).createVmValidator(vm);
    doReturn(diskDao).when(vmValidator).getDiskDao();
    doReturn(getNoVirtioScsiDiskElement()).when(diskVmElementDao).get(any(VmDeviceId.class));
    doReturn(diskVmElementDao).when(vmValidator).getDiskVmElementDao();
}
#end_block

#method_before
private DiskVmElement createDiskVmElementUsingScsiReserevation() {
    DiskVmElement dve = new DiskVmElement();
    dve.setUsingScsiReservation(true);
    return dve;
}
#method_after
private static DiskVmElement createDiskVmElementUsingScsiReserevation() {
    DiskVmElement dve = new DiskVmElement();
    dve.setUsingScsiReservation(true);
    return dve;
}
#end_block

#method_before
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Guid vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (vdsToRunOn != null && vdsToRunOn.equals(Guid.Empty)) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#method_after
protected boolean initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    Optional<Guid> vdsToRunOn = schedulingManager.schedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), new ArrayList<>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setDestinationVdsId(vdsToRunOn.orElse(null));
    if (vdsToRunOn.isPresent()) {
        getRunVdssList().add(vdsToRunOn.get());
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    if (!vdsToRunOn.isPresent()) {
        return false;
    }
    if (getDestinationVds() == null || getVds() == null) {
        return false;
    }
    return true;
}
#end_block

#method_before
private AuditLogType getAuditLogForMigrationStarted() {
    return isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START;
}
#method_after
private AuditLogType getAuditLogForMigrationStarted() {
    addCustomValue("OptionalReason", getParameters().getReason());
    return isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START;
}
#end_block

#method_before
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = getVmValidator();
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion(), getVmDeviceUtils());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#method_after
@Override
protected boolean validate() {
    final VM vm = getVm();
    if (vm == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    VmValidator vmValidator = getVmValidator();
    if (!validate(vmValidator.isVmPluggedDiskNotUsingScsiReservation())) {
        return false;
    }
    if (!FeatureSupported.isMigrationSupported(getCluster().getArchitecture(), getCluster().getCompatibilityVersion())) {
        return failValidation(EngineMessage.MIGRATION_IS_NOT_SUPPORTED);
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !getParameters().isForceMigrationForNonMigratableVm()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    switch(vm.getStatus()) {
        case MigratingFrom:
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
        case NotResponding:
            return failVmStatusIllegal();
        case Paused:
            if (vm.getVmPauseStatus() == VmPauseStatus.EIO) {
                return failValidation(EngineMessage.MIGRATE_PAUSED_EIO_VM_IS_NOT_SUPPORTED);
            }
            break;
        default:
    }
    if (!vm.isQualifyToMigrate()) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (!validate(new MultipleVmsValidator(vm).vmNotHavingPluggedDiskSnapshots(EngineMessage.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT)) || !validate(vmValidator.vmNotHavingPassthroughVnics())) {
        return false;
    }
    if (getParameters().getTargetClusterId() != null) {
        ChangeVmClusterValidator changeVmClusterValidator = new ChangeVmClusterValidator(this, getParameters().getTargetClusterId(), getVm().getCustomCompatibilityVersion(), getVmDeviceUtils());
        if (!changeVmClusterValidator.validate()) {
            return false;
        }
    }
    if (isInternalExecution() && getVm().getMigrationSupport() != MigrationSupport.MIGRATABLE) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && schedulingManager.canSchedule(getCluster(), getVm(), getVdsBlackList(), getVdsWhiteList(), getDestinationHostList(), getReturnValue().getValidationMessages());
}
#end_block

#method_before
@Mapping(from = DiskAttachment.class, to = org.ovirt.engine.core.common.businessentities.storage.DiskVmElement.class)
public static org.ovirt.engine.core.common.businessentities.storage.DiskVmElement map(DiskAttachment model, org.ovirt.engine.core.common.businessentities.storage.DiskVmElement template) {
    org.ovirt.engine.core.common.businessentities.storage.DiskVmElement entity = template != null ? template : new DiskVmElement();
    if (model.isSetId()) {
        entity.setId(new VmDeviceId(GuidUtils.asGuid(model.getId()), null));
    } else {
        entity.setId(new VmDeviceId());
    }
    if (model.isSetBootable()) {
        entity.setBoot(model.isBootable());
    }
    if (model.isSetInterface()) {
        entity.setDiskInterface(DiskMapper.mapInterface(model.getInterface()));
    }
    if (model.isSetUsingScsiReservation()) {
        entity.setUsingScsiReservation(model.isUsingScsiReservation());
    }
    return entity;
}
#method_after
@Mapping(from = DiskAttachment.class, to = org.ovirt.engine.core.common.businessentities.storage.DiskVmElement.class)
public static org.ovirt.engine.core.common.businessentities.storage.DiskVmElement map(DiskAttachment model, org.ovirt.engine.core.common.businessentities.storage.DiskVmElement template) {
    org.ovirt.engine.core.common.businessentities.storage.DiskVmElement entity = template != null ? template : new DiskVmElement();
    if (model.isSetId()) {
        entity.setId(new VmDeviceId(GuidUtils.asGuid(model.getId()), null));
    } else {
        entity.setId(new VmDeviceId());
    }
    if (model.isSetBootable()) {
        entity.setBoot(model.isBootable());
    }
    if (model.isSetInterface()) {
        entity.setDiskInterface(DiskMapper.mapInterface(model.getInterface()));
    }
    if (model.isSetUsesScsiReservation()) {
        entity.setUsingScsiReservation(model.isUsesScsiReservation());
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.storage.DiskVmElement.class, to = DiskAttachment.class)
public static DiskAttachment map(org.ovirt.engine.core.common.businessentities.storage.DiskVmElement entity, DiskAttachment template) {
    DiskAttachment model = template != null ? template : new DiskAttachment();
    Guid vmId = entity.getVmId();
    if (vmId != null) {
        Vm vm = new Vm();
        vm.setId(vmId.toString());
        model.setVm(vm);
    }
    Guid diskId = entity.getDiskId();
    if (diskId != null) {
        Disk disk = new Disk();
        disk.setId(diskId.toString());
        model.setDisk(disk);
    }
    model.setId(entity.getDiskId().toString());
    model.setBootable(entity.isBoot());
    model.setInterface(DiskMapper.mapInterface(entity.getDiskInterface()));
    model.setActive(entity.isPlugged());
    model.setLogicalName(entity.getLogicalName());
    model.setUsingScsiReservation(entity.isUsingScsiReservation());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.storage.DiskVmElement.class, to = DiskAttachment.class)
public static DiskAttachment map(org.ovirt.engine.core.common.businessentities.storage.DiskVmElement entity, DiskAttachment template) {
    DiskAttachment model = template != null ? template : new DiskAttachment();
    Guid vmId = entity.getVmId();
    if (vmId != null) {
        Vm vm = new Vm();
        vm.setId(vmId.toString());
        model.setVm(vm);
    }
    Guid diskId = entity.getDiskId();
    if (diskId != null) {
        Disk disk = new Disk();
        disk.setId(diskId.toString());
        model.setDisk(disk);
    }
    model.setId(entity.getDiskId().toString());
    model.setBootable(entity.isBoot());
    model.setInterface(DiskMapper.mapInterface(entity.getDiskInterface()));
    model.setActive(entity.isPlugged());
    model.setLogicalName(entity.getLogicalName());
    model.setUsesScsiReservation(entity.isUsingScsiReservation());
    return model;
}
#end_block

#method_before
public static void addDiskAttachmentDetails(String vmId, List<V3Disk> disks) {
    if (vmId != null) {
        SystemResource systemResource = BackendApiResource.getInstance();
        VmsResource vmsResource = systemResource.getVmsResource();
        VmResource vmResource = vmsResource.getVmResource(vmId);
        DiskAttachmentsResource attachmentsResource = vmResource.getDiskAttachmentsResource();
        for (V3Disk disk : disks) {
            String diskId = disk.getId();
            if (diskId != null) {
                DiskAttachmentResource attachmentResource = attachmentsResource.getAttachmentResource(diskId);
                try {
                    DiskAttachment attachment = attachmentResource.get();
                    if (attachment.isSetBootable()) {
                        disk.setBootable(attachment.isBootable());
                    }
                    if (attachment.isSetInterface()) {
                        disk.setInterface(attachment.getInterface().toString().toLowerCase());
                    }
                    if (attachment.isSetLogicalName()) {
                        disk.setLogicalName(attachment.getLogicalName());
                    }
                    if (attachment.isSetActive()) {
                        disk.setActive(attachment.isActive());
                    }
                    if (attachment.isSetUsingScsiReservation()) {
                        disk.setUsesScsiReservation(attachment.isUsingScsiReservation());
                    }
                } catch (WebApplicationException exception) {
                // If an application exception is generated while retrieving the details of the disk attachment
                // it is safe to ignore it, as it may be that the user just doesn't have permission to see
                // attachment, but she may still have permissions to see the other details of the disk.
                }
            }
        }
    }
}
#method_after
public static void addDiskAttachmentDetails(String vmId, List<V3Disk> disks) {
    if (vmId != null) {
        SystemResource systemResource = BackendApiResource.getInstance();
        VmsResource vmsResource = systemResource.getVmsResource();
        VmResource vmResource = vmsResource.getVmResource(vmId);
        DiskAttachmentsResource attachmentsResource = vmResource.getDiskAttachmentsResource();
        for (V3Disk disk : disks) {
            String diskId = disk.getId();
            if (diskId != null) {
                DiskAttachmentResource attachmentResource = attachmentsResource.getAttachmentResource(diskId);
                try {
                    DiskAttachment attachment = attachmentResource.get();
                    if (attachment.isSetBootable()) {
                        disk.setBootable(attachment.isBootable());
                    }
                    if (attachment.isSetInterface()) {
                        disk.setInterface(attachment.getInterface().toString().toLowerCase());
                    }
                    if (attachment.isSetLogicalName()) {
                        disk.setLogicalName(attachment.getLogicalName());
                    }
                    if (attachment.isSetActive()) {
                        disk.setActive(attachment.isActive());
                    }
                    if (attachment.isSetUsesScsiReservation()) {
                        disk.setUsesScsiReservation(attachment.isUsesScsiReservation());
                    }
                } catch (WebApplicationException exception) {
                // If an application exception is generated while retrieving the details of the disk attachment
                // it is safe to ignore it, as it may be that the user just doesn't have permission to see
                // attachment, but she may still have permissions to see the other details of the disk.
                }
            }
        }
    }
}
#end_block

#method_before
private Map<String, List<Pair<VDS, LUNs>>> createLunMap(boolean sameLunSizesPerHost) {
    RandomUtils rnd = RandomUtils.instance();
    String lunId = rnd.nextString(34);
    int lunSize = rnd.nextInt();
    List<Pair<VDS, LUNs>> lunList = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        LUNs lun = new LUNs();
        if (!sameLunSizesPerHost) {
            lunSize++;
        }
        lun.setDeviceSize(lunSize);
        lunList.add(new Pair<>(new VDS(), lun));
    }
    return new SingletonMap(lunId, lunList);
}
#method_after
private Map<String, List<Pair<VDS, LUNs>>> createLunMap(boolean sameLunSizesPerHost) {
    RandomUtils rnd = RandomUtils.instance();
    String lunId = rnd.nextString(34);
    int lunSize = rnd.nextInt();
    List<Pair<VDS, LUNs>> lunList = new ArrayList<>();
    for (int i = 0; i < 10; i++) {
        LUNs lun = new LUNs();
        if (!sameLunSizesPerHost) {
            lunSize++;
        }
        lun.setDeviceSize(lunSize);
        lunList.add(new Pair<>(new VDS(), lun));
    }
    return Collections.singletonMap(lunId, lunList);
}
#end_block

#method_before
@Override
protected boolean validateCreateImage() {
    VdcReturnValueBase returnValue = CommandHelper.canDoAction(VdcActionType.AddDisk, getAddDiskParameters(), getContext().clone().getExecutionContext(), true);
    getReturnValue().setValidationMessages(returnValue.getValidationMessages());
    return returnValue.isValid();
}
#method_after
@Override
protected boolean validateCreateImage() {
    VdcReturnValueBase returnValue = CommandHelper.canDoAction(VdcActionType.AddDisk, getAddDiskParameters(), getContext().clone());
    getReturnValue().setValidationMessages(returnValue.getValidationMessages());
    return returnValue.isValid();
}
#end_block

#method_before
@Override
protected boolean validateUploadToImage(Guid imageId) {
    DiskImage diskImage = (DiskImage) getDiskDao().get(imageId);
    DiskValidator diskValidator = getDiskValidator(diskImage);
    DiskImagesValidator diskImagesValidator = getDiskImagesValidator(diskImage);
    return validate(diskValidator.isDiskExists()) && validate(diskValidator.isDiskAttachedToAnyVm()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#method_after
@Override
protected boolean validateUploadToImage(Guid imageId) {
    DiskImage diskImage = (DiskImage) diskDao.get(imageId);
    DiskValidator diskValidator = getDiskValidator(diskImage);
    DiskImagesValidator diskImagesValidator = getDiskImagesValidator(diskImage);
    return validate(diskValidator.isDiskExists()) && validate(diskValidator.isDiskAttachedToAnyVm()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#end_block

#method_before
protected DiskImagesValidator getDiskImagesValidator(DiskImage diskImage) {
    List<DiskImage> diskImageInList = new ArrayList<>();
    diskImageInList.add(diskImage);
    return new DiskImagesValidator(diskImageInList);
}
#method_after
protected DiskImagesValidator getDiskImagesValidator(DiskImage diskImage) {
    return new DiskImagesValidator(diskImage);
}
#end_block

#method_before
protected DiskValidator getDiskValidator(DiskImage diskImage) {
    return new DiskValidator(diskImage, getVmDeviceUtils());
}
#method_after
protected DiskValidator getDiskValidator(DiskImage diskImage) {
    return new DiskValidator(diskImage);
}
#end_block

#method_before
@Override
protected void tearDownImage(Guid vdsId) {
    VDSReturnValue vdsRetVal = runVdsCommand(VDSCommandType.TeardownImage, getImageActionsParameters(vdsId));
    if (!vdsRetVal.getSucceeded()) {
        DiskImage image = (DiskImage) getDiskDao().get(getParameters().getImageId());
        log.warn("Failed to tear down image '{}' for image transfer session: {}", image, vdsRetVal.getVdsError());
        // Invoke log method directly rather than relying on infra, because teardown
        // failure may occur during command execution, e.g. if the upload is paused.
        addCustomValue("DiskAlias", image != null ? image.getDiskAlias() : "(unknown)");
        auditLogDirector.log(this, AuditLogType.UPLOAD_IMAGE_TEARDOWN_FAILED);
    }
}
#method_after
@Override
protected void tearDownImage(Guid vdsId) {
    VDSReturnValue vdsRetVal = runVdsCommand(VDSCommandType.TeardownImage, getImageActionsParameters(vdsId));
    if (!vdsRetVal.getSucceeded()) {
        DiskImage image = (DiskImage) diskDao.get(getParameters().getImageId());
        log.warn("Failed to tear down image '{}' for image transfer session: {}", image, vdsRetVal.getVdsError());
        // Invoke log method directly rather than relying on infra, because teardown
        // failure may occur during command execution, e.g. if the upload is paused.
        addCustomValue("DiskAlias", image != null ? image.getDiskAlias() : "(unknown)");
        auditLogDirector.log(this, AuditLogType.UPLOAD_IMAGE_TEARDOWN_FAILED);
    }
}
#end_block

#method_before
@Override
protected String getImageAlias() {
    return getParameters().getAddDiskParameters().getDiskInfo().getDiskAlias();
}
#method_after
@Override
protected String getImageAlias() {
    return getParameters().getAddDiskParameters() != null ? getParameters().getAddDiskParameters().getDiskInfo().getDiskAlias() : getDiskImage().getDiskAlias();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getUploadSize());
    getImageTransferDao().save(entity);
    log.info("Creating {} image", getUploadType());
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        createImage();
    } else {
        handleImageIsReadyForUpload(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getUploadSize());
    imageTransferDao.save(entity);
    log.info("Creating {} image", getUploadType());
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        createImage();
    } else {
        handleImageIsReadyForUpload(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = getImageTransferDao().get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image Upload status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the upload is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImage((DiskImage) getDiskDao().get(entity.getDiskId()));
    }
    // Check conditions for pausing the upload (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseUploadIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#method_after
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = imageTransferDao.get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image Upload status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the upload is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImage((DiskImage) diskDao.get(entity.getDiskId()));
    }
    // Check conditions for pausing the upload (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseUploadIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#end_block

#method_before
protected void handleImageIsReadyForUpload(Guid imageGuid) {
    DiskImage image = (DiskImage) getDiskDao().get(imageGuid);
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setImageId(imageGuid);
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    if (getParameters().getUploadSize() == 0) {
        getParameters().setUploadSize(image.getSize());
    }
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getUploadDescription(), getCommandId());
    ImageTransfer updates = new ImageTransfer();
    updates.setDiskId(imageGuid);
    updateEntity(updates);
    // The image will remain locked until the upload command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#method_after
protected void handleImageIsReadyForUpload(Guid imageGuid) {
    DiskImage image = (DiskImage) diskDao.get(imageGuid);
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setImageId(imageGuid);
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    if (getParameters().getUploadSize() == 0) {
        getParameters().setUploadSize(image.getSize());
    }
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getUploadDescription(), getCommandId());
    ImageTransfer updates = new ImageTransfer();
    updates.setDiskId(imageGuid);
    updateEntity(updates);
    // The image will remain locked until the upload command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#end_block

#method_before
protected boolean validate() {
    Guid imageId = getParameters().getImageId();
    if (!Guid.isNullOrEmpty(imageId)) {
        return validateUploadToImage(imageId);
    } else {
        return validateCreateImage();
    }
}
#method_after
@Override
protected boolean validate() {
    Guid imageId = getParameters().getImageId();
    if (!Guid.isNullOrEmpty(imageId)) {
        return validateUploadToImage(imageId);
    } else {
        return validateCreateImage();
    }
}
#end_block

#method_before
protected ImageTransfer updateEntity(ImageTransfer updates, boolean clearResourceId) {
    return getImageTransferUpdater().updateEntity(updates, getCommandId(), clearResourceId);
}
#method_after
protected ImageTransfer updateEntity(ImageTransfer updates, boolean clearResourceId) {
    return imageTransferUpdater.updateEntity(updates, getCommandId(), clearResourceId);
}
#end_block

#method_before
// Return a string describing the upload, safe for use before the new image
protected String getUploadDescription() {
    // TODO: nicer.
    String imageAlias = "";
    DiskImage diskImage = getDiskImage();
    if (diskImage != null && diskImage.getDiskAlias() != null) {
        imageAlias = getDiskImage().getDiskAlias();
    } else if (getParameters().getDiskAlias() != null) {
        imageAlias = getParameters().getDiskAlias();
    }
    return String.format("%s '%s' (id '%s')", getUploadType(), imageAlias, getImageIdNullSafe());
}
#method_after
// Return a string describing the upload, safe for use before the new image
protected String getUploadDescription() {
    return String.format("%s '%s' (id '%s')", getUploadType(), getImageAlias(), getImageIdNullSafe());
}
#end_block

#method_before
public void onSucceeded() {
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
    log.debug("Removing ImageUpload id {}", getCommandId());
    getImageTransferDao().remove(getCommandId());
    endSuccessfully();
    log.info("Successfully uploaded {} (command id '{}')", getUploadDescription(), getCommandId());
}
#method_after
public void onSucceeded() {
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
    log.debug("Removing ImageUpload id {}", getCommandId());
    imageTransferDao.remove(getCommandId());
    endSuccessfully();
    log.info("Successfully uploaded {} (command id '{}')", getUploadDescription(), getCommandId());
}
#end_block

#method_before
public void onFailed() {
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    log.debug("Removing ImageUpload id {}", getCommandId());
    getImageTransferDao().remove(getCommandId());
    endWithFailure();
    log.error("Failed to upload {} (command id '{}')", getUploadDescription(), getCommandId());
}
#method_after
public void onFailed() {
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    log.debug("Removing ImageUpload id {}", getCommandId());
    imageTransferDao.remove(getCommandId());
    endWithFailure();
    log.error("Failed to upload {} (command id '{}')", getUploadDescription(), getCommandId());
}
#end_block

#method_before
public boolean validate() {
    boolean uploadImageIsValid;
    setIsValid(true);
    getInvalidityReasons().clear();
    getImageInfoModel().getInvalidityReasons().clear();
    if (getImageSourceLocalEnabled().getEntity()) {
        getImagePath().validateEntity(new IValidation[] { new IValidation() {

            @Override
            public ValidationResult validate(Object value) {
                ValidationResult result = new ValidationResult();
                if (value == null || StringHelper.isNullOrEmpty((String) value)) {
                    result.setSuccess(false);
                    result.getReasons().add(constants.emptyImagePath());
                }
                return result;
            }
        } });
        if (getImagePath().getIsValid()) {
            getImageInfoModel().validateEntity(new IValidation[] { new IValidation() {

                @Override
                public ValidationResult validate(Object value) {
                    ValidationResult result = new ValidationResult();
                    ImageInfoModel.QemuCompat qcowCompat = getImageInfoModel().getQcowCompat();
                    if (qcowCompat != null && qcowCompat != ImageInfoModel.QemuCompat.V2) {
                        StorageFormatType storageFormatType = getDiskModel().getStorageDomain().getSelectedItem().getStorageFormat();
                        switch(storageFormatType) {
                            case V1:
                            case V2:
                            case V3:
                                result.setSuccess(false);
                                result.getReasons().add(messages.uploadImageQemuCompatUnsupported(qcowCompat.getValue(), storageFormatType.name()));
                                break;
                        }
                    }
                    return result;
                }
            } });
        }
        uploadImageIsValid = getImagePath().getIsValid() && getImageInfoModel().validate();
        getInvalidityReasons().addAll(getImagePath().getInvalidityReasons());
        getInvalidityReasons().addAll(getImageInfoModel().getInvalidityReasons());
    } else {
        // TODO remote/download
        uploadImageIsValid = false;
    }
    return uploadImageIsValid && diskModel.validate();
}
#method_after
public boolean validate() {
    boolean uploadImageIsValid;
    setIsValid(true);
    getInvalidityReasons().clear();
    getImageInfoModel().getInvalidityReasons().clear();
    if (getImageSourceLocalEnabled().getEntity()) {
        getImagePath().validateEntity(new IValidation[] { new IValidation() {

            @Override
            public ValidationResult validate(Object value) {
                ValidationResult result = new ValidationResult();
                if (value == null || StringHelper.isNullOrEmpty((String) value)) {
                    result.setSuccess(false);
                    result.getReasons().add(constants.emptyImagePath());
                }
                return result;
            }
        } });
        if (getImagePath().getIsValid()) {
            getImageInfoModel().validateEntity(new IValidation[] { new IValidation() {

                @Override
                public ValidationResult validate(Object value) {
                    ValidationResult result = new ValidationResult();
                    ImageInfoModel.QemuCompat qcowCompat = getImageInfoModel().getQcowCompat();
                    if (qcowCompat != null && qcowCompat != ImageInfoModel.QemuCompat.V2) {
                        StorageFormatType storageFormatType = getDiskModel().getStorageDomain().getSelectedItem().getStorageFormat();
                        switch(storageFormatType) {
                            case V1:
                            case V2:
                            case V3:
                            case V4:
                                result.setSuccess(false);
                                result.getReasons().add(messages.uploadImageQemuCompatUnsupported(qcowCompat.getValue(), storageFormatType.name()));
                                break;
                        }
                    }
                    return result;
                }
            } });
        }
        uploadImageIsValid = getImagePath().getIsValid() && getImageInfoModel().validate();
        getInvalidityReasons().addAll(getImagePath().getInvalidityReasons());
        getInvalidityReasons().addAll(getImageInfoModel().getInvalidityReasons());
    } else {
        // TODO remote/download
        uploadImageIsValid = false;
    }
    return uploadImageIsValid && diskModel.validate();
}
#end_block

#method_before
@Before
public void setUp() {
    backend = createMock(BackendLocal.class);
    currentUser = new DbUser();
    currentUser.setLoginName(USER);
    currentUser.setDomain(DOMAIN);
    current = new Current();
    current.setUser(currentUser);
    current.setSessionId(SESSION_ID);
    current.setRoot(URI_ROOT);
    current.setPrefix(BASE_PATH);
    current.setPath("");
    current.setVersion("4");
    current.setVersionSource(VersionSource.DEFAULT);
    current.setBackend(backend);
    CurrentManager.put(current);
    MessageBundle messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    resource.setMessageBundle(messageBundle);
    httpHeaders = createMock(HttpHeaders.class);
    List<Locale> locales = new ArrayList<>();
    expect(httpHeaders.getAcceptableLanguages()).andReturn(locales).anyTimes();
    List<String> filterValue = new ArrayList<>();
    filterValue.add("false");
    expect(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).andReturn(filterValue).anyTimes();
    resource.setHttpHeaders(httpHeaders);
}
#method_after
@Before
public void setUp() {
    backend = mock(BackendLocal.class);
    currentUser = new DbUser();
    currentUser.setLoginName(USER);
    currentUser.setDomain(DOMAIN);
    current = new Current();
    current.setUser(currentUser);
    current.setSessionId(SESSION_ID);
    current.setRoot(URI_ROOT);
    current.setPrefix(BASE_PATH);
    current.setPath("");
    current.setVersion("4");
    current.setVersionSource(VersionSource.DEFAULT);
    current.setBackend(backend);
    CurrentManager.put(current);
    MessageBundle messageBundle = new MessageBundle();
    messageBundle.setPath(BUNDLE_PATH);
    messageBundle.populate();
    resource.setMessageBundle(messageBundle);
    httpHeaders = mock(HttpHeaders.class);
    List<Locale> locales = new ArrayList<>();
    when(httpHeaders.getAcceptableLanguages()).thenReturn(locales);
    List<String> filterValue = new ArrayList<>();
    filterValue.add("false");
    when(httpHeaders.getRequestHeader(USER_FILTER_HEADER)).thenReturn(filterValue);
    resource.setHttpHeaders(httpHeaders);
}
#end_block

#method_before
@After
public void tearDown() {
    verifyAll();
    CurrentManager.remove();
}
#method_after
@After
public void tearDown() {
    CurrentManager.remove();
}
#end_block

#method_before
protected UriInfo setUpUriInfo() {
    UriBuilder uriBuilder = createMock(UriBuilder.class);
    expect(uriBuilder.clone()).andReturn(uriBuilder).anyTimes();
    UriInfo uriInfo = createMock(UriInfo.class);
    expect(uriInfo.getQueryParameters()).andReturn(null).anyTimes();
    expect(uriInfo.getPathSegments()).andReturn(null).anyTimes();
    return uriInfo;
}
#method_after
protected UriInfo setUpUriInfo() {
    UriBuilder uriBuilder = mock(UriBuilder.class);
    when(uriBuilder.clone()).thenReturn(uriBuilder);
    UriInfo uriInfo = mock(UriInfo.class);
    when(uriInfo.getQueryParameters()).thenReturn(null);
    when(uriInfo.getPathSegments()).thenReturn(null);
    return uriInfo;
}
#end_block

#method_before
protected void setUpGetSystemVersionExpectations() {
    VdcQueryReturnValue productRpmQueryResult = createMock(VdcQueryReturnValue.class);
    expect(productRpmQueryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(productRpmQueryResult.getReturnValue()).andReturn(SYSTEM_VERSION).anyTimes();
    expect(backend.runQuery(eq(VdcQueryType.GetConfigurationValue), getProductRPMVersionParams())).andReturn(productRpmQueryResult);
    VdcQueryReturnValue productVersionQueryResult = createMock(VdcQueryReturnValue.class);
    expect(productVersionQueryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(productVersionQueryResult.getReturnValue()).andReturn(new Version(MAJOR, MINOR, BUILD, REVISION)).anyTimes();
    expect(backend.runQuery(eq(VdcQueryType.GetProductVersion), getProductVersionParams())).andReturn(productVersionQueryResult);
}
#method_after
protected void setUpGetSystemVersionExpectations() {
    VdcQueryReturnValue productRpmQueryResult = mock(VdcQueryReturnValue.class);
    when(productRpmQueryResult.getSucceeded()).thenReturn(true);
    when(productRpmQueryResult.getReturnValue()).thenReturn(SYSTEM_VERSION);
    when(backend.runQuery(eq(VdcQueryType.GetConfigurationValue), getProductRPMVersionParams())).thenReturn(productRpmQueryResult);
    VdcQueryReturnValue productVersionQueryResult = mock(VdcQueryReturnValue.class);
    when(productVersionQueryResult.getSucceeded()).thenReturn(true);
    when(productVersionQueryResult.getReturnValue()).thenReturn(new Version(MAJOR, MINOR, BUILD, REVISION));
    when(backend.runQuery(eq(VdcQueryType.GetProductVersion), getProductVersionParams())).thenReturn(productVersionQueryResult);
}
#end_block

#method_before
protected void setUpGetSystemStatisticsExpectations() {
    VdcQueryReturnValue queryResult = createMock(VdcQueryReturnValue.class);
    expect(backend.runQuery(eq(VdcQueryType.GetSystemStatistics), queryParams())).andReturn(queryResult);
    expect(queryResult.getSucceeded()).andReturn(true).anyTimes();
    expect(queryResult.getReturnValue()).andReturn(setUpStats()).anyTimes();
    replayAll();
}
#method_after
protected void setUpGetSystemStatisticsExpectations() {
    VdcQueryReturnValue queryResult = mock(VdcQueryReturnValue.class);
    when(backend.runQuery(eq(VdcQueryType.GetSystemStatistics), queryParams())).thenReturn(queryResult);
    when(queryResult.getSucceeded()).thenReturn(true);
    when(queryResult.getReturnValue()).thenReturn(setUpStats());
}
#end_block

#method_before
@Mapping(from = ImageTransfer.class, to = org.ovirt.engine.api.model.ImageTransfer.class)
public static org.ovirt.engine.api.model.ImageTransfer map(ImageTransfer entity, org.ovirt.engine.api.model.ImageTransfer template) {
    org.ovirt.engine.api.model.ImageTransfer model = template != null ? template : new org.ovirt.engine.api.model.ImageTransfer();
    if (entity.getId() != null) {
        model.setId(entity.getId().toString());
    }
    if (entity.getVdsId() != null) {
        model.setHost(new Host());
        model.getHost().setId(entity.getVdsId().toString());
    }
    if (entity.getDiskId() != null) {
        model.setImage(new Image());
        model.getImage().setId(entity.getDiskId().toString());
    }
    if (entity.getProxyUri() != null && entity.getImagedTicketId() != null) {
        model.setProxyUrl(entity.getProxyUri() + "/" + entity.getImagedTicketId());
    }
    if (entity.getSignedTicket() != null) {
        model.setSignedTicket(entity.getSignedTicket());
    }
    if (entity.getPhase() != null) {
        model.setPhase(ImageTransferPhase.valueOf(entity.getPhase().name()));
    }
    return model;
}
#method_after
@Mapping(from = ImageTransfer.class, to = org.ovirt.engine.core.common.businessentities.storage.ImageTransfer.class)
public static org.ovirt.engine.core.common.businessentities.storage.ImageTransfer map(ImageTransfer model, org.ovirt.engine.core.common.businessentities.storage.ImageTransfer template) {
    org.ovirt.engine.core.common.businessentities.storage.ImageTransfer entity = template != null ? template : new org.ovirt.engine.core.common.businessentities.storage.ImageTransfer();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetHost() && model.getHost().isSetId()) {
        entity.setVdsId(GuidUtils.asGuid(model.getHost().getId()));
    }
    if (model.isSetImage() && model.getImage().isSetId()) {
        entity.setDiskId(GuidUtils.asGuid(model.getImage().getId()));
    }
    return entity;
}
#end_block

#method_before
private Response getSchema() {
    ByteArrayOutputStream baos = null;
    InputStream is = null;
    byte[] buffer = new byte[4096];
    try {
        baos = new ByteArrayOutputStream();
        String version = getCurrent().getVersion();
        String resourcePath = String.format("/v%s/%s", version, API_SCHEMA);
        is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourcePath);
        int count;
        while ((count = is.read(buffer)) != -1) {
            baos.write(buffer, 0, count);
        }
        baos.flush();
        return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM).header("content-disposition", "attachment; filename = " + SCHEMA_NAME).build();
    } catch (IOException e) {
        log.error("Loading api.xsd file failed.", e);
        return Response.serverError().build();
    } finally {
        try {
            if (baos != null) {
                baos.close();
            }
            if (is != null) {
                is.close();
            }
        } catch (IOException e) {
            log.error("cannot close a resource", e);
        }
    }
}
#method_after
private Response getSchema() {
    byte[] buffer = new byte[4096];
    String version = getCurrent().getVersion();
    String resourcePath = String.format("/v%s/%s", version, API_SCHEMA);
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream();
        InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(resourcePath)) {
        int count;
        while ((count = is.read(buffer)) != -1) {
            baos.write(buffer, 0, count);
        }
        baos.flush();
        return Response.ok(baos.toByteArray(), MediaType.APPLICATION_OCTET_STREAM).header("content-disposition", "attachment; filename = " + SCHEMA_NAME).build();
    } catch (IOException e) {
        log.error("Loading api.xsd file failed.", e);
        return Response.serverError().build();
    }
}
#end_block

#method_before
@Override
public Response add(org.ovirt.engine.api.model.ImageTransfer imageTransfer) {
    UploadDiskImageParameters params = new UploadDiskImageParameters();
    params.setImageId(GuidUtils.asGuid(imageTransfer.getImage().getId()));
    params.setKeepaliveInterval(ConfigurationValues.UploadImageUiInactivityTimeoutInSeconds.getValue());
    return performCreate(VdcActionType.UploadDiskImage, params, new QueryIdResolver<Guid>(VdcQueryType.GetImageTransferById, IdQueryParameters.class));
}
#method_after
@Override
public Response add(ImageTransfer imageTransfer) {
    UploadDiskImageParameters params = new UploadDiskImageParameters();
    params.setImageId(GuidUtils.asGuid(imageTransfer.getImage().getId()));
    params.setKeepaliveInterval(ConfigurationValues.UploadImageUiInactivityTimeoutInSeconds.getValue());
    return performCreate(VdcActionType.UploadDiskImage, params, new QueryIdResolver<Guid>(VdcQueryType.GetImageTransferById, IdQueryParameters.class));
}
#end_block

#method_before
@Override
public org.ovirt.engine.api.model.ImageTransfers list() {
    return mapCollection(getBackendCollection(VdcQueryType.GetAllImageTransfers, new VdcQueryParametersBase()));
}
#method_after
@Override
public ImageTransfers list() {
    return mapCollection(getBackendCollection(VdcQueryType.GetAllImageTransfers, new VdcQueryParametersBase()));
}
#end_block

#method_before
private org.ovirt.engine.api.model.ImageTransfers mapCollection(List<ImageTransfer> imageTransfers) {
    ImageTransfers mappedImageTransfers = new ImageTransfers();
    for (ImageTransfer imageTransfer : imageTransfers) {
        mappedImageTransfers.getImageTransfers().add(addLinks(populate(map(imageTransfer), imageTransfer)));
    }
    return mappedImageTransfers;
}
#method_after
private ImageTransfers mapCollection(List<org.ovirt.engine.core.common.businessentities.storage.ImageTransfer> imageTransfers) {
    ImageTransfers mappedImageTransfers = new ImageTransfers();
    for (org.ovirt.engine.core.common.businessentities.storage.ImageTransfer imageTransfer : imageTransfers) {
        mappedImageTransfers.getImageTransfers().add(addLinks(populate(map(imageTransfer), imageTransfer)));
    }
    return mappedImageTransfers;
}
#end_block

#method_before
private UploadImageStatusParameters prepareStatusParams(ImageTransferPhase phase) {
    ImageTransfer imageTransfer = get();
    org.ovirt.engine.core.common.businessentities.storage.ImageTransfer updates = new org.ovirt.engine.core.common.businessentities.storage.ImageTransfer(GuidUtils.asGuid(imageTransfer.getId()));
    updates.setPhase(phase);
    UploadImageStatusParameters params = new UploadImageStatusParameters();
    params.setDiskId(GuidUtils.asGuid(imageTransfer.getImage().getId()));
    params.setUpdates(updates);
    return params;
}
#method_after
private UploadImageStatusParameters prepareStatusParams(ImageTransferPhase phase) {
    org.ovirt.engine.core.common.businessentities.storage.ImageTransfer updates = new org.ovirt.engine.core.common.businessentities.storage.ImageTransfer(guid);
    updates.setPhase(phase);
    UploadImageStatusParameters params = new UploadImageStatusParameters();
    params.setUploadImageCommandId(guid);
    params.setUpdates(updates);
    return params;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addValidationMessageVariable("diskAliases", getDiskAlias());
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator((DiskImage) getDisk());
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            addValidationMessageVariable("diskAlias", getDiskAlias());
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = getStoragePoolDao().get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (getDisk() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (getVm() == null) {
        addValidationMessageVariable("diskAliases", getDiskAlias());
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_IS_NOT_VM_DISK);
    }
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator((DiskImage) getDisk());
        if (!validate(diskImagesValidator.diskImagesNotLocked()) || !validate(diskImagesValidator.diskImagesNotIllegal())) {
            return false;
        }
        StorageDomainStatic sds = storageDomainStaticDao.get(((DiskImage) getDisk()).getStorageIds().get(0));
        if (!sds.getStorageType().isBlockDomain()) {
            addValidationMessageVariable("diskAlias", getDiskAlias());
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_ALIGNMENT_SCAN_STORAGE_TYPE);
        }
    }
    if (getVm().isRunningOrPaused()) {
        return failValidation(EngineMessage.ERROR_CANNOT_RUN_ALIGNMENT_SCAN_VM_IS_RUNNING);
    }
    if (getVdsIdInGroup() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_NO_VDS_IN_POOL);
    }
    StoragePool sp = storagePoolDao.get(getStoragePoolId());
    if (!validate(new StoragePoolValidator(sp).isUp())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GetDiskAlignmentVDSCommandParameters parameters;
    auditLogDirector.log(this, AuditLogType.DISK_ALIGNMENT_SCAN_START);
    acquireExclusiveDiskDbLocks();
    // Live scan is not supported yet, this might become: getVm().getId()
    Guid vmId = Guid.Empty;
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        GetDiskImageAlignmentVDSCommandParameters imageParameters = new GetDiskImageAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        imageParameters.setPoolId(getStoragePoolId());
        imageParameters.setDomainId(diskImage.getStorageIds().get(0));
        imageParameters.setImageGroupId(diskImage.getId());
        imageParameters.setImageId(diskImage.getImageId());
        parameters = imageParameters;
    } else if (getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) getDisk();
        GetDiskLunAlignmentVDSCommandParameters lunParameters = new GetDiskLunAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        lunParameters.setLunId(lunDisk.getLun().getLUNId());
        parameters = lunParameters;
    } else {
        throw new EngineException(EngineError.ENGINE, "Unknown DiskStorageType: " + getDiskStorageType().toString() + " Disk id: " + getDisk().getId().toString());
    }
    Boolean isDiskAligned = (Boolean) runVdsCommand(VDSCommandType.GetDiskAlignment, parameters).getReturnValue();
    getDisk().setAlignment(isDiskAligned ? DiskAlignment.Aligned : DiskAlignment.Misaligned);
    getDisk().setLastAlignmentScan(new Date());
    getBaseDiskDao().update(getDisk());
    setSucceeded(true);
    releaseExclusiveDiskDbLocks();
}
#method_after
@Override
protected void executeCommand() {
    GetDiskAlignmentVDSCommandParameters parameters;
    auditLogDirector.log(this, AuditLogType.DISK_ALIGNMENT_SCAN_START);
    acquireExclusiveDiskDbLocks();
    // Live scan is not supported yet, this might become: getVm().getId()
    Guid vmId = Guid.Empty;
    if (getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage diskImage = (DiskImage) getDisk();
        GetDiskImageAlignmentVDSCommandParameters imageParameters = new GetDiskImageAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        imageParameters.setPoolId(getStoragePoolId());
        imageParameters.setDomainId(diskImage.getStorageIds().get(0));
        imageParameters.setImageGroupId(diskImage.getId());
        imageParameters.setImageId(diskImage.getImageId());
        parameters = imageParameters;
    } else if (getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) getDisk();
        GetDiskLunAlignmentVDSCommandParameters lunParameters = new GetDiskLunAlignmentVDSCommandParameters(getVdsIdInGroup(), vmId);
        lunParameters.setLunId(lunDisk.getLun().getLUNId());
        parameters = lunParameters;
    } else {
        throw new EngineException(EngineError.ENGINE, "Unknown DiskStorageType: " + getDiskStorageType().toString() + " Disk id: " + getDisk().getId().toString());
    }
    Boolean isDiskAligned = (Boolean) runVdsCommand(VDSCommandType.GetDiskAlignment, parameters).getReturnValue();
    getDisk().setAlignment(isDiskAligned ? DiskAlignment.Aligned : DiskAlignment.Misaligned);
    getDisk().setLastAlignmentScan(new Date());
    baseDiskDao.update(getDisk());
    setSucceeded(true);
    releaseExclusiveDiskDbLocks();
}
#end_block

#method_before
protected Guid getVdsIdInGroup() {
    if (vdsInPool == null && getCluster() != null) {
        List<VDS> vdsInPoolList = getVdsDao().getAllForClusterWithStatus(getCluster().getId(), VDSStatus.Up);
        if (!vdsInPoolList.isEmpty()) {
            vdsInPool = vdsInPoolList.get(0).getId();
        }
    }
    return vdsInPool;
}
#method_after
protected Guid getVdsIdInGroup() {
    if (vdsInPool == null && getCluster() != null) {
        List<VDS> vdsInPoolList = vdsDao.getAllForClusterWithStatus(getCluster().getId(), VDSStatus.Up);
        if (!vdsInPoolList.isEmpty()) {
            vdsInPool = vdsInPoolList.get(0).getId();
        }
    }
    return vdsInPool;
}
#end_block

#method_before
@Override
public VM getVm() {
    if (diskVm == null && getDisk() != null) {
        diskVm = getVmDao().getVmsListForDisk(getDisk().getId(), false).stream().findFirst().orElse(null);
    }
    return diskVm;
}
#method_after
@Override
public VM getVm() {
    if (diskVm == null && getDisk() != null) {
        diskVm = vmDao.getVmsListForDisk(getDisk().getId(), false).stream().findFirst().orElse(null);
    }
    return diskVm;
}
#end_block

#method_before
protected Disk getDisk() {
    if (diskToScan == null) {
        diskToScan = getDiskDao().get(getParameters().getDiskId());
    }
    return diskToScan;
}
#method_after
protected Disk getDisk() {
    if (diskToScan == null) {
        diskToScan = diskDao.get(getParameters().getDiskId());
    }
    return diskToScan;
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly(diskValidator) && validateVmPoolProperties() && validateQuota() && validate(diskValidator.isVirtIoScsiValid(getVm(), getDiskVmElement())) && (!isDiskInterfaceUpdated || validate(diskValidator.isDiskInterfaceSupported(getVm(), getDiskVmElement()))) && setAndValidateDiskProfiles();
}
#method_after
@Override
protected boolean validate() {
    if (!validate(new VmValidator(getVm()).isVmExists()) || !isDiskExistAndAttachedToVm(getOldDisk()) || !validateDiskVmData()) {
        return false;
    }
    boolean isDiskImageOrCinder = DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() || DiskStorageType.CINDER == getOldDisk().getDiskStorageType();
    if (isDiskImageOrCinder) {
        ValidationResult imagesNotLocked = new DiskImagesValidator((DiskImage) getOldDisk()).diskImagesNotLocked();
        if (!imagesNotLocked.isValid()) {
            return validate(imagesNotLocked);
        }
    }
    DiskValidator oldDiskValidator = getDiskValidator(getOldDisk());
    ValidationResult isHostedEngineDisk = oldDiskValidator.validateNotHostedEngineDisk();
    if (!isHostedEngineDisk.isValid()) {
        return validate(isHostedEngineDisk);
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    boolean isDiskInterfaceUpdated = getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface();
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDiskVmElement().isBoot() && getDiskVmElement().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(oldDiskValidator.isVmNotContainsBootDisk(getVm()))) {
            return false;
        }
        if (isDiskInterfaceUpdated && !isDiskPassPciAndIdeLimit()) {
            return false;
        }
    }
    if (isDiskImageOrCinder && !validateCanResizeDisk()) {
        return false;
    }
    DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validateVmPoolProperties() && validateQuota() && validate(diskVmElementValidator.isVirtIoScsiValid(getVm())) && (!isDiskInterfaceUpdated || validate(diskVmElementValidator.isDiskInterfaceSupported(getVm()))) && setAndValidateDiskProfiles();
}
#end_block

#method_before
protected StorageDomainValidator getStorageDomainValidator(DiskImage diskImage) {
    StorageDomain storageDomain = getStorageDomainDao().getForStoragePool(diskImage.getStorageIds().get(0), diskImage.getStoragePoolId());
    return new StorageDomainValidator(storageDomain);
}
#method_after
protected StorageDomainValidator getStorageDomainValidator(DiskImage diskImage) {
    StorageDomain storageDomain = storageDomainDao.getForStoragePool(diskImage.getStorageIds().get(0), diskImage.getStoragePoolId());
    return new StorageDomainValidator(storageDomain);
}
#end_block

#method_before
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = getStorageDomainStaticDao().get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = getDiskImageDao().getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failValidation(EngineMessage.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#method_after
private boolean validateCanUpdateShareable() {
    if (DiskStorageType.LUN == getOldDisk().getDiskStorageType()) {
        return true;
    }
    // Check if VM is not during snapshot.
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (isUpdatedToShareable(getOldDisk(), getNewDisk())) {
        StorageDomainStatic sds = storageDomainStaticDao.get(((DiskImage) getNewDisk()).getStorageIds().get(0));
        if (sds.getStorageType() == StorageType.GLUSTERFS) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_SHAREABLE_DISKS_NOT_SUPPORTED_ON_GLUSTER_DOMAIN);
        }
        List<DiskImage> diskImageList = diskImageDao.getAllSnapshotsForImageGroup(getOldDisk().getId());
        // disk and all the other images are the snapshots.
        if ((diskImageList.size() > 1) || !Guid.Empty.equals(((DiskImage) getOldDisk()).getImageTemplateId())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_FOR_DISK);
        }
        if (!isVolumeFormatSupportedForShareable(((DiskImage) getNewDisk()).getVolumeFormat())) {
            return failValidation(EngineMessage.SHAREABLE_DISK_IS_NOT_SUPPORTED_BY_VOLUME_FORMAT);
        }
    } else if (isUpdatedToNonShareable(getOldDisk(), getNewDisk())) {
        if (vmsDiskOrSnapshotAttachedTo.size() > 1) {
            return failValidation(EngineMessage.DISK_IS_ALREADY_SHARED_BETWEEN_VMS);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean validateCanUpdateReadOnly(DiskValidator diskValidator) {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        return validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface(getDiskVmElement()));
    }
    return true;
}
#method_after
protected boolean validateCanUpdateReadOnly() {
    if (updateReadOnlyRequested()) {
        if (getVm().getStatus() != VMStatus.Down && vmDeviceForVm.getIsPlugged()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        DiskVmElementValidator diskVmElementValidator = getDiskVmElementValidator(getNewDisk(), getDiskVmElement());
        return validate(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface());
    }
    return true;
}
#end_block

#method_before
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = getDiskImageDao().getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#method_after
protected boolean validateCanResizeDisk() {
    DiskImage newDiskImage = (DiskImage) getNewDisk();
    DiskImage oldDiskImage = (DiskImage) getOldDisk();
    if (newDiskImage.getSize() != oldDiskImage.getSize()) {
        if (Boolean.TRUE.equals(getVmDeviceForVm().getIsReadOnly())) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_READ_ONLY_DISK);
        }
        if (vmDeviceForVm.getSnapshotId() != null) {
            DiskImage snapshotDisk = diskImageDao.getDiskSnapshotForVmSnapshot(getParameters().getDiskInfo().getId(), vmDeviceForVm.getSnapshotId());
            if (snapshotDisk.getSize() != newDiskImage.getSize()) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANNOT_RESIZE_DISK_SNAPSHOT);
            }
        }
        if (oldDiskImage.getSize() > newDiskImage.getSize()) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_REQUESTED_DISK_SIZE_IS_TOO_SMALL);
        }
        for (VM vm : getVmsDiskPluggedTo()) {
            if (!VdcActionUtils.canExecute(Collections.singletonList(vm), VM.class, VdcActionType.ExtendImageSize)) {
                return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
            }
        }
        StorageDomainValidator storageDomainValidator = getStorageDomainValidator((DiskImage) getNewDisk());
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
        // For size allocation validation, we'll create a dummy with the additional size required.
        // That way, the validator can hold all the logic about storage types.
        long additionalDiskSpaceInGB = newDiskImage.getSizeInGigabytes() - oldDiskImage.getSizeInGigabytes();
        DiskImage dummyForValidation = DiskImage.copyOf(newDiskImage);
        dummyForValidation.setSizeInGigabytes(additionalDiskSpaceInGB);
        return validate(storageDomainValidator.hasSpaceForNewDisk(dummyForValidation));
    }
    return true;
}
#end_block

#method_before
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = getDiskDao().get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = getDiskVmElementDao().get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            getVmStaticDao().incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            getBaseDiskDao().update(diskForUpdate);
            getDiskVmElementDao().update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    getImageDao().update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                getVmDeviceDao().update(vmDeviceForVm);
            }
            if (getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) {
                vmDeviceForVm.setAddress("");
                getVmDeviceDao().clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                getVmDeviceDao().update(vmDeviceForVm);
            }
        }
    });
}
#method_after
protected void performDiskUpdate(final boolean unlockImage) {
    if (shouldPerformMetadataUpdate()) {
        updateMetaDataDescription((DiskImage) getNewDisk());
    }
    final Disk diskForUpdate = diskDao.get(getParameters().getDiskInfo().getId());
    final DiskVmElement diskVmElementForUpdate = diskVmElementDao.get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    applyUserChanges(diskForUpdate, diskVmElementForUpdate);
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

        @Override
        public Object runInTransaction() {
            vmStaticDao.incrementDbGeneration(getVm().getId());
            updateDeviceProperties();
            baseDiskDao.update(diskForUpdate);
            diskVmElementDao.update(diskVmElementForUpdate);
            switch(diskForUpdate.getDiskStorageType()) {
                case IMAGE:
                    DiskImage diskImage = (DiskImage) diskForUpdate;
                    diskImage.setQuotaId(getQuotaId());
                    if (unlockImage && diskImage.getImageStatus() == ImageStatus.LOCKED) {
                        diskImage.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(diskImage.getImage());
                    updateQuota(diskImage);
                    updateDiskProfile();
                    break;
                case CINDER:
                    CinderDisk cinderDisk = (CinderDisk) diskForUpdate;
                    cinderDisk.setQuotaId(getQuotaId());
                    setStorageDomainId(cinderDisk.getStorageIds().get(0));
                    getCinderBroker().updateDisk(cinderDisk);
                    if (unlockImage && cinderDisk.getImageStatus() == ImageStatus.LOCKED) {
                        cinderDisk.setImageStatus(ImageStatus.OK);
                    }
                    imageDao.update(cinderDisk.getImage());
                    updateQuota(cinderDisk);
                    break;
                case LUN:
                    updateLunProperties((LunDisk) getNewDisk());
                    break;
            }
            reloadDisks();
            updateBootOrder();
            setSucceeded(true);
            // If necessary set the new Storage QoS values on running VMs asynchronously
            liveUpdateDiskProfile();
            return null;
        }

        private void updateDeviceProperties() {
            if (updateReadOnlyRequested()) {
                vmDeviceForVm.setIsReadOnly(getNewDisk().getReadOnly());
                vmDeviceDao.update(vmDeviceForVm);
            }
            if ((getOldDiskVmElement().getDiskInterface() != getDiskVmElement().getDiskInterface()) || ((getOldDiskVmElement().isBoot() != getDiskVmElement().isBoot()) && (getDiskVmElement().getDiskInterface() == DiskInterface.IDE))) {
                vmDeviceForVm.setAddress("");
                vmDeviceDao.clearDeviceAddress(getOldDisk().getId());
            }
        }

        private void updateLunProperties(LunDisk lunDisk) {
            if (updateIsUsingScsiReservationRequested(lunDisk)) {
                vmDeviceForVm.setUsingScsiReservation(lunDisk.isUsingScsiReservation());
                vmDeviceDao.update(vmDeviceForVm);
            }
        }
    });
}
#end_block

#method_before
private void updateMetaDataDescription(DiskImage diskImage) {
    StorageDomain storageDomain = getStorageDomainDao().getForStoragePool(diskImage.getStorageIds().get(0), getVm().getStoragePoolId());
    if (!getStorageDomainValidator((DiskImage) getNewDisk()).isDomainExistAndActive().isValid()) {
        auditLogForNoMetadataDescriptionUpdate(AuditLogType.UPDATE_DESCRIPTION_FOR_DISK_SKIPPED_SINCE_STORAGE_DOMAIN_NOT_ACTIVE, storageDomain, diskImage);
        return;
    }
    setVolumeDescription(diskImage, storageDomain);
}
#method_after
private void updateMetaDataDescription(DiskImage diskImage) {
    StorageDomain storageDomain = storageDomainDao.getForStoragePool(diskImage.getStorageIds().get(0), getVm().getStoragePoolId());
    if (!getStorageDomainValidator((DiskImage) getNewDisk()).isDomainExistAndActive().isValid()) {
        auditLogForNoMetadataDescriptionUpdate(AuditLogType.UPDATE_DESCRIPTION_FOR_DISK_SKIPPED_SINCE_STORAGE_DOMAIN_NOT_ACTIVE, storageDomain, diskImage);
        return;
    }
    setVolumeDescription(diskImage, storageDomain);
}
#end_block

#method_before
private void auditLogForNoMetadataDescriptionUpdate(AuditLogType auditLogType, StorageDomain storageDomain, DiskImage diskImage) {
    AuditLogableBase auditLogableBase = new AuditLogableBase();
    auditLogableBase.addCustomValue("DataCenterName", getStoragePool().getName());
    auditLogableBase.addCustomValue("StorageDomainName", storageDomain.getName());
    auditLogableBase.addCustomValue("DiskName", diskImage.getDiskAlias());
    auditLogDirector.log(auditLogableBase, auditLogType);
}
#method_after
private void auditLogForNoMetadataDescriptionUpdate(AuditLogType auditLogType, StorageDomain storageDomain, DiskImage diskImage) {
    addCustomValue("DataCenterName", getStoragePool().getName());
    addCustomValue("StorageDomainName", storageDomain.getName());
    addCustomValue("DiskName", diskImage.getDiskAlias());
    auditLogDirector.log(this, auditLogType);
}
#end_block

#method_before
protected void updateDiskProfile() {
    if (isDiskImage()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        DiskImage newDisk = (DiskImage) getNewDisk();
        if (!Objects.equals(oldDisk.getDiskProfileId(), newDisk.getDiskProfileId())) {
            getImageStorageDomainMapDao().updateDiskProfileByImageGroupIdAndStorageDomainId(newDisk.getId(), newDisk.getStorageIds().get(0), newDisk.getDiskProfileId());
        }
    }
}
#method_after
protected void updateDiskProfile() {
    if (isDiskImage()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        DiskImage newDisk = (DiskImage) getNewDisk();
        if (!Objects.equals(oldDisk.getDiskProfileId(), newDisk.getDiskProfileId())) {
            imageStorageDomainMapDao.updateDiskProfileByImageGroupIdAndStorageDomainId(newDisk.getId(), newDisk.getStorageIds().get(0), newDisk.getDiskProfileId());
        }
    }
}
#end_block

#method_before
protected void updateQuota(DiskImage diskImage) {
    if (isInternalManagedDisk()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        if (!Objects.equals(oldDisk.getQuotaId(), diskImage.getQuotaId())) {
            getImageStorageDomainMapDao().updateQuotaForImageAndSnapshots(diskImage.getId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId());
        }
    }
}
#method_after
protected void updateQuota(DiskImage diskImage) {
    if (isInternalManagedDisk()) {
        DiskImage oldDisk = (DiskImage) getOldDisk();
        if (!Objects.equals(oldDisk.getQuotaId(), diskImage.getQuotaId())) {
            imageStorageDomainMapDao.updateQuotaForImageAndSnapshots(diskImage.getId(), diskImage.getStorageIds().get(0), diskImage.getQuotaId());
        }
    }
}
#end_block

#method_before
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        // when disk profile isn't updated, skip check.
        if (diskImage.getDiskProfileId() != null && diskImage.getDiskProfileId().equals(((DiskImage) getOldDisk()).getDiskProfileId())) {
            return true;
        }
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(DiskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#method_after
protected boolean setAndValidateDiskProfiles() {
    if (isDiskImage()) {
        DiskImage diskImage = (DiskImage) getNewDisk();
        // when disk profile isn't updated, skip check.
        if (diskImage.getDiskProfileId() != null && diskImage.getDiskProfileId().equals(((DiskImage) getOldDisk()).getDiskProfileId())) {
            return true;
        }
        Map<DiskImage, Guid> map = new HashMap<>();
        map.put(diskImage, diskImage.getStorageIds().get(0));
        return validate(diskProfileHelper.setAndValidateDiskProfiles(map, getCurrentUser()));
    }
    return true;
}
#end_block

#method_before
private void updateSnapshotIdOnShareableChange(Disk oldDisk, Disk newDisk) {
    if (oldDisk.isShareable() != newDisk.isShareable() && oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        Guid vmSnapshotId = isUpdatedToShareable(oldDisk, newDisk) ? null : getSnapshotDao().getId(getVmId(), SnapshotType.ACTIVE);
        oldDiskImage.setVmSnapshotId(vmSnapshotId);
    }
}
#method_after
private void updateSnapshotIdOnShareableChange(Disk oldDisk, Disk newDisk) {
    if (oldDisk.isShareable() != newDisk.isShareable() && oldDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
        DiskImage oldDiskImage = (DiskImage) oldDisk;
        Guid vmSnapshotId = isUpdatedToShareable(oldDisk, newDisk) ? null : snapshotDao.getId(getVmId(), SnapshotType.ACTIVE);
        oldDiskImage.setVmSnapshotId(vmSnapshotId);
    }
}
#end_block

#method_before
protected Disk getOldDisk() {
    if (oldDisk == null && getParameters().getDiskInfo() != null) {
        oldDisk = getDiskDao().get(getParameters().getDiskInfo().getId());
    }
    return oldDisk;
}
#method_after
protected Disk getOldDisk() {
    if (oldDisk == null && getParameters().getDiskInfo() != null) {
        oldDisk = diskDao.get(getParameters().getDiskInfo().getId());
    }
    return oldDisk;
}
#end_block

#method_before
protected DiskVmElement getOldDiskVmElement() {
    if (oldDiskVmElement == null) {
        oldDiskVmElement = getDiskVmElementDao().get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    }
    return oldDiskVmElement;
}
#method_after
protected DiskVmElement getOldDiskVmElement() {
    if (oldDiskVmElement == null) {
        oldDiskVmElement = diskVmElementDao.get(new VmDeviceId(getOldDisk().getId(), getVmId()));
    }
    return oldDiskVmElement;
}
#end_block

#method_before
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        List<Pair<VM, VmDevice>> attachedVmsInfo = getVmDao().getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#method_after
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        List<Pair<VM, VmDevice>> attachedVmsInfo = vmDao.getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#end_block

#method_before
private boolean validateHostedEngineDisks() {
    DiskValidator oldDiskValidator = new DiskValidator(getDisk(), vmDeviceUtils);
    if (getDisk().getVmEntityType() != null && getDisk().getVmEntityType().isVmType()) {
        for (VM vm : getVmsForDiskId()) {
            if (!validate(oldDiskValidator.validRemovableHostedEngineDisks(vm))) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean validateHostedEngineDisks() {
    DiskValidator oldDiskValidator = new DiskValidator(getDisk());
    if (getDisk().getVmEntityType() != null && getDisk().getVmEntityType().isVmType()) {
        for (VM vm : getVmsForDiskId()) {
            if (!validate(oldDiskValidator.validRemovableHostedEngineDisks(vm))) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean validateAllVmsForDiskAreDown() {
    if (getDisk().getVmEntityType() != null && getDisk().getVmEntityType().isVmType()) {
        for (VM vm : getVmsForDiskId()) {
            if (vm.getStatus() != VMStatus.Down && !vm.isHostedEngine()) {
                VmDevice vmDevice = getVmDeviceDao().get(new VmDeviceId(getDisk().getId(), vm.getId()));
                if (vmDevice.getIsPlugged()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
    }
    return true;
}
#method_after
private boolean validateAllVmsForDiskAreDown() {
    if (getDisk().getVmEntityType() != null && getDisk().getVmEntityType().isVmType()) {
        for (VM vm : getVmsForDiskId()) {
            if (vm.getStatus() != VMStatus.Down && !vm.isHostedEngine()) {
                VmDevice vmDevice = vmDeviceDao.get(new VmDeviceId(getDisk().getId(), vm.getId()));
                if (vmDevice.getIsPlugged()) {
                    addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
                    return false;
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImage);
    if (diskImage.isOvfStore() && !validate(diskImagesValidator.disksInStatus(ImageStatus.ILLEGAL, EngineMessage.ACTION_TYPE_FAILED_OVF_DISK_NOT_IN_APPLICABLE_STATUS))) {
        return false;
    }
    boolean isVmTemplateType = diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType();
    if (Guid.isNullOrEmpty(getParameters().getStorageDomainId())) {
        if (isVmTemplateType) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_DELETE_TEMPLATE_DISK_WITHOUT_SPECIFYING_DOMAIN);
        }
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (isVmTemplateType) {
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImage);
    if (diskImage.isOvfStore() && !validate(diskImagesValidator.disksInStatus(ImageStatus.ILLEGAL, EngineMessage.ACTION_TYPE_FAILED_OVF_DISK_NOT_IN_APPLICABLE_STATUS))) {
        return false;
    }
    boolean isVmTemplateType = diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType();
    if (Guid.isNullOrEmpty(getParameters().getStorageDomainId())) {
        if (isVmTemplateType) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_CANT_DELETE_TEMPLATE_DISK_WITHOUT_SPECIFYING_DOMAIN);
        }
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (isVmTemplateType) {
        diskImage.setStorageIds(diskImageDao.get(diskImage.getImageId()).getStorageIds());
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#end_block

#method_before
private void setVmTemplateIdParameter() {
    Map<Boolean, VmTemplate> templateMap = // Disk image is the only disk type that can be part of the template disks.
    getVmTemplateDao().getAllForImage(getDiskImage().getImageId());
    if (!templateMap.isEmpty()) {
        setVmTemplateId(templateMap.values().iterator().next().getId());
    }
}
#method_after
private void setVmTemplateIdParameter() {
    Map<Boolean, VmTemplate> templateMap = // Disk image is the only disk type that can be part of the template disks.
    vmTemplateDao.getAllForImage(getDiskImage().getImageId());
    if (!templateMap.isEmpty()) {
        setVmTemplateId(templateMap.values().iterator().next().getId());
    }
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDao().getVmsListForDisk(getParameters().getDiskId(), true);
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = vmDao.getVmsListForDisk(getParameters().getDiskId(), true);
    }
    return listVms;
}
#end_block

#method_before
private List<String> getNamesOfDerivedVmsFromTemplate(DiskImage diskImage) {
    List<String> result = new ArrayList<>();
    for (VM vm : getVmDao().getAllWithTemplate(getVmTemplateId())) {
        for (Disk vmDisk : getDiskDao().getAllForVm(vm.getId())) {
            if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage vmDiskImage = (DiskImage) vmDisk;
                if (vmDiskImage.getImageTemplateId().equals(diskImage.getImageId())) {
                    if (vmDiskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
                        result.add(vm.getName());
                    }
                    break;
                }
            }
        }
    }
    return result;
}
#method_after
private List<String> getNamesOfDerivedVmsFromTemplate(DiskImage diskImage) {
    List<String> result = new ArrayList<>();
    for (VM vm : vmDao.getAllWithTemplate(getVmTemplateId())) {
        for (Disk vmDisk : diskDao.getAllForVm(vm.getId())) {
            if (vmDisk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage vmDiskImage = (DiskImage) vmDisk;
                if (vmDiskImage.getImageTemplateId().equals(diskImage.getImageId())) {
                    if (vmDiskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
                        result.add(vm.getName());
                    }
                    break;
                }
            }
        }
    }
    return result;
}
#end_block

#method_before
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = getStoragePoolDao().get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = ImagesHandler.filterImageDisks(Collections.singletonList(getDisk()), true, false, true);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean canRemoveVmImageDisk() {
    if (!listVms.isEmpty()) {
        Guid storagePoolId = listVms.get(0).getStoragePoolId();
        StoragePool sp = storagePoolDao.get(storagePoolId);
        if (!validate(new StoragePoolValidator(sp).isUp())) {
            return false;
        }
        List<DiskImage> diskList = DisksFilter.filterImageDisks(Collections.singletonList(getDisk()), ONLY_NOT_SHAREABLE, ONLY_ACTIVE);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskList);
        if (!validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
    }
    SnapshotsValidator snapshotsValidator = new SnapshotsValidator();
    for (VM vm : listVms) {
        if (!validate(snapshotsValidator.vmNotDuringSnapshot(vm.getId())) || !validate(snapshotsValidator.vmNotInPreview(vm.getId()))) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private void incrementVmsGeneration() {
    List<VM> listVms = getVmsForDiskId();
    for (VM vm : listVms) {
        getVmStaticDao().incrementDbGeneration(vm.getId());
    }
}
#method_after
private void incrementVmsGeneration() {
    List<VM> listVms = getVmsForDiskId();
    for (VM vm : listVms) {
        vmStaticDao.incrementDbGeneration(vm.getId());
    }
}
#end_block

#method_before
protected Disk getDisk() {
    if (disk == null) {
        disk = getDiskDao().get(getParameters().getDiskId());
    }
    return disk;
}
#method_after
protected Disk getDisk() {
    if (disk == null) {
        disk = diskDao.get(getParameters().getDiskId());
    }
    return disk;
}
#end_block

#method_before
protected DiskImage getDiskImage() {
    if (diskImage == null) {
        Disk disk = getDiskDao().get(getParameters().getImageGroupID());
        if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            diskImage = (DiskImage) disk;
        }
    }
    return diskImage;
}
#method_after
protected DiskImage getDiskImage() {
    if (diskImage == null) {
        Disk disk = diskDao.get(getParameters().getImageGroupID());
        if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            diskImage = (DiskImage) disk;
        }
    }
    return diskImage;
}
#end_block

#method_before
private boolean validateDiskImage() {
    Disk disk = getDiskDao().get(getParameters().getImageGroupID());
    if (disk != null && !validate(new DiskValidator(disk, vmDeviceUtils).validateUnsupportedDiskStorageType(DiskStorageType.LUN, DiskStorageType.CINDER))) {
        return false;
    }
    if (getDiskImage() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#method_after
private boolean validateDiskImage() {
    Disk disk = diskDao.get(getParameters().getImageGroupID());
    if (disk != null && !validate(new DiskValidator(disk).validateUnsupportedDiskStorageType(DiskStorageType.LUN, DiskStorageType.CINDER))) {
        return false;
    }
    if (getDiskImage() == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
public String getDestinationStorageDomainName() {
    return getStorageDomainDao().get(getParameters().getDestinationDomainId()).getName();
}
#method_after
public String getDestinationStorageDomainName() {
    return storageDomainDao.get(getParameters().getDestinationDomainId()).getName();
}
#end_block

#method_before
@Override
protected boolean validate() {
    if (!validateDiskImage()) {
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDao().getVmsListForDisk(getDiskImage().getId(), false)) {
        if (vm.getStatus() != VMStatus.Down) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(getDiskImage());
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean validate() {
    if (!validateDiskImage()) {
        return false;
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : vmDao.getVmsListForDisk(getDiskImage().getId(), false)) {
        if (vm.getStatus() != VMStatus.Down) {
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(getDiskImage());
    if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
        return false;
    }
    return true;
}
#end_block

#method_before
public ValidationResult isDiskAttachedToAnyVm() {
    List<VM> vms = getVmDao().getVmsListForDisk(disk.getId(), true);
    if (!vms.isEmpty()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS, DISK_NAME_VARIABLE, disk.getDiskAlias());
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult isDiskAttachedToAnyVm() {
    List<VM> vms = getVmDao().getVmsListForDisk(disk.getId(), true);
    if (!vms.isEmpty()) {
        return new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS, ReplacementUtils.createSetVariableString(DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(VM_LIST, vms.stream().map(VM::getName).collect(Collectors.joining(","))));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Before
public void setUp() {
    initializeOsRepository(1, DiskInterface.VirtIO);
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    validator = spy(new DiskValidator(disk, vmDeviceUtils));
    doReturn(vmDao).when(validator).getVmDao();
}
#method_after
@Before
public void setUp() {
    disk = createDiskImage();
    disk.setDiskAlias("disk1");
    validator = spy(new DiskValidator(disk));
    doReturn(vmDao).when(validator).getVmDao();
}
#end_block

#method_before
private void setupForLun() {
    lunDisk = createLunDisk();
    lunValidator = spy(new DiskValidator(lunDisk, vmDeviceUtils));
    doReturn(vmDao).when(lunValidator).getVmDao();
}
#method_after
private void setupForLun() {
    lunDisk = createLunDisk();
    lunValidator = spy(new DiskValidator(lunDisk));
    doReturn(vmDao).when(lunValidator).getVmDao();
}
#end_block

#method_before
@Test
public void testDiskAttachedToVMValid() {
    VM vm = createVM();
    when(vmDao.getVmsListForDisk(Matchers.any(Guid.class), anyBoolean())).thenReturn(Collections.singletonList(vm));
    assertThat(validator.isDiskAttachedToVm(vm), isValid());
}
#method_after
@Test
public void testDiskAttachedToVMValid() {
    VM vm = createVM();
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(Collections.singletonList(vm));
    assertThat(validator.isDiskAttachedToVm(vm), isValid());
}
#end_block

#method_before
@Test
public void testDiskAttachedToVMFail() {
    VM vm = createVM();
    when(vmDao.getVmsListForDisk(Matchers.any(Guid.class), anyBoolean())).thenReturn(Collections.emptyList());
    assertThat(validator.isDiskAttachedToVm(vm), failsWith(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_ATTACHED_TO_VM));
}
#method_after
@Test
public void testDiskAttachedToVMFail() {
    VM vm = createVM();
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(Collections.emptyList());
    assertThat(validator.isDiskAttachedToVm(vm), failsWith(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_ATTACHED_TO_VM));
}
#end_block

#method_before
@Test
public void testDiskAttachedToAnyVM() {
    when(vmDao.getVmsListForDisk(Matchers.any(Guid.class), anyBoolean())).thenReturn(Collections.emptyList());
    assertThat(validator.isDiskAttachedToAnyVm(), isValid());
}
#method_after
@Test
public void testDiskAttachedToAnyVM() {
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(Collections.emptyList());
    assertThat(validator.isDiskAttachedToAnyVm(), isValid());
}
#end_block

#method_before
@Test
public void testDiskAttachedToAnyVMFails() {
    VM vm = createVM();
    when(vmDao.getVmsListForDisk(Matchers.any(Guid.class), anyBoolean())).thenReturn(Collections.singletonList(vm));
    assertThat(validator.isDiskAttachedToAnyVm(), failsWith(EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS));
}
#method_after
@Test
public void testDiskAttachedToAnyVMFails() {
    VM vm1 = createVM();
    VM vm2 = createVM();
    vm1.setName("Vm1");
    vm2.setName("Vm2");
    List<VM> vmList = Arrays.asList(vm1, vm2);
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
    String[] expectedReplacements = { ReplacementUtils.createSetVariableString(DiskValidator.DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(DiskValidator.VM_LIST, "Vm1,Vm2") };
    assertThat(validator.isDiskAttachedToAnyVm(), failsWith(EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS, expectedReplacements));
}
#end_block

#method_before
@Test
public void testDiskAttachedToVMFailWithCorrectReplacements() {
    VM vm = createVM();
    vm.setName("MyVm");
    disk.setDiskAlias("MyDisk");
    when(vmDao.getVmsListForDisk(Matchers.any(Guid.class), anyBoolean())).thenReturn(Collections.emptyList());
    String[] expectedReplacements = { ReplacementUtils.createSetVariableString(DiskValidator.DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(DiskValidator.VM_NAME_VARIABLE, vm.getName()) };
    assertThat(validator.isDiskAttachedToVm(vm), failsWith(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_ATTACHED_TO_VM, expectedReplacements));
}
#method_after
@Test
public void testDiskAttachedToVMFailWithCorrectReplacements() {
    VM vm = createVM();
    vm.setName("MyVm");
    disk.setDiskAlias("MyDisk");
    when(vmDao.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(Collections.emptyList());
    String[] expectedReplacements = { ReplacementUtils.createSetVariableString(DiskValidator.DISK_NAME_VARIABLE, disk.getDiskAlias()), ReplacementUtils.createSetVariableString(DiskValidator.VM_NAME_VARIABLE, vm.getName()) };
    assertThat(validator.isDiskAttachedToVm(vm), failsWith(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_ATTACHED_TO_VM, expectedReplacements));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getUploadSize());
    getImageTransferDao().save(entity);
    log.info("Creating {} image", getUploadType());
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        createImage();
    } else {
        handleImageIsReadyForUpload(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    log.info("Creating ImageTransfer entity for command '{}'", getCommandId());
    ImageTransfer entity = new ImageTransfer(getCommandId());
    entity.setCommandType(getActionType());
    entity.setPhase(ImageTransferPhase.INITIALIZING);
    entity.setLastUpdated(new Date());
    entity.setBytesTotal(getParameters().getUploadSize());
    imageTransferDao.save(entity);
    log.info("Creating {} image", getUploadType());
    // If an image was not created yet, create it.
    if (Guid.isNullOrEmpty(getParameters().getImageId())) {
        createImage();
    } else {
        handleImageIsReadyForUpload(getParameters().getImageId());
    }
    setActionReturnValue(getCommandId());
    setSucceeded(true);
}
#end_block

#method_before
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = getImageTransferDao().get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image Upload status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the upload is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImage((DiskImage) getDiskDao().get(entity.getDiskId()));
    }
    // Check conditions for pausing the upload (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseUploadIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#method_after
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = imageTransferDao.get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image Upload status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the upload is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImage((DiskImage) diskDao.get(entity.getDiskId()));
    }
    // Check conditions for pausing the upload (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseUploadIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#end_block

#method_before
protected void handleImageIsReadyForUpload(Guid imageGuid) {
    DiskImage image = (DiskImage) getDiskDao().get(imageGuid);
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setImageId(imageGuid);
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    if (getParameters().getUploadSize() == 0) {
        getParameters().setUploadSize(image.getSize());
    }
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getUploadDescription(), getCommandId());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setDiskId(imageGuid);
    updateEntity(updates);
    // The image will remain locked until the upload command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#method_after
protected void handleImageIsReadyForUpload(Guid imageGuid) {
    DiskImage image = (DiskImage) diskDao.get(imageGuid);
    Guid domainId = image.getStorageIds().get(0);
    getParameters().setStorageDomainId(domainId);
    getParameters().setImageId(imageGuid);
    // ovirt-imageio-daemon must know the boundaries of the target image for writing permissions.
    if (getParameters().getUploadSize() == 0) {
        getParameters().setUploadSize(image.getSize());
    }
    persistCommand(getParameters().getParentCommand(), true);
    setImage(image);
    setStorageDomainId(domainId);
    log.info("Successfully added {} for image transfer command '{}'", getUploadDescription(), getCommandId());
    ImageTransfer updates = new ImageTransfer();
    updates.setDiskId(imageGuid);
    updateEntity(updates);
    // The image will remain locked until the upload command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#end_block

#method_before
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
protected boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
protected boolean validate() {
    Guid imageId = getParameters().getImageId();
    if (!Guid.isNullOrEmpty(imageId)) {
        return validateUploadToImage(imageId);
    } else {
        return validateCreateImage();
    }
}
#method_after
@Override
protected boolean validate() {
    Guid imageId = getParameters().getImageId();
    if (!Guid.isNullOrEmpty(imageId)) {
        return validateUploadToImage(imageId);
    } else {
        return validateCreateImage();
    }
}
#end_block

#method_before
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        log.warn("Failed to stop image transfer session. Ticket does not exist for image '{}'", entity.getDiskId());
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    boolean clearResourceId = true;
    updateEntity(updates, clearResourceId);
    return true;
}
#method_after
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        log.warn("Failed to stop image transfer session. Ticket does not exist for image '{}'", entity.getDiskId());
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransfer updates = new ImageTransfer();
    boolean clearResourceId = true;
    updateEntity(updates, clearResourceId);
    return true;
}
#end_block

#method_before
protected ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    ImageTransferUpdates updates = new ImageTransferUpdates(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#method_after
protected ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    ImageTransfer updates = new ImageTransfer(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#end_block

#method_before
protected ImageTransfer updateEntity(ImageTransferUpdates updates, boolean clearResourceId) {
    return getImageTransferUpdater().updateEntity(updates, getCommandId(), clearResourceId);
}
#method_after
protected ImageTransfer updateEntity(ImageTransfer updates) {
    return updateEntity(updates, false);
}
#end_block

#method_before
// Return a string describing the upload, safe for use before the new image
protected String getUploadDescription() {
    // TODO: nicer.
    String imageAlias = "";
    DiskImage diskImage = getDiskImage();
    if (diskImage != null && diskImage.getDiskAlias() != null) {
        imageAlias = getDiskImage().getDiskAlias();
    } else if (getParameters().getDiskAlias() != null) {
        imageAlias = getParameters().getDiskAlias();
    }
    return String.format("%s '%s' (id '%s')", getUploadType(), imageAlias, getImageIdNullSafe());
}
#method_after
// Return a string describing the upload, safe for use before the new image
protected String getUploadDescription() {
    return String.format("%s '%s' (id '%s')", getUploadType(), getImageAlias(), getImageIdNullSafe());
}
#end_block

#method_before
public void onSucceeded() {
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
    log.debug("Removing ImageUpload id {}", getCommandId());
    getImageTransferDao().remove(getCommandId());
    endSuccessfully();
    log.info("Successfully uploaded {} (command id '{}')", getUploadDescription(), getCommandId());
}
#method_after
public void onSucceeded() {
    updateEntityPhase(ImageTransferPhase.FINISHED_SUCCESS);
    log.debug("Removing ImageUpload id {}", getCommandId());
    imageTransferDao.remove(getCommandId());
    endSuccessfully();
    log.info("Successfully uploaded {} (command id '{}')", getUploadDescription(), getCommandId());
}
#end_block

#method_before
public void onFailed() {
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    log.debug("Removing ImageUpload id {}", getCommandId());
    getImageTransferDao().remove(getCommandId());
    endWithFailure();
    log.error("Failed to upload {} (command id '{}')", getUploadDescription(), getCommandId());
}
#method_after
public void onFailed() {
    updateEntityPhase(ImageTransferPhase.FINISHED_FAILURE);
    log.debug("Removing ImageUpload id {}", getCommandId());
    imageTransferDao.remove(getCommandId());
    endWithFailure();
    log.error("Failed to upload {} (command id '{}')", getUploadDescription(), getCommandId());
}
#end_block

#method_before
@Before
public void setUp() {
    uploadImageCommand = spy(new UploadDiskImageCommand(new UploadDiskImageParameters(), null));
    initCommand();
}
#method_after
@Before
public void setUp() {
    initCommand();
}
#end_block

#method_before
protected void initializeSuppliedImage() {
    super.initSuppliedImage(uploadImageCommand);
    DiskImage diskImage = new DiskImage();
    doReturn(diskImage).when(diskDao).get(any());
    doReturn(diskDao).when(uploadImageCommand).getDiskDao();
    ArrayList<DiskImage> diskImageList = new ArrayList<>();
    diskImageList.add(diskImage);
    doReturn(diskValidator).when(getCommand()).getDiskValidator(any());
    doReturn(diskImagesValidator).when(getCommand()).getDiskImagesValidator(any());
    // Set validators return
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToAnyVm();
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesNotLocked();
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesNotIllegal();
}
#method_after
protected void initializeSuppliedImage() {
    super.initSuppliedImage(uploadImageCommand);
    DiskImage diskImage = new DiskImage();
    doReturn(diskImage).when(diskDao).get(any());
    doReturn(diskValidator).when(getCommand()).getDiskValidator(any());
    doReturn(diskImagesValidator).when(getCommand()).getDiskImagesValidator(any());
    // Set validators return
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToAnyVm();
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesNotLocked();
    doReturn(ValidationResult.VALID).when(diskImagesValidator).diskImagesNotIllegal();
}
#end_block

#method_before
@Test
public void validateCantUploadLockedImage() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED, "")).when(diskImagesValidator).diskImagesNotLocked();
    assertFailsWithValidateMessage(getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
}
#method_after
@Test
public void validateCantUploadLockedImage() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED, "")).when(diskImagesValidator).diskImagesNotLocked();
    getCommand().validate();
    ValidateTestUtils.assertValidationMessages("Can't start a transfer for a locked image.", getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISKS_LOCKED);
}
#end_block

#method_before
@Test
public void validateCantUploadDiskAttached() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS, "")).when(diskValidator).isDiskAttachedToAnyVm();
    assertFailsWithValidateMessage(getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS);
}
#method_after
@Test
public void validateCantUploadDiskAttached() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS, "")).when(diskValidator).isDiskAttachedToAnyVm();
    getCommand().validate();
    ValidateTestUtils.assertValidationMessages("Can't start a transfer for an image that is attached to any VMs.", getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISK_ATTACHED_TO_VMS);
}
#end_block

#method_before
@Test
public void validateCantUploadDiskNotExists() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST, "")).when(diskValidator).isDiskExists();
    assertFailsWithValidateMessage(getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
}
#method_after
@Test
public void validateCantUploadDiskNotExists() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST, "")).when(diskValidator).isDiskExists();
    getCommand().validate();
    ValidateTestUtils.assertValidationMessages("Can't start a transfer for image that doesn't exist.", getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
}
#end_block

#method_before
@Test
public void validateCantUploadIllegalImage() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISKS_ILLEGAL, "")).when(diskImagesValidator).diskImagesNotIllegal();
    assertFailsWithValidateMessage(getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISKS_ILLEGAL);
}
#method_after
@Test
public void validateCantUploadIllegalImage() {
    initializeSuppliedImage();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_DISKS_ILLEGAL, "")).when(diskImagesValidator).diskImagesNotIllegal();
    getCommand().validate();
    ValidateTestUtils.assertValidationMessages("Can't start a transfer for an illegal image.", getCommand(), EngineMessage.ACTION_TYPE_FAILED_DISKS_ILLEGAL);
}
#end_block

#method_before
@Override
protected boolean validateCreateImage() {
    VdcReturnValueBase returnValue = CommandHelper.canDoAction(VdcActionType.AddDisk, getAddDiskParameters(), getContext().clone().getExecutionContext(), true);
    getReturnValue().setValidationMessages(returnValue.getValidationMessages());
    return returnValue.isValid();
}
#method_after
@Override
protected boolean validateCreateImage() {
    VdcReturnValueBase returnValue = CommandHelper.canDoAction(VdcActionType.AddDisk, getAddDiskParameters(), getContext().clone());
    getReturnValue().setValidationMessages(returnValue.getValidationMessages());
    return returnValue.isValid();
}
#end_block

#method_before
@Override
protected boolean validateUploadToImage(Guid imageId) {
    DiskImage diskImage = (DiskImage) getDiskDao().get(imageId);
    DiskValidator diskValidator = getDiskValidator(diskImage);
    DiskImagesValidator diskImagesValidator = getDiskImagesValidator(diskImage);
    return validate(diskValidator.isDiskExists()) && validate(diskValidator.isDiskAttachedToAnyVm()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#method_after
@Override
protected boolean validateUploadToImage(Guid imageId) {
    DiskImage diskImage = (DiskImage) diskDao.get(imageId);
    DiskValidator diskValidator = getDiskValidator(diskImage);
    DiskImagesValidator diskImagesValidator = getDiskImagesValidator(diskImage);
    return validate(diskValidator.isDiskExists()) && validate(diskValidator.isDiskAttachedToAnyVm()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(diskImagesValidator.diskImagesNotLocked());
}
#end_block

#method_before
protected DiskImagesValidator getDiskImagesValidator(DiskImage diskImage) {
    List<DiskImage> diskImageInList = new ArrayList<>();
    diskImageInList.add(diskImage);
    return new DiskImagesValidator(diskImageInList);
}
#method_after
protected DiskImagesValidator getDiskImagesValidator(DiskImage diskImage) {
    return new DiskImagesValidator(diskImage);
}
#end_block

#method_before
protected DiskValidator getDiskValidator(DiskImage diskImage) {
    return new DiskValidator(diskImage, getVmDeviceUtils());
}
#method_after
protected DiskValidator getDiskValidator(DiskImage diskImage) {
    return new DiskValidator(diskImage);
}
#end_block

#method_before
@Override
protected void tearDownImage(Guid vdsId) {
    VDSReturnValue vdsRetVal = runVdsCommand(VDSCommandType.TeardownImage, getImageActionsParameters(vdsId));
    if (!vdsRetVal.getSucceeded()) {
        DiskImage image = (DiskImage) getDiskDao().get(getParameters().getImageId());
        log.warn("Failed to tear down image '{}' for image transfer session: {}", image, vdsRetVal.getVdsError());
        // Invoke log method directly rather than relying on infra, because teardown
        // failure may occur during command execution, e.g. if the upload is paused.
        addCustomValue("DiskAlias", image != null ? image.getDiskAlias() : "(unknown)");
        auditLogDirector.log(this, AuditLogType.UPLOAD_IMAGE_TEARDOWN_FAILED);
    }
}
#method_after
@Override
protected void tearDownImage(Guid vdsId) {
    VDSReturnValue vdsRetVal = runVdsCommand(VDSCommandType.TeardownImage, getImageActionsParameters(vdsId));
    if (!vdsRetVal.getSucceeded()) {
        DiskImage image = (DiskImage) diskDao.get(getParameters().getImageId());
        log.warn("Failed to tear down image '{}' for image transfer session: {}", image, vdsRetVal.getVdsError());
        // Invoke log method directly rather than relying on infra, because teardown
        // failure may occur during command execution, e.g. if the upload is paused.
        addCustomValue("DiskAlias", image != null ? image.getDiskAlias() : "(unknown)");
        auditLogDirector.log(this, AuditLogType.UPLOAD_IMAGE_TEARDOWN_FAILED);
    }
}
#end_block

#method_before
@Override
protected String getImageAlias() {
    return getParameters().getAddDiskParameters().getDiskInfo().getDiskAlias();
}
#method_after
@Override
protected String getImageAlias() {
    return getParameters().getAddDiskParameters() != null ? getParameters().getAddDiskParameters().getDiskInfo().getDiskAlias() : getDiskImage().getDiskAlias();
}
#end_block

#method_before
@Before
public void setUp() {
    uploadImageCommand = spy(new UploadDiskImageCommand(new UploadDiskImageParameters(), null));
    initCommand();
}
#method_after
@Before
public void setUp() {
    initCommand();
}
#end_block

#method_before
protected void initCommand() {
    doNothing().when(uploadImageCommand).createImage();
    doNothing().when(uploadImageCommand).persistCommand(any(), anyBoolean());
    doNothing().when(uploadImageCommand).lockImage();
    doReturn(true).when(uploadImageCommand).startImageTransferSession();
    doReturn(null).when(imageTransferUpdater).updateEntity(any(), any(), anyBoolean());
    // Don't save the entity in DB.
    doNothing().when(imageTransferDao).save(any());
    doReturn(imageTransferDao).when(uploadImageCommand).getImageTransferDao();
    doReturn(diskDao).when(uploadImageCommand).getDiskDao();
    doReturn(imageTransferUpdater).when(uploadImageCommand).getImageTransferUpdater();
}
#method_after
protected void initCommand() {
    doNothing().when(uploadImageCommand).createImage();
    doNothing().when(uploadImageCommand).persistCommand(any(), anyBoolean());
    doNothing().when(uploadImageCommand).lockImage();
    doReturn(true).when(uploadImageCommand).startImageTransferSession();
    doReturn(null).when(imageTransferUpdater).updateEntity(any(), any(), anyBoolean());
}
#end_block

#method_before
@Test
public void testCommandPersistedWithParamUpdates() {
    DiskImage readyImage = initReadyImageForUpload();
    UploadDiskImageParameters params = mock(UploadDiskImageParameters.class);
    doNothing().when(params).setStorageDomainId(any());
    doNothing().when(params).setImageId(any());
    doNothing().when(params).setUploadSize(anyLong());
    doReturn(params).when(uploadImageCommand).getParameters();
    uploadImageCommand.handleImageIsReadyForUpload(readyImage.getImageId());
    // Verify that persistCommand is being called after each of the params changes.
    InOrder inOrder = inOrder(params, uploadImageCommand);
    inOrder.verify(params).setStorageDomainId(any());
    inOrder.verify(uploadImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, uploadImageCommand);
    inOrder.verify(params).setImageId(any());
    inOrder.verify(uploadImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, uploadImageCommand);
    inOrder.verify(params).setUploadSize(anyLong());
    inOrder.verify(uploadImageCommand).persistCommand(any(), anyBoolean());
}
#method_after
@Test
public void testCommandPersistedWithParamUpdates() {
    DiskImage readyImage = initReadyImageForUpload();
    UploadDiskImageParameters params = mock(UploadDiskImageParameters.class);
    doReturn(params).when(uploadImageCommand).getParameters();
    uploadImageCommand.handleImageIsReadyForUpload(readyImage.getImageId());
    // Verify that persistCommand is being called after each of the params changes.
    InOrder inOrder = inOrder(params, uploadImageCommand);
    inOrder.verify(params).setStorageDomainId(any());
    inOrder.verify(uploadImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, uploadImageCommand);
    inOrder.verify(params).setImageId(any());
    inOrder.verify(uploadImageCommand).persistCommand(any(), anyBoolean());
    inOrder = inOrder(params, uploadImageCommand);
    inOrder.verify(params).setUploadSize(anyLong());
    inOrder.verify(uploadImageCommand).persistCommand(any(), anyBoolean());
}
#end_block

#method_before
public ImageTransfer updateEntity(ImageTransferUpdates updates, Guid commandId, boolean clearResourceId) {
    // TODO this lock might not be enough; analyze possible concurrent calls
    LockManager lockManager = LockManagerFactory.getLockManager();
    EngineLock lock = getEntityUpdateLock(commandId);
    lockManager.acquireLockWait(lock);
    ImageTransfer entity = imageTransferDao.get(commandId);
    if (entity == null) {
        log.error("Attempt to update non-existent ImageUpload entity");
        return null;
    }
    entity.setLastUpdated(new java.util.Date());
    if (updates != null) {
        if (updates.getId() != null) {
            entity.setId(updates.getId());
        }
        if (updates.getPhase() != null) {
            String disk = entity.getDiskId() != null ? String.format(" (image %s)", entity.getDiskId().toString()) : "";
            String message = entity.getMessage() != null ? String.format(" (message: '%s')", entity.getMessage()) : "";
            log.info("Updating image upload {}{} phase to {}{}", commandId, disk, updates.getPhase(), message);
            entity.setPhase(updates.getPhase());
        }
        if (updates.getMessage() != null) {
            entity.setMessage(updates.getMessage());
        }
        if (updates.getVdsId() != null) {
            entity.setVdsId(updates.getVdsId());
        }
        if (updates.getDiskId() != null) {
            entity.setDiskId(updates.getDiskId());
        }
        if (updates.getImagedTicketId() != null || clearResourceId) {
            entity.setImagedTicketId(updates.getImagedTicketId());
        }
        if (updates.getProxyUri() != null) {
            entity.setProxyUri(updates.getProxyUri());
        }
        if (updates.getSignedTicket() != null) {
            entity.setSignedTicket(updates.getSignedTicket());
        }
        if (updates.getBytesSent() != null) {
            entity.setBytesSent(updates.getBytesSent());
        }
        if (updates.getBytesTotal() != null) {
            entity.setBytesTotal(updates.getBytesTotal());
        }
    }
    imageTransferDao.update(entity);
    lockManager.releaseLock(lock);
    return entity;
}
#method_after
public ImageTransfer updateEntity(ImageTransfer updates, Guid commandId, boolean clearResourceId) {
    // TODO this lock might not be enough; analyze possible concurrent calls
    LockManager lockManager = LockManagerFactory.getLockManager();
    EngineLock lock = getEntityUpdateLock(commandId);
    lockManager.acquireLockWait(lock);
    ImageTransfer entity = imageTransferDao.get(commandId);
    if (entity == null) {
        log.error("Attempt to update non-existent ImageUpload entity");
        return null;
    }
    entity.setLastUpdated(new java.util.Date());
    if (updates != null) {
        if (updates.getId() != null) {
            entity.setId(updates.getId());
        }
        if (updates.getPhase() != null) {
            String disk = entity.getDiskId() != null ? String.format(" (image %s)", entity.getDiskId().toString()) : "";
            String message = entity.getMessage() != null ? String.format(" (message: '%s')", entity.getMessage()) : "";
            log.info("Updating image upload {}{} phase to {}{}", commandId, disk, updates.getPhase(), message);
            entity.setPhase(updates.getPhase());
        }
        if (updates.getMessage() != null) {
            entity.setMessage(updates.getMessage());
        }
        if (updates.getVdsId() != null) {
            entity.setVdsId(updates.getVdsId());
        }
        if (updates.getDiskId() != null) {
            entity.setDiskId(updates.getDiskId());
        }
        if (updates.getImagedTicketId() != null || clearResourceId) {
            entity.setImagedTicketId(updates.getImagedTicketId());
        }
        if (updates.getProxyUri() != null) {
            entity.setProxyUri(updates.getProxyUri());
        }
        if (updates.getSignedTicket() != null) {
            entity.setSignedTicket(updates.getSignedTicket());
        }
        if (updates.getBytesSent() != null) {
            entity.setBytesSent(updates.getBytesSent());
        }
        if (updates.getBytesTotal() != null) {
            entity.setBytesTotal(updates.getBytesTotal());
        }
    }
    imageTransferDao.update(entity);
    lockManager.releaseLock(lock);
    return entity;
}
#end_block

#method_before
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = imageTransferDao.get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image Upload status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the upload is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImage((DiskImage) getDiskDao().get(entity.getDiskId()));
    }
    // Check conditions for pausing the upload (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseUploadIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#method_after
public void proceedCommandExecution(Guid childCmdId) {
    ImageTransfer entity = imageTransferDao.get(getCommandId());
    if (entity == null || entity.getPhase() == null) {
        log.error("Image Upload status entity corrupt or missing from database" + " for image transfer command '{}'", getCommandId());
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    if (entity.getDiskId() != null) {
        // Make the disk id available for all states below.  If the upload is still
        // initializing, this may be set below in the INITIALIZING block instead.
        setImage((DiskImage) diskDao.get(entity.getDiskId()));
    }
    // Check conditions for pausing the upload (ie UI is MIA)
    long ts = System.currentTimeMillis() / 1000;
    if (pauseUploadIfNecessary(entity, ts)) {
        return;
    }
    executeStateHandler(entity, ts, childCmdId);
}
#end_block

#method_before
private void handleInitializing(final StateContext context) {
    if (context.childCmdId == null) {
        // Guard against callback invocation before executeCommand() is complete
        return;
    }
    switch(CommandCoordinatorUtil.getCommandStatus(context.childCmdId)) {
        case NOT_STARTED:
        case ACTIVE:
            log.info("Waiting for {} to be added for image transfer command '{}'", getUploadType(), getCommandId());
            return;
        case SUCCEEDED:
            break;
        default:
            log.error("Failed to add {} for image transfer command '{}'", getUploadType(), getCommandId());
            setCommandStatus(CommandStatus.FAILED);
            return;
    }
    VdcReturnValueBase addDiskRetVal = CommandCoordinatorUtil.getCommandReturnValue(context.childCmdId);
    if (addDiskRetVal == null || !addDiskRetVal.getSucceeded()) {
        log.error("Failed to add {} (command status was success, but return value was failed)" + " for image transfer command '{}'", getUploadType(), getCommandId());
        setReturnValue(addDiskRetVal);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Guid createdId = addDiskRetVal.getActionReturnValue();
    DiskImage createdDiskImage = (DiskImage) getDiskDao().get(createdId);
    getParameters().setImageId(createdId);
    persistCommand(getParameters().getParentCommand(), true);
    setImage(createdDiskImage);
    log.info("Successfully added {} for image transfer command '{}'", getUploadDescription(), getCommandId());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setDiskId(createdId);
    updateEntity(updates);
    // The image will remain locked until the upload command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#method_after
private void handleInitializing(final StateContext context) {
    if (context.childCmdId == null) {
        // Guard against callback invocation before executeCommand() is complete
        return;
    }
    switch(CommandCoordinatorUtil.getCommandStatus(context.childCmdId)) {
        case NOT_STARTED:
        case ACTIVE:
            log.info("Waiting for {} to be added for image transfer command '{}'", getUploadType(), getCommandId());
            return;
        case SUCCEEDED:
            break;
        default:
            log.error("Failed to add {} for image transfer command '{}'", getUploadType(), getCommandId());
            setCommandStatus(CommandStatus.FAILED);
            return;
    }
    VdcReturnValueBase addDiskRetVal = CommandCoordinatorUtil.getCommandReturnValue(context.childCmdId);
    if (addDiskRetVal == null || !addDiskRetVal.getSucceeded()) {
        log.error("Failed to add {} (command status was success, but return value was failed)" + " for image transfer command '{}'", getUploadType(), getCommandId());
        setReturnValue(addDiskRetVal);
        setCommandStatus(CommandStatus.FAILED);
        return;
    }
    Guid createdId = addDiskRetVal.getActionReturnValue();
    DiskImage createdDiskImage = (DiskImage) diskDao.get(createdId);
    getParameters().setImageId(createdId);
    persistCommand(getParameters().getParentCommand(), true);
    setImage(createdDiskImage);
    log.info("Successfully added {} for image transfer command '{}'", getUploadDescription(), getCommandId());
    ImageTransfer updates = new ImageTransfer();
    updates.setDiskId(createdId);
    updateEntity(updates);
    // The image will remain locked until the upload command has completed.
    lockImage();
    boolean initSessionSuccess = startImageTransferSession();
    updateEntityPhase(initSessionSuccess ? ImageTransferPhase.TRANSFERRING : ImageTransferPhase.PAUSED_SYSTEM);
    log.info("Returning from proceedCommandExecution after starting transfer session" + " for image transfer command '{}'", getCommandId());
    resetPeriodicPauseLogTime(0);
}
#end_block

#method_before
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransferUpdates updates = new ImageTransferUpdates();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#method_after
private boolean startImageTransferSession() {
    if (!initializeVds()) {
        log.error("Could not find a suitable host for image data transfer");
        return false;
    }
    Guid imagedTicketId = Guid.newGuid();
    // Create the signed ticket first because we can just throw it away if we fail to start the image
    // transfer session.  The converse would require us to close the transfer session on failure.
    String signedTicket = createSignedTicket(getVds(), imagedTicketId);
    if (signedTicket == null) {
        return false;
    }
    String[] operations = { "write" };
    long timeout = getHostTicketLifetime();
    String imagePath;
    try {
        imagePath = prepareImage(getVdsId());
    } catch (Exception e) {
        log.error("Failed to prepare image for transfer session: {}", e);
        return false;
    }
    if (!setVolumeLegalityInStorage(ILLEGAL_IMAGE)) {
        return false;
    }
    AddImageTicketVDSCommandParameters transferCommandParams = new AddImageTicketVDSCommandParameters(getVdsId(), imagedTicketId, operations, timeout, getParameters().getUploadSize(), imagePath);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.AddImageTicket, transferCommandParams);
    } catch (RuntimeException e) {
        log.error("Failed to start image transfer session: {}", e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.error("Failed to start image transfer session");
        return false;
    }
    log.info("Started transfer session with ticket id {}, timeout {} seconds", imagedTicketId.toString(), timeout);
    ImageTransfer updates = new ImageTransfer();
    updates.setVdsId(getVdsId());
    updates.setImagedTicketId(imagedTicketId);
    updates.setProxyUri(getProxyUri());
    updates.setSignedTicket(signedTicket);
    updateEntity(updates);
    setNewSessionExpiration(timeout);
    return true;
}
#end_block

#method_before
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        log.warn("Failed to stop image transfer session. Ticket does not exist for image '{}'", entity.getDiskId());
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransferUpdates updates = new ImageTransferUpdates();
    boolean clearResourceId = true;
    updateEntity(updates, clearResourceId);
    return true;
}
#method_after
private boolean stopImageTransferSession(ImageTransfer entity) {
    if (entity.getImagedTicketId() == null) {
        log.warn("Failed to stop image transfer session. Ticket does not exist for image '{}'", entity.getDiskId());
        return false;
    }
    Guid resourceId = entity.getImagedTicketId();
    RemoveImageTicketVDSCommandParameters parameters = new RemoveImageTicketVDSCommandParameters(entity.getVdsId(), resourceId);
    // TODO This is called from doPolling(), we should run it async (runFutureVDSCommand?)
    VDSReturnValue vdsRetVal;
    try {
        vdsRetVal = getBackend().getResourceManager().runVdsCommand(VDSCommandType.RemoveImageTicket, parameters);
    } catch (RuntimeException e) {
        log.error("Failed to stop image transfer session for ticket '{}': {}", resourceId.toString(), e);
        return false;
    }
    if (!vdsRetVal.getSucceeded()) {
        log.warn("Failed to stop image transfer session for ticket '{}'", resourceId.toString());
        return false;
    }
    log.info("Successfully stopped image transfer session for ticket '{}'", resourceId.toString());
    ImageTransfer updates = new ImageTransfer();
    boolean clearResourceId = true;
    updateEntity(updates, clearResourceId);
    return true;
}
#end_block

#method_before
private ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    ImageTransferUpdates updates = new ImageTransferUpdates(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#method_after
private ImageTransfer updateEntityPhase(ImageTransferPhase phase) {
    ImageTransfer updates = new ImageTransfer(getCommandId());
    updates.setPhase(phase);
    return updateEntity(updates);
}
#end_block

#method_before
protected ImageTransfer updateEntity(ImageTransferUpdates updates, boolean clearResourceId) {
    return imageTransferUpdater.updateEntity(updates, getCommandId(), clearResourceId);
}
#method_after
protected ImageTransfer updateEntity(ImageTransfer updates) {
    return updateEntity(updates, false);
}
#end_block

#method_before
@Override
public Object getQueryableId() {
    return getId();
}
#method_after
@Override
public Guid getQueryableId() {
    return getId();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(DbFacade.getInstance().getImageTransferDao().getAll());
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(imageTransferDao.getAll());
}
#end_block

#method_before
@Override
public Response remove() {
    get();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(id);
    String host = ParametersHelper.getParameter(httpHeaders, uriInfo, HOST);
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = getHostId(host);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    return performAction(VdcActionType.RemoveStorageServerConnection, parameters);
}
#method_after
@Override
public Response remove() {
    get();
    StorageServerConnections connection = new StorageServerConnections();
    connection.setId(id);
    String host = ParametersHelper.getParameter(httpHeaders, uriInfo, HOST);
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = getHostId(host);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId, false);
    return performAction(VdcActionType.RemoveStorageServerConnection, parameters);
}
#end_block

#method_before
@Override
protected boolean validate() {
    StorageServerConnections newConnectionDetails = getConnection();
    StorageType storageType = newConnectionDetails.getStorageType();
    if (!storageType.isFileDomain() && !storageType.equals(StorageType.ISCSI)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_STORAGE_TYPE);
    }
    if (!isValidConnection(newConnectionDetails)) {
        return false;
    }
    // Check if connection exists by id, otherwise there's nothing to update
    String connectionId = newConnectionDetails.getId();
    StorageServerConnections oldConnection = getStorageConnDao().get(connectionId);
    if (oldConnection == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (!newConnectionDetails.getStorageType().equals(oldConnection.getStorageType())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
    }
    Guid storagePoolId = getStoragePoolIdByFileConnectionId(oldConnection.getId());
    if (isConnWithSameDetailsExists(newConnectionDetails, storagePoolId)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    if (doDomainsUseConnection(newConnectionDetails) || doLunsUseConnection()) {
        if (storageType.isFileDomain() && domains.size() > 1) {
            String domainNames = createDomainNamesList(domains);
            addValidationMessageVariable("domainNames", domainNames);
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
        }
        // Check that the storage domain is in proper state to be edited
        if (!isConnectionEditable(newConnectionDetails)) {
            return false;
        }
    }
    return super.validate();
}
#method_after
@Override
protected boolean validate() {
    StorageServerConnections newConnectionDetails = getConnection();
    StorageType storageType = newConnectionDetails.getStorageType();
    if (!storageType.isFileDomain() && !storageType.equals(StorageType.ISCSI)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_STORAGE_TYPE);
    }
    if (!isValidConnection(newConnectionDetails)) {
        return false;
    }
    // Check if connection exists by id, otherwise there's nothing to update
    String connectionId = newConnectionDetails.getId();
    StorageServerConnections oldConnection = storageServerConnectionDao.get(connectionId);
    if (oldConnection == null) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_NOT_EXIST);
    }
    if (!newConnectionDetails.getStorageType().equals(oldConnection.getStorageType())) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_CHANGE_STORAGE_TYPE);
    }
    Guid storagePoolId = getStoragePoolIdByFileConnectionId(oldConnection.getId());
    if (isConnWithSameDetailsExists(newConnectionDetails, storagePoolId)) {
        return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_ALREADY_EXISTS);
    }
    if (doDomainsUseConnection(newConnectionDetails) || doLunsUseConnection()) {
        if (storageType.isFileDomain() && domains.size() > 1) {
            String domainNames = createDomainNamesList(domains);
            addValidationMessageVariable("domainNames", domainNames);
            return failValidation(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_BELONGS_TO_SEVERAL_STORAGE_DOMAINS);
        }
        // Check that the storage domain is in proper state to be edited
        if (!isConnectionEditable(newConnectionDetails)) {
            return false;
        }
    }
    return super.validate();
}
#end_block

#method_before
protected List<LUNs> getLuns() {
    if (luns.isEmpty()) {
        luns = getLunDao().getAllForStorageServerConnection(getConnection().getId());
    }
    return luns;
}
#method_after
protected List<LUNs> getLuns() {
    if (luns.isEmpty()) {
        luns = lunDao.getAllForStorageServerConnection(getConnection().getId());
    }
    return luns;
}
#end_block

#method_before
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getStorageType().isFileDomain()) {
        boolean isConnectionEditable = isFileDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addValidationMessageVariable("domainNames", domains.get(0).getStorageName());
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = getVmDao().getForDisk(diskId, true);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = getStorageDomainDao().get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached)) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance) && !getParameters().isForce()) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addValidationMessageVariable("vmNames", prepareEntityNamesForMessage(problematicVMNames));
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addValidationMessageVariable("vmNames", prepareEntityNamesForMessage(problematicVMNames));
                addValidationMessageVariable("domainNames", prepareEntityNamesForMessage(problematicDomainNames));
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addValidationMessageVariable("domainNames", prepareEntityNamesForMessage(problematicDomainNames));
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean isConnectionEditable(StorageServerConnections connection) {
    if (connection.getStorageType().isFileDomain()) {
        boolean isConnectionEditable = isFileDomainInEditState(domains.get(0));
        if (!isConnectionEditable) {
            addValidationMessageVariable("domainNames", domains.get(0).getStorageName());
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
        }
        return isConnectionEditable;
    }
    if (!getLuns().isEmpty()) {
        List<String> problematicVMNames = new ArrayList<>();
        List<String> problematicDomainNames = new ArrayList<>();
        for (LUNs lun : getLuns()) {
            Guid diskId = lun.getDiskId();
            if (diskId != null) {
                Map<Boolean, List<VM>> vmsMap = vmDao.getForDisk(diskId, true);
                List<VM> pluggedVms = vmsMap.get(Boolean.TRUE);
                if (pluggedVms != null && !pluggedVms.isEmpty()) {
                    for (VM vm : pluggedVms) {
                        if (!vm.getStatus().equals(VMStatus.Down)) {
                            problematicVMNames.add(vm.getName());
                        }
                    }
                }
            }
            Guid storageDomainId = lun.getStorageDomainId();
            if (storageDomainId != null) {
                StorageDomain domain = storageDomainDao.get(storageDomainId);
                if (!domain.getStorageDomainSharedStatus().equals(StorageDomainSharedStatus.Unattached) && !getParameters().isForce()) {
                    for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                        if (!map.getStatus().equals(StorageDomainStatus.Maintenance)) {
                            String domainName = domain.getStorageName();
                            problematicDomainNames.add(domainName);
                        } else {
                            domains.add(domain);
                        }
                    }
                } else {
                    // unattached domain, edit allowed
                    domains.add(domain);
                }
            }
        }
        if (!problematicVMNames.isEmpty()) {
            if (problematicDomainNames.isEmpty()) {
                addValidationMessageVariable("vmNames", prepareEntityNamesForMessage(problematicVMNames));
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS);
            } else {
                addValidationMessageVariable("vmNames", prepareEntityNamesForMessage(problematicVMNames));
                addValidationMessageVariable("domainNames", prepareEntityNamesForMessage(problematicDomainNames));
                addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_STORAGE_CONNECTION_UNSUPPORTED_ACTION_FOR_RUNNING_VMS_AND_DOMAINS_STATUS);
            }
            return false;
        }
        if (!problematicDomainNames.isEmpty()) {
            addValidationMessageVariable("domainNames", prepareEntityNamesForMessage(problematicDomainNames));
            addValidationMessage(EngineMessage.ACTION_TYPE_FAILED_UNSUPPORTED_ACTION_DOMAIN_MUST_BE_IN_MAINTENANCE_OR_UNATTACHED);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    boolean isDomainUpdateRequired = !Guid.isNullOrEmpty(getVdsId()) && doDomainsUseConnection(getConnection());
    List<StorageDomain> updatedDomains = new ArrayList<>();
    boolean hasConnectStorageSucceeded = false;
    if (isDomainUpdateRequired) {
        hasConnectStorageSucceeded = connectToStorage();
        VDSReturnValue returnValueUpdatedStorageDomain = null;
        if (hasConnectStorageSucceeded) {
            changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
            for (StorageDomain domain : domains) {
                // update info such as free space - because we switched to a different server
                returnValueUpdatedStorageDomain = getStatsForDomain(domain);
                if (returnValueUpdatedStorageDomain.getSucceeded()) {
                    StorageDomain updatedStorageDomain = (StorageDomain) returnValueUpdatedStorageDomain.getReturnValue();
                    updatedDomains.add(updatedStorageDomain);
                }
            }
            if (!updatedDomains.isEmpty()) {
                updateStorageDomain(updatedDomains);
            }
        }
    }
    getStorageConnDao().update(getParameters().getStorageServerConnection());
    if (isDomainUpdateRequired) {
        for (StorageDomain domain : domains) {
            for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                restoreStateAfterUpdate(map);
            }
        }
        if (hasConnectStorageSucceeded) {
            disconnectFromStorage();
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    boolean isDomainUpdateRequired = !Guid.isNullOrEmpty(getVdsId()) && doDomainsUseConnection(getConnection());
    List<StorageDomain> updatedDomains = new ArrayList<>();
    boolean hasConnectStorageSucceeded = false;
    if (isDomainUpdateRequired) {
        hasConnectStorageSucceeded = connectToStorage();
        VDSReturnValue returnValueUpdatedStorageDomain = null;
        if (hasConnectStorageSucceeded) {
            changeStorageDomainStatusInTransaction(StorageDomainStatus.Locked);
            for (StorageDomain domain : domains) {
                // update info such as free space - because we switched to a different server
                returnValueUpdatedStorageDomain = getStatsForDomain(domain);
                if (returnValueUpdatedStorageDomain.getSucceeded()) {
                    StorageDomain updatedStorageDomain = (StorageDomain) returnValueUpdatedStorageDomain.getReturnValue();
                    updatedDomains.add(updatedStorageDomain);
                }
            }
            if (!updatedDomains.isEmpty()) {
                updateStorageDomain(updatedDomains);
            }
        }
    }
    storageServerConnectionDao.update(getParameters().getStorageServerConnection());
    if (isDomainUpdateRequired) {
        for (StorageDomain domain : domains) {
            for (StoragePoolIsoMap map : getStoragePoolIsoMap(domain)) {
                restoreStateAfterUpdate(map);
            }
        }
        if (hasConnectStorageSucceeded) {
            disconnectFromStorage();
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
protected Collection<StoragePoolIsoMap> getStoragePoolIsoMap(StorageDomain storageDomain) {
    return getStoragePoolIsoMapDao().getAllForStorage(storageDomain.getId());
}
#method_after
protected Collection<StoragePoolIsoMap> getStoragePoolIsoMap(StorageDomain storageDomain) {
    return storagePoolIsoMapDao.getAllForStorage(storageDomain.getId());
}
#end_block

#method_before
protected void updateStorageDomain(final List<StorageDomain> storageDomainsToUpdate) {
    executeInNewTransaction(() -> {
        for (StorageDomain domainToUpdate : storageDomainsToUpdate) {
            CompensationContext context = getCompensationContext();
            context.snapshotEntity(domainToUpdate.getStorageDynamicData());
            getStorageDomainDynamicDao().update(domainToUpdate.getStorageDynamicData());
            getCompensationContext().stateChanged();
        }
        return null;
    });
}
#method_after
protected void updateStorageDomain(final List<StorageDomain> storageDomainsToUpdate) {
    executeInNewTransaction(() -> {
        for (StorageDomain domainToUpdate : storageDomainsToUpdate) {
            CompensationContext context = getCompensationContext();
            context.snapshotEntity(domainToUpdate.getStorageDynamicData());
            storageDomainDynamicDao.update(domainToUpdate.getStorageDynamicData());
            getCompensationContext().stateChanged();
        }
        return null;
    });
}
#end_block

#method_before
protected void updateStatus(StoragePoolIsoMap map, StorageDomainStatus status) {
    log.info("Setting domain '{}' to status '{}'", map.getId(), status.name());
    map.setStatus(status);
    getStoragePoolIsoMapDao().updateStatus(map.getId(), map.getStatus());
}
#method_after
protected void updateStatus(StoragePoolIsoMap map, StorageDomainStatus status) {
    log.info("Setting domain '{}' to status '{}'", map.getId(), status.name());
    map.setStatus(status);
    storagePoolIsoMapDao.updateStatus(map.getId(), map.getStatus());
}
#end_block

#method_before
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            int connectionId = client.getConnectionId();
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
            if (client.isClosed() && client.getConnectionId() == connectionId) {
                waitUntilCheck(client -> client.isClosed(), "Waiting on losing connection to {}", "Connection lost for {}");
            }
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#method_after
@SuppressWarnings("rawtypes")
@Override
public Future<Map<String, Object>> setupNetworks(Map networks, Map bonding, Map options, final boolean isPolicyReset) {
    final JsonRpcRequest request = new RequestBuilder("Host.setupNetworks").withParameter("networks", networks).withParameter("bondings", bonding).withParameter("options", options).build();
    final FutureCallable callable = new FutureCallable(() -> {
        if (isPolicyReset) {
            updateHeartbeatPolicy(client.getClientRetryPolicy().clone(), false);
        }
        return new FutureMap(client, request).withResponseKey("status");
    });
    FutureTask<Map<String, Object>> future = new FutureTask<Map<String, Object>>(callable) {

        @Override
        public boolean isDone() {
            if (callable.isDone()) {
                if (isPolicyReset) {
                    updateHeartbeatPolicy(client.getClientRetryPolicy(), true);
                }
                return true;
            }
            return false;
        }
    };
    ThreadPoolUtil.execute(future);
    return future;
}
#end_block

#method_before
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(() -> {
            try {
                // migrate vms that its their default vds and failback
                // is on
                List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                if (!vmsToMigrate.isEmpty()) {
                    CommandContext ctx = new CommandContext(new EngineContext());
                    ctx.getExecutionContext().setMonitored(true);
                    backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds)), ctx);
                }
            } catch (RuntimeException e) {
                log.error("Failed to initialize Vds on up: {}", e.getMessage());
                log.error("Exception", e);
            }
        });
    }
    return isSucceeded;
}
#method_after
@Override
public boolean vdsUpEvent(final VDS vds) {
    HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(vds);
    boolean isSucceeded = backend.runInternalAction(VdcActionType.InitVdsOnUp, params).getSucceeded();
    if (isSucceeded) {
        ThreadPoolUtil.execute(() -> {
            try {
                // migrate vms that its their default vds and failback
                // is on
                List<VmStatic> vmsToMigrate = DbFacade.getInstance().getVmStaticDao().getAllWithFailbackByVds(vds.getId());
                if (!vmsToMigrate.isEmpty()) {
                    CommandContext ctx = new CommandContext(new EngineContext());
                    ctx.getExecutionContext().setMonitored(true);
                    backend.runInternalMultipleActions(VdcActionType.MigrateVmToServer, new ArrayList<>(createMigrateVmToServerParametersList(vmsToMigrate, vds, null)), ctx);
                }
            } catch (RuntimeException e) {
                log.error("Failed to initialize Vds on up: {}", e.getMessage());
                log.error("Exception", e);
            }
        });
    }
    return isSucceeded;
}
#end_block

#method_before
private List<VdcActionParametersBase> createMigrateVmToServerParametersList(List<VmStatic> vmsToMigrate, final VDS vds) {
    return vmsToMigrate.stream().map(vm -> {
        MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId(), MigrationReason.PREFERRED_HOST_UP);
        parameters.setShouldBeLogged(false);
        return parameters;
    }).collect(Collectors.toList());
}
#method_after
private List<VdcActionParametersBase> createMigrateVmToServerParametersList(List<VmStatic> vmsToMigrate, final VDS vds, String reason) {
    return vmsToMigrate.stream().map(vm -> {
        MigrateVmToServerParameters parameters = new MigrateVmToServerParameters(false, vm.getId(), vds.getId());
        parameters.setReason(reason);
        parameters.setShouldBeLogged(false);
        return parameters;
    }).collect(Collectors.toList());
}
#end_block

#method_before
@Override
public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate, MigrationReason reason) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate, reason);
    parameters.setInitialHosts(new ArrayList<>(initialHosts));
    backendInternal.runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
}
#method_after
@Override
public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate, String reason) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
    parameters.setInitialHosts(new ArrayList<>(initialHosts));
    parameters.setReason(reason);
    backendInternal.runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
protected void migrateVM(final VM vmToMigrate) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate.getId(), MigrationReason.AFFINITY_ENFORCEMENT);
    backend.runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
}
#method_after
protected void migrateVM(final VM vmToMigrate) {
    MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate.getId());
    parameters.setReason(AuditLogDirector.getMessage(AuditLogType.MIGRATION_REASON_AFFINITY_ENFORCEMENT));
    backend.runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
}
#end_block

#method_before
@OnTimerMethodAnnotation("performLoadBalancing")
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<Cluster> clusters = getClusterDao().getAll();
    for (Cluster cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Optional<BalanceResult> balanceResult = Optional.empty();
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDao().getAllForClusterWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult.isPresent() && balanceResult.get().isValid()) {
            migrationHandler.migrateVM(balanceResult.get().getCandidateHosts(), balanceResult.get().getVmToMigrate(), MigrationReason.LOAD_BALANCING);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("performLoadBalancing")
public void performLoadBalancing() {
    log.debug("Load Balancer timer entered.");
    List<Cluster> clusters = getClusterDao().getAll();
    for (Cluster cluster : clusters) {
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        PolicyUnitImpl policyUnit = policyUnits.get(policy.getBalance());
        Optional<BalanceResult> balanceResult = Optional.empty();
        if (policyUnit.getPolicyUnit().isEnabled()) {
            List<VDS> hosts = getVdsDao().getAllForClusterWithoutMigrating(cluster.getId());
            if (policyUnit.getPolicyUnit().isInternal()) {
                balanceResult = internalRunBalance(policyUnit, cluster, hosts);
            } else if (Config.<Boolean>getValue(ConfigValues.ExternalSchedulerEnabled)) {
                balanceResult = externalRunBalance(policyUnit, cluster, hosts);
            }
        }
        if (balanceResult.isPresent() && balanceResult.get().isValid()) {
            migrationHandler.migrateVM(balanceResult.get().getCandidateHosts(), balanceResult.get().getVmToMigrate(), AuditLogDirector.getMessage(AuditLogType.MIGRATION_REASON_LOAD_BALANCING));
        }
    }
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        autoConverge = effectiveMigrationPolicy.isAutoConvergence();
        migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    Map<String, Object> convergenceSchedule = null;
    Integer maxBandwidth = null;
    Boolean autoConverge = getAutoConverge();
    Boolean migrateCompressed = getMigrateCompressed();
    Boolean enableGuestEvents = null;
    if (FeatureSupported.migrationPoliciesSupported(getVm().getCompatibilityVersion())) {
        MigrationPolicy clusterMigrationPolicy = convergenceConfigProvider.getMigrationPolicy(getCluster().getMigrationPolicyId());
        MigrationPolicy effectiveMigrationPolicy = findEffectiveConvergenceConfig(clusterMigrationPolicy);
        convergenceSchedule = ConvergenceSchedule.from(effectiveMigrationPolicy.getConfig()).asMap();
        maxBandwidth = getMaxBandwidth(clusterMigrationPolicy);
        if (!NoMigrationPolicy.ID.equals(effectiveMigrationPolicy.getId())) {
            autoConverge = effectiveMigrationPolicy.isAutoConvergence();
            migrateCompressed = effectiveMigrationPolicy.isMigrationCompression();
        }
        enableGuestEvents = effectiveMigrationPolicy.isEnableGuestEvents();
    }
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, getDestinationVdsId(), dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getClusterCompatibilityVersion(), getMaximumMigrationDowntime(), autoConverge, migrateCompressed, getDestinationVds().getConsoleAddress(), maxBandwidth, convergenceSchedule, enableGuestEvents);
}
#end_block

#method_before
private AuditLogType getAuditLogForMigrationStarted() {
    return isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START;
}
#method_after
private AuditLogType getAuditLogForMigrationStarted() {
    addCustomValue("OptionalReason", getParameters().getReason());
    return isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START;
}
#end_block

#method_before
protected boolean migrateVm(VM vm, ExecutionContext parentContext) {
    return runInternalAction(VdcActionType.InternalMigrateVm, new InternalMigrateVmParameters(vm.getId(), getActionType(), MigrationReason.HOST_IN_MAINTENANCE), createMigrateVmContext(parentContext, vm)).getSucceeded();
}
#method_after
protected boolean migrateVm(VM vm, ExecutionContext parentContext) {
    InternalMigrateVmParameters parameters = new InternalMigrateVmParameters(vm.getId(), getActionType());
    parameters.setReason(AuditLogDirector.getMessage(AuditLogType.MIGRATION_REASON_HOST_IN_MAINTENANCE));
    return runInternalAction(VdcActionType.InternalMigrateVm, parameters, createMigrateVmContext(parentContext, vm)).getSucceeded();
}
#end_block

#method_before
@Override
public int hashCode() {
    return Objects.hash(getVmId(), forceMigrationForNonMigratableVm, targetClusterId, migrationReason);
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(getVmId(), forceMigrationForNonMigratableVm, targetClusterId, reason);
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof MigrateVmParameters)) {
        return false;
    }
    MigrateVmParameters other = (MigrateVmParameters) obj;
    return Objects.equals(getVmId(), other.getVmId()) && forceMigrationForNonMigratableVm == other.forceMigrationForNonMigratableVm && Objects.equals(targetClusterId, other.targetClusterId) && Objects.equals(migrationReason, other.migrationReason);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof MigrateVmParameters)) {
        return false;
    }
    MigrateVmParameters other = (MigrateVmParameters) obj;
    return Objects.equals(getVmId(), other.getVmId()) && forceMigrationForNonMigratableVm == other.forceMigrationForNonMigratableVm && Objects.equals(targetClusterId, other.targetClusterId) && Objects.equals(reason, other.reason);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Cluster cluster = getCluster();
    boolean initSucceeded = true;
    initHostKdumpDetectionStatus();
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    DbFacade.getInstance().getVdsDynamicDao().updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (cluster.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && cluster.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && cluster.supportsGlusterService()) {
        initSucceeded = glusterCommandHelper.initGlusterHost(getVds());
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("HostStatus", getVds().getStatus().toString());
        auditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#method_after
@Override
protected void executeCommand() {
    Cluster cluster = getCluster();
    boolean initSucceeded = true;
    initHostKdumpDetectionStatus();
    /* Host is UP, re-set the policy controlled power management flag */
    getVds().setPowerManagementControlledByPolicy(true);
    vdsDynamicDao.updateVdsDynamicPowerManagementPolicyFlag(getVds().getId(), getVds().isPowerManagementControlledByPolicy());
    if (cluster.supportsTrustedService()) {
        initSucceeded = initTrustedService();
    }
    if (initSucceeded && cluster.supportsVirtService()) {
        initSucceeded = initVirtResources();
    }
    if (initSucceeded && cluster.supportsGlusterService()) {
        initSucceeded = glusterCommandHelper.initGlusterHost(getVds());
    }
    setSucceeded(initSucceeded);
    if (getSucceeded()) {
        AuditLogableBase logable = new AuditLogableBase(getVds().getId());
        logable.addCustomValue("HostStatus", getVds().getStatus().toString());
        auditLogDirector.log(logable, AuditLogType.VDS_DETECTED);
    }
}
#end_block

#method_before
private void processStoragePoolStatus() {
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getVds().getStoragePoolId());
        if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
            pool.setStatus(StoragePoolStatus.NonResponsive);
            DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), pool.getStatus());
            StoragePoolStatusHandler.poolStatusChanged(pool.getId(), pool.getStatus());
        }
    }
}
#method_after
private void processStoragePoolStatus() {
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        StoragePool pool = storagePoolDao.get(getVds().getStoragePoolId());
        if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
            pool.setStatus(StoragePoolStatus.NonResponsive);
            storagePoolDao.updateStatus(pool.getId(), pool.getStatus());
            StoragePoolStatusHandler.poolStatusChanged(pool.getId(), pool.getStatus());
        }
    }
}
#end_block

#method_before
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = getStoragePoolDao().get(storagePoolId);
    StorageDomain masterDomain = getStorageDomainDao().getStorageDomains(storagePoolId, StorageDomainType.Master).get(0);
    List<StoragePoolIsoMap> storagePoolIsoMap = getStoragePoolIsoMapDao().getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (EngineException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != EngineError.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.info("Could not connect host '{}' to pool '{}', as the master domain is in inactive/unknown" + " status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.error("Could not connect host '{}' to pool '{}': {}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown, storagePool);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#method_after
private EventResult runConnectHostToPoolEvent(final Guid storagePoolId, final VDS vds) {
    EventResult result = new EventResult(true, EventType.VDSCONNECTTOPOOL);
    StoragePool storagePool = storagePoolDao.get(storagePoolId);
    StorageDomain masterDomain = storageDomainDao.getStorageDomains(storagePoolId, StorageDomainType.Master).get(0);
    List<StoragePoolIsoMap> storagePoolIsoMap = storagePoolIsoMapDao.getAllForStoragePool(storagePoolId);
    boolean masterDomainInactiveOrUnknown = masterDomain.getStatus() == StorageDomainStatus.Inactive || masterDomain.getStatus() == StorageDomainStatus.Unknown;
    VDSError error = null;
    try {
        VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(vds, storagePool, masterDomain.getId(), storagePoolIsoMap));
        if (!vdsReturnValue.getSucceeded()) {
            error = vdsReturnValue.getVdsError();
        }
    } catch (EngineException e) {
        error = e.getVdsError();
    }
    if (error != null) {
        if (error.getCode() != EngineError.CannotConnectMultiplePools && masterDomainInactiveOrUnknown) {
            log.info("Could not connect host '{}' to pool '{}', as the master domain is in inactive/unknown" + " status - not failing the operation", vds.getName(), storagePool.getName());
        } else {
            log.error("Could not connect host '{}' to pool '{}': {}", vds.getName(), storagePool.getName(), error.getMessage());
            result.setSuccess(false);
        }
    }
    if (result.isSuccess()) {
        Pair<Boolean, List<StorageDomainStatic>> vdsStatsResults = proceedVdsStats(!masterDomainInactiveOrUnknown, storagePool);
        result.setSuccess(vdsStatsResults.getFirst());
        if (!result.isSuccess()) {
            result.setResultData(vdsStatsResults.getSecond());
            auditLogDirector.log(new AuditLogableBase(getVdsId()), AuditLogType.VDS_STORAGE_VDS_STATS_FAILED);
        }
    }
    return result;
}
#end_block

#method_before
private Pair<Boolean, List<StorageDomainStatic>> proceedVdsStats(boolean shouldCheckReportedDomains, StoragePool storagePool) {
    Pair<Boolean, List<StorageDomainStatic>> returnValue = new Pair<>(true, null);
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        if (shouldCheckReportedDomains) {
            List<Guid> problematicDomainsIds = fetchDomainsReportedAsProblematic(getVds().getDomains(), storagePool);
            for (Guid domainId : problematicDomainsIds) {
                StorageDomainStatic domainInfo = getStorageDomainStaticDao().get(domainId);
                log.error("Storage Domain '{}' of pool '{}' is in problem in host '{}'", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
                if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                    returnValue.setFirst(false);
                    if (returnValue.getSecond() == null) {
                        returnValue.setSecond(new ArrayList<>());
                    }
                    returnValue.getSecond().add(domainInfo);
                }
            }
        }
    } catch (EngineException e) {
        log.error("Could not get Host statistics for Host '{}': {}", getVds().getName(), e.getMessage());
        log.debug("Exception", e);
        returnValue.setFirst(false);
    }
    return returnValue;
}
#method_after
private Pair<Boolean, List<StorageDomainStatic>> proceedVdsStats(boolean shouldCheckReportedDomains, StoragePool storagePool) {
    Pair<Boolean, List<StorageDomainStatic>> returnValue = new Pair<>(true, null);
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        if (shouldCheckReportedDomains) {
            List<Guid> problematicDomainsIds = fetchDomainsReportedAsProblematic(getVds().getDomains(), storagePool);
            for (Guid domainId : problematicDomainsIds) {
                StorageDomainStatic domainInfo = storageDomainStaticDao.get(domainId);
                log.error("Storage Domain '{}' of pool '{}' is in problem in host '{}'", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
                if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                    returnValue.setFirst(false);
                    if (returnValue.getSecond() == null) {
                        returnValue.setSecond(new ArrayList<>());
                    }
                    returnValue.getSecond().add(domainInfo);
                }
            }
        }
    } catch (EngineException e) {
        log.error("Could not get Host statistics for Host '{}': {}", getVds().getName(), e.getMessage());
        log.debug("Exception", e);
        returnValue.setFirst(false);
    }
    return returnValue;
}
#end_block

#method_before
private void initHostKdumpDetectionStatus() {
    // host is UP, remove kdump status
    getDbFacade().getVdsKdumpStatusDao().remove(getVdsId());
    if (getVds().isPmEnabled() && getVds().isPmKdumpDetection() && getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        auditLogDirector.log(base, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
    }
}
#method_after
private void initHostKdumpDetectionStatus() {
    // host is UP, remove kdump status
    vdsKdumpStatusDao.remove(getVdsId());
    if (getVds().isPmEnabled() && getVds().isPmKdumpDetection() && getVds().getKdumpStatus() != KdumpStatus.ENABLED) {
        AuditLogableBase base = new AuditLogableBase();
        base.setVds(getVds());
        auditLogDirector.log(base, AuditLogType.KDUMP_DETECTION_NOT_CONFIGURED_ON_VDS);
    }
}
#end_block

#method_before
@Before
public void setup() {
    map = new StoragePoolIsoMap();
    cmd.init();
    doReturn(eventQueue).when(cmd).getEventQueue();
}
#method_after
@Before
public void setup() {
    map = new StoragePoolIsoMap();
    cmd.init();
}
#end_block

#method_before
@Before
public void setUp() {
    mockVds();
    mockVmDevice(false);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
    doReturn(vmNetworkInterfaceDao).when(command).getVmNetworkInterfaceDao();
    doReturn(new ArrayList<>()).when(diskVmElementDao).getAllForVm(vmId);
    doReturn(diskValidator).when(command).getDiskValidator(disk);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(vm);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<>(DISK_HOTPLUGGABLE_INTERFACES));
}
#method_after
@Before
public void setUp() {
    mockVds();
    mockVmDevice(false);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
    doReturn(vmNetworkInterfaceDao).when(command).getVmNetworkInterfaceDao();
    doReturn(new ArrayList<>()).when(diskVmElementDao).getAllForVm(vmId);
    doReturn(diskValidator).when(command).getDiskValidator(disk);
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(vm);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<>(DISK_HOTPLUGGABLE_INTERFACES));
    SimpleDependencyInjector.getInstance().bind(VmDeviceUtils.class, vmDeviceUtils);
}
#end_block

#method_before
@Test
public void validateFailedDiskInterfaceUnsupported() {
    mockVmStatusUp();
    createVirtIODisk();
    initStorageDomain();
    when(diskValidator.isDiskInterfaceSupported(any(VM.class), any(DiskVmElement.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED);
}
#method_after
@Test
public void validateFailedDiskInterfaceUnsupported() {
    mockVmStatusUp();
    createVirtIODisk();
    initStorageDomain();
    when(diskVmElementValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED);
}
#end_block

#method_before
protected VmDiskOperationParameterBase createParameters() {
    return new VmDiskOperationParameterBase(new DiskVmElement(diskImageGuid, vmId));
}
#method_after
protected VmDiskOperationParameterBase createParameters() {
    return new VmDiskOperationParameterBase(diskVmElement);
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand();
    mockVdsCommandSetVolumeDescription();
    DiskVmElement dve = new DiskVmElement(diskImageGuid, vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    doReturn(dve).when(command).getOldDiskVmElement();
    doReturn(createDiskImage()).when(command).getOldDisk();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class), any(DiskVmElement.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(command.getParameters().getDiskInfo())).thenReturn(diskValidator);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED);
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    command.getParameters().getDiskVmElement().setDiskInterface(DiskInterface.IDE);
    initializeCommand();
    mockVdsCommandSetVolumeDescription();
    DiskVmElement dve = new DiskVmElement(diskImageGuid, vmId);
    dve.setDiskInterface(DiskInterface.VirtIO);
    doReturn(dve).when(command).getOldDiskVmElement();
    doReturn(createDiskImage()).when(command).getOldDisk();
    when(diskVmElementValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskVmElementValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(command.getDiskValidator(command.getParameters().getDiskInfo())).thenReturn(diskValidator);
    ValidateTestUtils.runAndAssertValidateFailure(command, EngineMessage.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED);
}
#end_block

#method_before
@Test
public void testFailInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    assertFalse(command.validateCanUpdateReadOnly(diskValidator));
}
#method_after
@Test
public void testFailInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(new ValidationResult(EngineMessage.ACTION_TYPE_FAILED_INTERFACE_DOES_NOT_SUPPORT_READ_ONLY_ATTR)).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    assertFalse(command.validateCanUpdateReadOnly());
}
#end_block

#method_before
@Test
public void testSucceedInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    assertTrue(command.validateCanUpdateReadOnly(diskValidator));
}
#method_after
@Test
public void testSucceedInterfaceCanUpdateReadOnly() {
    initializeCommand();
    doReturn(true).when(command).updateReadOnlyRequested();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    assertTrue(command.validateCanUpdateReadOnly());
}
#end_block

#method_before
protected void initializeCommand(VM vm) {
    mockGetForDisk(vm);
    mockGetVmsListForDisk(vm);
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskValidator.isVirtIoScsiValid(any(VM.class), any(DiskVmElement.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskValidator).isReadOnlyPropertyCompatibleWithInterface(any(DiskVmElement.class));
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vm);
    mockToUpdateDiskVm(vm);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#method_after
protected void initializeCommand(VM vm) {
    mockGetForDisk(vm);
    mockGetVmsListForDisk(vm);
    doNothing().when(command).reloadDisks();
    doNothing().when(command).updateBootOrder();
    doReturn(quotaManager).when(command).getQuotaManager();
    doAnswer(invocation -> invocation.getArguments()[0] != null ? invocation.getArguments()[0] : Guid.newGuid()).when(quotaManager).getDefaultQuotaIfNull(any(Guid.class), any(Guid.class));
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    when(diskVmElementValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskUsedAsOvfStore()).thenReturn(ValidationResult.VALID);
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskAttachedToVm(any(VM.class));
    doReturn(ValidationResult.VALID).when(diskValidator).isDiskExists();
    doReturn(ValidationResult.VALID).when(diskValidator).validateNotHostedEngineDisk();
    doReturn(ValidationResult.VALID).when(diskVmElementValidator).isReadOnlyPropertyCompatibleWithInterface();
    doReturn(diskValidator).when(command).getDiskValidator(any(Disk.class));
    doReturn(diskVmElementValidator).when(command).getDiskVmElementValidator(any(Disk.class), any(DiskVmElement.class));
    doReturn(true).when(command).setAndValidateDiskProfiles();
    doReturn(true).when(command).validateQuota();
    SimpleDependencyInjector.getInstance().bind(OsRepository.class, osRepository);
    mockVds();
    mockVmsStoragePoolInfo(vm);
    mockToUpdateDiskVm(vm);
    StorageDomain sd = new StorageDomain();
    sd.setAvailableDiskSize(Integer.MAX_VALUE);
    sd.setStatus(StorageDomainStatus.Active);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(sd);
    StorageDomainValidator sdValidator = new StorageDomainValidator(sd);
    doReturn(sdValidator).when(command).getStorageDomainValidator(any(DiskImage.class));
    command.init();
}
#end_block

#method_before
private void mockVmDevice(VmDevice vmDevice) {
    when(vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), vmDevice.getType())).thenReturn(Collections.singletonList(vmDevice));
    doReturn(vmDeviceDao).when(dbFacade).getVmDeviceDao();
}
#method_after
private void mockVmDevice(VmDevice vmDevice) {
    when(vmDeviceDao.getVmDeviceByVmIdAndType(vm.getId(), vmDevice.getType())).thenReturn(Collections.singletonList(vmDevice));
}
#end_block

#method_before
@Override
protected boolean validate() {
    boolean retValue = true;
    if (getParameters().getParentCommand() == VdcActionType.Unknown) {
        retValue = super.validate();
        if (getVds() != null && getVds().getStatus() != VDSStatus.Maintenance) {
            addValidationMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_STOP);
            retValue = false;
        }
    }
    getReturnValue().setValid(retValue);
    return retValue;
}
#method_after
@Override
protected boolean validate() {
    boolean retValue = true;
    if (!isExecutedAsChildCommand()) {
        retValue = super.validate();
        if (getVds() != null && getVds().getStatus() != VDSStatus.Maintenance) {
            addValidationMessage(EngineMessage.VDS_STATUS_NOT_VALID_FOR_STOP);
            retValue = false;
        }
    }
    getReturnValue().setValid(retValue);
    return retValue;
}
#end_block

#method_before
private void createCommand(final Cluster group) {
    setValidCpuVersionMap();
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(cpuFlagsManagerHandler).when(cmd).getCpuFlagsManagerHandler();
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(defaultManagementNetworkFinder).when(cmd).getDefaultManagementNetworkFinder();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(schedulingManager).when(cmd).getSchedulingManager();
    doReturn(vmNumaNodeDao).when(cmd).getVmNumaNodeDao();
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterIdAsMap(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#method_after
private void createCommand(final Cluster group) {
    setValidCpuVersionMap();
    cmd.getParameters().setManagementNetworkId(managementNetworkId);
    cmd.getParameters().setCluster(group);
    cmd.setClusterId(group.getId());
    doReturn(0).when(cmd).compareCpuLevels(any(Cluster.class));
    doReturn(dbFacadeMock).when(cmd).getDbFacade();
    doReturn(clusterDao).when(dbFacadeMock).getClusterDao();
    doReturn(storagePoolDao).when(dbFacadeMock).getStoragePoolDao();
    doReturn(networkDao).when(cmd).getNetworkDao();
    doReturn(clusterFeatureDao).when(cmd).getClusterFeatureDao();
    doReturn(hostFeatureDao).when(cmd).getHostFeatureDao();
    doReturn(networkClusterValidator).when(cmd).createManagementNetworkClusterValidator();
    doReturn(true).when(cmd).isSupportedEmulatedMachinesMatchClusterLevel(any(VDS.class));
    // cluster upgrade
    doReturn(vmNumaNodeDao).when(cmd).getVmNumaNodeDao();
    doReturn(inClusterUpgradeValidator).when(cmd).getUpgradeValidator();
    doReturn(new ClusterPolicy()).when(schedulingManager).getClusterPolicy(any(Guid.class));
    final ClusterPolicy clusterPolicy = new ClusterPolicy();
    clusterPolicy.setId(ClusterPolicy.UPGRADE_POLICY_GUID);
    doReturn(clusterPolicy).when(schedulingManager).getClusterPolicy(eq(ClusterPolicy.UPGRADE_POLICY_GUID));
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradeDone(anyList());
    doReturn(ValidationResult.VALID).when(inClusterUpgradeValidator).isUpgradePossible(anyList(), anyList());
    doReturn(new HashMap<Guid, List<VmNumaNode>>()).when(vmNumaNodeDao).getVmNumaNodeInfoByClusterIdAsMap(any(Guid.class));
    if (StringUtils.isEmpty(group.getCpuName())) {
        doReturn(ArchitectureType.undefined).when(cmd).getArchitecture();
    } else {
        doReturn(ArchitectureType.x86_64).when(cmd).getArchitecture();
    }
    when(clusterDao.get(any(Guid.class))).thenReturn(createDefaultCluster());
    when(clusterDao.getByName(anyString())).thenReturn(createDefaultCluster());
    List<Cluster> clusterList = new ArrayList<>();
    clusterList.add(createDefaultCluster());
    when(clusterDao.getByName(anyString(), anyBoolean())).thenReturn(clusterList);
}
#end_block

#method_before
@Test
public void statusSetInMap() {
    Guid storageDomainId = cmd.getStorageDomainId();
    Guid poolId = cmd.getStoragePoolId();
    cmd.init();
    doNothing().when(cmd).attemptToActivateDomain();
    doReturn(Collections.emptyList()).when(cmd).connectHostsInUpToDomainStorageServer();
    doReturn(vdsBrokerFrontend).when(cmd).getVdsBroker();
    StoragePool pool = new StoragePool();
    pool.setId(poolId);
    pool.setStatus(StoragePoolStatus.Up);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(pool);
    when(isoMapDao.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    when(diskImageDao.getAllForStorageDomain(any(Guid.class))).thenReturn(Collections.emptyList());
    when(storageDomainStaticDao.get(any(Guid.class))).thenReturn(new StorageDomainStatic());
    doReturn(pool.getId()).when(cmd).getStoragePoolIdFromVds();
    doReturn(backendInternal).when(cmd).getBackend();
    VdcReturnValueBase vdcReturnValue = new VdcReturnValueBase();
    vdcReturnValue.setSucceeded(true);
    when(backendInternal.runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class))).thenReturn(vdcReturnValue);
    StorageDomainStatic storageDomain = new StorageDomainStatic();
    storageDomain.setId(Guid.newGuid());
    storageDomain.setStorageDomainType(StorageDomainType.ImportExport);
    mockGetStorageDomainInfoVdsCommand(storageDomain);
    mockAttachStorageDomainVdsCommand();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(Collections.emptyList()).when(cmd).getEntitiesFromStorageOvfDisk(storageDomainId, pool.getId());
    doReturn(Collections.emptyList()).when(cmd).getAllOVFDisks(storageDomainId, pool.getId());
    doAnswer(invocation -> {
        map = (StoragePoolIsoMap) invocation.getArguments()[0];
        return null;
    }).when(isoMapDao).save(any(StoragePoolIsoMap.class));
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertNotNull(map);
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#method_after
@Test
public void statusSetInMap() {
    cmd.init();
    Guid storageDomainId = cmd.getStorageDomainId();
    Guid poolId = cmd.getStoragePoolId();
    doNothing().when(cmd).attemptToActivateDomain();
    doReturn(Collections.emptyList()).when(cmd).connectHostsInUpToDomainStorageServer();
    StoragePool pool = new StoragePool();
    pool.setId(poolId);
    pool.setStatus(StoragePoolStatus.Up);
    when(storagePoolDao.get(any(Guid.class))).thenReturn(pool);
    when(isoMapDao.get(any(StoragePoolIsoMapId.class))).thenReturn(map);
    when(storageDomainDao.getForStoragePool(any(Guid.class), any(Guid.class))).thenReturn(new StorageDomain());
    when(diskImageDao.getAllForStorageDomain(any(Guid.class))).thenReturn(Collections.emptyList());
    when(storageDomainStaticDao.get(any(Guid.class))).thenReturn(new StorageDomainStatic());
    doReturn(pool.getId()).when(cmd).getStoragePoolIdFromVds();
    VdcReturnValueBase vdcReturnValue = new VdcReturnValueBase();
    vdcReturnValue.setSucceeded(true);
    when(backendInternal.runInternalAction(any(VdcActionType.class), any(VdcActionParametersBase.class), any(CommandContext.class))).thenReturn(vdcReturnValue);
    StorageDomainStatic storageDomain = new StorageDomainStatic();
    storageDomain.setId(Guid.newGuid());
    storageDomain.setStorageDomainType(StorageDomainType.ImportExport);
    mockGetStorageDomainInfoVdsCommand(storageDomain);
    mockAttachStorageDomainVdsCommand();
    when(vdsDao.get(any(Guid.class))).thenReturn(vds);
    doReturn(Collections.emptyList()).when(cmd).getEntitiesFromStorageOvfDisk(storageDomainId, pool.getId());
    doReturn(Collections.emptyList()).when(cmd).getAllOVFDisks(storageDomainId, pool.getId());
    doAnswer(invocation -> {
        map = (StoragePoolIsoMap) invocation.getArguments()[0];
        return null;
    }).when(isoMapDao).save(any(StoragePoolIsoMap.class));
    cmd.setCompensationContext(mock(CompensationContext.class));
    cmd.executeCommand();
    assertNotNull(map);
    assertEquals(StorageDomainStatus.Maintenance, map.getStatus());
}
#end_block

#method_before
@Before
public void setUp() {
    Guid vmId = Guid.newGuid();
    Guid poolId = Guid.newGuid();
    Guid storageDomainId = Guid.newGuid();
    Guid vdsId = Guid.newGuid();
    disk = new DiskImage();
    disk.setId(diskId);
    disk.setVmEntityType(VmEntityType.VM);
    disk.setImageStatus(ImageStatus.OK);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
    vm = new VM();
    vm.setId(vmId);
    vm.setStatus(VMStatus.Down);
    vm.setStoragePoolId(poolId);
    vm.setClusterId(groupId);
    VmDeviceId vmDeviceId = new VmDeviceId(diskId, vmId);
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    Cluster cluster = new Cluster();
    cluster.setId(groupId);
    VDS vds = new VDS();
    vds.setId(vdsId);
    storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    storageDomain = new StorageDomain();
    storageDomain.setStorageType(StorageType.ISCSI);
    when(vmDao.getVmsListForDisk(diskId, Boolean.FALSE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    when(vdsDao.getAllForClusterWithStatus(groupId, VDSStatus.Up)).thenReturn(Collections.singletonList(vds));
    when(spDao.get(poolId)).thenReturn(storagePool);
    when(clusterDao.get(groupId)).thenReturn(cluster);
    when(storageDomainStaticDao.get(storageDomainId)).thenReturn(storageDomain.getStorageStaticData());
    doReturn(disk).when(cmd).getDisk();
}
#method_after
@Before
public void setUp() {
    Guid vmId = Guid.newGuid();
    Guid poolId = Guid.newGuid();
    Guid storageDomainId = Guid.newGuid();
    groupId = Guid.newGuid();
    Guid vdsId = Guid.newGuid();
    disk = new DiskImage();
    disk.setId(diskId);
    disk.setVmEntityType(VmEntityType.VM);
    disk.setImageStatus(ImageStatus.OK);
    disk.setStorageIds(new ArrayList<>(Collections.singletonList(storageDomainId)));
    vm = new VM();
    vm.setId(vmId);
    vm.setStatus(VMStatus.Down);
    vm.setStoragePoolId(poolId);
    vm.setClusterId(groupId);
    VmDeviceId vmDeviceId = new VmDeviceId(diskId, vmId);
    VmDevice vmDevice = new VmDevice();
    vmDevice.setId(vmDeviceId);
    Cluster cluster = new Cluster();
    cluster.setId(groupId);
    VDS vds = new VDS();
    vds.setId(vdsId);
    storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    storageDomain = new StorageDomain();
    storageDomain.setStorageType(StorageType.ISCSI);
    when(vmDao.getVmsListForDisk(diskId, Boolean.FALSE)).thenReturn(Collections.singletonList(vm));
    when(vmDeviceDao.get(vmDeviceId)).thenReturn(vmDevice);
    when(vdsDao.getAllForClusterWithStatus(groupId, VDSStatus.Up)).thenReturn(Collections.singletonList(vds));
    when(spDao.get(poolId)).thenReturn(storagePool);
    when(clusterDao.get(groupId)).thenReturn(cluster);
    when(storageDomainStaticDao.get(storageDomainId)).thenReturn(storageDomain.getStorageStaticData());
    doReturn(disk).when(cmd).getDisk();
}
#end_block

