176
#method_before
@Override
public void getThemeContent(Theme theme, OverlayThemeInfo info) throws RemoteException {
    PackageManager pm = getPackageManager();
    if (pm != null) {
        ThemePrefs prefs = getThemePrefs(theme.packageName + "_prefs");
        try {
            Context themeContext = getBaseContext().createPackageContext(theme.packageName, 0);
            String[] olays = themeContext.getAssets().list("overlays");
            if (olays.length > 0) {
                info.groups.put(OverlayGroup.OVERLAYS, getOverlays(themeContext, olays, prefs));
            }
            // TODO: handle font overlays
            // String[] fonts = themeContext.getAssets().list("fonts");
            String[] fonts = new String[0];
            if (fonts.length > 0) {
                OverlayGroup fontGroup = new OverlayGroup();
                for (String font : fonts) {
                    // cache font for further preview
                    File fontFile = new File(getCacheDir(), theme.packageName + "/fonts/" + font);
                    if (fontFile.exists()) {
                        fontFile.delete();
                    }
                    AssetUtils.copyAsset(themeContext.getAssets(), "fonts/" + font, fontFile.getAbsolutePath());
                    try {
                        Os.chmod(fontFile.getAbsolutePath(), 00777);
                        Os.chmod(fontFile.getParent(), 00777);
                        Os.chmod(fontFile.getParentFile().getParent(), 00777);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    Overlay fon = new Overlay(font, font, true);
                    fon.tag = fontFile.getAbsolutePath();
                    fontGroup.overlays.add(fon);
                }
                info.groups.put(OverlayGroup.FONTS, fontGroup);
            }
            String[] bootanis = themeContext.getAssets().list("bootanimation");
            if (bootanis.length > 0) {
                OverlayGroup bootanimations = new OverlayGroup();
                for (String bootani : bootanis) {
                    String bootName = bootani.substring(0, bootani.lastIndexOf("."));
                    // cache bootanimation for further preview
                    File bootanimFile = new File(getCacheDir(), theme.packageName + "/bootanimation/" + bootani);
                    if (bootanimFile.exists()) {
                        bootanimFile.delete();
                    }
                    parseBootanimation(themeContext, bootName, bootanimFile);
                    try {
                        Os.chmod(bootanimFile.getAbsolutePath(), 00777);
                        Os.chmod(bootanimFile.getParent(), 00777);
                        Os.chmod(bootanimFile.getParentFile().getParent(), 00777);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    Overlay bootanimation = new Overlay(bootName, OverlayGroup.BOOTANIMATIONS, true);
                    bootanimation.tag = bootanimFile.getAbsolutePath();
                    bootanimations.overlays.add(bootanimation);
                }
                info.groups.put(OverlayGroup.BOOTANIMATIONS, bootanimations);
            }
            ApplicationInfo aInfo = getPackageManager().getApplicationInfo(theme.packageName, PackageManager.GET_META_DATA);
            String wallpapersXmlUri = aInfo.metaData.getString("Substratum_Wallpapers");
            if (wallpapersXmlUri != null && isOnline()) {
                try {
                    OverlayGroup wallpapers = new OverlayGroup();
                    URL url = new URL(wallpapersXmlUri);
                    InputStream is = url.openStream();
                    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
                    XmlPullParser parser = factory.newPullParser();
                    parser.setInput(new InputStreamReader(is));
                    Overlay wallpaper = null;
                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
                        if (parser.getEventType() == XmlPullParser.START_TAG) {
                            if (parser.getName().equals("wallpaper")) {
                                String id = parser.getAttributeValue(null, "id");
                                wallpaper = new Overlay(id, id, true);
                            } else if (parser.getName().equals("link")) {
                                assert wallpaper != null;
                                wallpaper.tag = parser.nextText();
                            }
                        } else if (parser.getEventType() == XmlPullParser.END_TAG) {
                            if (parser.getName().equals("wallpaper")) {
                                assert wallpaper != null;
                                wallpapers.overlays.add(wallpaper);
                            }
                        }
                        parser.next();
                    }
                    is.close();
                    info.groups.put(OverlayGroup.WALLPAPERS, wallpapers);
                } catch (Exception ex) {
                    // something went wrong, no wallpapers for you
                    ex.printStackTrace();
                }
            }
            // Housekeeping: cleanup cache
            prefs.removeFile();
        } catch (PackageManager.NameNotFoundException | IOException e) {
            e.printStackTrace();
        }
    }
}
#method_after
@Override
public void getThemeContent(Theme theme, OverlayThemeInfo info) throws RemoteException {
    PackageManager pm = getPackageManager();
    if (pm != null) {
        ThemePrefs prefs = getThemePrefs(theme.packageName + "_prefs");
        try {
            Context themeContext = getBaseContext().createPackageContext(theme.packageName, 0);
            String[] olays = themeContext.getAssets().list("overlays");
            if (olays.length > 0) {
                info.groups.put(OverlayGroup.OVERLAYS, getOverlays(themeContext, olays, prefs));
            }
            // TODO: handle font overlays
            // String[] fonts = themeContext.getAssets().list("fonts");
            String[] fonts = new String[0];
            if (fonts.length > 0) {
                OverlayGroup fontGroup = new OverlayGroup();
                for (String font : fonts) {
                    // cache font for further preview
                    File fontFile = new File(getCacheDir(), theme.packageName + "/fonts/" + font);
                    if (fontFile.exists()) {
                        fontFile.delete();
                    }
                    AssetUtils.copyAsset(themeContext.getAssets(), "fonts/" + font, fontFile.getAbsolutePath());
                    try {
                        Os.chmod(fontFile.getAbsolutePath(), 00777);
                        Os.chmod(fontFile.getParent(), 00777);
                        Os.chmod(fontFile.getParentFile().getParent(), 00777);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    Overlay fon = new Overlay(font, font, true);
                    fon.tag = fontFile.getAbsolutePath();
                    fontGroup.overlays.add(fon);
                }
                info.groups.put(OverlayGroup.FONTS, fontGroup);
            }
            String[] bootanis = themeContext.getAssets().list("bootanimation");
            if (bootanis.length > 0) {
                OverlayGroup bootanimations = new OverlayGroup();
                for (String bootani : bootanis) {
                    String bootName = bootani.substring(0, bootani.lastIndexOf("."));
                    // cache bootanimation for further preview
                    File bootanimFile = new File(getCacheDir(), theme.packageName + "/bootanimation/" + bootani);
                    if (bootanimFile.exists()) {
                        bootanimFile.delete();
                    }
                    parseBootanimation(themeContext, bootName, bootanimFile);
                    try {
                        Os.chmod(bootanimFile.getAbsolutePath(), 00777);
                        Os.chmod(bootanimFile.getParent(), 00777);
                        Os.chmod(bootanimFile.getParentFile().getParent(), 00777);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    Overlay bootanimation = new Overlay(bootName, OverlayGroup.BOOTANIMATIONS, true);
                    bootanimation.tag = bootanimFile.getAbsolutePath();
                    bootanimations.overlays.add(bootanimation);
                }
                info.groups.put(OverlayGroup.BOOTANIMATIONS, bootanimations);
            }
            ApplicationInfo aInfo = getPackageManager().getApplicationInfo(theme.packageName, PackageManager.GET_META_DATA);
            String wallpapersXmlUri = aInfo.metaData.getString("Substratum_Wallpapers");
            if (wallpapersXmlUri != null && isOnline()) {
                try {
                    OverlayGroup wallpapers = new OverlayGroup();
                    URL url = new URL(wallpapersXmlUri);
                    InputStream is = url.openStream();
                    XmlPullParserFactory factory = XmlPullParserFactory.newInstance();
                    XmlPullParser parser = factory.newPullParser();
                    parser.setInput(new InputStreamReader(is));
                    Overlay wallpaper = null;
                    while (parser.getEventType() != XmlPullParser.END_DOCUMENT) {
                        if (parser.getEventType() == XmlPullParser.START_TAG) {
                            if (parser.getName().equals("wallpaper")) {
                                String id = parser.getAttributeValue(null, "id");
                                wallpaper = new Overlay(id, id, true);
                            } else if (parser.getName().equals("link")) {
                                assert wallpaper != null;
                                wallpaper.tag = parser.nextText();
                            }
                        } else if (parser.getEventType() == XmlPullParser.END_TAG) {
                            if (parser.getName().equals("wallpaper")) {
                                assert wallpaper != null;
                                wallpapers.overlays.add(wallpaper);
                            }
                        }
                        parser.next();
                    }
                    is.close();
                    info.groups.put(OverlayGroup.WALLPAPERS, wallpapers);
                } catch (Exception ex) {
                    // something went wrong, no wallpapers for you
                    ex.printStackTrace();
                }
            }
        } catch (PackageManager.NameNotFoundException | IOException e) {
            e.printStackTrace();
        }
    }
}
#end_block

#method_before
@SuppressLint("SetWorldReadable")
@Override
public boolean installOverlaysFromTheme(Theme theme, OverlayThemeInfo info) throws RemoteException {
    final int totalCount = info.getSelectedCount();
    if (totalCount == 0) {
        return false;
    }
    int index = 0;
    if (mPMUtils == null) {
        mPMUtils = new PackageManagerUtils(getBaseContext());
    }
    startWakeLock();
    try {
        notifyInstallProgress(totalCount, 0, null);
        File themeCache = setupCache(theme.packageName);
        Context themeContext = getBaseContext().createPackageContext(theme.packageName, 0);
        StringBuilder sb = new StringBuilder();
        // handle overlays first
        OverlayGroup overlays = info.groups.get(OverlayGroup.OVERLAYS);
        if (overlays != null) {
            ThemePrefs prefs = getThemePrefs(theme.packageName + "_prefs");
            if (!TextUtils.isEmpty(overlays.selectedStyle)) {
                Log.d(TAG, "selectedStyle=" + overlays.selectedStyle);
                prefs.putString("selectedStyle", overlays.selectedStyle);
            }
            // put system overlay to the end of the list
            // to prevent possible quirks
            Overlay systemOverlay = overlays.findByTargetPackage("android");
            if (systemOverlay != null) {
                overlays.overlays.remove(systemOverlay);
                overlays.overlays.add(systemOverlay);
            }
            for (Overlay overlay : overlays.overlays) {
                if (!overlay.checked)
                    continue;
                sb.setLength(0);
                sb.append("Installing overlay");
                sb.append(" name=" + overlay.overlayName);
                notifyInstallProgress(totalCount, ++index, overlay.overlayName);
                // check if installed and latest
                sb.append(", package=" + overlay.overlayPackage);
                sb.append(", newVersion=" + theme.themeVersion);
                try {
                    ApplicationInfo aInfo = getPackageManager().getApplicationInfo(overlay.overlayPackage, PackageManager.GET_META_DATA);
                    if (aInfo.metaData != null) {
                        String themeVersion = aInfo.metaData.getString("theme_version", "").replace("v=", "");
                        sb.append(", installedVersion=" + themeVersion);
                        if (TextUtils.equals(themeVersion, theme.themeVersion)) {
                            Log.d(TAG, sb.toString());
                            Log.d(TAG, "Skipped");
                            continue;
                        }
                    }
                } catch (PackageManager.NameNotFoundException e) {
                    sb.append(", installedVersion=null");
                }
                File overlayFolder = new File(themeCache, overlay.targetPackage);
                if (overlayFolder.exists()) {
                    deleteContents(overlayFolder);
                }
                AssetUtils.copyAssetFolder(themeContext.getAssets(), "overlays/" + overlay.targetPackage + "/res", overlayFolder.getAbsolutePath() + "/res");
                if (!TextUtils.isEmpty(overlays.selectedStyle)) {
                    AssetUtils.copyAssetFolder(themeContext.getAssets(), "overlays/" + overlay.targetPackage + "/" + overlays.selectedStyle, overlayFolder.getAbsolutePath() + "/res");
                }
                // handle type 2 overlay if non-default selected
                OverlayFlavor type2 = overlay.flavors.get("type2");
                if (type2 != null) {
                    sb.append(", type2=" + type2.selected);
                    AssetUtils.copyAssetFolder(themeContext.getAssets(), "overlays/" + overlay.targetPackage + "/" + type2.selected, overlayFolder.getAbsolutePath() + "/res");
                    prefs.putString(overlay.targetPackage, type2.selected);
                } else {
                    sb.append(", type2=null");
                }
                Log.d(TAG, sb.toString());
                sb.setLength(0);
                sb.append("Available flavors:");
                for (String flavor : overlay.flavors.keySet()) {
                    sb.append(" " + flavor);
                }
                Log.d(TAG, sb.toString());
                // handle type1 last
                handleExtractType1Flavor(themeContext, overlay, "type1a", overlayFolder, prefs);
                handleExtractType1Flavor(themeContext, overlay, "type1b", overlayFolder, prefs);
                handleExtractType1Flavor(themeContext, overlay, "type1c", overlayFolder, prefs);
                generateManifest(theme, overlay, overlayFolder.getAbsolutePath());
                if (!compileOverlay(theme, overlay, overlayFolder.getAbsolutePath())) {
                    continue;
                }
                installAndEnable(getCacheDir().getAbsolutePath() + "/" + theme.packageName + "/overlays/" + theme.packageName + "." + overlay.targetPackage + ".apk", theme.packageName + "." + overlay.targetPackage);
            }
            // Housekeeping: cleanup cache
            prefs.removeFile();
        }
        // now for the bootanimation
        overlays = info.groups.get(OverlayGroup.BOOTANIMATIONS);
        if (overlays != null) {
            final File bootanimBinary = new File(BOOTANIMATION_FILE);
            final File bootanimMetadata = new File(BOOTANIMATION_METADATA);
            final Gson gson = new GsonBuilder().create();
            for (Overlay overlay : overlays.overlays) {
                if (overlay.checked) {
                    notifyInstallProgress(totalCount, ++index, overlay.overlayName);
                    // cleaning up previous installation
                    if (bootanimBinary.exists()) {
                        bootanimBinary.delete();
                    }
                    if (bootanimMetadata.exists()) {
                        bootanimMetadata.delete();
                    }
                    // apply bootanimation
                    File bootAnimCache = new File(overlay.tag);
                    if (bootAnimCache.exists()) {
                        bootAnimCache.renameTo(bootanimBinary);
                    } else {
                        parseBootanimation(themeContext, overlay.overlayName, bootanimBinary);
                    }
                    // chmod 644
                    try {
                        Os.chmod(bootanimBinary.getAbsolutePath(), 00644);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    // save metadata
                    try {
                        final String json = gson.toJson(overlay);
                        FileUtils.writeStringToFile(bootanimMetadata, json, Charset.defaultCharset());
                        // chmod 644
                        Os.chmod(bootanimMetadata.getAbsolutePath(), 00644);
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                    break;
                }
            }
        }
        // mOverlayManager.refresh(UserHandle.USER_CURRENT);
        sendFinishedBroadcast();
        notifyInstallComplete();
        // Housekeeping: cleanup cache
        deleteContents(themeCache);
        return true;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    } finally {
        stopWakeLock();
    }
    return false;
}
#method_after
@SuppressLint("SetWorldReadable")
@Override
public boolean installOverlaysFromTheme(Theme theme, OverlayThemeInfo info) throws RemoteException {
    final int totalCount = info.getSelectedCount();
    if (totalCount == 0) {
        return false;
    }
    int index = 0;
    if (mPMUtils == null) {
        mPMUtils = new PackageManagerUtils(getBaseContext());
    }
    startWakeLock();
    try {
        notifyInstallProgress(totalCount, 0, null);
        File themeCache = setupCache(theme.packageName);
        Context themeContext = getBaseContext().createPackageContext(theme.packageName, 0);
        StringBuilder sb = new StringBuilder();
        // handle overlays first
        OverlayGroup overlays = info.groups.get(OverlayGroup.OVERLAYS);
        if (overlays != null) {
            ThemePrefs prefs = getThemePrefs(theme.packageName + "_prefs");
            if (!TextUtils.isEmpty(overlays.selectedStyle)) {
                Log.d(TAG, "selectedStyle=" + overlays.selectedStyle);
                prefs.putString("selectedStyle", overlays.selectedStyle);
            }
            // put system overlay to the end of the list
            // to prevent possible quirks
            Overlay systemOverlay = overlays.findByTargetPackage("android");
            if (systemOverlay != null) {
                overlays.overlays.remove(systemOverlay);
                overlays.overlays.add(systemOverlay);
            }
            for (Overlay overlay : overlays.overlays) {
                if (!overlay.checked)
                    continue;
                sb.setLength(0);
                sb.append("Installing overlay");
                sb.append(" name=" + overlay.overlayName);
                notifyInstallProgress(totalCount, ++index, overlay.overlayName);
                // check if installed and latest
                sb.append(", package=" + overlay.overlayPackage);
                sb.append(", newVersion=" + theme.themeVersion);
                try {
                    ApplicationInfo aInfo = getPackageManager().getApplicationInfo(overlay.overlayPackage, PackageManager.GET_META_DATA);
                    if (aInfo.metaData != null) {
                        String themeVersion = aInfo.metaData.getString("theme_version", "").replace("v=", "");
                        sb.append(", installedVersion=" + themeVersion);
                        if (TextUtils.equals(themeVersion, theme.themeVersion) && !checkStyles(overlay, prefs)) {
                            Log.d(TAG, sb.toString());
                            Log.d(TAG, "Skipped");
                            continue;
                        }
                    }
                } catch (PackageManager.NameNotFoundException e) {
                    sb.append(", installedVersion=null");
                }
                File overlayFolder = new File(themeCache, overlay.targetPackage);
                if (overlayFolder.exists()) {
                    deleteContents(overlayFolder);
                }
                AssetUtils.copyAssetFolder(themeContext.getAssets(), "overlays/" + overlay.targetPackage + "/res", overlayFolder.getAbsolutePath() + "/res");
                if (!TextUtils.isEmpty(overlays.selectedStyle)) {
                    AssetUtils.copyAssetFolder(themeContext.getAssets(), "overlays/" + overlay.targetPackage + "/" + overlays.selectedStyle, overlayFolder.getAbsolutePath() + "/res");
                }
                // handle type 2 overlay if non-default selected
                OverlayFlavor type2 = overlay.flavors.get("type2");
                if (type2 != null) {
                    sb.append(", type2=" + type2.selected);
                    AssetUtils.copyAssetFolder(themeContext.getAssets(), "overlays/" + overlay.targetPackage + "/" + type2.selected, overlayFolder.getAbsolutePath() + "/res");
                    prefs.putTypeSelection(overlay.targetPackage, "type2", type2.selected);
                } else {
                    sb.append(", type2=null");
                }
                Log.d(TAG, sb.toString());
                sb.setLength(0);
                sb.append("Available flavors:");
                for (String flavor : overlay.flavors.keySet()) {
                    sb.append(" " + flavor);
                }
                Log.d(TAG, sb.toString());
                // handle type1 last
                handleExtractType1Flavor(themeContext, overlay, "type1a", overlayFolder, prefs);
                handleExtractType1Flavor(themeContext, overlay, "type1b", overlayFolder, prefs);
                handleExtractType1Flavor(themeContext, overlay, "type1c", overlayFolder, prefs);
                generateManifest(theme, overlay, overlayFolder.getAbsolutePath());
                if (!compileOverlay(theme, overlay, overlayFolder.getAbsolutePath())) {
                    continue;
                }
                installAndEnable(getCacheDir().getAbsolutePath() + "/" + theme.packageName + "/overlays/" + theme.packageName + "." + overlay.targetPackage + ".apk", theme.packageName + "." + overlay.targetPackage);
            }
        }
        // now for the bootanimation
        overlays = info.groups.get(OverlayGroup.BOOTANIMATIONS);
        if (overlays != null) {
            final File bootanimBinary = new File(BOOTANIMATION_FILE);
            final File bootanimMetadata = new File(BOOTANIMATION_METADATA);
            final Gson gson = new GsonBuilder().create();
            for (Overlay overlay : overlays.overlays) {
                if (overlay.checked) {
                    notifyInstallProgress(totalCount, ++index, overlay.overlayName);
                    // cleaning up previous installation
                    if (bootanimBinary.exists()) {
                        bootanimBinary.delete();
                    }
                    if (bootanimMetadata.exists()) {
                        bootanimMetadata.delete();
                    }
                    // apply bootanimation
                    File bootAnimCache = new File(overlay.tag);
                    if (bootAnimCache.exists()) {
                        bootAnimCache.renameTo(bootanimBinary);
                    } else {
                        parseBootanimation(themeContext, overlay.overlayName, bootanimBinary);
                    }
                    // chmod 644
                    try {
                        Os.chmod(bootanimBinary.getAbsolutePath(), 00644);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    // save metadata
                    try {
                        final String json = gson.toJson(overlay);
                        FileUtils.writeStringToFile(bootanimMetadata, json, Charset.defaultCharset());
                        // chmod 644
                        Os.chmod(bootanimMetadata.getAbsolutePath(), 00644);
                    } catch (Exception ex) {
                        ex.printStackTrace();
                    }
                    break;
                }
            }
        }
        // mOverlayManager.refresh(UserHandle.USER_CURRENT);
        sendFinishedBroadcast();
        notifyInstallComplete();
        // Housekeeping: cleanup cache
        deleteContents(themeCache);
        return true;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    } finally {
        stopWakeLock();
    }
    return false;
}
#end_block

#method_before
@SuppressLint("SetWorldReadable")
private String getAapt() {
    String path = "/data/system/theme/bin";
    File aaptDir = new File(path);
    File aaptFile = new File(aaptDir, "aapt");
    if (aaptFile.exists()) {
    } else {
        try {
            copyInputStreamToFile(getAssets().open("aapt"), aaptFile);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
    // chmod 755
    try {
        Os.chmod(aaptDir.getAbsolutePath(), 755);
        Os.chmod(aaptFile.getAbsolutePath(), 755);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return path;
}
#method_after
@SuppressLint("SetWorldReadable")
private String getAapt() {
    String path = "/data/system/theme/bin";
    File aaptDir = new File(path);
    File aaptFile = new File(aaptDir, "aapt");
    if (aaptFile.exists()) {
    } else {
        try {
            copyInputStreamToFile(getAssets().open("aapt"), aaptFile);
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
    // chmod 755
    try {
        Os.chmod(aaptDir.getAbsolutePath(), 755);
        Os.chmod(aaptFile.getAbsolutePath(), 755);
    } catch (Exception e) {
        e.printStackTrace();
    }
    return aaptFile.getAbsolutePath();
}
#end_block

#method_before
private OverlayGroup getOverlays(Context themeContext, String[] packages, ThemePrefs prefs) {
    OverlayGroup group = new OverlayGroup();
    Map<String, List<OverlayInfo>> overlays = new HashMap<>();
    try {
        overlays = mOverlayManager.getAllOverlays(UserHandle.USER_CURRENT);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
    group.selectedStyle = prefs.getString("selectedStyle", "");
    for (String p : packages) {
        Overlay overlay = null;
        if (isSystemUIOverlay(p)) {
            overlay = new Overlay(getSystemUIOverlayName(p), p, true);
        } else {
            try {
                ApplicationInfo info = getPackageManager().getApplicationInfo(p, 0);
                // don't show frozen apps
                if (info.enabled) {
                    overlay = new Overlay((String) info.loadLabel(getPackageManager()), p, true);
                }
            } catch (PackageManager.NameNotFoundException e) {
            // overlay = new Overlay(p, p, false);
            }
        }
        if (overlay != null) {
            overlay.overlayPackage = themeContext.getPackageName() + "." + overlay.targetPackage;
            List<OverlayInfo> ois = overlays.get(getTargetPackage(overlay.targetPackage));
            if (ois != null) {
                for (OverlayInfo oi : ois) {
                    if (oi.packageName.equals(overlay.overlayPackage)) {
                        overlay.isOverlayInstalled = true;
                        overlay.checked = (oi.state == OverlayInfo.STATE_APPROVED_ENABLED);
                        overlay.isOverlayEnabled = (oi.state == OverlayInfo.STATE_APPROVED_ENABLED);
                        try {
                            ApplicationInfo oai = getPackageManager().getApplicationInfo(overlay.overlayPackage, PackageManager.GET_META_DATA);
                            overlay.overlayVersion = oai.metaData.getString("theme_version", "").replace("v=", "");
                        } catch (PackageManager.NameNotFoundException ex) {
                        // ignore
                        }
                        break;
                    }
                }
            }
            loadOverlayFlavors(themeContext, overlay);
            for (OverlayFlavor flavor : overlay.flavors.values()) {
                String sel = prefs.getString(overlay.targetPackage + "_" + flavor.key, "");
                if (!TextUtils.isEmpty(sel)) {
                    flavor.selected = sel;
                }
            }
            group.overlays.add(overlay);
        }
    }
    getThemeStyles(themeContext, group);
    group.sort();
    return group;
}
#method_after
private OverlayGroup getOverlays(Context themeContext, String[] packages, ThemePrefs prefs) {
    OverlayGroup group = new OverlayGroup();
    Map<String, List<OverlayInfo>> overlays = new HashMap<>();
    try {
        overlays = mOverlayManager.getAllOverlays(UserHandle.USER_CURRENT);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
    group.selectedStyle = prefs.getString("selectedStyle", "");
    for (String p : packages) {
        Overlay overlay = null;
        if (isSystemUIOverlay(p)) {
            overlay = new Overlay(getSystemUIOverlayName(p), p, true);
        } else {
            try {
                ApplicationInfo info = getPackageManager().getApplicationInfo(p, 0);
                // don't show frozen apps
                if (info.enabled) {
                    overlay = new Overlay((String) info.loadLabel(getPackageManager()), p, true);
                }
            } catch (PackageManager.NameNotFoundException e) {
            // overlay = new Overlay(p, p, false);
            }
        }
        if (overlay != null) {
            overlay.overlayPackage = themeContext.getPackageName() + "." + overlay.targetPackage;
            List<OverlayInfo> ois = overlays.get(getTargetPackage(overlay.targetPackage));
            if (ois != null) {
                for (OverlayInfo oi : ois) {
                    if (oi.packageName.equals(overlay.overlayPackage)) {
                        overlay.isOverlayInstalled = true;
                        overlay.checked = (oi.state == OverlayInfo.STATE_APPROVED_ENABLED);
                        overlay.isOverlayEnabled = (oi.state == OverlayInfo.STATE_APPROVED_ENABLED);
                        try {
                            ApplicationInfo oai = getPackageManager().getApplicationInfo(overlay.overlayPackage, PackageManager.GET_META_DATA);
                            overlay.overlayVersion = oai.metaData.getString("theme_version", "").replace("v=", "");
                        } catch (PackageManager.NameNotFoundException ex) {
                        // ignore
                        }
                        break;
                    }
                }
            }
            loadOverlayFlavors(themeContext, overlay);
            for (OverlayFlavor flavor : overlay.flavors.values()) {
                String sel = prefs.getTypeSelection(overlay.targetPackage, flavor.key);
                if (!TextUtils.isEmpty(sel)) {
                    flavor.selected = sel;
                }
            }
            group.overlays.add(overlay);
        }
    }
    getThemeStyles(themeContext, group);
    group.sort();
    return group;
}
#end_block

#method_before
private void loadOverlayFlavors(Context themeContext, Overlay overlay) {
    String[] types = null;
    try {
        types = themeContext.getAssets().list("overlays/" + overlay.targetPackage);
    } catch (IOException e) {
        e.printStackTrace();
    }
    if (types != null) {
        Map<String, OverlayFlavor> flavorMap = new HashMap<>();
        for (String flavor : types) {
            if (flavor.contains("res") || flavor.contains("type3")) {
                continue;
            }
            if (flavor.startsWith("type")) {
                if (!flavor.contains("_")) {
                    try {
                        String flavorName = IOUtils.toString(themeContext.getAssets().open("overlays/" + overlay.targetPackage + "/" + flavor), Charset.defaultCharset());
                        flavorMap.put(flavor, new OverlayFlavor(flavor, flavorName));
                    } catch (IOException e) {
                    // ignore
                    }
                } else {
                    String flavorName = flavor.substring(flavor.indexOf("_") + 1);
                    if (flavorName.contains(".")) {
                        flavorName = flavorName.substring(0, flavorName.indexOf("."));
                    }
                    String key = flavor.substring(0, flavor.indexOf("_"));
                    if (flavorMap.containsKey(key)) {
                        flavorMap.get(key).flavors.put(flavor, flavorName);
                    }
                }
            }
        }
        overlay.flavors.putAll(flavorMap);
    }
}
#method_after
private void loadOverlayFlavors(Context themeContext, Overlay overlay) {
    String[] types = null;
    try {
        types = themeContext.getAssets().list("overlays/" + overlay.targetPackage);
    } catch (IOException e) {
        e.printStackTrace();
    }
    if (types != null) {
        Map<String, OverlayFlavor> flavorMap = new HashMap<>();
        for (String flavor : types) {
            if (flavor.endsWith(".enc")) {
                flavor = flavor.substring(0, flavor.lastIndexOf("."));
            }
            if (flavor.contains("res") || flavor.contains("type3")) {
                continue;
            }
            if (flavor.startsWith("type")) {
                if (!flavor.contains("_")) {
                    if (!isValidFlavor(flavor)) {
                        continue;
                    }
                    try {
                        String flavorName = IOUtils.toString(themeContext.getAssets().open("overlays/" + overlay.targetPackage + "/" + flavor), Charset.defaultCharset());
                        flavorMap.put(flavor, new OverlayFlavor(flavor, flavorName));
                    } catch (IOException e) {
                    // ignore
                    }
                } else {
                    String flavorName = flavor.substring(flavor.indexOf("_") + 1);
                    if (flavorName.contains(".")) {
                        flavorName = flavorName.substring(0, flavorName.indexOf("."));
                    }
                    String key = flavor.substring(0, flavor.indexOf("_"));
                    if (!isValidFlavor(key)) {
                        continue;
                    }
                    if (!flavorMap.containsKey(key)) {
                        flavorMap.put(key, new OverlayFlavor(flavor, flavorName));
                    } else {
                        flavorMap.get(key).flavors.put(flavor, flavorName);
                    }
                }
            }
        }
        overlay.flavors.putAll(flavorMap);
    }
}
#end_block

#method_before
private void handleExtractType1Flavor(Context themeContext, Overlay overlay, String typeName, File overlayFolder, ThemePrefs prefs) {
    OverlayFlavor type = overlay.flavors.get(typeName);
    if (type != null) {
        Log.d(TAG, "handleExtractType1Flavor, selected=" + type.selected);
        if (type.selected == null)
            return;
        AssetManager am = themeContext.getAssets();
        try {
            String of = "overlays/" + overlay.targetPackage + "/res";
            for (String n : am.list(of)) {
                if (n.contains("values")) {
                    for (String s : am.list(of + "/" + n)) {
                        if (s.equals(type.key + ".xml")) {
                            AssetUtils.copyAsset(am, "overlays/" + overlay.targetPackage + "/" + type.selected, overlayFolder.getAbsolutePath() + "/res/" + n + "/" + type.key + ".xml");
                        }
                    }
                }
            }
            prefs.putString(overlay.targetPackage, type.selected);
        } catch (Exception e) {
            e.printStackTrace();
        }
    } else {
        Log.d(TAG, "Flavor " + typeName + " is null!");
    }
}
#method_after
private void handleExtractType1Flavor(Context themeContext, Overlay overlay, String typeName, File overlayFolder, ThemePrefs prefs) {
    OverlayFlavor type = overlay.flavors.get(typeName);
    if (type != null) {
        Log.d(TAG, "handleExtractType1Flavor, selected=" + type.selected);
        if (type.selected == null)
            return;
        AssetManager am = themeContext.getAssets();
        try {
            String of = "overlays/" + overlay.targetPackage + "/res";
            for (String n : am.list(of)) {
                if (n.contains("values")) {
                    for (String s : am.list(of + "/" + n)) {
                        if (s.equals(type.key + ".xml")) {
                            AssetUtils.copyAsset(am, "overlays/" + overlay.targetPackage + "/" + type.selected, overlayFolder.getAbsolutePath() + "/res/" + n + "/" + type.key + ".xml");
                        }
                    }
                }
            }
            prefs.putTypeSelection(overlay.targetPackage, typeName, type.selected);
        } catch (Exception e) {
            e.printStackTrace();
        }
    } else {
        Log.d(TAG, "Flavor " + typeName + " is null!");
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
@Override
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel((String) m.obj);
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
private void bluetoothStateChangeHandler(int prevState, int newState) {
    boolean isStandardBroadcast = true;
    if (prevState == newState) {
        // No change. Nothing to do.
        return;
    }
    // Notify all proxy objects first of adapter state change
    if (newState == BluetoothAdapter.STATE_BLE_ON || newState == BluetoothAdapter.STATE_OFF) {
        boolean intermediate_off = (prevState == BluetoothAdapter.STATE_TURNING_OFF && newState == BluetoothAdapter.STATE_BLE_ON);
        if (newState == BluetoothAdapter.STATE_OFF) {
            // If Bluetooth is off, send service down event to proxy objects, and unbind
            if (DBG)
                Slog.d(TAG, "Bluetooth is complete send Service Down");
            sendBluetoothServiceDownCallback();
            unbindAndFinish();
            sendBleStateChanged(prevState, newState);
            // Don't broadcast as it has already been broadcast before
            isStandardBroadcast = false;
        } else if (!intermediate_off) {
            // connect to GattService
            if (DBG)
                Slog.d(TAG, "Bluetooth is in LE only mode");
            if (mBluetoothGatt != null) {
                if (DBG)
                    Slog.d(TAG, "Calling BluetoothGattServiceUp");
                onBluetoothGattServiceUp();
            } else {
                if (DBG)
                    Slog.d(TAG, "Binding Bluetooth GATT service");
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
                    Intent i = new Intent(IBluetoothGatt.class.getName());
                    doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT);
                }
            }
            sendBleStateChanged(prevState, newState);
            // Don't broadcase this as std intent
            isStandardBroadcast = false;
        } else if (intermediate_off) {
            if (DBG)
                Slog.d(TAG, "Intermediate off, back to LE only mode");
            // For LE only mode, broadcast as is
            sendBleStateChanged(prevState, newState);
            // BT is OFF for general users
            sendBluetoothStateCallback(false);
            // Broadcast as STATE_OFF
            newState = BluetoothAdapter.STATE_OFF;
            sendBrEdrDownCallback();
        }
    } else if (newState == BluetoothAdapter.STATE_ON) {
        boolean isUp = (newState == BluetoothAdapter.STATE_ON);
        sendBluetoothStateCallback(isUp);
        sendBleStateChanged(prevState, newState);
        if (isStandardBroadcast) {
            if (prevState == BluetoothAdapter.STATE_BLE_ON) {
                // Show prevState of BLE_ON as OFF to standard users
                prevState = BluetoothAdapter.STATE_OFF;
            }
            Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
            intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
            intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
            intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
            mContext.sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
        }
        Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
    }
}
#method_after
private void bluetoothStateChangeHandler(int prevState, int newState) {
    boolean isStandardBroadcast = true;
    if (prevState == newState) {
        // No change. Nothing to do.
        return;
    }
    // Notify all proxy objects first of adapter state change
    if (newState == BluetoothAdapter.STATE_BLE_ON || newState == BluetoothAdapter.STATE_OFF) {
        boolean intermediate_off = (prevState == BluetoothAdapter.STATE_TURNING_OFF && newState == BluetoothAdapter.STATE_BLE_ON);
        if (newState == BluetoothAdapter.STATE_OFF) {
            // If Bluetooth is off, send service down event to proxy objects, and unbind
            if (DBG)
                Slog.d(TAG, "Bluetooth is complete send Service Down");
            sendBluetoothServiceDownCallback();
            unbindAndFinish();
            sendBleStateChanged(prevState, newState);
            // Don't broadcast as it has already been broadcast before
            isStandardBroadcast = false;
        } else if (!intermediate_off) {
            // connect to GattService
            if (DBG)
                Slog.d(TAG, "Bluetooth is in LE only mode");
            if (mBluetoothGatt != null) {
                if (DBG)
                    Slog.d(TAG, "Calling BluetoothGattServiceUp");
                onBluetoothGattServiceUp();
            } else {
                if (DBG)
                    Slog.d(TAG, "Binding Bluetooth GATT service");
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
                    Intent i = new Intent(IBluetoothGatt.class.getName());
                    doBind(i, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_IMPORTANT, UserHandle.CURRENT);
                }
            }
            sendBleStateChanged(prevState, newState);
            // Don't broadcase this as std intent
            isStandardBroadcast = false;
        } else if (intermediate_off) {
            if (DBG)
                Slog.d(TAG, "Intermediate off, back to LE only mode");
            // For LE only mode, broadcast as is
            sendBleStateChanged(prevState, newState);
            // BT is OFF for general users
            sendBluetoothStateCallback(false);
            // Broadcast as STATE_OFF
            newState = BluetoothAdapter.STATE_OFF;
            sendBrEdrDownCallback();
        }
    } else if (newState == BluetoothAdapter.STATE_ON) {
        boolean isUp = (newState == BluetoothAdapter.STATE_ON);
        sendBluetoothStateCallback(isUp);
        sendBleStateChanged(prevState, newState);
    } else if (newState == BluetoothAdapter.STATE_BLE_TURNING_ON || newState == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        sendBleStateChanged(prevState, newState);
        isStandardBroadcast = false;
    } else if (newState == BluetoothAdapter.STATE_TURNING_ON || newState == BluetoothAdapter.STATE_TURNING_OFF) {
        sendBleStateChanged(prevState, newState);
    }
    if (isStandardBroadcast) {
        if (prevState == BluetoothAdapter.STATE_BLE_ON) {
            // Show prevState of BLE_ON as OFF to standard users
            prevState = BluetoothAdapter.STATE_OFF;
        }
        Intent intent = new Intent(BluetoothAdapter.ACTION_STATE_CHANGED);
        intent.putExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, prevState);
        intent.putExtra(BluetoothAdapter.EXTRA_STATE, newState);
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        mContext.sendBroadcastAsUser(intent, UserHandle.ALL, BLUETOOTH_PERM);
    }
}
#end_block

#method_before
public Builder detectAll() {
    int flags = DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE;
    // for apps to mark sockets that should be ignored
    if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
        flags |= DETECT_VM_CLEARTEXT_NETWORK;
    }
    return enable(flags);
}
#method_after
public Builder detectAll() {
    return enable(ALL_THREAD_DETECT_BITS);
}
#end_block

#method_before
public VmPolicy build() {
    // set, enable simple logging.
    if (mMask != 0 && (mMask & (PENALTY_DEATH | PENALTY_LOG | PENALTY_DROPBOX | PENALTY_DIALOG)) == 0) {
        penaltyLog();
    }
    return new VmPolicy(mMask, mClassInstanceLimit != null ? mClassInstanceLimit : EMPTY_CLASS_LIMIT_MAP);
}
#method_after
public ThreadPolicy build() {
    // set, enable simple logging.
    if (mMask != 0 && (mMask & (PENALTY_DEATH | PENALTY_LOG | PENALTY_DROPBOX | PENALTY_DIALOG)) == 0) {
        penaltyLog();
    }
    return new ThreadPolicy(mMask);
}
#end_block

#method_before
private void setupItemTouchHelper() {
    ItemTouchHelper touchHelper = new ItemTouchHelper(new ItemTouchHelper.Callback() {

        @Override
        public boolean onMove(RecyclerView recyclerView, ViewHolder viewHolder, ViewHolder target) {
            return true;
        }

        @Override
        public void onSwiped(ViewHolder viewHolder, int direction) {
            int pos = viewHolder.getAdapterPosition();
            CardHolder card = mCards.get(pos);
            mCards.remove(pos);
            mCardAdapter.removeCard(pos);
            removeApplication(card.task);
        }

        @Override
        public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
            // Set movement flags based on the layout manager
            final int dragFlags = 0;
            final int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END;
            return makeMovementFlags(dragFlags, swipeFlags);
        }
    });
    touchHelper.attachToRecyclerView(mCardRecyclerView);
}
#method_after
private void setupItemTouchHelper() {
    ItemTouchHelper touchHelper = new ItemTouchHelper(new ItemTouchHelper.Callback() {

        RecentCard card;

        int taskid;

        int initPos;

        int finalPos;

        boolean isSwipe;

        boolean unwantedDrag = true;

        @Override
        public boolean onMove(RecyclerView recyclerView, ViewHolder viewHolder, ViewHolder target) {
            /* We'll start multiwindow action in the clearView void, when the drag action
                and all animations are completed. Otherwise we'd do a loop action
                till the drag is completed for each onMove (wasting resources and making
                the drag not smooth).*/
            ExpandableCardAdapter.ViewHolder vh = (ExpandableCardAdapter.ViewHolder) viewHolder;
            vh.hideOptions(-1, -1);
            initPos = viewHolder.getAdapterPosition();
            card = (RecentCard) mCardAdapter.getCard(initPos);
            taskid = card.task.persistentTaskId;
            unwantedDrag = false;
            return true;
        }

        @Override
        public void onMoved(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, int fromPos, RecyclerView.ViewHolder target, int toPos, int x, int y) {
            finalPos = toPos;
            isSwipe = false;
        }

        @Override
        public float getMoveThreshold(RecyclerView.ViewHolder viewHolder) {
            // if less then this we consider it as unwanted drag
            return 0.2f;
        }

        @Override
        public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
            super.clearView(recyclerView, viewHolder);
            if (isSwipe) {
                // don't start multiwindow on swipe
                return;
            }
            if (unwantedDrag) {
                /*this means MoveThreshold is less than needed, so onMove
                    has not been considered, so we don't consider the action as wanted drag*/
                return;
            }
            // restore the drag check
            unwantedDrag = true;
            // If a multiwin session is already active, ask the user to close it
            int dockSide = WindowManagerProxy.getInstance().getDockSide();
            if (dockSide != WindowManager.DOCKED_INVALID) {
                Toast mWarningToast = Toast.makeText(mContext, R.string.recents_multiwin_warning, Toast.LENGTH_LONG);
                mWarningToast.show();
                return;
            }
            ActivityOptions options = ActivityOptions.makeBasic();
            /* Activity Manager let's dock the app to top or bottom dinamically,
                with the setDockCreateMode DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT is 0,
                DOCKED_STACK_CREATE_MODE_BOTTOM_OR_RIGHT is 1. Thus if we drag down,
                dock app to bottom, if we drag up dock app to top*/
            options.setDockCreateMode(finalPos > initPos ? 0 : 1);
            options.setLaunchStackId(ActivityManager.StackId.DOCKED_STACK_ID);
            try {
                ActivityManagerNative.getDefault().startActivityFromRecents(taskid, options.toBundle());
                card = (RecentCard) mCardAdapter.getCard(finalPos);
                int newTaskid = card.task.persistentTaskId;
                /*after we docked our main app, on the other side of the screen we
                    open the app we dragged the main app over*/
                mController.openOnDraggedApptoOtherSide(newTaskid);
            } catch (RemoteException e) {
            }
        }

        @Override
        public boolean isLongPressDragEnabled() {
            return true;
        }

        @Override
        public void onSwiped(ViewHolder viewHolder, int direction) {
            int pos = viewHolder.getAdapterPosition();
            RecentCard card = (RecentCard) mCardAdapter.getCard(pos);
            mCardAdapter.removeCard(pos);
            removeApplication(card.task);
            isSwipe = true;
        }

        @Override
        public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
            // Set movement flags based on the layout manager
            final int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;
            final int swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END;
            return makeMovementFlags(dragFlags, swipeFlags);
        }
    });
    touchHelper.attachToRecyclerView(mCardRecyclerView);
}
#end_block

#method_before
private boolean isReferenceInstalled(String packagename, PackageManager pm) {
    try {
        pm.getPackageInfo(packagename, PackageManager.GET_ACTIVITIES);
        return true;
    } catch (NameNotFoundException e) {
        if (DEBUG)
            Log.e(TAG, "Store is not installed: " + packagename, e);
        return false;
    }
}
#method_after
private boolean isReferenceInstalled(String packagename, PackageManager pm) {
    try {
        pm.getPackageInfo(packagename, PackageManager.GET_ACTIVITIES);
        return true;
    } catch (NameNotFoundException e) {
        if (DEBUG)
            Log.e(TAG, "Store is not installed: " + packagename);
        return false;
    }
}
#end_block

#method_before
private void removeApplication(TaskDescription td) {
    if (DEBUG)
        Log.v(TAG, "Jettison " + td.getLabel());
    // Kill the actual app and send accessibility event.
    final ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    if (am != null) {
        am.removeTask(td.persistentTaskId);
        // Accessibility feedback
        mCardRecyclerView.setContentDescription(mContext.getString(R.string.accessibility_recents_item_dismissed, td.getLabel()));
        mCardRecyclerView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
        mCardRecyclerView.setContentDescription(null);
        // Remove app from task, cache and expanded state list.
        removeApplicationBitmapCacheAndExpandedState(td);
    }
    // All apps were removed? Close recents panel.
    if (mCardAdapter.getItemCount() == 0) {
        setVisibility();
        exit();
    }
}
#method_after
private void removeApplication(TaskDescription td) {
    if (DEBUG)
        Log.v(TAG, "Jettison " + td.getLabel());
    // Kill the actual app and send accessibility event.
    final ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    if (am != null) {
        am.removeTask(td.persistentTaskId);
        // Accessibility feedback
        mCardRecyclerView.setContentDescription(mContext.getString(R.string.accessibility_recents_item_dismissed, td.getLabel()));
        mCardRecyclerView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
        mCardRecyclerView.setContentDescription(null);
        // Remove app from task and expanded state list.
        removeExpandedTaskState(td.identifier);
    }
    // All apps were removed? Close recents panel.
    if (mCardAdapter.getItemCount() == 0) {
        setVisibility();
        exit();
    }
}
#end_block

#method_before
protected boolean removeAllApplications() {
    final ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    boolean hasFavorite = false;
    int size = mCardAdapter.getItemCount() - 1;
    for (int i = size; i >= 0; i--) {
        CardHolder holder = mCards.get(i);
        ;
        TaskDescription td = holder.task;
        // User favorites are not removed.
        if (td.getIsFavorite()) {
            hasFavorite = true;
            continue;
        }
        // Remove from task stack.
        if (am != null) {
            am.removeTask(td.persistentTaskId);
        }
        // Remove the card.
        removeRecentCard(holder);
        // Remove bitmap and expanded state.
        removeApplicationBitmapCacheAndExpandedState(td);
    }
    return !hasFavorite;
}
#method_after
protected boolean removeAllApplications() {
    final ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    boolean hasFavorite = false;
    int size = mCardAdapter.getItemCount() - 1;
    for (int i = size; i >= 0; i--) {
        RecentCard card = (RecentCard) mCardAdapter.getCard(i);
        TaskDescription td = card.task;
        // User favorites are not removed.
        if (td.getIsFavorite()) {
            hasFavorite = true;
            continue;
        }
        // Remove from task stack.
        if (am != null) {
            am.removeTask(td.persistentTaskId);
        }
        // Remove the card.
        removeRecentCard(card);
        // Remove expanded state.
        removeExpandedTaskState(td.identifier);
    }
    return !hasFavorite;
}
#end_block

#method_before
private void removeRecentCard(CardHolder holder) {
    int pos = mCards.indexOf(holder);
    mCards.remove(pos);
    mCardAdapter.notifyItemRemoved(pos);
}
#method_after
private void removeRecentCard(RecentCard card) {
    mCardAdapter.removeCard(card);
}
#end_block

#method_before
private boolean storeIsInTaskList(String uriReference) {
    if (mFirstTask != null && uriReference.equals(mFirstTask.packageName)) {
        return true;
    }
    for (CardHolder c : mCards) {
        if (uriReference.equals(c.task.packageName)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean storeIsInTaskList(String uriReference) {
    if (mFirstTask != null && uriReference.equals(mFirstTask.packageName)) {
        return true;
    }
    int count = mCardAdapter.getItemCount();
    for (int i = 0; i < count; i++) {
        RecentCard c = (RecentCard) mCardAdapter.getCard(i);
        if (uriReference.equals(c.task.packageName)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected void loadTasks() {
    if (isTasksLoaded() || mIsLoading) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, "loading tasks");
    mIsLoading = true;
    updateExpandedTaskStates();
    // We have all needed tasks now.
    // Let us load the cards for it in background.
    final CardLoader cardLoader = new CardLoader();
    cardLoader.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR);
}
#method_after
protected void loadTasks() {
    if (isTasksLoaded() || mIsLoading) {
        return;
    }
    if (DEBUG)
        Log.v(TAG, "loading tasks");
    mIsLoading = true;
    updateExpandedTaskStates();
    // We have all needed tasks now.
    // Let us load the cards for it in background.
    final CardLoader cardLoader = new CardLoader();
    cardLoader.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#end_block

#method_before
private void updateExpandedTaskStates() {
    for (CardHolder holder : mCards) {
        boolean updated = false;
        for (TaskExpandedStates expandedState : mExpandedTaskStates) {
            if (holder.task.identifier.equals(expandedState.getIdentifier())) {
                updated = true;
                expandedState.setExpandedState(holder.task.getExpandedState());
            }
        }
        if (!updated) {
            mExpandedTaskStates.add(new TaskExpandedStates(holder.task.identifier, holder.task.getExpandedState()));
        }
    }
}
#method_after
private void updateExpandedTaskStates() {
    int count = mCardAdapter.getItemCount();
    for (int i = 0; i < count; i++) {
        RecentCard card = (RecentCard) mCardAdapter.getCard(i);
        boolean updated = false;
        for (TaskExpandedStates expandedState : mExpandedTaskStates) {
            if (card.task.identifier.equals(expandedState.getIdentifier())) {
                updated = true;
                expandedState.setExpandedState(card.task.getExpandedState());
            }
        }
        if (!updated) {
            mExpandedTaskStates.add(new TaskExpandedStates(card.task.identifier, card.task.getExpandedState()));
        }
    }
}
#end_block

#method_before
protected boolean hasFavorite() {
    for (CardHolder holder : mCards) {
        if (holder.task.getIsFavorite()) {
            return true;
        }
    }
    return false;
}
#method_after
protected boolean hasFavorite() {
    int count = mCardAdapter.getItemCount();
    for (int i = 0; i < count; i++) {
        RecentCard card = (RecentCard) mCardAdapter.getCard(i);
        if (card.task.getIsFavorite()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected boolean hasClearableTasks() {
    for (CardHolder holder : mCards) {
        if (!holder.task.getIsFavorite()) {
            return true;
        }
    }
    return false;
}
#method_after
protected boolean hasClearableTasks() {
    int count = mCardAdapter.getItemCount();
    for (int i = 0; i < count; i++) {
        RecentCard card = (RecentCard) mCardAdapter.getCard(i);
        if (!card.task.getIsFavorite()) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected Boolean doInBackground(Void... params) {
    // Save current thread priority and set it during the loading
    // to background priority.
    // mOrigPri = Process.getThreadPriority(Process.myTid());
    Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
    final int oldSize = mCardAdapter.getItemCount();
    mCounter = 0;
    // Check and get user favorites.
    final String favorites = SlimSettings.System.getStringForUser(mContext.getContentResolver(), SlimSettings.System.RECENT_PANEL_FAVORITES, UserHandle.USER_CURRENT);
    final ArrayList<String> favList = new ArrayList<>();
    final ArrayList<TaskDescription> nonFavoriteTasks = new ArrayList<>();
    if (favorites != null && !favorites.isEmpty()) {
        for (String favorite : favorites.split("\\|")) {
            favList.add(favorite);
        }
    }
    final PackageManager pm = mContext.getPackageManager();
    final ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    int maxNumTasksToLoad = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.RECENTS_MAX_APPS, mContext.getResources().getInteger(slim.R.integer.slim_recents_max_apps_default), UserHandle.USER_CURRENT);
    final List<ActivityManager.RecentTaskInfo> recentTasks = am.getRecentTasksForUser(ActivityManager.getMaxRecentTasksStatic(), ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS | ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_PROFILES, UserHandle.CURRENT.getIdentifier());
    final List<ActivityManager.RunningTaskInfo> runningTasks = am.getRunningTasks(Integer.MAX_VALUE);
    final int numTasks = recentTasks.size();
    int newSize = numTasks;
    ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME).resolveActivityInfo(pm, 0);
    int firstItems = 0;
    final int firstExpandedItems = mContext.getResources().getInteger(R.integer.expanded_items_default);
    // Get current task list. We do not need to do it in background. We only load MAX_TASKS.
    for (int i = 0; i < numTasks; i++) {
        if (isCancelled() || mCancelledByUser) {
            if (DEBUG)
                Log.v(TAG, "loading tasks cancelled");
            mIsLoading = false;
            return false;
        }
        final ActivityManager.RecentTaskInfo recentInfo = recentTasks.get(i);
        final Intent intent = new Intent(recentInfo.baseIntent);
        if (recentInfo.origActivity != null) {
            intent.setComponent(recentInfo.origActivity);
        }
        boolean topTask = i == 0;
        if (topTask) {
            ActivityManager.RunningTaskInfo rTask = getRunningTask(am);
            if (rTask != null) {
                if (!rTask.baseActivity.getPackageName().equals(recentInfo.baseIntent.getComponent().getPackageName())) {
                    topTask = false;
                }
            }
        }
        if (mOnlyShowRunningTasks) {
            boolean isRunning = false;
            for (ActivityManager.RunningTaskInfo task : runningTasks) {
                if (recentInfo.baseIntent.getComponent().getPackageName().equals(task.baseActivity.getPackageName())) {
                    isRunning = true;
                }
            }
            if (!isRunning) {
                newSize--;
                continue;
            }
        }
        TaskDescription item = createTaskDescription(recentInfo.id, recentInfo.persistentId, recentInfo.baseIntent, recentInfo.origActivity, recentInfo.description, false, EXPANDED_STATE_UNKNOWN, recentInfo.taskDescription);
        if (item != null) {
            // Remove any tasks after our max task limit to keep good ux
            if (i >= maxNumTasksToLoad) {
                am.removeTask(item.persistentTaskId);
                continue;
            }
            for (String fav : favList) {
                if (fav.equals(item.identifier)) {
                    item.setIsFavorite(true);
                    break;
                }
            }
            if (topTask) {
                if (mShowTopTask || screenPinningEnabled()) {
                    // User want to see actual running task. Set it here
                    int oldState = getExpandedState(item);
                    if ((oldState & EXPANDED_STATE_TOPTASK) == 0) {
                        oldState |= EXPANDED_STATE_TOPTASK;
                    }
                    item.setExpandedState(oldState);
                    addCard(item, oldSize, true);
                    mFirstTask = item;
                } else {
                    // Skip the first task for our list but save it for later use.
                    mFirstTask = item;
                    newSize--;
                }
            } else {
                // FirstExpandedItems value forces to show always the app screenshot
                // if the old state is not known and the user has set expanded mode to auto.
                // On all other items we check if they were expanded from the user
                // in last known recent app list and restore the state. This counts as well
                // if expanded mode is always or never.
                int oldState = getExpandedState(item);
                if ((oldState & EXPANDED_STATE_BY_SYSTEM) != 0) {
                    oldState &= ~EXPANDED_STATE_BY_SYSTEM;
                }
                if ((oldState & EXPANDED_STATE_TOPTASK) != 0) {
                    oldState &= ~EXPANDED_STATE_TOPTASK;
                }
                if (DEBUG)
                    Log.v(TAG, "old expanded state = " + oldState);
                if (firstItems < firstExpandedItems) {
                    if (mExpandedMode != EXPANDED_MODE_NEVER) {
                        oldState |= EXPANDED_STATE_BY_SYSTEM;
                    }
                    item.setExpandedState(oldState);
                    // The first tasks are always added to the task list.
                    addCard(item, oldSize, false);
                } else {
                    if (mExpandedMode == EXPANDED_MODE_ALWAYS) {
                        oldState |= EXPANDED_STATE_BY_SYSTEM;
                    }
                    item.setExpandedState(oldState);
                    // we hold for a short time in an extra list.
                    if (item.getIsFavorite()) {
                        addCard(item, oldSize, false);
                    } else {
                        nonFavoriteTasks.add(item);
                    }
                }
                firstItems++;
            }
        }
    }
    // Add now the non favorite tasks to the final task list.
    for (TaskDescription item : nonFavoriteTasks) {
        addCard(item, oldSize, false);
    }
    // in the old task list. Let us remove them as well.
    if (newSize < oldSize) {
        for (int i = oldSize - 1; i >= newSize; i--) {
            if (DEBUG)
                Log.v(TAG, "loading tasks - remove not needed old card - position=" + i);
            mCards.remove(i);
        }
    }
    return true;
}
#method_after
@Override
protected Boolean doInBackground(Void... params) {
    Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
    final int oldSize = mCardAdapter.getItemCount();
    mCounter = 0;
    // Check and get user favorites.
    final String favorites = SlimSettings.System.getStringForUser(mContext.getContentResolver(), SlimSettings.System.RECENT_PANEL_FAVORITES, UserHandle.USER_CURRENT);
    final ArrayList<String> favList = new ArrayList<>();
    final ArrayList<TaskDescription> nonFavoriteTasks = new ArrayList<>();
    if (favorites != null && !favorites.isEmpty()) {
        for (String favorite : favorites.split("\\|")) {
            favList.add(favorite);
        }
    }
    final PackageManager pm = mContext.getPackageManager();
    final ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
    int maxNumTasksToLoad = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.RECENTS_MAX_APPS, mContext.getResources().getInteger(slim.R.integer.slim_recents_max_apps_default), UserHandle.USER_CURRENT);
    final List<ActivityManager.RecentTaskInfo> recentTasks = am.getRecentTasksForUser(ActivityManager.getMaxRecentTasksStatic(), ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS | ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK | ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS | ActivityManager.RECENT_IGNORE_UNAVAILABLE | ActivityManager.RECENT_INCLUDE_PROFILES, UserHandle.CURRENT.getIdentifier());
    final List<ActivityManager.RunningTaskInfo> runningTasks = am.getRunningTasks(Integer.MAX_VALUE);
    final int numTasks = recentTasks.size();
    int newSize = numTasks;
    ActivityInfo homeInfo = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME).resolveActivityInfo(pm, 0);
    int firstItems = 0;
    final int firstExpandedItems = mContext.getResources().getInteger(R.integer.expanded_items_default);
    // Get current task list. We do not need to do it in background. We only load MAX_TASKS.
    for (int i = 0; i < numTasks; i++) {
        if (isCancelled() || mCancelledByUser) {
            if (DEBUG)
                Log.v(TAG, "loading tasks cancelled");
            mIsLoading = false;
            return false;
        }
        final ActivityManager.RecentTaskInfo recentInfo = recentTasks.get(i);
        final Intent intent = new Intent(recentInfo.baseIntent);
        if (recentInfo.origActivity != null) {
            intent.setComponent(recentInfo.origActivity);
        }
        boolean topTask = i == 0;
        if (topTask) {
            ActivityManager.RunningTaskInfo rTask = getRunningTask(am);
            if (rTask != null) {
                if (!rTask.baseActivity.getPackageName().equals(recentInfo.baseIntent.getComponent().getPackageName())) {
                    topTask = false;
                }
            }
        }
        if (mOnlyShowRunningTasks) {
            boolean isRunning = false;
            for (ActivityManager.RunningTaskInfo task : runningTasks) {
                if (recentInfo.baseIntent.getComponent().getPackageName().equals(task.baseActivity.getPackageName())) {
                    isRunning = true;
                }
            }
            if (!isRunning) {
                newSize--;
                continue;
            }
        }
        TaskDescription item = createTaskDescription(recentInfo.id, recentInfo.persistentId, recentInfo.baseIntent, recentInfo.origActivity, recentInfo.description, false, EXPANDED_STATE_UNKNOWN, recentInfo.taskDescription);
        if (item != null) {
            // Remove any tasks after our max task limit to keep good ux
            if (i >= maxNumTasksToLoad) {
                am.removeTask(item.persistentTaskId);
                continue;
            }
            for (String fav : favList) {
                if (fav.equals(item.identifier)) {
                    item.setIsFavorite(true);
                    break;
                }
            }
            if (topTask) {
                if (mShowTopTask || screenPinningEnabled()) {
                    // User want to see actual running task. Set it here
                    int oldState = getExpandedState(item);
                    if ((oldState & EXPANDED_STATE_TOPTASK) == 0) {
                        oldState |= EXPANDED_STATE_TOPTASK;
                    }
                    item.setExpandedState(oldState);
                    addCard(item, oldSize, true);
                    mFirstTask = item;
                } else {
                    // Skip the first task for our list but save it for later use.
                    mFirstTask = item;
                    newSize--;
                }
            } else {
                // FirstExpandedItems value forces to show always the app screenshot
                // if the old state is not known and the user has set expanded mode to auto.
                // On all other items we check if they were expanded from the user
                // in last known recent app list and restore the state. This counts as well
                // if expanded mode is always or never.
                int oldState = getExpandedState(item);
                if ((oldState & EXPANDED_STATE_BY_SYSTEM) != 0) {
                    oldState &= ~EXPANDED_STATE_BY_SYSTEM;
                }
                if ((oldState & EXPANDED_STATE_TOPTASK) != 0) {
                    oldState &= ~EXPANDED_STATE_TOPTASK;
                }
                if (DEBUG)
                    Log.v(TAG, "old expanded state = " + oldState);
                if (firstItems < firstExpandedItems) {
                    if (mExpandedMode != EXPANDED_MODE_NEVER) {
                        oldState |= EXPANDED_STATE_BY_SYSTEM;
                    }
                    item.setExpandedState(oldState);
                    // The first tasks are always added to the task list.
                    addCard(item, oldSize, false);
                } else {
                    if (mExpandedMode == EXPANDED_MODE_ALWAYS) {
                        oldState |= EXPANDED_STATE_BY_SYSTEM;
                    }
                    item.setExpandedState(oldState);
                    // we hold for a short time in an extra list.
                    if (item.getIsFavorite()) {
                        addCard(item, oldSize, false);
                    } else {
                        nonFavoriteTasks.add(item);
                    }
                }
                firstItems++;
            }
        }
    }
    // Add now the non favorite tasks to the final task list.
    for (TaskDescription item : nonFavoriteTasks) {
        addCard(item, oldSize, false);
    }
    // in the old task list. Let us remove them as well.
    if (newSize < oldSize) {
        for (int i = oldSize - 1; i >= newSize; i--) {
            if (DEBUG)
                Log.v(TAG, "loading tasks - remove not needed old card - position=" + i);
            mCardAdapter.removeCard(i);
        }
    }
    return true;
}
#end_block

#method_before
private void addCard(final TaskDescription task, int oldSize, boolean topTask) {
    ExpandableCard card = null;
    final int index = mCounter;
    // Let us reuse them and just update the content.
    if (mCounter < oldSize) {
        CardHolder holder = mCards.get(mCounter);
        if (holder != null) {
            card = holder.card;
            if (DEBUG)
                Log.v(TAG, "loading tasks - update old card");
            card.appName = task.getLabel();
            holder.setTask(task);
            holder.task = task;
            // card.updateCardContent(task, mScaleFactor);
            card = assignListeners(card, task);
        }
    }
    // No old card was present to update....so add a new one.
    if (card == null) {
        if (DEBUG)
            Log.v(TAG, "loading tasks - create new card");
        card = new ExpandableCard(task.getLabel(), null);
        card = assignListeners(card, task);
        CardHolder holder = new CardHolder(card, task);
        holder.position = index;
        mCards.add(holder);
    }
    // Set card color
    card.cardBackgroundColor = getCardBackgroundColor(task);
    final ExpandableCard ec = card;
    AppIconLoader.getInstance(mContext).loadAppIcon(task.resolveInfo, task.identifier, new AppIconLoader.IconCallback() {

        @Override
        public void onDrawableLoaded(Drawable drawable) {
            ec.appIcon = drawable;
            mCardAdapter.notifyItemChanged(index);
        }
    }, mScaleFactor);
    new BitmapDownloaderTask(mContext, mScaleFactor, new DownloaderCallback() {

        @Override
        public void onBitmapLoaded(Bitmap bitmap) {
            ec.screenshot = bitmap;
            mCardAdapter.notifyItemChanged(index);
        }
    }).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, task.persistentTaskId);
    card.cardClickListener = new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            startApplication(task);
        }
    };
    // cards.add(card);
    publishProgress(card);
    mCounter++;
}
#method_after
private void addCard(final TaskDescription task, int oldSize, boolean topTask) {
    RecentCard card = null;
    final int index = mCounter;
    // Let us reuse them and just update the content.
    if (mCounter < oldSize) {
        card = (RecentCard) mCardAdapter.getCard(mCounter);
        if (card != null) {
            if (DEBUG)
                Log.v(TAG, "loading tasks - update old card");
            card.setTask(task);
        }
    }
    // No old card was present to update....so add a new one.
    if (card == null) {
        if (DEBUG)
            Log.v(TAG, "loading tasks - create new card");
        card = new RecentCard(task);
        card.position = index;
    }
    // Set card color
    card.cardBackgroundColor = getCardBackgroundColor(task);
    final ExpandableCard ec = card;
    AppIconLoader.getInstance(mContext).loadAppIcon(task.resolveInfo, task.identifier, new AppIconLoader.IconCallback() {

        @Override
        public void onDrawableLoaded(Drawable drawable) {
            ec.appIcon = drawable;
            mCardAdapter.notifyItemChanged(index);
        }
    }, mScaleFactor);
    new BitmapDownloaderTask(mContext, mScaleFactor, new DownloaderCallback() {

        @Override
        public void onBitmapLoaded(Bitmap bitmap) {
            ec.screenshot = bitmap;
            mCardAdapter.notifyItemChanged(index);
        }
    }).executeOnExecutor(AsyncTask.SERIAL_EXECUTOR, task.persistentTaskId);
    card.cardClickListener = new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            startApplication(task);
        }
    };
    mCounter++;
    publishProgress(card);
}
#end_block

#method_before
@Override
protected void onProgressUpdate(ExpandableCard... card) {
    if (mCounter > 2 && !isTasksLoaded()) {
        setVisibility();
        tasksLoaded();
    }
    mCardAdapter.addCard(card[0]);
}
#method_after
@Override
protected void onProgressUpdate(ExpandableCard... card) {
    mCardAdapter.addCard(card[0]);
    if (!isTasksLoaded()) {
        // we have at least one task and card, so can show the panel while we
        // load more tasks and cards
        setVisibility();
        tasksLoaded();
    }
}
#end_block

#method_before
@Override
protected void onPostExecute(Boolean loaded) {
    // removing alive. This should never happen. Just in case.
    if (!loaded) {
        Log.v(TAG, "card constructing was cancelled by system or user");
    }
    // Notify arrayadapter that data set has changed
    if (DEBUG)
        Log.v(TAG, "notifiy arrayadapter that data has changed");
    notifyDataSetChanged(true);
// Notfiy controller that tasks are completly loaded.
// tasksLoaded();
}
#method_after
@Override
protected void onPostExecute(Boolean loaded) {
    // removing alive. This should never happen. Just in case.
    if (!loaded) {
        Log.v(TAG, "card constructing was cancelled by system or user");
    }
    // Notify arrayadapter that data set has changed
    if (DEBUG)
        Log.v(TAG, "notifiy arrayadapter that data has changed");
    notifyDataSetChanged(true);
    // Notfiy controller that tasks are completly loaded.
    if (!isTasksLoaded()) {
        setVisibility();
        tasksLoaded();
    }
}
#end_block

#method_before
private int getCardBackgroundColor(TaskDescription task) {
    int color = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.RECENT_CARD_BG_COLOR, 0x00ffffff, UserHandle.USER_CURRENT);
    if (color != 0x0ffffff) {
        return color;
    } else if (task != null && task.cardColor != 0) {
        return task.cardColor;
    } else {
        return mContext.getResources().getColor(R.color.recents_task_bar_default_background_color);
    }
}
#method_after
private int getCardBackgroundColor(TaskDescription task) {
    if (mCardColor != 0x0ffffff) {
        return mCardColor;
    } else if (task != null && task.cardColor != 0) {
        return task.cardColor;
    } else {
        return mContext.getResources().getColor(R.color.recents_task_bar_default_background_color);
    }
}
#end_block

#method_before
@Override
protected Bitmap doInBackground(Integer... params) {
    mLoaded = false;
    mLRUCacheKey = null;
    // Save current thread priority and set it during the loading
    // to background priority.
    mOrigPri = Process.getThreadPriority(Process.myTid());
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
    if (isCancelled() || rContext == null) {
        return null;
    }
    mLRUCacheKey = String.valueOf(params[0]);
    // Load and return bitmap
    return loadThumbnail(params[0], rContext.get(), mScaleFactor);
}
#method_after
@Override
protected Bitmap doInBackground(Integer... params) {
    mLoaded = false;
    Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
    if (isCancelled() || rContext == null) {
        return null;
    }
    // Load and return bitmap
    return loadThumbnail(params[0], rContext.get(), mScaleFactor);
}
#end_block

#method_before
@Override
protected void onPostExecute(Bitmap bitmap) {
    if (isCancelled()) {
        bitmap = null;
    }
    // Restore original thread priority.
    Process.setThreadPriority(mOrigPri);
    // Assign image to the view.
    mLoaded = true;
    if (mCallback != null) {
        mCallback.onBitmapLoaded(bitmap);
        if (bitmap != null && rContext != null) {
            final Context context = rContext.get();
            if (context != null) {
                // Put the loaded bitmap into the LRU cache for later use.
                CacheController.getInstance(context).addBitmapToMemoryCache(mLRUCacheKey, bitmap);
            }
        }
    }
}
#method_after
@Override
protected void onPostExecute(Bitmap bitmap) {
    if (isCancelled()) {
        bitmap = null;
    }
    // Assign image to the view.
    mLoaded = true;
    if (mCallback != null) {
        mCallback.onBitmapLoaded(bitmap);
    }
}
#end_block

#method_before
@Override
public void onBindViewHolder(final ViewHolder holder, final int position) {
    ExpandableCard card = mCards.get(position);
    updateExpand(holder, card.expanded, false);
    if (card.customIcon) {
        holder.expandButton.setImageDrawable(card.custom);
        holder.expandButton.setOnClickListener(card.customClickListener);
    } else {
        holder.expandButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                ExpandableCard expand = mCards.get(holder.getAdapterPosition());
                expand.expanded = !expand.expanded;
                updateExpand(holder, expand.expanded, true);
                if (card.expandListener != null) {
                    card.expandListener.onExpanded(expand.expanded);
                }
            }
        });
    }
    holder.expandButton.setVisibility((card.expandVisible || card.customIcon) ? View.VISIBLE : View.GONE);
    if (card.cardClickListener != null) {
        holder.itemView.setOnClickListener(card.cardClickListener);
    }
    if (card.cardBackgroundColor != 0) {
        holder.card.setCardBackgroundColor(card.cardBackgroundColor);
        int color;
        if (ColorUtils.isDarkColor(card.cardBackgroundColor)) {
            color = mContext.getColor(R.color.recents_task_bar_light_text_color);
        } else {
            color = mContext.getColor(R.color.recents_task_bar_dark_text_color);
        }
        holder.appName.setTextColor(color);
        holder.expandButton.setColorFilter(color, PorterDuff.Mode.MULTIPLY);
    }
    holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {

        @Override
        public boolean onLongClick(View v) {
            mCards.get(holder.getAdapterPosition()).optionsShown = true;
            int[] temp = new int[2];
            v.getLocationOnScreen(temp);
            int x = holder.upX - temp[0];
            int y = holder.upY - temp[1];
            holder.showOptions(x, y);
            return true;
        }
    });
    holder.itemView.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            holder.upX = (int) event.getRawX();
            holder.upY = (int) event.getRawY();
            return false;
        }
    });
    if (card.appIcon != null) {
        holder.appIcon.setImageDrawable(card.appIcon);
    } else {
        holder.appIcon.setImageResource(android.R.drawable.sym_def_app_icon);
    }
    if (card.appIconLongClickListener != null) {
        holder.appIcon.setOnLongClickListener(card.appIconLongClickListener);
    }
    holder.favorite.setVisibility(card.favorite ? View.VISIBLE : View.GONE);
    holder.appName.setText(card.appName);
    if (card.screenshot != null && !card.screenshot.isRecycled()) {
        holder.screenshot.setImageBitmap(card.screenshot);
    }
    LayoutInflater inflater = LayoutInflater.from(mContext);
    int backgroundColor = holder.card.getCardBackgroundColor().getDefaultColor();
    if (ColorUtils.isDarkColor(backgroundColor)) {
        holder.optionsView.setBackgroundColor(ColorUtils.lightenColor(backgroundColor));
    } else {
        holder.optionsView.setBackgroundColor(ColorUtils.darkenColor(backgroundColor));
    }
    holder.optionsView.removeAllViewsInLayout();
    for (final OptionsItem item : mCards.get(position).mOptions) {
        ImageView option = (ImageView) inflater.inflate(R.layout.options_item, holder.optionsView, false);
        option.setImageDrawable(item.icon);
        option.setId(item.id);
        option.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                if (item.clickListener != null) {
                    item.clickListener.onClick(v);
                }
                mCards.get(holder.getAdapterPosition()).optionsShown = false;
                int[] temp = new int[2];
                v.getLocationOnScreen(temp);
                int x = holder.upX - temp[0];
                int y = holder.upY - temp[1];
                holder.hideOptions(x, y);
            }
        });
        holder.optionsView.addView(option);
    }
}
#method_after
@Override
public void onBindViewHolder(final ViewHolder holder, final int position) {
    ExpandableCard card = mCards.get(position);
    holder.screenshot.setVisibility(card.expanded ? View.VISIBLE : View.GONE);
    holder.expandButton.setRotation(card.expanded ? -180 : 0);
    if (card.customIcon) {
        holder.expandButton.setImageDrawable(card.custom);
        holder.expandButton.setOnClickListener(card.customClickListener);
    } else {
        holder.expandButton.setImageResource(R.drawable.ic_expand);
        holder.expandButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                ExpandableCard expand = mCards.get(holder.getAdapterPosition());
                expand.expanded = !expand.expanded;
                if (card.expandListener != null) {
                    card.expandListener.onExpanded(expand.expanded);
                }
                Fade trans = new Fade();
                trans.setDuration(150);
                TransitionManager.beginDelayedTransition((ViewGroup) holder.itemView.getParent(), trans);
                holder.expandButton.animate().rotation(expand.expanded ? -180 : 0);
                notifyItemChanged(position);
            }
        });
    }
    holder.expandButton.setVisibility((card.expandVisible || card.customIcon) ? View.VISIBLE : View.GONE);
    if (card.cardClickListener != null) {
        holder.itemView.setOnClickListener(card.cardClickListener);
    }
    if (card.cardBackgroundColor != 0) {
        holder.card.setCardBackgroundColor(card.cardBackgroundColor);
        int color;
        if (ColorUtils.isDarkColor(card.cardBackgroundColor)) {
            color = mContext.getColor(R.color.recents_task_bar_light_text_color);
        } else {
            color = mContext.getColor(R.color.recents_task_bar_dark_text_color);
        }
        holder.appName.setTextColor(color);
        holder.expandButton.setColorFilter(color, PorterDuff.Mode.MULTIPLY);
    }
    holder.hideOptions(-1, -1);
    holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {

        @Override
        public boolean onLongClick(View v) {
            mCards.get(holder.getAdapterPosition()).optionsShown = true;
            int[] temp = new int[2];
            v.getLocationOnScreen(temp);
            int x = holder.upX - temp[0];
            int y = holder.upY - temp[1];
            holder.showOptions(x, y);
            return true;
        }
    });
    holder.itemView.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            holder.upX = (int) event.getRawX();
            holder.upY = (int) event.getRawY();
            return false;
        }
    });
    if (card.appIcon != null) {
        holder.appIcon.setImageDrawable(card.appIcon);
    } else {
        holder.appIcon.setImageResource(android.R.drawable.sym_def_app_icon);
    }
    if (card.appIconLongClickListener != null) {
        holder.appIcon.setOnLongClickListener(card.appIconLongClickListener);
    }
    holder.favorite.setVisibility(card.favorite ? View.VISIBLE : View.GONE);
    holder.appName.setText(card.appName);
    if (card.screenshot != null && !card.screenshot.isRecycled()) {
        holder.screenshot.setImageBitmap(card.screenshot);
    }
    LayoutInflater inflater = LayoutInflater.from(mContext);
    int backgroundColor = holder.card.getCardBackgroundColor().getDefaultColor();
    if (ColorUtils.isDarkColor(backgroundColor)) {
        holder.optionsView.setBackgroundColor(ColorUtils.lightenColor(backgroundColor));
    } else {
        holder.optionsView.setBackgroundColor(ColorUtils.darkenColor(backgroundColor));
    }
    holder.optionsView.removeAllViewsInLayout();
    for (final OptionsItem item : mCards.get(position).mOptions) {
        ImageView option = (ImageView) inflater.inflate(R.layout.options_item, holder.optionsView, false);
        option.setImageDrawable(item.icon);
        option.setId(item.id);
        option.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                if (item.clickListener != null) {
                    item.clickListener.onClick(v);
                }
                mCards.get(holder.getAdapterPosition()).optionsShown = false;
                int[] temp = new int[2];
                v.getLocationOnScreen(temp);
                int x = holder.upX - temp[0];
                int y = holder.upY - temp[1];
                holder.hideOptions(x, y);
            }
        });
        holder.optionsView.addView(option);
    }
}
#end_block

#method_before
public void removeCard(int pos) {
    mCards.remove(pos);
    notifyItemRemoved(pos);
    notifyItemRangeChanged(pos, getItemCount());
}
#method_after
public void removeCard(ExpandableCard card) {
    removeCard(mCards.indexOf(card));
}
#end_block

#method_before
public boolean hideRecents(boolean forceHide) {
    if (isShowing()) {
        mIsPreloaded = false;
        mIsToggled = false;
        mIsShowing = false;
        mRecentPanelView.setTasksLoaded(false);
        mRecentPanelView.dismissPopup();
        if (forceHide) {
            if (DEBUG)
                Log.d(TAG, "force hide recent window");
            CacheController.getInstance(mContext).setRecentScreenShowing(false);
            mAnimationState = ANIMATION_STATE_NONE;
            mHandler.removeCallbacks(mRecentRunnable);
            mWindowManager.removeViewImmediate(mParentView);
            return true;
        } else if (mAnimationState != ANIMATION_STATE_OUT) {
            if (DEBUG)
                Log.d(TAG, "out animation starting");
            mAnimationState = ANIMATION_STATE_OUT;
            mHandler.removeCallbacks(mRecentRunnable);
            mHandler.postDelayed(mRecentRunnable, mContext.getResources().getInteger(org.slim.framework.internal.R.integer.config_recentDefaultDur));
            mWindowManager.removeView(mParentView);
            return true;
        }
    }
    return false;
}
#method_after
public boolean hideRecents(boolean forceHide) {
    if (isShowing()) {
        mIsPreloaded = false;
        mIsToggled = false;
        mIsShowing = false;
        mRecentPanelView.setTasksLoaded(false);
        if (forceHide) {
            if (DEBUG)
                Log.d(TAG, "force hide recent window");
            mAnimationState = ANIMATION_STATE_NONE;
            mHandler.removeCallbacks(mRecentRunnable);
            mWindowManager.removeViewImmediate(mParentView);
            return true;
        } else if (mAnimationState != ANIMATION_STATE_OUT) {
            if (DEBUG)
                Log.d(TAG, "out animation starting");
            mAnimationState = ANIMATION_STATE_OUT;
            mHandler.removeCallbacks(mRecentRunnable);
            mHandler.postDelayed(mRecentRunnable, mContext.getResources().getInteger(org.slim.framework.internal.R.integer.config_recentDefaultDur));
            mWindowManager.removeView(mParentView);
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void showRecents() {
    if (DEBUG)
        Log.d(TAG, "in animation starting");
    mIsShowing = true;
    sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
    mAnimationState = ANIMATION_STATE_NONE;
    mHandler.removeCallbacks(mRecentRunnable);
    CacheController.getInstance(mContext).setRecentScreenShowing(true);
    mWindowManager.addView(mParentView, generateLayoutParameter());
    mRecentPanelView.scrollToFirst();
}
#method_after
private void showRecents() {
    if (DEBUG)
        Log.d(TAG, "in animation starting");
    mIsShowing = true;
    sendCloseSystemWindows(BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
    mAnimationState = ANIMATION_STATE_NONE;
    mHandler.removeCallbacks(mRecentRunnable);
    mWindowManager.addView(mParentView, generateLayoutParameter());
    mRecentPanelView.scrollToFirst();
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_GRAVITY), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_SCALE_FACTOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_EXPANDED_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_SHOW_TOPMOST), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_BG_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_SHOW_RUNNING_TASKS), false, this, UserHandle.USER_ALL);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_GRAVITY), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_SCALE_FACTOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_EXPANDED_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_SHOW_TOPMOST), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_PANEL_BG_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_SHOW_RUNNING_TASKS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.RECENT_CARD_BG_COLOR), false, this, UserHandle.USER_ALL);
    update();
}
#end_block

#method_before
public void update() {
    // Close recent panel if it is opened.
    hideRecents(false);
    ContentResolver resolver = mContext.getContentResolver();
    // Get user gravity.
    mUserGravity = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_GRAVITY, Gravity.RIGHT, UserHandle.USER_CURRENT);
    // Set main gravity and background images.
    setGravityAndImageResources();
    // Get user scale factor.
    float scaleFactor = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_SCALE_FACTOR, 100, UserHandle.USER_CURRENT) / 100.0f;
    // and notify RecentPanelView about new value.
    if (scaleFactor != mScaleFactor) {
        mScaleFactor = scaleFactor;
        rebuildRecentsScreen();
    }
    if (mRecentPanelView != null) {
        mRecentPanelView.setScaleFactor(mScaleFactor);
        mRecentPanelView.setExpandedMode(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_EXPANDED_MODE, mRecentPanelView.EXPANDED_MODE_AUTO, UserHandle.USER_CURRENT));
        mRecentPanelView.setShowTopTask(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_SHOW_TOPMOST, 0, UserHandle.USER_CURRENT) == 1);
        mRecentPanelView.setShowOnlyRunningTasks(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_SHOW_RUNNING_TASKS, 0, UserHandle.USER_CURRENT) == 1);
    }
    // Update colors in RecentPanelView
    mPanelColor = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_BG_COLOR, 0x00ffffff, UserHandle.USER_CURRENT);
    mRecentContent.setElevation(50);
    if (mPanelColor != 0x00ffffff) {
        mRecentContent.setBackgroundColor(mPanelColor);
    } else {
        mRecentContent.setBackgroundColor(mContext.getResources().getColor(R.color.recent_background));
    }
}
#method_after
public void update() {
    // Close recent panel if it is opened.
    hideRecents(false);
    ContentResolver resolver = mContext.getContentResolver();
    // Get user gravity.
    mUserGravity = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_GRAVITY, Gravity.RIGHT, UserHandle.USER_CURRENT);
    // Set main gravity and background images.
    setGravityAndImageResources();
    // Get user scale factor.
    float scaleFactor = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_SCALE_FACTOR, 100, UserHandle.USER_CURRENT) / 100.0f;
    // and notify RecentPanelView about new value.
    if (scaleFactor != mScaleFactor) {
        mScaleFactor = scaleFactor;
        rebuildRecentsScreen();
    }
    if (mRecentPanelView != null) {
        mRecentPanelView.setScaleFactor(mScaleFactor);
        mRecentPanelView.setExpandedMode(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_EXPANDED_MODE, mRecentPanelView.EXPANDED_MODE_AUTO, UserHandle.USER_CURRENT));
        mRecentPanelView.setShowTopTask(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_SHOW_TOPMOST, 0, UserHandle.USER_CURRENT) == 1);
        mRecentPanelView.setShowOnlyRunningTasks(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_SHOW_RUNNING_TASKS, 0, UserHandle.USER_CURRENT) == 1);
        mRecentPanelView.setCardColor(SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_CARD_BG_COLOR, 0x00ffffff, UserHandle.USER_CURRENT));
    }
    // Update colors in RecentPanelView
    mPanelColor = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.RECENT_PANEL_BG_COLOR, 0x00ffffff, UserHandle.USER_CURRENT);
    mRecentContent.setElevation(50);
    if (mPanelColor != 0x00ffffff) {
        mRecentContent.setBackgroundColor(mPanelColor);
    } else {
        mRecentContent.setBackgroundColor(mContext.getResources().getColor(R.color.recent_background));
    }
}
#end_block

#method_before
@Override
protected Drawable doInBackground(ResolveInfo... params) {
    // Save current thread priority and set it during the loading
    // to background priority.
    // mOrigPri = Process.getThreadPriority(Process.myTid());
    Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
    if (isCancelled() || rContext == null) {
        return null;
    }
    // Load and return bitmap
    return getAppIcon(params[0], rContext.get(), mScaleFactor);
}
#method_after
@Override
protected Drawable doInBackground(ResolveInfo... params) {
    Process.setThreadPriority(Process.THREAD_PRIORITY_FOREGROUND);
    if (isCancelled() || rContext == null) {
        return null;
    }
    // Load and return bitmap
    return getAppIcon(params[0], rContext.get(), mScaleFactor);
}
#end_block

#method_before
@Override
protected void onPostExecute(Drawable bitmap) {
    if (isCancelled()) {
        bitmap = null;
    }
    // Restore original thread priority.
    // Process.setThreadPriority(mOrigPri);
    final Context context;
    if (rContext != null) {
        context = rContext.get();
    } else {
        context = null;
    }
    // #link:loadAppIcon
    if (mCallback != null) {
        mCallback.onDrawableLoaded(bitmap);
    }
    if (bitmap != null && context != null && bitmap instanceof BitmapDrawable) {
        // Put our bitmap intu LRU cache for later use.
        CacheController.getInstance(context).addBitmapDrawableToMemoryCache(mLRUCacheKey, (BitmapDrawable) bitmap);
    }
}
#method_after
@Override
protected void onPostExecute(Drawable bitmap) {
    if (isCancelled()) {
        bitmap = null;
    }
    final Context context;
    if (rContext != null) {
        context = rContext.get();
    } else {
        context = null;
    }
    // #link:loadAppIcon
    if (mCallback != null) {
        mCallback.onDrawableLoaded(bitmap);
    }
}
#end_block

#method_before
@Override
protected int getMetricsCategory() {
    return SlimMetricsLogger.PROX_AUTO_SPEAKER_SETTINGS;
}
#method_after
@Override
protected int getMetricsCategory() {
    return SlimMetricsLogger.PROXIMITY_AUTO_SPEAKER_SETTINGS;
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.prox_auto_speaker);
    // enable
    mProxSpeaker = (SlimSwitchPreference) findPreference(PROX_AUTO_SPEAKER);
    // during call only
    mProxSpeakerIncallOnly = (SlimSwitchPreference) findPreference(PROX_AUTO_SPEAKER_INCALL_ONLY);
    // delay
    mProxSpeakerDelay = (SlimSeekBarPreference) findPreference(PROX_AUTO_SPEAKER_DELAY);
    if (mProxSpeakerDelay != null) {
        mProxSpeakerDelay.setDefault(100);
        mProxSpeakerDelay.isMilliseconds(true);
        mProxSpeakerDelay.setInterval(1);
        mProxSpeakerDelay.minimumValue(100);
        mProxSpeakerDelay.multiplyValue(100);
        mProxSpeakerDelay.setOnPreferenceChangeListener(this);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.prox_auto_speaker);
}
#end_block

#method_before
private void getIcons(Resources res) {
    Drawable backIcon, backIconLand;
    ActionConfig actionConfig;
    String backIconUri = ActionConstants.ICON_EMPTY;
    for (int j = 0; j < mButtonsConfig.size(); j++) {
        actionConfig = mButtonsConfig.get(j);
        final String action = actionConfig.getClickAction();
        if (action.equals(ActionConstants.ACTION_BACK)) {
            backIconUri = actionConfig.getIcon();
        }
    }
    backIcon = ActionHelper.getActionIconImage(mContext, ActionConstants.ACTION_BACK, backIconUri);
    backIconLand = backIcon;
    boolean shouldColor = true;
    if (backIconUri != null && !backIconUri.equals(ActionConstants.ICON_EMPTY) && !backIconUri.startsWith(ActionConstants.SYSTEM_ICON_IDENTIFIER) && mNavBarButtonColorMode == 1) {
        shouldColor = false;
    }
    // update back buttons color
    if (shouldColor && mNavBarButtonColorMode != 3) {
        backIcon.mutate();
        backIcon.setTintMode(PorterDuff.Mode.MULTIPLY);
        backIcon.setTint(mNavBarButtonColor);
        backIconLand.mutate();
        backIconLand.setTintMode(PorterDuff.Mode.MULTIPLY);
        backIconLand.setTint(mNavBarButtonColor);
    }
    mBackIcon = new BackButtonDrawable(backIcon);
    mBackLandIcon = new BackButtonDrawable(backIconLand);
}
#method_after
private void getIcons(Resources res) {
    Drawable backIcon, backIconLand;
    ActionConfig actionConfig;
    String backIconUri = ActionConstants.ICON_EMPTY;
    for (int j = 0; j < mButtonsConfig.size(); j++) {
        actionConfig = mButtonsConfig.get(j);
        final String action = actionConfig.getClickAction();
        if (action.equals(ActionConstants.ACTION_BACK)) {
            backIconUri = actionConfig.getIcon();
        }
    }
    backIcon = ActionHelper.getActionIconImage(mContext, ActionConstants.ACTION_BACK, backIconUri);
    backIconLand = backIcon;
    boolean shouldColor = true;
    if (backIconUri != null && !backIconUri.equals(ActionConstants.ICON_EMPTY) && !backIconUri.startsWith(ActionConstants.SYSTEM_ICON_IDENTIFIER) && mNavBarButtonColorMode == 1) {
        shouldColor = false;
    }
    // update back buttons color
    if (shouldColor && mNavBarButtonColorMode != 3) {
        backIcon.mutate();
        backIcon.setTintMode(PorterDuff.Mode.MULTIPLY);
        backIcon.setTint(mNavBarButtonColor);
        backIconLand.mutate();
        backIconLand.setTintMode(PorterDuff.Mode.MULTIPLY);
        backIconLand.setTint(mNavBarButtonColor);
    }
    mBackIcon = backIcon;
    mBackLandIcon = backIconLand;
    // TOFIX - This will need updating
    mHomeIcon = res.getDrawable(R.drawable.ic_sysbar_home);
    mHomeLandIcon = mHomeIcon;
}
#end_block

#method_before
private void makeBar() {
    if (mButtonsConfig.isEmpty() || mButtonsConfig == null) {
        return;
    }
    mButtonIdList.clear();
    mRippleColor = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_GLOW_TINT, -2, UserHandle.USER_CURRENT);
    ((LinearLayout) mRot0.findViewById(R.id.nav_buttons)).removeAllViews();
    ((LinearLayout) mRot0.findViewById(R.id.lights_out)).removeAllViews();
    ((LinearLayout) mRot90.findViewById(R.id.nav_buttons)).removeAllViews();
    ((LinearLayout) mRot90.findViewById(R.id.lights_out)).removeAllViews();
    for (int i = 0; i <= 1; i++) {
        boolean landscape = (i == 1);
        LinearLayout navButtonLayout = (LinearLayout) (landscape ? mRot90.findViewById(R.id.nav_buttons) : mRot0.findViewById(R.id.nav_buttons));
        LinearLayout lightsOut = (LinearLayout) (landscape ? mRot90.findViewById(R.id.lights_out) : mRot0.findViewById(R.id.lights_out));
        // add left menu
        KeyButtonView leftMenuKeyView = generateMenuKey(landscape, KEY_MENU_LEFT);
        leftMenuKeyView.setLongClickCallback(mCallback);
        addButton(navButtonLayout, leftMenuKeyView, landscape);
        addLightsOutButton(lightsOut, leftMenuKeyView, landscape, true);
        mAppIsBinded = false;
        ActionConfig actionConfig;
        for (int j = 0; j < mButtonsConfig.size(); j++) {
            actionConfig = mButtonsConfig.get(j);
            KeyButtonView v = generateKey(landscape, actionConfig.getClickAction(), actionConfig.getLongpressAction(), actionConfig.getIcon());
            v.setTag((landscape ? "key_land_" : "key_") + j);
            addButton(navButtonLayout, v, landscape);
            addLightsOutButton(lightsOut, v, landscape, false);
            if (mButtonsConfig.size() == 3 && j != (mButtonsConfig.size() - 1)) {
                // add separator view here
                View separator = new View(mContext);
                separator.setLayoutParams(getSeparatorLayoutParams(landscape));
                addButton(navButtonLayout, separator, landscape);
                addLightsOutButton(lightsOut, separator, landscape, true);
            }
        }
        KeyButtonView rightMenuKeyView = generateMenuKey(landscape, KEY_MENU_RIGHT);
        rightMenuKeyView.setLongClickCallback(mCallback);
        addButton(navButtonLayout, rightMenuKeyView, landscape);
        addLightsOutButton(lightsOut, rightMenuKeyView, landscape, true);
        View imeSwitcher = generateMenuKey(landscape, KEY_IME_SWITCHER);
        addButton(navButtonLayout, imeSwitcher, landscape);
        addLightsOutButton(lightsOut, imeSwitcher, landscape, true);
    }
    setMenuVisibility(mShowMenu, true);
}
#method_after
private void makeBar() {
    if (mButtonsConfig.isEmpty() || mButtonsConfig == null) {
        return;
    }
    mButtonIdList.clear();
    mRippleColor = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_GLOW_TINT, -2, UserHandle.USER_CURRENT);
    ((LinearLayout) mRot0.findViewById(R.id.nav_buttons)).removeAllViews();
    ((LinearLayout) mRot0.findViewById(R.id.lights_out)).removeAllViews();
    ((LinearLayout) mRot90.findViewById(R.id.nav_buttons)).removeAllViews();
    ((LinearLayout) mRot90.findViewById(R.id.lights_out)).removeAllViews();
    for (int i = 0; i <= 1; i++) {
        boolean landscape = (i == 1);
        LinearLayout navButtonLayout = (LinearLayout) (landscape ? mRot90.findViewById(R.id.nav_buttons) : mRot0.findViewById(R.id.nav_buttons));
        LinearLayout lightsOut = (LinearLayout) (landscape ? mRot90.findViewById(R.id.lights_out) : mRot0.findViewById(R.id.lights_out));
        // add left menu
        KeyButtonView leftMenuKeyView = generateMenuKey(landscape, KEY_MENU_LEFT);
        leftMenuKeyView.setLongClickCallback(mCallback);
        addButton(navButtonLayout, leftMenuKeyView, landscape);
        addLightsOutButton(lightsOut, leftMenuKeyView, landscape, true);
        mAppIsBinded = false;
        ActionConfig actionConfig;
        for (int j = 0; j < mButtonsConfig.size(); j++) {
            actionConfig = mButtonsConfig.get(j);
            KeyButtonView v = generateKey(landscape, actionConfig.getClickAction(), actionConfig.getLongpressAction(), actionConfig.getIcon());
            v.setTag((landscape ? "key_land_" : "key_") + j);
            addButton(navButtonLayout, v, landscape);
            addLightsOutButton(lightsOut, v, landscape, false);
            if (mButtonsConfig.size() == 3 && j != (mButtonsConfig.size() - 1)) {
                // add separator view here
                View separator = new View(mContext);
                separator.setLayoutParams(getSeparatorLayoutParams(landscape));
                addButton(navButtonLayout, separator, landscape);
                addLightsOutButton(lightsOut, separator, landscape, true);
            }
        }
        KeyButtonView rightMenuKeyView = generateMenuKey(landscape, KEY_MENU_RIGHT);
        rightMenuKeyView.setLongClickCallback(mCallback);
        addButton(navButtonLayout, rightMenuKeyView, landscape);
        addLightsOutButton(lightsOut, rightMenuKeyView, landscape, true);
        View imeSwitcher = generateMenuKey(landscape, KEY_IME_SWITCHER);
        addButton(navButtonLayout, imeSwitcher, landscape);
        addLightsOutButton(lightsOut, imeSwitcher, landscape, true);
    }
    setMenuVisibility(mShowMenu, true);
}
#end_block

#method_before
public void setNavigationIconHints(int hints, boolean force) {
    if (!force && hints == mNavigationIconHints)
        return;
    final boolean backAlt = (hints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0;
    if ((mNavigationIconHints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0 && !backAlt) {
        mTransitionListener.onBackAltCleared();
    }
    if (DEBUG) {
        android.widget.Toast.makeText(getContext(), "Navigation icon hints = " + hints, 500).show();
    }
    mNavigationIconHints = hints;
    if (getBackButton() != null) {
        ((ImageView) getBackButton()).setImageDrawable(null);
        ((ImageView) getBackButton()).setImageDrawable(mVertical ? mBackLandIcon : mBackIcon);
    }
    mBackLandIcon.setImeVisible(backAlt);
    mBackIcon.setImeVisible(backAlt);
    final boolean showImeButton = ((hints & StatusBarManager.NAVIGATION_HINT_IME_SHOWN) != 0);
    if (getImeSwitchButton() != null) {
        getImeSwitchButton().setVisibility(showImeButton ? View.VISIBLE : View.GONE);
        mIsImeButtonVisible = showImeButton;
    }
    // Update menu button in case the IME state has changed.
    setMenuVisibility(mShowMenu, true);
    setDisabledFlags(mDisabledFlags, true);
}
#method_after
public void setNavigationIconHints(int hints, boolean force) {
    if (!force && hints == mNavigationIconHints)
        return;
    final boolean backAlt = (hints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0;
    if ((mNavigationIconHints & StatusBarManager.NAVIGATION_HINT_BACK_ALT) != 0 && !backAlt) {
        mTransitionListener.onBackAltCleared();
    }
    if (DEBUG) {
        android.widget.Toast.makeText(getContext(), "Navigation icon hints = " + hints, 500).show();
    }
    mNavigationIconHints = hints;
    if (getBackButton() != null) {
        ((ImageView) getBackButton()).setImageDrawable(null);
        ((ImageView) getBackButton()).setImageDrawable(mVertical ? mBackLandIcon : mBackIcon);
    }
    final boolean showImeButton = ((hints & StatusBarManager.NAVIGATION_HINT_IME_SHOWN) != 0);
    if (getImeSwitchButton() != null) {
        getImeSwitchButton().setVisibility(showImeButton ? View.VISIBLE : View.GONE);
        mIsImeButtonVisible = showImeButton;
    }
    // Update menu button in case the IME state has changed.
    setMenuVisibility(mShowMenu, true);
    setDisabledFlags(mDisabledFlags, true);
}
#end_block

#method_before
private void setUseFadingAnimations(boolean useFadingAnimations) {
    WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
    if (lp != null) {
        boolean old = lp.windowAnimations != 0;
        if (!old && useFadingAnimations) {
            lp.windowAnimations = R.style.Animation_NavigationBarFadeIn;
        } else if (old && !useFadingAnimations) {
            lp.windowAnimations = 0;
        } else {
            return;
        }
        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
        wm.updateViewLayout(this, lp);
    }
}
#method_after
private void setUseFadingAnimations(boolean useFadingAnimations) {
    if (!isAttachedToWindow())
        return;
    WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
    if (lp != null) {
        boolean old = lp.windowAnimations != 0;
        if (!old && useFadingAnimations) {
            lp.windowAnimations = R.style.Animation_NavigationBarFadeIn;
        } else if (old && !useFadingAnimations) {
            lp.windowAnimations = 0;
        } else {
            return;
        }
        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
        wm.updateViewLayout(this, lp);
    }
}
#end_block

#method_before
public void setSlippery(boolean newSlippery) {
    WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
    if (lp != null) {
        boolean oldSlippery = (lp.flags & WindowManager.LayoutParams.FLAG_SLIPPERY) != 0;
        if (!oldSlippery && newSlippery) {
            lp.flags |= WindowManager.LayoutParams.FLAG_SLIPPERY;
        } else if (oldSlippery && !newSlippery) {
            lp.flags &= ~WindowManager.LayoutParams.FLAG_SLIPPERY;
        } else {
            return;
        }
        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
        wm.updateViewLayout(this, lp);
    }
}
#method_after
public void setSlippery(boolean newSlippery) {
    if (!isAttachedToWindow())
        return;
    WindowManager.LayoutParams lp = (WindowManager.LayoutParams) getLayoutParams();
    if (lp != null) {
        boolean oldSlippery = (lp.flags & WindowManager.LayoutParams.FLAG_SLIPPERY) != 0;
        if (!oldSlippery && newSlippery) {
            lp.flags |= WindowManager.LayoutParams.FLAG_SLIPPERY;
        } else if (oldSlippery && !newSlippery) {
            lp.flags &= ~WindowManager.LayoutParams.FLAG_SLIPPERY;
        } else {
            return;
        }
        WindowManager wm = (WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE);
        wm.updateViewLayout(this, lp);
    }
}
#end_block

#method_before
public void reorient() {
    final int rot = mDisplay.getRotation();
    for (int i = 0; i < 4; i++) {
        mRotatedViews[i].setVisibility(View.GONE);
    }
    if (Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_CAN_MOVE, DeviceUtils.isPhone(mContext) ? 1 : 0, UserHandle.USER_CURRENT) != 1) {
        mCurrentView = mRotatedViews[Surface.ROTATION_0];
    } else {
        mCurrentView = mRotatedViews[rot];
    }
    mCurrentView.setVisibility(View.VISIBLE);
    updateLayoutTransitionsEnabled();
    if (getImeSwitchButton() != null)
        getImeSwitchButton().setOnClickListener(mImeSwitcherClickListener);
    mDeadZone = (DeadZone) mCurrentView.findViewById(R.id.deadzone);
    // force the low profile & disabled states into compliance
    mBarTransitions.init();
    setDisabledFlags(mDisabledFlags, true);
    setMenuVisibility(mShowMenu, true);
    if (DEBUG) {
        Log.d(TAG, "reorient(): rot=" + mDisplay.getRotation());
    }
    updateTaskSwitchHelper();
    setNavigationIconHints(mNavigationIconHints, true);
}
#method_after
public void reorient() {
    final int rot = mDisplay.getRotation();
    for (int i = 0; i < 4; i++) {
        mRotatedViews[i].setVisibility(View.GONE);
    }
    if (SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_CAN_MOVE, DeviceUtils.isPhone(mContext) ? 1 : 0, UserHandle.USER_CURRENT) != 1) {
        mCurrentView = mRotatedViews[Surface.ROTATION_0];
    } else {
        mCurrentView = mRotatedViews[rot];
    }
    mCurrentView.setVisibility(View.VISIBLE);
    updateLayoutTransitionsEnabled();
    if (getImeSwitchButton() != null)
        getImeSwitchButton().setOnClickListener(mImeSwitcherClickListener);
    mDeadZone = (DeadZone) mCurrentView.findViewById(R.id.deadzone);
    // force the low profile & disabled states into compliance
    mBarTransitions.init();
    setDisabledFlags(mDisabledFlags, true);
    setMenuVisibility(mShowMenu, true);
    if (DEBUG) {
        Log.d(TAG, "reorient(): rot=" + mDisplay.getRotation());
    }
    updateTaskSwitchHelper();
    setNavigationIconHints(mNavigationIconHints, true);
}
#end_block

#method_before
private void updateSettings(boolean recreate) {
    ContentResolver resolver = mContext.getContentResolver();
    mNavBarButtonColor = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_BUTTON_TINT, -2, UserHandle.USER_CURRENT);
    if (mNavBarButtonColor == -2) {
        mNavBarButtonColor = mContext.getResources().getColor(R.color.navigationbar_button_default_color);
    }
    mNavBarButtonColorMode = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE, 0, UserHandle.USER_CURRENT);
    mButtonsConfig = ActionHelper.getNavBarConfig(mContext);
    mMenuSetting = Settings.System.getIntForUser(resolver, Settings.System.MENU_LOCATION, SHOW_RIGHT_MENU, UserHandle.USER_CURRENT);
    mMenuVisibility = Settings.System.getIntForUser(resolver, Settings.System.MENU_VISIBILITY, MENU_VISIBILITY_SYSTEM, UserHandle.USER_CURRENT);
    getIcons(getContext().getResources());
    // construct the navigationbar
    if (recreate) {
        makeBar();
    }
}
#method_after
private void updateSettings(boolean recreate) {
    ContentResolver resolver = mContext.getContentResolver();
    mNavBarButtonColor = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT, -2, UserHandle.USER_CURRENT);
    if (mNavBarButtonColor == -2) {
        mNavBarButtonColor = mContext.getResources().getColor(R.color.navigationbar_button_default_color);
    }
    mNavBarButtonColorMode = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT_MODE, 0, UserHandle.USER_CURRENT);
    mButtonsConfig = ActionHelper.getNavBarConfig(mContext);
    mMenuSetting = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.MENU_LOCATION, SHOW_RIGHT_MENU, UserHandle.USER_CURRENT);
    mMenuVisibility = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.MENU_VISIBILITY, MENU_VISIBILITY_SYSTEM, UserHandle.USER_CURRENT);
    getIcons(getContext().getResources());
    // construct the navigationbar
    if (recreate) {
        makeBar();
    }
}
#end_block

#method_before
public boolean onTouchEvent(MotionEvent ev) {
    final int action = ev.getAction();
    int x, y;
    if (action == MotionEvent.ACTION_DOWN) {
        mGestureAborted = false;
    }
    if (mGestureAborted) {
        return false;
    }
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            mDownTime = SystemClock.uptimeMillis();
            mIsLongpressed = false;
            setPressed(true);
            if (mCode != 0) {
                sendEvent(KeyEvent.ACTION_DOWN, 0, mDownTime);
            }
            removeCallbacks(mCheckLongPress);
            postDelayed(mCheckLongPress, ViewConfiguration.getLongPressTimeout());
            break;
        case MotionEvent.ACTION_MOVE:
            x = (int) ev.getX();
            y = (int) ev.getY();
            setPressed(x >= -mTouchSlop && x < getWidth() + mTouchSlop && y >= -mTouchSlop && y < getHeight() + mTouchSlop);
            break;
        case MotionEvent.ACTION_CANCEL:
            setPressed(false);
            // hack to fix ripple getting stuck. exitHardware() starts an animation,
            // but sometimes does not finish it.
            mRipple.exitSoftware();
            if (mCode != 0) {
                sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);
            }
            removeCallbacks(mCheckLongPress);
            break;
        case MotionEvent.ACTION_UP:
            final boolean doIt = isPressed();
            setPressed(false);
            if (!mIsLongpressed) {
                if (mCode != 0) {
                    if (doIt) {
                        sendEvent(KeyEvent.ACTION_UP, 0);
                    } else {
                        sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);
                    }
                } else {
                    // no key code, it is a custom click action
                    if (doIt) {
                        if (mClickAction != null && !Action.isActionKeyEvent(mClickAction)) {
                            performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
                        }
                        performClick();
                    }
                }
                if (doIt) {
                    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
                }
            }
            removeCallbacks(mCheckLongPress);
            break;
    }
    return true;
}
#method_after
public boolean onTouchEvent(MotionEvent ev) {
    final int action = ev.getAction();
    int x, y;
    if (action == MotionEvent.ACTION_DOWN) {
        mGestureAborted = false;
    }
    if (mGestureAborted) {
        return false;
    }
    switch(action) {
        case MotionEvent.ACTION_DOWN:
            mDownTime = SystemClock.uptimeMillis();
            mIsLongpressed = false;
            setPressed(true);
            if (mClickAction.equals(ActionConstants.ACTION_RECENTS)) {
                try {
                    mStatusBar.preloadRecentApps();
                } catch (RemoteException e) {
                }
            }
            if (mCode != 0) {
                sendEvent(KeyEvent.ACTION_DOWN, 0, mDownTime);
            }
            removeCallbacks(mCheckLongPress);
            postDelayed(mCheckLongPress, ViewConfiguration.getLongPressTimeout());
            break;
        case MotionEvent.ACTION_MOVE:
            x = (int) ev.getX();
            y = (int) ev.getY();
            setPressed(x >= -mTouchSlop && x < getWidth() + mTouchSlop && y >= -mTouchSlop && y < getHeight() + mTouchSlop);
            break;
        case MotionEvent.ACTION_CANCEL:
            setPressed(false);
            if (mClickAction.equals(ActionConstants.ACTION_RECENTS)) {
                try {
                    mStatusBar.cancelPreloadRecentApps();
                } catch (RemoteException e) {
                }
            }
            // hack to fix ripple getting stuck. exitHardware() starts an animation,
            // but sometimes does not finish it.
            mRipple.exitSoftware();
            if (mCode != 0) {
                sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);
            }
            removeCallbacks(mCheckLongPress);
            break;
        case MotionEvent.ACTION_UP:
            final boolean doIt = isPressed();
            setPressed(false);
            if (!doIt && mClickAction.equals(ActionConstants.ACTION_RECENTS)) {
                try {
                    mStatusBar.cancelPreloadRecentApps();
                } catch (RemoteException e) {
                }
            }
            if (!mIsLongpressed) {
                if (mCode != 0) {
                    if (doIt) {
                        sendEvent(KeyEvent.ACTION_UP, 0);
                    } else {
                        sendEvent(KeyEvent.ACTION_UP, KeyEvent.FLAG_CANCELED);
                    }
                } else {
                    // no key code, it is a custom click action
                    if (doIt) {
                        if (mClickAction != null && !Action.isActionKeyEvent(mClickAction)) {
                            performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
                        }
                        performClick();
                    }
                }
                if (doIt) {
                    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
                }
            }
            removeCallbacks(mCheckLongPress);
            break;
    }
    return true;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CAN_MOVE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_HEIGHT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_HEIGHT_LANDSCAPE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_WIDTH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_SHOW), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CAN_MOVE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_HEIGHT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_HEIGHT_LANDSCAPE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_WIDTH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_SHOW), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
void observe() {
    // Observe all hw key users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEY_REBINDING), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_CAMERA_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    updateKeyAssignments();
}
#method_after
void observe() {
    // Observe all hw key users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_HOME_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_MENU_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_ASSIST_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_APP_SWITCH_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_BACK_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_BACK_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.HARDWARE_KEY_REBINDING), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_CAMERA_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_CAMERA_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.KEY_CAMERA_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    updateKeyAssignments();
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    if (mDeviceHardwareKeys > 0) {
        mHwKeySettingsObserver = new HwKeySettingsObserver(mHandler);
        mHwKeySettingsObserver.observe();
    }
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mActivityManagerInternal = LocalServices.getService(ActivityManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE);
    mPowerManagerInternal = LocalServices.getService(PowerManagerInternal.class);
    // Init display burn-in protection
    boolean burnInProtectionEnabled = context.getResources().getBoolean(com.android.internal.R.bool.config_enableBurnInProtection);
    // Allow a system property to override this. Used by developer settings.
    boolean burnInProtectionDevMode = SystemProperties.getBoolean("persist.debug.force_burn_in", false);
    if (burnInProtectionEnabled || burnInProtectionDevMode) {
        final int minHorizontal;
        final int maxHorizontal;
        final int minVertical;
        final int maxVertical;
        final int maxRadius;
        if (burnInProtectionDevMode) {
            minHorizontal = -8;
            maxHorizontal = 8;
            minVertical = -8;
            maxVertical = -4;
            maxRadius = (isRoundWindow()) ? 6 : -1;
        } else {
            Resources resources = context.getResources();
            minHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinHorizontalOffset);
            maxHorizontal = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxHorizontalOffset);
            minVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMinVerticalOffset);
            maxVertical = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxVerticalOffset);
            maxRadius = resources.getInteger(com.android.internal.R.integer.config_burnInProtectionMaxRadius);
        }
        mBurnInProtectionHelper = new BurnInProtectionHelper(context, minHorizontal, maxHorizontal, minVertical, maxVertical, maxRadius);
    }
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    if (mDeviceHardwareKeys > 0) {
        mHwKeySettingsObserver = new HwKeySettingsObserver(mHandler);
        mHwKeySettingsObserver.observe();
    }
    mShortcutManager = new ShortcutManager(context);
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mPowerKeyWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mPowerKeyWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mAllowTheaterModeWakeFromKey = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromKey);
    mAllowTheaterModeWakeFromPowerKey = mAllowTheaterModeWakeFromKey || mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromPowerKey);
    mAllowTheaterModeWakeFromMotion = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotion);
    mAllowTheaterModeWakeFromMotionWhenNotDreaming = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromMotionWhenNotDreaming);
    mAllowTheaterModeWakeFromCameraLens = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromCameraLens);
    mAllowTheaterModeWakeFromLidSwitch = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromLidSwitch);
    mAllowTheaterModeWakeFromWakeGesture = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowTheaterModeWakeFromGesture);
    mGoToSleepOnButtonPressTheaterMode = mContext.getResources().getBoolean(com.android.internal.R.bool.config_goToSleepOnButtonPressTheaterMode);
    mSupportLongPressPowerWhenNonInteractive = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportLongPressPowerWhenNonInteractive);
    mShortPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnPowerBehavior);
    mLongPressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnPowerBehavior);
    mDoublePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doublePressOnPowerBehavior);
    mTriplePressOnPowerBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_triplePressOnPowerBehavior);
    mShortPressOnSleepBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_shortPressOnSleepBehavior);
    mUseTvRouting = AudioSystem.getPlatformType(mContext) == AudioSystem.PLATFORM_TELEVISION;
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onFling(int duration) {
            if (mPowerManagerInternal != null) {
                mPowerManagerInternal.powerHint(PowerManagerInternal.POWER_HINT_INTERACTION, duration);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }

        @Override
        public void onDown() {
            mOrientationListener.onTouchStart();
        }

        @Override
        public void onUpOrCancel() {
            mOrientationListener.onTouchEnd();
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    /* Register for WIFI Display Intents */
    IntentFilter wifiDisplayFilter = new IntentFilter(ACTION_WIFI_DISPLAY_VIDEO);
    Intent wifidisplayIntent = context.registerReceiver(mWifiDisplayReceiver, wifiDisplayFilter);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mContextClickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_contextClickVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        startedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
        finishedGoingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    mWindowManagerInternal.registerAppTransitionListener(mStatusBarController.getAppTransitionListener());
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        DexClassLoader loader = new DexClassLoader(deviceKeyHandlerLib, new ContextWrapper(mContext).getCacheDir().getAbsolutePath(), null, ClassLoader.getSystemClassLoader());
        try {
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            if (DEBUG)
                Slog.d(TAG, "Device key handler loaded");
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#end_block

#method_before
private void updateKeyAssignments() {
    final boolean noMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) == 0;
    final boolean noBack = (mDeviceHardwareKeys & KEY_MASK_BACK) == 0;
    final boolean noHome = (mDeviceHardwareKeys & KEY_MASK_HOME) == 0;
    final boolean noAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) == 0;
    final boolean noAppSwitch = (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) == 0;
    final boolean noCamera = (mDeviceHardwareKeys & KEY_MASK_CAMERA) == 0;
    // Setup hardware keys
    boolean keyRebindingDisabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 0;
    // Home button
    mPressOnHomeBehavior = HwKeyHelper.getPressOnHomeBehavior(mContext, noHome || keyRebindingDisabled);
    mLongPressOnHomeBehavior = HwKeyHelper.getLongPressOnHomeBehavior(mContext, noHome || keyRebindingDisabled);
    mDoubleTapOnHomeBehavior = HwKeyHelper.getDoubleTapOnHomeBehavior(mContext, noHome || keyRebindingDisabled);
    // Menu button
    mPressOnMenuBehavior = HwKeyHelper.getPressOnMenuBehavior(mContext, noMenu || keyRebindingDisabled);
    mLongPressOnMenuBehavior = HwKeyHelper.getLongPressOnMenuBehavior(mContext, noMenu || keyRebindingDisabled, noMenu || !noAssist);
    mDoubleTapOnMenuBehavior = HwKeyHelper.getDoubleTapOnMenuBehavior(mContext, noMenu || keyRebindingDisabled);
    // Back button
    mPressOnBackBehavior = HwKeyHelper.getPressOnBackBehavior(mContext, noBack || keyRebindingDisabled);
    mLongPressOnBackBehavior = HwKeyHelper.getLongPressOnBackBehavior(mContext, noBack || keyRebindingDisabled);
    mDoubleTapOnBackBehavior = HwKeyHelper.getDoubleTapOnBackBehavior(mContext, noBack || keyRebindingDisabled);
    // Assist button
    mPressOnAssistBehavior = HwKeyHelper.getPressOnAssistBehavior(mContext, noAssist || keyRebindingDisabled);
    mLongPressOnAssistBehavior = HwKeyHelper.getLongPressOnAssistBehavior(mContext, noAssist || keyRebindingDisabled);
    mDoubleTapOnAssistBehavior = HwKeyHelper.getDoubleTapOnAssistBehavior(mContext, noAssist || keyRebindingDisabled);
    // App switcher button
    mPressOnAppSwitchBehavior = HwKeyHelper.getPressOnAppSwitchBehavior(mContext, noAppSwitch || keyRebindingDisabled);
    mLongPressOnAppSwitchBehavior = HwKeyHelper.getLongPressOnAppSwitchBehavior(mContext, noAppSwitch || keyRebindingDisabled);
    mDoubleTapOnAppSwitchBehavior = HwKeyHelper.getDoubleTapOnAppSwitchBehavior(mContext, noAppSwitch || keyRebindingDisabled);
    // Camera button
    mPressOnCameraBehavior = HwKeyHelper.getPressOnCameraBehavior(mContext, noCamera || keyRebindingDisabled);
    mLongPressOnCameraBehavior = HwKeyHelper.getLongPressOnCameraBehavior(mContext, noCamera || keyRebindingDisabled);
    mDoubleTapOnCameraBehavior = HwKeyHelper.getDoubleTapOnCameraBehavior(mContext, noCamera || keyRebindingDisabled);
}
#method_after
private void updateKeyAssignments() {
    final boolean noMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) == 0;
    final boolean noBack = (mDeviceHardwareKeys & KEY_MASK_BACK) == 0;
    final boolean noHome = (mDeviceHardwareKeys & KEY_MASK_HOME) == 0;
    final boolean noAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) == 0;
    final boolean noAppSwitch = (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) == 0;
    final boolean noCamera = (mDeviceHardwareKeys & KEY_MASK_CAMERA) == 0;
    // Setup hardware keys
    boolean keyRebindingDisabled = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 0;
    // Home button
    mPressOnHomeBehavior = HwKeyHelper.getPressOnHomeBehavior(mContext, noHome || keyRebindingDisabled);
    mLongPressOnHomeBehavior = HwKeyHelper.getLongPressOnHomeBehavior(mContext, noHome || keyRebindingDisabled);
    mDoubleTapOnHomeBehavior = HwKeyHelper.getDoubleTapOnHomeBehavior(mContext, noHome || keyRebindingDisabled);
    // Menu button
    mPressOnMenuBehavior = HwKeyHelper.getPressOnMenuBehavior(mContext, noMenu || keyRebindingDisabled);
    mLongPressOnMenuBehavior = HwKeyHelper.getLongPressOnMenuBehavior(mContext, noMenu || keyRebindingDisabled, noMenu || !noAssist);
    mDoubleTapOnMenuBehavior = HwKeyHelper.getDoubleTapOnMenuBehavior(mContext, noMenu || keyRebindingDisabled);
    // Back button
    mPressOnBackBehavior = HwKeyHelper.getPressOnBackBehavior(mContext, noBack || keyRebindingDisabled);
    mLongPressOnBackBehavior = HwKeyHelper.getLongPressOnBackBehavior(mContext, noBack || keyRebindingDisabled);
    mDoubleTapOnBackBehavior = HwKeyHelper.getDoubleTapOnBackBehavior(mContext, noBack || keyRebindingDisabled);
    // Assist button
    mPressOnAssistBehavior = HwKeyHelper.getPressOnAssistBehavior(mContext, noAssist || keyRebindingDisabled);
    mLongPressOnAssistBehavior = HwKeyHelper.getLongPressOnAssistBehavior(mContext, noAssist || keyRebindingDisabled);
    mDoubleTapOnAssistBehavior = HwKeyHelper.getDoubleTapOnAssistBehavior(mContext, noAssist || keyRebindingDisabled);
    // App switcher button
    mPressOnAppSwitchBehavior = HwKeyHelper.getPressOnAppSwitchBehavior(mContext, noAppSwitch || keyRebindingDisabled);
    mLongPressOnAppSwitchBehavior = HwKeyHelper.getLongPressOnAppSwitchBehavior(mContext, noAppSwitch || keyRebindingDisabled);
    mDoubleTapOnAppSwitchBehavior = HwKeyHelper.getDoubleTapOnAppSwitchBehavior(mContext, noAppSwitch || keyRebindingDisabled);
    // Camera button
    mPressOnCameraBehavior = HwKeyHelper.getPressOnCameraBehavior(mContext, noCamera || keyRebindingDisabled);
    mLongPressOnCameraBehavior = HwKeyHelper.getLongPressOnCameraBehavior(mContext, noCamera || keyRebindingDisabled);
    mDoubleTapOnCameraBehavior = HwKeyHelper.getDoubleTapOnCameraBehavior(mContext, noCamera || keyRebindingDisabled);
}
#end_block

#method_before
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // or for other displays we don't care about.
    if (mContext == null || display.getDisplayId() != Display.DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    mPanelOrientation = SystemProperties.getInt("persist.panel.orientation", 0) / 90;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    mStatusBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    // SystemUI (status bar) layout policy
    mShortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on small devices (phones).
    mNavigationBarCanMove = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_CAN_MOVE, mShortSizeDp < 600 ? 1 : 0, UserHandle.USER_CURRENT) == 1;
    final int showByDefault = mContext.getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar) ? 1 : 0;
    mHasNavigationBar = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_SHOW, showByDefault, UserHandle.USER_CURRENT) == 1;
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    mForceDefaultOrientation = longSizeDp >= 960 && mShortSizeDp >= 720 && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#method_after
@Override
public void setInitialDisplaySize(Display display, int width, int height, int density) {
    // or for other displays we don't care about.
    if (mContext == null || display.getDisplayId() != Display.DEFAULT_DISPLAY) {
        return;
    }
    mDisplay = display;
    mPanelOrientation = SystemProperties.getInt("persist.panel.orientation", 0) / 90;
    final Resources res = mContext.getResources();
    int shortSize, longSize;
    if (width > height) {
        shortSize = height;
        longSize = width;
        mLandscapeRotation = Surface.ROTATION_0;
        mSeascapeRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mPortraitRotation = Surface.ROTATION_90;
            mUpsideDownRotation = Surface.ROTATION_270;
        } else {
            mPortraitRotation = Surface.ROTATION_270;
            mUpsideDownRotation = Surface.ROTATION_90;
        }
    } else {
        shortSize = width;
        longSize = height;
        mPortraitRotation = Surface.ROTATION_0;
        mUpsideDownRotation = Surface.ROTATION_180;
        if (res.getBoolean(com.android.internal.R.bool.config_reverseDefaultRotation)) {
            mLandscapeRotation = Surface.ROTATION_270;
            mSeascapeRotation = Surface.ROTATION_90;
        } else {
            mLandscapeRotation = Surface.ROTATION_90;
            mSeascapeRotation = Surface.ROTATION_270;
        }
    }
    mStatusBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    // SystemUI (status bar) layout policy
    mShortSizeDp = shortSize * DisplayMetrics.DENSITY_DEFAULT / density;
    int longSizeDp = longSize * DisplayMetrics.DENSITY_DEFAULT / density;
    // Allow the navigation bar to move on small devices (phones).
    mNavigationBarCanMove = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_CAN_MOVE, mShortSizeDp < 600 ? 1 : 0, UserHandle.USER_CURRENT) == 1;
    final int showByDefault = mContext.getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar) ? 1 : 0;
    mHasNavigationBar = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_SHOW, showByDefault, UserHandle.USER_CURRENT) == 1;
    // Allow a system property to override this. Used by the emulator.
    // See also hasNavigationBar().
    String navBarOverride = SystemProperties.get("qemu.hw.mainkeys");
    if ("1".equals(navBarOverride)) {
        mHasNavigationBar = false;
    } else if ("0".equals(navBarOverride)) {
        mHasNavigationBar = true;
    }
    // By default, HDMI locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.hdmirotation"))) {
        mDemoHdmiRotation = mPortraitRotation;
    } else {
        mDemoHdmiRotation = mLandscapeRotation;
    }
    mDemoHdmiRotationLock = SystemProperties.getBoolean("persist.demo.hdmirotationlock", false);
    // By default, remote display locks rotation to landscape.
    if ("portrait".equals(SystemProperties.get("persist.demo.remoterotation"))) {
        mDemoRotation = mPortraitRotation;
    } else {
        mDemoRotation = mLandscapeRotation;
    }
    mDemoRotationLock = SystemProperties.getBoolean("persist.demo.rotationlock", false);
    // Only force the default orientation if the screen is xlarge, at least 960dp x 720dp, per
    // http://developer.android.com/guide/practices/screens_support.html#range
    mForceDefaultOrientation = longSizeDp >= 960 && mShortSizeDp >= 720 && res.getBoolean(com.android.internal.R.bool.config_forceDefaultOrientation) && // $ adb shell wm size reset
    !"true".equals(SystemProperties.get("config.override_forced_orient"));
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mNavigationBarCanMove = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_CAN_MOVE, mShortSizeDp < 600 ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        final int showByDefault = mContext.getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar) ? 1 : 0;
        mHasNavigationBar = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_SHOW, showByDefault, UserHandle.USER_CURRENT) == 1;
        if (!mHasNavigationBar) {
            // Set the navigation bar's dimensions to 0 in expanded desktop mode
            mNavigationBarWidthForRotation[mPortraitRotation] = mNavigationBarWidthForRotation[mUpsideDownRotation] = mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] = mNavigationBarHeightForRotation[mPortraitRotation] = mNavigationBarHeightForRotation[mUpsideDownRotation] = mNavigationBarHeightForRotation[mLandscapeRotation] = mNavigationBarHeightForRotation[mSeascapeRotation] = 0;
        } else {
            // Height of the navigation bar when presented horizontally at bottom *******
            mNavigationBarHeightForRotation[mPortraitRotation] = mNavigationBarHeightForRotation[mUpsideDownRotation] = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_HEIGHT, mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height), UserHandle.USER_CURRENT);
            mNavigationBarHeightForRotation[mLandscapeRotation] = mNavigationBarHeightForRotation[mSeascapeRotation] = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_HEIGHT_LANDSCAPE, mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_landscape), UserHandle.USER_CURRENT);
            // Width of the navigation bar when presented vertically along one side
            mNavigationBarWidthForRotation[mPortraitRotation] = mNavigationBarWidthForRotation[mUpsideDownRotation] = mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.NAVIGATION_BAR_WIDTH, mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width), UserHandle.USER_CURRENT);
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        WindowManagerPolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mNavigationBarCanMove = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.NAVIGATION_BAR_CAN_MOVE, mShortSizeDp < 600 ? 1 : 0, UserHandle.USER_CURRENT) == 1;
        final int showByDefault = mContext.getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar) ? 1 : 0;
        mHasNavigationBar = SlimSettings.System.getIntForUser(resolver, SlimSettings.System.NAVIGATION_BAR_SHOW, showByDefault, UserHandle.USER_CURRENT) == 1;
        if (!mHasNavigationBar) {
            // Set the navigation bar's dimensions to 0 in expanded desktop mode
            mNavigationBarWidthForRotation[mPortraitRotation] = mNavigationBarWidthForRotation[mUpsideDownRotation] = mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] = mNavigationBarHeightForRotation[mPortraitRotation] = mNavigationBarHeightForRotation[mUpsideDownRotation] = mNavigationBarHeightForRotation[mLandscapeRotation] = mNavigationBarHeightForRotation[mSeascapeRotation] = 0;
        } else {
            // Height of the navigation bar when presented horizontally at bottom *******
            mNavigationBarHeightForRotation[mPortraitRotation] = mNavigationBarHeightForRotation[mUpsideDownRotation] = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_HEIGHT, mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height), UserHandle.USER_CURRENT);
            mNavigationBarHeightForRotation[mLandscapeRotation] = mNavigationBarHeightForRotation[mSeascapeRotation] = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_HEIGHT_LANDSCAPE, mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_height_landscape), UserHandle.USER_CURRENT);
            // Width of the navigation bar when presented vertically along one side
            mNavigationBarWidthForRotation[mPortraitRotation] = mNavigationBarWidthForRotation[mUpsideDownRotation] = mNavigationBarWidthForRotation[mLandscapeRotation] = mNavigationBarWidthForRotation[mSeascapeRotation] = SlimSettings.System.getIntForUser(mContext.getContentResolver(), SlimSettings.System.NAVIGATION_BAR_WIDTH, mContext.getResources().getDimensionPixelSize(com.android.internal.R.dimen.navigation_bar_width), UserHandle.USER_CURRENT);
        }
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
    }
    synchronized (mWindowManagerFuncs.getWindowManagerLock()) {
        PolicyControl.reloadFromSetting(mContext);
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " longPress=" + longPress + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // If the boot mode is power off alarm, we should not dispatch the several physical keys
    // in power off alarm UI to avoid pausing power off alarm UI.
    int isPowerOffAlarmMode = Settings.System.getInt(mContext.getContentResolver(), Settings.System.POWER_OFF_ALARM_MODE, 0);
    if (DEBUG_INPUT) {
        Log.d(TAG, "intercept Dispatching isPowerOffAlarmMode = " + isPowerOffAlarmMode);
    }
    if (isPowerOffAlarmMode == 1 && (keyCode == KeyEvent.KEYCODE_HOME || keyCode == KeyEvent.KEYCODE_SEARCH || keyCode == KeyEvent.KEYCODE_MENU)) {
        // ignore the physical key here
        return -1;
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnHomeBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            if (!virtualKey && !mPressOnHomeBehavior.equals(ActionConstants.ACTION_HOME)) {
                if (!mPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnHomeBehavior);
                Action.processAction(mContext, mPressOnHomeBehavior, false);
                return -1;
            }
            // Go home
            launchHomeFromHotKey();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (virtualKey && down) {
            mHomePressed = true;
            mHomeConsumed = false;
            return -1;
        }
        // Remember that home is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mHomePressed = true;
                if (mHomeDoubleTapPending) {
                    mHomeDoubleTapPending = false;
                    mDisableVibration = false;
                    mHomeConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnHomeBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnHomeBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnHomeBehavior, false);
                    mHomeConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        // while it was pressed, then it is time to process the menu action!
        if (!down && mMenuPressed) {
            mMenuPressed = false;
            if (mMenuConsumed) {
                mMenuConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring MENU; event canceled.");
                return -1;
            }
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcast(intent, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
            // Delay handling menu if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnMenuBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mMenuDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnMenuBehavior);
                Action.processAction(mContext, mPressOnMenuBehavior, false);
                return -1;
            }
        }
        if (virtualKey && down) {
            mMenuPressed = true;
            mMenuConsumed = false;
        } else if (down) {
            // Remember that menu is pressed and handle special actions.
            if (!mPreloadedRecentApps && (mLongPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mMenuPressed = true;
                if (mMenuDoubleTapPending) {
                    mMenuDoubleTapPending = false;
                    mDisableVibration = false;
                    mMenuConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnMenuBehavior, false);
                    return -1;
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnMenuBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnMenuBehavior, false);
                    mMenuConsumed = true;
                    return -1;
                }
            }
        }
        if (!virtualKey) {
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        // while it was pressed, then it is time to process the app switch action!
        if (!down && mAppSwitchPressed) {
            mAppSwitchPressed = false;
            if (mAppSwitchConsumed) {
                mAppSwitchConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring APPSWITCH; event canceled.");
                return -1;
            }
            // Delay handling AppSwitch if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnAppSwitchBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mAppSwitchDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnAppSwitchBehavior);
                Action.processAction(mContext, mPressOnAppSwitchBehavior, false);
                return -1;
            }
            // Nothing happened execute default action
            Action.processAction(mContext, HwKeyHelper.getPressOnAppSwitchBehavior(mContext, true), false);
            return -1;
        }
        if (virtualKey && down) {
            mAppSwitchPressed = true;
            mAppSwitchConsumed = false;
            return -1;
        }
        // Remember that AppSwitch is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchPressed = true;
                if (mAppSwitchDoubleTapPending) {
                    mAppSwitchDoubleTapPending = false;
                    mDisableVibration = false;
                    mAppSwitchConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnAppSwitchBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnAppSwitchBehavior, false);
                    mAppSwitchConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        // while it was pressed, then it is time to process the assistant action!
        if (!down && mAssistPressed) {
            mAssistPressed = false;
            if (mAssistConsumed) {
                mAssistConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring ASSIST; event canceled.");
                return -1;
            }
            // Delay handling assistant if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnAssistBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mAssistDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnAssistBehavior);
                Action.processAction(mContext, mPressOnAssistBehavior, false);
                return -1;
            }
            // Nothing happened execute default action
            Action.processAction(mContext, HwKeyHelper.getPressOnAssistBehavior(mContext, true), false);
            return -1;
        }
        if (virtualKey && down) {
            mAssistPressed = true;
            mAssistConsumed = false;
            return -1;
        }
        // Remember that assistant key is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistPressed = true;
                if (mAssistDoubleTapPending) {
                    mAssistDoubleTapPending = false;
                    mDisableVibration = false;
                    mAssistConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnAssistBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnAssistBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnAssistBehavior, false);
                    mAssistConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_CAMERA) {
        // while it was pressed, then it is time to process the assistant action!
        if (!down && mCameraPressed) {
            mCameraPressed = false;
            if (mCameraConsumed) {
                mCameraConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring ASSIST; event canceled.");
                return -1;
            }
            // Delay handling assistant if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnCameraBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mCameraDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnCameraBehavior);
                Action.processAction(mContext, mPressOnCameraBehavior, false);
                return -1;
            }
            // Nothing happened execute default action
            Action.processAction(mContext, HwKeyHelper.getPressOnCameraBehavior(mContext, true), false);
            return -1;
        }
        if (virtualKey && down) {
            mAssistPressed = true;
            mAssistConsumed = false;
            return -1;
        }
        // Remember that camera key is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mCameraPressed = true;
                if (mCameraDoubleTapPending) {
                    mCameraDoubleTapPending = false;
                    mDisableVibration = false;
                    mCameraConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnCameraBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnCameraBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnCameraBehavior, false);
                    mCameraConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        // while it was pressed, then it is time to process the back action!
        if (!down && mBackPressed) {
            mBackPressed = false;
            if (mBackConsumed) {
                mBackConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring BACK; event canceled.");
                return -1;
            }
            // Delay handling back if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnBackBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mBackDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnBackBehavior);
                Action.processAction(mContext, mPressOnBackBehavior, false);
                return -1;
            }
        }
        if (virtualKey && down) {
            mBackPressed = true;
            mBackConsumed = false;
        } else if (down) {
            // Remember that back is pressed and handle special actions.
            if (!mPreloadedRecentApps && (mLongPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnBackBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mBackPressed = true;
                if (mBackDoubleTapPending) {
                    mBackDoubleTapPending = false;
                    mDisableVibration = false;
                    mBackConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnBackBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnBackBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnBackBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnBackBehavior, false);
                    mBackConsumed = true;
                }
            }
        }
        if (!virtualKey) {
            return -1;
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey + " longPress=" + longPress + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // If the boot mode is power off alarm, we should not dispatch the several physical keys
    // in power off alarm UI to avoid pausing power off alarm UI.
    int isPowerOffAlarmMode = Settings.System.getInt(mContext.getContentResolver(), Settings.System.POWER_OFF_ALARM_MODE, 0);
    if (DEBUG_INPUT) {
        Log.d(TAG, "intercept Dispatching isPowerOffAlarmMode = " + isPowerOffAlarmMode);
    }
    if (isPowerOffAlarmMode == 1 && (keyCode == KeyEvent.KEYCODE_HOME || keyCode == KeyEvent.KEYCODE_SEARCH || keyCode == KeyEvent.KEYCODE_MENU)) {
        // ignore the physical key here
        return -1;
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mScreenshotChordVolumeDownKeyTriggered && !mScreenshotChordPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mScreenshotChordVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mScreenshotChordVolumeDownKeyConsumed) {
            if (!down) {
                mScreenshotChordVolumeDownKeyConsumed = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                return -1;
            }
            // Delay handling home if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnHomeBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            if (!virtualKey && !mPressOnHomeBehavior.equals(ActionConstants.ACTION_HOME)) {
                if (!mPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnHomeBehavior);
                Action.processAction(mContext, mPressOnHomeBehavior, false);
                return -1;
            }
            // Go home
            launchHomeFromHotKey();
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (virtualKey && down) {
            mHomePressed = true;
            mHomeConsumed = false;
            return -1;
        }
        // Remember that home is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mHomePressed = true;
                if (mHomeDoubleTapPending) {
                    mHomeDoubleTapPending = false;
                    mDisableVibration = false;
                    mHomeConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnHomeBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnHomeBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnHomeBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnHomeBehavior, false);
                    mHomeConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        // while it was pressed, then it is time to process the menu action!
        if (!down && mMenuPressed) {
            mMenuPressed = false;
            if (mMenuConsumed) {
                mMenuConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring MENU; event canceled.");
                return -1;
            }
            if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                mContext.sendOrderedBroadcast(intent, null);
                return -1;
            } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                Intent service = new Intent();
                service.setClassName(mContext, "com.android.server.LoadAverageService");
                ContentResolver res = mContext.getContentResolver();
                boolean shown = Settings.Global.getInt(res, Settings.Global.SHOW_PROCESSES, 0) != 0;
                if (!shown) {
                    mContext.startService(service);
                } else {
                    mContext.stopService(service);
                }
                Settings.Global.putInt(res, Settings.Global.SHOW_PROCESSES, shown ? 0 : 1);
                return -1;
            }
            // Delay handling menu if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnMenuBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mMenuDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnMenuBehavior);
                Action.processAction(mContext, mPressOnMenuBehavior, false);
                return -1;
            }
        }
        if (virtualKey && down) {
            mMenuPressed = true;
            mMenuConsumed = false;
        } else if (down) {
            // Remember that menu is pressed and handle special actions.
            if (!mPreloadedRecentApps && (mLongPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mMenuPressed = true;
                if (mMenuDoubleTapPending) {
                    mMenuDoubleTapPending = false;
                    mDisableVibration = false;
                    mMenuConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnMenuBehavior, false);
                    return -1;
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnMenuBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnMenuBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnMenuBehavior, false);
                    mMenuConsumed = true;
                    return -1;
                }
            }
        }
        if (!virtualKey) {
            return -1;
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        // while it was pressed, then it is time to process the app switch action!
        if (!down && mAppSwitchPressed) {
            mAppSwitchPressed = false;
            if (mAppSwitchConsumed) {
                mAppSwitchConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring APPSWITCH; event canceled.");
                return -1;
            }
            // Delay handling AppSwitch if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnAppSwitchBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mAppSwitchDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnAppSwitchBehavior);
                Action.processAction(mContext, mPressOnAppSwitchBehavior, false);
                return -1;
            }
            // Nothing happened execute default action
            Action.processAction(mContext, HwKeyHelper.getPressOnAppSwitchBehavior(mContext, true), false);
            return -1;
        }
        if (virtualKey && down) {
            mAppSwitchPressed = true;
            mAppSwitchConsumed = false;
            return -1;
        }
        // Remember that AppSwitch is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchPressed = true;
                if (mAppSwitchDoubleTapPending) {
                    mAppSwitchDoubleTapPending = false;
                    mDisableVibration = false;
                    mAppSwitchConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnAppSwitchBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnAppSwitchBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnAppSwitchBehavior, false);
                    mAppSwitchConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_N && event.isMetaPressed()) {
        if (down) {
            IStatusBarService service = getStatusBarService();
            if (service != null) {
                try {
                    service.expandNotificationsPanel();
                } catch (RemoteException e) {
                // do nothing.
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        // while it was pressed, then it is time to process the assistant action!
        if (!down && mAssistPressed) {
            mAssistPressed = false;
            if (mAssistConsumed) {
                mAssistConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring ASSIST; event canceled.");
                return -1;
            }
            // Delay handling assistant if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnAssistBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mAssistDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnAssistBehavior);
                Action.processAction(mContext, mPressOnAssistBehavior, false);
                return -1;
            }
            // Nothing happened execute default action
            Action.processAction(mContext, HwKeyHelper.getPressOnAssistBehavior(mContext, true), false);
            return -1;
        }
        if (virtualKey && down) {
            mAssistPressed = true;
            mAssistConsumed = false;
            return -1;
        }
        // Remember that assistant key is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistPressed = true;
                if (mAssistDoubleTapPending) {
                    mAssistDoubleTapPending = false;
                    mDisableVibration = false;
                    mAssistConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnAssistBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnAssistBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnAssistBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnAssistBehavior, false);
                    mAssistConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_CAMERA) {
        // while it was pressed, then it is time to process the assistant action!
        if (!down && mCameraPressed) {
            mCameraPressed = false;
            if (mCameraConsumed) {
                mCameraConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring ASSIST; event canceled.");
                return -1;
            }
            // Delay handling assistant if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnCameraBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mCameraDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnCameraBehavior);
                Action.processAction(mContext, mPressOnCameraBehavior, false);
                return -1;
            }
            // Nothing happened execute default action
            Action.processAction(mContext, HwKeyHelper.getPressOnCameraBehavior(mContext, true), false);
            return -1;
        }
        if (virtualKey && down) {
            mAssistPressed = true;
            mAssistConsumed = false;
            return -1;
        }
        // Remember that camera key is pressed and handle special actions.
        if (down) {
            if (!mPreloadedRecentApps && (mLongPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mCameraPressed = true;
                if (mCameraDoubleTapPending) {
                    mCameraDoubleTapPending = false;
                    mDisableVibration = false;
                    mCameraConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnCameraBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnCameraBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnCameraBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnCameraBehavior, false);
                    mCameraConsumed = true;
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                IDeviceIdleController dic = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
                if (dic != null) {
                    try {
                        dic.exitIdle("voice-search");
                    } catch (RemoteException e) {
                    }
                }
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD, event.getDeviceId());
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        // while it was pressed, then it is time to process the back action!
        if (!down && mBackPressed) {
            mBackPressed = false;
            if (mBackConsumed) {
                mBackConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring BACK; event canceled.");
                return -1;
            }
            // Delay handling back if a double-tap is possible.
            if (!virtualKey && !mDoubleTapOnBackBehavior.equals(ActionConstants.ACTION_NULL)) {
                // just in case
                mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                // just in case
                mDisableVibration = false;
                mBackDoubleTapPending = true;
                mHandler.postDelayed(mDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (!virtualKey) {
                if (!mPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                    cancelPreloadRecentApps();
                }
                mDisableVibration = maybeDisableVibration(mPressOnBackBehavior);
                Action.processAction(mContext, mPressOnBackBehavior, false);
                return -1;
            }
        }
        if (virtualKey && down) {
            mBackPressed = true;
            mBackConsumed = false;
        } else if (down) {
            // Remember that back is pressed and handle special actions.
            if (!mPreloadedRecentApps && (mLongPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS) || mDoubleTapOnBackBehavior.equals(ActionConstants.ACTION_RECENTS) || mPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS))) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mBackPressed = true;
                if (mBackDoubleTapPending) {
                    mBackDoubleTapPending = false;
                    mDisableVibration = false;
                    mBackConsumed = true;
                    mHandler.removeCallbacks(mDoubleTapTimeoutRunnable);
                    if (!mDoubleTapOnBackBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    Action.processAction(mContext, mDoubleTapOnBackBehavior, false);
                }
            } else if (longPress) {
                if (!keyguardOn && !mLongPressOnBackBehavior.equals(ActionConstants.ACTION_NULL)) {
                    if (!mLongPressOnBackBehavior.equals(ActionConstants.ACTION_RECENTS)) {
                        cancelPreloadRecentApps();
                    }
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    Action.processAction(mContext, mLongPressOnBackBehavior, false);
                    mBackConsumed = true;
                }
            }
        }
        if (!virtualKey) {
            return -1;
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn && isUserSetupComplete()) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) {
    // Note: This method is only called if the initial down was unhandled.
    if (DEBUG_INPUT) {
        Slog.d(TAG, "Unhandled key: win=" + win + ", action=" + event.getAction() + ", flags=" + event.getFlags() + ", keyCode=" + event.getKeyCode() + ", scanCode=" + event.getScanCode() + ", metaState=" + event.getMetaState() + ", repeatCount=" + event.getRepeatCount() + ", policyFlags=" + policyFlags);
    }
    KeyEvent fallbackEvent = null;
    if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        final int keyCode = event.getKeyCode();
        final int metaState = event.getMetaState();
        final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0;
        // Check for fallback actions specified by the key character map.
        final FallbackAction fallbackAction;
        if (initialDown) {
            fallbackAction = kcm.getFallbackAction(keyCode, metaState);
        } else {
            fallbackAction = mFallbackActions.get(keyCode);
        }
        if (fallbackAction != null) {
            if (DEBUG_INPUT) {
                Slog.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode + " metaState=" + Integer.toHexString(fallbackAction.metaState));
            }
            final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;
            fallbackEvent = KeyEvent.obtain(event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null);
            if (!interceptFallback(win, fallbackEvent, policyFlags)) {
                fallbackEvent.recycle();
                fallbackEvent = null;
            }
            if (initialDown) {
                mFallbackActions.put(keyCode, fallbackAction);
            } else if (event.getAction() == KeyEvent.ACTION_UP) {
                mFallbackActions.remove(keyCode);
                fallbackAction.recycle();
            }
        }
    }
    if (DEBUG_INPUT) {
        if (fallbackEvent == null) {
            Slog.d(TAG, "No fallback.");
        } else {
            Slog.d(TAG, "Performing fallback: " + fallbackEvent);
        }
    }
    return fallbackEvent;
}
#method_after
@Override
public KeyEvent dispatchUnhandledKey(WindowState win, KeyEvent event, int policyFlags) {
    // Note: This method is only called if the initial down was unhandled.
    if (DEBUG_INPUT) {
        Slog.d(TAG, "Unhandled key: win=" + win + ", action=" + event.getAction() + ", flags=" + event.getFlags() + ", keyCode=" + event.getKeyCode() + ", scanCode=" + event.getScanCode() + ", metaState=" + event.getMetaState() + ", repeatCount=" + event.getRepeatCount() + ", policyFlags=" + policyFlags);
    }
    KeyEvent fallbackEvent = null;
    if ((event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        final int keyCode = event.getKeyCode();
        final int metaState = event.getMetaState();
        final boolean initialDown = event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0;
        // Specific device key handling
        if (mDeviceKeyHandler != null) {
            try {
                // The device only should consume known keys.
                if (mDeviceKeyHandler.handleKeyEvent(event)) {
                    return null;
                }
            } catch (Exception e) {
                Slog.w(TAG, "Could not dispatch event to device key handler", e);
            }
        }
        // Check for fallback actions specified by the key character map.
        final FallbackAction fallbackAction;
        if (initialDown) {
            fallbackAction = kcm.getFallbackAction(keyCode, metaState);
        } else {
            fallbackAction = mFallbackActions.get(keyCode);
        }
        if (fallbackAction != null) {
            if (DEBUG_INPUT) {
                Slog.d(TAG, "Fallback: keyCode=" + fallbackAction.keyCode + " metaState=" + Integer.toHexString(fallbackAction.metaState));
            }
            final int flags = event.getFlags() | KeyEvent.FLAG_FALLBACK;
            fallbackEvent = KeyEvent.obtain(event.getDownTime(), event.getEventTime(), event.getAction(), fallbackAction.keyCode, event.getRepeatCount(), fallbackAction.metaState, event.getDeviceId(), event.getScanCode(), flags, event.getSource(), null);
            if (!interceptFallback(win, fallbackEvent, policyFlags)) {
                fallbackEvent.recycle();
                fallbackEvent = null;
            }
            if (initialDown) {
                mFallbackActions.put(keyCode, fallbackAction);
            } else if (event.getAction() == KeyEvent.ACTION_UP) {
                mFallbackActions.remove(keyCode);
                fallbackAction.recycle();
            }
        }
    }
    if (DEBUG_INPUT) {
        if (fallbackEvent == null) {
            Slog.d(TAG, "No fallback.");
        } else {
            Slog.d(TAG, "Performing fallback: " + fallbackEvent);
        }
    }
    return fallbackEvent;
}
#end_block

#method_before
@Override
public void getInsetHintLw(WindowManager.LayoutParams attrs, int displayRotation, Rect outContentInsets, Rect outStableInsets, Rect outOutsets) {
    final int fl = WindowManagerPolicyControl.getWindowFlags(null, attrs);
    final int sysuiVis = WindowManagerPolicyControl.getSystemUiVisibility(null, attrs);
    final int systemUiVisibility = (sysuiVis | attrs.subtreeSystemUiVisibility);
    final boolean useOutsets = outOutsets != null && shouldUseOutsets(attrs, fl);
    if (useOutsets) {
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            if (displayRotation == Surface.ROTATION_0) {
                outOutsets.bottom += outset;
            } else if (displayRotation == Surface.ROTATION_90) {
                outOutsets.right += outset;
            } else if (displayRotation == Surface.ROTATION_180) {
                outOutsets.top += outset;
            } else if (displayRotation == Surface.ROTATION_270) {
                outOutsets.left += outset;
            }
        }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
        int availRight, availBottom;
        if (canHideNavigationBar() && (systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0) {
            availRight = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
            availBottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        } else {
            availRight = mRestrictedScreenLeft + mRestrictedScreenWidth;
            availBottom = mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
            if ((fl & FLAG_FULLSCREEN) != 0) {
                outContentInsets.set(mStableFullscreenLeft, mStableFullscreenTop, availRight - mStableFullscreenRight, availBottom - mStableFullscreenBottom);
            } else {
                outContentInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
            }
        } else if ((fl & FLAG_FULLSCREEN) != 0 || (fl & FLAG_LAYOUT_IN_OVERSCAN) != 0) {
            outContentInsets.setEmpty();
        } else if ((systemUiVisibility & (View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)) == 0) {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        } else {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        }
        outStableInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
        return;
    }
    outContentInsets.setEmpty();
    outStableInsets.setEmpty();
}
#method_after
@Override
public void getInsetHintLw(WindowManager.LayoutParams attrs, int displayRotation, Rect outContentInsets, Rect outStableInsets, Rect outOutsets) {
    final int fl = PolicyControl.getWindowFlags(null, attrs);
    final int sysuiVis = PolicyControl.getSystemUiVisibility(null, attrs);
    final int systemUiVisibility = (sysuiVis | attrs.subtreeSystemUiVisibility);
    final boolean useOutsets = outOutsets != null && shouldUseOutsets(attrs, fl);
    if (useOutsets) {
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            if (displayRotation == Surface.ROTATION_0) {
                outOutsets.bottom += outset;
            } else if (displayRotation == Surface.ROTATION_90) {
                outOutsets.right += outset;
            } else if (displayRotation == Surface.ROTATION_180) {
                outOutsets.top += outset;
            } else if (displayRotation == Surface.ROTATION_270) {
                outOutsets.left += outset;
            }
        }
    }
    if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
        int availRight, availBottom;
        if (canHideNavigationBar() && (systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0) {
            availRight = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
            availBottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        } else {
            availRight = mRestrictedScreenLeft + mRestrictedScreenWidth;
            availBottom = mRestrictedScreenTop + mRestrictedScreenHeight;
        }
        if ((systemUiVisibility & View.SYSTEM_UI_FLAG_LAYOUT_STABLE) != 0) {
            if ((fl & FLAG_FULLSCREEN) != 0) {
                outContentInsets.set(mStableFullscreenLeft, mStableFullscreenTop, availRight - mStableFullscreenRight, availBottom - mStableFullscreenBottom);
            } else {
                outContentInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
            }
        } else if ((fl & FLAG_FULLSCREEN) != 0 || (fl & FLAG_LAYOUT_IN_OVERSCAN) != 0) {
            outContentInsets.setEmpty();
        } else if ((systemUiVisibility & (View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN)) == 0) {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        } else {
            outContentInsets.set(mCurLeft, mCurTop, availRight - mCurRight, availBottom - mCurBottom);
        }
        outStableInsets.set(mStableLeft, mStableTop, availRight - mStableRight, availBottom - mStableBottom);
        return;
    }
    outContentInsets.setEmpty();
    outStableInsets.setEmpty();
}
#end_block

#method_before
@Override
public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation) {
    mDisplayRotation = displayRotation;
    final int overscanLeft, overscanTop, overscanRight, overscanBottom;
    if (isDefaultDisplay) {
        switch(displayRotation) {
            case Surface.ROTATION_90:
                overscanLeft = mOverscanTop;
                overscanTop = mOverscanRight;
                overscanRight = mOverscanBottom;
                overscanBottom = mOverscanLeft;
                break;
            case Surface.ROTATION_180:
                overscanLeft = mOverscanRight;
                overscanTop = mOverscanBottom;
                overscanRight = mOverscanLeft;
                overscanBottom = mOverscanTop;
                break;
            case Surface.ROTATION_270:
                overscanLeft = mOverscanBottom;
                overscanTop = mOverscanLeft;
                overscanRight = mOverscanTop;
                overscanBottom = mOverscanRight;
                break;
            default:
                overscanLeft = mOverscanLeft;
                overscanTop = mOverscanTop;
                overscanRight = mOverscanRight;
                overscanBottom = mOverscanBottom;
                break;
        }
    } else {
        overscanLeft = 0;
        overscanTop = 0;
        overscanRight = 0;
        overscanBottom = 0;
    }
    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0;
    mOverscanScreenTop = mRestrictedOverscanScreenTop = 0;
    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;
    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;
    mSystemLeft = 0;
    mSystemTop = 0;
    mSystemRight = displayWidth;
    mSystemBottom = displayHeight;
    mUnrestrictedScreenLeft = overscanLeft;
    mUnrestrictedScreenTop = overscanTop;
    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;
    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;
    mRestrictedScreenLeft = mUnrestrictedScreenLeft;
    mRestrictedScreenTop = mUnrestrictedScreenTop;
    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mForceImmersiveLeft = mUnrestrictedScreenLeft;
    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mForceImmersiveTop = mUnrestrictedScreenTop;
    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = mForceImmersiveRight = displayWidth - overscanRight;
    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = mForceImmersiveBottom = displayHeight - overscanBottom;
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect osf = mTmpOutsetFrame;
    pf.left = df.left = of.left = vf.left = mDockLeft;
    pf.top = df.top = of.top = vf.top = mDockTop;
    pf.right = df.right = of.right = vf.right = mDockRight;
    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (isDefaultDisplay) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        // bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mInputConsumer.dismiss();
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null) {
            mInputConsumer = mWindowManagerFuncs.addInputConsumer(mHandler.getLooper(), mHideNavInputEventReceiverFactory);
        }
        // For purposes of positioning and showing the nav bar, if we have
        // decided that it can't be hidden (because of the screen aspect ratio),
        // then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = false;
        if (mNavigationBar != null) {
            boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
            // Force the navigation bar to its appropriate place and
            // size.  We need to do this directly, instead of relying on
            // it to bubble up from the nav bar, because this needs to
            // change atomically with screen rotations.
            mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth < displayHeight);
            if (mNavigationBarOnBottom) {
                // It's a system nav bar or a portrait screen; nav bar goes on bottom.
                int top = displayHeight - overscanBottom - mNavigationBarHeightForRotation[displayRotation];
                mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom);
                mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockBottom = mTmpNavigationFrame.top;
                    mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop;
                    mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the opaque nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemBottom = mTmpNavigationFrame.top;
                }
            } else {
                // Landscape screen; nav bar goes to the right.
                int left = displayWidth - overscanRight - mNavigationBarWidthForRotation[displayRotation];
                mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight);
                mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockRight = mTmpNavigationFrame.left;
                    mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                    mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemRight = mTmpNavigationFrame.left;
                }
            }
            // Make sure the content and current rectangles are updated to
            // account for the restrictions from the navigation bar.
            mContentTop = mVoiceContentTop = mCurTop = mDockTop;
            mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
            mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
            mContentRight = mVoiceContentRight = mCurRight = mDockRight;
            mStatusBarLayer = mNavigationBar.getSurfaceLayer();
            // And compute the final frame.
            mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame, mTmpNavigationFrame);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
            if (mNavigationBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (DEBUG_LAYOUT)
            Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)", mDockLeft, mDockTop, mDockRight, mDockBottom));
        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            // apply any navigation bar insets
            pf.left = df.left = of.left = mUnrestrictedScreenLeft;
            pf.top = df.top = of.top = mUnrestrictedScreenTop;
            pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
            pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
            vf.left = mStableLeft;
            vf.top = mStableTop;
            vf.right = mStableRight;
            vf.bottom = mStableBottom;
            mStatusBarLayer = mStatusBar.getSurfaceLayer();
            // Let the status bar determine its size.
            mStatusBar.computeFrameLw(pf, /* parentFrame */
            df, /* displayFrame */
            vf, /* overlayFrame */
            vf, /* contentFrame */
            vf, /* visibleFrame */
            dcf, /* decorFrame */
            vf, /* stableFrame */
            vf);
            // For layout, the status bar is always at the top with our fixed height.
            mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
            boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
            boolean statusBarTranslucent = (sysui & (View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
            if (!isKeyguardShowing) {
                statusBarTranslucent &= areTranslucentBarsAllowed();
            }
            // windows behind it to scroll.
            if (mStatusBar.isVisibleLw() && !statusBarTransient) {
                // Status bar may go away, so the screen area it occupies
                // is available to apps but just covering them when the
                // status bar is visible.
                mDockTop = mUnrestrictedScreenTop + mStatusBarHeight;
                mContentTop = mVoiceContentTop = mCurTop = mDockTop;
                mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
                mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
                mContentRight = mVoiceContentRight = mCurRight = mDockRight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
            }
            if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw() && !statusBarTransient && !statusBarTranslucent && !mStatusBarController.wasRecentlyTranslucent()) {
                // If the opaque status bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemTop = mUnrestrictedScreenTop + mStatusBarHeight;
            }
            if (mStatusBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
}
#method_after
@Override
public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation) {
    mDisplayRotation = displayRotation;
    final int overscanLeft, overscanTop, overscanRight, overscanBottom;
    if (isDefaultDisplay) {
        switch(displayRotation) {
            case Surface.ROTATION_90:
                overscanLeft = mOverscanTop;
                overscanTop = mOverscanRight;
                overscanRight = mOverscanBottom;
                overscanBottom = mOverscanLeft;
                break;
            case Surface.ROTATION_180:
                overscanLeft = mOverscanRight;
                overscanTop = mOverscanBottom;
                overscanRight = mOverscanLeft;
                overscanBottom = mOverscanTop;
                break;
            case Surface.ROTATION_270:
                overscanLeft = mOverscanBottom;
                overscanTop = mOverscanLeft;
                overscanRight = mOverscanTop;
                overscanBottom = mOverscanRight;
                break;
            default:
                overscanLeft = mOverscanLeft;
                overscanTop = mOverscanTop;
                overscanRight = mOverscanRight;
                overscanBottom = mOverscanBottom;
                break;
        }
    } else {
        overscanLeft = 0;
        overscanTop = 0;
        overscanRight = 0;
        overscanBottom = 0;
    }
    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0;
    mOverscanScreenTop = mRestrictedOverscanScreenTop = 0;
    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;
    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;
    mSystemLeft = 0;
    mSystemTop = 0;
    mSystemRight = displayWidth;
    mSystemBottom = displayHeight;
    mUnrestrictedScreenLeft = overscanLeft;
    mUnrestrictedScreenTop = overscanTop;
    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;
    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;
    mRestrictedScreenLeft = mUnrestrictedScreenLeft;
    mRestrictedScreenTop = mUnrestrictedScreenTop;
    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;
    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;
    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft;
    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop;
    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight;
    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom;
    mDockLayer = 0x10000000;
    mStatusBarLayer = -1;
    // start with the current dock rect, which will be (0,0,displayWidth,displayHeight)
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect osf = mTmpOutsetFrame;
    pf.left = df.left = of.left = vf.left = mDockLeft;
    pf.top = df.top = of.top = vf.top = mDockTop;
    pf.right = df.right = of.right = vf.right = mDockRight;
    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;
    // Decor frame N/A for system bars.
    dcf.setEmpty();
    if (isDefaultDisplay) {
        // For purposes of putting out fake window up to steal focus, we will
        // drive nav being hidden only by whether it is requested.
        final int sysui = mLastSystemUiFlags;
        boolean navVisible = (sysui & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0;
        boolean navTranslucent = (sysui & (View.NAVIGATION_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
        boolean immersive = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
        boolean immersiveSticky = (sysui & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
        boolean navAllowedHidden = immersive || immersiveSticky;
        // transient trumps translucent
        navTranslucent &= !immersiveSticky;
        boolean isKeyguardShowing = isStatusBarKeyguard() && !mHideLockScreen;
        if (!isKeyguardShowing) {
            navTranslucent &= areTranslucentBarsAllowed();
        }
        // bar and ensure the application doesn't see the event.
        if (navVisible || navAllowedHidden) {
            if (mInputConsumer != null) {
                mInputConsumer.dismiss();
                mInputConsumer = null;
            }
        } else if (mInputConsumer == null) {
            mInputConsumer = mWindowManagerFuncs.addInputConsumer(mHandler.getLooper(), mHideNavInputEventReceiverFactory);
        }
        // For purposes of positioning and showing the nav bar, if we have
        // decided that it can't be hidden (because of the screen aspect ratio),
        // then take that into account.
        navVisible |= !canHideNavigationBar();
        boolean updateSysUiVisibility = false;
        if (mNavigationBar != null) {
            boolean transientNavBarShowing = mNavigationBarController.isTransientShowing();
            // Force the navigation bar to its appropriate place and
            // size.  We need to do this directly, instead of relying on
            // it to bubble up from the nav bar, because this needs to
            // change atomically with screen rotations.
            mNavigationBarOnBottom = (!mNavigationBarCanMove || displayWidth < displayHeight);
            if (mNavigationBarOnBottom) {
                // It's a system nav bar or a portrait screen; nav bar goes on bottom.
                int top = displayHeight - overscanBottom - mNavigationBarHeightForRotation[displayRotation];
                mTmpNavigationFrame.set(0, top, displayWidth, displayHeight - overscanBottom);
                mStableBottom = mStableFullscreenBottom = mTmpNavigationFrame.top;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockBottom = mTmpNavigationFrame.top;
                    mRestrictedScreenHeight = mDockBottom - mRestrictedScreenTop;
                    mRestrictedOverscanScreenHeight = mDockBottom - mRestrictedOverscanScreenTop;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the opaque nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemBottom = mTmpNavigationFrame.top;
                }
            } else {
                // Landscape screen; nav bar goes to the right.
                int left = displayWidth - overscanRight - mNavigationBarWidthForRotation[displayRotation];
                mTmpNavigationFrame.set(left, 0, displayWidth - overscanRight, displayHeight);
                mStableRight = mStableFullscreenRight = mTmpNavigationFrame.left;
                if (transientNavBarShowing) {
                    mNavigationBarController.setBarShowingLw(true);
                } else if (navVisible) {
                    mNavigationBarController.setBarShowingLw(true);
                    mDockRight = mTmpNavigationFrame.left;
                    mRestrictedScreenWidth = mDockRight - mRestrictedScreenLeft;
                    mRestrictedOverscanScreenWidth = mDockRight - mRestrictedOverscanScreenLeft;
                } else {
                    // We currently want to hide the navigation UI.
                    mNavigationBarController.setBarShowingLw(false);
                }
                if (navVisible && !navTranslucent && !navAllowedHidden && !mNavigationBar.isAnimatingLw() && !mNavigationBarController.wasRecentlyTranslucent()) {
                    // If the nav bar is currently requested to be visible,
                    // and not in the process of animating on or off, then
                    // we can tell the app that it is covered by it.
                    mSystemRight = mTmpNavigationFrame.left;
                }
            }
            // Make sure the content and current rectangles are updated to
            // account for the restrictions from the navigation bar.
            mContentTop = mVoiceContentTop = mCurTop = mDockTop;
            mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
            mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
            mContentRight = mVoiceContentRight = mCurRight = mDockRight;
            mStatusBarLayer = mNavigationBar.getSurfaceLayer();
            // And compute the final frame.
            mNavigationBar.computeFrameLw(mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, mTmpNavigationFrame, dcf, mTmpNavigationFrame, mTmpNavigationFrame);
            if (DEBUG_LAYOUT)
                Slog.i(TAG, "mNavigationBar frame: " + mTmpNavigationFrame);
            if (mNavigationBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (DEBUG_LAYOUT)
            Slog.i(TAG, String.format("mDock rect: (%d,%d - %d,%d)", mDockLeft, mDockTop, mDockRight, mDockBottom));
        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            // apply any navigation bar insets
            pf.left = df.left = of.left = mUnrestrictedScreenLeft;
            pf.top = df.top = of.top = mUnrestrictedScreenTop;
            pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
            pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
            vf.left = mStableLeft;
            vf.top = mStableTop;
            vf.right = mStableRight;
            vf.bottom = mStableBottom;
            mStatusBarLayer = mStatusBar.getSurfaceLayer();
            // Let the status bar determine its size.
            mStatusBar.computeFrameLw(pf, /* parentFrame */
            df, /* displayFrame */
            vf, /* overlayFrame */
            vf, /* contentFrame */
            vf, /* visibleFrame */
            dcf, /* decorFrame */
            vf, /* stableFrame */
            vf);
            // For layout, the status bar is always at the top with our fixed height.
            mStableTop = mUnrestrictedScreenTop + mStatusBarHeight;
            boolean statusBarTransient = (sysui & View.STATUS_BAR_TRANSIENT) != 0;
            boolean statusBarTranslucent = (sysui & (View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT)) != 0;
            if (!isKeyguardShowing) {
                statusBarTranslucent &= areTranslucentBarsAllowed();
            }
            // windows behind it to scroll.
            if (mStatusBar.isVisibleLw() && !statusBarTransient) {
                // Status bar may go away, so the screen area it occupies
                // is available to apps but just covering them when the
                // status bar is visible.
                mDockTop = mUnrestrictedScreenTop + mStatusBarHeight;
                mContentTop = mVoiceContentTop = mCurTop = mDockTop;
                mContentBottom = mVoiceContentBottom = mCurBottom = mDockBottom;
                mContentLeft = mVoiceContentLeft = mCurLeft = mDockLeft;
                mContentRight = mVoiceContentRight = mCurRight = mDockRight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Status bar: " + String.format("dock=[%d,%d][%d,%d] content=[%d,%d][%d,%d] cur=[%d,%d][%d,%d]", mDockLeft, mDockTop, mDockRight, mDockBottom, mContentLeft, mContentTop, mContentRight, mContentBottom, mCurLeft, mCurTop, mCurRight, mCurBottom));
            }
            if (mStatusBar.isVisibleLw() && !mStatusBar.isAnimatingLw() && !statusBarTransient && !statusBarTranslucent && !mStatusBarController.wasRecentlyTranslucent()) {
                // If the opaque status bar is currently requested to be visible,
                // and not in the process of animating on or off, then
                // we can tell the app that it is covered by it.
                mSystemTop = mUnrestrictedScreenTop + mStatusBarHeight;
            }
            if (mStatusBarController.checkHiddenLw()) {
                updateSysUiVisibility = true;
            }
        }
        if (updateSysUiVisibility) {
            updateSystemUiVisibilityLw();
        }
    }
}
#end_block

#method_before
@Override
public void layoutWindowLw(WindowState win, WindowState attached) {
    // input, we need to layout it again to accomodate for the IME window.
    if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
        return;
    }
    final WindowManager.LayoutParams attrs = win.getAttrs();
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = WindowManagerPolicyControl.getWindowFlags(win, attrs);
    final int pfl = WindowManagerPolicyControl.getPrivateWindowFlags(win, attrs);
    final int sim = attrs.softInputMode;
    final int sysUiFl = WindowManagerPolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    Rect osf = null;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (attrs.type == TYPE_VOICE_INTERACTION) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        cf.bottom = vf.bottom = mStableBottom;
        // Note: In Phone landscape mode, the button bar should also be excluded.
        cf.right = vf.right = mStableRight;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
    } else if (win == mStatusBar) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = mStableRight;
        vf.bottom = mStableBottom;
        cf.bottom = mContentBottom;
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0 || (pfl & PRIVATE_FLAG_WAS_NOT_FULLSCREEN) != 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                        applyForceImmersiveMode(pfl, cf);
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
                applyForceImmersiveMode(pfl, vf);
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_WALLPAPER) {
                // The wallpaper also has Real Ultimate Power, but we want to tell
                // it about the overscan area.
                pf.left = df.left = mOverscanScreenLeft;
                pf.top = df.top = mOverscanScreenTop;
                pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                of.left = cf.left = mUnrestrictedScreenLeft;
                of.top = cf.top = mUnrestrictedScreenTop;
                of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
            applyForceImmersiveMode(pfl, vf);
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                // Status bar panels and the volume dialog are the only windows who can go on
                // top of the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
                applyForceImmersiveMode(pfl, vf);
            }
        }
    }
    // TYPE_SYSTEM_ERROR is above the NavigationBar so it can't be allowed to extend over it.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    // If the device has a chin (e.g. some watches), a dead area at the bottom of the screen we
    // need to provide information to the clients that want to pretend that you can draw there.
    // We only want to apply outsets to certain types of windows. For example, we never want to
    // apply the outsets to floating dialogs, because they wouldn't make sense there.
    final boolean useOutsets = shouldUseOutsets(attrs, fl);
    if (isDefaultDisplay && useOutsets) {
        osf = mTmpOutsetFrame;
        osf.set(cf.left, cf.top, cf.right, cf.bottom);
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            int rotation = mDisplayRotation;
            if (rotation == Surface.ROTATION_0) {
                osf.bottom += outset;
            } else if (rotation == Surface.ROTATION_90) {
                osf.right += outset;
            } else if (rotation == Surface.ROTATION_180) {
                osf.top -= outset;
            } else if (rotation == Surface.ROTATION_270) {
                osf.left -= outset;
            }
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "applying bottom outset of " + outset + " with rotation " + rotation + ", result: " + osf);
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString() + " osf=" + (osf == null ? "null" : osf.toShortString()));
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
#method_after
@Override
public void layoutWindowLw(WindowState win, WindowState attached) {
    // input, we need to layout it again to accomodate for the IME window.
    if ((win == mStatusBar && !canReceiveInput(win)) || win == mNavigationBar) {
        return;
    }
    final WindowManager.LayoutParams attrs = win.getAttrs();
    final boolean isDefaultDisplay = win.isDefaultDisplay();
    final boolean needsToOffsetInputMethodTarget = isDefaultDisplay && (win == mLastInputMethodTargetWindow && mLastInputMethodWindow != null);
    if (needsToOffsetInputMethodTarget) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "Offset ime target window by the last ime window state");
        offsetInputMethodWindowLw(mLastInputMethodWindow);
    }
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    final int sim = attrs.softInputMode;
    final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null);
    final Rect pf = mTmpParentFrame;
    final Rect df = mTmpDisplayFrame;
    final Rect of = mTmpOverscanFrame;
    final Rect cf = mTmpContentFrame;
    final Rect vf = mTmpVisibleFrame;
    final Rect dcf = mTmpDecorFrame;
    final Rect sf = mTmpStableFrame;
    Rect osf = null;
    dcf.setEmpty();
    final boolean hasNavBar = (isDefaultDisplay && mHasNavigationBar && mNavigationBar != null && mNavigationBar.isVisibleLw());
    final int adjust = sim & SOFT_INPUT_MASK_ADJUST;
    if (isDefaultDisplay) {
        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);
    } else {
        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);
    }
    if (!isDefaultDisplay) {
        if (attached != null) {
            // If this window is attached to another, our display
            // frame is the same as the one we are attached to.
            setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
        } else {
            // Give the window full screen.
            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
            pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
            pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
        }
    } else if (attrs.type == TYPE_INPUT_METHOD) {
        pf.left = df.left = of.left = cf.left = vf.left = mDockLeft;
        pf.top = df.top = of.top = cf.top = vf.top = mDockTop;
        pf.right = df.right = of.right = cf.right = vf.right = mDockRight;
        // IM dock windows layout below the nav bar...
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        // ...with content insets above the nav bar
        cf.bottom = vf.bottom = mStableBottom;
        // IM dock windows always go to the bottom of the screen.
        attrs.gravity = Gravity.BOTTOM;
        mDockLayer = win.getSurfaceLayer();
    } else if (attrs.type == TYPE_VOICE_INTERACTION) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
        cf.bottom = vf.bottom = mStableBottom;
        // Note: In Phone landscape mode, the button bar should also be excluded.
        cf.right = vf.right = mStableRight;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
    } else if (win == mStatusBar) {
        pf.left = df.left = of.left = mUnrestrictedScreenLeft;
        pf.top = df.top = of.top = mUnrestrictedScreenTop;
        pf.right = df.right = of.right = mUnrestrictedScreenWidth + mUnrestrictedScreenLeft;
        pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenHeight + mUnrestrictedScreenTop;
        cf.left = vf.left = mStableLeft;
        cf.top = vf.top = mStableTop;
        cf.right = vf.right = mStableRight;
        vf.bottom = mStableBottom;
        cf.bottom = mContentBottom;
    } else {
        // Default policy decor for the default display
        dcf.left = mSystemLeft;
        dcf.top = mSystemTop;
        dcf.right = mSystemRight;
        dcf.bottom = mSystemBottom;
        final boolean inheritTranslucentDecor = (attrs.privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_INHERIT_TRANSLUCENT_DECOR) != 0;
        final boolean isAppWindow = attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_APPLICATION_WINDOW;
        final boolean topAtRest = win == mTopFullscreenOpaqueWindowState && !win.isAnimatingLw();
        if (isAppWindow && !inheritTranslucentDecor && !topAtRest) {
            if ((sysUiFl & View.SYSTEM_UI_FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) == 0 && (fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes status bar
                dcf.top = mStableTop;
            }
            if ((fl & WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION) == 0 && (sysUiFl & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) == 0 && (fl & WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS) == 0) {
                // Ensure policy decor includes navigation bar
                dcf.bottom = mStableBottom;
                dcf.right = mStableRight;
            }
        }
        if ((fl & (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN, INSET_DECOR");
            // intrude into that space.
            if (attached != null) {
                // If this window is attached to another, our display
                // frame is the same as the one we are attached to.
                setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf);
            } else {
                if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL) {
                    // Status bar panels are the only windows who can go on top of
                    // the status bar.  They are protected by the STATUS_BAR_SERVICE
                    // permission, so they have the same privileges as the status
                    // bar itself.
                    // 
                    // However, they should still dodge the navigation bar if it exists.
                    pf.left = df.left = of.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                    pf.top = df.top = of.top = mUnrestrictedScreenTop;
                    pf.right = df.right = of.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    pf.bottom = df.bottom = of.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, String.format("Laying out status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
                } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking to layout into the overscan region, so give it that pure
                    // unrestricted area.
                    pf.left = df.left = of.left = mOverscanScreenLeft;
                    pf.top = df.top = of.top = mOverscanScreenTop;
                    pf.right = df.right = of.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = of.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                    // Asking for layout as if the nav bar is hidden, lets the
                    // application extend into the unrestricted overscan screen area.  We
                    // only do this for application windows to ensure no window that
                    // can be above the nav bar can do this.
                    pf.left = df.left = mOverscanScreenLeft;
                    pf.top = df.top = mOverscanScreenTop;
                    pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                    pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                } else {
                    pf.left = df.left = mRestrictedOverscanScreenLeft;
                    pf.top = df.top = mRestrictedOverscanScreenTop;
                    pf.right = df.right = mRestrictedOverscanScreenLeft + mRestrictedOverscanScreenWidth;
                    pf.bottom = df.bottom = mRestrictedOverscanScreenTop + mRestrictedOverscanScreenHeight;
                    // We need to tell the app about where the frame inside the overscan
                    // is, so it can inset its content by that amount -- it didn't ask
                    // to actually extend itself into the overscan region.
                    of.left = mUnrestrictedScreenLeft;
                    of.top = mUnrestrictedScreenTop;
                    of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                    of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                }
                if ((fl & FLAG_FULLSCREEN) == 0) {
                    if (win.isVoiceInteraction()) {
                        cf.left = mVoiceContentLeft;
                        cf.top = mVoiceContentTop;
                        cf.right = mVoiceContentRight;
                        cf.bottom = mVoiceContentBottom;
                    } else {
                        if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                            cf.left = mDockLeft;
                            cf.top = mDockTop;
                            cf.right = mDockRight;
                            cf.bottom = mDockBottom;
                        } else {
                            cf.left = mContentLeft;
                            cf.top = mContentTop;
                            cf.right = mContentRight;
                            cf.bottom = mContentBottom;
                        }
                    }
                } else {
                    // Full screen windows are always given a layout that is as if the
                    // status bar and other transient decors are gone.  This is to avoid
                    // bad states when moving from a window that is not hding the
                    // status bar to one that is.
                    cf.left = mRestrictedScreenLeft;
                    cf.top = mRestrictedScreenTop;
                    cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                    cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
                }
                applyStableConstraints(sysUiFl, fl, cf);
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        } else if ((fl & FLAG_LAYOUT_IN_SCREEN) != 0 || (sysUiFl & (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION)) != 0) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): IN_SCREEN");
            // gets everything, period.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_STATUS_BAR_SUB_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                pf.left = df.left = of.left = cf.left = hasNavBar ? mDockLeft : mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = hasNavBar ? mRestrictedScreenLeft + mRestrictedScreenWidth : mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = hasNavBar ? mRestrictedScreenTop + mRestrictedScreenHeight : mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out IN_SCREEN status bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if (attrs.type == TYPE_NAVIGATION_BAR || attrs.type == TYPE_NAVIGATION_BAR_PANEL) {
                // The navigation bar has Real Ultimate Power.
                pf.left = df.left = of.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, String.format("Laying out navigation bar window: (%d,%d - %d,%d)", pf.left, pf.top, pf.right, pf.bottom));
            } else if ((attrs.type == TYPE_SECURE_SYSTEM_OVERLAY || attrs.type == TYPE_BOOT_PROGRESS) && ((fl & FLAG_FULLSCREEN) != 0)) {
                // Fullscreen secure system overlays get what they ask for.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_BOOT_PROGRESS) {
                // Boot progress screen always covers entire display.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (attrs.type == TYPE_WALLPAPER) {
                // The wallpaper also has Real Ultimate Power, but we want to tell
                // it about the overscan area.
                pf.left = df.left = mOverscanScreenLeft;
                pf.top = df.top = mOverscanScreenTop;
                pf.right = df.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = mOverscanScreenTop + mOverscanScreenHeight;
                of.left = cf.left = mUnrestrictedScreenLeft;
                of.top = cf.top = mUnrestrictedScreenTop;
                of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else if ((fl & FLAG_LAYOUT_IN_OVERSCAN) != 0 && attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                // Asking to layout into the overscan region, so give it that pure
                // unrestricted area.
                pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;
                pf.top = df.top = of.top = cf.top = mOverscanScreenTop;
                pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight;
            } else if (canHideNavigationBar() && (sysUiFl & View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION) != 0 && (attrs.type == TYPE_STATUS_BAR || attrs.type == TYPE_TOAST || attrs.type == TYPE_VOICE_INTERACTION_STARTING || (attrs.type >= WindowManager.LayoutParams.FIRST_APPLICATION_WINDOW && attrs.type <= WindowManager.LayoutParams.LAST_SUB_WINDOW))) {
                // Asking for layout as if the nav bar is hidden, lets the
                // application extend into the unrestricted screen area.  We
                // only do this for application windows (or toasts) to ensure no window that
                // can be above the nav bar can do this.
                // XXX This assumes that an app asking for this will also
                // ask for layout in only content.  We can't currently figure out
                // what the screen would be if only laying out to hide the nav bar.
                pf.left = df.left = of.left = cf.left = mUnrestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mUnrestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mUnrestrictedScreenLeft + mUnrestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mUnrestrictedScreenTop + mUnrestrictedScreenHeight;
            } else {
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            }
            applyStableConstraints(sysUiFl, fl, cf);
            if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                vf.left = mCurLeft;
                vf.top = mCurTop;
                vf.right = mCurRight;
                vf.bottom = mCurBottom;
            } else {
                vf.set(cf);
            }
        } else if (attached != null) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): attached to " + attached);
            // A child window should be placed inside of the same visible
            // frame that its parent had.
            setAttachedWindowFrames(win, fl, adjust, attached, false, pf, df, of, cf, vf);
        } else {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "layoutWindowLw(" + attrs.getTitle() + "): normal window");
            // of all screen decorations.
            if (attrs.type == TYPE_STATUS_BAR_PANEL || attrs.type == TYPE_VOLUME_OVERLAY) {
                // Status bar panels and the volume dialog are the only windows who can go on
                // top of the status bar.  They are protected by the STATUS_BAR_SERVICE
                // permission, so they have the same privileges as the status
                // bar itself.
                pf.left = df.left = of.left = cf.left = mRestrictedScreenLeft;
                pf.top = df.top = of.top = cf.top = mRestrictedScreenTop;
                pf.right = df.right = of.right = cf.right = mRestrictedScreenLeft + mRestrictedScreenWidth;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mRestrictedScreenTop + mRestrictedScreenHeight;
            } else if (attrs.type == TYPE_TOAST || attrs.type == TYPE_SYSTEM_ALERT) {
                // These dialogs are stable to interim decor changes.
                pf.left = df.left = of.left = cf.left = mStableLeft;
                pf.top = df.top = of.top = cf.top = mStableTop;
                pf.right = df.right = of.right = cf.right = mStableRight;
                pf.bottom = df.bottom = of.bottom = cf.bottom = mStableBottom;
            } else {
                pf.left = mContentLeft;
                pf.top = mContentTop;
                pf.right = mContentRight;
                pf.bottom = mContentBottom;
                if (win.isVoiceInteraction()) {
                    df.left = of.left = cf.left = mVoiceContentLeft;
                    df.top = of.top = cf.top = mVoiceContentTop;
                    df.right = of.right = cf.right = mVoiceContentRight;
                    df.bottom = of.bottom = cf.bottom = mVoiceContentBottom;
                } else if (adjust != SOFT_INPUT_ADJUST_RESIZE) {
                    df.left = of.left = cf.left = mDockLeft;
                    df.top = of.top = cf.top = mDockTop;
                    df.right = of.right = cf.right = mDockRight;
                    df.bottom = of.bottom = cf.bottom = mDockBottom;
                } else {
                    df.left = of.left = cf.left = mContentLeft;
                    df.top = of.top = cf.top = mContentTop;
                    df.right = of.right = cf.right = mContentRight;
                    df.bottom = of.bottom = cf.bottom = mContentBottom;
                }
                if (adjust != SOFT_INPUT_ADJUST_NOTHING) {
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                } else {
                    vf.set(cf);
                }
            }
        }
    }
    // TYPE_SYSTEM_ERROR is above the NavigationBar so it can't be allowed to extend over it.
    if ((fl & FLAG_LAYOUT_NO_LIMITS) != 0 && attrs.type != TYPE_SYSTEM_ERROR) {
        df.left = df.top = -10000;
        df.right = df.bottom = 10000;
        if (attrs.type != TYPE_WALLPAPER) {
            of.left = of.top = cf.left = cf.top = vf.left = vf.top = -10000;
            of.right = of.bottom = cf.right = cf.bottom = vf.right = vf.bottom = 10000;
        }
    }
    // If the device has a chin (e.g. some watches), a dead area at the bottom of the screen we
    // need to provide information to the clients that want to pretend that you can draw there.
    // We only want to apply outsets to certain types of windows. For example, we never want to
    // apply the outsets to floating dialogs, because they wouldn't make sense there.
    final boolean useOutsets = shouldUseOutsets(attrs, fl);
    if (isDefaultDisplay && useOutsets) {
        osf = mTmpOutsetFrame;
        osf.set(cf.left, cf.top, cf.right, cf.bottom);
        int outset = ScreenShapeHelper.getWindowOutsetBottomPx(mContext.getResources());
        if (outset > 0) {
            int rotation = mDisplayRotation;
            if (rotation == Surface.ROTATION_0) {
                osf.bottom += outset;
            } else if (rotation == Surface.ROTATION_90) {
                osf.right += outset;
            } else if (rotation == Surface.ROTATION_180) {
                osf.top -= outset;
            } else if (rotation == Surface.ROTATION_270) {
                osf.left -= outset;
            }
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "applying bottom outset of " + outset + " with rotation " + rotation + ", result: " + osf);
        }
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Compute frame " + attrs.getTitle() + ": sim=#" + Integer.toHexString(sim) + " attach=" + attached + " type=" + attrs.type + String.format(" flags=0x%08x", fl) + " pf=" + pf.toShortString() + " df=" + df.toShortString() + " of=" + of.toShortString() + " cf=" + cf.toShortString() + " vf=" + vf.toShortString() + " dcf=" + dcf.toShortString() + " sf=" + sf.toShortString() + " osf=" + (osf == null ? "null" : osf.toShortString()));
    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);
    // can't appear underneath them.
    if (attrs.type == TYPE_INPUT_METHOD && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        setLastInputMethodWindowLw(null, null);
        offsetInputMethodWindowLw(win);
    }
    if (attrs.type == TYPE_VOICE_INTERACTION && win.isVisibleOrBehindKeyguardLw() && !win.getGivenInsetsPendingLw()) {
        offsetVoiceInputWindowLw(win);
    }
}
#end_block

#method_before
private void offsetInputMethodWindowLw(WindowState win) {
    int top = Math.max(win.getDisplayFrameLw().top, win.getContentFrameLw().top);
    top += win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
        mContentBottom = top;
    }
    if (mForceImmersiveBottom > top) {
        mForceImmersiveBottom = top;
    }
    if (mVoiceContentBottom > top) {
        mVoiceContentBottom = top;
    }
    top = win.getVisibleFrameLw().top;
    top += win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
        mCurBottom = top;
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Input method: mDockBottom=" + mDockBottom + " mContentBottom=" + mContentBottom + " mCurBottom=" + mCurBottom);
}
#method_after
private void offsetInputMethodWindowLw(WindowState win) {
    int top = Math.max(win.getDisplayFrameLw().top, win.getContentFrameLw().top);
    top += win.getGivenContentInsetsLw().top;
    if (mContentBottom > top) {
        mContentBottom = top;
    }
    if (mVoiceContentBottom > top) {
        mVoiceContentBottom = top;
    }
    top = win.getVisibleFrameLw().top;
    top += win.getGivenVisibleInsetsLw().top;
    if (mCurBottom > top) {
        mCurBottom = top;
    }
    if (DEBUG_LAYOUT)
        Slog.v(TAG, "Input method: mDockBottom=" + mDockBottom + " mContentBottom=" + mContentBottom + " mCurBottom=" + mCurBottom);
}
#end_block

#method_before
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached) {
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = WindowManagerPolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
            mShowingLockscreen = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
    final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else if (win.isDrawnLw() || win.hasAppShownWindows()) {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = (mWinDismissingKeyguard == win && mSecureDismissingKeyguard == mKeyguardSecure) ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mSecureDismissingKeyguard = mKeyguardSecure;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked && (win.isDrawnLw() || win.hasAppShownWindows())) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken() && (attrs.flags & FLAG_SHOW_WHEN_LOCKED) == 0) {
                win.hideLw(false);
            }
        }
    } else if (mTopFullscreenOpaqueWindowState == null && mWinShowWhenLocked == null) {
        // we know whether to show the keyguard or not.
        if (win.isAnimatingLw() && appWindow && showWhenLocked && mKeyguardHidden) {
            mHideLockScreen = true;
            mWinShowWhenLocked = win;
        }
    }
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw() && win.isDimming()) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
}
#method_after
@Override
public void applyPostLayoutPolicyLw(WindowState win, WindowManager.LayoutParams attrs, WindowState attached) {
    if (DEBUG_LAYOUT)
        Slog.i(TAG, "Win " + win + ": isVisibleOrBehindKeyguardLw=" + win.isVisibleOrBehindKeyguardLw());
    final int fl = PolicyControl.getWindowFlags(win, attrs);
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleLw() && attrs.type == TYPE_INPUT_METHOD) {
        mForcingShowNavBar = true;
        mForcingShowNavBarLayer = win.getSurfaceLayer();
    }
    if (attrs.type == TYPE_STATUS_BAR) {
        if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
            mForceStatusBarFromKeyguard = true;
            mShowingLockscreen = true;
        }
        if ((attrs.privateFlags & PRIVATE_FLAG_FORCE_STATUS_BAR_VISIBLE_TRANSPARENT) != 0) {
            mForceStatusBarTransparent = true;
        }
    }
    boolean appWindow = attrs.type >= FIRST_APPLICATION_WINDOW && attrs.type < FIRST_SYSTEM_WINDOW;
    final boolean showWhenLocked = (fl & FLAG_SHOW_WHEN_LOCKED) != 0;
    final boolean dismissKeyguard = (fl & FLAG_DISMISS_KEYGUARD) != 0;
    if (mTopFullscreenOpaqueWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw()) {
        if ((fl & FLAG_FORCE_NOT_FULLSCREEN) != 0) {
            if ((attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                mForceStatusBarFromKeyguard = true;
            } else {
                mForceStatusBar = true;
            }
        }
        if (attrs.type == TYPE_DREAM) {
            // for the dream to draw before hiding the lockscreen.
            if (!mDreamingLockscreen || (win.isVisibleLw() && win.hasDrawnLw())) {
                mShowingDream = true;
                appWindow = true;
            }
        }
        final IApplicationToken appToken = win.getAppToken();
        // windows we defer the decision to the window it is attached to.
        if (appWindow && attached == null) {
            if (showWhenLocked) {
                // Remove any previous windows with the same appToken.
                mAppsToBeHidden.remove(appToken);
                mAppsThatDismissKeyguard.remove(appToken);
                if (mAppsToBeHidden.isEmpty()) {
                    if (dismissKeyguard && !mKeyguardSecure) {
                        mAppsThatDismissKeyguard.add(appToken);
                    } else if (win.isDrawnLw() || win.hasAppShownWindows()) {
                        mWinShowWhenLocked = win;
                        mHideLockScreen = true;
                        mForceStatusBarFromKeyguard = false;
                    }
                }
            } else if (dismissKeyguard) {
                if (mKeyguardSecure) {
                    mAppsToBeHidden.add(appToken);
                } else {
                    mAppsToBeHidden.remove(appToken);
                }
                mAppsThatDismissKeyguard.add(appToken);
            } else {
                mAppsToBeHidden.add(appToken);
            }
            if (attrs.x == 0 && attrs.y == 0 && attrs.width == WindowManager.LayoutParams.MATCH_PARENT && attrs.height == WindowManager.LayoutParams.MATCH_PARENT) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "Fullscreen window: " + win);
                mTopFullscreenOpaqueWindowState = win;
                if (mTopFullscreenOpaqueOrDimmingWindowState == null) {
                    mTopFullscreenOpaqueOrDimmingWindowState = win;
                }
                if (!mAppsThatDismissKeyguard.isEmpty() && mDismissKeyguard == DISMISS_KEYGUARD_NONE) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mDismissKeyguard true by win " + win);
                    mDismissKeyguard = (mWinDismissingKeyguard == win && mSecureDismissingKeyguard == mKeyguardSecure) ? DISMISS_KEYGUARD_CONTINUE : DISMISS_KEYGUARD_START;
                    mWinDismissingKeyguard = win;
                    mSecureDismissingKeyguard = mKeyguardSecure;
                    mForceStatusBarFromKeyguard = mShowingLockscreen && mKeyguardSecure;
                } else if (mAppsToBeHidden.isEmpty() && showWhenLocked && (win.isDrawnLw() || win.hasAppShownWindows())) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Setting mHideLockScreen to true by win " + win);
                    mHideLockScreen = true;
                    mForceStatusBarFromKeyguard = false;
                }
                if ((fl & FLAG_ALLOW_LOCK_WHILE_SCREEN_ON) != 0) {
                    mAllowLockscreenWhenOn = true;
                }
            }
            if (mWinShowWhenLocked != null && mWinShowWhenLocked.getAppToken() != win.getAppToken() && (attrs.flags & FLAG_SHOW_WHEN_LOCKED) == 0) {
                win.hideLw(false);
            }
        }
    } else if (mTopFullscreenOpaqueWindowState == null && mWinShowWhenLocked == null) {
        // we know whether to show the keyguard or not.
        if (win.isAnimatingLw() && appWindow && showWhenLocked && mKeyguardHidden) {
            mHideLockScreen = true;
            mWinShowWhenLocked = win;
        }
    }
    if (mTopFullscreenOpaqueOrDimmingWindowState == null && win.isVisibleOrBehindKeyguardLw() && !win.isGoneForLayoutLw() && win.isDimming()) {
        mTopFullscreenOpaqueOrDimmingWindowState = win;
    }
}
#end_block

#method_before
@Override
public int finishPostLayoutPolicyLw() {
    if (mWinShowWhenLocked != null && mTopFullscreenOpaqueWindowState != null && mWinShowWhenLocked.getAppToken() != mTopFullscreenOpaqueWindowState.getAppToken() && isKeyguardLocked()) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = WindowManagerPolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardSecure) {
            mKeyguardHidden = true;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            mWinDismissingKeyguard = null;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                // Only launch the next keyguard unlock window once per window.
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.dismiss();
                    }
                });
            }
        } else {
            mWinDismissingKeyguard = null;
            mSecureDismissingKeyguard = false;
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
#method_after
@Override
public int finishPostLayoutPolicyLw() {
    if (mWinShowWhenLocked != null && mTopFullscreenOpaqueWindowState != null && mWinShowWhenLocked.getAppToken() != mTopFullscreenOpaqueWindowState.getAppToken() && isKeyguardLocked()) {
        // A dialog is dismissing the keyguard. Put the wallpaper behind it and hide the
        // fullscreen window.
        // TODO: Make sure FLAG_SHOW_WALLPAPER is restored when dialog is dismissed. Or not.
        mWinShowWhenLocked.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        mTopFullscreenOpaqueWindowState.hideLw(false);
        mTopFullscreenOpaqueWindowState = mWinShowWhenLocked;
    }
    int changes = 0;
    boolean topIsFullscreen = false;
    final WindowManager.LayoutParams lp = (mTopFullscreenOpaqueWindowState != null) ? mTopFullscreenOpaqueWindowState.getAttrs() : null;
    // while the dream is showing.
    if (!mShowingDream) {
        mDreamingLockscreen = mShowingLockscreen;
        if (mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = false;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 0, 1).sendToTarget();
        }
    } else {
        if (!mDreamingSleepTokenNeeded) {
            mDreamingSleepTokenNeeded = true;
            mHandler.obtainMessage(MSG_UPDATE_DREAMING_SLEEP_TOKEN, 1, 1).sendToTarget();
        }
    }
    if (mStatusBar != null) {
        if (DEBUG_LAYOUT)
            Slog.i(TAG, "force=" + mForceStatusBar + " forcefkg=" + mForceStatusBarFromKeyguard + " top=" + mTopFullscreenOpaqueWindowState);
        boolean shouldBeTransparent = mForceStatusBarTransparent && !mForceStatusBar && !mForceStatusBarFromKeyguard;
        if (!shouldBeTransparent) {
            mStatusBarController.setShowTransparent(false);
        } else if (!mStatusBar.isVisibleLw()) {
            mStatusBarController.setShowTransparent(true);
        }
        if (mForceStatusBar || mForceStatusBarFromKeyguard || mForceStatusBarTransparent) {
            if (DEBUG_LAYOUT)
                Slog.v(TAG, "Showing status bar: forced");
            if (mStatusBarController.setBarShowingLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT;
            }
            // Maintain fullscreen layout until incoming animation is complete.
            topIsFullscreen = mTopIsFullscreen && mStatusBar.isAnimatingLw();
            // Transient status bar on the lockscreen is not allowed
            if (mForceStatusBarFromKeyguard && mStatusBarController.isTransientShowing()) {
                mStatusBarController.updateVisibilityLw(false, /*transientAllowed*/
                mLastSystemUiFlags, mLastSystemUiFlags);
            }
        } else if (mTopFullscreenOpaqueWindowState != null) {
            final int fl = PolicyControl.getWindowFlags(null, lp);
            if (localLOGV) {
                Slog.d(TAG, "frame: " + mTopFullscreenOpaqueWindowState.getFrameLw() + " shown frame: " + mTopFullscreenOpaqueWindowState.getShownFrameLw());
                Slog.d(TAG, "attr: " + mTopFullscreenOpaqueWindowState.getAttrs() + " lp.flags=0x" + Integer.toHexString(fl));
            }
            topIsFullscreen = (fl & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0 || (mLastSystemUiFlags & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
            // case though.
            if (mStatusBarController.isTransientShowing()) {
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            } else if (topIsFullscreen) {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** HIDING status bar");
                if (mStatusBarController.setBarShowingLw(false)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                } else {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Status bar already hiding");
                }
            } else {
                if (DEBUG_LAYOUT)
                    Slog.v(TAG, "** SHOWING status bar: top is not fullscreen");
                if (mStatusBarController.setBarShowingLw(true)) {
                    changes |= FINISH_LAYOUT_REDO_LAYOUT;
                }
            }
        }
    }
    if (mTopIsFullscreen != topIsFullscreen) {
        if (!topIsFullscreen) {
            // Force another layout when status bar becomes fully shown.
            changes |= FINISH_LAYOUT_REDO_LAYOUT;
        }
        mTopIsFullscreen = topIsFullscreen;
    }
    // displayed when the screen is locked.
    if (mKeyguardDelegate != null && mStatusBar != null) {
        if (localLOGV)
            Slog.v(TAG, "finishPostLayoutPolicyLw: mHideKeyguard=" + mHideLockScreen);
        if (mDismissKeyguard != DISMISS_KEYGUARD_NONE && !mKeyguardSecure) {
            mKeyguardHidden = true;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mKeyguardDelegate.isShowing()) {
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.keyguardDone(false, false);
                    }
                });
            }
        } else if (mHideLockScreen) {
            mKeyguardHidden = true;
            mWinDismissingKeyguard = null;
            if (setKeyguardOccludedLw(true)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        } else if (mDismissKeyguard != DISMISS_KEYGUARD_NONE) {
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
            if (mDismissKeyguard == DISMISS_KEYGUARD_START) {
                // Only launch the next keyguard unlock window once per window.
                mHandler.post(new Runnable() {

                    @Override
                    public void run() {
                        mKeyguardDelegate.dismiss();
                    }
                });
            }
        } else {
            mWinDismissingKeyguard = null;
            mSecureDismissingKeyguard = false;
            mKeyguardHidden = false;
            if (setKeyguardOccludedLw(false)) {
                changes |= FINISH_LAYOUT_REDO_LAYOUT | FINISH_LAYOUT_REDO_CONFIG | FINISH_LAYOUT_REDO_WALLPAPER;
            }
        }
    }
    if ((updateSystemUiVisibilityLw() & SYSTEM_UI_CHANGING_LAYOUT) != 0) {
        // If the navigation bar has been hidden or shown, we need to do another
        // layout pass to update that window.
        changes |= FINISH_LAYOUT_REDO_LAYOUT;
    }
    // update since mAllowLockscreenWhenOn might have changed
    updateLockScreenTimeout();
    return changes;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (mUseTvRouting) {
                    // On TVs volume keys never go to the foreground app
                    result &= ~ACTION_PASS_TO_USER;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                    if ((result & ACTION_PASS_TO_USER) == 0) {
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(event);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to
                            // figure out.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                        }
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY");
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean interactive = (policyFlags & FLAG_INTERACTIVE) != 0;
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (interactive ? isKeyguardShowingAndNotOccluded() : mKeyguardDelegate.isShowing()));
    if (DEBUG_INPUT) {
        Log.d(TAG, "interceptKeyTq keycode=" + keyCode + " interactive=" + interactive + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags));
    }
    // Basic policy based on interactive state.
    int result;
    boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0 || event.isWakeKey();
    if (interactive || (isInjected && !isWakeKey)) {
        // When the device is interactive or the key is injected pass the
        // key to the application.
        result = ACTION_PASS_TO_USER;
        isWakeKey = false;
    } else if (!interactive && shouldDispatchInputWhenNonInteractive()) {
        // If we're currently dozing with the screen on and the keyguard showing, pass the key
        // to the application but preserve its wake key status to make sure we still move
        // from dozing to fully interactive if we would normally go from off to fully
        // interactive.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (isWakeKey && (!down || !isWakeKeyWhenScreenOff(keyCode))) {
            isWakeKey = false;
        }
    }
    // key processing.
    if (isValidGlobalKey(keyCode) && mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        if (isWakeKey) {
            wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
        }
        return result;
    }
    boolean useHapticFeedback = down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0;
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (mUseTvRouting) {
                    // On TVs volume keys never go to the foreground app
                    result &= ~ACTION_PASS_TO_USER;
                }
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeDownKeyTriggered = true;
                            mScreenshotChordVolumeDownKeyTime = event.getDownTime();
                            mScreenshotChordVolumeDownKeyConsumed = false;
                            cancelPendingPowerKeyAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mScreenshotChordVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (interactive && !mScreenshotChordVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mScreenshotChordVolumeUpKeyTriggered = true;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                        }
                    } else {
                        mScreenshotChordVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                    }
                }
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            // If an incoming call is ringing, either VOLUME key means
                            // "silence ringer".  We handle these keys here, rather than
                            // in the InCallScreen, to make sure we'll respond to them
                            // even if the InCallScreen hasn't come to the foreground yet.
                            // Look for the DOWN event here, to agree with the "fallback"
                            // behavior in the InCallScreen.
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                            // Silence the ringer.  (It's safe to call this
                            // even if the ringer has already been silenced.)
                            telecomManager.silenceRinger();
                            // And *don't* pass this key thru to the current activity
                            // (which is probably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                            break;
                        }
                        if (telecomManager.isInCall() && (result & ACTION_PASS_TO_USER) == 0) {
                            // If we are in call but we decided not to pass the key to
                            // the application, just pass it to the session service.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
                            break;
                        }
                    }
                    if ((result & ACTION_PASS_TO_USER) == 0) {
                        if (mUseTvRouting) {
                            dispatchDirectAudioEvent(event);
                        } else {
                            // If we aren't passing to the user and no one else
                            // handled it send it to the session manager to
                            // figure out.
                            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, true);
                        }
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    boolean hungUp = false;
                    if (telecomManager != null) {
                        hungUp = telecomManager.endCall();
                    }
                    if (interactive && !hungUp) {
                        mEndCallKeyHandled = false;
                        mHandler.postDelayed(mEndCallLongPress, ViewConfiguration.get(mContext).getDeviceGlobalActionKeyTimeout());
                    } else {
                        mEndCallKeyHandled = true;
                    }
                } else {
                    if (!mEndCallKeyHandled) {
                        mHandler.removeCallbacks(mEndCallLongPress);
                        if (!canceled) {
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                                if (goHome()) {
                                    break;
                                }
                            }
                            if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                                mPowerManager.goToSleep(event.getEventTime(), PowerManager.GO_TO_SLEEP_REASON_POWER_BUTTON, 0);
                                isWakeKey = false;
                            }
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                if ((mTopFullscreenOpaqueWindowState.getAttrs().privateFlags & WindowManager.LayoutParams.PRIVATE_FLAG_PREVENT_POWER_KEY) != 0 && mScreenOnFully) {
                    return result;
                }
                result &= ~ACTION_PASS_TO_USER;
                // wake-up will be handled separately
                isWakeKey = false;
                if (down) {
                    interceptPowerKeyDown(event, interactive);
                } else {
                    interceptPowerKeyUp(event, interactive, canceled);
                }
                break;
            }
        case KeyEvent.KEYCODE_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!mPowerManager.isInteractive()) {
                    // suppress feedback if already non-interactive
                    useHapticFeedback = false;
                }
                if (down) {
                    sleepPress(event.getEventTime());
                } else {
                    sleepRelease(event.getEventTime());
                }
                break;
            }
        case KeyEvent.KEYCODE_SOFT_SLEEP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = false;
                if (!down) {
                    mPowerManagerInternal.setUserInactiveOverrideFromWindowManager();
                }
                break;
            }
        case KeyEvent.KEYCODE_WAKEUP:
            {
                result &= ~ACTION_PASS_TO_USER;
                isWakeKey = true;
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if (MediaSessionLegacyHelper.getHelper(mContext).isGlobalPriorityActive()) {
                    // If the global session is active pass all media keys to it
                    // instead of the active window.
                    result &= ~ACTION_PASS_TO_USER;
                }
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    TelecomManager telecomManager = getTelecommService();
                    if (telecomManager != null) {
                        if (telecomManager.isRinging()) {
                            Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                            telecomManager.acceptRingingCall();
                            // And *don't* pass this key thru to the current activity
                            // (which is presumably the InCallScreen.)
                            result &= ~ACTION_PASS_TO_USER;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_VOICE_ASSIST:
            {
                // key event here because the original key event will be recycled when we return.
                if ((result & ACTION_PASS_TO_USER) == 0 && !down) {
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_LAUNCH_VOICE_ASSIST_WITH_WAKE_LOCK, keyguardActive ? 1 : 0, 0);
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
            }
    }
    if (useHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    if (isWakeKey) {
        wakeUp(event.getEventTime(), mAllowTheaterModeWakeFromKey, "android.policy:KEY", true);
    }
    return result;
}
#end_block

#method_before
private void wakeUpFromPowerKey(long eventTime) {
    wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, "android.policy:POWER");
}
#method_after
private void wakeUpFromPowerKey(long eventTime) {
    wakeUp(eventTime, mAllowTheaterModeWakeFromPowerKey, "android.policy:POWER", true);
}
#end_block

#method_before
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    mPowerManager.wakeUp(wakeTime, reason);
    return true;
}
#method_after
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    return wakeUp(wakeTime, wakeInTheaterMode, reason, false);
}
#end_block

#method_before
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    mPowerManager.wakeUp(wakeTime, reason);
    return true;
}
#method_after
private boolean wakeUp(long wakeTime, boolean wakeInTheaterMode, String reason, boolean withProximityCheck) {
    final boolean theaterModeEnabled = isTheaterModeEnabled();
    if (!wakeInTheaterMode && theaterModeEnabled) {
        return false;
    }
    if (theaterModeEnabled) {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0);
    }
    if (withProximityCheck) {
        mPowerManager.wakeUpWithProximityCheck(wakeTime, reason);
    } else {
        mPowerManager.wakeUp(wakeTime, reason);
    }
    return true;
}
#end_block

#method_before
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
            if (mBootMessageNeedsHiding) {
                mBootMessageNeedsHiding = false;
                hideBootMessages();
            }
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
}
#method_after
private void finishScreenTurningOn() {
    synchronized (mLock) {
        // We have just finished drawing screen content. Since the orientation listener
        // gets only installed when all windows are drawn, we try to install it again.
        updateOrientationListenerLp();
    }
    final ScreenOnListener listener;
    final boolean enableScreen;
    synchronized (mLock) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "finishScreenTurningOn: mAwake=" + mAwake + ", mScreenOnEarly=" + mScreenOnEarly + ", mScreenOnFully=" + mScreenOnFully + ", mKeyguardDrawComplete=" + mKeyguardDrawComplete + ", mWindowManagerDrawComplete=" + mWindowManagerDrawComplete);
        if (mScreenOnFully || !mScreenOnEarly || !mWindowManagerDrawComplete || (mAwake && !mKeyguardDrawComplete)) {
            // spurious or not ready yet
            return;
        }
        if (DEBUG_WAKEUP)
            Slog.i(TAG, "Finished screen turning on...");
        listener = mScreenOnListener;
        mScreenOnListener = null;
        mScreenOnFully = true;
        // the main part of booting and can enable the screen and hide boot messages.
        if (!mKeyguardDrawnOnce && mAwake) {
            mKeyguardDrawnOnce = true;
            enableScreen = true;
        } else {
            enableScreen = false;
        }
    }
    if (listener != null) {
        listener.onScreenOn();
    }
    if (enableScreen) {
        try {
            mWindowManager.enableScreenIfNeeded();
        } catch (RemoteException unhandled) {
        }
    }
}
#end_block

#method_before
private void handleHideBootMessage() {
    synchronized (mLock) {
        if (!mKeyguardDrawnOnce) {
            mBootMessageNeedsHiding = true;
            // keyguard hasn't drawn the first time yet, not done booting
            return;
        }
    }
    if (mBootMsgDialog != null) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "handleHideBootMessage: dismissing");
        mBootMsgDialog.dismiss();
        mBootMsgDialog = null;
    }
}
#method_after
private void handleHideBootMessage() {
    synchronized (mLock) {
        if (!mKeyguardDrawComplete) {
            // keyguard hasn't completed drawing, not done booting.
            return;
        }
    }
    if (mBootMsgDialog != null) {
        if (DEBUG_WAKEUP)
            Slog.d(TAG, "handleHideBootMessage: dismissing");
        mBootMsgDialog.dismiss();
        mBootMsgDialog = null;
    }
}
#end_block

#method_before
@Override
public void showBootMessage(final CharSequence msg, final boolean always) {
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog == null) {
                int theme;
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                    theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
                } else if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION)) {
                    theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
                } else {
                    theme = 0;
                }
                mBootMsgDialog = new ProgressDialog(mContext, theme) {

                    // This dialog will consume all events coming in to
                    // it, to avoid it trying to do things too early in boot.
                    @Override
                    public boolean dispatchKeyEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTouchEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTrackballEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
                        return true;
                    }
                };
                if (mContext.getPackageManager().isUpgrade()) {
                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                } else {
                    mBootMsgDialog.setTitle(R.string.android_start_title);
                }
                mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mBootMsgDialog.setIndeterminate(true);
                mBootMsgDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                mBootMsgDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                mBootMsgDialog.getWindow().setDimAmount(1);
                WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                mBootMsgDialog.getWindow().setAttributes(lp);
                mBootMsgDialog.setCancelable(false);
                mBootMsgDialog.show();
            }
            mBootMsgDialog.setMessage(msg);
        }
    });
}
#method_after
@Override
public void showBootMessage(final CharSequence msg, final boolean always) {
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mBootMsgDialog == null) {
                int theme;
                if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_WATCH)) {
                    theme = com.android.internal.R.style.Theme_Micro_Dialog_Alert;
                } else if (mContext.getPackageManager().hasSystemFeature(PackageManager.FEATURE_TELEVISION)) {
                    theme = com.android.internal.R.style.Theme_Leanback_Dialog_Alert;
                } else {
                    theme = 6;
                }
                mBootMsgDialog = new ProgressDialog(mContext, theme) {

                    // This dialog will consume all events coming in to
                    // it, to avoid it trying to do things too early in boot.
                    @Override
                    public boolean dispatchKeyEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchKeyShortcutEvent(KeyEvent event) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTouchEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchTrackballEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchGenericMotionEvent(MotionEvent ev) {
                        return true;
                    }

                    @Override
                    public boolean dispatchPopulateAccessibilityEvent(AccessibilityEvent event) {
                        return true;
                    }
                };
                if (mContext.getPackageManager().isUpgrade()) {
                    mBootMsgDialog.setTitle(R.string.android_upgrading_title);
                } else {
                    mBootMsgDialog.setTitle(R.string.android_start_title);
                }
                mBootMsgDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER);
                mBootMsgDialog.setIndeterminate(true);
                mBootMsgDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_BOOT_PROGRESS);
                mBootMsgDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DIM_BEHIND | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
                mBootMsgDialog.getWindow().setDimAmount(1);
                WindowManager.LayoutParams lp = mBootMsgDialog.getWindow().getAttributes();
                lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR;
                mBootMsgDialog.getWindow().setAttributes(lp);
                mBootMsgDialog.setCancelable(false);
                mBootMsgDialog.show();
            }
            if (always && (currentPackageName != null)) {
                // Only display the current package name if the main message says
                // "Optimizing app N of M".
                // We don't want to do this when the message says "Starting apps" or
                // "Finishing boot", etc.
                mBootMsgDialog.setMessage(msg + "\n" + currentPackageName);
            } else {
                mBootMsgDialog.setMessage(msg);
            }
        }
    });
}
#end_block

#method_before
private void applyLidSwitchState() {
    if (mLidState == LID_CLOSED && mLidControlsSleep) {
        mPowerManager.goToSleep(SystemClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_LID_SWITCH, PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE);
    }
    synchronized (mLock) {
        updateWakeGestureListenerLp();
    }
}
#method_after
private void applyLidSwitchState() {
    mPowerManager.setKeyboardVisibility(isBuiltInKeyboardVisible());
    if (mLidState == LID_CLOSED && mLidControlsSleep) {
        mPowerManager.goToSleep(SystemClock.uptimeMillis(), PowerManager.GO_TO_SLEEP_REASON_LID_SWITCH, PowerManager.GO_TO_SLEEP_FLAG_NO_DOZE);
    }
    synchronized (mLock) {
        updateWakeGestureListenerLp();
    }
}
#end_block

#method_before
private int updateSystemUiVisibilityLw() {
    // If there is no window focused, there will be nobody to handle the events
    // anyway, so just hang on in whatever state we're in until things settle down.
    final WindowState win = mFocusedWindow != null ? mFocusedWindow : mTopFullscreenOpaqueWindowState;
    if (win == null) {
        return 0;
    }
    if ((win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0 && mHideLockScreen == true) {
        // will quickly lose focus once it correctly gets hidden.
        return 0;
    }
    int tmpVisibility = WindowManagerPolicyControl.getSystemUiVisibility(win, null) & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
    boolean wasCleared = mClearedBecauseOfForceShow;
    if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
        tmpVisibility &= ~WindowManagerPolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
        mClearedBecauseOfForceShow = true;
    } else {
        mClearedBecauseOfForceShow = false;
    }
    // transient state have more priority than translucent (why?) and cause bad UX
    if (wasCleared && !mClearedBecauseOfForceShow && (tmpVisibility & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0) {
        mNavigationBarController.showTransient();
        tmpVisibility |= View.NAVIGATION_BAR_TRANSIENT;
        mWindowManagerFuncs.addSystemUIVisibilityFlag(View.NAVIGATION_BAR_TRANSIENT);
    }
    boolean topWindowWasKeyguard = mTopWindowIsKeyguard;
    mTopWindowIsKeyguard = (win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0;
    if (topWindowWasKeyguard && !mTopWindowIsKeyguard && (tmpVisibility & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0) {
        mStatusBarController.showTransient();
        tmpVisibility |= View.STATUS_BAR_TRANSIENT;
        mWindowManagerFuncs.addSystemUIVisibilityFlag(View.STATUS_BAR_TRANSIENT);
    }
    final int visibility = updateSystemBarsLw(win, mLastSystemUiFlags, tmpVisibility);
    final int diff = visibility ^ mLastSystemUiFlags;
    final boolean needsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
    if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == win.getAppToken()) {
        return 0;
    }
    mLastSystemUiFlags = visibility;
    mLastFocusNeedsMenu = needsMenu;
    mFocusedApp = win.getAppToken();
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                IStatusBarService statusbar = getStatusBarService();
                if (statusbar != null) {
                    statusbar.setSystemUiVisibility(visibility, 0xffffffff, win.toString());
                    statusbar.topAppWindowChanged(needsMenu);
                }
            } catch (RemoteException e) {
                // re-acquire status bar service next time it is needed.
                mStatusBarService = null;
            }
        }
    });
    return diff;
}
#method_after
private int updateSystemUiVisibilityLw() {
    // If there is no window focused, there will be nobody to handle the events
    // anyway, so just hang on in whatever state we're in until things settle down.
    final WindowState win = mFocusedWindow != null ? mFocusedWindow : mTopFullscreenOpaqueWindowState;
    if (win == null) {
        return 0;
    }
    if ((win.getAttrs().privateFlags & PRIVATE_FLAG_KEYGUARD) != 0 && mHideLockScreen == true) {
        // will quickly lose focus once it correctly gets hidden.
        return 0;
    }
    int tmpVisibility = PolicyControl.getSystemUiVisibility(win, null) & ~mResettingSystemUiFlags & ~mForceClearedSystemUiFlags;
    if (mForcingShowNavBar && win.getSurfaceLayer() < mForcingShowNavBarLayer) {
        tmpVisibility &= ~PolicyControl.adjustClearableFlags(win, View.SYSTEM_UI_CLEARABLE_FLAGS);
    }
    tmpVisibility = updateLightStatusBarLw(tmpVisibility);
    final int visibility = updateSystemBarsLw(win, mLastSystemUiFlags, tmpVisibility);
    final int diff = visibility ^ mLastSystemUiFlags;
    final boolean needsMenu = win.getNeedsMenuLw(mTopFullscreenOpaqueWindowState);
    if (diff == 0 && mLastFocusNeedsMenu == needsMenu && mFocusedApp == win.getAppToken()) {
        return 0;
    }
    mLastSystemUiFlags = visibility;
    mLastFocusNeedsMenu = needsMenu;
    mFocusedApp = win.getAppToken();
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                IStatusBarService statusbar = getStatusBarService();
                if (statusbar != null) {
                    statusbar.setSystemUiVisibility(visibility, 0xffffffff, win.toString());
                    statusbar.topAppWindowChanged(needsMenu);
                }
            } catch (RemoteException e) {
                // re-acquire status bar service next time it is needed.
                mStatusBarService = null;
            }
        }
    });
    return diff;
}
#end_block

#method_before
private int updateLightStatusBarLw(int vis) {
    WindowState statusColorWin = isStatusBarKeyguard() && !mHideLockScreen ? mStatusBar : mTopFullscreenOpaqueOrDimmingWindowState;
    if (statusColorWin != null) {
        if (statusColorWin == mTopFullscreenOpaqueWindowState) {
            // If the top fullscreen-or-dimming window is also the top fullscreen, respect
            // its light flag.
            vis &= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
            vis |= WindowManagerPolicyControl.getSystemUiVisibility(statusColorWin, null) & View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        } else if (statusColorWin != null && statusColorWin.isDimming()) {
            // Otherwise if it's dimming, clear the light flag.
            vis &= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        }
    }
    return vis;
}
#method_after
private int updateLightStatusBarLw(int vis) {
    WindowState statusColorWin = isStatusBarKeyguard() && !mHideLockScreen ? mStatusBar : mTopFullscreenOpaqueOrDimmingWindowState;
    if (statusColorWin != null) {
        if (statusColorWin == mTopFullscreenOpaqueWindowState) {
            // If the top fullscreen-or-dimming window is also the top fullscreen, respect
            // its light flag.
            vis &= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
            vis |= PolicyControl.getSystemUiVisibility(statusColorWin, null) & View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        } else if (statusColorWin != null && statusColorWin.isDimming()) {
            // Otherwise if it's dimming, clear the light flag.
            vis &= ~View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        }
    }
    return vis;
}
#end_block

#method_before
private int updateSystemBarsLw(WindowState win, int oldVis, int vis) {
    // apply translucent bar vis flags
    WindowState transWin = isStatusBarKeyguard() && !mHideLockScreen ? mStatusBar : mTopFullscreenOpaqueWindowState;
    vis = mStatusBarController.applyTranslucentFlagLw(transWin, vis, oldVis);
    vis = mNavigationBarController.applyTranslucentFlagLw(transWin, vis, oldVis);
    // prevent status bar interaction from clearing certain flags
    int type = win.getAttrs().type;
    boolean statusBarHasFocus = type == TYPE_STATUS_BAR;
    if (statusBarHasFocus && !isStatusBarKeyguard()) {
        int flags = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        if (mHideLockScreen) {
            flags |= View.STATUS_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSLUCENT;
        }
        vis = (vis & ~flags) | (oldVis & flags);
    }
    if (!areTranslucentBarsAllowed() && transWin != mStatusBar) {
        vis &= ~(View.NAVIGATION_BAR_TRANSLUCENT | View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT);
    }
    // update status bar
    boolean immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    boolean hideStatusBarWM = mTopFullscreenOpaqueWindowState != null && (WindowManagerPolicyControl.getWindowFlags(mTopFullscreenOpaqueWindowState, null) & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
    boolean hideStatusBarSysui = (vis & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
    boolean hideNavBarSysui = (vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0;
    boolean transientStatusBarAllowed = mStatusBar != null && (hideStatusBarWM || (hideStatusBarSysui && immersiveSticky) || statusBarHasFocus);
    boolean transientNavBarAllowed = mNavigationBar != null && hideNavBarSysui && immersiveSticky;
    final long now = SystemClock.uptimeMillis();
    final boolean pendingPanic = mPendingPanicGestureUptime != 0 && now - mPendingPanicGestureUptime <= PANIC_GESTURE_EXPIRATION;
    if (pendingPanic && hideNavBarSysui && !isStatusBarKeyguard() && mKeyguardDrawComplete) {
        // The user performed the panic gesture recently, we're about to hide the bars,
        // we're no longer on the Keyguard and the screen is ready. We can now request the bars.
        mPendingPanicGestureUptime = 0;
        mStatusBarController.showTransient();
        mNavigationBarController.showTransient();
    }
    boolean denyTransientStatus = mStatusBarController.isTransientShowRequested() && !transientStatusBarAllowed && hideStatusBarSysui;
    boolean denyTransientNav = mNavigationBarController.isTransientShowRequested() && !transientNavBarAllowed;
    if (denyTransientStatus || denyTransientNav) {
        // clear the clearable flags instead
        clearClearableFlagsLw();
        vis &= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
    }
    final boolean immersive = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
    immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    final boolean navAllowedHidden = immersive || immersiveSticky;
    if (hideNavBarSysui && !navAllowedHidden && windowTypeToLayerLw(win.getBaseType()) > windowTypeToLayerLw(TYPE_INPUT_CONSUMER)) {
        // We can't hide the navbar from this window otherwise the input consumer would not get
        // the input events.
        vis = (vis & ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
    }
    vis = mStatusBarController.updateVisibilityLw(transientStatusBarAllowed, oldVis, vis);
    // update navigation bar
    boolean oldImmersiveMode = isImmersiveMode(oldVis);
    boolean newImmersiveMode = isImmersiveMode(vis);
    if (win != null && oldImmersiveMode != newImmersiveMode) {
        final String pkg = win.getOwningPackage();
        mImmersiveModeConfirmation.immersiveModeChanged(pkg, newImmersiveMode, isUserSetupComplete());
    }
    vis = mNavigationBarController.updateVisibilityLw(transientNavBarAllowed, oldVis, vis);
    return vis;
}
#method_after
private int updateSystemBarsLw(WindowState win, int oldVis, int vis) {
    // apply translucent bar vis flags
    WindowState transWin = isStatusBarKeyguard() && !mHideLockScreen ? mStatusBar : mTopFullscreenOpaqueWindowState;
    vis = mStatusBarController.applyTranslucentFlagLw(transWin, vis, oldVis);
    vis = mNavigationBarController.applyTranslucentFlagLw(transWin, vis, oldVis);
    // prevent status bar interaction from clearing certain flags
    int type = win.getAttrs().type;
    boolean statusBarHasFocus = type == TYPE_STATUS_BAR;
    if (statusBarHasFocus && !isStatusBarKeyguard()) {
        int flags = View.SYSTEM_UI_FLAG_FULLSCREEN | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;
        if (mHideLockScreen) {
            flags |= View.STATUS_BAR_TRANSLUCENT | View.NAVIGATION_BAR_TRANSLUCENT;
        }
        vis = (vis & ~flags) | (oldVis & flags);
    }
    if (!areTranslucentBarsAllowed() && transWin != mStatusBar) {
        vis &= ~(View.NAVIGATION_BAR_TRANSLUCENT | View.STATUS_BAR_TRANSLUCENT | View.SYSTEM_UI_TRANSPARENT);
    }
    // update status bar
    boolean immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    boolean hideStatusBarWM = mTopFullscreenOpaqueWindowState != null && (PolicyControl.getWindowFlags(mTopFullscreenOpaqueWindowState, null) & WindowManager.LayoutParams.FLAG_FULLSCREEN) != 0;
    boolean hideStatusBarSysui = (vis & View.SYSTEM_UI_FLAG_FULLSCREEN) != 0;
    boolean hideNavBarSysui = (vis & View.SYSTEM_UI_FLAG_HIDE_NAVIGATION) != 0;
    boolean transientStatusBarAllowed = mStatusBar != null && (hideStatusBarWM || (hideStatusBarSysui && immersiveSticky) || statusBarHasFocus);
    boolean transientNavBarAllowed = mNavigationBar != null && hideNavBarSysui && immersiveSticky;
    final long now = SystemClock.uptimeMillis();
    final boolean pendingPanic = mPendingPanicGestureUptime != 0 && now - mPendingPanicGestureUptime <= PANIC_GESTURE_EXPIRATION;
    if (pendingPanic && hideNavBarSysui && !isStatusBarKeyguard() && mKeyguardDrawComplete) {
        // The user performed the panic gesture recently, we're about to hide the bars,
        // we're no longer on the Keyguard and the screen is ready. We can now request the bars.
        mPendingPanicGestureUptime = 0;
        mStatusBarController.showTransient();
        mNavigationBarController.showTransient();
    }
    boolean denyTransientStatus = mStatusBarController.isTransientShowRequested() && !transientStatusBarAllowed && hideStatusBarSysui;
    boolean denyTransientNav = mNavigationBarController.isTransientShowRequested() && !transientNavBarAllowed;
    if (denyTransientStatus || denyTransientNav) {
        // clear the clearable flags instead
        clearClearableFlagsLw();
        vis &= ~View.SYSTEM_UI_CLEARABLE_FLAGS;
    }
    final boolean immersive = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE) != 0;
    immersiveSticky = (vis & View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY) != 0;
    final boolean navAllowedHidden = immersive || immersiveSticky;
    if (hideNavBarSysui && !navAllowedHidden && windowTypeToLayerLw(win.getBaseType()) > windowTypeToLayerLw(TYPE_INPUT_CONSUMER)) {
        // We can't hide the navbar from this window otherwise the input consumer would not get
        // the input events.
        vis = (vis & ~View.SYSTEM_UI_FLAG_HIDE_NAVIGATION);
    }
    vis = mStatusBarController.updateVisibilityLw(transientStatusBarAllowed, oldVis, vis);
    // update navigation bar
    boolean oldImmersiveMode = isImmersiveMode(oldVis);
    boolean newImmersiveMode = isImmersiveMode(vis);
    if (win != null && oldImmersiveMode != newImmersiveMode) {
        final String pkg = win.getOwningPackage();
        mImmersiveModeConfirmation.immersiveModeChanged(pkg, newImmersiveMode, isUserSetupComplete());
    }
    vis = mNavigationBarController.updateVisibilityLw(transientNavBarAllowed, oldVis, vis);
    return vis;
}
#end_block

#method_before
@Override
public void dump(String prefix, PrintWriter pw, String[] args) {
    pw.print(prefix);
    pw.print("mSafeMode=");
    pw.print(mSafeMode);
    pw.print(" mSystemReady=");
    pw.print(mSystemReady);
    pw.print(" mSystemBooted=");
    pw.println(mSystemBooted);
    pw.print(prefix);
    pw.print("mLidState=");
    pw.print(mLidState);
    pw.print(" mLidOpenRotation=");
    pw.print(mLidOpenRotation);
    pw.print(" mCameraLensCoverState=");
    pw.print(mCameraLensCoverState);
    pw.print(" mHdmiPlugged=");
    pw.println(mHdmiPlugged);
    if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
        pw.print(prefix);
        pw.print("mLastSystemUiFlags=0x");
        pw.print(Integer.toHexString(mLastSystemUiFlags));
        pw.print(" mResettingSystemUiFlags=0x");
        pw.print(Integer.toHexString(mResettingSystemUiFlags));
        pw.print(" mForceClearedSystemUiFlags=0x");
        pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
    }
    if (mLastFocusNeedsMenu) {
        pw.print(prefix);
        pw.print("mLastFocusNeedsMenu=");
        pw.println(mLastFocusNeedsMenu);
    }
    pw.print(prefix);
    pw.print("mWakeGestureEnabledSetting=");
    pw.println(mWakeGestureEnabledSetting);
    pw.print(prefix);
    pw.print("mSupportAutoRotation=");
    pw.println(mSupportAutoRotation);
    pw.print(prefix);
    pw.print("mUiMode=");
    pw.print(mUiMode);
    pw.print(" mDockMode=");
    pw.print(mDockMode);
    pw.print(" mCarDockRotation=");
    pw.print(mCarDockRotation);
    pw.print(" mDeskDockRotation=");
    pw.println(mDeskDockRotation);
    pw.print(prefix);
    pw.print("mUserRotationMode=");
    pw.print(mUserRotationMode);
    pw.print(" mUserRotation=");
    pw.print(mUserRotation);
    pw.print(" mAllowAllRotations=");
    pw.println(mAllowAllRotations);
    pw.print(prefix);
    pw.print("mCurrentAppOrientation=");
    pw.println(mCurrentAppOrientation);
    pw.print(prefix);
    pw.print("mCarDockEnablesAccelerometer=");
    pw.print(mCarDockEnablesAccelerometer);
    pw.print(" mDeskDockEnablesAccelerometer=");
    pw.println(mDeskDockEnablesAccelerometer);
    pw.print(prefix);
    pw.print("mLidKeyboardAccessibility=");
    pw.print(mLidKeyboardAccessibility);
    pw.print(" mLidNavigationAccessibility=");
    pw.print(mLidNavigationAccessibility);
    pw.print(" mLidControlsSleep=");
    pw.println(mLidControlsSleep);
    pw.print(prefix);
    pw.print("mShortPressOnPowerBehavior=");
    pw.print(mShortPressOnPowerBehavior);
    pw.print(" mLongPressOnPowerBehavior=");
    pw.println(mLongPressOnPowerBehavior);
    pw.print(prefix);
    pw.print("mDoublePressOnPowerBehavior=");
    pw.print(mDoublePressOnPowerBehavior);
    pw.print(" mTriplePressOnPowerBehavior=");
    pw.println(mTriplePressOnPowerBehavior);
    pw.print(prefix);
    pw.print("mHasSoftInput=");
    pw.println(mHasSoftInput);
    pw.print(prefix);
    pw.print("mAwake=");
    pw.println(mAwake);
    pw.print(prefix);
    pw.print("mScreenOnEarly=");
    pw.print(mScreenOnEarly);
    pw.print(" mScreenOnFully=");
    pw.println(mScreenOnFully);
    pw.print(prefix);
    pw.print("mKeyguardDrawComplete=");
    pw.print(mKeyguardDrawComplete);
    pw.print(" mWindowManagerDrawComplete=");
    pw.println(mWindowManagerDrawComplete);
    pw.print(prefix);
    pw.print("mOrientationSensorEnabled=");
    pw.println(mOrientationSensorEnabled);
    pw.print(prefix);
    pw.print("mOverscanScreen=(");
    pw.print(mOverscanScreenLeft);
    pw.print(",");
    pw.print(mOverscanScreenTop);
    pw.print(") ");
    pw.print(mOverscanScreenWidth);
    pw.print("x");
    pw.println(mOverscanScreenHeight);
    if (mOverscanLeft != 0 || mOverscanTop != 0 || mOverscanRight != 0 || mOverscanBottom != 0) {
        pw.print(prefix);
        pw.print("mOverscan left=");
        pw.print(mOverscanLeft);
        pw.print(" top=");
        pw.print(mOverscanTop);
        pw.print(" right=");
        pw.print(mOverscanRight);
        pw.print(" bottom=");
        pw.println(mOverscanBottom);
    }
    pw.print(prefix);
    pw.print("mRestrictedOverscanScreen=(");
    pw.print(mRestrictedOverscanScreenLeft);
    pw.print(",");
    pw.print(mRestrictedOverscanScreenTop);
    pw.print(") ");
    pw.print(mRestrictedOverscanScreenWidth);
    pw.print("x");
    pw.println(mRestrictedOverscanScreenHeight);
    pw.print(prefix);
    pw.print("mUnrestrictedScreen=(");
    pw.print(mUnrestrictedScreenLeft);
    pw.print(",");
    pw.print(mUnrestrictedScreenTop);
    pw.print(") ");
    pw.print(mUnrestrictedScreenWidth);
    pw.print("x");
    pw.println(mUnrestrictedScreenHeight);
    pw.print(prefix);
    pw.print("mRestrictedScreen=(");
    pw.print(mRestrictedScreenLeft);
    pw.print(",");
    pw.print(mRestrictedScreenTop);
    pw.print(") ");
    pw.print(mRestrictedScreenWidth);
    pw.print("x");
    pw.println(mRestrictedScreenHeight);
    pw.print(prefix);
    pw.print("mStableFullscreen=(");
    pw.print(mStableFullscreenLeft);
    pw.print(",");
    pw.print(mStableFullscreenTop);
    pw.print(")-(");
    pw.print(mStableFullscreenRight);
    pw.print(",");
    pw.print(mStableFullscreenBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mStable=(");
    pw.print(mStableLeft);
    pw.print(",");
    pw.print(mStableTop);
    pw.print(")-(");
    pw.print(mStableRight);
    pw.print(",");
    pw.print(mStableBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mSystem=(");
    pw.print(mSystemLeft);
    pw.print(",");
    pw.print(mSystemTop);
    pw.print(")-(");
    pw.print(mSystemRight);
    pw.print(",");
    pw.print(mSystemBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mCur=(");
    pw.print(mCurLeft);
    pw.print(",");
    pw.print(mCurTop);
    pw.print(")-(");
    pw.print(mCurRight);
    pw.print(",");
    pw.print(mCurBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mContent=(");
    pw.print(mContentLeft);
    pw.print(",");
    pw.print(mContentTop);
    pw.print(")-(");
    pw.print(mContentRight);
    pw.print(",");
    pw.print(mContentBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mVoiceContent=(");
    pw.print(mVoiceContentLeft);
    pw.print(",");
    pw.print(mVoiceContentTop);
    pw.print(")-(");
    pw.print(mVoiceContentRight);
    pw.print(",");
    pw.print(mVoiceContentBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mDock=(");
    pw.print(mDockLeft);
    pw.print(",");
    pw.print(mDockTop);
    pw.print(")-(");
    pw.print(mDockRight);
    pw.print(",");
    pw.print(mDockBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mDockLayer=");
    pw.print(mDockLayer);
    pw.print(" mStatusBarLayer=");
    pw.println(mStatusBarLayer);
    pw.print(prefix);
    pw.print("mShowingLockscreen=");
    pw.print(mShowingLockscreen);
    pw.print(" mShowingDream=");
    pw.print(mShowingDream);
    pw.print(" mDreamingLockscreen=");
    pw.print(mDreamingLockscreen);
    pw.print(" mDreamingSleepToken=");
    pw.println(mDreamingSleepToken);
    if (mLastInputMethodWindow != null) {
        pw.print(prefix);
        pw.print("mLastInputMethodWindow=");
        pw.println(mLastInputMethodWindow);
    }
    if (mLastInputMethodTargetWindow != null) {
        pw.print(prefix);
        pw.print("mLastInputMethodTargetWindow=");
        pw.println(mLastInputMethodTargetWindow);
    }
    if (mStatusBar != null) {
        pw.print(prefix);
        pw.print("mStatusBar=");
        pw.print(mStatusBar);
        pw.print(" isStatusBarKeyguard=");
        pw.println(isStatusBarKeyguard());
    }
    if (mNavigationBar != null) {
        pw.print(prefix);
        pw.print("mNavigationBar=");
        pw.println(mNavigationBar);
    }
    if (mFocusedWindow != null) {
        pw.print(prefix);
        pw.print("mFocusedWindow=");
        pw.println(mFocusedWindow);
    }
    if (mFocusedApp != null) {
        pw.print(prefix);
        pw.print("mFocusedApp=");
        pw.println(mFocusedApp);
    }
    if (mWinDismissingKeyguard != null) {
        pw.print(prefix);
        pw.print("mWinDismissingKeyguard=");
        pw.println(mWinDismissingKeyguard);
    }
    if (mTopFullscreenOpaqueWindowState != null) {
        pw.print(prefix);
        pw.print("mTopFullscreenOpaqueWindowState=");
        pw.println(mTopFullscreenOpaqueWindowState);
    }
    if (mTopFullscreenOpaqueOrDimmingWindowState != null) {
        pw.print(prefix);
        pw.print("mTopFullscreenOpaqueOrDimmingWindowState=");
        pw.println(mTopFullscreenOpaqueOrDimmingWindowState);
    }
    if (mForcingShowNavBar) {
        pw.print(prefix);
        pw.print("mForcingShowNavBar=");
        pw.println(mForcingShowNavBar);
        pw.print("mForcingShowNavBarLayer=");
        pw.println(mForcingShowNavBarLayer);
    }
    pw.print(prefix);
    pw.print("mTopIsFullscreen=");
    pw.print(mTopIsFullscreen);
    pw.print(" mHideLockScreen=");
    pw.println(mHideLockScreen);
    pw.print(prefix);
    pw.print("mForceStatusBar=");
    pw.print(mForceStatusBar);
    pw.print(" mForceStatusBarFromKeyguard=");
    pw.println(mForceStatusBarFromKeyguard);
    pw.print(prefix);
    pw.print("mDismissKeyguard=");
    pw.print(mDismissKeyguard);
    pw.print(" mWinDismissingKeyguard=");
    pw.print(mWinDismissingKeyguard);
    pw.print(" mHomePressed=");
    pw.println(mHomePressed);
    pw.print(prefix);
    pw.print("mAllowLockscreenWhenOn=");
    pw.print(mAllowLockscreenWhenOn);
    pw.print(" mLockScreenTimeout=");
    pw.print(mLockScreenTimeout);
    pw.print(" mLockScreenTimerActive=");
    pw.println(mLockScreenTimerActive);
    pw.print(prefix);
    pw.print("mEndcallBehavior=");
    pw.print(mEndcallBehavior);
    pw.print(" mIncallPowerBehavior=");
    pw.print(mIncallPowerBehavior);
    pw.print(" mLongPressOnHomeBehavior=");
    pw.println(mLongPressOnHomeBehavior);
    pw.print(prefix);
    pw.print("mLandscapeRotation=");
    pw.print(mLandscapeRotation);
    pw.print(" mSeascapeRotation=");
    pw.println(mSeascapeRotation);
    pw.print(prefix);
    pw.print("mPortraitRotation=");
    pw.print(mPortraitRotation);
    pw.print(" mUpsideDownRotation=");
    pw.println(mUpsideDownRotation);
    pw.print(prefix);
    pw.print("mDemoHdmiRotation=");
    pw.print(mDemoHdmiRotation);
    pw.print(" mDemoHdmiRotationLock=");
    pw.println(mDemoHdmiRotationLock);
    pw.print(prefix);
    pw.print("mUndockedHdmiRotation=");
    pw.println(mUndockedHdmiRotation);
    mGlobalKeyManager.dump(prefix, pw);
    mStatusBarController.dump(pw, prefix);
    mNavigationBarController.dump(pw, prefix);
    WindowManagerPolicyControl.dump(prefix, pw);
    if (mWakeGestureListener != null) {
        mWakeGestureListener.dump(pw, prefix);
    }
    if (mOrientationListener != null) {
        mOrientationListener.dump(pw, prefix);
    }
    if (mBurnInProtectionHelper != null) {
        mBurnInProtectionHelper.dump(prefix, pw);
    }
    if (mKeyguardDelegate != null) {
        mKeyguardDelegate.dump(prefix, pw);
    }
}
#method_after
@Override
public void dump(String prefix, PrintWriter pw, String[] args) {
    pw.print(prefix);
    pw.print("mSafeMode=");
    pw.print(mSafeMode);
    pw.print(" mSystemReady=");
    pw.print(mSystemReady);
    pw.print(" mSystemBooted=");
    pw.println(mSystemBooted);
    pw.print(prefix);
    pw.print("mLidState=");
    pw.print(mLidState);
    pw.print(" mLidOpenRotation=");
    pw.print(mLidOpenRotation);
    pw.print(" mCameraLensCoverState=");
    pw.print(mCameraLensCoverState);
    pw.print(" mHdmiPlugged=");
    pw.println(mHdmiPlugged);
    if (mLastSystemUiFlags != 0 || mResettingSystemUiFlags != 0 || mForceClearedSystemUiFlags != 0) {
        pw.print(prefix);
        pw.print("mLastSystemUiFlags=0x");
        pw.print(Integer.toHexString(mLastSystemUiFlags));
        pw.print(" mResettingSystemUiFlags=0x");
        pw.print(Integer.toHexString(mResettingSystemUiFlags));
        pw.print(" mForceClearedSystemUiFlags=0x");
        pw.println(Integer.toHexString(mForceClearedSystemUiFlags));
    }
    if (mLastFocusNeedsMenu) {
        pw.print(prefix);
        pw.print("mLastFocusNeedsMenu=");
        pw.println(mLastFocusNeedsMenu);
    }
    pw.print(prefix);
    pw.print("mWakeGestureEnabledSetting=");
    pw.println(mWakeGestureEnabledSetting);
    pw.print(prefix);
    pw.print("mSupportAutoRotation=");
    pw.println(mSupportAutoRotation);
    pw.print(prefix);
    pw.print("mUiMode=");
    pw.print(mUiMode);
    pw.print(" mDockMode=");
    pw.print(mDockMode);
    pw.print(" mCarDockRotation=");
    pw.print(mCarDockRotation);
    pw.print(" mDeskDockRotation=");
    pw.println(mDeskDockRotation);
    pw.print(prefix);
    pw.print("mUserRotationMode=");
    pw.print(mUserRotationMode);
    pw.print(" mUserRotation=");
    pw.print(mUserRotation);
    pw.print(" mAllowAllRotations=");
    pw.println(mAllowAllRotations);
    pw.print(prefix);
    pw.print("mCurrentAppOrientation=");
    pw.println(mCurrentAppOrientation);
    pw.print(prefix);
    pw.print("mCarDockEnablesAccelerometer=");
    pw.print(mCarDockEnablesAccelerometer);
    pw.print(" mDeskDockEnablesAccelerometer=");
    pw.println(mDeskDockEnablesAccelerometer);
    pw.print(prefix);
    pw.print("mLidKeyboardAccessibility=");
    pw.print(mLidKeyboardAccessibility);
    pw.print(" mLidNavigationAccessibility=");
    pw.print(mLidNavigationAccessibility);
    pw.print(" mLidControlsSleep=");
    pw.println(mLidControlsSleep);
    pw.print(prefix);
    pw.print("mShortPressOnPowerBehavior=");
    pw.print(mShortPressOnPowerBehavior);
    pw.print(" mLongPressOnPowerBehavior=");
    pw.println(mLongPressOnPowerBehavior);
    pw.print(prefix);
    pw.print("mDoublePressOnPowerBehavior=");
    pw.print(mDoublePressOnPowerBehavior);
    pw.print(" mTriplePressOnPowerBehavior=");
    pw.println(mTriplePressOnPowerBehavior);
    pw.print(prefix);
    pw.print("mHasSoftInput=");
    pw.println(mHasSoftInput);
    pw.print(prefix);
    pw.print("mAwake=");
    pw.println(mAwake);
    pw.print(prefix);
    pw.print("mScreenOnEarly=");
    pw.print(mScreenOnEarly);
    pw.print(" mScreenOnFully=");
    pw.println(mScreenOnFully);
    pw.print(prefix);
    pw.print("mKeyguardDrawComplete=");
    pw.print(mKeyguardDrawComplete);
    pw.print(" mWindowManagerDrawComplete=");
    pw.println(mWindowManagerDrawComplete);
    pw.print(prefix);
    pw.print("mOrientationSensorEnabled=");
    pw.println(mOrientationSensorEnabled);
    pw.print(prefix);
    pw.print("mOverscanScreen=(");
    pw.print(mOverscanScreenLeft);
    pw.print(",");
    pw.print(mOverscanScreenTop);
    pw.print(") ");
    pw.print(mOverscanScreenWidth);
    pw.print("x");
    pw.println(mOverscanScreenHeight);
    if (mOverscanLeft != 0 || mOverscanTop != 0 || mOverscanRight != 0 || mOverscanBottom != 0) {
        pw.print(prefix);
        pw.print("mOverscan left=");
        pw.print(mOverscanLeft);
        pw.print(" top=");
        pw.print(mOverscanTop);
        pw.print(" right=");
        pw.print(mOverscanRight);
        pw.print(" bottom=");
        pw.println(mOverscanBottom);
    }
    pw.print(prefix);
    pw.print("mRestrictedOverscanScreen=(");
    pw.print(mRestrictedOverscanScreenLeft);
    pw.print(",");
    pw.print(mRestrictedOverscanScreenTop);
    pw.print(") ");
    pw.print(mRestrictedOverscanScreenWidth);
    pw.print("x");
    pw.println(mRestrictedOverscanScreenHeight);
    pw.print(prefix);
    pw.print("mUnrestrictedScreen=(");
    pw.print(mUnrestrictedScreenLeft);
    pw.print(",");
    pw.print(mUnrestrictedScreenTop);
    pw.print(") ");
    pw.print(mUnrestrictedScreenWidth);
    pw.print("x");
    pw.println(mUnrestrictedScreenHeight);
    pw.print(prefix);
    pw.print("mRestrictedScreen=(");
    pw.print(mRestrictedScreenLeft);
    pw.print(",");
    pw.print(mRestrictedScreenTop);
    pw.print(") ");
    pw.print(mRestrictedScreenWidth);
    pw.print("x");
    pw.println(mRestrictedScreenHeight);
    pw.print(prefix);
    pw.print("mStableFullscreen=(");
    pw.print(mStableFullscreenLeft);
    pw.print(",");
    pw.print(mStableFullscreenTop);
    pw.print(")-(");
    pw.print(mStableFullscreenRight);
    pw.print(",");
    pw.print(mStableFullscreenBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mStable=(");
    pw.print(mStableLeft);
    pw.print(",");
    pw.print(mStableTop);
    pw.print(")-(");
    pw.print(mStableRight);
    pw.print(",");
    pw.print(mStableBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mSystem=(");
    pw.print(mSystemLeft);
    pw.print(",");
    pw.print(mSystemTop);
    pw.print(")-(");
    pw.print(mSystemRight);
    pw.print(",");
    pw.print(mSystemBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mCur=(");
    pw.print(mCurLeft);
    pw.print(",");
    pw.print(mCurTop);
    pw.print(")-(");
    pw.print(mCurRight);
    pw.print(",");
    pw.print(mCurBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mContent=(");
    pw.print(mContentLeft);
    pw.print(",");
    pw.print(mContentTop);
    pw.print(")-(");
    pw.print(mContentRight);
    pw.print(",");
    pw.print(mContentBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mVoiceContent=(");
    pw.print(mVoiceContentLeft);
    pw.print(",");
    pw.print(mVoiceContentTop);
    pw.print(")-(");
    pw.print(mVoiceContentRight);
    pw.print(",");
    pw.print(mVoiceContentBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mDock=(");
    pw.print(mDockLeft);
    pw.print(",");
    pw.print(mDockTop);
    pw.print(")-(");
    pw.print(mDockRight);
    pw.print(",");
    pw.print(mDockBottom);
    pw.println(")");
    pw.print(prefix);
    pw.print("mDockLayer=");
    pw.print(mDockLayer);
    pw.print(" mStatusBarLayer=");
    pw.println(mStatusBarLayer);
    pw.print(prefix);
    pw.print("mShowingLockscreen=");
    pw.print(mShowingLockscreen);
    pw.print(" mShowingDream=");
    pw.print(mShowingDream);
    pw.print(" mDreamingLockscreen=");
    pw.print(mDreamingLockscreen);
    pw.print(" mDreamingSleepToken=");
    pw.println(mDreamingSleepToken);
    if (mLastInputMethodWindow != null) {
        pw.print(prefix);
        pw.print("mLastInputMethodWindow=");
        pw.println(mLastInputMethodWindow);
    }
    if (mLastInputMethodTargetWindow != null) {
        pw.print(prefix);
        pw.print("mLastInputMethodTargetWindow=");
        pw.println(mLastInputMethodTargetWindow);
    }
    if (mStatusBar != null) {
        pw.print(prefix);
        pw.print("mStatusBar=");
        pw.print(mStatusBar);
        pw.print(" isStatusBarKeyguard=");
        pw.println(isStatusBarKeyguard());
    }
    if (mNavigationBar != null) {
        pw.print(prefix);
        pw.print("mNavigationBar=");
        pw.println(mNavigationBar);
    }
    if (mFocusedWindow != null) {
        pw.print(prefix);
        pw.print("mFocusedWindow=");
        pw.println(mFocusedWindow);
    }
    if (mFocusedApp != null) {
        pw.print(prefix);
        pw.print("mFocusedApp=");
        pw.println(mFocusedApp);
    }
    if (mWinDismissingKeyguard != null) {
        pw.print(prefix);
        pw.print("mWinDismissingKeyguard=");
        pw.println(mWinDismissingKeyguard);
    }
    if (mTopFullscreenOpaqueWindowState != null) {
        pw.print(prefix);
        pw.print("mTopFullscreenOpaqueWindowState=");
        pw.println(mTopFullscreenOpaqueWindowState);
    }
    if (mTopFullscreenOpaqueOrDimmingWindowState != null) {
        pw.print(prefix);
        pw.print("mTopFullscreenOpaqueOrDimmingWindowState=");
        pw.println(mTopFullscreenOpaqueOrDimmingWindowState);
    }
    if (mForcingShowNavBar) {
        pw.print(prefix);
        pw.print("mForcingShowNavBar=");
        pw.println(mForcingShowNavBar);
        pw.print("mForcingShowNavBarLayer=");
        pw.println(mForcingShowNavBarLayer);
    }
    pw.print(prefix);
    pw.print("mTopIsFullscreen=");
    pw.print(mTopIsFullscreen);
    pw.print(" mHideLockScreen=");
    pw.println(mHideLockScreen);
    pw.print(prefix);
    pw.print("mForceStatusBar=");
    pw.print(mForceStatusBar);
    pw.print(" mForceStatusBarFromKeyguard=");
    pw.println(mForceStatusBarFromKeyguard);
    pw.print(prefix);
    pw.print("mDismissKeyguard=");
    pw.print(mDismissKeyguard);
    pw.print(" mWinDismissingKeyguard=");
    pw.print(mWinDismissingKeyguard);
    pw.print(" mHomePressed=");
    pw.println(mHomePressed);
    pw.print(prefix);
    pw.print("mAllowLockscreenWhenOn=");
    pw.print(mAllowLockscreenWhenOn);
    pw.print(" mLockScreenTimeout=");
    pw.print(mLockScreenTimeout);
    pw.print(" mLockScreenTimerActive=");
    pw.println(mLockScreenTimerActive);
    pw.print(prefix);
    pw.print("mEndcallBehavior=");
    pw.print(mEndcallBehavior);
    pw.print(" mIncallPowerBehavior=");
    pw.print(mIncallPowerBehavior);
    pw.print(" mLongPressOnHomeBehavior=");
    pw.println(mLongPressOnHomeBehavior);
    pw.print(prefix);
    pw.print("mLandscapeRotation=");
    pw.print(mLandscapeRotation);
    pw.print(" mSeascapeRotation=");
    pw.println(mSeascapeRotation);
    pw.print(prefix);
    pw.print("mPortraitRotation=");
    pw.print(mPortraitRotation);
    pw.print(" mUpsideDownRotation=");
    pw.println(mUpsideDownRotation);
    pw.print(prefix);
    pw.print("mDemoHdmiRotation=");
    pw.print(mDemoHdmiRotation);
    pw.print(" mDemoHdmiRotationLock=");
    pw.println(mDemoHdmiRotationLock);
    pw.print(prefix);
    pw.print("mUndockedHdmiRotation=");
    pw.println(mUndockedHdmiRotation);
    mGlobalKeyManager.dump(prefix, pw);
    mStatusBarController.dump(pw, prefix);
    mNavigationBarController.dump(pw, prefix);
    PolicyControl.dump(prefix, pw);
    if (mWakeGestureListener != null) {
        mWakeGestureListener.dump(pw, prefix);
    }
    if (mOrientationListener != null) {
        mOrientationListener.dump(pw, prefix);
    }
    if (mBurnInProtectionHelper != null) {
        mBurnInProtectionHelper.dump(prefix, pw);
    }
    if (mKeyguardDelegate != null) {
        mKeyguardDelegate.dump(prefix, pw);
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
private void addTunable(Tunable tunable, String key) {
    if (!mTunableLookup.containsKey(key)) {
        mTunableLookup.put(key, new ArrayList<Tunable>());
    }
    mTunableLookup.get(key).add(tunable);
    Uri uri = Settings.Secure.getUriFor(key);
    if (!mListeningUris.containsKey(uri)) {
        mListeningUris.put(uri, key);
        mContentResolver.registerContentObserver(uri, false, mObserver, mCurrentUser);
    }
    // Send the first state.
    String value = Settings.Secure.getStringForUser(mContentResolver, key, mCurrentUser);
    tunable.onTuningChanged(key, value);
}
#method_after
public void addTunable(Tunable tunable, String... keys) {
    for (String key : keys) {
        addTunable(tunable, key);
    }
}
#end_block

#method_before
private void loadShowBatterySetting() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean showInsidePercent = SlimSettings.System.getInt(resolver, SlimSettings.System.STATUS_BAR_BATTERY_PERCENT, 0) == 1;
    int batteryStyle = SlimSettings.System.getInt(resolver, SlimSettings.System.STATUS_BAR_BATTERY_STYLE, 0);
    BatteryMeterMode meterMode = BatteryMeterMode.BATTERY_METER_GONE;
    switch(batteryStyle) {
        case 0:
            meterMode = BatteryMeterMode.BATTERY_METER_ICON_PORTRAIT;
            break;
        case 2:
            meterMode = BatteryMeterMode.BATTERY_METER_CIRCLE;
            break;
        case 3:
            meterMode = BatteryMeterMode.BATTERY_METER_DOTTED_CIRCLE;
            break;
        case 4:
            meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            showInsidePercent = false;
            break;
        case 5:
            meterMode = BatteryMeterMode.BATTERY_METER_ICON_LANDSCAPE;
            break;
        case 6:
            meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            showInsidePercent = false;
            break;
        default:
            break;
    }
    setMode(meterMode);
    setShowPercent(showInsidePercent);
}
#method_after
private void loadShowBatterySetting() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean showInsidePercent = SlimSettings.Secure.getInt(resolver, SlimSettings.Secure.STATUS_BAR_BATTERY_PERCENT, 0) == 1;
    int batteryStyle = SlimSettings.Secure.getInt(resolver, SlimSettings.Secure.STATUS_BAR_BATTERY_STYLE, 0);
    BatteryMeterMode meterMode = BatteryMeterMode.BATTERY_METER_GONE;
    switch(batteryStyle) {
        case 0:
            meterMode = BatteryMeterMode.BATTERY_METER_ICON_PORTRAIT;
            break;
        case 2:
            meterMode = BatteryMeterMode.BATTERY_METER_CIRCLE;
            break;
        case 3:
            meterMode = BatteryMeterMode.BATTERY_METER_DOTTED_CIRCLE;
            break;
        case 4:
            meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            showInsidePercent = false;
            break;
        case 5:
            meterMode = BatteryMeterMode.BATTERY_METER_ICON_LANDSCAPE;
            break;
        case 6:
            meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            showInsidePercent = false;
            break;
        default:
            break;
    }
    setMode(meterMode);
    setShowPercent(showInsidePercent);
}
#end_block

#method_before
private void loadShowBatteryTextSetting() {
    mShowBatteryText = SlimSettings.System.getInt(getContext().getContentResolver(), SlimSettings.System.STATUS_BAR_BATTERY_PERCENT, 0) == 2;
    int batteryStyle = SlimSettings.System.getInt(getContext().getContentResolver(), SlimSettings.System.STATUS_BAR_BATTERY_STYLE, 0);
    switch(batteryStyle) {
        case 4:
            // meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            mShowBatteryText = false;
            mShowBatteryTextCharging = false;
            break;
        case 6:
            // meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            mShowBatteryText = true;
            mShowBatteryTextCharging = true;
            break;
        default:
            mShowBatteryTextCharging = false;
            break;
    }
}
#method_after
private void loadShowBatteryTextSetting() {
    mShowBatteryText = SlimSettings.Secure.getInt(getContext().getContentResolver(), SlimSettings.Secure.STATUS_BAR_BATTERY_PERCENT, 0) == 2;
    int batteryStyle = SlimSettings.Secure.getInt(getContext().getContentResolver(), SlimSettings.Secure.STATUS_BAR_BATTERY_STYLE, 0);
    switch(batteryStyle) {
        case 4:
            // meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            mShowBatteryText = false;
            mShowBatteryTextCharging = false;
            break;
        case 6:
            // meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            mShowBatteryText = true;
            mShowBatteryTextCharging = true;
            break;
        default:
            mShowBatteryTextCharging = false;
            break;
    }
}
#end_block

#method_before
@Override
public void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    if (mBatteryController != null) {
        mBatteryController.removeStateChangedCallback(this);
    }
}
#method_after
@Override
protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    if (mUserInfoController != null) {
        mUserInfoController.removeListener(mUserInfoChangedListener);
    }
    if (mBatteryController != null) {
        mBatteryController.removeStateChangedCallback(this);
    }
}
#end_block

#method_before
public void setUserInfoController(UserInfoController userInfoController) {
    userInfoController.addListener(new UserInfoController.OnUserInfoChangedListener() {

        @Override
        public void onUserInfoChanged(String name, Drawable picture) {
            mMultiUserAvatar.setImageDrawable(picture);
        }
    });
}
#method_after
public void setUserInfoController(UserInfoController userInfoController) {
    mUserInfoController = userInfoController;
    userInfoController.addListener(mUserInfoChangedListener);
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.STATUS_BAR_BATTERY_PERCENT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.STATUS_BAR_BATTERY_STYLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_GLOW_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CONFIG), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CAN_MOVE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.MENU_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.MENU_VISIBILITY), false, this, UserHandle.USER_ALL);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(SlimSettings.Secure.getUriFor(SlimSettings.Secure.STATUS_BAR_BATTERY_PERCENT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.Secure.getUriFor(SlimSettings.Secure.STATUS_BAR_BATTERY_STYLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_GLOW_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_SHOW), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CONFIG), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CAN_MOVE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.MENU_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(SlimSettings.System.getUriFor(SlimSettings.System.MENU_VISIBILITY), false, this, UserHandle.USER_ALL);
    update();
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    if (uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.STATUS_BAR_BATTERY_PERCENT)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.STATUS_BAR_BATTERY_STYLE))) {
        mBatteryView.updateBatteryIconSettings();
        mHeader.updateBatteryIconSettings();
        mKeyguardStatusBar.updateBatteryIconSettings();
    } else if (uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT_MODE)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CONFIG)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_GLOW_TINT)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.MENU_LOCATION)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.MENU_VISIBILITY))) {
        if (mNavigationBarView != null) {
            mNavigationBarView.recreateNavigationBar();
            prepareNavigationBarView();
        }
    } else if (uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CAN_MOVE))) {
        prepareNavigationBarView();
    }
    update();
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    if (uri.equals(SlimSettings.Secure.getUriFor(SlimSettings.Secure.STATUS_BAR_BATTERY_PERCENT)) || uri.equals(SlimSettings.Secure.getUriFor(SlimSettings.Secure.STATUS_BAR_BATTERY_STYLE))) {
        mBatteryView.updateBatteryIconSettings();
        mHeader.updateBatteryIconSettings();
        mKeyguardStatusBar.updateBatteryIconSettings();
    } else if (uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_BUTTON_TINT_MODE)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CONFIG)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_GLOW_TINT)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.MENU_LOCATION)) || uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.MENU_VISIBILITY))) {
        if (mNavigationBarView != null) {
            mNavigationBarView.recreateNavigationBar();
            prepareNavigationBarView();
        }
    } else if (uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_CAN_MOVE))) {
        prepareNavigationBarView();
    } else if (uri.equals(SlimSettings.System.getUriFor(SlimSettings.System.NAVIGATION_BAR_SHOW))) {
        updateNavigationBarVisibility();
    }
    update();
}
#end_block

#method_before
private void loadShowBatteryTextSetting() {
    ContentResolver resolver = mContext.getContentResolver();
    mShowBatteryText = SlimSettings.System.getInt(resolver, SlimSettings.System.STATUS_BAR_BATTERY_PERCENT, 0) == 2;
    int batteryStyle = SlimSettings.System.getInt(resolver, SlimSettings.System.STATUS_BAR_BATTERY_STYLE, 0);
    switch(batteryStyle) {
        case 4:
            // meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            mShowBatteryText = false;
            mShowBatteryTextCharging = false;
            break;
        case 6:
            // meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            mShowBatteryText = true;
            mShowBatteryTextCharging = true;
            break;
        default:
            mShowBatteryTextCharging = false;
            break;
    }
}
#method_after
private void loadShowBatteryTextSetting() {
    ContentResolver resolver = mContext.getContentResolver();
    mShowBatteryText = SlimSettings.Secure.getInt(resolver, SlimSettings.Secure.STATUS_BAR_BATTERY_PERCENT, 0) == 2;
    int batteryStyle = SlimSettings.Secure.getInt(resolver, SlimSettings.Secure.STATUS_BAR_BATTERY_STYLE, 0);
    switch(batteryStyle) {
        case 4:
            // meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            mShowBatteryText = false;
            mShowBatteryTextCharging = false;
            break;
        case 6:
            // meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            mShowBatteryText = true;
            mShowBatteryTextCharging = true;
            break;
        default:
            mShowBatteryTextCharging = false;
            break;
    }
}
#end_block

#method_before
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mHotspotController, mUserInfoController, mBluetoothController, mSuController);
    mIconPolicy.setCurrentUserSetup(mUserSetup);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mDozeServiceHost);
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mScreenPinningRequest.setCallback(mScreenPinningCallback);
}
#method_after
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    mStatusBarWindow = new StatusBarWindowView(mContext, null);
    mStatusBarWindow.setService(this);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    updateNavigationBarVisibility();
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mHotspotController, mUserInfoController, mBluetoothController, mSuController);
    mIconPolicy.setCurrentUserSetup(mUserSetup);
    // set up
    mSettingsObserver.onChange(false);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.HEADS_UP_NOTIFICATIONS_ENABLED), true, mHeadsUpObserver);
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP_TICKER), true, mHeadsUpObserver);
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    KeyguardUpdateMonitor.getInstance(mContext).registerCallback(mDozeServiceHost);
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mScreenPinningRequest.setCallback(mScreenPinningCallback);
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.setService(this);
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow);
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    if (mNavigationBarView == null) {
        mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
    }
    mNavigationBarView.setDisabledFlags(mDisabled1);
    mNavigationBarView.setBar(this);
    mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

        @Override
        public void onVerticalChanged(boolean isVertical) {
            if (mAssistManager != null) {
                mAssistManager.onConfigurationChanged();
            }
            mNotificationPanel.setQsScrimEnabled(!isVertical);
        }
    });
    mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            return false;
        }
    });
    mAssistManager = new AssistManager(this, context);
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    if (mContext.getResources().getBoolean(R.bool.enable_operator_name)) {
        mCarrierText = mStatusBarView.findViewById(R.id.status_carrier_text);
    }
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindow.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mKeyguardIconOverflowContainer = (NotificationOverflowContainer) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow, mStackScroller, false);
    mKeyguardIconOverflowContainer.setOnActivatedListener(this);
    mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
    mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
    SpeedBumpView speedBump = (SpeedBumpView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_speed_bump, mStackScroller, false);
    mStackScroller.setSpeedBumpView(speedBump);
    mEmptyShadeView = (EmptyShadeView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_no_notifications, mStackScroller, false);
    mStackScroller.setEmptyShadeView(mEmptyShadeView);
    mDismissView = (DismissView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_dismiss_all, mStackScroller, false);
    mDismissView.setOnButtonClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            MetricsLogger.action(mContext, MetricsLogger.ACTION_DISMISS_ALL_NOTES);
            clearAllNotifications();
        }
    });
    mStackScroller.setDismissView(mDismissView);
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindow.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    ScrimView scrimBehind = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindow.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindow.findViewById(R.id.heads_up_scrim);
    mScrimController = new ScrimController(scrimBehind, scrimInFront, headsUpScrim, mScrimSrcModeEnabled);
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mScrimController.setBackDropView(mBackdrop);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mHeader = (StatusBarHeaderView) mStatusBarWindow.findViewById(R.id.header);
    mHeader.setActivityStarter(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindow.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindow.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindow.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindow.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the inital view visibility
    setAreThereNotifications();
    mIconController = new StatusBarIconController(mContext, mStatusBarView, mKeyguardStatusBar, this);
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    mBatteryLevel = (TextView) mStatusBarView.findViewById(R.id.battery_level_text);
    // Other icons
    mLocationController = new LocationControllerImpl(mContext, // will post a notification
    mHandlerThread.getLooper());
    mBatteryController = new BatteryController(mContext);
    mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

        @Override
        public void onPowerSaveChanged() {
            mHandler.post(mCheckBarModes);
            if (mDozeServiceHost != null) {
                mDozeServiceHost.firePowerSaveChanged(mBatteryController.isPowerSave());
            }
        }

        @Override
        public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
            mBatteryIsCharging = charging;
            mBatteryChargeLevel = level;
            loadShowBatteryTextSetting();
            updateBatteryLevelText();
            mHeader.updateBatteryLevel(level, charging);
            mKeyguardStatusBar.updateBatteryLevel(level, charging);
        }
    });
    mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    mHotspotController = new HotspotControllerImpl(mContext);
    mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    mSecurityController = new SecurityControllerImpl(mContext);
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        mRotationLockController = new RotationLockControllerImpl(mContext);
    }
    mUserInfoController = new UserInfoController(mContext);
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        mZenModeController = mVolumeComponent.getZenController();
    }
    mCastController = new CastControllerImpl(mContext);
    mSuController = new SuControllerImpl(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterKeyguard = (SignalClusterView) mKeyguardStatusBar.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterQs = (SignalClusterView) mHeader.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCallback(signalCluster);
    mNetworkController.addSignalCallback(signalClusterKeyguard);
    mNetworkController.addSignalCallback(signalClusterQs);
    signalCluster.setSecurityController(mSecurityController);
    signalCluster.setNetworkController(mNetworkController);
    signalClusterKeyguard.setSecurityController(mSecurityController);
    signalClusterKeyguard.setNetworkController(mNetworkController);
    signalClusterQs.setSecurityController(mSecurityController);
    signalClusterQs.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mNetworkController.addEmergencyListener(mHeader);
    }
    mFlashlightController = new FlashlightController(mContext);
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    mAccessibilityController = new AccessibilityController(mContext);
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    mNextAlarmController = new NextAlarmController(mContext);
    mKeyguardMonitor = new KeyguardMonitor(mContext);
    if (UserSwitcherController.isUserSwitcherAvailable(UserManager.get(mContext))) {
        mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler);
    }
    mKeyguardUserSwitcher = new KeyguardUserSwitcher(mContext, (ViewStub) mStatusBarWindow.findViewById(R.id.keyguard_user_switcher), mKeyguardStatusBar, mNotificationPanel, mUserSwitcherController);
    // Set up the quick settings tile panel
    mQSPanel = (QSPanel) mStatusBarWindow.findViewById(R.id.quick_settings_panel);
    if (mQSPanel != null) {
        final QSTileHost qsh = new QSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mKeyguardMonitor, mSecurityController);
        mQSPanel.setHost(qsh);
        mQSPanel.setTiles(qsh.getTiles());
        mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindow);
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader.setQSPanel(mQSPanel);
        qsh.setCallback(new QSTileHost.Callback() {

            @Override
            public void onTilesChanged() {
                mQSPanel.setTiles(qsh.getTiles());
            }
        });
    }
    // User info. Trigger first load.
    mHeader.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    mHeader.setBatteryController(mBatteryController);
    mBatteryView = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mBatteryView.setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mHeader.setNextAlarmController(mNextAlarmController);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    mStatusBarWindowContent = (FrameLayout) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.setService(this);
    mStatusBarWindowContent.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindowContent.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindowContent.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindowContent.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindowContent.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getColor(R.color.notification_panel_solid_background)));
    }
    if (mHeadsUpManager == null) {
        mHeadsUpManager = new HeadsUpManager(context, mStatusBarWindow);
    }
    mHeadsUpManager.setBar(this);
    mHeadsUpManager.addListener(this);
    mHeadsUpManager.addListener(mNotificationPanel);
    mNotificationPanel.setHeadsUpManager(mHeadsUpManager);
    mNotificationData.setHeadsUpManager(mHeadsUpManager);
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    if (mNavigationBarView == null) {
        mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
    }
    mNavigationBarView.setDisabledFlags(mDisabled1);
    mNavigationBarView.setBar(this);
    mNavigationBarView.setOnVerticalChangedListener(new NavigationBarView.OnVerticalChangedListener() {

        @Override
        public void onVerticalChanged(boolean isVertical) {
            if (mAssistManager != null) {
                mAssistManager.onConfigurationChanged();
            }
            mNotificationPanel.setQsScrimEnabled(!isVertical);
        }
    });
    mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            return false;
        }
    });
    if (mAssistManager == null) {
        mAssistManager = new AssistManager(this, context);
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    if (mContext.getResources().getBoolean(R.bool.enable_operator_name)) {
        mCarrierText = mStatusBarView.findViewById(R.id.status_carrier_text);
    }
    mStackScroller = (NotificationStackScrollLayout) mStatusBarWindowContent.findViewById(R.id.notification_stack_scroller);
    mStackScroller.setLongPressListener(getNotificationLongClicker());
    mStackScroller.setPhoneStatusBar(this);
    mStackScroller.setGroupManager(mGroupManager);
    mStackScroller.setHeadsUpManager(mHeadsUpManager);
    mGroupManager.setOnGroupChangeListener(mStackScroller);
    mKeyguardIconOverflowContainer = (NotificationOverflowContainer) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_keyguard_overflow, mStackScroller, false);
    mKeyguardIconOverflowContainer.setOnActivatedListener(this);
    mKeyguardIconOverflowContainer.setOnClickListener(mOverflowClickListener);
    mStackScroller.setOverflowContainer(mKeyguardIconOverflowContainer);
    SpeedBumpView speedBump = (SpeedBumpView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_speed_bump, mStackScroller, false);
    mStackScroller.setSpeedBumpView(speedBump);
    mEmptyShadeView = (EmptyShadeView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_no_notifications, mStackScroller, false);
    mStackScroller.setEmptyShadeView(mEmptyShadeView);
    mDismissView = (DismissView) LayoutInflater.from(mContext).inflate(R.layout.status_bar_notification_dismiss_all, mStackScroller, false);
    mDismissView.setOnButtonClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            MetricsLogger.action(mContext, MetricsLogger.ACTION_DISMISS_ALL_NOTES);
            clearAllNotifications();
        }
    });
    mStackScroller.setDismissView(mDismissView);
    mExpandedContents = mStackScroller;
    mBackdrop = (BackDropView) mStatusBarWindowContent.findViewById(R.id.backdrop);
    mBackdropFront = (ImageView) mBackdrop.findViewById(R.id.backdrop_front);
    mBackdropBack = (ImageView) mBackdrop.findViewById(R.id.backdrop_back);
    ScrimView scrimBehind = (ScrimView) mStatusBarWindowContent.findViewById(R.id.scrim_behind);
    ScrimView scrimInFront = (ScrimView) mStatusBarWindowContent.findViewById(R.id.scrim_in_front);
    View headsUpScrim = mStatusBarWindowContent.findViewById(R.id.heads_up_scrim);
    mScrimController = new ScrimController(scrimBehind, scrimInFront, headsUpScrim, mScrimSrcModeEnabled);
    mHeadsUpManager.addListener(mScrimController);
    mStackScroller.setScrimController(mScrimController);
    mScrimController.setBackDropView(mBackdrop);
    mStatusBarView.setScrimController(mScrimController);
    mDozeScrimController = new DozeScrimController(mScrimController, context);
    mHeader = (StatusBarHeaderView) mStatusBarWindowContent.findViewById(R.id.header);
    mHeader.setActivityStarter(this);
    mKeyguardStatusBar = (KeyguardStatusBarView) mStatusBarWindowContent.findViewById(R.id.keyguard_header);
    mKeyguardStatusView = mStatusBarWindowContent.findViewById(R.id.keyguard_status_view);
    mKeyguardBottomArea = (KeyguardBottomAreaView) mStatusBarWindowContent.findViewById(R.id.keyguard_bottom_area);
    mKeyguardBottomArea.setActivityStarter(this);
    mKeyguardBottomArea.setAssistManager(mAssistManager);
    mKeyguardIndicationController = new KeyguardIndicationController(mContext, (KeyguardIndicationTextView) mStatusBarWindowContent.findViewById(R.id.keyguard_indication_text), mKeyguardBottomArea.getLockIcon());
    mKeyguardBottomArea.setKeyguardIndicationController(mKeyguardIndicationController);
    // set the inital view visibility
    setAreThereNotifications();
    mIconController = new StatusBarIconController(mContext, mStatusBarView, mKeyguardStatusBar, this);
    // Background thread for any controllers that need it.
    mHandlerThread = new HandlerThread(TAG, Process.THREAD_PRIORITY_BACKGROUND);
    mHandlerThread.start();
    mBatteryLevel = (TextView) mStatusBarView.findViewById(R.id.battery_level_text);
    // Other icons
    if (mLocationController == null) {
        mLocationController = new LocationControllerImpl(mContext, // will post a notification
        mHandlerThread.getLooper());
    }
    if (mBatteryController == null) {
        mBatteryController = new BatteryController(mContext);
        mBatteryController.addStateChangedCallback(new BatteryStateChangeCallback() {

            @Override
            public void onPowerSaveChanged() {
                mHandler.post(mCheckBarModes);
                if (mDozeServiceHost != null) {
                    mDozeServiceHost.firePowerSaveChanged(mBatteryController.isPowerSave());
                }
            }

            @Override
            public void onBatteryLevelChanged(int level, boolean pluggedIn, boolean charging) {
                mBatteryIsCharging = charging;
                mBatteryChargeLevel = level;
                loadShowBatteryTextSetting();
                updateBatteryLevelText();
                mHeader.updateBatteryLevel(level, charging);
                mKeyguardStatusBar.updateBatteryLevel(level, charging);
            }
        });
    }
    if (mNetworkController == null) {
        mNetworkController = new NetworkControllerImpl(mContext, mHandlerThread.getLooper());
    }
    if (mHotspotController == null) {
        mHotspotController = new HotspotControllerImpl(mContext);
    }
    if (mBluetoothController == null) {
        mBluetoothController = new BluetoothControllerImpl(mContext, mHandlerThread.getLooper());
    }
    if (mSecurityController == null) {
        mSecurityController = new SecurityControllerImpl(mContext);
    }
    if (mContext.getResources().getBoolean(R.bool.config_showRotationLock)) {
        if (mRotationLockController == null) {
            mRotationLockController = new RotationLockControllerImpl(mContext);
        }
    }
    if (mUserInfoController == null) {
        mUserInfoController = new UserInfoController(mContext);
    }
    mVolumeComponent = getComponent(VolumeComponent.class);
    if (mVolumeComponent != null) {
        if (mZenModeController == null) {
            mZenModeController = mVolumeComponent.getZenController();
        }
    }
    if (mCastController == null) {
        mCastController = new CastControllerImpl(mContext);
    }
    mSuController = new SuControllerImpl(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterKeyguard = (SignalClusterView) mKeyguardStatusBar.findViewById(R.id.signal_cluster);
    final SignalClusterView signalClusterQs = (SignalClusterView) mHeader.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCallback(signalCluster);
    mNetworkController.addSignalCallback(signalClusterKeyguard);
    mNetworkController.addSignalCallback(signalClusterQs);
    signalCluster.setSecurityController(mSecurityController);
    signalCluster.setNetworkController(mNetworkController);
    signalClusterKeyguard.setSecurityController(mSecurityController);
    signalClusterKeyguard.setNetworkController(mNetworkController);
    signalClusterQs.setSecurityController(mSecurityController);
    signalClusterQs.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mNetworkController.addEmergencyListener(mHeader);
    }
    if (mFlashlightController == null) {
        mFlashlightController = new FlashlightController(mContext);
    }
    mKeyguardBottomArea.setFlashlightController(mFlashlightController);
    mKeyguardBottomArea.setPhoneStatusBar(this);
    mKeyguardBottomArea.setUserSetupComplete(mUserSetup);
    if (mAccessibilityController == null) {
        mAccessibilityController = new AccessibilityController(mContext);
    }
    mKeyguardBottomArea.setAccessibilityController(mAccessibilityController);
    if (mNextAlarmController == null) {
        mNextAlarmController = new NextAlarmController(mContext);
    }
    if (mKeyguardMonitor == null) {
        mKeyguardMonitor = new KeyguardMonitor(mContext);
    }
    if (UserSwitcherController.isUserSwitcherAvailable(UserManager.get(mContext))) {
        if (mUserSwitcherController == null) {
            mUserSwitcherController = new UserSwitcherController(mContext, mKeyguardMonitor, mHandler);
        }
    }
    mKeyguardUserSwitcher = new KeyguardUserSwitcher(mContext, (ViewStub) mStatusBarWindowContent.findViewById(R.id.keyguard_user_switcher), mKeyguardStatusBar, mNotificationPanel, mUserSwitcherController);
    // Set up the quick settings tile panel
    mQSPanel = (QSPanel) mStatusBarWindowContent.findViewById(R.id.quick_settings_panel);
    if (mQSPanel != null) {
        if (mQSTileHost == null) {
            mQSTileHost = new QSTileHost(mContext, this, mBluetoothController, mLocationController, mRotationLockController, mNetworkController, mZenModeController, mHotspotController, mCastController, mFlashlightController, mUserSwitcherController, mKeyguardMonitor, mSecurityController);
        }
        mQSPanel.setHost(mQSTileHost);
        mQSPanel.setTiles(mQSTileHost.getTiles());
        if (mBrightnessMirrorController == null) {
            mBrightnessMirrorController = new BrightnessMirrorController(mStatusBarWindowContent);
        }
        mQSPanel.setBrightnessMirror(mBrightnessMirrorController);
        mHeader.setQSPanel(mQSPanel);
        mQSTileHost.setCallback(new QSTileHost.Callback() {

            @Override
            public void onTilesChanged() {
                mQSPanel.setTiles(mQSTileHost.getTiles());
            }
        });
    }
    // User info. Trigger first load.
    mHeader.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserInfoController(mUserInfoController);
    mKeyguardStatusBar.setUserSwitcherController(mUserSwitcherController);
    mUserInfoController.reloadUserInfo();
    mHeader.setBatteryController(mBatteryController);
    mBatteryView = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mBatteryView.setBatteryController(mBatteryController);
    mKeyguardStatusBar.setBatteryController(mBatteryController);
    mHeader.setNextAlarmController(mNextAlarmController);
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    mGestureWakeLock = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "GestureWakeLock");
    mVibrator = mContext.getSystemService(Vibrator.class);
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    context.registerReceiverAsUser(mBroadcastReceiver, UserHandle.ALL, filter, null, null);
    IntentFilter demoFilter = new IntentFilter();
    if (DEBUG_MEDIA_FAKE_ARTWORK) {
        demoFilter.addAction(ACTION_FAKE_ARTWORK);
    }
    demoFilter.addAction(ACTION_DEMO);
    context.registerReceiverAsUser(mDemoReceiver, UserHandle.ALL, demoFilter, android.Manifest.permission.DUMP, null);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    // disable profiling bars, since they overlap and clutter the output on app windows
    ThreadedRenderer.overrideProperty("disableProfileBars", "true");
    // Private API call to make the shadows look better for Recents
    ThreadedRenderer.overrideProperty("ambientRatio", String.valueOf(1.5f));
    return mStatusBarView;
}
#end_block

#method_before
private void addNavigationBar() {
    if (DEBUG)
        Log.v(TAG, "addNavigationBar: about to add " + mNavigationBarView);
    if (mNavigationBarView == null)
        return;
    prepareNavigationBarView();
    mWindowManager.addView(mNavigationBarView, getNavigationBarLayoutParams());
}
#method_after
private void addNavigationBar() {
    if (DEBUG)
        Log.v(TAG, "addNavigationBar: about to add " + mNavigationBarView);
    if (mNavigationBarView == null)
        return;
    prepareNavigationBarView();
    if (!mNavigationBarAttached) {
        mNavigationBarAttached = true;
        mWindowManager.addView(mNavigationBarView, getNavigationBarLayoutParams());
    }
}
#end_block

#method_before
@Override
protected void refreshLayout(int layoutDirection) {
    if (mNavigationBarView != null) {
        mNavigationBarView.setLayoutDirection(layoutDirection);
    }
}
#method_after
@Override
protected void refreshLayout(int layoutDirection) {
    if (mNavigationBarView != null) {
        mNavigationBarView.setLayoutDirection(layoutDirection);
    }
    mIconController.refreshAllStatusBarIcons();
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
void makeExpandedVisible(boolean force) {
    if (SPEW)
        Log.d(TAG, "Make expanded visible: expanded visible=" + mExpandedVisible);
    if (!force && (mExpandedVisible || !panelsEnabled())) {
        return;
    }
    mExpandedVisible = true;
    if (mNavigationBarView != null)
        mNavigationBarView.setSlippery(true);
    // Expand the window to encompass the full screen in anticipation of the drag.
    // This is only possible to do atomically because the status bar is at the top of the screen!
    mStatusBarWindowManager.setPanelVisible(true);
    visibilityChanged(true);
    mWaitingForKeyguardExit = false;
    disable(mDisabledUnmodified1, mDisabledUnmodified2, !force);
    setInteracting(StatusBarManager.WINDOW_STATUS_BAR, true);
}
#method_after
void makeExpandedVisible(boolean force) {
    if (SPEW)
        Log.d(TAG, "Make expanded visible: expanded visible=" + mExpandedVisible);
    if (!force && (mExpandedVisible || !panelsEnabled())) {
        return;
    }
    mExpandedVisible = true;
    if (mNavigationBarView != null && mNavigationBarAttached)
        mNavigationBarView.setSlippery(true);
    // Expand the window to encompass the full screen in anticipation of the drag.
    // This is only possible to do atomically because the status bar is at the top of the screen!
    mStatusBarWindowManager.setPanelVisible(true);
    visibilityChanged(true);
    mWaitingForKeyguardExit = false;
    disable(mDisabledUnmodified1, mDisabledUnmodified2, !force);
    setInteracting(StatusBarManager.WINDOW_STATUS_BAR, true);
}
#end_block

#method_before
private void addStatusBarWindow() {
    makeStatusBarView();
    mStatusBarWindowManager = new StatusBarWindowManager(mContext);
    mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight());
}
#method_after
private void addStatusBarWindow() {
    makeStatusBarView();
    mStatusBarWindow.addContent(mStatusBarWindowContent);
    mStatusBarWindowManager = new StatusBarWindowManager(mContext);
    mStatusBarWindowManager.add(mStatusBarWindow, getStatusBarHeight());
}
#end_block

#method_before
@Override
protected void onConfigurationChanged(Configuration newConfig) {
    // calls refreshLayout
    super.onConfigurationChanged(newConfig);
    if (DEBUG) {
        Log.v(TAG, "configuration changed: " + mContext.getResources().getConfiguration());
    }
    // populates mDisplayMetrics
    updateDisplaySize();
    updateResources();
    repositionNavigationBar();
    updateRowStates();
    mIconController.updateResources();
    mScreenPinningRequest.onConfigurationChanged();
    mNetworkController.onConfigurationChanged();
    FontSizeUtils.updateFontSize(mBatteryLevel, R.dimen.battery_level_text_size);
}
#method_after
@Override
protected void onConfigurationChanged(Configuration newConfig) {
    // calls refreshLayout
    super.onConfigurationChanged(newConfig);
    if (DEBUG) {
        Log.v(TAG, "configuration changed: " + mContext.getResources().getConfiguration());
    }
    // populates mDisplayMetrics
    updateDisplaySize();
    mIconController.updateResources();
    mScreenPinningRequest.onConfigurationChanged();
    mNetworkController.onConfigurationChanged();
    FontSizeUtils.updateFontSize(mBatteryLevel, R.dimen.battery_level_text_size);
    if (mUiMode != newConfig.uiMode) {
        mUiMode = newConfig.uiMode;
        recreateStatusBar(true);
        if (mNavigationBarView != null) {
            mNavigationBarView.updateResources();
        }
    }
    updateResources();
    repositionNavigationBar();
    updateRowStates();
}
#end_block

#method_before
void updateResources() {
    // Update the quick setting tiles
    if (mQSPanel != null) {
        mQSPanel.updateResources();
    }
    loadDimens();
    if (mNotificationPanel != null) {
        mNotificationPanel.updateResources();
    }
    if (mBrightnessMirrorController != null) {
        mBrightnessMirrorController.updateResources();
    }
}
#method_after
void updateResources() {
    // Update the quick setting tiles
    if (mQSPanel != null) {
        mQSPanel.updateResources();
    }
    loadDimens();
    if (mNotificationPanel != null) {
        mNotificationPanel.updateResources();
    }
    if (mBrightnessMirrorController != null) {
        mBrightnessMirrorController.updateResources();
    }
    if (mNavigationBarView != null) {
        mNavigationBarView.updateResources();
    }
}
#end_block

#method_before
private void showBouncer() {
    if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
        mWaitingForKeyguardExit = mStatusBarKeyguardViewManager.isShowing();
        mStatusBarKeyguardViewManager.dismiss();
    }
}
#method_after
private void showBouncer() {
    if (!mRecreating && (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED)) {
        mWaitingForKeyguardExit = mStatusBarKeyguardViewManager.isShowing();
        mStatusBarKeyguardViewManager.dismiss();
    }
}
#end_block

#method_before
private void loadShowBatteryTextSetting() {
    int batteryText = SlimSettings.System.getInt(getContext().getContentResolver(), SlimSettings.System.STATUS_BAR_BATTERY_PERCENT, 0);
    int batteryStyle = SlimSettings.System.getInt(getContext().getContentResolver(), SlimSettings.System.STATUS_BAR_BATTERY_STYLE, 0);
    switch(batteryStyle) {
        case 4:
            // meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            mShowBatteryText = false;
            mShowBatteryTextExpanded = true;
            mShowBatteryTextCharging = true;
            break;
        case 6:
            // meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            mShowBatteryText = true;
            mShowBatteryTextExpanded = true;
            mShowBatteryTextCharging = true;
            break;
        default:
            mShowBatteryText = (batteryText == 2);
            // Only show when percent is not already shown inside icon
            mShowBatteryTextExpanded = (batteryText != 1);
            mShowBatteryTextCharging = false;
            break;
    }
}
#method_after
private void loadShowBatteryTextSetting() {
    int batteryText = SlimSettings.Secure.getInt(getContext().getContentResolver(), SlimSettings.Secure.STATUS_BAR_BATTERY_PERCENT, 0);
    int batteryStyle = SlimSettings.Secure.getInt(getContext().getContentResolver(), SlimSettings.Secure.STATUS_BAR_BATTERY_STYLE, 0);
    switch(batteryStyle) {
        case 4:
            // meterMode = BatteryMeterMode.BATTERY_METER_GONE;
            mShowBatteryText = false;
            mShowBatteryTextExpanded = true;
            mShowBatteryTextCharging = true;
            break;
        case 6:
            // meterMode = BatteryMeterMode.BATTERY_METER_TEXT;
            mShowBatteryText = true;
            mShowBatteryTextExpanded = true;
            mShowBatteryTextCharging = true;
            break;
        default:
            mShowBatteryText = (batteryText == 2);
            // Only show when percent is not already shown inside icon
            mShowBatteryTextExpanded = (batteryText != 1);
            mShowBatteryTextCharging = false;
            break;
    }
}
#end_block

#method_before
@Override
public void onDetachedFromWindow() {
    super.onDetachedFromWindow();
}
#method_after
@Override
protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    if (mUserInfoController != null) {
        mUserInfoController.removeListener(mUserInfoChangedListener);
    }
    setListening(false);
}
#end_block

#method_before
private void updateVisibilities() {
    mDateCollapsed.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mDateExpanded.setVisibility(mExpanded && mAlarmShowing ? View.INVISIBLE : View.VISIBLE);
    mAlarmStatus.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mSettingsContainer.setVisibility(mExpanded ? View.VISIBLE : View.INVISIBLE);
    mQsDetailHeader.setVisibility(mExpanded && mShowingDetail ? View.VISIBLE : View.INVISIBLE);
    if (mSignalCluster != null) {
        updateSignalClusterDetachment();
    }
    mEmergencyCallsOnly.setVisibility(mExpanded && mShowEmergencyCallsOnly ? VISIBLE : GONE);
    loadShowBatteryTextSetting();
    updateBatteryLevelText();
    mBatteryLevel.setVisibility(mExpanded ? (mShowBatteryTextExpanded ? View.VISIBLE : View.GONE) : (mShowBatteryText ? View.VISIBLE : View.GONE));
    mSettingsContainer.findViewById(R.id.tuner_icon).setVisibility(TunerService.isTunerEnabled(mContext) ? View.VISIBLE : View.INVISIBLE);
}
#method_after
private void updateVisibilities() {
    mDateCollapsed.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mDateExpanded.setVisibility(mExpanded && mAlarmShowing ? View.INVISIBLE : View.VISIBLE);
    mAlarmStatus.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mSettingsContainer.setVisibility(mExpanded ? View.VISIBLE : View.INVISIBLE);
    mQsDetailHeader.setVisibility(mExpanded && mShowingDetail ? View.VISIBLE : View.INVISIBLE);
    if (mSignalCluster != null) {
        updateSignalClusterDetachment();
    }
    mEmergencyCallsOnly.setVisibility(mExpanded && mShowEmergencyCallsOnly ? VISIBLE : GONE);
    loadShowBatteryTextSetting();
    updateBatteryLevelText();
    mBatteryLevel.setVisibility(mExpanded ? (mShowBatteryTextExpanded ? View.VISIBLE : View.GONE) : (mShowBatteryText ? View.VISIBLE : View.GONE));
    View tunerIcon = mSettingsContainer.findViewById(R.id.tuner_icon);
    if (tunerIcon != null) {
        tunerIcon.setVisibility(TunerService.isTunerEnabled(mContext) ? View.VISIBLE : View.INVISIBLE);
    }
}
#end_block

#method_before
public void setUserInfoController(UserInfoController userInfoController) {
    userInfoController.addListener(new UserInfoController.OnUserInfoChangedListener() {

        @Override
        public void onUserInfoChanged(String name, Drawable picture) {
            mMultiUserAvatar.setImageDrawable(picture);
        }
    });
}
#method_after
public void setUserInfoController(UserInfoController userInfoController) {
    mUserInfoController = userInfoController;
    userInfoController.addListener(mUserInfoChangedListener);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
    }
}
#end_block

#method_before
@Override
protected void onConfigurationChanged(Configuration newConfig) {
    // calls refreshLayout
    super.onConfigurationChanged(newConfig);
    if (DEBUG) {
        Log.v(TAG, "configuration changed: " + mContext.getResources().getConfiguration());
    }
    // populates mDisplayMetrics
    updateDisplaySize();
    mIconController.updateResources();
    mScreenPinningRequest.onConfigurationChanged();
    mNetworkController.onConfigurationChanged();
    if (mAssetSeq != newConfig.assetSeq) {
        mAssetSeq = newConfig.assetSeq;
        recreateStatusBar();
        mNavigationBarView.updateResources();
    }
    updateResources();
    repositionNavigationBar();
    updateRowStates();
}
#method_after
@Override
protected void onConfigurationChanged(Configuration newConfig) {
    // calls refreshLayout
    super.onConfigurationChanged(newConfig);
    if (DEBUG) {
        Log.v(TAG, "configuration changed: " + mContext.getResources().getConfiguration());
    }
    // populates mDisplayMetrics
    updateDisplaySize();
    mIconController.updateResources();
    mScreenPinningRequest.onConfigurationChanged();
    mNetworkController.onConfigurationChanged();
    if (mUiMode != newConfig.uiMode) {
        mUiMode = newConfig.uiMode;
        recreateStatusBar();
        if (mNavigationBarView != null) {
            mNavigationBarView.updateResources();
        }
    }
    updateResources();
    repositionNavigationBar();
    updateRowStates();
}
#end_block

#method_before
private void updateVisibilities() {
    mDateCollapsed.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mDateExpanded.setVisibility(mExpanded && mAlarmShowing ? View.INVISIBLE : View.VISIBLE);
    mAlarmStatus.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mSettingsContainer.setVisibility(mExpanded ? View.VISIBLE : View.INVISIBLE);
    mQsDetailHeader.setVisibility(mExpanded && mShowingDetail ? View.VISIBLE : View.INVISIBLE);
    if (mSignalCluster != null) {
        updateSignalClusterDetachment();
    }
    mEmergencyCallsOnly.setVisibility(mExpanded && mShowEmergencyCallsOnly ? VISIBLE : GONE);
    mBatteryLevel.setVisibility(mExpanded ? View.VISIBLE : View.GONE);
    mSettingsContainer.findViewById(R.id.tuner_icon).setVisibility(TunerService.isTunerEnabled(mContext) ? View.VISIBLE : View.INVISIBLE);
}
#method_after
private void updateVisibilities() {
    mDateCollapsed.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mDateExpanded.setVisibility(mExpanded && mAlarmShowing ? View.INVISIBLE : View.VISIBLE);
    mAlarmStatus.setVisibility(mExpanded && mAlarmShowing ? View.VISIBLE : View.INVISIBLE);
    mSettingsContainer.setVisibility(mExpanded ? View.VISIBLE : View.INVISIBLE);
    mQsDetailHeader.setVisibility(mExpanded && mShowingDetail ? View.VISIBLE : View.INVISIBLE);
    if (mSignalCluster != null) {
        updateSignalClusterDetachment();
    }
    mEmergencyCallsOnly.setVisibility(mExpanded && mShowEmergencyCallsOnly ? VISIBLE : GONE);
    mBatteryLevel.setVisibility(mExpanded ? View.VISIBLE : View.GONE);
    View tunerIcon = mSettingsContainer.findViewById(R.id.tuner_icon);
    if (tunerIcon != null) {
        tunerIcon.setVisibility(TunerService.isTunerEnabled(mContext) ? View.VISIBLE : View.INVISIBLE);
    }
}
#end_block

#method_before
private static int getAdvancedReboot(Context context) {
    int def = BuildInfo.getSlimBuildType().equals(BuildInfo.BUILD_TYPE_UNOFFICIAL) ? 1 : 0;
    return SlimSettings.Secure.getInt(context.getContentResolver(), SlimSettings.Secure.ADVANCED_REBOOT, def);
}
#method_after
private static int getAdvancedReboot(Context context) {
    return SlimSettings.Secure.getInt(context.getContentResolver(), SlimSettings.Secure.ADVANCED_REBOOT, 0);
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_SHOW_BATTERY_PERCENT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BATTERY_STYLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SU_INDICATOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_GLOW_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CONFIG), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CAN_MOVE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.MENU_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.MENU_VISIBILITY), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HEADS_UP_NOTIFCATION_DECAY), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HEADS_UP_SNOOZE_TIME), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HEADS_UP_GLOBAL_SWITCH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.PIE_CONTROLS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USE_SLIM_RECENTS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.RECENT_CARD_BG_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.RECENT_CARD_TEXT_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_SHOW_BATTERY_PERCENT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BATTERY_STYLE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SU_INDICATOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_GLOW_TINT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CONFIG), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CAN_MOVE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.MENU_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.MENU_VISIBILITY), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HEADS_UP_NOTIFCATION_DECAY), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HEADS_UP_SNOOZE_TIME), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HEADS_UP_GLOBAL_SWITCH), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.PIE_CONTROLS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USE_SLIM_RECENTS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.RECENT_CARD_BG_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.RECENT_CARD_TEXT_COLOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_IME_ARROWS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_ALPHA), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_ANIMATE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_ANIMATE_DURATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_TOUCH_ANYWHERE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    update();
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange, Uri uri) {
    super.onChange(selfChange, uri);
    if (uri.equals(Settings.System.getUriFor(Settings.System.STATUS_BAR_SHOW_BATTERY_PERCENT)) || uri.equals(Settings.System.getUriFor(Settings.System.STATUS_BAR_BATTERY_STYLE))) {
        mBatteryView.updateBatteryIconSettings();
        mHeader.updateBatteryIconSettings();
        mKeyguardStatusBar.updateBatteryIconSettings();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.SU_INDICATOR))) {
        mSuController.updateNotification();
        mSuController.fireCallbacks();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.HEADS_UP_SNOOZE_TIME))) {
        final int snoozeTime = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADS_UP_SNOOZE_TIME, mContext.getResources().getInteger(R.integer.heads_up_snooze_time), UserHandle.USER_CURRENT);
        setHeadsUpSnoozeTime(snoozeTime);
        if (mHeadsUpNotificationView != null) {
            mHeadsUpNotificationView.setSnoozeVisibility(snoozeTime != 0);
        }
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.HEADS_UP_NOTIFCATION_DECAY))) {
        mHeadsUpNotificationDecay = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADS_UP_NOTIFCATION_DECAY, mContext.getResources().getInteger(R.integer.heads_up_notification_decay), UserHandle.USER_CURRENT);
        resetHeadsUpDecayTimer();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.HEADS_UP_GLOBAL_SWITCH))) {
        final int headsUpGlobalSwitch = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADS_UP_GLOBAL_SWITCH, 1, UserHandle.USER_CURRENT);
        setHeadsUpGlobalSwitch(headsUpGlobalSwitch);
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.PIE_CONTROLS))) {
        attachPieContainer(isPieEnabled());
    }
    update();
    if (uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT)) || uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE)) || uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CONFIG)) || uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_GLOW_TINT)) || uri.equals(Settings.System.getUriFor(Settings.System.MENU_LOCATION)) || uri.equals(Settings.System.getUriFor(Settings.System.MENU_VISIBILITY))) {
        if (mNavigationBarView != null) {
            mNavigationBarView.recreateNavigationBar();
            prepareNavigationBarView();
        }
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CAN_MOVE))) {
        prepareNavigationBarView();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.USE_SLIM_RECENTS))) {
        updateRecents();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.RECENT_CARD_BG_COLOR)) || uri.equals(Settings.System.getUriFor(Settings.System.RECENT_CARD_TEXT_COLOR))) {
        rebuildRecentsScreen();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.LOCKSCREEN_ROTATION)) || uri.equals(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION))) {
        mStatusBarWindowManager.updateKeyguardScreenRotation();
    }
}
#method_after
@Override
public void onChange(boolean selfChange, Uri uri) {
    super.onChange(selfChange, uri);
    if (uri.equals(Settings.System.getUriFor(Settings.System.STATUS_BAR_SHOW_BATTERY_PERCENT)) || uri.equals(Settings.System.getUriFor(Settings.System.STATUS_BAR_BATTERY_STYLE))) {
        mBatteryView.updateBatteryIconSettings();
        mHeader.updateBatteryIconSettings();
        mKeyguardStatusBar.updateBatteryIconSettings();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.SU_INDICATOR))) {
        mSuController.updateNotification();
        mSuController.fireCallbacks();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.HEADS_UP_SNOOZE_TIME))) {
        final int snoozeTime = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADS_UP_SNOOZE_TIME, mContext.getResources().getInteger(R.integer.heads_up_snooze_time), UserHandle.USER_CURRENT);
        setHeadsUpSnoozeTime(snoozeTime);
        if (mHeadsUpNotificationView != null) {
            mHeadsUpNotificationView.setSnoozeVisibility(snoozeTime != 0);
        }
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.HEADS_UP_NOTIFCATION_DECAY))) {
        mHeadsUpNotificationDecay = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADS_UP_NOTIFCATION_DECAY, mContext.getResources().getInteger(R.integer.heads_up_notification_decay), UserHandle.USER_CURRENT);
        resetHeadsUpDecayTimer();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.HEADS_UP_GLOBAL_SWITCH))) {
        final int headsUpGlobalSwitch = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.HEADS_UP_GLOBAL_SWITCH, 1, UserHandle.USER_CURRENT);
        setHeadsUpGlobalSwitch(headsUpGlobalSwitch);
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.PIE_CONTROLS))) {
        attachPieContainer(isPieEnabled());
    }
    update();
    if (uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT)) || uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_BUTTON_TINT_MODE)) || uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CONFIG)) || uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_GLOW_TINT)) || uri.equals(Settings.System.getUriFor(Settings.System.MENU_LOCATION)) || uri.equals(Settings.System.getUriFor(Settings.System.MENU_VISIBILITY))) {
        if (mNavigationBarView != null) {
            mNavigationBarView.recreateNavigationBar();
            prepareNavigationBarView();
        }
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.NAVIGATION_BAR_CAN_MOVE))) {
        prepareNavigationBarView();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.USE_SLIM_RECENTS))) {
        updateRecents();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.RECENT_CARD_BG_COLOR)) || uri.equals(Settings.System.getUriFor(Settings.System.RECENT_CARD_TEXT_COLOR))) {
        rebuildRecentsScreen();
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.STATUS_BAR_IME_ARROWS))) {
        if (mNavigationBarView != null) {
            mNavigationBarView.updateNavigationBarSettings();
        }
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS)) || uri.equals(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_TIMEOUT)) || uri.equals(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_ALPHA)) || uri.equals(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_ANIMATE)) || uri.equals(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_ANIMATE_DURATION)) || uri.equals(Settings.System.getUriFor(Settings.System.DIM_NAV_BUTTONS_TOUCH_ANYWHERE)) || uri.equals(Settings.System.getUriFor(Settings.Global.POLICY_CONTROL))) {
        if (mNavigationBarView != null) {
            mNavigationBarView.updateNavigationBarSettings();
            mNavigationBarView.onNavButtonTouched();
        }
    } else if (uri.equals(Settings.System.getUriFor(Settings.System.LOCKSCREEN_ROTATION)) || uri.equals(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION))) {
        mStatusBarWindowManager.updateKeyguardScreenRotation();
    }
}
#end_block

#method_before
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mSuController);
    // set up
    mSettingsObserver.onChange(false);
    // when StatusBarManager notifies us that the state has changed.
    if (!mDisableNotificationAlerts) {
        addHeadsUpView();
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mScreenPinningRequest.setCallback(mScreenPinningCallback);
}
#method_after
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    mScrimSrcModeEnabled = mContext.getResources().getBoolean(R.bool.config_status_bar_scrim_behind_use_src);
    // calls createAndAddWindows()
    super.start();
    mMediaSessionManager = (MediaSessionManager) mContext.getSystemService(Context.MEDIA_SESSION_SERVICE);
    // TODO: use MediaSessionManager.SessionListener to hook us up to future updates
    // in session state
    addNavigationBar();
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext, mCastController, mSuController);
    // set up
    mSettingsObserver.onChange(false);
    // when StatusBarManager notifies us that the state has changed.
    if (!mDisableNotificationAlerts) {
        addHeadsUpView();
    }
    mUnlockMethodCache = UnlockMethodCache.getInstance(mContext);
    mUnlockMethodCache.addListener(this);
    startKeyguard();
    mDozeServiceHost = new DozeServiceHost();
    putComponent(DozeHost.class, mDozeServiceHost);
    putComponent(PhoneStatusBar.class, this);
    setControllerUsers();
    notifyUserAboutHiddenNotifications();
    mScreenPinningRequest = new ScreenPinningRequest(mContext);
    mScreenPinningRequest.setCallback(mScreenPinningCallback);
}
#end_block

#method_before
private void performDismissAllAnimations(ArrayList<View> hideAnimatedList) {
    Runnable animationFinishAction = new Runnable() {

        @Override
        public void run() {
            mStackScroller.post(new Runnable() {

                @Override
                public void run() {
                    mStackScroller.setDismissAllInProgress(false);
                }
            });
            animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_NONE);
        }
    };
    // let's disable our normal animations
    mStackScroller.setDismissAllInProgress(true);
    // Decrease the delay for every row we animate to give the sense of
    // accelerating the swipes
    int rowDelayDecrement = 10;
    int currentDelay = 140;
    int totalDelay = 0;
    int numItems = hideAnimatedList.size();
    for (int i = 0; i < numItems; i++) {
        View view = hideAnimatedList.get(i);
        Runnable endRunnable = null;
        if (i == numItems - 1) {
            endRunnable = animationFinishAction;
        }
        mStackScroller.dismissViewAnimated(view, endRunnable, totalDelay, 260);
        currentDelay = Math.max(50, currentDelay - rowDelayDecrement);
        totalDelay += currentDelay;
    }
}
#method_after
private void performDismissAllAnimations(ArrayList<View> hideAnimatedList) {
    Runnable animationFinishAction = new Runnable() {

        @Override
        public void run() {
            mStackScroller.post(new Runnable() {

                @Override
                public void run() {
                    mStackScroller.setDismissAllInProgress(false);
                }
            });
            animateCollapsePanels(CommandQueue.FLAG_EXCLUDE_NONE);
        }
    };
    // let's disable our normal animations
    mStackScroller.setDismissAllInProgress(true);
    // Decrease the delay for every row we animate to give the sense of
    // accelerating the swipes
    int rowDelayDecrement = 10;
    int currentDelay = 140;
    int totalDelay = 180;
    int numItems = hideAnimatedList.size();
    for (int i = numItems - 1; i >= 0; i--) {
        View view = hideAnimatedList.get(i);
        Runnable endRunnable = null;
        if (i == 0) {
            endRunnable = animationFinishAction;
        }
        mStackScroller.dismissViewAnimated(view, endRunnable, totalDelay, 260);
        currentDelay = Math.max(50, currentDelay - rowDelayDecrement);
        totalDelay += currentDelay;
    }
}
#end_block

#method_before
@Override
public void addNotification(StatusBarNotification notification, RankingMap ranking) {
    if (DEBUG)
        Log.d(TAG, "addNotification key=" + notification.getKey());
    if (!mDisableNotificationAlerts && shouldInterrupt(notification)) {
        if (DEBUG)
            Log.d(TAG, "launching notification in heads up mode");
        Entry interruptionCandidate = new Entry(notification, null);
        ViewGroup holder = mHeadsUpNotificationView.getHolder();
        if (inflateViewsForHeadsUp(interruptionCandidate, holder)) {
            // 1. Populate mHeadsUpNotificationView
            mHeadsUpNotificationView.showNotification(interruptionCandidate);
            // do not show the notification in the shade, yet.
            return;
        }
    }
    Entry shadeEntry = createNotificationViews(notification);
    if (shadeEntry == null) {
        return;
    }
    if (notification.getNotification().fullScreenIntent != null) {
        // Stop screensaver if the notification has a full-screen intent.
        // (like an incoming phone call)
        awakenDreams();
        // not immersive & a full-screen alert should be shown
        if (DEBUG)
            Log.d(TAG, "Notification has fullScreenIntent; sending fullScreenIntent");
        try {
            notification.getNotification().fullScreenIntent.send();
        } catch (PendingIntent.CanceledException e) {
        }
    } else {
        // show the ticker if there isn't already a heads up
        if (mHeadsUpNotificationView.getEntry() == null) {
            tick(notification, true);
        }
    }
    addNotificationViews(shadeEntry, ranking);
    // Recalculate the position of the sliding windows and the titles.
    setAreThereNotifications();
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
}
#method_after
@Override
public void addNotification(StatusBarNotification notification, RankingMap ranking) {
    if (DEBUG)
        Log.d(TAG, "addNotification key=" + notification.getKey());
    if (!mDisableNotificationAlerts && shouldInterrupt(notification)) {
        if (DEBUG)
            Log.d(TAG, "launching notification in heads up mode");
        Entry interruptionCandidate = new Entry(notification, null);
        ViewGroup holder = mHeadsUpNotificationView.getHolder();
        if (inflateViewsForHeadsUp(interruptionCandidate, holder)) {
            // 1. Populate mHeadsUpNotificationView
            mHeadsUpNotificationView.showNotification(interruptionCandidate);
            // do not show the notification in the shade, yet.
            return;
        }
    }
    Entry shadeEntry = createNotificationViews(notification);
    if (shadeEntry == null) {
        return;
    }
    if (notification.getNotification().fullScreenIntent != null) {
        // Stop screensaver if the notification has a full-screen intent.
        // (like an incoming phone call)
        awakenDreams();
        // not immersive & a full-screen alert should be shown
        if (DEBUG)
            Log.d(TAG, "Notification has fullScreenIntent; sending fullScreenIntent");
        try {
            EventLog.writeEvent(EventLogTags.SYSUI_FULLSCREEN_NOTIFICATION, notification.getKey());
            notification.getNotification().fullScreenIntent.send();
        } catch (PendingIntent.CanceledException e) {
        }
    } else {
        // show the ticker if there isn't already a heads up
        if (mHeadsUpNotificationView.getEntry() == null) {
            tick(notification, true);
        }
    }
    addNotificationViews(shadeEntry, ranking);
    // Recalculate the position of the sliding windows and the titles.
    setAreThereNotifications();
    updateExpandedViewPos(EXPANDED_LEAVE_ALONE);
}
#end_block

#method_before
@Override
public void scheduleHeadsUpOpen() {
    mHandler.sendEmptyMessage(MSG_SHOW_HEADS_UP);
}
#method_after
@Override
public void scheduleHeadsUpOpen() {
    mHandler.removeMessages(MSG_SHOW_HEADS_UP);
    mHandler.sendEmptyMessage(MSG_SHOW_HEADS_UP);
}
#end_block

#method_before
// CommandQueue
@Override
public void scheduleHeadsUpClose() {
    mHandler.sendEmptyMessage(MSG_HIDE_HEADS_UP);
}
#method_after
// CommandQueue
@Override
public void scheduleHeadsUpClose() {
    mHandler.removeMessages(MSG_HIDE_HEADS_UP);
    mHandler.sendEmptyMessage(MSG_HIDE_HEADS_UP);
}
#end_block

#method_before
@Override
public void scheduleHeadsUpEscalation() {
    mHandler.sendEmptyMessage(MSG_ESCALATE_HEADS_UP);
}
#method_after
@Override
public void scheduleHeadsUpEscalation() {
    mHandler.removeMessages(MSG_ESCALATE_HEADS_UP);
    mHandler.sendEmptyMessage(MSG_ESCALATE_HEADS_UP);
}
#end_block

#method_before
private void updateNotificationShade() {
    if (mStackScroller == null)
        return;
    // Do not modify the notifications during collapse.
    if (isCollapsing()) {
        addPostCollapseAction(new Runnable() {

            @Override
            public void run() {
                updateNotificationShade();
            }
        });
        return;
    }
    ArrayList<Entry> activeNotifications = mNotificationData.getActiveNotifications();
    ArrayList<ExpandableNotificationRow> toShow = new ArrayList<>(activeNotifications.size());
    final int N = activeNotifications.size();
    for (int i = 0; i < N; i++) {
        Entry ent = activeNotifications.get(i);
        int vis = ent.notification.getNotification().visibility;
        // Display public version of the notification if we need to redact.
        final boolean hideSensitive = !userAllowsPrivateNotificationsInPublic(ent.notification.getUserId());
        boolean sensitiveNote = vis == Notification.VISIBILITY_PRIVATE;
        boolean sensitivePackage = packageHasVisibilityOverride(ent.notification.getKey());
        boolean sensitive = (sensitiveNote && hideSensitive) || sensitivePackage;
        boolean showingPublic = sensitive && isLockscreenPublicMode();
        ent.row.setSensitive(sensitive);
        if (ent.autoRedacted && ent.legacy) {
            // for legacy auto redacted notifications.
            if (showingPublic) {
                ent.row.setShowingLegacyBackground(false);
            } else {
                ent.row.setShowingLegacyBackground(true);
            }
        }
        toShow.add(ent.row);
    }
    ArrayList<View> toRemove = new ArrayList<View>();
    for (int i = 0; i < mStackScroller.getChildCount(); i++) {
        View child = mStackScroller.getChildAt(i);
        if (!toShow.contains(child) && child instanceof ExpandableNotificationRow) {
            toRemove.add(child);
        }
    }
    for (View remove : toRemove) {
        mStackScroller.removeView(remove);
    }
    for (int i = 0; i < toShow.size(); i++) {
        View v = toShow.get(i);
        if (v.getParent() == null) {
            mStackScroller.addView(v);
        }
    }
    // So after all this work notifications still aren't sorted correctly.
    // Let's do that now by advancing through toShow and mStackScroller in
    // lock-step, making sure mStackScroller matches what we see in toShow.
    int j = 0;
    for (int i = 0; i < mStackScroller.getChildCount(); i++) {
        View child = mStackScroller.getChildAt(i);
        if (!(child instanceof ExpandableNotificationRow)) {
            // We don't care about non-notification views.
            continue;
        }
        if (child == toShow.get(j)) {
            // Everything is well, advance both lists.
            j++;
            continue;
        }
        // Oops, wrong notification at this position. Put the right one
        // here and advance both lists.
        mStackScroller.changeViewPosition(toShow.get(j), i);
        j++;
    }
    updateRowStates();
    updateSpeedbump();
    updateClearAll();
    updateEmptyShadeView();
    // Disable QS if device not provisioned.
    // If the user switcher is simple then disable QS during setup because
    // the user intends to use the lock screen user switcher, QS in not needed.
    mNotificationPanel.setQsExpansionEnabled(isDeviceProvisioned() && (!mUserSwitcherController.isSimpleUserSwitcher() || mUserSetup));
    mShadeUpdates.check();
}
#method_after
private void updateNotificationShade() {
    if (mStackScroller == null)
        return;
    // Do not modify the notifications during collapse.
    if (isCollapsing()) {
        addPostCollapseAction(new Runnable() {

            @Override
            public void run() {
                updateNotificationShade();
            }
        });
        return;
    }
    ArrayList<Entry> activeNotifications = mNotificationData.getActiveNotifications();
    ArrayList<ExpandableNotificationRow> toShow = new ArrayList<>(activeNotifications.size());
    final int N = activeNotifications.size();
    for (int i = 0; i < N; i++) {
        Entry ent = activeNotifications.get(i);
        int vis = ent.notification.getNotification().visibility;
        // Display public version of the notification if we need to redact.
        final boolean hideSensitive = !userAllowsPrivateNotificationsInPublic(ent.notification.getUserId());
        boolean sensitiveNote = vis == Notification.VISIBILITY_PRIVATE;
        boolean sensitivePackage = packageHasVisibilityOverride(ent.notification.getKey());
        boolean sensitive = (sensitiveNote && hideSensitive) || sensitivePackage;
        boolean showingPublic = sensitive && isLockscreenPublicMode();
        ent.row.setSensitive(sensitive);
        if (ent.autoRedacted && ent.legacy) {
            // for legacy auto redacted notifications.
            if (showingPublic) {
                ent.row.setShowingLegacyBackground(false);
            } else {
                ent.row.setShowingLegacyBackground(true);
            }
        }
        toShow.add(ent.row);
    }
    ArrayList<View> toRemove = new ArrayList<View>();
    for (int i = 0; i < mStackScroller.getChildCount(); i++) {
        View child = mStackScroller.getChildAt(i);
        if (!toShow.contains(child) && child instanceof ExpandableNotificationRow) {
            toRemove.add(child);
        }
    }
    for (View remove : toRemove) {
        mStackScroller.removeView(remove);
    }
    for (int i = 0; i < toShow.size(); i++) {
        View v = toShow.get(i);
        if (v.getParent() == null) {
            mStackScroller.addView(v);
        }
    }
    // So after all this work notifications still aren't sorted correctly.
    // Let's do that now by advancing through toShow and mStackScroller in
    // lock-step, making sure mStackScroller matches what we see in toShow.
    int j = 0;
    for (int i = 0; i < mStackScroller.getChildCount(); i++) {
        View child = mStackScroller.getChildAt(i);
        if (!(child instanceof ExpandableNotificationRow)) {
            // We don't care about non-notification views.
            continue;
        }
        if (child == toShow.get(j)) {
            // Everything is well, advance both lists.
            j++;
            continue;
        }
        // Oops, wrong notification at this position. Put the right one
        // here and advance both lists.
        mStackScroller.changeViewPosition(toShow.get(j), i);
        j++;
    }
    updateRowStates();
    updateSpeedbump();
    updateClearAll();
    updateEmptyShadeView();
    // Disable QS if device not provisioned.
    // If the user switcher is simple then disable QS during setup because
    // the user intends to use the lock screen user switcher, QS in not needed.
    mNotificationPanel.setQsExpansionEnabled(isDeviceProvisioned() && (mUserSetup || mUserSwitcherController == null || !mUserSwitcherController.isSimpleUserSwitcher()));
    mShadeUpdates.check();
}
#end_block

#method_before
@Override
protected void updateNotifications() {
    if (!mHandler.hasMessages(MSG_UPDATE_NOTIFICATIONS)) {
        mHandler.sendEmptyMessage(MSG_UPDATE_NOTIFICATIONS);
    }
}
#method_after
@Override
protected void updateNotifications(boolean immediate) {
    if (immediate) {
        mHandler.removeMessages(MSG_UPDATE_NOTIFICATIONS);
        handleUpdateNotifications();
    } else {
        if (!mHandler.hasMessages(MSG_UPDATE_NOTIFICATIONS)) {
            mHandler.sendEmptyMessage(MSG_UPDATE_NOTIFICATIONS);
        }
    }
}
#end_block

#method_before
public boolean isFalsingThresholdNeeded() {
    boolean onKeyguard = getBarState() == StatusBarState.KEYGUARD;
    // boolean isMethodInsecure = mUnlockMethodCache.isMethodInsecure();
    return onKeyguard && (/*isMethodInsecure ||*/
    mDozing || mScreenOnComingFromTouch);
}
#method_after
public boolean isFalsingThresholdNeeded() {
    boolean onKeyguard = getBarState() == StatusBarState.KEYGUARD;
    boolean isCurrentlyInsecure = mUnlockMethodCache.isCurrentlyInsecure();
    return onKeyguard && (isCurrentlyInsecure || mDozing || mScreenOnComingFromTouch);
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_SHOW_HEADS_UP:
            setHeadsUpVisibility(true);
            break;
        case MSG_DECAY_HEADS_UP:
            mHeadsUpNotificationView.release();
            setHeadsUpVisibility(false);
            break;
        case MSG_HIDE_HEADS_UP:
            mHeadsUpNotificationView.release();
            setHeadsUpVisibility(false);
            break;
        case MSG_ESCALATE_HEADS_UP:
            escalateHeadsUp();
            setHeadsUpVisibility(false);
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
        case MSG_UPDATE_NOTIFICATIONS:
            handleUpdateNotifications();
            break;
    }
}
#end_block

#method_before
private void escalateHeadsUp() {
    if (mHeadsUpNotificationView.getEntry() != null) {
        final StatusBarNotification sbn = mHeadsUpNotificationView.getEntry().notification;
        mHeadsUpNotificationView.release();
        final Notification notification = sbn.getNotification();
        if (notification.fullScreenIntent != null) {
            if (DEBUG)
                Log.d(TAG, "converting a heads up to fullScreen");
            try {
                notification.fullScreenIntent.send();
            } catch (PendingIntent.CanceledException e) {
            }
        }
    }
}
#method_after
private void escalateHeadsUp() {
    if (mHeadsUpNotificationView.getEntry() != null) {
        final StatusBarNotification sbn = mHeadsUpNotificationView.getEntry().notification;
        mHeadsUpNotificationView.release();
        final Notification notification = sbn.getNotification();
        if (notification.fullScreenIntent != null) {
            if (DEBUG)
                Log.d(TAG, "converting a heads up to fullScreen");
            try {
                EventLog.writeEvent(EventLogTags.SYSUI_HEADS_UP_ESCALATION, sbn.getKey());
                notification.fullScreenIntent.send();
            } catch (PendingIntent.CanceledException e) {
            }
        }
    }
}
#end_block

#method_before
void makeExpandedInvisible() {
    if (SPEW)
        Log.d(TAG, "makeExpandedInvisible: mExpandedVisible=" + mExpandedVisible + " mExpandedVisible=" + mExpandedVisible);
    if (!mExpandedVisible || mStatusBarWindow == null) {
        return;
    }
    // Ensure the panel is fully collapsed (just in case; bug 6765842, 7260868)
    mStatusBarView.collapseAllPanels(/*animate=*/
    false);
    // reset things to their proper state
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    mStackScroller.setVisibility(View.VISIBLE);
    mNotificationPanel.setVisibility(View.GONE);
    mNotificationPanel.closeQs();
    mExpandedVisible = false;
    if (mNavigationBarView != null)
        mNavigationBarView.setSlippery(false);
    visibilityChanged(false);
    // Shrink the window to the size of the status bar only
    mStatusBarWindowManager.setStatusBarExpanded(false);
    mStatusBarView.setFocusable(true);
    // Close any "App info" popups that might have snuck on-screen
    dismissPopups();
    runPostCollapseRunnables();
    setInteracting(StatusBarManager.WINDOW_STATUS_BAR, false);
    showBouncer();
    disable(mDisabledUnmodified, true);
}
#method_after
void makeExpandedInvisible() {
    if (SPEW)
        Log.d(TAG, "makeExpandedInvisible: mExpandedVisible=" + mExpandedVisible + " mExpandedVisible=" + mExpandedVisible);
    if (!mExpandedVisible || mStatusBarWindow == null) {
        return;
    }
    // Ensure the panel is fully collapsed (just in case; bug 6765842, 7260868)
    mStatusBarView.collapseAllPanels(/*animate=*/
    false);
    // reset things to their proper state
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    mStackScroller.setVisibility(View.VISIBLE);
    mNotificationPanel.setVisibility(View.GONE);
    mNotificationPanel.closeQs();
    mExpandedVisible = false;
    if (mNavigationBarView != null)
        mNavigationBarView.setSlippery(false);
    visibilityChanged(false);
    // Shrink the window to the size of the status bar only
    mStatusBarWindowManager.setStatusBarExpanded(false);
    mStatusBarView.setFocusable(true);
    // Close any "App info" popups that might have snuck on-screen
    dismissPopups();
    runPostCollapseRunnables();
    setInteracting(StatusBarManager.WINDOW_STATUS_BAR, false);
    showBouncer();
    disable(mDisabledUnmodified, true);
    // the bouncer appear animation.
    if (!mStatusBarKeyguardViewManager.isShowing()) {
        WindowManagerGlobal.getInstance().trimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
    }
}
#end_block

#method_before
private int barMode(int vis, int transientFlag, int translucentFlag) {
    return (vis & transientFlag) != 0 ? MODE_SEMI_TRANSPARENT : (vis & translucentFlag) != 0 ? MODE_TRANSLUCENT : (vis & View.SYSTEM_UI_TRANSPARENT) != 0 ? MODE_TRANSPARENT : (vis & View.SYSTEM_UI_FLAG_LOW_PROFILE) != 0 ? MODE_LIGHTS_OUT : MODE_OPAQUE;
}
#method_after
private int barMode(int vis, int transientFlag, int translucentFlag) {
    int lightsOutTransparent = View.SYSTEM_UI_FLAG_LOW_PROFILE | View.SYSTEM_UI_TRANSPARENT;
    return (vis & transientFlag) != 0 ? MODE_SEMI_TRANSPARENT : (vis & translucentFlag) != 0 ? MODE_TRANSLUCENT : (vis & lightsOutTransparent) == lightsOutTransparent ? MODE_LIGHTS_OUT_TRANSPARENT : (vis & View.SYSTEM_UI_TRANSPARENT) != 0 ? MODE_TRANSPARENT : (vis & View.SYSTEM_UI_FLAG_LOW_PROFILE) != 0 ? MODE_LIGHTS_OUT : MODE_OPAQUE;
}
#end_block

#method_before
@Override
public void setInteracting(int barWindow, boolean interacting) {
    mInteractingWindows = interacting ? (mInteractingWindows | barWindow) : (mInteractingWindows & ~barWindow);
    if (mInteractingWindows != 0) {
        suspendAutohide();
    } else {
        resumeSuspendedAutohide();
    }
    checkBarModes();
}
#method_after
@Override
public void setInteracting(int barWindow, boolean interacting) {
    final boolean changing = ((mInteractingWindows & barWindow) != 0) != interacting;
    mInteractingWindows = interacting ? (mInteractingWindows | barWindow) : (mInteractingWindows & ~barWindow);
    if (mInteractingWindows != 0) {
        suspendAutohide();
    } else {
        resumeSuspendedAutohide();
    }
    // manually dismiss the volume panel when interacting with the nav bar
    if (changing && interacting && barWindow == StatusBarManager.WINDOW_NAVIGATION_BAR) {
        if (mVolumeComponent != null) {
            mVolumeComponent.dismissNow();
        }
    }
    checkBarModes();
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    synchronized (mQueueLock) {
        pw.println("Current Status Bar state:");
        pw.println("  mExpandedVisible=" + mExpandedVisible + ", mTrackingPosition=" + mTrackingPosition);
        pw.println("  mTickerEnabled=" + mTickerEnabled);
        if (mTickerEnabled) {
            pw.println("  mTicking=" + mTicking);
            pw.println("  mTickerView: " + viewInfo(mTickerView));
        }
        pw.println("  mTracking=" + mTracking);
        pw.println("  mDisplayMetrics=" + mDisplayMetrics);
        pw.println("  mStackScroller: " + viewInfo(mStackScroller));
        pw.println("  mStackScroller: " + viewInfo(mStackScroller) + " scroll " + mStackScroller.getScrollX() + "," + mStackScroller.getScrollY());
    }
    pw.print("  mInteractingWindows=");
    pw.println(mInteractingWindows);
    pw.print("  mStatusBarWindowState=");
    pw.println(windowStateToString(mStatusBarWindowState));
    pw.print("  mStatusBarMode=");
    pw.println(BarTransitions.modeToString(mStatusBarMode));
    pw.print("  mDozing=");
    pw.println(mDozing);
    pw.print("  mZenMode=");
    pw.println(Settings.Global.zenModeToString(mZenMode));
    pw.print("  interrupting package: ");
    pw.println(hunStateToString(mHeadsUpNotificationView.getEntry()));
    dumpBarTransitions(pw, "mStatusBarView", mStatusBarView.getBarTransitions());
    if (mNavigationBarView != null) {
        pw.print("  mNavigationBarWindowState=");
        pw.println(windowStateToString(mNavigationBarWindowState));
        pw.print("  mNavigationBarMode=");
        pw.println(BarTransitions.modeToString(mNavigationBarMode));
        dumpBarTransitions(pw, "mNavigationBarView", mNavigationBarView.getBarTransitions());
    }
    pw.print("  mNavigationBarView=");
    if (mNavigationBarView == null) {
        pw.println("null");
    } else {
        mNavigationBarView.dump(fd, pw, args);
    }
    pw.print("  mMediaSessionManager=");
    pw.println(mMediaSessionManager);
    pw.print("  mMediaNotificationKey=");
    pw.println(mMediaNotificationKey);
    pw.print("  mMediaController=");
    pw.print(mMediaController);
    if (mMediaController != null) {
        pw.print(" state=" + mMediaController.getPlaybackState());
    }
    pw.println();
    pw.print("  mMediaMetadata=");
    pw.print(mMediaMetadata);
    if (mMediaMetadata != null) {
        pw.print(" title=" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
    }
    pw.println();
    pw.println("  Panels: ");
    if (mNotificationPanel != null) {
        pw.println("    mNotificationPanel=" + mNotificationPanel + " params=" + mNotificationPanel.getLayoutParams().debug(""));
        pw.print("      ");
        mNotificationPanel.dump(fd, pw, args);
    }
    DozeLog.dump(pw);
    if (DUMPTRUCK) {
        synchronized (mNotificationData) {
            mNotificationData.dump(pw, "  ");
        }
        int N = mStatusIcons.getChildCount();
        pw.println("  system icons: " + N);
        for (int i = 0; i < N; i++) {
            StatusBarIconView ic = (StatusBarIconView) mStatusIcons.getChildAt(i);
            pw.println("    [" + i + "] icon=" + ic);
        }
        if (false) {
            pw.println("see the logcat for a dump of the views we have created.");
            // must happen on ui thread
            mHandler.post(new Runnable() {

                public void run() {
                    mStatusBarView.getLocationOnScreen(mAbsPos);
                    Log.d(TAG, "mStatusBarView: ----- (" + mAbsPos[0] + "," + mAbsPos[1] + ") " + mStatusBarView.getWidth() + "x" + getStatusBarHeight());
                    mStatusBarView.debug();
                }
            });
        }
    }
    if (DEBUG_GESTURES) {
        pw.print("  status bar gestures: ");
        mGestureRec.dump(fd, pw, args);
    }
    if (isMSim()) {
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            if (mMSimNetworkController != null) {
                mMSimNetworkController.dump(fd, pw, args, i);
            }
        }
    } else {
        if (mNetworkController != null) {
            mNetworkController.dump(fd, pw, args);
        }
    }
    if (mBluetoothController != null) {
        mBluetoothController.dump(fd, pw, args);
    }
    if (mCastController != null) {
        mCastController.dump(fd, pw, args);
    }
    if (mUserSwitcherController != null) {
        mUserSwitcherController.dump(fd, pw, args);
    }
    if (mBatteryController != null) {
        mBatteryController.dump(fd, pw, args);
    }
    if (mNextAlarmController != null) {
        mNextAlarmController.dump(fd, pw, args);
    }
    if (mSecurityController != null) {
        mSecurityController.dump(fd, pw, args);
    }
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    synchronized (mQueueLock) {
        pw.println("Current Status Bar state:");
        pw.println("  mExpandedVisible=" + mExpandedVisible + ", mTrackingPosition=" + mTrackingPosition);
        pw.println("  mTickerEnabled=" + mTickerEnabled);
        if (mTickerEnabled) {
            pw.println("  mTicking=" + mTicking);
            pw.println("  mTickerView: " + viewInfo(mTickerView));
        }
        pw.println("  mTracking=" + mTracking);
        pw.println("  mDisplayMetrics=" + mDisplayMetrics);
        pw.println("  mStackScroller: " + viewInfo(mStackScroller));
        pw.println("  mStackScroller: " + viewInfo(mStackScroller) + " scroll " + mStackScroller.getScrollX() + "," + mStackScroller.getScrollY());
    }
    pw.print("  mInteractingWindows=");
    pw.println(mInteractingWindows);
    pw.print("  mStatusBarWindowState=");
    pw.println(windowStateToString(mStatusBarWindowState));
    pw.print("  mStatusBarMode=");
    pw.println(BarTransitions.modeToString(mStatusBarMode));
    pw.print("  mDozing=");
    pw.println(mDozing);
    pw.print("  mZenMode=");
    pw.println(Settings.Global.zenModeToString(mZenMode));
    pw.print("  interrupting package: ");
    pw.println(hunStateToString(mHeadsUpNotificationView.getEntry()));
    dumpBarTransitions(pw, "mStatusBarView", mStatusBarView.getBarTransitions());
    if (mNavigationBarView != null) {
        pw.print("  mNavigationBarWindowState=");
        pw.println(windowStateToString(mNavigationBarWindowState));
        pw.print("  mNavigationBarMode=");
        pw.println(BarTransitions.modeToString(mNavigationBarMode));
        dumpBarTransitions(pw, "mNavigationBarView", mNavigationBarView.getBarTransitions());
    }
    pw.print("  mNavigationBarView=");
    if (mNavigationBarView == null) {
        pw.println("null");
    } else {
        mNavigationBarView.dump(fd, pw, args);
    }
    pw.print("  mMediaSessionManager=");
    pw.println(mMediaSessionManager);
    pw.print("  mMediaNotificationKey=");
    pw.println(mMediaNotificationKey);
    pw.print("  mMediaController=");
    pw.print(mMediaController);
    if (mMediaController != null) {
        pw.print(" state=" + mMediaController.getPlaybackState());
    }
    pw.println();
    pw.print("  mMediaMetadata=");
    pw.print(mMediaMetadata);
    if (mMediaMetadata != null) {
        pw.print(" title=" + mMediaMetadata.getText(MediaMetadata.METADATA_KEY_TITLE));
    }
    pw.println();
    pw.println("  Panels: ");
    if (mNotificationPanel != null) {
        pw.println("    mNotificationPanel=" + mNotificationPanel + " params=" + mNotificationPanel.getLayoutParams().debug(""));
        pw.print("      ");
        mNotificationPanel.dump(fd, pw, args);
    }
    DozeLog.dump(pw);
    if (DUMPTRUCK) {
        synchronized (mNotificationData) {
            mNotificationData.dump(pw, "  ");
        }
        int N = mStatusIcons.getChildCount();
        pw.println("  system icons: " + N);
        for (int i = 0; i < N; i++) {
            StatusBarIconView ic = (StatusBarIconView) mStatusIcons.getChildAt(i);
            pw.println("    [" + i + "] icon=" + ic);
        }
        if (false) {
            pw.println("see the logcat for a dump of the views we have created.");
            // must happen on ui thread
            mHandler.post(new Runnable() {

                public void run() {
                    mStatusBarView.getLocationOnScreen(mAbsPos);
                    Log.d(TAG, "mStatusBarView: ----- (" + mAbsPos[0] + "," + mAbsPos[1] + ") " + mStatusBarView.getWidth() + "x" + getStatusBarHeight());
                    mStatusBarView.debug();
                }
            });
        }
    }
    if (DEBUG_GESTURES) {
        pw.print("  status bar gestures: ");
        mGestureRec.dump(fd, pw, args);
    }
    if (isMSim()) {
        for (int i = 0; i < TelephonyManager.getDefault().getPhoneCount(); i++) {
            if (mMSimNetworkController != null) {
                mMSimNetworkController.dump(fd, pw, args, i);
            }
        }
    } else {
        if (mNetworkController != null) {
            mNetworkController.dump(fd, pw, args);
        }
    }
    if (mBluetoothController != null) {
        mBluetoothController.dump(fd, pw, args);
    }
    if (mCastController != null) {
        mCastController.dump(fd, pw, args);
    }
    if (mUserSwitcherController != null) {
        mUserSwitcherController.dump(fd, pw, args);
    }
    if (mBatteryController != null) {
        mBatteryController.dump(fd, pw, args);
    }
    if (mNextAlarmController != null) {
        mNextAlarmController.dump(fd, pw, args);
    }
    if (mSecurityController != null) {
        mSecurityController.dump(fd, pw, args);
    }
    pw.println("SharedPreferences:");
    for (Map.Entry<String, ?> entry : mContext.getSharedPreferences(mContext.getPackageName(), Context.MODE_PRIVATE).getAll().entrySet()) {
        pw.print("  ");
        pw.print(entry.getKey());
        pw.print("=");
        pw.println(entry.getValue());
    }
}
#end_block

#method_before
@Override
protected void dismissKeyguardThenExecute(final OnDismissAction action, boolean afterKeyguardGone) {
    if (mStatusBarKeyguardViewManager.isShowing()) {
        if (/*UnlockMethodCache.getInstance(mContext).isMethodInsecure()
                    &&*/
        mNotificationPanel.isLaunchTransitionRunning() && !afterKeyguardGone) {
            action.onDismiss();
            mNotificationPanel.setLaunchTransitionEndRunnable(new Runnable() {

                @Override
                public void run() {
                    mStatusBarKeyguardViewManager.dismiss();
                }
            });
        } else {
            mStatusBarKeyguardViewManager.dismissWithAction(action, afterKeyguardGone);
        }
    } else {
        action.onDismiss();
    }
}
#method_after
@Override
protected void dismissKeyguardThenExecute(final OnDismissAction action, boolean afterKeyguardGone) {
    if (mStatusBarKeyguardViewManager.isShowing()) {
        mStatusBarKeyguardViewManager.dismissWithAction(action, afterKeyguardGone);
    } else {
        action.onDismiss();
    }
}
#end_block

#method_before
@Override
public void userSwitched(int newUserId) {
    if (MULTIUSER_DEBUG)
        mNotificationPanelDebugText.setText("USER " + newUserId);
    animateCollapsePanels();
    updateNotifications();
    resetUserSetupObserver();
    setControllerUsers();
}
#method_after
@Override
public void userSwitched(int newUserId) {
    super.userSwitched(newUserId);
    if (MULTIUSER_DEBUG)
        mNotificationPanelDebugText.setText("USER " + newUserId);
    animateCollapsePanels();
    updatePublicMode();
    updateNotifications(true);
    resetUserSetupObserver();
    setControllerUsers();
}
#end_block

#method_before
@Override
public void dispatchDemoCommand(String command, Bundle args) {
    if (!mDemoModeAllowed) {
        mDemoModeAllowed = Settings.Global.getInt(mContext.getContentResolver(), "sysui_demo_allowed", 0) != 0;
    }
    if (!mDemoModeAllowed)
        return;
    if (command.equals(COMMAND_ENTER)) {
        mDemoMode = true;
    } else if (command.equals(COMMAND_EXIT)) {
        mDemoMode = false;
        checkBarModes();
    } else if (!mDemoMode) {
        // automatically enter demo mode on first demo command
        dispatchDemoCommand(COMMAND_ENTER, new Bundle());
    }
    boolean modeChange = command.equals(COMMAND_ENTER) || command.equals(COMMAND_EXIT);
    if (modeChange || command.equals(COMMAND_CLOCK)) {
        dispatchDemoCommandToView(command, args, R.id.clock);
    }
    if (modeChange || command.equals(COMMAND_BATTERY)) {
        dispatchDemoCommandToView(command, args, R.id.battery);
    }
    if (modeChange || command.equals(COMMAND_STATUS)) {
        if (mDemoStatusIcons == null) {
            mDemoStatusIcons = new DemoStatusIcons(mStatusIcons, mIconSize);
        }
        mDemoStatusIcons.dispatchDemoCommand(command, args);
    }
    if (mNetworkController != null && (modeChange || command.equals(COMMAND_NETWORK))) {
        mNetworkController.dispatchDemoCommand(command, args);
    }
    if (modeChange || command.equals(COMMAND_NOTIFICATIONS)) {
        View notifications = mStatusBarView == null ? null : mStatusBarView.findViewById(R.id.notification_icon_area);
        if (notifications != null) {
            String visible = args.getString("visible");
            int vis = mDemoMode && "false".equals(visible) ? View.INVISIBLE : View.VISIBLE;
            notifications.setVisibility(vis);
        }
    }
    if (command.equals(COMMAND_BARS)) {
        String mode = args.getString("mode");
        int barMode = "opaque".equals(mode) ? MODE_OPAQUE : "translucent".equals(mode) ? MODE_TRANSLUCENT : "semi-transparent".equals(mode) ? MODE_SEMI_TRANSPARENT : "transparent".equals(mode) ? MODE_TRANSPARENT : "warning".equals(mode) ? MODE_WARNING : -1;
        if (barMode != -1) {
            boolean animate = true;
            if (mStatusBarView != null) {
                mStatusBarView.getBarTransitions().transitionTo(barMode, animate);
            }
            if (mNavigationBarView != null) {
                mNavigationBarView.getBarTransitions().transitionTo(barMode, animate);
            }
        }
    }
}
#method_after
@Override
public void dispatchDemoCommand(String command, Bundle args) {
    if (!mDemoModeAllowed) {
        mDemoModeAllowed = Settings.Global.getInt(mContext.getContentResolver(), "sysui_demo_allowed", 0) != 0;
    }
    if (!mDemoModeAllowed)
        return;
    if (command.equals(COMMAND_ENTER)) {
        mDemoMode = true;
    } else if (command.equals(COMMAND_EXIT)) {
        mDemoMode = false;
        checkBarModes();
    } else if (!mDemoMode) {
        // automatically enter demo mode on first demo command
        dispatchDemoCommand(COMMAND_ENTER, new Bundle());
    }
    boolean modeChange = command.equals(COMMAND_ENTER) || command.equals(COMMAND_EXIT);
    if ((modeChange || command.equals(COMMAND_VOLUME)) && mVolumeComponent != null) {
        mVolumeComponent.dispatchDemoCommand(command, args);
    }
    if (modeChange || command.equals(COMMAND_CLOCK)) {
        dispatchDemoCommandToView(command, args, R.id.clock);
    }
    if (modeChange || command.equals(COMMAND_BATTERY)) {
        dispatchDemoCommandToView(command, args, R.id.battery);
    }
    if (modeChange || command.equals(COMMAND_STATUS)) {
        if (mDemoStatusIcons == null) {
            mDemoStatusIcons = new DemoStatusIcons(mStatusIcons, mIconSize);
        }
        mDemoStatusIcons.dispatchDemoCommand(command, args);
    }
    if (mNetworkController != null && (modeChange || command.equals(COMMAND_NETWORK))) {
        mNetworkController.dispatchDemoCommand(command, args);
    }
    if (modeChange || command.equals(COMMAND_NOTIFICATIONS)) {
        View notifications = mStatusBarView == null ? null : mStatusBarView.findViewById(R.id.notification_icon_area);
        if (notifications != null) {
            String visible = args.getString("visible");
            int vis = mDemoMode && "false".equals(visible) ? View.INVISIBLE : View.VISIBLE;
            notifications.setVisibility(vis);
        }
    }
    if (command.equals(COMMAND_BARS)) {
        String mode = args.getString("mode");
        int barMode = "opaque".equals(mode) ? MODE_OPAQUE : "translucent".equals(mode) ? MODE_TRANSLUCENT : "semi-transparent".equals(mode) ? MODE_SEMI_TRANSPARENT : "transparent".equals(mode) ? MODE_TRANSPARENT : "warning".equals(mode) ? MODE_WARNING : -1;
        if (barMode != -1) {
            boolean animate = true;
            if (mStatusBarView != null) {
                mStatusBarView.getBarTransitions().transitionTo(barMode, animate);
            }
            if (mNavigationBarView != null) {
                mNavigationBarView.getBarTransitions().transitionTo(barMode, animate);
            }
        }
    }
}
#end_block

#method_before
private void updatePublicMode() {
    setLockscreenPublicMode((mStatusBarKeyguardViewManager.isShowing() || mStatusBarKeyguardViewManager.isOccluded()) && mStatusBarKeyguardViewManager.isSecure());
}
#method_after
private void updatePublicMode() {
    setLockscreenPublicMode(mStatusBarKeyguardViewManager.isShowing() && mStatusBarKeyguardViewManager.isSecure(mCurrentUserId));
}
#end_block

#method_before
private void updateKeyguardState(boolean goingToFullShade, boolean fromShadeLocked) {
    if (mState == StatusBarState.KEYGUARD) {
        mKeyguardIndicationController.setVisible(true);
        mNotificationPanel.resetViews();
        mKeyguardUserSwitcher.setKeyguard(true, fromShadeLocked);
    } else {
        mKeyguardIndicationController.setVisible(false);
        mKeyguardUserSwitcher.setKeyguard(false, goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
    }
    if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
        mScrimController.setKeyguardShowing(true);
    } else {
        mScrimController.setKeyguardShowing(false);
    }
    mNotificationPanel.setBarState(mState, mKeyguardFadingAway, goingToFullShade);
    updateDozingState();
    updatePublicMode();
    updateStackScrollerState(goingToFullShade);
    updateNotifications();
    checkBarModes();
    updateCarrierLabelVisibility(false);
    updateMediaMetaData(false);
    mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(), mStatusBarKeyguardViewManager.isSecure());
}
#method_after
private void updateKeyguardState(boolean goingToFullShade, boolean fromShadeLocked) {
    if (mState == StatusBarState.KEYGUARD) {
        mKeyguardIndicationController.setVisible(true);
        mNotificationPanel.resetViews();
        mKeyguardUserSwitcher.setKeyguard(true, fromShadeLocked);
    } else {
        mKeyguardIndicationController.setVisible(false);
        mKeyguardUserSwitcher.setKeyguard(false, goingToFullShade || mState == StatusBarState.SHADE_LOCKED || fromShadeLocked);
    }
    if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
        mScrimController.setKeyguardShowing(true);
    } else {
        mScrimController.setKeyguardShowing(false);
    }
    mNotificationPanel.setBarState(mState, mKeyguardFadingAway, goingToFullShade);
    updateDozingState();
    updatePublicMode();
    updateStackScrollerState(goingToFullShade);
    updateNotifications(true);
    checkBarModes();
    updateCarrierLabelVisibility(false);
    updateMediaMetaData(false);
    mKeyguardMonitor.notifyKeyguardState(mStatusBarKeyguardViewManager.isShowing(), mStatusBarKeyguardViewManager.isSecure());
}
#end_block

#method_before
@Override
public void onActivated(ActivatableNotificationView view) {
    mKeyguardIndicationController.showTransientIndication(R.string.notification_tap_again);
    ActivatableNotificationView previousView = mStackScroller.getActivatedChild();
    if (previousView != null) {
        previousView.makeInactive(true);
    }
    mStackScroller.setActivatedChild(view);
}
#method_after
@Override
public void onActivated(ActivatableNotificationView view) {
    EventLogTags.writeSysuiLockscreenGesture(EventLogConstants.SYSUI_LOCKSCREEN_GESTURE_TAP_NOTIFICATION_ACTIVATE, 0, /* lengthDp - N/A */
    0);
    mKeyguardIndicationController.showTransientIndication(R.string.notification_tap_again);
    ActivatableNotificationView previousView = mStackScroller.getActivatedChild();
    if (previousView != null) {
        previousView.makeInactive(true);
    }
    mStackScroller.setActivatedChild(view);
}
#end_block

#method_before
public void setBarState(int state) {
    mState = state;
    mStatusBarWindowManager.setStatusBarState(state);
}
#method_after
public void setBarState(int state) {
    // Other transitions are covered in handleVisibleToUserChanged().
    if (state != mState && mVisible && state == StatusBarState.SHADE_LOCKED) {
        try {
            mBarService.clearNotificationEffects();
        } catch (RemoteException e) {
        // Ignore.
        }
    }
    mState = state;
    mStatusBarWindowManager.setStatusBarState(state);
}
#end_block

#method_before
public void onTrackingStopped(boolean expand) {
    if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
        if (!expand) /*&& !mUnlockMethodCache.isMethodInsecure()*/
        {
            showBouncer();
        }
    }
}
#method_after
public void onTrackingStopped(boolean expand) {
    if (mState == StatusBarState.KEYGUARD || mState == StatusBarState.SHADE_LOCKED) {
        if (!expand && !mUnlockMethodCache.isCurrentlyInsecure()) {
            showBouncer();
        }
    }
}
#end_block

#method_before
// ---------------------- DragDownHelper.OnDragDownListener ------------------------------------
@Override
public boolean onDraggedDown(View startingChild, int dragLengthY) {
    if (hasActiveNotifications()) {
        // We have notifications, go to locked shade.
        goToLockedShade(startingChild);
        return true;
    } else {
        // No notifications - abort gesture.
        return false;
    }
}
#method_after
// ---------------------- DragDownHelper.OnDragDownListener ------------------------------------
@Override
public boolean onDraggedDown(View startingChild, int dragLengthY) {
    if (hasActiveNotifications()) {
        EventLogTags.writeSysuiLockscreenGesture(EventLogConstants.SYSUI_LOCKSCREEN_GESTURE_SWIPE_DOWN_FULL_SHADE, (int) (dragLengthY / mDisplayMetrics.density), 0);
        // We have notifications, go to locked shade.
        goToLockedShade(startingChild);
        return true;
    } else {
        // No notifications - abort gesture.
        return false;
    }
}
#end_block

#method_before
public void onScreenTurnedOff() {
    mScreenOnFromKeyguard = false;
    mScreenOnComingFromTouch = false;
    mScreenOnTouchLocation = null;
    mStackScroller.setAnimationsEnabled(false);
    updateVisibleToUser();
}
#method_after
void onScreenTurnedOff() {
    mScreenOnFromKeyguard = false;
    mScreenOnComingFromTouch = false;
    mScreenOnTouchLocation = null;
    mStackScroller.setAnimationsEnabled(false);
    updateVisibleToUser();
}
#end_block

#method_before
public void onBackAltCleared() {
    // animation as home (if we catch this condition early enough).
    if (getBackButton() == null && getHomeButton() == null)
        return;
    if (getBackButton() != null) {
        if (!mBackTransitioning && getBackButton().getVisibility() == VISIBLE && mHomeAppearing && getHomeButton().getAlpha() == 0) {
            getBackButton().setAlpha(0);
            ValueAnimator a = ObjectAnimator.ofFloat(getBackButton(), "alpha", 0, 1);
            a.setStartDelay(mStartDelay);
            a.setDuration(mDuration);
            a.setInterpolator(mInterpolator);
            a.start();
        }
    }
}
#method_after
public void onBackAltCleared() {
    // animation as home (if we catch this condition early enough).
    if (getBackButton() == null || getHomeButton() == null)
        return;
    if (!mBackTransitioning && getBackButton().getVisibility() == VISIBLE && mHomeAppearing && getHomeButton().getAlpha() == 0) {
        getBackButton().setAlpha(0);
        ValueAnimator a = ObjectAnimator.ofFloat(getBackButton(), "alpha", 0, 1);
        a.setStartDelay(mStartDelay);
        a.setDuration(mDuration);
        a.setInterpolator(mInterpolator);
        a.start();
    }
}
#end_block

#method_before
private KeyButtonView generateKey(boolean landscape, String clickAction, String longpress, String iconUri) {
    KeyButtonView v = new KeyButtonView(mContext, null);
    v.setClickAction(clickAction);
    v.setLongpressAction(longpress);
    int i = mContext.getResources().getDimensionPixelSize(R.dimen.navigation_key_width);
    v.setLayoutParams(getLayoutParams(landscape, i));
    if (clickAction.equals(ActionConstants.ACTION_BACK)) {
        v.setId(R.id.back);
    } else if (clickAction.equals(ActionConstants.ACTION_HOME)) {
        v.setId(R.id.home);
    } else if (clickAction.equals(ActionConstants.ACTION_RECENTS)) {
        v.setId(R.id.recent_apps);
    } else {
        int buttonId = v.generateViewId();
        v.setId(buttonId);
        mButtonIdList.add(buttonId);
    }
    if (clickAction.startsWith("**")) {
        v.setScaleType(KeyButtonView.ScaleType.CENTER_INSIDE);
    }
    boolean colorize = true;
    if (iconUri != null && !iconUri.equals(ActionConstants.ICON_EMPTY) && !iconUri.startsWith(ActionConstants.SYSTEM_ICON_IDENTIFIER) && mNavBarButtonColorMode == 1) {
        colorize = false;
    } else if (!clickAction.startsWith("**")) {
        final int[] appIconPadding = getAppIconPadding();
        if (landscape) {
            v.setPaddingRelative(appIconPadding[1], appIconPadding[0], appIconPadding[3], appIconPadding[2]);
        } else {
            v.setPaddingRelative(appIconPadding[0], appIconPadding[1], appIconPadding[2], appIconPadding[3]);
        }
        if (mNavBarButtonColorMode != 0) {
            colorize = false;
        }
        mAppIsBinded = true;
    }
    Drawable d = ActionHelper.getActionIconImage(mContext, clickAction, iconUri);
    if (d != null) {
        if (colorize && mNavBarButtonColorMode != 3) {
            d = ColorHelper.getColoredDrawable(d, mNavBarButtonColor);
        }
        v.setImageBitmap(ColorHelper.drawableToBitmap(d));
    }
    v.setRippleColor(mRippleColor);
    return v;
}
#method_after
private KeyButtonView generateKey(boolean landscape, String clickAction, String longpress, String iconUri) {
    KeyButtonView v = new KeyButtonView(mContext, null);
    v.setClickAction(clickAction);
    v.setLongpressAction(longpress);
    int i = mContext.getResources().getDimensionPixelSize(R.dimen.navigation_key_width);
    v.setLayoutParams(getLayoutParams(landscape, i));
    if (clickAction.equals(ActionConstants.ACTION_BACK)) {
        v.setId(R.id.back);
    } else if (clickAction.equals(ActionConstants.ACTION_HOME)) {
        v.setId(R.id.home);
    } else if (clickAction.equals(ActionConstants.ACTION_RECENTS)) {
        v.setId(R.id.recent_apps);
    } else {
        int buttonId = v.generateViewId();
        v.setId(buttonId);
        mButtonIdList.add(buttonId);
    }
    if (clickAction.startsWith("**")) {
        v.setScaleType(KeyButtonView.ScaleType.CENTER_INSIDE);
    }
    boolean colorize = true;
    if (iconUri != null && !iconUri.equals(ActionConstants.ICON_EMPTY) && !iconUri.startsWith(ActionConstants.SYSTEM_ICON_IDENTIFIER) && mNavBarButtonColorMode == 1) {
        colorize = false;
    } else if (!clickAction.startsWith("**")) {
        final int[] appIconPadding = getAppIconPadding();
        if (landscape) {
            v.setPaddingRelative(appIconPadding[1], appIconPadding[0], appIconPadding[3], appIconPadding[2]);
        } else {
            v.setPaddingRelative(appIconPadding[0], appIconPadding[1], appIconPadding[2], appIconPadding[3]);
        }
        if (mNavBarButtonColorMode != 0) {
            colorize = false;
        }
        mAppIsBinded = true;
    }
    Drawable d = ActionHelper.getActionIconImage(mContext, clickAction, iconUri);
    if (d != null) {
        if (colorize && mNavBarButtonColorMode != 3) {
            d = ImageHelper.getColoredDrawable(d, mNavBarButtonColor);
        }
        v.setImageBitmap(ImageHelper.drawableToBitmap(d));
    }
    v.setRippleColor(mRippleColor);
    return v;
}
#end_block

#method_before
private KeyButtonView generateMenuKey(boolean landscape, int keyId) {
    Drawable d = null;
    KeyButtonView v = new KeyButtonView(mContext, null);
    int width = mContext.getResources().getDimensionPixelSize(R.dimen.navigation_extra_key_width);
    v.setLayoutParams(getLayoutParams(landscape, width));
    v.setScaleType(KeyButtonView.ScaleType.CENTER_INSIDE);
    if (keyId == KEY_MENU_LEFT || keyId == KEY_MENU_RIGHT) {
        v.setClickAction(ActionConstants.ACTION_MENU);
        v.setLongpressAction(ActionConstants.ACTION_NULL);
        if (keyId == KEY_MENU_LEFT) {
            v.setId(R.id.menu_left);
        } else {
            v.setId(R.id.menu);
        }
        v.setVisibility(View.INVISIBLE);
        v.setContentDescription(getResources().getString(R.string.accessibility_menu));
        d = mContext.getResources().getDrawable(R.drawable.ic_sysbar_menu);
    } else if (keyId == KEY_IME_LEFT) {
        v.setClickAction(ActionConstants.ACTION_IME_NAVIGATION_LEFT);
        v.setLongpressAction(ActionConstants.ACTION_IME_NAVIGATION_UP);
        v.setId(R.id.ime_left);
        v.setVisibility(View.GONE);
        d = mContext.getResources().getDrawable(R.drawable.ic_sysbar_ime_left);
    } else if (keyId == KEY_IME_RIGHT) {
        v.setClickAction(ActionConstants.ACTION_IME_NAVIGATION_RIGHT);
        v.setLongpressAction(ActionConstants.ACTION_IME_NAVIGATION_DOWN);
        v.setId(R.id.ime_right);
        v.setVisibility(View.GONE);
        d = mContext.getResources().getDrawable(R.drawable.ic_sysbar_ime_right);
    } else if (keyId == KEY_IME_SWITCHER) {
        v.setClickAction(ActionConstants.ACTION_IME);
        v.setId(R.id.ime_switcher);
        v.setVisibility(View.GONE);
        d = mContext.getResources().getDrawable(R.drawable.ic_ime_switcher_default);
    }
    if (mNavBarButtonColorMode != 3) {
        if (d instanceof VectorDrawable) {
            d.setTint(mNavBarButtonColor);
        } else {
            d = ColorHelper.getColoredDrawable(d, mNavBarButtonColor);
        }
    }
    v.setImageBitmap(ColorHelper.drawableToBitmap(d));
    v.setRippleColor(mRippleColor);
    return v;
}
#method_after
private KeyButtonView generateMenuKey(boolean landscape, int keyId) {
    Drawable d = null;
    KeyButtonView v = new KeyButtonView(mContext, null);
    int width = mContext.getResources().getDimensionPixelSize(R.dimen.navigation_extra_key_width);
    v.setLayoutParams(getLayoutParams(landscape, width));
    v.setScaleType(KeyButtonView.ScaleType.CENTER_INSIDE);
    if (keyId == KEY_MENU_LEFT || keyId == KEY_MENU_RIGHT) {
        v.setClickAction(ActionConstants.ACTION_MENU);
        v.setLongpressAction(ActionConstants.ACTION_NULL);
        if (keyId == KEY_MENU_LEFT) {
            v.setId(R.id.menu_left);
        } else {
            v.setId(R.id.menu);
        }
        v.setVisibility(View.INVISIBLE);
        v.setContentDescription(getResources().getString(R.string.accessibility_menu));
        d = mContext.getResources().getDrawable(R.drawable.ic_sysbar_menu);
    } else if (keyId == KEY_IME_LEFT) {
        v.setClickAction(ActionConstants.ACTION_IME_NAVIGATION_LEFT);
        v.setLongpressAction(ActionConstants.ACTION_IME_NAVIGATION_UP);
        v.setId(R.id.ime_left);
        v.setVisibility(View.GONE);
        d = mContext.getResources().getDrawable(R.drawable.ic_sysbar_ime_left);
    } else if (keyId == KEY_IME_RIGHT) {
        v.setClickAction(ActionConstants.ACTION_IME_NAVIGATION_RIGHT);
        v.setLongpressAction(ActionConstants.ACTION_IME_NAVIGATION_DOWN);
        v.setId(R.id.ime_right);
        v.setVisibility(View.GONE);
        d = mContext.getResources().getDrawable(R.drawable.ic_sysbar_ime_right);
    } else if (keyId == KEY_IME_SWITCHER) {
        v.setClickAction(ActionConstants.ACTION_IME);
        v.setId(R.id.ime_switcher);
        v.setVisibility(View.GONE);
        d = mContext.getResources().getDrawable(R.drawable.ic_ime_switcher_default);
    }
    if (mNavBarButtonColorMode != 3) {
        if (d instanceof VectorDrawable) {
            d.setTint(mNavBarButtonColor);
        } else {
            d = ImageHelper.getColoredDrawable(d, mNavBarButtonColor);
        }
    }
    v.setImageBitmap(ImageHelper.drawableToBitmap(d));
    v.setRippleColor(mRippleColor);
    return v;
}
#end_block

#method_before
public void dispatchMediaKeyEvent(KeyEvent keyEvent) {
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.sendMediaButtonEvent(keyEvent, false);
}
#method_after
public void dispatchMediaKeyEvent(KeyEvent keyEvent) {
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
    helper.sendMediaButtonEvent(keyEvent, false);
}
#end_block

#method_before
public void handleKeyDown(KeyEvent event, int stream) {
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
#method_after
public void handleKeyDown(KeyEvent event, int stream) {
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(getContext()).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
#end_block

#method_before
public void handleKeyUp(KeyEvent event, int stream) {
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseMasterVolume) {
                adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
            } else {
                int flags = FLAG_PLAY_SOUND;
                adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            break;
    }
}
#method_after
public void handleKeyUp(KeyEvent event, int stream) {
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseMasterVolume) {
                adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
            } else {
                int flags = FLAG_PLAY_SOUND;
                adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            MediaSessionLegacyHelper.getHelper(getContext()).sendVolumeKeyEvent(event, false);
            break;
    }
}
#end_block

#method_before
public void adjustStreamVolume(int streamType, int direction, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, mContext.getOpPackageName());
        } else {
            service.adjustStreamVolume(streamType, direction, flags, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustStreamVolume", e);
    }
}
#method_after
public void adjustStreamVolume(int streamType, int direction, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, getContext().getOpPackageName());
        } else {
            service.adjustStreamVolume(streamType, direction, flags, getContext().getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustStreamVolume", e);
    }
}
#end_block

#method_before
public void adjustVolume(int direction, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, mContext.getOpPackageName());
        } else {
            MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
            helper.sendAdjustVolumeBy(USE_DEFAULT_STREAM_TYPE, direction, flags);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustVolume", e);
    }
}
#method_after
public void adjustVolume(int direction, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, getContext().getOpPackageName());
        } else {
            MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
            helper.sendAdjustVolumeBy(USE_DEFAULT_STREAM_TYPE, direction, flags);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustVolume", e);
    }
}
#end_block

#method_before
public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, mContext.getOpPackageName());
        } else {
            MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
            helper.sendAdjustVolumeBy(suggestedStreamType, direction, flags);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustSuggestedStreamVolume", e);
    }
}
#method_after
public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, getContext().getOpPackageName());
        } else {
            MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
            helper.sendAdjustVolumeBy(suggestedStreamType, direction, flags);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustSuggestedStreamVolume", e);
    }
}
#end_block

#method_before
public void adjustMasterVolume(int steps, int flags) {
    IAudioService service = getService();
    try {
        service.adjustMasterVolume(steps, flags, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustMasterVolume", e);
    }
}
#method_after
public void adjustMasterVolume(int steps, int flags) {
    IAudioService service = getService();
    try {
        service.adjustMasterVolume(steps, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustMasterVolume", e);
    }
}
#end_block

#method_before
public void setRingerMode(int ringerMode) {
    if (!isValidRingerMode(ringerMode)) {
        return;
    }
    IAudioService service = getService();
    try {
        service.setRingerModeExternal(ringerMode, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setRingerMode", e);
    }
}
#method_after
public void setRingerMode(int ringerMode) {
    if (!isValidRingerMode(ringerMode)) {
        return;
    }
    IAudioService service = getService();
    try {
        service.setRingerModeExternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setRingerMode", e);
    }
}
#end_block

#method_before
public void setStreamVolume(int streamType, int index, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.setMasterVolume(index, flags, mContext.getOpPackageName());
        } else {
            service.setStreamVolume(streamType, index, flags, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setStreamVolume", e);
    }
}
#method_after
public void setStreamVolume(int streamType, int index, int flags) {
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.setMasterVolume(index, flags, getContext().getOpPackageName());
        } else {
            service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setStreamVolume", e);
    }
}
#end_block

#method_before
public void setMasterVolume(int index, int flags) {
    IAudioService service = getService();
    try {
        service.setMasterVolume(index, flags, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMasterVolume", e);
    }
}
#method_after
public void setMasterVolume(int index, int flags) {
    IAudioService service = getService();
    try {
        service.setMasterVolume(index, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMasterVolume", e);
    }
}
#end_block

#method_before
public void setMasterMute(boolean state, int flags) {
    IAudioService service = getService();
    try {
        service.setMasterMute(state, flags, mContext.getOpPackageName(), mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMasterMute", e);
    }
}
#method_after
public void setMasterMute(boolean state, int flags) {
    IAudioService service = getService();
    try {
        service.setMasterMute(state, flags, getContext().getOpPackageName(), mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMasterMute", e);
    }
}
#end_block

#method_before
public boolean isBluetoothScoAvailableOffCall() {
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_sco_off_call);
}
#method_after
public boolean isBluetoothScoAvailableOffCall() {
    return getContext().getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_sco_off_call);
}
#end_block

#method_before
public void startBluetoothSco() {
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, mContext.getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in startBluetoothSco", e);
    }
}
#method_after
public void startBluetoothSco() {
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, getContext().getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in startBluetoothSco", e);
    }
}
#end_block

#method_before
public void setMicrophoneMute(boolean on) {
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
#method_after
public void setMicrophoneMute(boolean on) {
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
#end_block

#method_before
private boolean querySoundEffectsEnabled(int user) {
    return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
}
#method_after
private boolean querySoundEffectsEnabled(int user) {
    return Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
}
#end_block

#method_before
@SystemApi
public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags, AudioPolicy ap) throws IllegalArgumentException {
    // parameter checking
    if (requestAttributes == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes argument");
    }
    if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
        throw new IllegalArgumentException("Invalid duration hint");
    }
    if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {
        throw new IllegalArgumentException("Illegal flags 0x" + Integer.toHexString(flags).toUpperCase());
    }
    if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {
        throw new IllegalArgumentException("Illegal null focus listener when flagged as accepting delayed focus grant");
    }
    if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {
        throw new IllegalArgumentException("Illegal null audio policy when locking audio focus");
    }
    int status = AUDIOFOCUS_REQUEST_FAILED;
    registerAudioFocusListener(l);
    IAudioService service = getService();
    try {
        status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack, mAudioFocusDispatcher, getIdForAudioFocusListener(l), mContext.getOpPackageName(), /* package name */
        flags, ap != null ? ap.cb() : null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocus() on AudioService:", e);
    }
    return status;
}
#method_after
@SystemApi
public int requestAudioFocus(OnAudioFocusChangeListener l, @NonNull AudioAttributes requestAttributes, int durationHint, int flags, AudioPolicy ap) throws IllegalArgumentException {
    // parameter checking
    if (requestAttributes == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes argument");
    }
    if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
        throw new IllegalArgumentException("Invalid duration hint");
    }
    if (flags != (flags & AUDIOFOCUS_FLAGS_SYSTEM)) {
        throw new IllegalArgumentException("Illegal flags 0x" + Integer.toHexString(flags).toUpperCase());
    }
    if (((flags & AUDIOFOCUS_FLAG_DELAY_OK) == AUDIOFOCUS_FLAG_DELAY_OK) && (l == null)) {
        throw new IllegalArgumentException("Illegal null focus listener when flagged as accepting delayed focus grant");
    }
    if (((flags & AUDIOFOCUS_FLAG_LOCK) == AUDIOFOCUS_FLAG_LOCK) && (ap == null)) {
        throw new IllegalArgumentException("Illegal null audio policy when locking audio focus");
    }
    int status = AUDIOFOCUS_REQUEST_FAILED;
    registerAudioFocusListener(l);
    IAudioService service = getService();
    try {
        status = service.requestAudioFocus(requestAttributes, durationHint, mICallBack, mAudioFocusDispatcher, getIdForAudioFocusListener(l), getContext().getOpPackageName(), /* package name */
        flags, ap != null ? ap.cb() : null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocus() on AudioService:", e);
    }
    return status;
}
#end_block

#method_before
public void requestAudioFocusForCall(int streamType, int durationHint) {
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, mContext.getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
#method_after
public void requestAudioFocusForCall(int streamType, int durationHint) {
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, getContext().getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
#end_block

#method_before
// ====================================================================
// Remote Control
@Deprecated
public void registerMediaButtonEventReceiver(ComponentName eventReceiver) {
    if (eventReceiver == null) {
        return;
    }
    if (!eventReceiver.getPackageName().equals(mContext.getPackageName())) {
        Log.e(TAG, "registerMediaButtonEventReceiver() error: " + "receiver and context package names don't match");
        return;
    }
    // construct a PendingIntent for the media button and register it
    Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
    mediaButtonIntent.addFlags(mediaButtonIntent.FLAG_RECEIVER_FOREGROUND);
    // the associated intent will be handled by the component being registered
    mediaButtonIntent.setComponent(eventReceiver);
    PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, /*requestCode, ignored*/
    mediaButtonIntent, 0);
    registerMediaButtonIntent(pi, eventReceiver);
}
#method_after
// ====================================================================
// Remote Control
@Deprecated
public void registerMediaButtonEventReceiver(ComponentName eventReceiver) {
    if (eventReceiver == null) {
        return;
    }
    if (!eventReceiver.getPackageName().equals(getContext().getPackageName())) {
        Log.e(TAG, "registerMediaButtonEventReceiver() error: " + "receiver and context package names don't match");
        return;
    }
    // construct a PendingIntent for the media button and register it
    Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
    mediaButtonIntent.addFlags(mediaButtonIntent.FLAG_RECEIVER_FOREGROUND);
    // the associated intent will be handled by the component being registered
    mediaButtonIntent.setComponent(eventReceiver);
    PendingIntent pi = PendingIntent.getBroadcast(getContext(), 0, /*requestCode, ignored*/
    mediaButtonIntent, 0);
    registerMediaButtonIntent(pi, eventReceiver);
}
#end_block

#method_before
public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.addMediaButtonListener(pi, eventReceiver, mContext);
}
#method_after
public void registerMediaButtonIntent(PendingIntent pi, ComponentName eventReceiver) {
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
    helper.addMediaButtonListener(pi, eventReceiver, getContext());
}
#end_block

#method_before
@Deprecated
public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {
    if (eventReceiver == null) {
        return;
    }
    // construct a PendingIntent for the media button and unregister it
    Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
    // the associated intent will be handled by the component being registered
    mediaButtonIntent.setComponent(eventReceiver);
    PendingIntent pi = PendingIntent.getBroadcast(mContext, 0, /*requestCode, ignored*/
    mediaButtonIntent, 0);
    unregisterMediaButtonIntent(pi);
}
#method_after
@Deprecated
public void unregisterMediaButtonEventReceiver(ComponentName eventReceiver) {
    if (eventReceiver == null) {
        return;
    }
    // construct a PendingIntent for the media button and unregister it
    Intent mediaButtonIntent = new Intent(Intent.ACTION_MEDIA_BUTTON);
    // the associated intent will be handled by the component being registered
    mediaButtonIntent.setComponent(eventReceiver);
    PendingIntent pi = PendingIntent.getBroadcast(getContext(), 0, /*requestCode, ignored*/
    mediaButtonIntent, 0);
    unregisterMediaButtonIntent(pi);
}
#end_block

#method_before
public void unregisterMediaButtonIntent(PendingIntent pi) {
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.removeMediaButtonListener(pi);
}
#method_after
public void unregisterMediaButtonIntent(PendingIntent pi) {
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
    helper.removeMediaButtonListener(pi);
}
#end_block

#method_before
@Deprecated
public void registerRemoteControlClient(RemoteControlClient rcClient) {
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.registerWithSession(MediaSessionLegacyHelper.getHelper(mContext));
}
#method_after
@Deprecated
public void registerRemoteControlClient(RemoteControlClient rcClient) {
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.registerWithSession(MediaSessionLegacyHelper.getHelper(getContext()));
}
#end_block

#method_before
@Deprecated
public void unregisterRemoteControlClient(RemoteControlClient rcClient) {
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.unregisterWithSession(MediaSessionLegacyHelper.getHelper(mContext));
}
#method_after
@Deprecated
public void unregisterRemoteControlClient(RemoteControlClient rcClient) {
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.unregisterWithSession(MediaSessionLegacyHelper.getHelper(getContext()));
}
#end_block

#method_before
public void setRingerModeInternal(int ringerMode) {
    try {
        getService().setRingerModeInternal(ringerMode, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling setRingerModeInternal", e);
    }
}
#method_after
public void setRingerModeInternal(int ringerMode) {
    try {
        getService().setRingerModeInternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling setRingerModeInternal", e);
    }
}
#end_block

#method_before
private void setRingerModeInt(int ringerMode, boolean persist) {
    final boolean change;
    synchronized (mSettingsLock) {
        change = mRingerMode != ringerMode;
        mRingerMode = ringerMode;
    }
    // Mute stream if not previously muted by ringer mode and ringer mode
    // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
    // Unmute stream if previously muted by ringer mode and ringer mode
    // is RINGER_MODE_NORMAL or stream is not affected by ringer mode.
    int numStreamTypes = AudioSystem.getNumStreamTypes();
    final boolean ringerModeMute = ringerMode == AudioManager.RINGER_MODE_VIBRATE || ringerMode == AudioManager.RINGER_MODE_SILENT;
    for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
        final boolean isMuted = isStreamMutedByRingerMode(streamType);
        final boolean shouldMute = ringerModeMute && isStreamAffectedByRingerMode(streamType);
        if (isMuted == shouldMute)
            continue;
        if (!shouldMute) {
            // on voice capable devices or devices that support vibration
            if ((isPlatformVoice() || mHasVibrator) && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_RING) {
                synchronized (VolumeStreamState.class) {
                    Set set = mStreamStates[streamType].mIndex.entrySet();
                    Iterator i = set.iterator();
                    while (i.hasNext()) {
                        Map.Entry entry = (Map.Entry) i.next();
                        if ((Integer) entry.getValue() == 0) {
                            entry.setValue(10);
                        }
                    }
                }
                // Post a persist volume msg to save that changed volume
                int device = getDeviceForStream(streamType);
                sendMsg(mAudioHandler, MSG_PERSIST_VOLUME, SENDMSG_QUEUE, device, 0, mStreamStates[streamType], PERSIST_DELAY);
            }
            mStreamStates[streamType].mute(null, false);
            mRingerModeMutedStreams &= ~(1 << streamType);
        } else {
            // mute
            mStreamStates[streamType].mute(null, true);
            mRingerModeMutedStreams |= (1 << streamType);
        }
    }
    // Post a persist ringer mode msg
    if (persist) {
        sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE, SENDMSG_REPLACE, 0, 0, null, PERSIST_DELAY);
    }
    if (change) {
        // Send sticky broadcast
        broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, ringerMode);
    }
}
#method_after
private void setRingerModeInt(int ringerMode, boolean persist) {
    final boolean change;
    synchronized (mSettingsLock) {
        change = mRingerMode != ringerMode;
        mRingerMode = ringerMode;
    }
    // Mute stream if not previously muted by ringer mode and ringer mode
    // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
    // Unmute stream if previously muted by ringer mode and ringer mode
    // is RINGER_MODE_NORMAL or stream is not affected by ringer mode.
    int numStreamTypes = AudioSystem.getNumStreamTypes();
    final boolean ringerModeMute = ringerMode == AudioManager.RINGER_MODE_VIBRATE || ringerMode == AudioManager.RINGER_MODE_SILENT;
    for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
        final boolean isMuted = isStreamMutedByRingerMode(streamType);
        final boolean shouldMute = ringerModeMute && isStreamAffectedByRingerMode(streamType);
        if (isMuted == shouldMute)
            continue;
        if (!shouldMute) {
            // on voice capable devices or devices that support vibration
            if ((isPlatformVoice() || mHasVibrator) && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_RING) {
                synchronized (VolumeStreamState.class) {
                    Set set = mStreamStates[streamType].mIndex.entrySet();
                    Iterator i = set.iterator();
                    while (i.hasNext()) {
                        Map.Entry entry = (Map.Entry) i.next();
                        if ((Integer) entry.getValue() == 0) {
                            entry.setValue(10);
                        }
                    }
                    // Persist volume for stream when ringer mode changed
                    final int device = getDeviceForStream(streamType);
                    sendMsg(mAudioHandler, MSG_PERSIST_VOLUME, SENDMSG_QUEUE, device, 0, mStreamStates[streamType], PERSIST_DELAY);
                }
                // Post a persist volume msg to save that changed volume
                int device = getDeviceForStream(streamType);
                sendMsg(mAudioHandler, MSG_PERSIST_VOLUME, SENDMSG_QUEUE, device, 0, mStreamStates[streamType], PERSIST_DELAY);
            }
            mStreamStates[streamType].mute(null, false);
            mRingerModeMutedStreams &= ~(1 << streamType);
        } else {
            // mute
            mStreamStates[streamType].mute(null, true);
            mRingerModeMutedStreams |= (1 << streamType);
        }
    }
    // Post a persist ringer mode msg
    if (persist) {
        sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE, SENDMSG_REPLACE, 0, 0, null, PERSIST_DELAY);
    }
    if (change) {
        // Send sticky broadcast
        broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, ringerMode);
    }
}
#end_block

#method_before
private void setRingerModeInt(int ringerMode, boolean persist) {
    final boolean change;
    synchronized (mSettingsLock) {
        change = mRingerMode != ringerMode;
        mRingerMode = ringerMode;
    }
    // Mute stream if not previously muted by ringer mode and ringer mode
    // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
    // Unmute stream if previously muted by ringer mode and ringer mode
    // is RINGER_MODE_NORMAL or stream is not affected by ringer mode.
    int numStreamTypes = AudioSystem.getNumStreamTypes();
    final boolean ringerModeMute = ringerMode == AudioManager.RINGER_MODE_VIBRATE || ringerMode == AudioManager.RINGER_MODE_SILENT;
    for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
        final boolean isMuted = isStreamMutedByRingerMode(streamType);
        final boolean shouldMute = ringerModeMute && isStreamAffectedByRingerMode(streamType);
        if (isMuted == shouldMute)
            continue;
        if (!shouldMute) {
            // on voice capable devices or devices that support vibration
            if ((isPlatformVoice() || mHasVibrator) && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_RING) {
                synchronized (VolumeStreamState.class) {
                    Set set = mStreamStates[streamType].mIndex.entrySet();
                    Iterator i = set.iterator();
                    while (i.hasNext()) {
                        Map.Entry entry = (Map.Entry) i.next();
                        if ((Integer) entry.getValue() == 0) {
                            entry.setValue(10);
                        }
                    }
                }
            }
            mStreamStates[streamType].mute(null, false);
            mRingerModeMutedStreams &= ~(1 << streamType);
        } else {
            // mute
            mStreamStates[streamType].mute(null, true);
            mRingerModeMutedStreams |= (1 << streamType);
        }
    }
    // Post a persist ringer mode msg
    if (persist) {
        sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE, SENDMSG_REPLACE, 0, 0, null, PERSIST_DELAY);
    }
    if (change) {
        // Send sticky broadcast
        broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, ringerMode);
    }
}
#method_after
private void setRingerModeInt(int ringerMode, boolean persist) {
    final boolean change;
    synchronized (mSettingsLock) {
        change = mRingerMode != ringerMode;
        mRingerMode = ringerMode;
    }
    // Mute stream if not previously muted by ringer mode and ringer mode
    // is not RINGER_MODE_NORMAL and stream is affected by ringer mode.
    // Unmute stream if previously muted by ringer mode and ringer mode
    // is RINGER_MODE_NORMAL or stream is not affected by ringer mode.
    int numStreamTypes = AudioSystem.getNumStreamTypes();
    final boolean ringerModeMute = ringerMode == AudioManager.RINGER_MODE_VIBRATE || ringerMode == AudioManager.RINGER_MODE_SILENT;
    for (int streamType = numStreamTypes - 1; streamType >= 0; streamType--) {
        final boolean isMuted = isStreamMutedByRingerMode(streamType);
        final boolean shouldMute = ringerModeMute && isStreamAffectedByRingerMode(streamType);
        if (isMuted == shouldMute)
            continue;
        if (!shouldMute) {
            // on voice capable devices or devices that support vibration
            if ((isPlatformVoice() || mHasVibrator) && mStreamVolumeAlias[streamType] == AudioSystem.STREAM_RING) {
                synchronized (VolumeStreamState.class) {
                    Set set = mStreamStates[streamType].mIndex.entrySet();
                    Iterator i = set.iterator();
                    while (i.hasNext()) {
                        Map.Entry entry = (Map.Entry) i.next();
                        if ((Integer) entry.getValue() == 0) {
                            entry.setValue(10);
                        }
                    }
                    // Persist volume for stream when ringer mode changed
                    final int device = getDeviceForStream(streamType);
                    sendMsg(mAudioHandler, MSG_PERSIST_VOLUME, SENDMSG_QUEUE, device, 0, mStreamStates[streamType], PERSIST_DELAY);
                }
            }
            mStreamStates[streamType].mute(null, false);
            mRingerModeMutedStreams &= ~(1 << streamType);
        } else {
            // mute
            mStreamStates[streamType].mute(null, true);
            mRingerModeMutedStreams |= (1 << streamType);
        }
    }
    // Post a persist ringer mode msg
    if (persist) {
        sendMsg(mAudioHandler, MSG_PERSIST_RINGER_MODE, SENDMSG_REPLACE, 0, 0, null, PERSIST_DELAY);
    }
    if (change) {
        // Send sticky broadcast
        broadcastRingerMode(AudioManager.INTERNAL_RINGER_MODE_CHANGED_ACTION, ringerMode);
    }
}
#end_block

#method_before
private boolean setKeyguardOccludedLw(boolean isOccluded) {
    boolean wasOccluded = mKeyguardOccluded;
    boolean showing = mKeyguardDelegate.isShowing();
    if (wasOccluded && !isOccluded && showing) {
        mKeyguardOccluded = false;
        mKeyguardDelegate.setOccluded(false);
        mStatusBar.getAttrs().privateFlags |= PRIVATE_FLAG_KEYGUARD;
        mStatusBar.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        return true;
    } else if (!wasOccluded && isOccluded && showing) {
        mKeyguardOccluded = true;
        mKeyguardDelegate.setOccluded(true);
        mStatusBar.getAttrs().privateFlags &= ~PRIVATE_FLAG_KEYGUARD;
        mStatusBar.getAttrs().flags &= ~FLAG_SHOW_WALLPAPER;
        return true;
    } else {
        return false;
    }
}
#method_after
private boolean setKeyguardOccludedLw(boolean isOccluded) {
    boolean wasOccluded = mKeyguardOccluded;
    boolean showing = mKeyguardDelegate.isShowing();
    if (wasOccluded && !isOccluded && showing) {
        mKeyguardOccluded = false;
        mKeyguardDelegate.setOccluded(false);
        mStatusBar.getAttrs().privateFlags |= PRIVATE_FLAG_KEYGUARD;
        mStatusBar.getAttrs().flags |= FLAG_SHOW_WALLPAPER;
        return true;
    } else if (!wasOccluded && isOccluded && showing) {
        mKeyguardOccluded = true;
        mKeyguardDelegate.setOccluded(true);
        mStatusBar.getAttrs().privateFlags &= ~PRIVATE_FLAG_KEYGUARD;
        mStatusBar.getAttrs().flags &= ~FLAG_SHOW_WALLPAPER;
        return true;
    } else {
        if (wasOccluded && !isOccluded && !showing) {
            mKeyguardOccluded = false;
            mKeyguardDelegate.setOccluded(false);
        }
        return false;
    }
}
#end_block

#method_before
boolean updateOrientationFromAppTokensLocked(boolean inTransaction) {
    long ident = Binder.clearCallingIdentity();
    try {
        int req = getOrientationFromWindowsLocked();
        if (req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
            req = getOrientationFromAppTokensLocked();
        }
        if (req != mForcedAppOrientation) {
            mForcedAppOrientation = req;
            // send a message to Policy indicating orientation change to take
            // action like disabling/enabling sensors etc.,
            mPolicy.setCurrentOrientationLw(req);
            if (updateRotationUncheckedLocked(inTransaction)) {
                // changed
                return true;
            }
        }
        return false;
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
boolean updateOrientationFromAppTokensLocked(boolean inTransaction) {
    long ident = Binder.clearCallingIdentity();
    try {
        int req = getOrientationLocked();
        if (req != mForcedAppOrientation) {
            mForcedAppOrientation = req;
            // send a message to Policy indicating orientation change to take
            // action like disabling/enabling sensors etc.,
            mPolicy.setCurrentOrientationLw(req);
            if (updateRotationUncheckedLocked(inTransaction)) {
                // changed
                return true;
            }
        }
        return false;
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public void setAppVisibility(IBinder token, boolean visible) {
    if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS, "setAppVisibility()")) {
        throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
    }
    AppWindowToken wtoken;
    synchronized (mWindowMap) {
        wtoken = findAppWindowToken(token);
        if (wtoken == null) {
            Slog.w(TAG, "Attempted to set visibility of non-existing app token: " + token);
            return;
        }
        if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)
            Slog.v(TAG, "setAppVisibility(" + token + ", visible=" + visible + "): " + mAppTransition + " hidden=" + wtoken.hidden + " hiddenRequested=" + wtoken.hiddenRequested, HIDE_STACK_CRAWLS ? null : new RuntimeException("here").fillInStackTrace());
        mOpeningApps.remove(wtoken);
        mClosingApps.remove(wtoken);
        wtoken.waitingToShow = wtoken.waitingToHide = false;
        wtoken.hiddenRequested = !visible;
        // the visibility of this token until we execute that transition.
        if (okToDisplay() && mAppTransition.isTransitionSet()) {
            if (!wtoken.startingDisplayed) {
                if (DEBUG_APP_TRANSITIONS)
                    Slog.v(TAG, "Setting dummy animation on: " + wtoken);
                wtoken.mAppAnimator.setDummyAnimation();
            }
            wtoken.inPendingTransaction = true;
            if (visible) {
                mOpeningApps.add(wtoken);
                wtoken.startingMoved = false;
                wtoken.mEnteringAnimation = true;
                // its windows to be ready.
                if (wtoken.hidden) {
                    wtoken.allDrawn = false;
                    wtoken.deferClearAllDrawn = false;
                    wtoken.waitingToShow = true;
                    if (wtoken.clientHidden) {
                        // In the case where we are making an app visible
                        // but holding off for a transition, we still need
                        // to tell the client to make its windows visible so
                        // they get drawn.  Otherwise, we will wait on
                        // performing the transition until all windows have
                        // been drawn, they never will be, and we are sad.
                        wtoken.clientHidden = false;
                        wtoken.sendAppVisibilityToClients();
                    }
                }
            } else {
                mClosingApps.add(wtoken);
                wtoken.mEnteringAnimation = false;
                // common case), then set up to wait for it to be hidden.
                if (!wtoken.hidden) {
                    wtoken.waitingToHide = true;
                }
            }
            if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
                // We're launchingBehind, add the launching activity to mOpeningApps.
                final WindowState win = findFocusedWindowLocked(getDefaultDisplayContentLocked());
                if (win != null) {
                    final AppWindowToken focusedToken = win.mAppToken;
                    if (focusedToken != null) {
                        if (DEBUG_APP_TRANSITIONS)
                            Slog.d(TAG, "TRANSIT_TASK_OPEN_BEHIND, " + " adding " + focusedToken + " to mOpeningApps");
                        // Force animation to be loaded.
                        focusedToken.hidden = true;
                        mOpeningApps.add(focusedToken);
                    }
                }
            }
            return;
        }
        final long origId = Binder.clearCallingIdentity();
        setTokenVisibilityLocked(wtoken, null, visible, AppTransition.TRANSIT_UNSET, true, wtoken.voiceInteraction);
        wtoken.updateReportedVisibilityLocked();
        Binder.restoreCallingIdentity(origId);
    }
}
#method_after
@Override
public void setAppVisibility(IBinder token, boolean visible) {
    if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS, "setAppVisibility()")) {
        throw new SecurityException("Requires MANAGE_APP_TOKENS permission");
    }
    AppWindowToken wtoken;
    synchronized (mWindowMap) {
        wtoken = findAppWindowToken(token);
        if (wtoken == null) {
            Slog.w(TAG, "Attempted to set visibility of non-existing app token: " + token);
            return;
        }
        if (DEBUG_APP_TRANSITIONS || DEBUG_ORIENTATION)
            Slog.v(TAG, "setAppVisibility(" + token + ", visible=" + visible + "): " + mAppTransition + " hidden=" + wtoken.hidden + " hiddenRequested=" + wtoken.hiddenRequested, HIDE_STACK_CRAWLS ? null : new RuntimeException("here").fillInStackTrace());
        mOpeningApps.remove(wtoken);
        mClosingApps.remove(wtoken);
        wtoken.waitingToShow = wtoken.waitingToHide = false;
        wtoken.hiddenRequested = !visible;
        // the visibility of this token until we execute that transition.
        if (okToDisplay() && mAppTransition.isTransitionSet()) {
            if (!wtoken.startingDisplayed) {
                if (DEBUG_APP_TRANSITIONS)
                    Slog.v(TAG, "Setting dummy animation on: " + wtoken);
                wtoken.mAppAnimator.setDummyAnimation();
            }
            wtoken.inPendingTransaction = true;
            if (visible) {
                mOpeningApps.add(wtoken);
                wtoken.startingMoved = false;
                wtoken.mEnteringAnimation = true;
                // its windows to be ready.
                if (wtoken.hidden) {
                    wtoken.allDrawn = false;
                    wtoken.deferClearAllDrawn = false;
                    wtoken.waitingToShow = true;
                    if (wtoken.clientHidden) {
                        // In the case where we are making an app visible
                        // but holding off for a transition, we still need
                        // to tell the client to make its windows visible so
                        // they get drawn.  Otherwise, we will wait on
                        // performing the transition until all windows have
                        // been drawn, they never will be, and we are sad.
                        wtoken.clientHidden = false;
                        wtoken.sendAppVisibilityToClients();
                    }
                }
            } else {
                mClosingApps.add(wtoken);
                wtoken.mEnteringAnimation = false;
                // common case), then set up to wait for it to be hidden.
                if (!wtoken.hidden) {
                    wtoken.waitingToHide = true;
                }
            }
            if (mAppTransition.getAppTransition() == AppTransition.TRANSIT_TASK_OPEN_BEHIND) {
                // We're launchingBehind, add the launching activity to mOpeningApps.
                final WindowState win = findFocusedWindowLocked(getDefaultDisplayContentLocked());
                if (win != null) {
                    final AppWindowToken focusedToken = win.mAppToken;
                    if (focusedToken != null) {
                        if (DEBUG_APP_TRANSITIONS)
                            Slog.d(TAG, "TRANSIT_TASK_OPEN_BEHIND, " + " adding " + focusedToken + " to mOpeningApps");
                        // Force animation to be loaded.
                        focusedToken.hidden = true;
                        mOpeningApps.add(focusedToken);
                    }
                }
            }
            return;
        }
        final long origId = Binder.clearCallingIdentity();
        wtoken.inPendingTransaction = false;
        setTokenVisibilityLocked(wtoken, null, visible, AppTransition.TRANSIT_UNSET, true, wtoken.voiceInteraction);
        wtoken.updateReportedVisibilityLocked();
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
void unsetAppFreezingScreenLocked(AppWindowToken wtoken, boolean unfreezeSurfaceNow, boolean force) {
    if (wtoken.mAppAnimator.freezingScreen) {
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Clear freezing of " + wtoken + " force=" + force);
        final int N = wtoken.allAppWindows.size();
        boolean unfrozeWindows = false;
        for (int i = 0; i < N; i++) {
            WindowState w = wtoken.allAppWindows.get(i);
            if (w.mAppFreezing) {
                w.mAppFreezing = false;
                if (w.mHasSurface && !w.mOrientationChanging) {
                    if (DEBUG_ORIENTATION)
                        Slog.v(TAG, "set mOrientationChanging of " + w);
                    w.mOrientationChanging = true;
                    mInnerFields.mOrientationChangeComplete = false;
                }
                w.mLastFreezeDuration = 0;
                unfrozeWindows = true;
                final DisplayContent displayContent = w.getDisplayContent();
                if (displayContent != null) {
                    displayContent.layoutNeeded = true;
                }
            }
        }
        if (force || unfrozeWindows) {
            if (DEBUG_ORIENTATION)
                Slog.v(TAG, "No longer freezing: " + wtoken);
            wtoken.mAppAnimator.freezingScreen = false;
            wtoken.mAppAnimator.lastFreezeDuration = (int) (SystemClock.elapsedRealtime() - mDisplayFreezeTime);
            mAppsFreezingScreen--;
            mLastFinishedFreezeSource = wtoken;
        }
        if (unfreezeSurfaceNow) {
            if (unfrozeWindows) {
                performLayoutAndPlaceSurfacesLocked();
            }
            stopFreezingDisplayLocked();
        }
    }
}
#method_after
void unsetAppFreezingScreenLocked(AppWindowToken wtoken, boolean unfreezeSurfaceNow, boolean force) {
    if (wtoken.mAppAnimator.freezingScreen) {
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Clear freezing of " + wtoken + " force=" + force);
        final int N = wtoken.allAppWindows.size();
        boolean unfrozeWindows = false;
        for (int i = 0; i < N; i++) {
            WindowState w = wtoken.allAppWindows.get(i);
            if (w.mAppFreezing) {
                w.mAppFreezing = false;
                if (w.mHasSurface && !w.mOrientationChanging && mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_TIMEOUT) {
                    if (DEBUG_ORIENTATION)
                        Slog.v(TAG, "set mOrientationChanging of " + w);
                    w.mOrientationChanging = true;
                    mInnerFields.mOrientationChangeComplete = false;
                }
                w.mLastFreezeDuration = 0;
                unfrozeWindows = true;
                final DisplayContent displayContent = w.getDisplayContent();
                if (displayContent != null) {
                    displayContent.layoutNeeded = true;
                }
            }
        }
        if (force || unfrozeWindows) {
            if (DEBUG_ORIENTATION)
                Slog.v(TAG, "No longer freezing: " + wtoken);
            wtoken.mAppAnimator.freezingScreen = false;
            wtoken.mAppAnimator.lastFreezeDuration = (int) (SystemClock.elapsedRealtime() - mDisplayFreezeTime);
            mAppsFreezingScreen--;
            mLastFinishedFreezeSource = wtoken;
        }
        if (unfreezeSurfaceNow) {
            if (unfrozeWindows) {
                performLayoutAndPlaceSurfacesLocked();
            }
            stopFreezingDisplayLocked();
        }
    }
}
#end_block

#method_before
private void startAppFreezingScreenLocked(AppWindowToken wtoken) {
    if (DEBUG_ORIENTATION) {
        RuntimeException e = null;
        if (!HIDE_STACK_CRAWLS) {
            e = new RuntimeException();
            e.fillInStackTrace();
        }
        Slog.i(TAG, "Set freezing of " + wtoken.appToken + ": hidden=" + wtoken.hidden + " freezing=" + wtoken.mAppAnimator.freezingScreen, e);
    }
    if (!wtoken.hiddenRequested) {
        if (!wtoken.mAppAnimator.freezingScreen) {
            wtoken.mAppAnimator.freezingScreen = true;
            wtoken.mAppAnimator.lastFreezeDuration = 0;
            mAppsFreezingScreen++;
            if (mAppsFreezingScreen == 1) {
                startFreezingDisplayLocked(false, 0, 0);
                mH.removeMessages(H.APP_FREEZE_TIMEOUT);
                mH.sendEmptyMessageDelayed(H.APP_FREEZE_TIMEOUT, 5000);
            }
        }
        final int N = wtoken.allAppWindows.size();
        for (int i = 0; i < N; i++) {
            WindowState w = wtoken.allAppWindows.get(i);
            w.mAppFreezing = true;
        }
    }
}
#method_after
private void startAppFreezingScreenLocked(AppWindowToken wtoken) {
    if (DEBUG_ORIENTATION) {
        RuntimeException e = null;
        if (!HIDE_STACK_CRAWLS) {
            e = new RuntimeException();
            e.fillInStackTrace();
        }
        Slog.i(TAG, "Set freezing of " + wtoken.appToken + ": hidden=" + wtoken.hidden + " freezing=" + wtoken.mAppAnimator.freezingScreen, e);
    }
    if (!wtoken.hiddenRequested) {
        if (!wtoken.mAppAnimator.freezingScreen) {
            wtoken.mAppAnimator.freezingScreen = true;
            wtoken.mAppAnimator.lastFreezeDuration = 0;
            mAppsFreezingScreen++;
            if (mAppsFreezingScreen == 1) {
                startFreezingDisplayLocked(false, 0, 0);
                mH.removeMessages(H.APP_FREEZE_TIMEOUT);
                mH.sendEmptyMessageDelayed(H.APP_FREEZE_TIMEOUT, 2000);
            }
        }
        final int N = wtoken.allAppWindows.size();
        for (int i = 0; i < N; i++) {
            WindowState w = wtoken.allAppWindows.get(i);
            w.mAppFreezing = true;
        }
    }
}
#end_block

#method_before
@Override
public Bitmap screenshotApplications(IBinder appToken, int displayId, int width, int height, boolean force565) {
    if (!checkCallingPermission(Manifest.permission.READ_FRAME_BUFFER, "screenshotApplications()")) {
        throw new SecurityException("Requires READ_FRAME_BUFFER permission");
    }
    final DisplayContent displayContent = getDisplayContentLocked(displayId);
    if (displayContent == null) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. No Display for displayId=" + displayId);
        return null;
    }
    final DisplayInfo displayInfo = displayContent.getDisplayInfo();
    int dw = displayInfo.logicalWidth;
    int dh = displayInfo.logicalHeight;
    if (dw == 0 || dh == 0) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. logical widthxheight=" + dw + "x" + dh);
        return null;
    }
    Bitmap bm = null;
    int maxLayer = 0;
    final Rect frame = new Rect();
    final Rect stackBounds = new Rect();
    float scale = 0;
    int rot = Surface.ROTATION_0;
    boolean screenshotReady;
    int minLayer;
    if (appToken == null) {
        screenshotReady = true;
        minLayer = 0;
    } else {
        screenshotReady = false;
        minLayer = Integer.MAX_VALUE;
    }
    int retryCount = 0;
    WindowState appWin = null;
    final boolean appIsImTarget = mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
    final int aboveAppLayer = (mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (true) {
        if (retryCount++ > 0) {
            // Reset max/min layers on retries so we don't accidentally take a screenshot of a
            // layer based on the previous try.
            maxLayer = 0;
            minLayer = Integer.MAX_VALUE;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        synchronized (mWindowMap) {
            // Figure out the part of the screen that is actually the app.
            appWin = null;
            final WindowList windows = displayContent.getWindowList();
            for (int i = windows.size() - 1; i >= 0; i--) {
                WindowState ws = windows.get(i);
                if (!ws.mHasSurface) {
                    continue;
                }
                if (ws.mLayer >= aboveAppLayer) {
                    continue;
                }
                if (ws.mIsImWindow) {
                    if (!appIsImTarget) {
                        continue;
                    }
                } else if (ws.mIsWallpaper) {
                    if (appWin == null) {
                        // the layer of the target window.
                        continue;
                    }
                // Fall through. The target window is in front of the wallpaper. For this
                // case we want to include the wallpaper layer in the screenshot because
                // the target window might have some transparent areas.
                } else if (appToken != null) {
                    if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
                        // screenshot app.
                        continue;
                    }
                    appWin = ws;
                }
                // Include this window.
                final WindowStateAnimator winAnim = ws.mWinAnimator;
                if (maxLayer < winAnim.mSurfaceLayer) {
                    maxLayer = winAnim.mSurfaceLayer;
                }
                if (minLayer > winAnim.mSurfaceLayer) {
                    minLayer = winAnim.mSurfaceLayer;
                }
                // Don't include wallpaper in bounds calculation
                if (!ws.mIsWallpaper) {
                    final Rect wf = ws.mFrame;
                    final Rect cr = ws.mContentInsets;
                    int left = wf.left + cr.left;
                    int top = wf.top + cr.top;
                    int right = wf.right - cr.right;
                    int bottom = wf.bottom - cr.bottom;
                    frame.union(left, top, right, bottom);
                    ws.getStackBounds(stackBounds);
                    frame.intersect(stackBounds);
                }
                if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
                    screenshotReady = true;
                }
            }
            if (appToken != null && appWin == null) {
                // Can't find a window to snapshot.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: Couldn't find a surface matching " + appToken);
                return null;
            }
            if (!screenshotReady) {
                if (retryCount > MAX_SCREENSHOT_RETRIES) {
                    Slog.i(TAG, "Screenshot max retries " + retryCount + " of " + appToken + " appWin=" + (appWin == null ? "null" : (appWin + " drawState=" + appWin.mWinAnimator.mDrawState)));
                    return null;
                }
                // Delay and hope that window gets drawn.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: No image ready for " + appToken + ", " + appWin + " drawState=" + appWin.mWinAnimator.mDrawState);
                continue;
            }
            if (maxLayer == 0) {
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot of " + appToken + ": returning null maxLayer=" + maxLayer);
                return null;
            }
            // Constrain frame to the screen size.
            frame.intersect(0, 0, dw, dh);
            // use the whole frame if width and height are not constrained
            if (width == -1 && height == -1) {
                width = frame.width();
                height = frame.height();
            }
            // Tell surface flinger what part of the image to crop. Take the top
            // right part of the application, and crop the larger dimension to fit.
            Rect crop = new Rect(frame);
            if (width / (float) frame.width() < height / (float) frame.height()) {
                int cropWidth = (int) ((float) width / (float) height * frame.height());
                crop.right = crop.left + cropWidth;
            } else {
                int cropHeight = (int) ((float) height / (float) width * frame.width());
                crop.bottom = crop.top + cropHeight;
            }
            // The screenshot API does not apply the current screen rotation.
            rot = getDefaultDisplayContentLocked().getDisplay().getRotation();
            // Allow for abnormal hardware orientation
            rot = (rot + mSfHwRotation) % 4;
            if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
                rot = (rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
            }
            // Surfaceflinger is not aware of orientation, so convert our logical
            // crop to surfaceflinger's portrait orientation.
            convertCropForSurfaceFlinger(crop, rot, dw, dh);
            if (DEBUG_SCREENSHOT) {
                Slog.i(TAG, "Screenshot: " + dw + "x" + dh + " from " + minLayer + " to " + maxLayer + " appToken=" + appToken);
                for (int i = 0; i < windows.size(); i++) {
                    WindowState win = windows.get(i);
                    Slog.i(TAG, win + ": " + win.mLayer + " animLayer=" + win.mWinAnimator.mAnimLayer + " surfaceLayer=" + win.mWinAnimator.mSurfaceLayer);
                }
            }
            ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
            final boolean inRotation = screenRotationAnimation != null && screenRotationAnimation.isAnimating();
            if (DEBUG_SCREENSHOT && inRotation)
                Slog.v(TAG, "Taking screenshot while rotating");
            bm = SurfaceControl.screenshot(crop, width, height, minLayer, maxLayer, inRotation, rot);
            if (bm == null) {
                Slog.w(TAG, "Screenshot failure taking screenshot for (" + dw + "x" + dh + ") to layer " + maxLayer);
                return null;
            }
        }
        break;
    }
    if (DEBUG_SCREENSHOT) {
        // TEST IF IT's ALL BLACK
        int[] buffer = new int[bm.getWidth() * bm.getHeight()];
        bm.getPixels(buffer, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight());
        boolean allBlack = true;
        final int firstColor = buffer[0];
        for (int i = 0; i < buffer.length; i++) {
            if (buffer[i] != firstColor) {
                allBlack = false;
                break;
            }
        }
        if (allBlack) {
            Slog.i(TAG, "Screenshot " + appWin + " was monochrome(" + Integer.toHexString(firstColor) + ")! mSurfaceLayer=" + (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : "null") + " minLayer=" + minLayer + " maxLayer=" + maxLayer);
        }
    }
    // Copy the screenshot bitmap to another buffer so that the gralloc backed
    // bitmap will not have a long lifetime. Gralloc memory can be pinned or
    // duplicated and might have a higher cost than a skia backed buffer.
    Bitmap ret = bm.copy(bm.getConfig(), true);
    bm.recycle();
    return ret;
}
#method_after
@Override
public Bitmap screenshotApplications(IBinder appToken, int displayId, int width, int height, boolean force565) {
    if (!checkCallingPermission(Manifest.permission.READ_FRAME_BUFFER, "screenshotApplications()")) {
        throw new SecurityException("Requires READ_FRAME_BUFFER permission");
    }
    final DisplayContent displayContent = getDisplayContentLocked(displayId);
    if (displayContent == null) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. No Display for displayId=" + displayId);
        return null;
    }
    final DisplayInfo displayInfo = displayContent.getDisplayInfo();
    int dw = displayInfo.logicalWidth;
    int dh = displayInfo.logicalHeight;
    if (dw == 0 || dh == 0) {
        if (DEBUG_SCREENSHOT)
            Slog.i(TAG, "Screenshot of " + appToken + ": returning null. logical widthxheight=" + dw + "x" + dh);
        return null;
    }
    Bitmap bm = null;
    int maxLayer = 0;
    final Rect frame = new Rect();
    final Rect stackBounds = new Rect();
    float scale = 0;
    int rot = Surface.ROTATION_0;
    boolean screenshotReady;
    int minLayer;
    if (appToken == null) {
        screenshotReady = true;
        minLayer = 0;
    } else {
        screenshotReady = false;
        minLayer = Integer.MAX_VALUE;
    }
    int retryCount = 0;
    WindowState appWin = null;
    final boolean appIsImTarget = mInputMethodTarget != null && mInputMethodTarget.mAppToken != null && mInputMethodTarget.mAppToken.appToken != null && mInputMethodTarget.mAppToken.appToken.asBinder() == appToken;
    final int aboveAppLayer = (mPolicy.windowTypeToLayerLw(TYPE_APPLICATION) + 1) * TYPE_LAYER_MULTIPLIER + TYPE_LAYER_OFFSET;
    while (true) {
        if (retryCount++ > 0) {
            // Reset max/min layers on retries so we don't accidentally take a screenshot of a
            // layer based on the previous try.
            maxLayer = 0;
            minLayer = Integer.MAX_VALUE;
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
            }
        }
        synchronized (mWindowMap) {
            // Figure out the part of the screen that is actually the app.
            appWin = null;
            final WindowList windows = displayContent.getWindowList();
            for (int i = windows.size() - 1; i >= 0; i--) {
                WindowState ws = windows.get(i);
                if (!ws.mHasSurface) {
                    continue;
                }
                if (ws.mLayer >= aboveAppLayer) {
                    continue;
                }
                if (ws.mIsImWindow) {
                    if (!appIsImTarget) {
                        continue;
                    }
                } else if (ws.mIsWallpaper) {
                    if (appWin == null) {
                        // the layer of the target window.
                        continue;
                    }
                // Fall through. The target window is in front of the wallpaper. For this
                // case we want to include the wallpaper layer in the screenshot because
                // the target window might have some transparent areas.
                } else if (appToken != null) {
                    if (ws.mAppToken == null || ws.mAppToken.token != appToken) {
                        // screenshot app.
                        continue;
                    }
                    appWin = ws;
                }
                // Include this window.
                final WindowStateAnimator winAnim = ws.mWinAnimator;
                if (maxLayer < winAnim.mSurfaceLayer) {
                    maxLayer = winAnim.mSurfaceLayer;
                }
                if (minLayer > winAnim.mSurfaceLayer) {
                    minLayer = winAnim.mSurfaceLayer;
                }
                // Don't include wallpaper in bounds calculation
                if (!ws.mIsWallpaper) {
                    final Rect wf = ws.mFrame;
                    final Rect cr = ws.mContentInsets;
                    int left = wf.left + cr.left;
                    int top = wf.top + cr.top;
                    int right = wf.right - cr.right;
                    int bottom = wf.bottom - cr.bottom;
                    frame.union(left, top, right, bottom);
                    ws.getStackBounds(stackBounds);
                    frame.intersect(stackBounds);
                }
                if (ws.mAppToken != null && ws.mAppToken.token == appToken && ws.isDisplayedLw()) {
                    screenshotReady = true;
                }
                if (ws.isFullscreen(dw, dh) && ws.isOpaqueDrawn()) {
                    break;
                }
            }
            if (appToken != null && appWin == null) {
                // Can't find a window to snapshot.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: Couldn't find a surface matching " + appToken);
                return null;
            }
            if (!screenshotReady) {
                if (retryCount > MAX_SCREENSHOT_RETRIES) {
                    Slog.i(TAG, "Screenshot max retries " + retryCount + " of " + appToken + " appWin=" + (appWin == null ? "null" : (appWin + " drawState=" + appWin.mWinAnimator.mDrawState)));
                    return null;
                }
                // Delay and hope that window gets drawn.
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot: No image ready for " + appToken + ", " + appWin + " drawState=" + appWin.mWinAnimator.mDrawState);
                continue;
            }
            if (maxLayer == 0) {
                if (DEBUG_SCREENSHOT)
                    Slog.i(TAG, "Screenshot of " + appToken + ": returning null maxLayer=" + maxLayer);
                return null;
            }
            // Constrain frame to the screen size.
            frame.intersect(0, 0, dw, dh);
            // use the whole frame if width and height are not constrained
            if (width == -1 && height == -1) {
                width = frame.width();
                height = frame.height();
            }
            // Tell surface flinger what part of the image to crop. Take the top
            // right part of the application, and crop the larger dimension to fit.
            Rect crop = new Rect(frame);
            if (width / (float) frame.width() < height / (float) frame.height()) {
                int cropWidth = (int) ((float) width / (float) height * frame.height());
                crop.right = crop.left + cropWidth;
            } else {
                int cropHeight = (int) ((float) height / (float) width * frame.width());
                crop.bottom = crop.top + cropHeight;
            }
            // The screenshot API does not apply the current screen rotation.
            rot = getDefaultDisplayContentLocked().getDisplay().getRotation();
            // Allow for abnormal hardware orientation
            rot = (rot + mSfHwRotation) % 4;
            if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
                rot = (rot == Surface.ROTATION_90) ? Surface.ROTATION_270 : Surface.ROTATION_90;
            }
            // Surfaceflinger is not aware of orientation, so convert our logical
            // crop to surfaceflinger's portrait orientation.
            convertCropForSurfaceFlinger(crop, rot, dw, dh);
            if (DEBUG_SCREENSHOT) {
                Slog.i(TAG, "Screenshot: " + dw + "x" + dh + " from " + minLayer + " to " + maxLayer + " appToken=" + appToken);
                for (int i = 0; i < windows.size(); i++) {
                    WindowState win = windows.get(i);
                    Slog.i(TAG, win + ": " + win.mLayer + " animLayer=" + win.mWinAnimator.mAnimLayer + " surfaceLayer=" + win.mWinAnimator.mSurfaceLayer);
                }
            }
            ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
            final boolean inRotation = screenRotationAnimation != null && screenRotationAnimation.isAnimating();
            if (DEBUG_SCREENSHOT && inRotation)
                Slog.v(TAG, "Taking screenshot while rotating");
            bm = SurfaceControl.screenshot(crop, width, height, minLayer, maxLayer, inRotation, rot);
            if (bm == null) {
                Slog.w(TAG, "Screenshot failure taking screenshot for (" + dw + "x" + dh + ") to layer " + maxLayer);
                return null;
            }
        }
        break;
    }
    if (DEBUG_SCREENSHOT) {
        // TEST IF IT's ALL BLACK
        int[] buffer = new int[bm.getWidth() * bm.getHeight()];
        bm.getPixels(buffer, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight());
        boolean allBlack = true;
        final int firstColor = buffer[0];
        for (int i = 0; i < buffer.length; i++) {
            if (buffer[i] != firstColor) {
                allBlack = false;
                break;
            }
        }
        if (allBlack) {
            Slog.i(TAG, "Screenshot " + appWin + " was monochrome(" + Integer.toHexString(firstColor) + ")! mSurfaceLayer=" + (appWin != null ? appWin.mWinAnimator.mSurfaceLayer : "null") + " minLayer=" + minLayer + " maxLayer=" + maxLayer);
        }
    }
    // Copy the screenshot bitmap to another buffer so that the gralloc backed
    // bitmap will not have a long lifetime. Gralloc memory can be pinned or
    // duplicated and might have a higher cost than a skia backed buffer.
    Bitmap ret = bm.copy(bm.getConfig(), true);
    bm.recycle();
    return ret;
}
#end_block

#method_before
// TODO(multidisplay): Rotate any display?
public boolean updateRotationUncheckedLocked(boolean inTransaction) {
    if (mDeferredRotationPauseCount > 0) {
        // updates have been resumed.
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Deferring rotation, rotation is paused.");
        return false;
    }
    ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        // again after the animation is finished and the display is unfrozen.
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Deferring rotation, animation in progress.");
        return false;
    }
    if (!mDisplayEnabled) {
        // No point choosing a rotation if the display is not enabled.
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Deferring rotation, display is not enabled.");
        return false;
    }
    // TODO: Implement forced rotation changes.
    // Set mAltOrientation to indicate that the application is receiving
    // an orientation that has different metrics than it expected.
    // eg. Portrait instead of Landscape.
    int rotation = mPolicy.rotationForOrientationLw(mForcedAppOrientation, mRotation);
    boolean altOrientation = !mPolicy.rotationHasCompatibleMetricsLw(mForcedAppOrientation, rotation);
    if (DEBUG_ORIENTATION) {
        Slog.v(TAG, "Application requested orientation " + mForcedAppOrientation + ", got rotation " + rotation + " which has " + (altOrientation ? "incompatible" : "compatible") + " metrics");
    }
    if (mRotation == rotation && mAltOrientation == altOrientation) {
        // No change.
        return false;
    }
    if (DEBUG_ORIENTATION) {
        Slog.v(TAG, "Rotation changed to " + rotation + (altOrientation ? " (alt)" : "") + " from " + mRotation + (mAltOrientation ? " (alt)" : "") + ", forceApp=" + mForcedAppOrientation);
    }
    mRotation = rotation;
    mAltOrientation = altOrientation;
    mPolicy.setRotationLw(mRotation);
    mWindowsFreezingScreen = true;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendEmptyMessageDelayed(H.WINDOW_FREEZE_TIMEOUT, WINDOW_FREEZE_TIMEOUT_DURATION);
    mWaitingForConfig = true;
    final DisplayContent displayContent = getDefaultDisplayContentLocked();
    displayContent.layoutNeeded = true;
    final int[] anim = new int[2];
    if (displayContent.isDimming()) {
        anim[0] = anim[1] = 0;
    } else {
        mPolicy.selectRotationAnimationLw(anim);
    }
    startFreezingDisplayLocked(inTransaction, anim[0], anim[1]);
    // startFreezingDisplayLocked can reset the ScreenRotationAnimation.
    screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    // We need to update our screen size information to match the new
    // rotation.  Note that this is redundant with the later call to
    // sendNewConfiguration() that must be called after this function
    // returns...  however we need to do the screen size part of that
    // before then so we have the correct size to use when initializing
    // the rotation animation for the new rotation.
    computeScreenConfigurationLocked(null);
    final DisplayInfo displayInfo = displayContent.getDisplayInfo();
    if (!inTransaction) {
        if (SHOW_TRANSACTIONS) {
            Slog.i(TAG, ">>> OPEN TRANSACTION setRotationUnchecked");
        }
        SurfaceControl.openTransaction();
    }
    try {
        // it doesn't support hardware OpenGL emulation yet.
        if (CUSTOM_SCREEN_ROTATION && screenRotationAnimation != null && screenRotationAnimation.hasScreenshot()) {
            if (screenRotationAnimation.setRotationInTransaction(rotation, mFxSession, MAX_ANIMATION_DURATION, getTransitionAnimationScaleLocked(), displayInfo.logicalWidth, displayInfo.logicalHeight)) {
                scheduleAnimationLocked();
            }
        }
        mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
    } finally {
        if (!inTransaction) {
            SurfaceControl.closeTransaction();
            if (SHOW_LIGHT_TRANSACTIONS) {
                Slog.i(TAG, "<<< CLOSE TRANSACTION setRotationUnchecked");
            }
        }
    }
    final WindowList windows = displayContent.getWindowList();
    for (int i = windows.size() - 1; i >= 0; i--) {
        WindowState w = windows.get(i);
        if (w.mHasSurface) {
            if (DEBUG_ORIENTATION)
                Slog.v(TAG, "Set mOrientationChanging of " + w);
            w.mOrientationChanging = true;
            mInnerFields.mOrientationChangeComplete = false;
        }
        w.mLastFreezeDuration = 0;
    }
    for (int i = mRotationWatchers.size() - 1; i >= 0; i--) {
        try {
            mRotationWatchers.get(i).watcher.onRotationChanged(rotation);
        } catch (RemoteException e) {
        }
    }
    // windows in final state. Otherwise, we make this call at the rotation end.
    if (screenRotationAnimation == null && mAccessibilityController != null && displayContent.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onRotationChangedLocked(getDefaultDisplayContentLocked(), rotation);
    }
    return true;
}
#method_after
// TODO(multidisplay): Rotate any display?
public boolean updateRotationUncheckedLocked(boolean inTransaction) {
    if (mDeferredRotationPauseCount > 0) {
        // updates have been resumed.
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Deferring rotation, rotation is paused.");
        return false;
    }
    ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    if (screenRotationAnimation != null && screenRotationAnimation.isAnimating()) {
        // again after the animation is finished and the display is unfrozen.
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Deferring rotation, animation in progress.");
        return false;
    }
    if (!mDisplayEnabled) {
        // No point choosing a rotation if the display is not enabled.
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Deferring rotation, display is not enabled.");
        return false;
    }
    // TODO: Implement forced rotation changes.
    // Set mAltOrientation to indicate that the application is receiving
    // an orientation that has different metrics than it expected.
    // eg. Portrait instead of Landscape.
    int rotation = mPolicy.rotationForOrientationLw(mForcedAppOrientation, mRotation);
    boolean altOrientation = !mPolicy.rotationHasCompatibleMetricsLw(mForcedAppOrientation, rotation);
    if (DEBUG_ORIENTATION) {
        Slog.v(TAG, "Application requested orientation " + mForcedAppOrientation + ", got rotation " + rotation + " which has " + (altOrientation ? "incompatible" : "compatible") + " metrics");
    }
    if (mRotation == rotation && mAltOrientation == altOrientation) {
        // No change.
        return false;
    }
    if (DEBUG_ORIENTATION) {
        Slog.v(TAG, "Rotation changed to " + rotation + (altOrientation ? " (alt)" : "") + " from " + mRotation + (mAltOrientation ? " (alt)" : "") + ", forceApp=" + mForcedAppOrientation);
    }
    mRotation = rotation;
    mAltOrientation = altOrientation;
    mPolicy.setRotationLw(mRotation);
    mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_ACTIVE;
    mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
    mH.sendEmptyMessageDelayed(H.WINDOW_FREEZE_TIMEOUT, WINDOW_FREEZE_TIMEOUT_DURATION);
    mWaitingForConfig = true;
    final DisplayContent displayContent = getDefaultDisplayContentLocked();
    displayContent.layoutNeeded = true;
    final int[] anim = new int[2];
    if (displayContent.isDimming()) {
        anim[0] = anim[1] = 0;
    } else {
        mPolicy.selectRotationAnimationLw(anim);
    }
    startFreezingDisplayLocked(inTransaction, anim[0], anim[1]);
    // startFreezingDisplayLocked can reset the ScreenRotationAnimation.
    screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(Display.DEFAULT_DISPLAY);
    // We need to update our screen size information to match the new
    // rotation.  Note that this is redundant with the later call to
    // sendNewConfiguration() that must be called after this function
    // returns...  however we need to do the screen size part of that
    // before then so we have the correct size to use when initializing
    // the rotation animation for the new rotation.
    computeScreenConfigurationLocked(null);
    final DisplayInfo displayInfo = displayContent.getDisplayInfo();
    if (!inTransaction) {
        if (SHOW_TRANSACTIONS) {
            Slog.i(TAG, ">>> OPEN TRANSACTION setRotationUnchecked");
        }
        SurfaceControl.openTransaction();
    }
    try {
        // it doesn't support hardware OpenGL emulation yet.
        if (CUSTOM_SCREEN_ROTATION && screenRotationAnimation != null && screenRotationAnimation.hasScreenshot()) {
            if (screenRotationAnimation.setRotationInTransaction(rotation, mFxSession, MAX_ANIMATION_DURATION, getTransitionAnimationScaleLocked(), displayInfo.logicalWidth, displayInfo.logicalHeight)) {
                scheduleAnimationLocked();
            }
        }
        mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
    } finally {
        if (!inTransaction) {
            SurfaceControl.closeTransaction();
            if (SHOW_LIGHT_TRANSACTIONS) {
                Slog.i(TAG, "<<< CLOSE TRANSACTION setRotationUnchecked");
            }
        }
    }
    final WindowList windows = displayContent.getWindowList();
    for (int i = windows.size() - 1; i >= 0; i--) {
        WindowState w = windows.get(i);
        if (w.mHasSurface) {
            if (DEBUG_ORIENTATION)
                Slog.v(TAG, "Set mOrientationChanging of " + w);
            w.mOrientationChanging = true;
            mInnerFields.mOrientationChangeComplete = false;
        }
        w.mLastFreezeDuration = 0;
    }
    for (int i = mRotationWatchers.size() - 1; i >= 0; i--) {
        try {
            mRotationWatchers.get(i).watcher.onRotationChanged(rotation);
        } catch (RemoteException e) {
        }
    }
    // windows in final state. Otherwise, we make this call at the rotation end.
    if (screenRotationAnimation == null && mAccessibilityController != null && displayContent.getDisplayId() == Display.DEFAULT_DISPLAY) {
        mAccessibilityController.onRotationChangedLocked(getDefaultDisplayContentLocked(), rotation);
    }
    return true;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "handleMessage: entry what=" + msg.what);
    }
    switch(msg.what) {
        case REPORT_FOCUS_CHANGE:
            {
                WindowState lastFocus;
                WindowState newFocus;
                AccessibilityController accessibilityController = null;
                synchronized (mWindowMap) {
                    // TODO(multidisplay): Accessibility supported only of default desiplay.
                    if (mAccessibilityController != null && getDefaultDisplayContentLocked().getDisplayId() == Display.DEFAULT_DISPLAY) {
                        accessibilityController = mAccessibilityController;
                    }
                    lastFocus = mLastFocus;
                    newFocus = mCurrentFocus;
                    if (lastFocus == newFocus) {
                        // Focus is not changing, so nothing to do.
                        return;
                    }
                    mLastFocus = newFocus;
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Focus moving from " + lastFocus + " to " + newFocus);
                    if (newFocus != null && lastFocus != null && !newFocus.isDisplayedLw()) {
                        // Slog.i(TAG, "Delaying loss of focus...");
                        mLosingFocus.add(lastFocus);
                        lastFocus = null;
                    }
                }
                // the windows before the newly focused one starts firing eventgs.
                if (accessibilityController != null) {
                    accessibilityController.onWindowFocusChangedNotLocked();
                }
                // + " to " + newFocus);
                if (newFocus != null) {
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Gaining focus: " + newFocus);
                    newFocus.reportFocusChangedSerialized(true, mInTouchMode);
                    notifyFocusChanged();
                }
                if (lastFocus != null) {
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Losing focus: " + lastFocus);
                    lastFocus.reportFocusChangedSerialized(false, mInTouchMode);
                }
            }
            break;
        case REPORT_LOSING_FOCUS:
            {
                ArrayList<WindowState> losers;
                synchronized (mWindowMap) {
                    losers = mLosingFocus;
                    mLosingFocus = new ArrayList<WindowState>();
                }
                final int N = losers.size();
                for (int i = 0; i < N; i++) {
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Losing delayed focus: " + losers.get(i));
                    losers.get(i).reportFocusChangedSerialized(false, mInTouchMode);
                }
            }
            break;
        case DO_TRAVERSAL:
            {
                synchronized (mWindowMap) {
                    mTraversalScheduled = false;
                    performLayoutAndPlaceSurfacesLocked();
                }
            }
            break;
        case ADD_STARTING:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                final StartingData sd = wtoken.startingData;
                if (sd == null) {
                    // Animation has been canceled... do nothing.
                    return;
                }
                if (DEBUG_STARTING_WINDOW)
                    Slog.v(TAG, "Add starting " + wtoken + ": pkg=" + sd.pkg);
                View view = null;
                try {
                    view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme, sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo, sd.windowFlags);
                } catch (Exception e) {
                    Slog.w(TAG, "Exception when adding starting window", e);
                }
                if (view != null) {
                    boolean abort = false;
                    synchronized (mWindowMap) {
                        if (wtoken.removed || wtoken.startingData == null) {
                            // we need to remove it.
                            if (wtoken.startingWindow != null) {
                                if (DEBUG_STARTING_WINDOW)
                                    Slog.v(TAG, "Aborted starting " + wtoken + ": removed=" + wtoken.removed + " startingData=" + wtoken.startingData);
                                wtoken.startingWindow = null;
                                wtoken.startingData = null;
                                abort = true;
                            }
                        } else {
                            wtoken.startingView = view;
                        }
                        if (DEBUG_STARTING_WINDOW && !abort)
                            Slog.v(TAG, "Added starting " + wtoken + ": startingWindow=" + wtoken.startingWindow + " startingView=" + wtoken.startingView);
                    }
                    if (abort) {
                        try {
                            mPolicy.removeStartingWindow(wtoken.token, view);
                        } catch (Exception e) {
                            Slog.w(TAG, "Exception when removing starting window", e);
                        }
                    }
                }
            }
            break;
        case REMOVE_STARTING:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                IBinder token = null;
                View view = null;
                synchronized (mWindowMap) {
                    if (DEBUG_STARTING_WINDOW)
                        Slog.v(TAG, "Remove starting " + wtoken + ": startingWindow=" + wtoken.startingWindow + " startingView=" + wtoken.startingView);
                    if (wtoken.startingWindow != null) {
                        view = wtoken.startingView;
                        token = wtoken.token;
                        wtoken.startingData = null;
                        wtoken.startingView = null;
                        wtoken.startingWindow = null;
                        wtoken.startingDisplayed = false;
                    }
                }
                if (view != null) {
                    try {
                        mPolicy.removeStartingWindow(token, view);
                    } catch (Exception e) {
                        Slog.w(TAG, "Exception when removing starting window", e);
                    }
                }
            }
            break;
        case FINISHED_STARTING:
            {
                IBinder token = null;
                View view = null;
                while (true) {
                    synchronized (mWindowMap) {
                        final int N = mFinishedStarting.size();
                        if (N <= 0) {
                            break;
                        }
                        AppWindowToken wtoken = mFinishedStarting.remove(N - 1);
                        if (DEBUG_STARTING_WINDOW)
                            Slog.v(TAG, "Finished starting " + wtoken + ": startingWindow=" + wtoken.startingWindow + " startingView=" + wtoken.startingView);
                        if (wtoken.startingWindow == null) {
                            continue;
                        }
                        view = wtoken.startingView;
                        token = wtoken.token;
                        wtoken.startingData = null;
                        wtoken.startingView = null;
                        wtoken.startingWindow = null;
                        wtoken.startingDisplayed = false;
                    }
                    try {
                        mPolicy.removeStartingWindow(token, view);
                    } catch (Exception e) {
                        Slog.w(TAG, "Exception when removing starting window", e);
                    }
                }
            }
            break;
        case REPORT_APPLICATION_TOKEN_DRAWN:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                try {
                    if (DEBUG_VISIBILITY)
                        Slog.v(TAG, "Reporting drawn in " + wtoken);
                    wtoken.appToken.windowsDrawn();
                } catch (RemoteException ex) {
                }
            }
            break;
        case REPORT_APPLICATION_TOKEN_WINDOWS:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                boolean nowVisible = msg.arg1 != 0;
                boolean nowGone = msg.arg2 != 0;
                try {
                    if (DEBUG_VISIBILITY)
                        Slog.v(TAG, "Reporting visible in " + wtoken + " visible=" + nowVisible + " gone=" + nowGone);
                    if (nowVisible) {
                        wtoken.appToken.windowsVisible();
                    } else {
                        wtoken.appToken.windowsGone();
                    }
                } catch (RemoteException ex) {
                }
            }
            break;
        case WINDOW_FREEZE_TIMEOUT:
            {
                // TODO(multidisplay): Can non-default displays rotate?
                synchronized (mWindowMap) {
                    Slog.w(TAG, "Window freeze timeout expired.");
                    final WindowList windows = getDefaultWindowListLocked();
                    int i = windows.size();
                    while (i > 0) {
                        i--;
                        WindowState w = windows.get(i);
                        if (w.mOrientationChanging) {
                            w.mOrientationChanging = false;
                            w.mLastFreezeDuration = (int) (SystemClock.elapsedRealtime() - mDisplayFreezeTime);
                            Slog.w(TAG, "Force clearing orientation change: " + w);
                        }
                    }
                    performLayoutAndPlaceSurfacesLocked();
                }
                break;
            }
        case APP_TRANSITION_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    if (mAppTransition.isTransitionSet() || !mOpeningApps.isEmpty() || !mClosingApps.isEmpty()) {
                        if (DEBUG_APP_TRANSITIONS)
                            Slog.v(TAG, "*** APP TRANSITION TIMEOUT." + " isTransitionSet()=" + mAppTransition.isTransitionSet() + " mOpeningApps.size()=" + mOpeningApps.size() + " mClosingApps.size()=" + mClosingApps.size());
                        mAppTransition.setTimeout();
                        performLayoutAndPlaceSurfacesLocked();
                    }
                }
                break;
            }
        case PERSIST_ANIMATION_SCALE:
            {
                Settings.Global.putFloat(mContext.getContentResolver(), Settings.Global.WINDOW_ANIMATION_SCALE, mWindowAnimationScaleSetting);
                Settings.Global.putFloat(mContext.getContentResolver(), Settings.Global.TRANSITION_ANIMATION_SCALE, mTransitionAnimationScaleSetting);
                Settings.Global.putFloat(mContext.getContentResolver(), Settings.Global.ANIMATOR_DURATION_SCALE, mAnimatorDurationScaleSetting);
                break;
            }
        case FORCE_GC:
            {
                synchronized (mWindowMap) {
                    // hold mAnimator.mLayoutToAnim.
                    if (mAnimator.mAnimating || mAnimationScheduled) {
                        // If we are animating, don't do the gc now but
                        // delay a bit so we don't interrupt the animation.
                        sendEmptyMessageDelayed(H.FORCE_GC, 2000);
                        return;
                    }
                    // schedule a new message when done.
                    if (mDisplayFrozen) {
                        return;
                    }
                }
                Runtime.getRuntime().gc();
                break;
            }
        case ENABLE_SCREEN:
            {
                performEnableScreen();
                break;
            }
        case APP_FREEZE_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    Slog.w(TAG, "App freeze timeout expired.");
                    final int numStacks = mStackIdToStack.size();
                    for (int stackNdx = 0; stackNdx < numStacks; ++stackNdx) {
                        final TaskStack stack = mStackIdToStack.valueAt(stackNdx);
                        final ArrayList<Task> tasks = stack.getTasks();
                        for (int taskNdx = tasks.size() - 1; taskNdx >= 0; --taskNdx) {
                            AppTokenList tokens = tasks.get(taskNdx).mAppTokens;
                            for (int tokenNdx = tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
                                AppWindowToken tok = tokens.get(tokenNdx);
                                if (tok.mAppAnimator.freezingScreen) {
                                    Slog.w(TAG, "Force clearing freeze: " + tok);
                                    unsetAppFreezingScreenLocked(tok, true, true);
                                }
                            }
                        }
                    }
                }
                break;
            }
        case CLIENT_FREEZE_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    if (mClientFreezingScreen) {
                        mClientFreezingScreen = false;
                        mLastFinishedFreezeSource = "client-timeout";
                        stopFreezingDisplayLocked();
                    }
                }
                break;
            }
        case SEND_NEW_CONFIGURATION:
            {
                removeMessages(SEND_NEW_CONFIGURATION);
                sendNewConfiguration();
                break;
            }
        case REPORT_WINDOWS_CHANGE:
            {
                if (mWindowsChanged) {
                    synchronized (mWindowMap) {
                        mWindowsChanged = false;
                    }
                    notifyWindowsChanged();
                }
                break;
            }
        case DRAG_START_TIMEOUT:
            {
                IBinder win = (IBinder) msg.obj;
                if (DEBUG_DRAG) {
                    Slog.w(TAG, "Timeout starting drag by win " + win);
                }
                synchronized (mWindowMap) {
                    // !!! TODO: ANR the app that has failed to start the drag in time
                    if (mDragState != null) {
                        mDragState.unregister();
                        mInputMonitor.updateInputWindowsLw(true);
                        mDragState.reset();
                        mDragState = null;
                    }
                }
                break;
            }
        case DRAG_END_TIMEOUT:
            {
                IBinder win = (IBinder) msg.obj;
                if (DEBUG_DRAG) {
                    Slog.w(TAG, "Timeout ending drag to win " + win);
                }
                synchronized (mWindowMap) {
                    // !!! TODO: ANR the drag-receiving app
                    if (mDragState != null) {
                        mDragState.mDragResult = false;
                        mDragState.endDragLw();
                    }
                }
                break;
            }
        case REPORT_HARD_KEYBOARD_STATUS_CHANGE:
            {
                notifyHardKeyboardStatusChange();
                break;
            }
        case BOOT_TIMEOUT:
            {
                performBootTimeout();
                break;
            }
        case WAITING_FOR_DRAWN_TIMEOUT:
            {
                Runnable callback = null;
                synchronized (mWindowMap) {
                    Slog.w(TAG, "Timeout waiting for drawn: undrawn=" + mWaitingForDrawn);
                    mWaitingForDrawn.clear();
                    callback = mWaitingForDrawnCallback;
                    mWaitingForDrawnCallback = null;
                }
                if (callback != null) {
                    callback.run();
                }
                break;
            }
        case SHOW_STRICT_MODE_VIOLATION:
            {
                showStrictModeViolation(msg.arg1, msg.arg2);
                break;
            }
        case SHOW_CIRCULAR_DISPLAY_MASK:
            {
                showCircularMask(msg.arg1 == 1);
                break;
            }
        case SHOW_EMULATOR_DISPLAY_OVERLAY:
            {
                showEmulatorDisplayOverlay();
                break;
            }
        case DO_ANIMATION_CALLBACK:
            {
                try {
                    ((IRemoteCallback) msg.obj).sendResult(null);
                } catch (RemoteException e) {
                }
                break;
            }
        case DO_DISPLAY_ADDED:
            handleDisplayAdded(msg.arg1);
            break;
        case DO_DISPLAY_REMOVED:
            synchronized (mWindowMap) {
                handleDisplayRemovedLocked(msg.arg1);
            }
            break;
        case DO_DISPLAY_CHANGED:
            synchronized (mWindowMap) {
                handleDisplayChangedLocked(msg.arg1);
            }
            break;
        case TAP_OUTSIDE_STACK:
            {
            // int stackId;
            // synchronized (mWindowMap) {
            // stackId = ((DisplayContent)msg.obj).stackIdFromPoint(msg.arg1, msg.arg2);
            // }
            // if (stackId >= 0) {
            // try {
            // mActivityManager.setFocusedStack(stackId);
            // } catch (RemoteException e) {
            // }
            // }
            }
            break;
        case NOTIFY_ACTIVITY_DRAWN:
            try {
                mActivityManager.notifyActivityDrawn((IBinder) msg.obj);
            } catch (RemoteException e) {
            }
            break;
        case ALL_WINDOWS_DRAWN:
            {
                Runnable callback;
                synchronized (mWindowMap) {
                    callback = mWaitingForDrawnCallback;
                    mWaitingForDrawnCallback = null;
                }
                if (callback != null) {
                    callback.run();
                }
            }
        case NEW_ANIMATOR_SCALE:
            {
                float scale = getCurrentAnimatorScale();
                ValueAnimator.setDurationScale(scale);
                Session session = (Session) msg.obj;
                if (session != null) {
                    try {
                        session.mCallback.onAnimatorScaleChanged(scale);
                    } catch (RemoteException e) {
                    }
                } else {
                    ArrayList<IWindowSessionCallback> callbacks = new ArrayList<IWindowSessionCallback>();
                    synchronized (mWindowMap) {
                        for (int i = 0; i < mSessions.size(); i++) {
                            callbacks.add(mSessions.valueAt(i).mCallback);
                        }
                    }
                    for (int i = 0; i < callbacks.size(); i++) {
                        try {
                            callbacks.get(i).onAnimatorScaleChanged(scale);
                        } catch (RemoteException e) {
                        }
                    }
                }
            }
            break;
        case CHECK_IF_BOOT_ANIMATION_FINISHED:
            {
                final boolean bootAnimationComplete;
                synchronized (mWindowMap) {
                    if (DEBUG_BOOT)
                        Slog.i(TAG, "CHECK_IF_BOOT_ANIMATION_FINISHED:");
                    bootAnimationComplete = checkBootAnimationCompleteLocked();
                }
                if (bootAnimationComplete) {
                    performEnableScreen();
                }
            }
            break;
        case RESET_ANR_MESSAGE:
            {
                synchronized (mWindowMap) {
                    mLastANRState = null;
                }
            }
            break;
        case WALLPAPER_DRAW_PENDING_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    if (mWallpaperDrawState == WALLPAPER_DRAW_PENDING) {
                        mWallpaperDrawState = WALLPAPER_DRAW_TIMEOUT;
                        if (DEBUG_APP_TRANSITIONS || DEBUG_WALLPAPER)
                            Slog.v(TAG, "*** WALLPAPER DRAW TIMEOUT");
                        performLayoutAndPlaceSurfacesLocked();
                    }
                }
            }
            break;
    }
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "handleMessage: exit");
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "handleMessage: entry what=" + msg.what);
    }
    switch(msg.what) {
        case REPORT_FOCUS_CHANGE:
            {
                WindowState lastFocus;
                WindowState newFocus;
                AccessibilityController accessibilityController = null;
                synchronized (mWindowMap) {
                    // TODO(multidisplay): Accessibility supported only of default desiplay.
                    if (mAccessibilityController != null && getDefaultDisplayContentLocked().getDisplayId() == Display.DEFAULT_DISPLAY) {
                        accessibilityController = mAccessibilityController;
                    }
                    lastFocus = mLastFocus;
                    newFocus = mCurrentFocus;
                    if (lastFocus == newFocus) {
                        // Focus is not changing, so nothing to do.
                        return;
                    }
                    mLastFocus = newFocus;
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Focus moving from " + lastFocus + " to " + newFocus);
                    if (newFocus != null && lastFocus != null && !newFocus.isDisplayedLw()) {
                        // Slog.i(TAG, "Delaying loss of focus...");
                        mLosingFocus.add(lastFocus);
                        lastFocus = null;
                    }
                }
                // the windows before the newly focused one starts firing eventgs.
                if (accessibilityController != null) {
                    accessibilityController.onWindowFocusChangedNotLocked();
                }
                // + " to " + newFocus);
                if (newFocus != null) {
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Gaining focus: " + newFocus);
                    newFocus.reportFocusChangedSerialized(true, mInTouchMode);
                    notifyFocusChanged();
                }
                if (lastFocus != null) {
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Losing focus: " + lastFocus);
                    lastFocus.reportFocusChangedSerialized(false, mInTouchMode);
                }
            }
            break;
        case REPORT_LOSING_FOCUS:
            {
                ArrayList<WindowState> losers;
                synchronized (mWindowMap) {
                    losers = mLosingFocus;
                    mLosingFocus = new ArrayList<WindowState>();
                }
                final int N = losers.size();
                for (int i = 0; i < N; i++) {
                    if (DEBUG_FOCUS_LIGHT)
                        Slog.i(TAG, "Losing delayed focus: " + losers.get(i));
                    losers.get(i).reportFocusChangedSerialized(false, mInTouchMode);
                }
            }
            break;
        case DO_TRAVERSAL:
            {
                synchronized (mWindowMap) {
                    mTraversalScheduled = false;
                    performLayoutAndPlaceSurfacesLocked();
                }
            }
            break;
        case ADD_STARTING:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                final StartingData sd = wtoken.startingData;
                if (sd == null) {
                    // Animation has been canceled... do nothing.
                    return;
                }
                if (DEBUG_STARTING_WINDOW)
                    Slog.v(TAG, "Add starting " + wtoken + ": pkg=" + sd.pkg);
                View view = null;
                try {
                    view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme, sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo, sd.windowFlags);
                } catch (Exception e) {
                    Slog.w(TAG, "Exception when adding starting window", e);
                }
                if (view != null) {
                    boolean abort = false;
                    synchronized (mWindowMap) {
                        if (wtoken.removed || wtoken.startingData == null) {
                            // we need to remove it.
                            if (wtoken.startingWindow != null) {
                                if (DEBUG_STARTING_WINDOW)
                                    Slog.v(TAG, "Aborted starting " + wtoken + ": removed=" + wtoken.removed + " startingData=" + wtoken.startingData);
                                wtoken.startingWindow = null;
                                wtoken.startingData = null;
                                abort = true;
                            }
                        } else {
                            wtoken.startingView = view;
                        }
                        if (DEBUG_STARTING_WINDOW && !abort)
                            Slog.v(TAG, "Added starting " + wtoken + ": startingWindow=" + wtoken.startingWindow + " startingView=" + wtoken.startingView);
                    }
                    if (abort) {
                        try {
                            mPolicy.removeStartingWindow(wtoken.token, view);
                        } catch (Exception e) {
                            Slog.w(TAG, "Exception when removing starting window", e);
                        }
                    }
                }
            }
            break;
        case REMOVE_STARTING:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                IBinder token = null;
                View view = null;
                synchronized (mWindowMap) {
                    if (DEBUG_STARTING_WINDOW)
                        Slog.v(TAG, "Remove starting " + wtoken + ": startingWindow=" + wtoken.startingWindow + " startingView=" + wtoken.startingView);
                    if (wtoken.startingWindow != null) {
                        view = wtoken.startingView;
                        token = wtoken.token;
                        wtoken.startingData = null;
                        wtoken.startingView = null;
                        wtoken.startingWindow = null;
                        wtoken.startingDisplayed = false;
                    }
                }
                if (view != null) {
                    try {
                        mPolicy.removeStartingWindow(token, view);
                    } catch (Exception e) {
                        Slog.w(TAG, "Exception when removing starting window", e);
                    }
                }
            }
            break;
        case FINISHED_STARTING:
            {
                IBinder token = null;
                View view = null;
                while (true) {
                    synchronized (mWindowMap) {
                        final int N = mFinishedStarting.size();
                        if (N <= 0) {
                            break;
                        }
                        AppWindowToken wtoken = mFinishedStarting.remove(N - 1);
                        if (DEBUG_STARTING_WINDOW)
                            Slog.v(TAG, "Finished starting " + wtoken + ": startingWindow=" + wtoken.startingWindow + " startingView=" + wtoken.startingView);
                        if (wtoken.startingWindow == null) {
                            continue;
                        }
                        view = wtoken.startingView;
                        token = wtoken.token;
                        wtoken.startingData = null;
                        wtoken.startingView = null;
                        wtoken.startingWindow = null;
                        wtoken.startingDisplayed = false;
                    }
                    try {
                        mPolicy.removeStartingWindow(token, view);
                    } catch (Exception e) {
                        Slog.w(TAG, "Exception when removing starting window", e);
                    }
                }
            }
            break;
        case REPORT_APPLICATION_TOKEN_DRAWN:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                try {
                    if (DEBUG_VISIBILITY)
                        Slog.v(TAG, "Reporting drawn in " + wtoken);
                    wtoken.appToken.windowsDrawn();
                } catch (RemoteException ex) {
                }
            }
            break;
        case REPORT_APPLICATION_TOKEN_WINDOWS:
            {
                final AppWindowToken wtoken = (AppWindowToken) msg.obj;
                boolean nowVisible = msg.arg1 != 0;
                boolean nowGone = msg.arg2 != 0;
                try {
                    if (DEBUG_VISIBILITY)
                        Slog.v(TAG, "Reporting visible in " + wtoken + " visible=" + nowVisible + " gone=" + nowGone);
                    if (nowVisible) {
                        wtoken.appToken.windowsVisible();
                    } else {
                        wtoken.appToken.windowsGone();
                    }
                } catch (RemoteException ex) {
                }
            }
            break;
        case WINDOW_FREEZE_TIMEOUT:
            {
                // TODO(multidisplay): Can non-default displays rotate?
                synchronized (mWindowMap) {
                    Slog.w(TAG, "Window freeze timeout expired.");
                    mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_TIMEOUT;
                    final WindowList windows = getDefaultWindowListLocked();
                    int i = windows.size();
                    while (i > 0) {
                        i--;
                        WindowState w = windows.get(i);
                        if (w.mOrientationChanging) {
                            w.mOrientationChanging = false;
                            w.mLastFreezeDuration = (int) (SystemClock.elapsedRealtime() - mDisplayFreezeTime);
                            Slog.w(TAG, "Force clearing orientation change: " + w);
                        }
                    }
                    performLayoutAndPlaceSurfacesLocked();
                }
                break;
            }
        case APP_TRANSITION_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    if (mAppTransition.isTransitionSet() || !mOpeningApps.isEmpty() || !mClosingApps.isEmpty()) {
                        if (DEBUG_APP_TRANSITIONS)
                            Slog.v(TAG, "*** APP TRANSITION TIMEOUT." + " isTransitionSet()=" + mAppTransition.isTransitionSet() + " mOpeningApps.size()=" + mOpeningApps.size() + " mClosingApps.size()=" + mClosingApps.size());
                        mAppTransition.setTimeout();
                        performLayoutAndPlaceSurfacesLocked();
                    }
                }
                break;
            }
        case PERSIST_ANIMATION_SCALE:
            {
                Settings.Global.putFloat(mContext.getContentResolver(), Settings.Global.WINDOW_ANIMATION_SCALE, mWindowAnimationScaleSetting);
                Settings.Global.putFloat(mContext.getContentResolver(), Settings.Global.TRANSITION_ANIMATION_SCALE, mTransitionAnimationScaleSetting);
                Settings.Global.putFloat(mContext.getContentResolver(), Settings.Global.ANIMATOR_DURATION_SCALE, mAnimatorDurationScaleSetting);
                break;
            }
        case FORCE_GC:
            {
                synchronized (mWindowMap) {
                    // hold mAnimator.mLayoutToAnim.
                    if (mAnimator.mAnimating || mAnimationScheduled) {
                        // If we are animating, don't do the gc now but
                        // delay a bit so we don't interrupt the animation.
                        sendEmptyMessageDelayed(H.FORCE_GC, 2000);
                        return;
                    }
                    // schedule a new message when done.
                    if (mDisplayFrozen) {
                        return;
                    }
                }
                Runtime.getRuntime().gc();
                break;
            }
        case ENABLE_SCREEN:
            {
                performEnableScreen();
                break;
            }
        case APP_FREEZE_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    Slog.w(TAG, "App freeze timeout expired.");
                    mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_TIMEOUT;
                    final int numStacks = mStackIdToStack.size();
                    for (int stackNdx = 0; stackNdx < numStacks; ++stackNdx) {
                        final TaskStack stack = mStackIdToStack.valueAt(stackNdx);
                        final ArrayList<Task> tasks = stack.getTasks();
                        for (int taskNdx = tasks.size() - 1; taskNdx >= 0; --taskNdx) {
                            AppTokenList tokens = tasks.get(taskNdx).mAppTokens;
                            for (int tokenNdx = tokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
                                AppWindowToken tok = tokens.get(tokenNdx);
                                if (tok.mAppAnimator.freezingScreen) {
                                    Slog.w(TAG, "Force clearing freeze: " + tok);
                                    unsetAppFreezingScreenLocked(tok, true, true);
                                }
                            }
                        }
                    }
                }
                break;
            }
        case CLIENT_FREEZE_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    if (mClientFreezingScreen) {
                        mClientFreezingScreen = false;
                        mLastFinishedFreezeSource = "client-timeout";
                        stopFreezingDisplayLocked();
                    }
                }
                break;
            }
        case SEND_NEW_CONFIGURATION:
            {
                removeMessages(SEND_NEW_CONFIGURATION);
                sendNewConfiguration();
                break;
            }
        case REPORT_WINDOWS_CHANGE:
            {
                if (mWindowsChanged) {
                    synchronized (mWindowMap) {
                        mWindowsChanged = false;
                    }
                    notifyWindowsChanged();
                }
                break;
            }
        case DRAG_START_TIMEOUT:
            {
                IBinder win = (IBinder) msg.obj;
                if (DEBUG_DRAG) {
                    Slog.w(TAG, "Timeout starting drag by win " + win);
                }
                synchronized (mWindowMap) {
                    // !!! TODO: ANR the app that has failed to start the drag in time
                    if (mDragState != null) {
                        mDragState.unregister();
                        mInputMonitor.updateInputWindowsLw(true);
                        mDragState.reset();
                        mDragState = null;
                    }
                }
                break;
            }
        case DRAG_END_TIMEOUT:
            {
                IBinder win = (IBinder) msg.obj;
                if (DEBUG_DRAG) {
                    Slog.w(TAG, "Timeout ending drag to win " + win);
                }
                synchronized (mWindowMap) {
                    // !!! TODO: ANR the drag-receiving app
                    if (mDragState != null) {
                        mDragState.mDragResult = false;
                        mDragState.endDragLw();
                    }
                }
                break;
            }
        case REPORT_HARD_KEYBOARD_STATUS_CHANGE:
            {
                notifyHardKeyboardStatusChange();
                break;
            }
        case BOOT_TIMEOUT:
            {
                performBootTimeout();
                break;
            }
        case WAITING_FOR_DRAWN_TIMEOUT:
            {
                Runnable callback = null;
                synchronized (mWindowMap) {
                    Slog.w(TAG, "Timeout waiting for drawn: undrawn=" + mWaitingForDrawn);
                    mWaitingForDrawn.clear();
                    callback = mWaitingForDrawnCallback;
                    mWaitingForDrawnCallback = null;
                }
                if (callback != null) {
                    callback.run();
                }
                break;
            }
        case SHOW_STRICT_MODE_VIOLATION:
            {
                showStrictModeViolation(msg.arg1, msg.arg2);
                break;
            }
        case SHOW_CIRCULAR_DISPLAY_MASK:
            {
                showCircularMask(msg.arg1 == 1);
                break;
            }
        case SHOW_EMULATOR_DISPLAY_OVERLAY:
            {
                showEmulatorDisplayOverlay();
                break;
            }
        case DO_ANIMATION_CALLBACK:
            {
                try {
                    ((IRemoteCallback) msg.obj).sendResult(null);
                } catch (RemoteException e) {
                }
                break;
            }
        case DO_DISPLAY_ADDED:
            handleDisplayAdded(msg.arg1);
            break;
        case DO_DISPLAY_REMOVED:
            synchronized (mWindowMap) {
                handleDisplayRemovedLocked(msg.arg1);
            }
            break;
        case DO_DISPLAY_CHANGED:
            synchronized (mWindowMap) {
                handleDisplayChangedLocked(msg.arg1);
            }
            break;
        case TAP_OUTSIDE_STACK:
            {
            // int stackId;
            // synchronized (mWindowMap) {
            // stackId = ((DisplayContent)msg.obj).stackIdFromPoint(msg.arg1, msg.arg2);
            // }
            // if (stackId >= 0) {
            // try {
            // mActivityManager.setFocusedStack(stackId);
            // } catch (RemoteException e) {
            // }
            // }
            }
            break;
        case NOTIFY_ACTIVITY_DRAWN:
            try {
                mActivityManager.notifyActivityDrawn((IBinder) msg.obj);
            } catch (RemoteException e) {
            }
            break;
        case ALL_WINDOWS_DRAWN:
            {
                Runnable callback;
                synchronized (mWindowMap) {
                    callback = mWaitingForDrawnCallback;
                    mWaitingForDrawnCallback = null;
                }
                if (callback != null) {
                    callback.run();
                }
            }
        case NEW_ANIMATOR_SCALE:
            {
                float scale = getCurrentAnimatorScale();
                ValueAnimator.setDurationScale(scale);
                Session session = (Session) msg.obj;
                if (session != null) {
                    try {
                        session.mCallback.onAnimatorScaleChanged(scale);
                    } catch (RemoteException e) {
                    }
                } else {
                    ArrayList<IWindowSessionCallback> callbacks = new ArrayList<IWindowSessionCallback>();
                    synchronized (mWindowMap) {
                        for (int i = 0; i < mSessions.size(); i++) {
                            callbacks.add(mSessions.valueAt(i).mCallback);
                        }
                    }
                    for (int i = 0; i < callbacks.size(); i++) {
                        try {
                            callbacks.get(i).onAnimatorScaleChanged(scale);
                        } catch (RemoteException e) {
                        }
                    }
                }
            }
            break;
        case CHECK_IF_BOOT_ANIMATION_FINISHED:
            {
                final boolean bootAnimationComplete;
                synchronized (mWindowMap) {
                    if (DEBUG_BOOT)
                        Slog.i(TAG, "CHECK_IF_BOOT_ANIMATION_FINISHED:");
                    bootAnimationComplete = checkBootAnimationCompleteLocked();
                }
                if (bootAnimationComplete) {
                    performEnableScreen();
                }
            }
            break;
        case RESET_ANR_MESSAGE:
            {
                synchronized (mWindowMap) {
                    mLastANRState = null;
                }
            }
            break;
        case WALLPAPER_DRAW_PENDING_TIMEOUT:
            {
                synchronized (mWindowMap) {
                    if (mWallpaperDrawState == WALLPAPER_DRAW_PENDING) {
                        mWallpaperDrawState = WALLPAPER_DRAW_TIMEOUT;
                        if (DEBUG_APP_TRANSITIONS || DEBUG_WALLPAPER)
                            Slog.v(TAG, "*** WALLPAPER DRAW TIMEOUT");
                        performLayoutAndPlaceSurfacesLocked();
                    }
                }
            }
            break;
    }
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "handleMessage: exit");
    }
}
#end_block

#method_before
void makeWindowFreezingScreenIfNeededLocked(WindowState w) {
    // orientation.
    if (!okToDisplay()) {
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Changing surface while display frozen: " + w);
        w.mOrientationChanging = true;
        w.mLastFreezeDuration = 0;
        mInnerFields.mOrientationChangeComplete = false;
        if (!mWindowsFreezingScreen) {
            mWindowsFreezingScreen = true;
            // XXX should probably keep timeout from
            // when we first froze the display.
            mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
            mH.sendEmptyMessageDelayed(H.WINDOW_FREEZE_TIMEOUT, WINDOW_FREEZE_TIMEOUT_DURATION);
        }
    }
}
#method_after
void makeWindowFreezingScreenIfNeededLocked(WindowState w) {
    // orientation.
    if (!okToDisplay() && mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_TIMEOUT) {
        if (DEBUG_ORIENTATION)
            Slog.v(TAG, "Changing surface while display frozen: " + w);
        w.mOrientationChanging = true;
        w.mLastFreezeDuration = 0;
        mInnerFields.mOrientationChangeComplete = false;
        if (mWindowsFreezingScreen == WINDOWS_FREEZING_SCREENS_NONE) {
            mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_ACTIVE;
            // XXX should probably keep timeout from
            // when we first froze the display.
            mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
            mH.sendEmptyMessageDelayed(H.WINDOW_FREEZE_TIMEOUT, WINDOW_FREEZE_TIMEOUT_DURATION);
        }
    }
}
#end_block

#method_before
private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory) {
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by " + Debug.getCallers(3));
    }
    final long currentTime = SystemClock.uptimeMillis();
    int i;
    boolean updateInputWindowsNeeded = false;
    if (mFocusMayChange) {
        mFocusMayChange = false;
        updateInputWindowsNeeded = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false);
    }
    // Initialize state of exiting tokens.
    final int numDisplays = mDisplayContents.size();
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        for (i = displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
            displayContent.mExitingTokens.get(i).hasVisible = false;
        }
    }
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (int tokenNdx = exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
            exitingAppTokens.get(tokenNdx).hasVisible = false;
        }
    }
    mInnerFields.mHoldScreen = null;
    mInnerFields.mScreenBrightness = -1;
    mInnerFields.mButtonBrightness = -1;
    mInnerFields.mUserActivityTimeout = -1;
    mInnerFields.mObscureApplicationContentOnSecondaryDisplays = false;
    mTransactionSequence++;
    final DisplayContent defaultDisplay = getDefaultDisplayContentLocked();
    final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();
    final int defaultDw = defaultInfo.logicalWidth;
    final int defaultDh = defaultInfo.logicalHeight;
    if (SHOW_LIGHT_TRANSACTIONS)
        Slog.i(TAG, ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
    SurfaceControl.openTransaction();
    try {
        if (mWatermark != null) {
            mWatermark.positionSurface(defaultDw, defaultDh);
        }
        if (mStrictModeFlash != null) {
            mStrictModeFlash.positionSurface(defaultDw, defaultDh);
        }
        if (mCircularDisplayMask != null) {
            mCircularDisplayMask.positionSurface(defaultDw, defaultDh, mRotation);
        }
        if (mEmulatorDisplayOverlay != null) {
            mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh, mRotation);
        }
        boolean focusDisplayed = false;
        for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
            final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
            boolean updateAllDrawn = false;
            WindowList windows = displayContent.getWindowList();
            DisplayInfo displayInfo = displayContent.getDisplayInfo();
            final int displayId = displayContent.getDisplayId();
            final int dw = displayInfo.logicalWidth;
            final int dh = displayInfo.logicalHeight;
            final int innerDw = displayInfo.appWidth;
            final int innerDh = displayInfo.appHeight;
            final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);
            // Reset for each display.
            mInnerFields.mDisplayHasContent = false;
            mInnerFields.mPreferredRefreshRate = 0;
            int repeats = 0;
            do {
                repeats++;
                if (repeats > 6) {
                    Slog.w(TAG, "Animation repeat aborted after too many iterations");
                    displayContent.layoutNeeded = false;
                    break;
                }
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("On entry to LockedInner", displayContent.pendingLayoutChanges);
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && (adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
                    assignLayersLocked(windows);
                    displayContent.layoutNeeded = true;
                }
                if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Computing new config from layout");
                    if (updateOrientationFromAppTokensLocked(true)) {
                        displayContent.layoutNeeded = true;
                        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
                    }
                }
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
                    displayContent.layoutNeeded = true;
                }
                // FIRST LOOP: Perform a layout, if needed.
                if (repeats < 4) {
                    performLayoutLockedInner(displayContent, repeats == 1, false);
                } else {
                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
                }
                // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think
                // it is animating.
                displayContent.pendingLayoutChanges = 0;
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("loop number " + mLayoutRepeatCount, displayContent.pendingLayoutChanges);
                if (isDefaultDisplay) {
                    mPolicy.beginPostLayoutPolicyLw(dw, dh);
                    for (i = windows.size() - 1; i >= 0; i--) {
                        WindowState w = windows.get(i);
                        if (w.mHasSurface) {
                            mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs, w.mAttachedWindow);
                        }
                    }
                    displayContent.pendingLayoutChanges |= mPolicy.finishPostLayoutPolicyLw();
                    if (DEBUG_LAYOUT_REPEATS)
                        debugLayoutRepeats("after finishPostLayoutPolicyLw", displayContent.pendingLayoutChanges);
                }
            } while (displayContent.pendingLayoutChanges != 0);
            mInnerFields.mObscured = false;
            mInnerFields.mSyswin = false;
            displayContent.resetDimming();
            // Only used if default window
            final boolean someoneLosingFocus = !mLosingFocus.isEmpty();
            final int N = windows.size();
            for (i = N - 1; i >= 0; i--) {
                WindowState w = windows.get(i);
                final TaskStack stack = w.getStack();
                if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
                    continue;
                }
                final boolean obscuredChanged = w.mObscured != mInnerFields.mObscured;
                // Update effect.
                w.mObscured = mInnerFields.mObscured;
                if (!mInnerFields.mObscured) {
                    handleNotObscuredLocked(w, currentTime, innerDw, innerDh);
                }
                if (stack != null && !stack.testDimmingTag()) {
                    handleFlagDimBehind(w);
                }
                handlePrivateFlagFullyTransparent(w);
                if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w) && w.isVisibleLw()) {
                    // This is the wallpaper target and its obscured state
                    // changed... make sure the current wallaper's visibility
                    // has been updated accordingly.
                    updateWallpaperVisibilityLocked();
                }
                final WindowStateAnimator winAnimator = w.mWinAnimator;
                // it.
                if (w.mHasSurface && w.shouldAnimateMove()) {
                    // Frame has moved, containing content frame
                    // has also moved, and we're not currently animating...
                    // let's do something.
                    Animation a = AnimationUtils.loadAnimation(mContext, com.android.internal.R.anim.window_move_from_decor);
                    winAnimator.setAnimation(a);
                    winAnimator.mAnimDw = w.mLastFrame.left - w.mFrame.left;
                    winAnimator.mAnimDh = w.mLastFrame.top - w.mFrame.top;
                    // TODO (multidisplay): Accessibility supported only for the default display.
                    if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
                        mAccessibilityController.onSomeWindowResizedOrMovedLocked();
                    }
                    try {
                        w.mClient.moved(w.mFrame.left, w.mFrame.top);
                    } catch (RemoteException e) {
                    }
                }
                // Slog.i(TAG, "Window " + this + " clearing mContentChanged - done placing");
                w.mContentChanged = false;
                // Moved from updateWindowsAndWallpaperLocked().
                if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
                    // Take care of the window being ready to display.
                    final boolean committed = winAnimator.commitFinishDrawingLocked(currentTime);
                    if (isDefaultDisplay && committed) {
                        if (w.mAttrs.type == TYPE_DREAM) {
                            // HACK: When a dream is shown, it may at that
                            // point hide the lock screen.  So we need to
                            // redo the layout to let the phone window manager
                            // make this happen.
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("dream and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                        if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                            if (DEBUG_WALLPAPER_LIGHT)
                                Slog.v(TAG, "First draw done in potential wallpaper target " + w);
                            mInnerFields.mWallpaperMayChange = true;
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("wallpaper and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                    }
                    winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
                    final AppWindowToken atoken = w.mAppToken;
                    if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
                        Slog.d(TAG, "updateWindows: starting " + w + " isOnScreen=" + w.isOnScreen() + " allDrawn=" + atoken.allDrawn + " freezingScreen=" + atoken.mAppAnimator.freezingScreen);
                    }
                    if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
                        if (atoken.lastTransactionSequence != mTransactionSequence) {
                            atoken.lastTransactionSequence = mTransactionSequence;
                            atoken.numInterestingWindows = atoken.numDrawnWindows = 0;
                            atoken.startingDisplayed = false;
                        }
                        if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
                            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                                Slog.v(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw() + ", isAnimating=" + winAnimator.isAnimating());
                                if (!w.isDrawnLw()) {
                                    Slog.v(TAG, "Not displayed: s=" + winAnimator.mSurfaceControl + " pv=" + w.mPolicyVisibility + " mDrawState=" + winAnimator.drawStateToString() + " ah=" + w.mAttachedHidden + " th=" + atoken.hiddenRequested + " a=" + winAnimator.mAnimating);
                                }
                            }
                            if (w != atoken.startingWindow) {
                                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                                    atoken.numInterestingWindows++;
                                    if (w.isDrawnLw()) {
                                        atoken.numDrawnWindows++;
                                        if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)
                                            Slog.v(TAG, "tokenMayBeDrawn: " + atoken + " freezingScreen=" + atoken.mAppAnimator.freezingScreen + " mAppFreezing=" + w.mAppFreezing);
                                        updateAllDrawn = true;
                                    }
                                }
                            } else if (w.isDrawnLw()) {
                                atoken.startingDisplayed = true;
                            }
                        }
                    }
                }
                if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus) && w.isDisplayedLw()) {
                    focusDisplayed = true;
                }
                updateResizingWindows(w);
            }
            mDisplayManagerInternal.setDisplayProperties(displayId, mInnerFields.mDisplayHasContent, mInnerFields.mPreferredRefreshRate, true);
            getDisplayContentLocked(displayId).stopDimmingIfNeeded();
            if (updateAllDrawn) {
                updateAllDrawnLocked(displayContent);
            }
        }
        if (focusDisplayed) {
            mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
        }
        // Give the display manager a chance to adjust properties
        // like display rotation if it needs to.
        mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
    } catch (RuntimeException e) {
        Slog.wtf(TAG, "Unhandled exception in Window Manager", e);
    } finally {
        SurfaceControl.closeTransaction();
        if (SHOW_LIGHT_TRANSACTIONS)
            Slog.i(TAG, "<<< CLOSE TRANSACTION performLayoutAndPlaceSurfaces");
    }
    final WindowList defaultWindows = defaultDisplay.getWindowList();
    // to go.
    if (mAppTransition.isReady()) {
        defaultDisplay.pendingLayoutChanges |= handleAppTransitionReadyLocked(defaultWindows);
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAppTransitionReadyLocked", defaultDisplay.pendingLayoutChanges);
    }
    if (!mAnimator.mAnimating && mAppTransition.isRunning()) {
        // We have finished the animation of an app transition.  To do
        // this, we have delayed a lot of operations like showing and
        // hiding apps, moving apps in Z-order, etc.  The app token list
        // reflects the correct Z-order, but the window list may now
        // be out of sync with it.  So here we will just rebuild the
        // entire app window list.  Fun!
        defaultDisplay.pendingLayoutChanges |= handleAnimatingStoppedAndTransitionLocked();
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAnimStopAndXitionLock", defaultDisplay.pendingLayoutChanges);
    }
    if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
        // At this point, there was a window with a wallpaper that
        // was force hiding other windows behind it, but now it
        // is going away.  This may be simple -- just animate
        // away the wallpaper and its window -- or it may be
        // hard -- the wallpaper now needs to be shown behind
        // something that was hidden.
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after animateAwayWallpaperLocked", defaultDisplay.pendingLayoutChanges);
    }
    mInnerFields.mWallpaperForceHidingChanged = false;
    if (mInnerFields.mWallpaperMayChange) {
        if (DEBUG_WALLPAPER_LIGHT)
            Slog.v(TAG, "Wallpaper may change!  Adjusting");
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("WallpaperMayChange", defaultDisplay.pendingLayoutChanges);
    }
    if (mFocusMayChange) {
        mFocusMayChange = false;
        if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, false)) {
            updateInputWindowsNeeded = true;
            defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
        }
    }
    if (needsLayout()) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("mLayoutNeeded", defaultDisplay.pendingLayoutChanges);
    }
    for (i = mResizingWindows.size() - 1; i >= 0; i--) {
        WindowState win = mResizingWindows.get(i);
        if (win.mAppFreezing) {
            // Don't remove this window until rotation has completed.
            continue;
        }
        win.reportResized();
        mResizingWindows.remove(i);
    }
    if (DEBUG_ORIENTATION && mDisplayFrozen)
        Slog.v(TAG, "With display frozen, orientationChangeComplete=" + mInnerFields.mOrientationChangeComplete);
    if (mInnerFields.mOrientationChangeComplete) {
        if (mWindowsFreezingScreen) {
            mWindowsFreezingScreen = false;
            mLastFinishedFreezeSource = mInnerFields.mLastWindowFreezeSource;
            mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        }
        stopFreezingDisplayLocked();
    }
    // Destroy the surface of any windows that are no longer visible.
    boolean wallpaperDestroyed = false;
    i = mDestroySurface.size();
    if (i > 0) {
        do {
            i--;
            WindowState win = mDestroySurface.get(i);
            win.mDestroying = false;
            if (mInputMethodWindow == win) {
                mInputMethodWindow = null;
            }
            if (win == mWallpaperTarget) {
                wallpaperDestroyed = true;
            }
            win.mWinAnimator.destroySurfaceLocked();
        } while (i > 0);
        mDestroySurface.clear();
    }
    // Time to remove any exiting tokens?
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        ArrayList<WindowToken> exitingTokens = displayContent.mExitingTokens;
        for (i = exitingTokens.size() - 1; i >= 0; i--) {
            WindowToken token = exitingTokens.get(i);
            if (!token.hasVisible) {
                exitingTokens.remove(i);
                if (token.windowType == TYPE_WALLPAPER) {
                    mWallpaperTokens.remove(token);
                }
            }
        }
    }
    // Time to remove any exiting applications?
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (i = exitingAppTokens.size() - 1; i >= 0; i--) {
            AppWindowToken token = exitingAppTokens.get(i);
            if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mDeferRemoval || token.allAppWindows.isEmpty())) {
                // Make sure there is no animation running on this token,
                // so any windows associated with it will be removed as
                // soon as their animations are complete
                token.mAppAnimator.clearAnimation();
                token.mAppAnimator.animating = false;
                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)
                    Slog.v(TAG, "performLayout: App token exiting now removed" + token);
                removeAppFromTaskLocked(token);
                exitingAppTokens.remove(i);
                final Task task = mTaskIdToTask.get(token.groupId);
                if (task != null && task.mDeferRemoval && task.mAppTokens.isEmpty()) {
                    removeTaskLocked(task);
                }
            }
        }
    }
    if (!mAnimator.mAnimating && mRelayoutWhileAnimating.size() > 0) {
        for (int j = mRelayoutWhileAnimating.size() - 1; j >= 0; j--) {
            try {
                mRelayoutWhileAnimating.get(j).mClient.doneAnimating();
            } catch (RemoteException e) {
            }
        }
        mRelayoutWhileAnimating.clear();
    }
    if (wallpaperDestroyed) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        defaultDisplay.layoutNeeded = true;
    }
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        if (displayContent.pendingLayoutChanges != 0) {
            displayContent.layoutNeeded = true;
        }
    }
    // Finally update all input windows now that the window changes have stabilized.
    mInputMonitor.updateInputWindowsLw(true);
    setHoldScreenLocked(mInnerFields.mHoldScreen);
    if (!mDisplayFrozen) {
        if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
        }
        if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
        }
        mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
    }
    if (mTurnOnScreen) {
        if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 0) {
            if (DEBUG_VISIBILITY)
                Slog.v(TAG, "Turning screen on after layout!");
            mPowerManager.wakeUp(SystemClock.uptimeMillis());
        }
        mTurnOnScreen = false;
    }
    if (mInnerFields.mUpdateRotation) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "Performing post-rotate rotation");
        if (updateRotationUncheckedLocked(false)) {
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
        } else {
            mInnerFields.mUpdateRotation = false;
        }
    }
    if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
        checkDrawnWindowsLocked();
    }
    final int N = mPendingRemove.size();
    if (N > 0) {
        if (mPendingRemoveTmp.length < N) {
            mPendingRemoveTmp = new WindowState[N + 10];
        }
        mPendingRemove.toArray(mPendingRemoveTmp);
        mPendingRemove.clear();
        DisplayContentList displayList = new DisplayContentList();
        for (i = 0; i < N; i++) {
            WindowState w = mPendingRemoveTmp[i];
            removeWindowInnerLocked(w.mSession, w);
            final DisplayContent displayContent = w.getDisplayContent();
            if (displayContent != null && !displayList.contains(displayContent)) {
                displayList.add(displayContent);
            }
        }
        for (DisplayContent displayContent : displayList) {
            assignLayersLocked(displayContent.getWindowList());
            displayContent.layoutNeeded = true;
        }
    }
    // Remove all deferred displays stacks, tasks, and activities.
    for (int displayNdx = mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
        mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
    }
    if (updateInputWindowsNeeded) {
        mInputMonitor.updateInputWindowsLw(false);
    }
    setFocusedStackFrame();
    // Check to see if we are now in a state where the screen should
    // be enabled, because the window obscured flags have changed.
    enableScreenIfNeededLocked();
    scheduleAnimationLocked();
    if (DEBUG_WINDOW_TRACE) {
        Slog.e(TAG, "performLayoutAndPlaceSurfacesLockedInner exit: animating=" + mAnimator.mAnimating);
    }
}
#method_after
private final void performLayoutAndPlaceSurfacesLockedInner(boolean recoveringMemory) {
    if (DEBUG_WINDOW_TRACE) {
        Slog.v(TAG, "performLayoutAndPlaceSurfacesLockedInner: entry. Called by " + Debug.getCallers(3));
    }
    final long currentTime = SystemClock.uptimeMillis();
    int i;
    boolean updateInputWindowsNeeded = false;
    if (mFocusMayChange) {
        mFocusMayChange = false;
        updateInputWindowsNeeded = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false);
    }
    // Initialize state of exiting tokens.
    final int numDisplays = mDisplayContents.size();
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        for (i = displayContent.mExitingTokens.size() - 1; i >= 0; i--) {
            displayContent.mExitingTokens.get(i).hasVisible = false;
        }
    }
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (int tokenNdx = exitingAppTokens.size() - 1; tokenNdx >= 0; --tokenNdx) {
            exitingAppTokens.get(tokenNdx).hasVisible = false;
        }
    }
    mInnerFields.mHoldScreen = null;
    mInnerFields.mScreenBrightness = -1;
    mInnerFields.mButtonBrightness = -1;
    mInnerFields.mUserActivityTimeout = -1;
    mInnerFields.mObscureApplicationContentOnSecondaryDisplays = false;
    mTransactionSequence++;
    final DisplayContent defaultDisplay = getDefaultDisplayContentLocked();
    final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();
    final int defaultDw = defaultInfo.logicalWidth;
    final int defaultDh = defaultInfo.logicalHeight;
    if (SHOW_LIGHT_TRANSACTIONS)
        Slog.i(TAG, ">>> OPEN TRANSACTION performLayoutAndPlaceSurfaces");
    SurfaceControl.openTransaction();
    try {
        if (mWatermark != null) {
            mWatermark.positionSurface(defaultDw, defaultDh);
        }
        if (mStrictModeFlash != null) {
            mStrictModeFlash.positionSurface(defaultDw, defaultDh);
        }
        if (mCircularDisplayMask != null) {
            mCircularDisplayMask.positionSurface(defaultDw, defaultDh, mRotation);
        }
        if (mEmulatorDisplayOverlay != null) {
            mEmulatorDisplayOverlay.positionSurface(defaultDw, defaultDh, mRotation);
        }
        boolean focusDisplayed = false;
        for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
            final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
            boolean updateAllDrawn = false;
            WindowList windows = displayContent.getWindowList();
            DisplayInfo displayInfo = displayContent.getDisplayInfo();
            final int displayId = displayContent.getDisplayId();
            final int dw = displayInfo.logicalWidth;
            final int dh = displayInfo.logicalHeight;
            final int innerDw = displayInfo.appWidth;
            final int innerDh = displayInfo.appHeight;
            final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);
            // Reset for each display.
            mInnerFields.mDisplayHasContent = false;
            mInnerFields.mPreferredRefreshRate = 0;
            int repeats = 0;
            do {
                repeats++;
                if (repeats > 6) {
                    Slog.w(TAG, "Animation repeat aborted after too many iterations");
                    displayContent.layoutNeeded = false;
                    break;
                }
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("On entry to LockedInner", displayContent.pendingLayoutChanges);
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0 && (adjustWallpaperWindowsLocked() & ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
                    assignLayersLocked(windows);
                    displayContent.layoutNeeded = true;
                }
                if (isDefaultDisplay && (displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_CONFIG) != 0) {
                    if (DEBUG_LAYOUT)
                        Slog.v(TAG, "Computing new config from layout");
                    if (updateOrientationFromAppTokensLocked(true)) {
                        displayContent.layoutNeeded = true;
                        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
                    }
                }
                if ((displayContent.pendingLayoutChanges & WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT) != 0) {
                    displayContent.layoutNeeded = true;
                }
                // FIRST LOOP: Perform a layout, if needed.
                if (repeats < 4) {
                    performLayoutLockedInner(displayContent, repeats == 1, false);
                } else {
                    Slog.w(TAG, "Layout repeat skipped after too many iterations");
                }
                // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think
                // it is animating.
                displayContent.pendingLayoutChanges = 0;
                if (DEBUG_LAYOUT_REPEATS)
                    debugLayoutRepeats("loop number " + mLayoutRepeatCount, displayContent.pendingLayoutChanges);
                if (isDefaultDisplay) {
                    mPolicy.beginPostLayoutPolicyLw(dw, dh);
                    for (i = windows.size() - 1; i >= 0; i--) {
                        WindowState w = windows.get(i);
                        if (w.mHasSurface) {
                            mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs, w.mAttachedWindow);
                        }
                    }
                    displayContent.pendingLayoutChanges |= mPolicy.finishPostLayoutPolicyLw();
                    if (DEBUG_LAYOUT_REPEATS)
                        debugLayoutRepeats("after finishPostLayoutPolicyLw", displayContent.pendingLayoutChanges);
                }
            } while (displayContent.pendingLayoutChanges != 0);
            mInnerFields.mObscured = false;
            mInnerFields.mSyswin = false;
            displayContent.resetDimming();
            // Only used if default window
            final boolean someoneLosingFocus = !mLosingFocus.isEmpty();
            final int N = windows.size();
            for (i = N - 1; i >= 0; i--) {
                WindowState w = windows.get(i);
                final TaskStack stack = w.getStack();
                if (stack == null && w.getAttrs().type != TYPE_PRIVATE_PRESENTATION) {
                    continue;
                }
                final boolean obscuredChanged = w.mObscured != mInnerFields.mObscured;
                // Update effect.
                w.mObscured = mInnerFields.mObscured;
                if (!mInnerFields.mObscured) {
                    handleNotObscuredLocked(w, currentTime, innerDw, innerDh);
                }
                if (stack != null && !stack.testDimmingTag()) {
                    handleFlagDimBehind(w);
                }
                handlePrivateFlagFullyTransparent(w);
                if (isDefaultDisplay && obscuredChanged && (mWallpaperTarget == w) && w.isVisibleLw()) {
                    // This is the wallpaper target and its obscured state
                    // changed... make sure the current wallaper's visibility
                    // has been updated accordingly.
                    updateWallpaperVisibilityLocked();
                }
                final WindowStateAnimator winAnimator = w.mWinAnimator;
                // it.
                if (w.mHasSurface && w.shouldAnimateMove()) {
                    // Frame has moved, containing content frame
                    // has also moved, and we're not currently animating...
                    // let's do something.
                    Animation a = AnimationUtils.loadAnimation(mContext, com.android.internal.R.anim.window_move_from_decor);
                    winAnimator.setAnimation(a);
                    winAnimator.mAnimDw = w.mLastFrame.left - w.mFrame.left;
                    winAnimator.mAnimDh = w.mLastFrame.top - w.mFrame.top;
                    winAnimator.mAnimateMove = true;
                    // TODO (multidisplay): Accessibility supported only for the default display.
                    if (mAccessibilityController != null && displayId == Display.DEFAULT_DISPLAY) {
                        mAccessibilityController.onSomeWindowResizedOrMovedLocked();
                    }
                    try {
                        w.mClient.moved(w.mFrame.left, w.mFrame.top);
                    } catch (RemoteException e) {
                    }
                }
                // Slog.i(TAG, "Window " + this + " clearing mContentChanged - done placing");
                w.mContentChanged = false;
                // Moved from updateWindowsAndWallpaperLocked().
                if (w.mHasSurface && !w.isHiddenFromUserLocked()) {
                    // Take care of the window being ready to display.
                    final boolean committed = winAnimator.commitFinishDrawingLocked(currentTime);
                    if (isDefaultDisplay && committed) {
                        if (w.mAttrs.type == TYPE_DREAM) {
                            // HACK: When a dream is shown, it may at that
                            // point hide the lock screen.  So we need to
                            // redo the layout to let the phone window manager
                            // make this happen.
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("dream and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                        if ((w.mAttrs.flags & FLAG_SHOW_WALLPAPER) != 0) {
                            if (DEBUG_WALLPAPER_LIGHT)
                                Slog.v(TAG, "First draw done in potential wallpaper target " + w);
                            mInnerFields.mWallpaperMayChange = true;
                            displayContent.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
                            if (DEBUG_LAYOUT_REPEATS) {
                                debugLayoutRepeats("wallpaper and commitFinishDrawingLocked true", displayContent.pendingLayoutChanges);
                            }
                        }
                    }
                    winAnimator.setSurfaceBoundariesLocked(recoveringMemory);
                    final AppWindowToken atoken = w.mAppToken;
                    if (DEBUG_STARTING_WINDOW && atoken != null && w == atoken.startingWindow) {
                        Slog.d(TAG, "updateWindows: starting " + w + " isOnScreen=" + w.isOnScreen() + " allDrawn=" + atoken.allDrawn + " freezingScreen=" + atoken.mAppAnimator.freezingScreen);
                    }
                    if (atoken != null && (!atoken.allDrawn || atoken.mAppAnimator.freezingScreen)) {
                        if (atoken.lastTransactionSequence != mTransactionSequence) {
                            atoken.lastTransactionSequence = mTransactionSequence;
                            atoken.numInterestingWindows = atoken.numDrawnWindows = 0;
                            atoken.startingDisplayed = false;
                        }
                        if ((w.isOnScreenIgnoringKeyguard() || winAnimator.mAttrType == TYPE_BASE_APPLICATION) && !w.mExiting && !w.mDestroying) {
                            if (DEBUG_VISIBILITY || DEBUG_ORIENTATION) {
                                Slog.v(TAG, "Eval win " + w + ": isDrawn=" + w.isDrawnLw() + ", isAnimating=" + winAnimator.isAnimating());
                                if (!w.isDrawnLw()) {
                                    Slog.v(TAG, "Not displayed: s=" + winAnimator.mSurfaceControl + " pv=" + w.mPolicyVisibility + " mDrawState=" + winAnimator.drawStateToString() + " ah=" + w.mAttachedHidden + " th=" + atoken.hiddenRequested + " a=" + winAnimator.mAnimating);
                                }
                            }
                            if (w != atoken.startingWindow) {
                                if (!atoken.mAppAnimator.freezingScreen || !w.mAppFreezing) {
                                    atoken.numInterestingWindows++;
                                    if (w.isDrawnLw()) {
                                        atoken.numDrawnWindows++;
                                        if (DEBUG_VISIBILITY || DEBUG_ORIENTATION)
                                            Slog.v(TAG, "tokenMayBeDrawn: " + atoken + " freezingScreen=" + atoken.mAppAnimator.freezingScreen + " mAppFreezing=" + w.mAppFreezing);
                                        updateAllDrawn = true;
                                    }
                                }
                            } else if (w.isDrawnLw()) {
                                atoken.startingDisplayed = true;
                            }
                        }
                    }
                }
                if (isDefaultDisplay && someoneLosingFocus && (w == mCurrentFocus) && w.isDisplayedLw()) {
                    focusDisplayed = true;
                }
                updateResizingWindows(w);
            }
            mDisplayManagerInternal.setDisplayProperties(displayId, mInnerFields.mDisplayHasContent, mInnerFields.mPreferredRefreshRate, true);
            getDisplayContentLocked(displayId).stopDimmingIfNeeded();
            if (updateAllDrawn) {
                updateAllDrawnLocked(displayContent);
            }
        }
        if (focusDisplayed) {
            mH.sendEmptyMessage(H.REPORT_LOSING_FOCUS);
        }
        // Give the display manager a chance to adjust properties
        // like display rotation if it needs to.
        mDisplayManagerInternal.performTraversalInTransactionFromWindowManager();
    } catch (RuntimeException e) {
        Slog.wtf(TAG, "Unhandled exception in Window Manager", e);
    } finally {
        SurfaceControl.closeTransaction();
        if (SHOW_LIGHT_TRANSACTIONS)
            Slog.i(TAG, "<<< CLOSE TRANSACTION performLayoutAndPlaceSurfaces");
    }
    final WindowList defaultWindows = defaultDisplay.getWindowList();
    // to go.
    if (mAppTransition.isReady()) {
        defaultDisplay.pendingLayoutChanges |= handleAppTransitionReadyLocked(defaultWindows);
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAppTransitionReadyLocked", defaultDisplay.pendingLayoutChanges);
    }
    if (!mAnimator.mAnimating && mAppTransition.isRunning()) {
        // We have finished the animation of an app transition.  To do
        // this, we have delayed a lot of operations like showing and
        // hiding apps, moving apps in Z-order, etc.  The app token list
        // reflects the correct Z-order, but the window list may now
        // be out of sync with it.  So here we will just rebuild the
        // entire app window list.  Fun!
        defaultDisplay.pendingLayoutChanges |= handleAnimatingStoppedAndTransitionLocked();
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after handleAnimStopAndXitionLock", defaultDisplay.pendingLayoutChanges);
    }
    if (mInnerFields.mWallpaperForceHidingChanged && defaultDisplay.pendingLayoutChanges == 0 && !mAppTransition.isReady()) {
        // At this point, there was a window with a wallpaper that
        // was force hiding other windows behind it, but now it
        // is going away.  This may be simple -- just animate
        // away the wallpaper and its window -- or it may be
        // hard -- the wallpaper now needs to be shown behind
        // something that was hidden.
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("after animateAwayWallpaperLocked", defaultDisplay.pendingLayoutChanges);
    }
    mInnerFields.mWallpaperForceHidingChanged = false;
    if (mInnerFields.mWallpaperMayChange) {
        if (DEBUG_WALLPAPER_LIGHT)
            Slog.v(TAG, "Wallpaper may change!  Adjusting");
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("WallpaperMayChange", defaultDisplay.pendingLayoutChanges);
    }
    if (mFocusMayChange) {
        mFocusMayChange = false;
        if (updateFocusedWindowLocked(UPDATE_FOCUS_PLACING_SURFACES, false)) {
            updateInputWindowsNeeded = true;
            defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM;
        }
    }
    if (needsLayout()) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_LAYOUT;
        if (DEBUG_LAYOUT_REPEATS)
            debugLayoutRepeats("mLayoutNeeded", defaultDisplay.pendingLayoutChanges);
    }
    for (i = mResizingWindows.size() - 1; i >= 0; i--) {
        WindowState win = mResizingWindows.get(i);
        if (win.mAppFreezing) {
            // Don't remove this window until rotation has completed.
            continue;
        }
        win.reportResized();
        mResizingWindows.remove(i);
    }
    if (DEBUG_ORIENTATION && mDisplayFrozen)
        Slog.v(TAG, "With display frozen, orientationChangeComplete=" + mInnerFields.mOrientationChangeComplete);
    if (mInnerFields.mOrientationChangeComplete) {
        if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
            mWindowsFreezingScreen = WINDOWS_FREEZING_SCREENS_NONE;
            mLastFinishedFreezeSource = mInnerFields.mLastWindowFreezeSource;
            mH.removeMessages(H.WINDOW_FREEZE_TIMEOUT);
        }
        stopFreezingDisplayLocked();
    }
    // Destroy the surface of any windows that are no longer visible.
    boolean wallpaperDestroyed = false;
    i = mDestroySurface.size();
    if (i > 0) {
        do {
            i--;
            WindowState win = mDestroySurface.get(i);
            win.mDestroying = false;
            if (mInputMethodWindow == win) {
                mInputMethodWindow = null;
            }
            if (win == mWallpaperTarget) {
                wallpaperDestroyed = true;
            }
            win.mWinAnimator.destroySurfaceLocked();
        } while (i > 0);
        mDestroySurface.clear();
    }
    // Time to remove any exiting tokens?
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        ArrayList<WindowToken> exitingTokens = displayContent.mExitingTokens;
        for (i = exitingTokens.size() - 1; i >= 0; i--) {
            WindowToken token = exitingTokens.get(i);
            if (!token.hasVisible) {
                exitingTokens.remove(i);
                if (token.windowType == TYPE_WALLPAPER) {
                    mWallpaperTokens.remove(token);
                }
            }
        }
    }
    // Time to remove any exiting applications?
    for (int stackNdx = mStackIdToStack.size() - 1; stackNdx >= 0; --stackNdx) {
        // Initialize state of exiting applications.
        final AppTokenList exitingAppTokens = mStackIdToStack.valueAt(stackNdx).mExitingAppTokens;
        for (i = exitingAppTokens.size() - 1; i >= 0; i--) {
            AppWindowToken token = exitingAppTokens.get(i);
            if (!token.hasVisible && !mClosingApps.contains(token) && (!token.mDeferRemoval || token.allAppWindows.isEmpty())) {
                // Make sure there is no animation running on this token,
                // so any windows associated with it will be removed as
                // soon as their animations are complete
                token.mAppAnimator.clearAnimation();
                token.mAppAnimator.animating = false;
                if (DEBUG_ADD_REMOVE || DEBUG_TOKEN_MOVEMENT)
                    Slog.v(TAG, "performLayout: App token exiting now removed" + token);
                removeAppFromTaskLocked(token);
                exitingAppTokens.remove(i);
                final Task task = mTaskIdToTask.get(token.groupId);
                if (task != null && task.mDeferRemoval && task.mAppTokens.isEmpty()) {
                    removeTaskLocked(task);
                }
            }
        }
    }
    if (!mAnimator.mAnimating && mRelayoutWhileAnimating.size() > 0) {
        for (int j = mRelayoutWhileAnimating.size() - 1; j >= 0; j--) {
            try {
                mRelayoutWhileAnimating.get(j).mClient.doneAnimating();
            } catch (RemoteException e) {
            }
        }
        mRelayoutWhileAnimating.clear();
    }
    if (wallpaperDestroyed) {
        defaultDisplay.pendingLayoutChanges |= WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER;
        defaultDisplay.layoutNeeded = true;
    }
    for (int displayNdx = 0; displayNdx < numDisplays; ++displayNdx) {
        final DisplayContent displayContent = mDisplayContents.valueAt(displayNdx);
        if (displayContent.pendingLayoutChanges != 0) {
            displayContent.layoutNeeded = true;
        }
    }
    // Finally update all input windows now that the window changes have stabilized.
    mInputMonitor.updateInputWindowsLw(true);
    setHoldScreenLocked(mInnerFields.mHoldScreen);
    if (!mDisplayFrozen) {
        if (mInnerFields.mScreenBrightness < 0 || mInnerFields.mScreenBrightness > 1.0f) {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setScreenBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mScreenBrightness));
        }
        if (mInnerFields.mButtonBrightness < 0 || mInnerFields.mButtonBrightness > 1.0f) {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(-1);
        } else {
            mPowerManagerInternal.setButtonBrightnessOverrideFromWindowManager(toBrightnessOverride(mInnerFields.mButtonBrightness));
        }
        mPowerManagerInternal.setUserActivityTimeoutOverrideFromWindowManager(mInnerFields.mUserActivityTimeout);
    }
    if (mTurnOnScreen) {
        if (mAllowTheaterModeWakeFromLayout || Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.THEATER_MODE_ON, 0) == 0) {
            if (DEBUG_VISIBILITY)
                Slog.v(TAG, "Turning screen on after layout!");
            mPowerManager.wakeUp(SystemClock.uptimeMillis());
        }
        mTurnOnScreen = false;
    }
    if (mInnerFields.mUpdateRotation) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "Performing post-rotate rotation");
        if (updateRotationUncheckedLocked(false)) {
            mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
        } else {
            mInnerFields.mUpdateRotation = false;
        }
    }
    if (mWaitingForDrawnCallback != null || (mInnerFields.mOrientationChangeComplete && !defaultDisplay.layoutNeeded && !mInnerFields.mUpdateRotation)) {
        checkDrawnWindowsLocked();
    }
    final int N = mPendingRemove.size();
    if (N > 0) {
        if (mPendingRemoveTmp.length < N) {
            mPendingRemoveTmp = new WindowState[N + 10];
        }
        mPendingRemove.toArray(mPendingRemoveTmp);
        mPendingRemove.clear();
        DisplayContentList displayList = new DisplayContentList();
        for (i = 0; i < N; i++) {
            WindowState w = mPendingRemoveTmp[i];
            removeWindowInnerLocked(w.mSession, w);
            final DisplayContent displayContent = w.getDisplayContent();
            if (displayContent != null && !displayList.contains(displayContent)) {
                displayList.add(displayContent);
            }
        }
        for (DisplayContent displayContent : displayList) {
            assignLayersLocked(displayContent.getWindowList());
            displayContent.layoutNeeded = true;
        }
    }
    // Remove all deferred displays stacks, tasks, and activities.
    for (int displayNdx = mDisplayContents.size() - 1; displayNdx >= 0; --displayNdx) {
        mDisplayContents.valueAt(displayNdx).checkForDeferredActions();
    }
    if (updateInputWindowsNeeded) {
        mInputMonitor.updateInputWindowsLw(false);
    }
    setFocusedStackFrame();
    // Check to see if we are now in a state where the screen should
    // be enabled, because the window obscured flags have changed.
    enableScreenIfNeededLocked();
    scheduleAnimationLocked();
    if (DEBUG_WINDOW_TRACE) {
        Slog.e(TAG, "performLayoutAndPlaceSurfacesLockedInner exit: animating=" + mAnimator.mAnimating);
    }
}
#end_block

#method_before
boolean copyAnimToLayoutParamsLocked() {
    boolean doRequest = false;
    final int bulkUpdateParams = mAnimator.mBulkUpdateParams;
    if ((bulkUpdateParams & LayoutFields.SET_UPDATE_ROTATION) != 0) {
        mInnerFields.mUpdateRotation = true;
        doRequest = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_WALLPAPER_MAY_CHANGE) != 0) {
        mInnerFields.mWallpaperMayChange = true;
        doRequest = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_FORCE_HIDING_CHANGED) != 0) {
        mInnerFields.mWallpaperForceHidingChanged = true;
        doRequest = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_ORIENTATION_CHANGE_COMPLETE) == 0) {
        mInnerFields.mOrientationChangeComplete = false;
    } else {
        mInnerFields.mOrientationChangeComplete = true;
        mInnerFields.mLastWindowFreezeSource = mAnimator.mLastWindowFreezeSource;
        if (mWindowsFreezingScreen) {
            doRequest = true;
        }
    }
    if ((bulkUpdateParams & LayoutFields.SET_TURN_ON_SCREEN) != 0) {
        mTurnOnScreen = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_WALLPAPER_ACTION_PENDING) != 0) {
        mInnerFields.mWallpaperActionPending = true;
    }
    return doRequest;
}
#method_after
boolean copyAnimToLayoutParamsLocked() {
    boolean doRequest = false;
    final int bulkUpdateParams = mAnimator.mBulkUpdateParams;
    if ((bulkUpdateParams & LayoutFields.SET_UPDATE_ROTATION) != 0) {
        mInnerFields.mUpdateRotation = true;
        doRequest = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_WALLPAPER_MAY_CHANGE) != 0) {
        mInnerFields.mWallpaperMayChange = true;
        doRequest = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_FORCE_HIDING_CHANGED) != 0) {
        mInnerFields.mWallpaperForceHidingChanged = true;
        doRequest = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_ORIENTATION_CHANGE_COMPLETE) == 0) {
        mInnerFields.mOrientationChangeComplete = false;
    } else {
        mInnerFields.mOrientationChangeComplete = true;
        mInnerFields.mLastWindowFreezeSource = mAnimator.mLastWindowFreezeSource;
        if (mWindowsFreezingScreen != WINDOWS_FREEZING_SCREENS_NONE) {
            doRequest = true;
        }
    }
    if ((bulkUpdateParams & LayoutFields.SET_TURN_ON_SCREEN) != 0) {
        mTurnOnScreen = true;
    }
    if ((bulkUpdateParams & LayoutFields.SET_WALLPAPER_ACTION_PENDING) != 0) {
        mInnerFields.mWallpaperActionPending = true;
    }
    return doRequest;
}
#end_block

#method_before
private void stopFreezingDisplayLocked() {
    if (!mDisplayFrozen) {
        return;
    }
    if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen || mClientFreezingScreen || !mOpeningApps.isEmpty()) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "stopFreezingDisplayLocked: Returning mWaitingForConfig=" + mWaitingForConfig + ", mAppsFreezingScreen=" + mAppsFreezingScreen + ", mWindowsFreezingScreen=" + mWindowsFreezingScreen + ", mClientFreezingScreen=" + mClientFreezingScreen + ", mOpeningApps.size()=" + mOpeningApps.size());
        return;
    }
    mDisplayFrozen = false;
    mLastDisplayFreezeDuration = (int) (SystemClock.elapsedRealtime() - mDisplayFreezeTime);
    StringBuilder sb = new StringBuilder(128);
    sb.append("Screen frozen for ");
    TimeUtils.formatDuration(mLastDisplayFreezeDuration, sb);
    if (mLastFinishedFreezeSource != null) {
        sb.append(" due to ");
        sb.append(mLastFinishedFreezeSource);
    }
    Slog.i(TAG, sb.toString());
    mH.removeMessages(H.APP_FREEZE_TIMEOUT);
    mH.removeMessages(H.CLIENT_FREEZE_TIMEOUT);
    if (PROFILE_ORIENTATION) {
        Debug.stopMethodTracing();
    }
    boolean updateRotation = false;
    final DisplayContent displayContent = getDefaultDisplayContentLocked();
    final int displayId = displayContent.getDisplayId();
    ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(displayId);
    if (CUSTOM_SCREEN_ROTATION && screenRotationAnimation != null && screenRotationAnimation.hasScreenshot()) {
        if (DEBUG_ORIENTATION)
            Slog.i(TAG, "**** Dismissing screen rotation animation");
        // TODO(multidisplay): rotation on main screen only.
        DisplayInfo displayInfo = displayContent.getDisplayInfo();
        // Get rotation animation again, with new top window
        boolean isDimming = displayContent.isDimming();
        if (!mPolicy.validateRotationAnimationLw(mExitAnimId, mEnterAnimId, isDimming)) {
            mExitAnimId = mEnterAnimId = 0;
        }
        if (screenRotationAnimation.dismiss(mFxSession, MAX_ANIMATION_DURATION, getTransitionAnimationScaleLocked(), displayInfo.logicalWidth, displayInfo.logicalHeight, mExitAnimId, mEnterAnimId)) {
            scheduleAnimationLocked();
        } else {
            screenRotationAnimation.kill();
            screenRotationAnimation = null;
            mAnimator.setScreenRotationAnimationLocked(displayId, screenRotationAnimation);
            updateRotation = true;
        }
    } else {
        if (screenRotationAnimation != null) {
            screenRotationAnimation.kill();
            screenRotationAnimation = null;
            mAnimator.setScreenRotationAnimationLocked(displayId, screenRotationAnimation);
        }
        updateRotation = true;
    }
    mInputMonitor.thawInputDispatchingLw();
    boolean configChanged;
    // While the display is frozen we don't re-compute the orientation
    // to avoid inconsistent states.  However, something interesting
    // could have actually changed during that time so re-evaluate it
    // now to catch that.
    configChanged = updateOrientationFromAppTokensLocked(false);
    // A little kludge: a lot could have happened while the
    // display was frozen, so now that we are coming back we
    // do a gc so that any remote references the system
    // processes holds on others can be released if they are
    // no longer needed.
    mH.removeMessages(H.FORCE_GC);
    mH.sendEmptyMessageDelayed(H.FORCE_GC, 2000);
    mScreenFrozenLock.release();
    if (updateRotation) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "Performing post-rotate rotation");
        configChanged |= updateRotationUncheckedLocked(false);
    }
    if (configChanged) {
        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
}
#method_after
private void stopFreezingDisplayLocked() {
    if (!mDisplayFrozen) {
        return;
    }
    if (mWaitingForConfig || mAppsFreezingScreen > 0 || mWindowsFreezingScreen == WINDOWS_FREEZING_SCREENS_ACTIVE || mClientFreezingScreen || !mOpeningApps.isEmpty()) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "stopFreezingDisplayLocked: Returning mWaitingForConfig=" + mWaitingForConfig + ", mAppsFreezingScreen=" + mAppsFreezingScreen + ", mWindowsFreezingScreen=" + mWindowsFreezingScreen + ", mClientFreezingScreen=" + mClientFreezingScreen + ", mOpeningApps.size()=" + mOpeningApps.size());
        return;
    }
    mDisplayFrozen = false;
    mLastDisplayFreezeDuration = (int) (SystemClock.elapsedRealtime() - mDisplayFreezeTime);
    StringBuilder sb = new StringBuilder(128);
    sb.append("Screen frozen for ");
    TimeUtils.formatDuration(mLastDisplayFreezeDuration, sb);
    if (mLastFinishedFreezeSource != null) {
        sb.append(" due to ");
        sb.append(mLastFinishedFreezeSource);
    }
    Slog.i(TAG, sb.toString());
    mH.removeMessages(H.APP_FREEZE_TIMEOUT);
    mH.removeMessages(H.CLIENT_FREEZE_TIMEOUT);
    if (PROFILE_ORIENTATION) {
        Debug.stopMethodTracing();
    }
    boolean updateRotation = false;
    final DisplayContent displayContent = getDefaultDisplayContentLocked();
    final int displayId = displayContent.getDisplayId();
    ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(displayId);
    if (CUSTOM_SCREEN_ROTATION && screenRotationAnimation != null && screenRotationAnimation.hasScreenshot()) {
        if (DEBUG_ORIENTATION)
            Slog.i(TAG, "**** Dismissing screen rotation animation");
        // TODO(multidisplay): rotation on main screen only.
        DisplayInfo displayInfo = displayContent.getDisplayInfo();
        // Get rotation animation again, with new top window
        boolean isDimming = displayContent.isDimming();
        if (!mPolicy.validateRotationAnimationLw(mExitAnimId, mEnterAnimId, isDimming)) {
            mExitAnimId = mEnterAnimId = 0;
        }
        if (screenRotationAnimation.dismiss(mFxSession, MAX_ANIMATION_DURATION, getTransitionAnimationScaleLocked(), displayInfo.logicalWidth, displayInfo.logicalHeight, mExitAnimId, mEnterAnimId)) {
            scheduleAnimationLocked();
        } else {
            screenRotationAnimation.kill();
            screenRotationAnimation = null;
            mAnimator.setScreenRotationAnimationLocked(displayId, screenRotationAnimation);
            updateRotation = true;
        }
    } else {
        if (screenRotationAnimation != null) {
            screenRotationAnimation.kill();
            screenRotationAnimation = null;
            mAnimator.setScreenRotationAnimationLocked(displayId, screenRotationAnimation);
        }
        updateRotation = true;
    }
    mInputMonitor.thawInputDispatchingLw();
    boolean configChanged;
    // While the display is frozen we don't re-compute the orientation
    // to avoid inconsistent states.  However, something interesting
    // could have actually changed during that time so re-evaluate it
    // now to catch that.
    configChanged = updateOrientationFromAppTokensLocked(false);
    // A little kludge: a lot could have happened while the
    // display was frozen, so now that we are coming back we
    // do a gc so that any remote references the system
    // processes holds on others can be released if they are
    // no longer needed.
    mH.removeMessages(H.FORCE_GC);
    mH.sendEmptyMessageDelayed(H.FORCE_GC, 2000);
    mScreenFrozenLock.release();
    if (updateRotation) {
        if (DEBUG_ORIENTATION)
            Slog.d(TAG, "Performing post-rotate rotation");
        configChanged |= updateRotationUncheckedLocked(false);
    }
    if (configChanged) {
        mH.sendEmptyMessage(H.SEND_NEW_CONFIGURATION);
    }
}
#end_block

#method_before
private QSTile<?> createTile(String tileSpec) {
    if (tileSpec.startsWith(IntentTile.PREFIX)) {
        return IntentTile.create(this, tileSpec);
    }
    // Ensure tile is supported on this device
    if (!QSUtils.getAvailableTiles(mContext).contains(tileSpec)) {
        return null;
    }
    switch(tileSpec) {
        case QSConstants.TILE_WIFI:
            return new WifiTile(this);
        case QSConstants.TILE_BLUETOOTH:
            return new BluetoothTile(this);
        case QSConstants.TILE_INVERSION:
            return new ColorInversionTile(this);
        case QSConstants.TILE_CELLULAR:
            return new CellularTile(this);
        case QSConstants.TILE_AIRPLANE:
            return new AirplaneModeTile(this);
        case QSConstants.TILE_ROTATION:
            return new RotationLockTile(this);
        case QSConstants.TILE_FLASHLIGHT:
            return new FlashlightTile(this);
        case QSConstants.TILE_LOCATION:
            return new LocationTile(this);
        case QSConstants.TILE_CAST:
            return new CastTile(this);
        case QSConstants.TILE_HOTSPOT:
            return new HotspotTile(this);
        case QSConstants.TILE_NOTIFICATIONS:
            return new NotificationsTile(this);
        case QSConstants.TILE_DATA:
            return new DataTile(this);
        case QSConstants.TILE_ROAMING:
            return new RoamingTile(this);
        case QSConstants.TILE_DDS:
            return new DdsTile(this);
        case QSConstants.TILE_COMPASS:
            return new CompassTile(this);
        case QSConstants.TILE_APN:
            return new ApnTile(this);
        case QSConstants.TILE_ADB_NETWORK:
            return new AdbOverNetworkTile(this);
        case QSConstants.TILE_NFC:
            return new NfcTile(this);
        case QSConstants.TILE_LOCKSCREEN:
            return new LockscreenToggleTile(this);
        case QSConstants.TILE_LTE:
            return new LteTile(this);
        case QSConstants.TILE_VISUALIZER:
            return new VisualizerTile(this);
        case QSConstants.TILE_SCREEN_TIMEOUT:
            return new ScreenTimeoutTile(this);
        case QSConstants.TILE_USB_TETHER:
            return new UsbTetherTile(this);
        case QSConstants.TILE_REBOOT:
            return new RebootTile(this);
        case QSConstants.TILE_SYNC:
            return new SyncTile(this);
        case QSConstants.TILE_AMBIENT_DISPLAY:
            return new AmbientDisplayTile(this);
        case QSConstants.TILE_SCREENSHOT:
            return new ScreenshotTile(this);
        case QSConstants.TILE_EXPANDED_DESKTOP:
            return new ExpandedDesktopTile(this);
        default:
            throw new IllegalArgumentException("Bad tile spec: " + tileSpec);
    }
}
#method_after
private QSTile<?> createTile(String tileSpec) {
    if (tileSpec.startsWith(IntentTile.PREFIX)) {
        return IntentTile.create(this, tileSpec);
    }
    // Ensure tile is supported on this device
    if (!QSUtils.getAvailableTiles(mContext).contains(tileSpec)) {
        return null;
    }
    switch(tileSpec) {
        case QSConstants.TILE_WIFI:
            return new WifiTile(this);
        case QSConstants.TILE_BLUETOOTH:
            return new BluetoothTile(this);
        case QSConstants.TILE_INVERSION:
            return new ColorInversionTile(this);
        case QSConstants.TILE_CELLULAR:
            return new CellularTile(this);
        case QSConstants.TILE_AIRPLANE:
            return new AirplaneModeTile(this);
        case QSConstants.TILE_ROTATION:
            return new RotationLockTile(this);
        case QSConstants.TILE_FLASHLIGHT:
            return new FlashlightTile(this);
        case QSConstants.TILE_LOCATION:
            return new LocationTile(this);
        case QSConstants.TILE_CAST:
            return new CastTile(this);
        case QSConstants.TILE_HOTSPOT:
            return new HotspotTile(this);
        case QSConstants.TILE_NOTIFICATIONS:
            return new NotificationsTile(this);
        case QSConstants.TILE_DATA:
            return new DataTile(this);
        case QSConstants.TILE_ROAMING:
            return new RoamingTile(this);
        case QSConstants.TILE_DDS:
            return new DdsTile(this);
        case QSConstants.TILE_COMPASS:
            return new CompassTile(this);
        case QSConstants.TILE_APN:
            return new ApnTile(this);
        case QSConstants.TILE_ADB_NETWORK:
            return new AdbOverNetworkTile(this);
        case QSConstants.TILE_NFC:
            return new NfcTile(this);
        case QSConstants.TILE_LOCKSCREEN:
            return new LockscreenToggleTile(this);
        case QSConstants.TILE_LTE:
            return new LteTile(this);
        case QSConstants.TILE_VISUALIZER:
            return new VisualizerTile(this);
        case QSConstants.TILE_SCREEN_TIMEOUT:
            return new ScreenTimeoutTile(this);
        case QSConstants.TILE_USB_TETHER:
            return new UsbTetherTile(this);
        case QSConstants.TILE_REBOOT:
            return new RebootTile(this);
        case QSConstants.TILE_SYNC:
            return new SyncTile(this);
        case QSConstants.TILE_AMBIENT_DISPLAY:
            return new AmbientDisplayTile(this);
        case QSConstants.TILE_SCREENSHOT:
            return new ScreenshotTile(this);
        case QSConstants.TILE_LIVE_DISPLAY:
            return new LiveDisplayTile(this);
        case QSConstants.TILE_EXPANDED_DESKTOP:
            return new ExpandedDesktopTile(this);
        default:
            throw new IllegalArgumentException("Bad tile spec: " + tileSpec);
    }
}
#end_block

#method_before
@Override
protected Intent getTargetIntent() {
    Intent targetIntent = new Intent(Intent.ACTION_MAIN, null);
    if (Settings.Secure.getIntForUser(getContentResolver(), Settings.Secure.CHAMBER_OF_SECRETS, 0, UserHandle.USER_CURRENT) == 1) {
        targetIntent.addCategory("com.android.systemui.SHORTCUT_EXTRA");
    } else {
        targetIntent.addCategory("com.android.systemui.SHORTCUT");
    }
    targetIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    return targetIntent;
}
#method_after
@Override
protected Intent getTargetIntent() {
    Intent targetIntent = new Intent(Intent.ACTION_MAIN, null);
    if (Settings.Secure.getIntForUser(getContentResolver(), Settings.Secure.CHAMBER_OF_SECRETS, 0, UserHandle.USER_CURRENT) == 1) {
        targetIntent.addCategory("com.android.systemui.SHORTCUT_COS");
    }
    targetIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    return targetIntent;
}
#end_block

#method_before
@Override
protected void onListItemClick(ListView list, View view, int position, long id) {
    mShortcutIntent = intentForPosition(position);
    String intentClass = mShortcutIntent.getComponent().getClassName();
    String className = intentClass.substring(intentClass.lastIndexOf(".") + 1);
    String intentAction = mShortcutIntent.getAction();
    mShortcutIntent = new Intent();
    mShortcutIntent.setClassName(this, intentClass);
    mShortcutIntent.setAction(intentAction);
    mIntent = new Intent();
    mIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, BitmapFactory.decodeResource(getResources(), returnIconResId(className)));
    mIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, itemForPosition(position).label);
    if (className.equals("ChamberOfSecrets")) {
        showDialogSetting(DLG_SECRET);
    } else if (className.equals("Immersive") || className.equals("Torch") || className.equals("Rotation")) {
        showDialogSetting(DLG_TOGGLE);
    } else {
        finalizeIntent();
    }
}
#method_after
@Override
protected void onListItemClick(ListView list, View view, int position, long id) {
    mShortcutIntent = intentForPosition(position);
    String intentClass = mShortcutIntent.getComponent().getClassName();
    String className = intentClass.substring(intentClass.lastIndexOf(".") + 1);
    String intentAction = mShortcutIntent.getAction();
    mShortcutIntent = new Intent();
    mShortcutIntent.setClassName(this, intentClass);
    mShortcutIntent.setAction(intentAction);
    mIntent = new Intent();
    mIntent.putExtra(Intent.EXTRA_SHORTCUT_ICON, BitmapFactory.decodeResource(getResources(), returnIconResId(className)));
    mIntent.putExtra(Intent.EXTRA_SHORTCUT_NAME, itemForPosition(position).label);
    if (className.equals("ChamberOfSecrets")) {
        showDialogSetting(DLG_SECRET);
    } else {
        finalizeIntent();
    }
}
#end_block

#method_before
private int returnIconResId(String c) {
    if (c.equals("Immersive")) {
        return R.drawable.ic_shortcut_immersive;
    } else if (c.equals("Rotation")) {
        return R.drawable.ic_shortcut_rotation;
    } else if (c.equals("Torch")) {
        return R.drawable.ic_shortcut_torch;
    } else if (c.equals("LastApp")) {
        return R.drawable.ic_shortcut_lastapp;
    } else if (c.equals("Reboot")) {
        return R.drawable.ic_shortcut_reboot;
    } else if (c.equals("Screenshot")) {
        return R.drawable.ic_shortcut_screenshot;
    } else if (c.equals("VolumePanel")) {
        return R.drawable.ic_shortcut_volumepanel;
    } else if (c.equals("ChamberOfSecrets")) {
        return R.drawable.ic_shortcut_chamberofsecrets;
    } else {
        // Oh-Noes, you found a wild derp.
        return R.drawable.ic_shortcut_null;
    }
}
#method_after
private int returnIconResId(String c) {
    if (c.equals("ChamberOfSecrets")) {
        return R.drawable.ic_shortcut_chamberofsecrets;
    } else {
        // Oh-Noes, you found a wild derp.
        return R.drawable.ic_shortcut_null;
    }
}
#end_block

#method_before
private void performPendingShutdown() {
    final String shutdownAction = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
    if (shutdownAction != null && shutdownAction.length() > 0) {
        boolean reboot = (shutdownAction.charAt(0) == '1');
        final String reason;
        if (shutdownAction.length() > 1) {
            reason = shutdownAction.substring(1, shutdownAction.length());
        } else {
            reason = null;
        }
        ShutdownThread.rebootOrShutdown(reboot, reason);
    }
}
#method_after
private void performPendingShutdown() {
    final String shutdownAction = SystemProperties.get(ShutdownThread.SHUTDOWN_ACTION_PROPERTY, "");
    if (shutdownAction != null && shutdownAction.length() > 0) {
        boolean reboot = (shutdownAction.charAt(0) == '1');
        final String reason;
        if (shutdownAction.length() > 1) {
            reason = shutdownAction.substring(1, shutdownAction.length());
        } else {
            reason = null;
        }
        ShutdownThread.rebootOrShutdown(null, reboot, reason);
    }
}
#end_block

#method_before
@Override
protected void handleUpdateState(LiveDisplayState state, Object arg) {
    state.visible = true;
    state.mode = arg == null ? getCurrentModeIndex() : (Integer) arg;
    state.label = mEntries[state.mode];
    state.icon = mContext.getDrawable(mEntryIconRes[state.mode]);
}
#method_after
@Override
protected void handleUpdateState(LiveDisplayState state, Object arg) {
    state.visible = true;
    state.mode = arg == null ? getCurrentModeIndex() : (Integer) arg;
    state.label = mEntries[state.mode];
    state.icon = ResourceIcon.get(mEntryIconRes[state.mode]);
}
#end_block

#method_before
protected boolean shouldInterrupt(StatusBarNotification sbn) {
    if (mNotificationData.shouldFilterOut(sbn)) {
        if (DEBUG) {
            Log.d(TAG, "Skipping HUN check for " + sbn.getKey() + " since it's filtered out.");
        }
        return false;
    }
    if (mHeadsUpNotificationView.isSnoozed(sbn.getPackageName())) {
        return false;
    }
    Notification notification = sbn.getNotification();
    // we are snoozing
    if (isHeadsUpInSnooze()) {
        return false;
    }
    // some predicates to make the boolean logic legible
    boolean isNoisy = (notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
    boolean isHighPriority = sbn.getScore() >= INTERRUPTION_THRESHOLD;
    boolean isFullscreen = notification.fullScreenIntent != null;
    int asHeadsUp = notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP, Notification.HEADS_UP_ALLOWED);
    boolean isAllowed = asHeadsUp != Notification.HEADS_UP_NEVER;
    boolean accessibilityForcesLaunch = isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
    boolean keyguardIsShowing = (mStatusBarKeyguardViewManager.isShowing() || !mStatusBarKeyguardViewManager.isOccluded()) && mStatusBarKeyguardViewManager.isInputRestricted();
    boolean interrupt = (isFullscreen || (isHighPriority && isNoisy) || asHeadsUp == Notification.HEADS_UP_REQUESTED) && isAllowed && !accessibilityForcesLaunch && mPowerManager.isScreenOn() && !keyguardIsShowing;
    if (!interrupt) {
        boolean isHeadsUpPackage = mNoMan.getHeadsUpNotificationsEnabledForPackage(sbn.getPackageName(), sbn.getUid()) != Notification.HEADS_UP_NEVER;
        boolean isExpanded = false;
        if (mStackScroller != null) {
            isExpanded = mStackScroller.getIsExpanded();
        }
        // Possibly a heads up package set from the user.
        interrupt = isHeadsUpPackage && !sbn.isOngoing() && mPowerManager.isScreenOn() && !accessibilityForcesLaunch && !isExpanded && !keyguardIsShowing;
        if (interrupt) {
            mHeadsUpPackageName = sbn.getPackageName();
        }
    }
    try {
        interrupt = interrupt && !mDreamManager.isDreaming();
    } catch (RemoteException e) {
        Log.d(TAG, "failed to query dream manager", e);
    }
    if (DEBUG)
        Log.d(TAG, "interrupt: " + interrupt);
    return interrupt;
}
#method_after
protected boolean shouldInterrupt(StatusBarNotification sbn) {
    if (mNotificationData.shouldFilterOut(sbn)) {
        if (DEBUG) {
            Log.d(TAG, "Skipping HUN check for " + sbn.getKey() + " since it's filtered out.");
        }
        return false;
    }
    String pkg = sbn.getPackageName();
    if (mHeadsUpNotificationView.isSnoozed(pkg)) {
        return false;
    }
    Notification notification = sbn.getNotification();
    // we are snoozing
    if (isHeadsUpInSnooze()) {
        return false;
    }
    // some predicates to make the boolean logic legible
    boolean isNoisy = (notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
    boolean isHighPriority = sbn.getScore() >= INTERRUPTION_THRESHOLD;
    boolean isFullscreen = notification.fullScreenIntent != null;
    // denying heads up by default
    int asHeadsUp = notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP, Notification.HEADS_UP_NEVER);
    PackageManager pmUser = getPackageManagerForUser(sbn.getUser().getIdentifier());
    // but if it's a system package, heads up should still be shown
    boolean isSystemPackage = isThisASystemPackage(pkg, pmUser);
    boolean isAllowed = (asHeadsUp != Notification.HEADS_UP_NEVER) || isSystemPackage;
    if (DEBUG)
        Log.d(TAG, "package: " + pkg + ", isSystem: " + isSystemPackage + ", asHeadsUp: " + asHeadsUp + ", isAllowed: " + isAllowed);
    boolean accessibilityForcesLaunch = isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
    boolean keyguardIsShowing = (mStatusBarKeyguardViewManager.isShowing() || !mStatusBarKeyguardViewManager.isOccluded()) && mStatusBarKeyguardViewManager.isInputRestricted();
    boolean interrupt = (isFullscreen || (isHighPriority && isNoisy) || asHeadsUp == Notification.HEADS_UP_REQUESTED) && isAllowed && !accessibilityForcesLaunch && mPowerManager.isScreenOn() && !keyguardIsShowing;
    if (!interrupt) {
        boolean isHeadsUpPackage = (mNoMan.getHeadsUpNotificationsEnabledForPackage(pkg, sbn.getUid()) != Notification.HEADS_UP_NEVER) || isSystemPackage;
        if (DEBUG)
            Log.d(TAG, "package: " + pkg + ", isHeadsUpPackage: " + isHeadsUpPackage);
        boolean isExpanded = false;
        if (mStackScroller != null) {
            isExpanded = mStackScroller.getIsExpanded();
        }
        // Possibly a heads up package set from the user.
        interrupt = isHeadsUpPackage && !sbn.isOngoing() && mPowerManager.isScreenOn() && !accessibilityForcesLaunch && !isExpanded && !keyguardIsShowing;
        if (interrupt) {
            mHeadsUpPackageName = pkg;
        }
    }
    try {
        interrupt = interrupt && !mDreamManager.isDreaming();
    } catch (RemoteException e) {
        Log.d(TAG, "failed to query dream manager", e);
    }
    if (DEBUG)
        Log.d(TAG, "interrupt: " + interrupt);
    return interrupt;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj, msg.arg1);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_SHOW_HEADS_UP:
            setHeadsUpVisibility(true);
            break;
        case MSG_DECAY_HEADS_UP:
            mHeadsUpNotificationView.release();
            setHeadsUpVisibility(false);
            break;
        case MSG_HIDE_HEADS_UP:
            mHeadsUpNotificationView.release();
            setHeadsUpVisibility(false);
            break;
        case MSG_ESCALATE_HEADS_UP:
            escalateHeadsUp();
            setHeadsUpVisibility(false);
            break;
        case MSG_LAUNCH_TRANSITION_TIMEOUT:
            onLaunchTransitionTimeout();
            break;
        case MSG_UPDATE_NOTIFICATIONS:
            handleUpdateNotifications();
            break;
    }
}
#end_block

#method_before
protected boolean shouldInterrupt(StatusBarNotification sbn) {
    if (mNotificationData.shouldFilterOut(sbn)) {
        if (DEBUG) {
            Log.d(TAG, "Skipping HUN check for " + sbn.getKey() + " since it's filtered out.");
        }
        return false;
    }
    String pkg = sbn.getPackageName();
    if (mHeadsUpNotificationView.isSnoozed(pkg)) {
        return false;
    }
    Notification notification = sbn.getNotification();
    // we are snoozing
    if (isHeadsUpInSnooze()) {
        return false;
    }
    // some predicates to make the boolean logic legible
    boolean isNoisy = (notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
    boolean isHighPriority = sbn.getScore() >= INTERRUPTION_THRESHOLD;
    boolean isFullscreen = notification.fullScreenIntent != null;
    // denying heads up by default
    int asHeadsUp = notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP, Notification.HEADS_UP_NEVER);
    PackageManager pmUser = getPackageManagerForUser(sbn.getUser().getIdentifier());
    // but if it's a system package, heads up should still be shown
    boolean isSystemPackage = isThisASystemPackage(pkg, pmUser);
    boolean isAllowed = (asHeadsUp != Notification.HEADS_UP_NEVER) || isSystemPackage;
    if (DEBUG)
        Log.d(TAG, "package: " + pkg + ", isSystem: " + Boolean.toString(isSystemPackage) + ", asHeadsUp: " + Integer.toString(asHeadsUp) + ", isAllowed: " + Boolean.toString(isAllowed));
    boolean accessibilityForcesLaunch = isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
    boolean keyguardIsShowing = (mStatusBarKeyguardViewManager.isShowing() || !mStatusBarKeyguardViewManager.isOccluded()) && mStatusBarKeyguardViewManager.isInputRestricted();
    boolean interrupt = (isFullscreen || (isHighPriority && isNoisy) || asHeadsUp == Notification.HEADS_UP_REQUESTED) && isAllowed && !accessibilityForcesLaunch && mPowerManager.isScreenOn() && !keyguardIsShowing;
    if (!interrupt) {
        boolean isHeadsUpPackage = (mNoMan.getHeadsUpNotificationsEnabledForPackage(pkg, sbn.getUid()) != Notification.HEADS_UP_NEVER) || isSystemPackage;
        if (DEBUG)
            Log.d(TAG, "package: " + pkg + ", isHeadsUpPackage: " + Boolean.toString(isHeadsUpPackage));
        boolean isExpanded = false;
        if (mStackScroller != null) {
            isExpanded = mStackScroller.getIsExpanded();
        }
        // Possibly a heads up package set from the user.
        interrupt = isHeadsUpPackage && !sbn.isOngoing() && mPowerManager.isScreenOn() && !accessibilityForcesLaunch && !isExpanded && !keyguardIsShowing;
        if (interrupt) {
            mHeadsUpPackageName = pkg;
        }
    }
    try {
        interrupt = interrupt && !mDreamManager.isDreaming();
    } catch (RemoteException e) {
        Log.d(TAG, "failed to query dream manager", e);
    }
    if (DEBUG)
        Log.d(TAG, "interrupt: " + interrupt);
    return interrupt;
}
#method_after
protected boolean shouldInterrupt(StatusBarNotification sbn) {
    if (mNotificationData.shouldFilterOut(sbn)) {
        if (DEBUG) {
            Log.d(TAG, "Skipping HUN check for " + sbn.getKey() + " since it's filtered out.");
        }
        return false;
    }
    String pkg = sbn.getPackageName();
    if (mHeadsUpNotificationView.isSnoozed(pkg)) {
        return false;
    }
    Notification notification = sbn.getNotification();
    // we are snoozing
    if (isHeadsUpInSnooze()) {
        return false;
    }
    // some predicates to make the boolean logic legible
    boolean isNoisy = (notification.defaults & Notification.DEFAULT_SOUND) != 0 || (notification.defaults & Notification.DEFAULT_VIBRATE) != 0 || notification.sound != null || notification.vibrate != null;
    boolean isHighPriority = sbn.getScore() >= INTERRUPTION_THRESHOLD;
    boolean isFullscreen = notification.fullScreenIntent != null;
    // denying heads up by default
    int asHeadsUp = notification.extras.getInt(Notification.EXTRA_AS_HEADS_UP, Notification.HEADS_UP_NEVER);
    PackageManager pmUser = getPackageManagerForUser(sbn.getUser().getIdentifier());
    // but if it's a system package, heads up should still be shown
    boolean isSystemPackage = isThisASystemPackage(pkg, pmUser);
    boolean isAllowed = (asHeadsUp != Notification.HEADS_UP_NEVER) || isSystemPackage;
    if (DEBUG)
        Log.d(TAG, "package: " + pkg + ", isSystem: " + isSystemPackage + ", asHeadsUp: " + asHeadsUp + ", isAllowed: " + isAllowed);
    boolean accessibilityForcesLaunch = isFullscreen && mAccessibilityManager.isTouchExplorationEnabled();
    boolean keyguardIsShowing = (mStatusBarKeyguardViewManager.isShowing() || !mStatusBarKeyguardViewManager.isOccluded()) && mStatusBarKeyguardViewManager.isInputRestricted();
    boolean interrupt = (isFullscreen || (isHighPriority && isNoisy) || asHeadsUp == Notification.HEADS_UP_REQUESTED) && isAllowed && !accessibilityForcesLaunch && mPowerManager.isScreenOn() && !keyguardIsShowing;
    if (!interrupt) {
        boolean isHeadsUpPackage = (mNoMan.getHeadsUpNotificationsEnabledForPackage(pkg, sbn.getUid()) != Notification.HEADS_UP_NEVER) || isSystemPackage;
        if (DEBUG)
            Log.d(TAG, "package: " + pkg + ", isHeadsUpPackage: " + isHeadsUpPackage);
        boolean isExpanded = false;
        if (mStackScroller != null) {
            isExpanded = mStackScroller.getIsExpanded();
        }
        // Possibly a heads up package set from the user.
        interrupt = isHeadsUpPackage && !sbn.isOngoing() && mPowerManager.isScreenOn() && !accessibilityForcesLaunch && !isExpanded && !keyguardIsShowing;
        if (interrupt) {
            mHeadsUpPackageName = pkg;
        }
    }
    try {
        interrupt = interrupt && !mDreamManager.isDreaming();
    } catch (RemoteException e) {
        Log.d(TAG, "failed to query dream manager", e);
    }
    if (DEBUG)
        Log.d(TAG, "interrupt: " + interrupt);
    return interrupt;
}
#end_block

