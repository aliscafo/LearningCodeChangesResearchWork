1137
#method_before
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeCommands());
    try (Repository codeRepo = repoManager.openRepository(change.getProject());
        RevWalk codeRw = new RevWalk(codeRepo)) {
        for (PatchSet ps : db.patchSets().byChange(changeId)) {
            events.add(new PatchSetEvent(change, ps, codeRw));
            List<PatchLineComment> comments = PatchLineCommentsUtil.PLC_ORDER.sortedCopy(db.patchComments().byPatchSet(ps.getId()));
            for (PatchLineComment c : comments) {
                PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
                if (c.getStatus() == Status.PUBLISHED) {
                    events.add(e);
                } else {
                    draftCommentEvents.put(c.getAuthor(), e);
                }
            }
        }
    }
    for (PatchSetApproval psa : db.patchSetApprovals().byChange(changeId)) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : db.changeMessages().byChange(changeId)) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(db, manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(db, manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(db, manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(db, manager, plcel, change);
    }
    createStarredChangesRefs(db, changeId, manager.getAllUsersCommands(), manager.getAllUsersRepo());
    return execute(db, changeId, manager);
}
#method_after
@Override
public NoteDbChangeState rebuild(ReviewDb db, Change.Id changeId) throws NoSuchChangeException, IOException, OrmException, ConfigInvalidException {
    db = unwrapDb(db);
    Change change = db.changes().get(changeId);
    if (change == null) {
        throw new NoSuchChangeException(changeId);
    }
    NoteDbUpdateManager manager = updateManagerFactory.create(change.getProject());
    // We will rebuild all events, except for draft comments, in buckets based
    // on author and timestamp.
    List<Event> events = Lists.newArrayList();
    Multimap<Account.Id, PatchLineCommentEvent> draftCommentEvents = ArrayListMultimap.create();
    Repository changeMetaRepo = manager.getChangeRepo();
    events.addAll(getHashtagsEvents(change, manager));
    // Delete ref only after hashtags have been read
    deleteRef(change, changeMetaRepo, manager.getChangeCommands());
    try (Repository codeRepo = repoManager.openRepository(change.getProject());
        RevWalk codeRw = new RevWalk(codeRepo)) {
        for (PatchSet ps : db.patchSets().byChange(changeId)) {
            events.add(new PatchSetEvent(change, ps, codeRw));
            List<PatchLineComment> comments = PatchLineCommentsUtil.PLC_ORDER.sortedCopy(db.patchComments().byPatchSet(ps.getId()));
            for (PatchLineComment c : comments) {
                PatchLineCommentEvent e = new PatchLineCommentEvent(c, change, ps, patchListCache);
                if (c.getStatus() == Status.PUBLISHED) {
                    events.add(e);
                } else {
                    draftCommentEvents.put(c.getAuthor(), e);
                }
            }
        }
    }
    for (PatchSetApproval psa : db.patchSetApprovals().byChange(changeId)) {
        events.add(new ApprovalEvent(psa, change.getCreatedOn()));
    }
    Change noteDbChange = new Change(null, null, null, null, null);
    for (ChangeMessage msg : db.changeMessages().byChange(changeId)) {
        events.add(new ChangeMessageEvent(msg, noteDbChange, change.getCreatedOn()));
    }
    Collections.sort(events, EVENT_ORDER);
    events.add(new FinalUpdatesEvent(change, noteDbChange));
    EventList<Event> el = new EventList<>();
    for (Event e : events) {
        if (!el.canAdd(e)) {
            flushEventsToUpdate(db, manager, el, change);
            checkState(el.canAdd(e));
        }
        el.add(e);
    }
    flushEventsToUpdate(db, manager, el, change);
    EventList<PatchLineCommentEvent> plcel = new EventList<>();
    for (Account.Id author : draftCommentEvents.keys()) {
        for (PatchLineCommentEvent e : draftCommentEvents.get(author)) {
            if (!plcel.canAdd(e)) {
                flushEventsToDraftUpdate(db, manager, plcel, change);
                checkState(plcel.canAdd(e));
            }
            plcel.add(e);
        }
        flushEventsToDraftUpdate(db, manager, plcel, change);
    }
    return execute(db, changeId, manager);
}
#end_block

#method_before
private LoadHandle rebuildAndOpen(Repository repo) throws IOException {
    try {
        NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId());
        if (newState == null) {
            return super.openHandle(repo);
        }
        // if we need to reopen the repo.
        return LoadHandle.create(new RevWalk(repo), newState.getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException | ConfigInvalidException e) {
        throw new IOException(e);
    }
}
#method_after
private LoadHandle rebuildAndOpen(Repository repo) throws IOException {
    try {
        NoteDbChangeState newState = args.rebuilder.get().rebuild(args.db.get(), getChangeId());
        if (newState == null) {
            // May be null in tests.
            return super.openHandle(repo);
        }
        repo.scanForRepoChanges();
        return LoadHandle.create(new RevWalk(repo), newState.getChangeMetaId());
    } catch (NoSuchChangeException e) {
        return super.openHandle(repo);
    } catch (OrmException | ConfigInvalidException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string: %s", str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size());
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part: %s", p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#method_after
@VisibleForTesting
static NoteDbChangeState parse(Change.Id id, String str) {
    if (str == null) {
        return null;
    }
    List<String> parts = Splitter.on(',').splitToList(str);
    checkArgument(!parts.isEmpty(), "invalid state string for change %s: %s", id, str);
    ObjectId changeMetaId = ObjectId.fromString(parts.get(0));
    Map<Account.Id, ObjectId> draftIds = Maps.newHashMapWithExpectedSize(parts.size() - 1);
    Splitter s = Splitter.on('=');
    for (int i = 1; i < parts.size(); i++) {
        String p = parts.get(i);
        List<String> draftParts = s.splitToList(p);
        checkArgument(draftParts.size() == 2, "invalid draft state part for change %s: %s", id, p);
        draftIds.put(Account.Id.parse(draftParts.get(0)), ObjectId.fromString(draftParts.get(1)));
    }
    return new NoteDbChangeState(id, changeMetaId, draftIds);
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Blocked on " + name);
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText(Util.M.needs(name));
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText(Util.M.blockedOn(name));
                        canSubmit = false;
                    }
                    break;
                case MAY:
                case OK:
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
@Override
public GeneralPreferencesInfo getPreferences() throws RestApiException {
    GetPreferences myGetPreferences = getPreferences.get();
    try {
        return myGetPreferences.apply(account);
    } catch (OrmException | IOException | ConfigInvalidException e) {
        throw new RestApiException("Cannot query preferences", e);
    }
}
#method_after
@Override
public GeneralPreferencesInfo getPreferences() throws RestApiException {
    return getPreferences.apply(account);
}
#end_block

#method_before
private Handler appHandler() {
    DebugRenderer renderer = new DebugRenderer(STATIC_PREFIX, Arrays.asList(cfg.getStringList("gitiles", null, "customTemplates")), new File(sourceRoot, "gitiles-servlet/src/main/resources/com/google/gitiles/templates").getPath(), firstNonNull(cfg.getString("gitiles", null, "siteTitle"), "Gitiles"));
    String docRoot = cfg.getString("gitiles", null, "docroot");
    Servlet servlet;
    if (!Strings.isNullOrEmpty(docRoot)) {
        servlet = createRootedDocServlet(renderer, docRoot);
    } else {
        servlet = new GitilesServlet(cfg, renderer, null, null, null, null, null, null, null);
    }
    ServletContextHandler handler = new ServletContextHandler();
    handler.setContextPath("");
    handler.addServlet(new ServletHolder(servlet), "/*");
    return handler;
}
#method_after
private Handler appHandler() {
    DebugRenderer renderer = new DebugRenderer(STATIC_PREFIX, Arrays.asList(cfg.getStringList("gitiles", null, "customTemplates")), sourceRoot.resolve("gitiles-servlet/src/main/resources/com/google/gitiles/templates").toString(), firstNonNull(cfg.getString("gitiles", null, "siteTitle"), "Gitiles"));
    String docRoot = cfg.getString("gitiles", null, "docroot");
    Servlet servlet;
    if (!Strings.isNullOrEmpty(docRoot)) {
        servlet = createRootedDocServlet(renderer, docRoot);
    } else {
        servlet = new GitilesServlet(cfg, renderer, null, null, null, null, null, null, null);
    }
    ServletContextHandler handler = new ServletContextHandler();
    handler.setContextPath("");
    handler.addServlet(new ServletHolder(servlet), "/*");
    return handler;
}
#end_block

#method_before
private Handler staticHandler() throws IOException {
    File staticRoot = new File(sourceRoot, "gitiles-servlet/src/main/resources/com/google/gitiles/static");
    ResourceHandler rh = new ResourceHandler();
    try {
        rh.setBaseResource(new FileResource(staticRoot.toURI().toURL()));
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    rh.setWelcomeFiles(new String[] {});
    rh.setDirectoriesListed(false);
    ContextHandler handler = new ContextHandler("/+static");
    handler.setHandler(rh);
    return handler;
}
#method_after
private Handler staticHandler() throws IOException {
    Path staticRoot = sourceRoot.resolve("gitiles-servlet/src/main/resources/com/google/gitiles/static");
    ResourceHandler rh = new ResourceHandler();
    try {
        rh.setBaseResource(new FileResource(staticRoot.toUri().toURL()));
    } catch (URISyntaxException e) {
        throw new IOException(e);
    }
    rh.setWelcomeFiles(new String[] {});
    rh.setDirectoriesListed(false);
    ContextHandler handler = new ContextHandler("/+static");
    handler.setHandler(rh);
    return handler;
}
#end_block

#method_before
public static void visitChangedEntries(Repository repo, RevCommit c, TreeWalkVisitor visitor) throws IOException {
    try (TreeWalk tw = new TreeWalk(repo);
        RevWalk rw = new RevWalk(repo)) {
        tw.setRecursive(true);
        tw.setFilter(TreeFilter.ANY_DIFF);
        tw.addTree(c.getTree());
        if (c.getParentCount() > 0) {
            for (RevCommit p : c.getParents()) {
                if (p.getTree() == null) {
                    rw.parseHeaders(p);
                }
                tw.addTree(p.getTree());
            }
            while (tw.next()) {
                if (isDifferentToAllParents(c, tw)) {
                    visitor.onVisit(tw);
                }
            }
        } else {
            while (tw.next()) {
                visitor.onVisit(tw);
            }
        }
    }
}
#method_after
public static void visitChangedEntries(Repository repo, RevCommit c, TreeWalkVisitor visitor) throws IOException {
    try (TreeWalk tw = new TreeWalk(repo)) {
        tw.setRecursive(true);
        tw.setFilter(TreeFilter.ANY_DIFF);
        tw.addTree(c.getTree());
        if (c.getParentCount() > 0) {
            @SuppressWarnings("resource")
            RevWalk rw = null;
            try {
                for (RevCommit p : c.getParents()) {
                    if (p.getTree() == null) {
                        if (rw == null) {
                            rw = new RevWalk(repo);
                        }
                        rw.parseHeaders(p);
                    }
                    tw.addTree(p.getTree());
                }
            } finally {
                if (rw != null) {
                    rw.close();
                }
            }
            while (tw.next()) {
                if (isDifferentToAllParents(c, tw)) {
                    visitor.onVisit(tw);
                }
            }
        } else {
            while (tw.next()) {
                visitor.onVisit(tw);
            }
        }
    }
}
#end_block

#method_before
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().submit();
}
#method_after
@Test
public void submit() throws Exception {
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    gApi.changes().id(changeId).current().submit();
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test(expected = AuthException.class)
public void submitOnBehalfOf() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    gApi.changes().id(project.get() + "~master~" + r.getChangeId()).current().submit(in);
}
#method_after
@Test
public void submitOnBehalfOf() throws Exception {
    allowSubmitOnBehalfOf();
    PushOneCommit.Result r = createChange();
    String changeId = project.get() + "~master~" + r.getChangeId();
    gApi.changes().id(changeId).current().review(ReviewInput.approve());
    SubmitInput in = new SubmitInput();
    in.onBehalfOf = admin2.email;
    gApi.changes().id(changeId).current().submit(in);
    assertThat(gApi.changes().id(changeId).get().status).isEqualTo(ChangeStatus.MERGED);
}
#end_block

#method_before
@Test
public void mergeable() throws Exception {
    ObjectId initial = repo().getRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 1 content");
    PushOneCommit.Result r1 = push1.to("refs/for/master");
    assertMergeable(r1.getChangeId(), true);
    merge(r1);
    // Reset HEAD to initial so the new change is a merge conflict.
    RefUpdate ru = repo().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 2 content");
    PushOneCommit.Result r2 = push2.to("refs/for/master");
    assertMergeable(r2.getChangeId(), false);
// TODO(dborowitz): Test for other-branches.
}
#method_after
@Test
public void mergeable() throws Exception {
    ObjectId initial = repo().exactRef(HEAD).getLeaf().getObjectId();
    PushOneCommit push1 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 1 content");
    PushOneCommit.Result r1 = push1.to("refs/for/master");
    assertMergeable(r1.getChangeId(), true);
    merge(r1);
    // Reset HEAD to initial so the new change is a merge conflict.
    RefUpdate ru = repo().updateRef(HEAD);
    ru.setNewObjectId(initial);
    assertThat(ru.forceUpdate()).isEqualTo(RefUpdate.Result.FORCED);
    PushOneCommit push2 = pushFactory.create(db, admin.getIdent(), testRepo, PushOneCommit.SUBJECT, PushOneCommit.FILE_NAME, "push 2 content");
    PushOneCommit.Result r2 = push2.to("refs/for/master");
    assertMergeable(r2.getChangeId(), false);
// TODO(dborowitz): Test for other-branches.
}
#end_block

#method_before
@Test
public void patch() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeApi changeApi = gApi.changes().id(r.getChangeId());
    BinaryResult bin = changeApi.revision(r.getCommit().name()).patch();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), UTF_8);
    ChangeInfo change = changeApi.get();
    RevisionInfo rev = change.revisions.get(change.currentRevision);
    DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US);
    String date = df.format(rev.commit.author.date);
    assertThat(res).isEqualTo(String.format(PATCH, r.getCommitId().name(), date, r.getChangeId()));
}
#method_after
@Test
public void patch() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeApi changeApi = gApi.changes().id(r.getChangeId());
    BinaryResult bin = changeApi.revision(r.getCommit().name()).patch();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), UTF_8);
    ChangeInfo change = changeApi.get();
    RevisionInfo rev = change.revisions.get(change.currentRevision);
    DateFormat df = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z", Locale.US);
    String date = df.format(rev.commit.author.date);
    assertThat(res).isEqualTo(String.format(PATCH, r.getCommit().name(), date, r.getChangeId()));
}
#end_block

#method_before
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    try {
        cfg.commit(md);
    } finally {
        md.close();
    }
}
#method_after
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        cfg.commit(md);
    }
}
#end_block

#method_before
@Override
protected void merge(PushOneCommit.Result r) throws Exception {
    super.merge(r);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.getRef("refs/heads/master").getObjectId()).isEqualTo(r.getCommitId());
    }
}
#method_after
@Override
protected void merge(PushOneCommit.Result r) throws Exception {
    super.merge(r);
    try (Repository repo = repoManager.openRepository(project)) {
        assertThat(repo.exactRef("refs/heads/master").getObjectId()).isEqualTo(r.getCommit());
    }
}
#end_block

#method_before
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        commonServer.stop();
        commonServer = null;
    }
    TempFileUtil.cleanup();
}
#method_after
@AfterClass
public static void stopCommonServer() throws Exception {
    if (commonServer != null) {
        try {
            commonServer.stop();
        } finally {
            commonServer = null;
        }
    }
    TempFileUtil.cleanup();
}
#end_block

#method_before
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    if (isNoteDbTestEnabled()) {
        NotesMigration.setAllEnabledConfig(baseConfig);
    }
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#method_after
protected void beforeTest(Description description) throws Exception {
    GerritServer.Description classDesc = GerritServer.Description.forTestClass(description, configName);
    GerritServer.Description methodDesc = GerritServer.Description.forTestMethod(description, configName);
    baseConfig.setString("gerrit", null, "tempSiteDir", tempSiteDir.getRoot().getPath());
    if (classDesc.equals(methodDesc)) {
        if (commonServer == null) {
            commonServer = GerritServer.start(classDesc, baseConfig);
        }
        server = commonServer;
    } else {
        server = GerritServer.start(methodDesc, baseConfig);
    }
    server.getTestInjector().injectMembers(this);
    notesMigration.setFromEnv();
    Transport.register(inProcessProtocol);
    toClose = Collections.synchronizedList(new ArrayList<Repository>());
    admin = accounts.admin();
    user = accounts.user();
    // Evict cached user state in case tests modify it.
    accountCache.evict(admin.getId());
    accountCache.evict(user.getId());
    adminSession = new RestSession(server, admin);
    userSession = new RestSession(server, user);
    initSsh(admin);
    db = reviewDbProvider.open();
    Context ctx = newRequestContext(admin);
    atrScope.set(ctx);
    sshSession = ctx.getSession();
    sshSession.open();
    resourcePrefix = UNSAFE_PROJECT_NAME.matcher(description.getClassName() + "_" + description.getMethodName() + "_").replaceAll("");
    project = createProject(projectInput(description));
    testRepo = cloneProject(project, getCloneAsAccount(description));
}
#end_block

#method_before
protected TestRepository<?>.CommitBuilder amendBuilder() throws Exception {
    ObjectId head = repo().getRef("HEAD").getObjectId();
    TestRepository<?>.CommitBuilder b = testRepo.amendRef("HEAD");
    Optional<String> id = GitUtil.getChangeId(testRepo, head);
    // preserve an existing Change-Id. Tests probably want this.
    if (id.isPresent()) {
        b.insertChangeId(id.get().substring(1));
    } else {
        b.insertChangeId();
    }
    return b;
}
#method_after
protected TestRepository<?>.CommitBuilder amendBuilder() throws Exception {
    ObjectId head = repo().exactRef("HEAD").getObjectId();
    TestRepository<?>.CommitBuilder b = testRepo.amendRef("HEAD");
    Optional<String> id = GitUtil.getChangeId(testRepo, head);
    // preserve an existing Change-Id. Tests probably want this.
    if (id.isPresent()) {
        b.insertChangeId(id.get().substring(1));
    } else {
        b.insertChangeId();
    }
    return b;
}
#end_block

#method_before
protected PushOneCommit.Result createChange() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    return result;
}
#method_after
protected PushOneCommit.Result createChange() throws Exception {
    return createChange("refs/for/master");
}
#end_block

#method_before
protected PushOneCommit.Result createChange() throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to("refs/for/master");
    result.assertOkStatus();
    return result;
}
#method_after
protected PushOneCommit.Result createChange(String ref) throws Exception {
    PushOneCommit push = pushFactory.create(db, admin.getIdent(), testRepo);
    PushOneCommit.Result result = push.to(ref);
    result.assertOkStatus();
    return result;
}
#end_block

#method_before
protected Context setApiUserAnonymous() {
    return atrScope.newContext(reviewDbProvider, null, anonymousUser.get());
}
#method_after
protected Context setApiUserAnonymous() {
    return atrScope.set(atrScope.newContext(reviewDbProvider, null, anonymousUser.get()));
}
#end_block

#method_before
protected void setUseContributorAgreements(InheritableBoolean value) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    ProjectConfig config = ProjectConfig.read(md);
    config.getProject().setUseContributorAgreements(value);
    config.commit(md);
    projectCache.evict(config.getProject());
}
#method_after
protected void setUseContributorAgreements(InheritableBoolean value) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().setUseContributorAgreements(value);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
protected void setUseSignedOffBy(InheritableBoolean value) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    ProjectConfig config = ProjectConfig.read(md);
    config.getProject().setUseSignedOffBy(value);
    config.commit(md);
    projectCache.evict(config.getProject());
}
#method_after
protected void setUseSignedOffBy(InheritableBoolean value) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        ProjectConfig config = ProjectConfig.read(md);
        config.getProject().setUseSignedOffBy(value);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
protected void saveProjectConfig(Project.NameKey p, ProjectConfig cfg) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(p);
    try {
        cfg.commit(md);
    } finally {
        md.close();
    }
    projectCache.evict(cfg.getProject());
}
#method_after
protected void saveProjectConfig(Project.NameKey p, ProjectConfig cfg) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(p)) {
        cfg.commit(md);
    }
    projectCache.evict(cfg.getProject());
}
#end_block

#method_before
protected void grant(String permission, Project.NameKey project, String ref, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    md.setMessage(String.format("Grant %s on %s", permission, ref));
    ProjectConfig config = ProjectConfig.read(md);
    AccessSection s = config.getAccessSection(ref, true);
    Permission p = s.getPermission(permission, true);
    AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
    PermissionRule rule = new PermissionRule(config.resolve(adminGroup));
    rule.setForce(force);
    p.add(rule);
    config.commit(md);
    projectCache.evict(config.getProject());
}
#method_after
protected void grant(String permission, Project.NameKey project, String ref, boolean force) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        md.setMessage(String.format("Grant %s on %s", permission, ref));
        ProjectConfig config = ProjectConfig.read(md);
        AccessSection s = config.getAccessSection(ref, true);
        Permission p = s.getPermission(permission, true);
        AccountGroup adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators"));
        PermissionRule rule = new PermissionRule(config.resolve(adminGroup));
        rule.setForce(force);
        p.add(rule);
        config.commit(md);
        projectCache.evict(config.getProject());
    }
}
#end_block

#method_before
public ChangeControl controlFor(Change change, CurrentUser user) throws NoSuchChangeException {
    final Project.NameKey projectKey = change.getProject();
    try {
        return projectControl.controlFor(projectKey, user).controlFor(change);
    } catch (NoSuchProjectException e) {
        throw new NoSuchChangeException(change.getId(), e);
    } catch (IOException e) {
        // TODO: propagate this exception
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public ChangeControl controlFor(ReviewDb db, Project.NameKey project, Change.Id changeId, CurrentUser user) throws NoSuchChangeException, OrmException {
    return controlFor(notesFactory.create(db, project, changeId), user);
}
#end_block

#method_before
public ChangeControl validateFor(Change change, CurrentUser user) throws NoSuchChangeException, OrmException {
    ChangeControl c = controlFor(change, user);
    if (!c.isVisible(db.get())) {
        throw new NoSuchChangeException(c.getChange().getId());
    }
    return c;
}
#method_after
public ChangeControl validateFor(ReviewDb db, Change.Id changeId, CurrentUser user) throws NoSuchChangeException, OrmException {
    return validateFor(db, notesFactory.createChecked(changeId), user);
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, MoveInput input) throws AuthException, RestApiException, ResourceConflictException, OrmException, IOException {
    ChangeControl control = req.getControl();
    Change change = req.getChange();
    if (!control.canMoveTo(RefNames.fullName(input.destination), dbProvider.get())) {
        throw new AuthException("Move not permitted");
    } else if (change.getStatus() != Status.NEW && change.getStatus() != Status.DRAFT) {
        throw new ResourceConflictException("Change is " + status(change));
    }
    Project.NameKey projectKey = change.getProject();
    final PatchSet.Id patchSetId = change.currentPatchSetId();
    try (Repository repo = repoManager.openRepository(projectKey);
        RevWalk revWalk = new RevWalk(repo)) {
        String currPatchsetRev = dbProvider.get().patchSets().get(patchSetId).getRevision().get();
        RevCommit currPatchsetRevCommit = revWalk.parseCommit(ObjectId.fromString((currPatchsetRev)));
        if (currPatchsetRevCommit.getParentCount() > 1) {
            throw new ResourceConflictException("Merge commit cannot be moved");
        }
        ObjectId refId = repo.resolve(input.destination);
        // Check if destination ref exists in project repo
        if (refId == null) {
            throw new ResourceConflictException("Destination " + input.destination + " not found in the project");
        }
        RevCommit refCommit = revWalk.parseCommit(refId);
        if (revWalk.isMergedInto(currPatchsetRevCommit, refCommit)) {
            throw new ResourceConflictException("Current patchset revision is reachable from tip of " + input.destination);
        }
    }
    Change.Key changeKey = change.getKey();
    final Branch.NameKey destKey = new Branch.NameKey(projectKey, input.destination);
    List<Change> destChanges = asChanges(queryProvider.get().byBranchKey(destKey, changeKey));
    if (!destChanges.isEmpty()) {
        for (Change destChange : destChanges) {
            if (destChange.getId().get() == change.getId().get()) {
                throw new ResourceConflictException("Change is already destined for branch");
            }
        }
        throw new ResourceConflictException("Destination " + destKey.getShortName() + " has a different change with same change key " + changeKey);
    }
    Branch.NameKey changePrevDest = change.getDest();
    ReviewDb db = dbProvider.get();
    db.changes().beginTransaction(change.getId());
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.currentPatchSetId().equals(patchSetId)) {
                    change.setDest(destKey);
                    ChangeUtil.updated(change);
                    return change;
                }
                return null;
            }
        });
        if (change == null) {
            throw new ResourceConflictException("Patch set is not current");
        }
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Patch set ");
    msgBuf.append(patchSetId.get());
    msgBuf.append(": Change destination moved from ");
    msgBuf.append(changePrevDest.getShortName());
    msgBuf.append(" to ");
    msgBuf.append(destKey.getShortName());
    if (!Strings.isNullOrEmpty(input.message)) {
        msgBuf.append("\n\n");
        msgBuf.append(input.message);
    }
    ReviewInput review = new ReviewInput();
    review.message = Strings.emptyToNull(msgBuf.toString());
    gApi.get().changes().id(change.getId().get()).revision(db.patchSets().get(patchSetId).getRevision().get()).review(review);
    return json.create(ChangeJson.NO_OPTIONS).format(change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, MoveInput input) throws RestApiException, OrmException, UpdateException {
    ChangeControl control = req.getControl();
    input.destination_branch = RefNames.fullName(input.destination_branch);
    if (!control.canMoveTo(input.destination_branch, dbProvider.get())) {
        throw new AuthException("Move not permitted");
    }
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), control.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), new Op(control, input));
        u.execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(req.getChange());
}
#end_block

#method_before
@Test
public void moveChange_shortRef() throws Exception {
    // Move change to a different branch using short ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.getShortName());
    assertThat(r.getChange().change().getDest().equals(newBranch));
}
#method_after
@Test
public void moveChange_shortRef() throws Exception {
    // Move change to a different branch using short ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.getShortName());
    assertThat(r.getChange().change().getDest()).isEqualTo(newBranch);
}
#end_block

#method_before
@Test
public void moveChange_fullRef() throws Exception {
    // Move change to a different branch using full ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.get());
    assertThat(r.getChange().change().getDest().equals(newBranch));
}
#method_after
@Test
public void moveChange_fullRef() throws Exception {
    // Move change to a different branch using full ref name
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    move(r.getChangeId(), newBranch.get());
    assertThat(r.getChange().change().getDest()).isEqualTo(newBranch);
}
#end_block

#method_before
@Test
public void moveChangeWithMessage() throws Exception {
    // Provide a message using --message flag (needed?)
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    String moveMessage = "Moving for the move test";
    move(r.getChangeId(), newBranch.get(), moveMessage);
    assertThat(r.getChange().change().getDest().equals(newBranch));
    assertThat(r.getChange().messages().get(1).equals(moveMessage));
}
#method_after
@Test
public void moveChangeWithMessage() throws Exception {
    // Provide a message using --message flag
    PushOneCommit.Result r = createChange();
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    String moveMessage = "Moving for the move test";
    move(r.getChangeId(), newBranch.get(), moveMessage);
    assertThat(r.getChange().change().getDest()).isEqualTo(newBranch);
    StringBuilder expectedMessage = new StringBuilder();
    expectedMessage.append("Change destination moved from master to moveTest");
    expectedMessage.append("\n\n");
    expectedMessage.append(moveMessage);
    assertThat(r.getChange().messages().get(1).getMessage()).isEqualTo(expectedMessage.toString());
}
#end_block

#method_before
@Test
public void moveChangeToSameRefAsCurrent() throws Exception {
    // Move change to the branch same as change's destination
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already destined for branch");
    move(r.getChangeId(), r.getChange().change().getDest().get());
}
#method_after
@Test
public void moveChangeToSameRefAsCurrent() throws Exception {
    // Move change to the branch same as change's destination
    PushOneCommit.Result r = createChange();
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Change is already destined for the specified branch");
    move(r.getChangeId(), r.getChange().change().getDest().get());
}
#end_block

#method_before
@Test
public void moveMergeCommitChange() throws Exception {
    // Move a change which has a merge commit as the current PS
    // Create a merge commit and push for review
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    TestRepository<?>.CommitBuilder commitBuilder = testRepo.branch("HEAD").commit().insertChangeId();
    commitBuilder.parent(r1.getCommit()).parent(r2.getCommit()).message("Move change Merge Commit").author(admin.getIdent()).committer(new PersonIdent(admin.getIdent(), testRepo.getClock()));
    RevCommit c = commitBuilder.create();
    pushHead(testRepo, "refs/for/master", false, false);
    // Try to move the merge commit to another branch
    Branch.NameKey newBranch = new Branch.NameKey(r1.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Merge commit cannot be moved");
    move(GitUtil.getChangeId(testRepo, c).get(), newBranch.get());
}
#method_after
@Test
public void moveMergeCommitChange() throws Exception {
    // Move a change which has a merge commit as the current PS
    // Create a merge commit and push for review
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    TestRepository<?>.CommitBuilder commitBuilder = testRepo.branch("HEAD").commit().insertChangeId();
    commitBuilder.parent(r1.getCommit()).parent(r2.getCommit()).message("Move change Merge Commit").author(admin.getIdent()).committer(new PersonIdent(admin.getIdent(), testRepo.getDate()));
    RevCommit c = commitBuilder.create();
    pushHead(testRepo, "refs/for/master", false, false);
    // Try to move the merge commit to another branch
    Branch.NameKey newBranch = new Branch.NameKey(r1.getChange().change().getProject(), "moveTest");
    createBranch(newBranch);
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Merge commit cannot be moved");
    move(GitUtil.getChangeId(testRepo, c).get(), newBranch.get());
}
#end_block

#method_before
@Test
public void moveChangeToBranchThatContainsCurrentCommit() throws Exception {
    // Move change to a branch for which current PS revision is reachable from
    // tip
    // Create a change
    PushOneCommit.Result r = createChange();
    int changeNum = r.getChange().change().getChangeId();
    // Create a branch with that same commit
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    BranchInput bi = new BranchInput();
    bi.revision = r.getCommitId().name();
    gApi.projects().name(newBranch.getParentKey().get()).branch(newBranch.get()).create(bi);
    // Try to move the change to the branch with the same commit
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Current patchset revision is reachable from tip of " + newBranch.get());
    move(changeNum, newBranch.get());
}
#method_after
@Test
public void moveChangeToBranchThatContainsCurrentCommit() throws Exception {
    // Move change to a branch for which current PS revision is reachable from
    // tip
    // Create a change
    PushOneCommit.Result r = createChange();
    int changeNum = r.getChange().change().getChangeId();
    // Create a branch with that same commit
    Branch.NameKey newBranch = new Branch.NameKey(r.getChange().change().getProject(), "moveTest");
    BranchInput bi = new BranchInput();
    bi.revision = r.getCommit().name();
    gApi.projects().name(newBranch.getParentKey().get()).branch(newBranch.get()).create(bi);
    // Try to move the change to the branch with the same commit
    exception.expect(ResourceConflictException.class);
    exception.expectMessage("Current patchset revision is reachable from tip of " + newBranch.get());
    move(changeNum, newBranch.get());
}
#end_block

#method_before
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    MetaDataUpdate md = metaDataUpdateFactory.create(project);
    try {
        cfg.commit(md);
    } finally {
        md.close();
    }
}
#method_after
private void saveProjectConfig(ProjectConfig cfg) throws Exception {
    try (MetaDataUpdate md = metaDataUpdateFactory.create(project)) {
        cfg.commit(md);
    }
}
#end_block

#method_before
private void move(String changeId, String destination, String message) throws RestApiException {
    MoveInput in = new MoveInput();
    in.destination = destination;
    in.message = message;
    gApi.changes().id(changeId).move(in);
}
#method_after
private void move(String changeId, String destination, String message) throws RestApiException {
    MoveInput in = new MoveInput();
    in.destination_branch = destination;
    in.message = message;
    gApi.changes().id(changeId).move(in);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "rebuild.notedb").to(Rebuild.class);
    post(CHANGE_KIND, "move").to(Move.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
@Override
public String id() {
    return Integer.toString(change.getChange().getId().get());
}
#method_after
@Override
public String id() {
    return Integer.toString(change.getId().get());
}
#end_block

#method_before
@Override
public void move(String destination) throws RestApiException {
    MoveInput input = new MoveInput();
    input.destination = destination;
    move(input);
}
#method_after
@Override
public void move(String destination) throws RestApiException {
    MoveInput in = new MoveInput();
    in.destination_branch = destination;
    move(in);
}
#end_block

#method_before
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#method_after
@Override
public void move(MoveInput in) throws RestApiException {
    try {
        move.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot move change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException | NoSuchChangeException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        SuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        SuggestChangeReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
private Result execute(String ref) throws Exception {
    RevCommit c = commitBuilder.create();
    if (changeId == null) {
        changeId = GitUtil.getChangeId(testRepo, c).get();
    }
    if (tag != null) {
        TagCommand tagCommand = testRepo.git().tag().setName(tag.name);
        if (tag instanceof AnnotatedTag) {
            AnnotatedTag annotatedTag = (AnnotatedTag) tag;
            tagCommand.setAnnotated(true).setMessage(annotatedTag.message).setTagger(annotatedTag.tagger);
        } else {
            tagCommand.setAnnotated(false);
        }
        tagCommand.call();
    }
    return new Result(ref, pushHead(testRepo, ref, tag != null, force), c, subject);
}
#method_after
public Result execute(String ref) throws Exception {
    RevCommit c = commitBuilder.create();
    if (changeId == null) {
        changeId = GitUtil.getChangeId(testRepo, c).get();
    }
    if (tag != null) {
        TagCommand tagCommand = testRepo.git().tag().setName(tag.name);
        if (tag instanceof AnnotatedTag) {
            AnnotatedTag annotatedTag = (AnnotatedTag) tag;
            tagCommand.setAnnotated(true).setMessage(annotatedTag.message).setTagger(annotatedTag.tagger);
        } else {
            tagCommand.setAnnotated(false);
        }
        tagCommand.call();
    }
    return new Result(ref, pushHead(testRepo, ref, tag != null, force), c, subject);
}
#end_block

#method_before
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    assertReviewers(c, expectedReviewers);
}
#method_after
public void assertChange(Change.Status expectedStatus, String expectedTopic, TestAccount... expectedReviewers) throws OrmException, NoSuchChangeException {
    Change c = getChange().change();
    assertThat(c.getSubject()).isEqualTo(resSubj);
    assertThat(c.getStatus()).isEqualTo(expectedStatus);
    assertThat(Strings.emptyToNull(c.getTopic())).isEqualTo(expectedTopic);
    assertReviewers(c, expectedReviewers);
}
#end_block

#method_before
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException {
    Iterable<Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.create(c)).values();
    assertThat(actualIds).containsExactlyElementsIn(Sets.newHashSet(TestAccount.ids(expectedReviewers)));
}
#method_after
private void assertReviewers(Change c, TestAccount... expectedReviewers) throws OrmException, NoSuchChangeException {
    Iterable<Account.Id> actualIds = approvalsUtil.getReviewers(db, notesFactory.createChecked(db, c)).values();
    assertThat(actualIds).containsExactlyElementsIn(Sets.newHashSet(TestAccount.ids(expectedReviewers)));
}
#end_block

#method_before
static int toMask(final KeyPressEvent event) {
    int mask = event.getUnicodeCharCode();
    if (mask == 0) {
        mask = event.getNativeEvent().getKeyCode();
    }
    if (event.isAltKeyDown()) {
        mask |= KeyCommand.M_ALT;
    }
    if (event.isControlKeyDown()) {
        mask |= KeyCommand.M_CTRL;
    }
    if (event.isMetaKeyDown()) {
        mask |= KeyCommand.M_META;
    }
    return mask;
}
#method_after
static int toMask(final KeyPressEvent event) {
    int mask = event.getUnicodeCharCode();
    if (mask == 0) {
        mask = event.getNativeEvent().getKeyCode();
    }
    if (event.isControlKeyDown()) {
        mask |= KeyCommand.M_CTRL;
    }
    if (event.isMetaKeyDown()) {
        mask |= KeyCommand.M_META;
    }
    return mask;
}
#end_block

#method_before
protected String currentTimeFormatted() {
    PersonIdent p = new PersonIdent(new PersonIdent(repo.getRepository()));
    return new DateFormatter(Optional.<TimeZone>absent(), DateFormatter.Format.ISO).format(p);
}
#method_after
protected String currentTimeFormatted() {
    PersonIdent p = new PersonIdent(repo.getRepository());
    return new DateFormatter(Optional.<TimeZone>absent(), DateFormatter.Format.ISO).format(p);
}
#end_block

#method_before
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(DeleteVoteSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(RevertedSender.Factory.class);
    factory(RestoredSender.Factory.class);
}
#method_after
@Override
protected void configure() {
    factory(AbandonedSender.Factory.class);
    factory(CommentSender.Factory.class);
    factory(DeleteVoteSender.Factory.class);
    factory(RestoredSender.Factory.class);
    factory(RevertedSender.Factory.class);
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    ChangeControl ctl = r.getControl();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), ctl.getUser().asIdentifiedUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), r.getControl().getUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getReviewerUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    ChangeControl ctl = ctx.getChangeControl();
    psId = change.currentPatchSetId();
    ps = ctx.getDb().patchSets().get(psId);
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(user.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                categories.put(a.getLabel(), a.getValue());
                ctx.getChangeUpdate().setPatchSetId(psId);
                ctx.getChangeUpdate().removeApproval(label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ChangeUtil.bumpRowVersionNotLastUpdatedOn(change.getId(), ctx.getDb());
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    ChangeControl ctl = ctx.getControl();
    change = ctl.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ps = psUtil.current(db.get(), ctl.getNotes());
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    // get all of the current approvals
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Map<String, Short> currentApprovals = new HashMap<>();
    for (LabelType lt : labelTypes.getLabelTypes()) {
        currentApprovals.put(lt.getName(), (short) 0);
        for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
            if (lt.getLabelId().equals(a.getLabelId())) {
                currentApprovals.put(lt.getName(), a.getValue());
            }
        }
    }
    // removing votes so we need to determine the new set of approval scores
    newApprovals.putAll(currentApprovals);
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                // set the approval to 0 if vote is being removed
                newApprovals.put(a.getLabel(), (short) 0);
                // set old value only if the vote changed
                oldApprovals.put(a.getLabel(), a.getValue());
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getUpdate(psId).removeApprovalFor(a.getAccountId(), label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ctx.saveChange();
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), ctx.getUser().asIdentifiedUser().getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(psId), changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    try {
        ReplyToChangeSender cm = deleteVoteSenderFactory.create(change.getId());
        if (user.getAccountId() != null) {
            cm.setFrom(user.getAccountId());
        }
        cm.setChangeMessage(changeMessage);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), categories, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#method_after
@Override
public void postUpdate(Context ctx) {
    if (changeMessage == null) {
        return;
    }
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    try {
        ReplyToChangeSender cm = deleteVoteSenderFactory.create(ctx.getProject(), change.getId());
        cm.setFrom(user.getAccountId());
        cm.setChangeMessage(changeMessage);
        cm.send();
    } catch (Exception e) {
        log.error("Cannot email update for change " + change.getId(), e);
    }
    try {
        hooks.doCommentAddedHook(change, user.getAccount(), ps, changeMessage.getMessage(), newApprovals, oldApprovals, ctx.getDb());
    } catch (OrmException e) {
        log.warn("ChangeHook.doCommentAddedHook delivery failed", e);
    }
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    Connection connection = schema.getConnection();
    String tableName = "accounts";
    String emailStrategy = "email_strategy";
    Set<String> columns = schema.getDialect().listColumns(connection, tableName);
    Map<Account.Id, GeneralPreferencesInfo> imports = new HashMap<>();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("select " + "account_id, " + "maximum_page_size, " + "show_site_header, " + "use_flash_clipboard, " + "download_url, " + "download_command, " + (columns.contains(emailStrategy) ? emailStrategy + ", " : "copy_self_on_email, ") + "date_format, " + "time_format, " + "relative_date_in_change_table, " + "diff_view, " + "size_bar_in_change_table, " + "legacycid_in_change_table, " + "review_category_strategy, " + "mute_common_path_prefixes " + "from accounts")) {
        while (rs.next()) {
            GeneralPreferencesInfo p = new GeneralPreferencesInfo();
            Account.Id accountId = new Account.Id(rs.getInt(1));
            p.changesPerPage = (int) rs.getShort(2);
            p.showSiteHeader = toBoolean(rs.getString(3));
            p.useFlashClipboard = toBoolean(rs.getString(4));
            p.downloadScheme = convertToModernNames(rs.getString(5));
            p.downloadCommand = toDownloadCommand(rs.getString(6));
            p.emailStrategy = toEmailStrategy(rs.getString(7), columns.contains(emailStrategy));
            p.dateFormat = toDateFormat(rs.getString(8));
            p.timeFormat = toTimeFormat(rs.getString(9));
            p.relativeDateInChangeTable = toBoolean(rs.getString(10));
            p.diffView = toDiffView(rs.getString(11));
            p.sizeBarInChangeTable = toBoolean(rs.getString(12));
            p.legacycidInChangeTable = toBoolean(rs.getString(13));
            p.reviewCategoryStrategy = toReviewCategoryStrategy(rs.getString(14));
            p.muteCommonPathPrefixes = toBoolean(rs.getString(15));
            imports.put(accountId, p);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = mgr.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        for (Map.Entry<Account.Id, GeneralPreferencesInfo> e : imports.entrySet()) {
            try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru)) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                VersionedAccountPreferences p = VersionedAccountPreferences.forUser(e.getKey());
                p.load(md);
                storeSection(p.getConfig(), UserConfigSections.GENERAL, null, e.getValue(), GeneralPreferencesInfo.defaults());
                p.commit(md);
            }
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    Connection connection = schema.getConnection();
    String tableName = "accounts";
    String emailStrategy = "email_strategy";
    Set<String> columns = schema.getDialect().listColumns(connection, tableName);
    Map<Account.Id, GeneralPreferencesInfo> imports = new HashMap<>();
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement();
        ResultSet rs = stmt.executeQuery("select " + "account_id, " + "maximum_page_size, " + "show_site_header, " + "use_flash_clipboard, " + "download_url, " + "download_command, " + (columns.contains(emailStrategy) ? emailStrategy + ", " : "copy_self_on_email, ") + "date_format, " + "time_format, " + "relative_date_in_change_table, " + "diff_view, " + "size_bar_in_change_table, " + "legacycid_in_change_table, " + "review_category_strategy, " + "mute_common_path_prefixes " + "from " + tableName)) {
        while (rs.next()) {
            GeneralPreferencesInfo p = new GeneralPreferencesInfo();
            Account.Id accountId = new Account.Id(rs.getInt(1));
            p.changesPerPage = (int) rs.getShort(2);
            p.showSiteHeader = toBoolean(rs.getString(3));
            p.useFlashClipboard = toBoolean(rs.getString(4));
            p.downloadScheme = convertToModernNames(rs.getString(5));
            p.downloadCommand = toDownloadCommand(rs.getString(6));
            p.emailStrategy = toEmailStrategy(rs.getString(7), columns.contains(emailStrategy));
            p.dateFormat = toDateFormat(rs.getString(8));
            p.timeFormat = toTimeFormat(rs.getString(9));
            p.relativeDateInChangeTable = toBoolean(rs.getString(10));
            p.diffView = toDiffView(rs.getString(11));
            p.sizeBarInChangeTable = toBoolean(rs.getString(12));
            p.legacycidInChangeTable = toBoolean(rs.getString(13));
            p.reviewCategoryStrategy = toReviewCategoryStrategy(rs.getString(14));
            p.muteCommonPathPrefixes = toBoolean(rs.getString(15));
            imports.put(accountId, p);
        }
    }
    if (imports.isEmpty()) {
        return;
    }
    try (Repository git = mgr.openRepository(allUsersName);
        RevWalk rw = new RevWalk(git)) {
        BatchRefUpdate bru = git.getRefDatabase().newBatchUpdate();
        for (Map.Entry<Account.Id, GeneralPreferencesInfo> e : imports.entrySet()) {
            try (MetaDataUpdate md = new MetaDataUpdate(GitReferenceUpdated.DISABLED, allUsersName, git, bru)) {
                md.getCommitBuilder().setAuthor(serverUser);
                md.getCommitBuilder().setCommitter(serverUser);
                VersionedAccountPreferences p = VersionedAccountPreferences.forUser(e.getKey());
                p.load(md);
                storeSection(p.getConfig(), UserConfigSections.GENERAL, null, e.getValue(), GeneralPreferencesInfo.defaults());
                p.commit(md);
            }
        }
        bru.execute(rw, NullProgressMonitor.INSTANCE);
    } catch (ConfigInvalidException | IOException ex) {
        throw new OrmException(ex);
    }
}
#end_block

#method_before
static List<Edit> intraline(String a, String b) throws Exception {
    return intraline(a, b, new Edit(0, 1, 0, 1));
}
#method_after
private static List<Edit> intraline(String a, String b) throws Exception {
    return intraline(a, b, new Edit(0, countLines(a), 0, countLines(b)));
}
#end_block

#method_before
static List<Edit> intraline(String a, String b, Edit lines) throws Exception {
    Text aText = new Text(a.getBytes("UTF-8"));
    Text bText = new Text(b.getBytes("UTF-8"));
    IntraLineDiff diff = IntraLineLoader.compute(aText, bText, EditList.singleton(lines));
    assertEquals(diff.getStatus(), IntraLineDiff.Status.EDIT_LIST);
    List<Edit> actualEdits = diff.getEdits();
    assertEquals(actualEdits.size(), 1);
    Edit actualEdit = actualEdits.get(0);
    assertEquals(lines.getBeginA(), actualEdit.getBeginA());
    assertEquals(lines.getEndA(), actualEdit.getEndA());
    assertEquals(lines.getBeginB(), actualEdit.getBeginB());
    assertEquals(lines.getEndB(), actualEdit.getEndB());
    assertTrue(actualEdit instanceof ReplaceEdit);
    return ((ReplaceEdit) actualEdit).getInternalEdits();
}
#method_after
private static List<Edit> intraline(String a, String b, Edit lines) throws Exception {
    Text aText = new Text(a.getBytes(UTF_8));
    Text bText = new Text(b.getBytes(UTF_8));
    IntraLineDiff diff;
    diff = IntraLineLoader.compute(aText, bText, EditList.singleton(lines));
    assertThat(diff.getStatus()).isEqualTo(IntraLineDiff.Status.EDIT_LIST);
    List<Edit> actualEdits = diff.getEdits();
    assertThat(actualEdits).hasSize(1);
    Edit actualEdit = actualEdits.get(0);
    assertThat(actualEdit.getBeginA()).isEqualTo(lines.getBeginA());
    assertThat(actualEdit.getEndA()).isEqualTo(lines.getEndA());
    assertThat(actualEdit.getBeginB()).isEqualTo(lines.getBeginB());
    assertThat(actualEdit.getEndB()).isEqualTo(lines.getEndB());
    assertThat(actualEdit).isInstanceOf(ReplaceEdit.class);
    return ((ReplaceEdit) actualEdit).getInternalEdits();
}
#end_block

#method_before
static List<Edit> wordEdit(int as, int ae, int bs, int be) {
    return EditList.singleton(new Edit(as, ae, bs, be));
}
#method_after
// helpers to compute reference values
private static List<Edit> wordEdit(int as, int ae, int bs, int be) {
    return EditList.singleton(new Edit(as, ae, bs, be));
}
#end_block

#method_before
@Override
protected void preUpdateSchema(ReviewDb db) throws OrmException, SQLException {
    try (Statement stmt = ((JdbcSchema) db).getConnection().createStatement()) {
        ResultSet rs = stmt.executeQuery("SELECT * FROM patch_sets");
        if (getColumnNames(rs).contains("push_certficate")) {
            renameColumn(db, "patch_sets", "push_certficate", "push_certificate");
        }
        try {
            stmt.execute("ALTER TABLE patch_sets MODIFY push_certificate clob");
        } catch (SQLException e) {
        // Ignore.  Type may have already been modified manually.
        }
    }
}
#method_after
@Override
protected void preUpdateSchema(ReviewDb db) throws OrmException, SQLException {
    JdbcSchema schema = (JdbcSchema) db;
    Connection connection = schema.getConnection();
    String tableName = "patch_sets";
    String oldColumnName = "push_certficate";
    String newColumnName = "push_certificate";
    Set<String> columns = schema.getDialect().listColumns(connection, tableName);
    if (columns.contains(oldColumnName)) {
        renameColumn(db, tableName, oldColumnName, newColumnName);
    }
    try (Statement stmt = schema.getConnection().createStatement()) {
        stmt.execute("ALTER TABLE " + tableName + " MODIFY " + newColumnName + " clob");
    } catch (SQLException e) {
    // Ignore.  Type may have already been modified manually.
    }
}
#end_block

#method_before
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameField(e, table, from, to);
    }
}
#method_after
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameColumn(e, table, from, to);
    }
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(ConfigResource rsrc, AccountGeneralPreferencesInfo i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.copySelfOnEmail != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        AccountGeneralPreferencesInfo a = new AccountGeneralPreferencesInfo();
        return loader.loadFromAllUsers(a, p, md.getRepository());
    } finally {
        md.close();
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(ConfigResource rsrc, GeneralPreferencesInfo i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        GeneralPreferencesInfo a = new GeneralPreferencesInfo();
        return loader.loadFromAllUsers(a, p, md.getRepository());
    }
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(ConfigResource rsrc) throws IOException, ConfigInvalidException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(git);
        AccountGeneralPreferencesInfo a = new AccountGeneralPreferencesInfo();
        // TODO(davido): Maintain cache of default values in AllUsers repository
        return loader.loadFromAllUsers(a, p, git);
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(ConfigResource rsrc) throws IOException, ConfigInvalidException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(git);
        GeneralPreferencesInfo a = new GeneralPreferencesInfo();
        // TODO(davido): Maintain cache of default values in AllUsers repository
        return loader.loadFromAllUsers(a, p, git);
    }
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(AccountResource rsrc, AccountGeneralPreferencesInfo i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    checkDownloadScheme(i);
    Account.Id id = rsrc.getUser().getAccountId();
    AccountGeneralPreferencesInfo n = loader.merge(id, i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = loader.merge(id, i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    return cache.get(id).getAccount().getGeneralPreferencesInfo();
}
#end_block

#method_before
private void writeToGit(Account.Id id, AccountGeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    try {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, AccountGeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    } finally {
        md.close();
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#end_block

#method_before
private void checkDownloadScheme(AccountGeneralPreferencesInfo p) throws BadRequestException {
    if (Strings.isNullOrEmpty(p.downloadScheme)) {
        return;
    }
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        if (e.getExportName().equals(p.downloadScheme) && e.getProvider().get().isEnabled()) {
            return;
        }
    }
    throw new BadRequestException("Unsupported download scheme: " + p.downloadScheme);
}
#method_after
private void checkDownloadScheme(String downloadScheme) throws BadRequestException {
    if (Strings.isNullOrEmpty(downloadScheme)) {
        return;
    }
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        if (e.getExportName().equals(downloadScheme) && e.getProvider().get().isEnabled()) {
            return;
        }
    }
    throw new BadRequestException("Unsupported download scheme: " + downloadScheme);
}
#end_block

#method_before
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(velocifyFile("Footer.vm"));
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            Boolean copySelfOnEmail = fromUser.getGeneralPreferencesInfo().copySelfOnEmail;
            if (copySelfOnEmail != null && copySelfOnEmail) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = body.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#method_after
public void send() throws EmailException {
    if (NotifyHandling.NONE.equals(notify)) {
        return;
    }
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(velocifyFile("Footer.vm"));
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            EmailStrategy strategy = fromUser.getGeneralPreferencesInfo().getEmailStrategy();
            if (strategy == EmailStrategy.CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                if (thisUser.getGeneralPreferencesInfo().getEmailStrategy() == EmailStrategy.DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = body.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#end_block

#method_before
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // If we have no message body, don't send.
        log.warn("Skipping delivery of email with no body");
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // If we have nobody to send this message to, then all of our
        // selection filters previously for this type of message were
        // unable to match a destination. Don't bother sending it.
        log.info("Skipping delivery of email with no recipients");
        return false;
    }
    if (smtpRcptTo.size() == 1 && rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#method_after
protected boolean shouldSendMessage() {
    if (body.length() == 0) {
        // If we have no message body, don't send.
        return false;
    }
    if (smtpRcptTo.isEmpty()) {
        // unable to match a destination. Don't bother sending it.
        return false;
    }
    if (smtpRcptTo.size() == 1 && rcptTo.size() == 1 && rcptTo.contains(fromId)) {
        // 
        return false;
    }
    return true;
}
#end_block

#method_before
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        if (args.emailSender.canEmail(addr.email)) {
            if (smtpRcptTo.add(addr)) {
                switch(rt) {
                    case TO:
                        ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                        break;
                    case CC:
                        ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                        break;
                    case BCC:
                        break;
                }
            }
        } else {
            log.warn("Not emailing " + addr.email + " (prohibited by allowrcpt)");
        }
    }
}
#method_after
protected void add(final RecipientType rt, final Address addr) {
    if (addr != null && addr.email != null && addr.email.length() > 0) {
        if (!EmailValidator.getInstance().isValid(addr.email)) {
            log.warn("Not emailing " + addr.email + " (invalid email address)");
        } else if (!args.emailSender.canEmail(addr.email)) {
            log.warn("Not emailing " + addr.email + " (prohibited by allowrcpt)");
        } else if (smtpRcptTo.add(addr)) {
            switch(rt) {
                case TO:
                    ((EmailHeader.AddressList) headers.get(HDR_TO)).add(addr);
                    break;
                case CC:
                    ((EmailHeader.AddressList) headers.get(HDR_CC)).add(addr);
                    break;
                case BCC:
                    break;
            }
        }
    }
}
#end_block

#method_before
public AccountGeneralPreferencesInfo getGeneralPreferencesInfo() {
    return generalPreferences;
}
#method_after
public GeneralPreferencesInfo getGeneralPreferencesInfo() {
    return generalPreferences;
}
#end_block

#method_before
public void setGeneralPreferences(AccountGeneralPreferencesInfo p) {
    generalPreferences = p;
}
#method_after
public void setGeneralPreferences(GeneralPreferencesInfo p) {
    generalPreferences = p;
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return accountCache.get(id).getAccount().getGeneralPreferencesInfo();
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return accountCache.get(id).getAccount().getGeneralPreferencesInfo();
}
#end_block

#method_before
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException {
    final Account account = db.accounts().get(who);
    if (account == null) {
        // 
        return missing(who);
    }
    final Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        throw new OrmException("Cannot load user preferences", e);
    }
    return new AccountState(account, internalGroups, externalIds);
}
#method_after
private AccountState load(final ReviewDb db, final Account.Id who) throws OrmException {
    final Account account = db.accounts().get(who);
    if (account == null) {
        // 
        return missing(who);
    }
    final Collection<AccountExternalId> externalIds = Collections.unmodifiableCollection(db.accountExternalIds().byAccount(who).toList());
    Set<AccountGroup.UUID> internalGroups = new HashSet<>();
    for (AccountGroupMember g : db.accountGroupMembers().byAccount(who)) {
        final AccountGroup.Id groupId = g.getAccountGroupId();
        final AccountGroup group = groupCache.get(groupId);
        if (group != null && group.getGroupUUID() != null) {
            internalGroups.add(group.getGroupUUID());
        }
    }
    internalGroups = Collections.unmodifiableSet(internalGroups);
    try {
        account.setGeneralPreferences(loader.load(who));
    } catch (IOException | ConfigInvalidException e) {
        log.warn("Cannot load GeneralPreferences for " + who + " (using default)", e);
        account.setGeneralPreferences(GeneralPreferencesInfo.defaults());
    }
    return new AccountState(account, internalGroups, externalIds);
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    // Respect timestamp, but truncate at change created-on time.
    ts = Ordering.natural().max(ts, revision.getChange().getCreatedOn());
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Boolean> approvalUpdated, ReviewDb db) {
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Short> oldApprovals, ReviewDb db) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, Event event) {
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) {
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private static Path hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    return path.resolve(value != null ? value : name);
}
#method_after
private static Optional<Path> hook(Config config, Path path, String name) {
    String setting = name.replace("-", "") + "hook";
    String value = config.getString("hooks", null, setting);
    Path p = path.resolve(value != null ? value : name);
    return Files.exists(p) ? Optional.of(p) : Optional.<Path>absent();
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    dispatcher.get().postEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, Map<String, Boolean> approvalStatus, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval, approvalStatus);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            addArg(args, "--" + lt.getName() + "-Updated", Boolean.toString(approvalStatus.get(approval.getKey())));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, final Map<String, Short> oldApprovals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval, oldApprovals);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null && approval.getValue() != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
            if (oldApprovals != null && !oldApprovals.isEmpty()) {
                Short oldValue = oldApprovals.get(approval.getKey());
                if (oldValue != null) {
                    addArg(args, "--" + lt.getName() + "-oldValue", Short.toString(oldValue));
                }
            }
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Boolean> approvalStatus) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    a.value = Short.toString(approval.getValue());
    a.updated = approvalStatus.get(approval.getKey());
    return a;
}
#method_after
private ApprovalAttribute getApprovalAttribute(LabelTypes labelTypes, Entry<String, Short> approval, Map<String, Short> oldApprovals) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getKey();
    if (oldApprovals != null && !oldApprovals.isEmpty()) {
        if (oldApprovals.get(approval.getKey()) != null) {
            a.oldValue = Short.toString(oldApprovals.get(approval.getKey()));
        }
    }
    LabelType lt = labelTypes.byLabel(approval.getKey());
    if (lt != null) {
        a.description = lt.getName();
    }
    if (approval.getValue() != null) {
        a.value = Short.toString(approval.getValue());
    }
    return a;
}
#end_block

#method_before
private synchronized void runHook(Path hook, List<String> args) {
    if (Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db.get(), change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(Change change) {
    try (ReviewDb db = schema.open()) {
        return asChangeAttribute(db, change);
    } catch (OrmException e) {
        log.error("Cannot open database connection", e);
        return new ChangeAttribute();
    }
}
#end_block

#method_before
public ChangeAttribute asChangeAttribute(final Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db.get(), change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#method_after
public ChangeAttribute asChangeAttribute(ReviewDb db, Change change) {
    ChangeAttribute a = new ChangeAttribute();
    a.project = change.getProject().get();
    a.branch = change.getDest().getShortName();
    a.topic = change.getTopic();
    a.id = change.getKey().get();
    a.number = change.getId().toString();
    a.subject = change.getSubject();
    try {
        a.commitMessage = changeDataFactory.create(db, change).commitMessage();
    } catch (Exception e) {
        log.error("Error while getting full commit message for" + " change " + a.number);
    }
    a.url = getChangeUrl(change);
    a.owner = asAccountAttribute(change.getOwner());
    a.status = change.getStatus();
    return a;
}
#end_block

#method_before
public RefUpdateAttribute asRefUpdateAttribute(final ObjectId oldId, final ObjectId newId, final Branch.NameKey refName) {
    RefUpdateAttribute ru = new RefUpdateAttribute();
    ru.newRev = newId != null ? newId.getName() : ObjectId.zeroId().getName();
    ru.oldRev = oldId != null ? oldId.getName() : ObjectId.zeroId().getName();
    ru.project = refName.getParentKey().get();
    ru.refName = refName.get();
    return ru;
}
#method_after
public RefUpdateAttribute asRefUpdateAttribute(ObjectId oldId, ObjectId newId, Branch.NameKey refName) {
    RefUpdateAttribute ru = new RefUpdateAttribute();
    ru.newRev = newId != null ? newId.getName() : ObjectId.zeroId().getName();
    ru.oldRev = oldId != null ? oldId.getName() : ObjectId.zeroId().getName();
    ru.project = refName.getParentKey().get();
    ru.refName = refName.get();
    return ru;
}
#end_block

#method_before
public void addAllReviewers(ChangeAttribute a, ChangeNotes notes) throws OrmException {
    Collection<Account.Id> reviewers = approvalsUtil.getReviewers(db.get(), notes).values();
    if (!reviewers.isEmpty()) {
        a.allReviewers = Lists.newArrayListWithCapacity(reviewers.size());
        for (Account.Id id : reviewers) {
            a.allReviewers.add(asAccountAttribute(id));
        }
    }
}
#method_after
public void addAllReviewers(ReviewDb db, ChangeAttribute a, ChangeNotes notes) throws OrmException {
    Collection<Account.Id> reviewers = approvalsUtil.getReviewers(db, notes).values();
    if (!reviewers.isEmpty()) {
        a.allReviewers = Lists.newArrayListWithCapacity(reviewers.size());
        for (Account.Id id : reviewers) {
            a.allReviewers.add(asAccountAttribute(id));
        }
    }
}
#end_block

#method_before
public void addDependencies(ChangeAttribute ca, Change change) {
    ca.dependsOn = new ArrayList<>();
    ca.neededBy = new ArrayList<>();
    try (ReviewDb db = schema.open()) {
        final PatchSet.Id psId = change.currentPatchSetId();
        for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
            for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
                Change c = db.changes().get(p.getId().getParentKey());
                if (c == null) {
                    log.error("Error while generating the ancestor change for" + " revision " + a.getAncestorRevision() + ": Cannot find" + " Change entry in database for " + p.getId().getParentKey());
                    continue;
                }
                ca.dependsOn.add(newDependsOn(c, p));
            }
        }
        final PatchSet ps = db.patchSets().get(psId);
        if (ps == null) {
            log.error("Error while generating the list of descendants for" + " PatchSet " + psId + ": Cannot find PatchSet entry in" + " database.");
        } else {
            final RevId revId = ps.getRevision();
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(revId)) {
                final PatchSet p = db.patchSets().get(a.getPatchSet());
                if (p == null) {
                    log.error("Error while generating the list of descendants for" + " revision " + revId.get() + ": Cannot find PatchSet entry in" + " database for " + a.getPatchSet());
                    continue;
                }
                final Change c = db.changes().get(p.getId().getParentKey());
                if (c == null) {
                    log.error("Error while generating the list of descendants for" + " revision " + revId.get() + ": Cannot find Change entry in" + " database for " + p.getId().getParentKey());
                    continue;
                }
                ca.neededBy.add(newNeededBy(c, p));
            }
        }
    } catch (OrmException e) {
    // Squash DB exceptions and leave dependency lists partially filled.
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.dependsOn.isEmpty()) {
        ca.dependsOn = null;
    }
    if (ca.neededBy.isEmpty()) {
        ca.neededBy = null;
    }
}
#method_after
public void addDependencies(RevWalk rw, ChangeAttribute ca, Change change, PatchSet currentPs) {
    if (change == null || currentPs == null) {
        return;
    }
    ca.dependsOn = new ArrayList<>();
    ca.neededBy = new ArrayList<>();
    try {
        addDependsOn(rw, ca, change, currentPs);
        addNeededBy(rw, ca, change, currentPs);
    } catch (OrmException | IOException e) {
    // Squash DB exceptions and leave dependency lists partially filled.
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.dependsOn.isEmpty()) {
        ca.dependsOn = null;
    }
    if (ca.neededBy.isEmpty()) {
        ca.neededBy = null;
    }
}
#end_block

#method_before
public void addPatchSets(ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, boolean includeFiles, Change change, LabelTypes labelTypes) {
    if (!ps.isEmpty()) {
        ca.patchSets = new ArrayList<>(ps.size());
        for (PatchSet p : ps) {
            PatchSetAttribute psa = asPatchSetAttribute(p);
            if (approvals != null) {
                addApprovals(psa, p.getId(), approvals, labelTypes);
            }
            ca.patchSets.add(psa);
            if (includeFiles && change != null) {
                addPatchSetFileNames(psa, change, p);
            }
        }
    }
}
#method_after
public void addPatchSets(ReviewDb db, RevWalk revWalk, ChangeAttribute ca, Collection<PatchSet> ps, Map<PatchSet.Id, Collection<PatchSetApproval>> approvals, LabelTypes labelTypes) {
    addPatchSets(db, revWalk, ca, ps, approvals, false, null, labelTypes);
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    final PatchSet.Id pId = patchSet.getId();
    try (ReviewDb db = schema.open()) {
        p.parents = new ArrayList<>();
        for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
            p.parents.add(a.getAncestorRevision().get());
        }
        UserIdentity author = psInfoFactory.get(db, pId).getAuthor();
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        Change change = db.changes().get(pId.getParentKey());
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(RevWalk revWalk, Change change, PatchSet patchSet) {
    try (ReviewDb db = schema.open()) {
        return asPatchSetAttribute(db, revWalk, change, patchSet);
    } catch (OrmException e) {
        log.error("Cannot open database connection", e);
        return new PatchSetAttribute();
    }
}
#end_block

#method_before
public AccountAttribute asAccountAttribute(final Account account) {
    if (account == null) {
        return null;
    }
    AccountAttribute who = new AccountAttribute();
    who.name = account.getFullName();
    who.email = account.getPreferredEmail();
    who.username = account.getUserName();
    return who;
}
#method_after
public AccountAttribute asAccountAttribute(Account account) {
    if (account == null) {
        return null;
    }
    AccountAttribute who = new AccountAttribute();
    who.name = account.getFullName();
    who.email = account.getPreferredEmail();
    who.username = account.getUserName();
    return who;
}
#end_block

#method_before
public ApprovalAttribute asApprovalAttribute(PatchSetApproval approval, LabelTypes labelTypes) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getLabelId().get();
    a.value = Short.toString(approval.getValue());
    a.by = asAccountAttribute(approval.getAccountId());
    a.grantedOn = approval.getGranted().getTime() / 1000L;
    a.updated = false;
    LabelType lt = labelTypes.byLabel(approval.getLabelId());
    if (lt != null) {
        a.description = lt.getName();
    }
    return a;
}
#method_after
public ApprovalAttribute asApprovalAttribute(PatchSetApproval approval, LabelTypes labelTypes) {
    ApprovalAttribute a = new ApprovalAttribute();
    a.type = approval.getLabelId().get();
    a.value = Short.toString(approval.getValue());
    a.by = asAccountAttribute(approval.getAccountId());
    a.grantedOn = approval.getGranted().getTime() / 1000L;
    a.oldValue = null;
    LabelType lt = labelTypes.byLabel(approval.getLabelId());
    if (lt != null) {
        a.description = lt.getName();
    }
    return a;
}
#end_block

#method_before
private String getChangeUrl(final Change change) {
    if (change != null && urlProvider.get() != null) {
        final StringBuilder r = new StringBuilder();
        r.append(urlProvider.get());
        r.append(change.getChangeId());
        return r.toString();
    }
    return null;
}
#method_after
private String getChangeUrl(Change change) {
    if (change != null && urlProvider.get() != null) {
        StringBuilder r = new StringBuilder();
        r.append(urlProvider.get());
        r.append(change.getChangeId());
        return r.toString();
    }
    return null;
}
#end_block

#method_before
@Override
protected void configureServlets() {
    serve("/*").with(LfsContentServlet.class);
}
#method_after
@Override
protected void configureServlets() {
    serveRegex(URL_REGEX).with(LfsApiServlet.class);
    bind(LocalLargeFileRepository.class);
    serve("/*").with(LfsContentServlet.class);
}
#end_block

#method_before
@Override
Runnable diffChunkNav(final CodeMirror cm, final Direction dir) {
    return new Runnable() {

        @Override
        public void run() {
            int line = cm.extras().hasActiveLine() ? cm.getLineNumber(cm.extras().activeLine()) : 0;
            int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(cm.side(), 0, 0, line, false), getDiffChunkComparatorCmLine());
            diffChunkNavHelper(chunks, host, res, dir);
        }
    };
}
#method_after
@Override
Runnable diffChunkNav(final CodeMirror cm, final Direction dir) {
    return new Runnable() {

        @Override
        public void run() {
            int line = cm.extras().hasActiveLine() ? cm.getLineNumber(cm.extras().activeLine()) : 0;
            int res = Collections.binarySearch(chunks, new UnifiedDiffChunkInfo(cm.side(), 0, 0, line, false), getDiffChunkComparatorCmLine());
            diffChunkNavHelper(chunks, cm, res, dir);
        }
    };
}
#end_block

#method_before
@Override
CodeMirror newCm(DiffInfo.FileMeta meta, String contents, Element parent) {
    return CodeMirror.create(parent, Configuration.create().set("cursorBlinkRate", prefs.cursorBlinkRate()).set("cursorHeight", 0.85).set("keyMap", "vim_ro").set("lineNumbers", prefs.showLineNumbers()).set("lineWrapping", false).set("matchBrackets", prefs.matchBrackets()).set("mode", getFileSize() == FileSize.SMALL ? getContentType(meta) : null).set("readOnly", true).set("scrollbarStyle", "overlay").set("showTrailingSpace", prefs.showWhitespaceErrors()).set("styleSelectedText", true).set("tabSize", prefs.tabSize()).set("theme", prefs.theme().name().toLowerCase()).set("value", meta != null ? contents : "").set("viewportMargin", renderEntireFile() ? POSITIVE_INFINITY : 10));
}
#method_after
@Override
CodeMirror newCm(DiffInfo.FileMeta meta, String contents, Element parent) {
    return CodeMirror.create(parent, Configuration.create().set("cursorBlinkRate", prefs.cursorBlinkRate()).set("cursorHeight", 0.85).set("inputStyle", "textarea").set("keyMap", "vim_ro").set("lineNumbers", prefs.showLineNumbers()).set("lineWrapping", false).set("matchBrackets", prefs.matchBrackets()).set("mode", getFileSize() == FileSize.SMALL ? getContentType(meta) : null).set("readOnly", true).set("scrollbarStyle", "overlay").set("showTrailingSpace", prefs.showWhitespaceErrors()).set("styleSelectedText", true).set("tabSize", prefs.tabSize()).set("theme", prefs.theme().name().toLowerCase()).set("value", meta != null ? contents : "").set("viewportMargin", renderEntireFile() ? POSITIVE_INFINITY : 10));
}
#end_block

#method_before
@Override
CodeMirror newCm(DiffInfo.FileMeta meta, String contents, Element parent) {
    JsArrayString gutters = JavaScriptObject.createArray().cast();
    gutters.push(UnifiedTable.style.lineNumbersLeft());
    gutters.push(UnifiedTable.style.lineNumbersRight());
    return CodeMirror.create(parent, Configuration.create().set("cursorBlinkRate", prefs.cursorBlinkRate()).set("cursorHeight", 0.85).set("gutters", gutters).set("keyMap", "vim_ro").set("lineNumbers", false).set("lineWrapping", false).set("matchBrackets", prefs.matchBrackets()).set("mode", getFileSize() == FileSize.SMALL ? getContentType(meta) : null).set("readOnly", true).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", prefs.showWhitespaceErrors()).set("tabSize", prefs.tabSize()).set("theme", prefs.theme().name().toLowerCase()).set("value", meta != null ? contents : "").set("viewportMargin", renderEntireFile() ? POSITIVE_INFINITY : 10));
}
#method_after
@Override
CodeMirror newCm(DiffInfo.FileMeta meta, String contents, Element parent) {
    JsArrayString gutters = JavaScriptObject.createArray().cast();
    gutters.push(UnifiedTable.style.lineNumbersLeft());
    gutters.push(UnifiedTable.style.lineNumbersRight());
    return CodeMirror.create(parent, Configuration.create().set("cursorBlinkRate", prefs.cursorBlinkRate()).set("cursorHeight", 0.85).set("gutters", gutters).set("inputStyle", "textarea").set("keyMap", "vim_ro").set("lineNumbers", false).set("lineWrapping", false).set("matchBrackets", prefs.matchBrackets()).set("mode", getFileSize() == FileSize.SMALL ? getContentType(meta) : null).set("readOnly", true).set("scrollbarStyle", "overlay").set("styleSelectedText", true).set("showTrailingSpace", prefs.showWhitespaceErrors()).set("tabSize", prefs.tabSize()).set("theme", prefs.theme().name().toLowerCase()).set("value", meta != null ? contents : "").set("viewportMargin", renderEntireFile() ? POSITIVE_INFINITY : 10));
}
#end_block

#method_before
void setNoDiff(DiffInfo diff) {
    JsArray<Region> regions = diff.content();
    boolean b = regions.length() == 0 || (regions.length() == 1 && regions.get(0).ab() != null);
    UIObject.setVisible(noDiff, b);
}
#method_after
void setNoDiff(DiffInfo diff) {
    if (diff.binary()) {
        // Don't bother showing "No Differences"
        UIObject.setVisible(noDiff, false);
    } else {
        JsArray<Region> regions = diff.content();
        boolean b = regions.length() == 0 || (regions.length() == 1 && regions.get(0).ab() != null);
        UIObject.setVisible(noDiff, b);
    }
}
#end_block

#method_before
void add(Widget widget) {
    ((HTMLPanel) getWidget()).add(widget);
}
#method_after
void add(Widget widget) {
    widgets.add(widget);
}
#end_block

#method_before
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(int line, LineClassWhere where, String className) {
    addLineClassNative(line, where.value(), className);
}
#end_block

#method_before
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void addLineClass(LineHandle line, LineClassWhere where, String className) {
    addLineClassNative(line, where.value(), className);
}
#end_block

#method_before
public final void removeLineClass(int line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void removeLineClass(int line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.value(), className);
}
#end_block

#method_before
public final void removeLineClass(LineHandle line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.name().toLowerCase(), className);
}
#method_after
public final void removeLineClass(LineHandle line, LineClassWhere where, String className) {
    removeLineClassNative(line, where.value(), className);
}
#end_block

#method_before
void setOpen(boolean open) {
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    UIObject.setVisible(buttons, open);
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
    super.setOpen(open);
}
#method_after
@Override
void setOpen(boolean open) {
    UIObject.setVisible(summary, !open);
    UIObject.setVisible(message, open);
    UIObject.setVisible(buttons, open && replyBox == null);
    if (open) {
        removeStyleName(style.closed());
    } else {
        addStyleName(style.closed());
    }
    super.setOpen(open);
}
#end_block

#method_before
void unregisterReplyBox() {
    replyBox = null;
}
#method_after
void unregisterReplyBox() {
    replyBox = null;
    UIObject.setVisible(buttons, isOpen());
}
#end_block

#method_before
DraftBox addReplyBox() {
    DraftBox box = getDiffScreen().addDraftBox(getDiffScreen().createReply(comment), getSide());
    registerReplyBox(box);
    return box;
}
#method_after
void addReplyBox(boolean quote) {
    CommentInfo commentReply = CommentInfo.createReply(comment);
    if (quote) {
        commentReply.message(ReplyBox.quote(comment.message()));
    }
    getCommentManager().addDraftBox(getCm().side(), commentReply).setEdit(true);
}
#end_block

#method_before
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getDiffScreen().getToken());
    } else if (replyBox == null) {
        DraftBox box = addReplyBox();
        if (!getCommentInfo().has_line()) {
            getDiffScreen().addFileCommentBox(box);
        }
    } else {
        openReplyBox();
    }
}
#method_after
void doReply() {
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getCommentManager().getDiffScreen().getToken());
    } else if (replyBox == null) {
        addReplyBox(false);
    } else {
        openReplyBox();
    }
}
#end_block

#method_before
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getDiffScreen().getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInput input = CommentInput.create(getDiffScreen().createReply(comment));
        input.setMessage(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                DraftBox box = getDiffScreen().addDraftBox(result, getSide());
                registerReplyBox(box);
                if (!getCommentInfo().has_line()) {
                    getDiffScreen().addFileCommentBox(box);
                }
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#method_after
@UiHandler("done")
void onReplyDone(ClickEvent e) {
    e.stopPropagation();
    if (!Gerrit.isSignedIn()) {
        Gerrit.doSignIn(getCommentManager().getDiffScreen().getToken());
    } else if (replyBox == null) {
        done.setEnabled(false);
        CommentInfo input = CommentInfo.createReply(comment);
        input.message(PatchUtil.C.cannedReplyDone());
        CommentApi.createDraft(psId, input, new GerritCallback<CommentInfo>() {

            @Override
            public void onSuccess(CommentInfo result) {
                done.setEnabled(true);
                setOpen(false);
                getCommentManager().addDraftBox(getCm().side(), result);
            }
        });
    } else {
        openReplyBox();
        setOpen(false);
    }
}
#end_block

#method_before
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.getConfig().getAnonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#method_after
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.info().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#end_block

#method_before
void setOpen(boolean open) {
    resizePaddingWidget();
    setRangeHighlight(open);
    getCm().focus();
}
#method_after
void setOpen(boolean open) {
    group.resize();
    setRangeHighlight(open);
    getCm().focus();
}
#end_block

#method_before
void setRangeHighlight(boolean highlight) {
    if (fromTo != null) {
        if (highlight && rangeHighlightMarker == null) {
            rangeHighlightMarker = cm.markText(fromTo.getFrom(), fromTo.getTo(), Configuration.create().set("className", Resources.I.diffTableStyle().rangeHighlight()));
        } else if (!highlight && rangeHighlightMarker != null) {
            rangeHighlightMarker.clear();
            rangeHighlightMarker = null;
        }
    }
}
#method_after
void setRangeHighlight(boolean highlight) {
    if (fromTo != null) {
        if (highlight && rangeHighlightMarker == null) {
            rangeHighlightMarker = group.getCm().markText(fromTo.from(), fromTo.to(), Configuration.create().set("className", Resources.I.diffTableStyle().rangeHighlight()));
        } else if (!highlight && rangeHighlightMarker != null) {
            rangeHighlightMarker.clear();
            rangeHighlightMarker = null;
        }
    }
}
#end_block

#method_before
void clearRange() {
    if (rangeMarker != null) {
        rangeMarker.clear();
    }
}
#method_after
void clearRange() {
    if (rangeMarker != null) {
        rangeMarker.clear();
        rangeMarker = null;
    }
}
#end_block

#method_before
CodeMirror getCm() {
    return cm;
}
#method_after
CodeMirror getCm() {
    return group.getCm();
}
#end_block

#method_before
private static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    return toPatch(type, diffBase, id.getParentKey(), id.get());
}
#method_after
public static String toPatch(String type, PatchSet.Id diffBase, Patch.Key id) {
    return toPatch(type, diffBase, id.getParentKey(), id.get(), null, 0);
}
#end_block

#method_before
public static String toPatch(final PatchScreen.Type type, final Patch.Key id) {
    if (type == PatchScreen.Type.SIDE_BY_SIDE) {
        return toPatchSideBySide(id);
    } else {
        return toPatchUnified(id);
    }
}
#method_after
private static String toPatch(String type, PatchSet.Id diffBase, PatchSet.Id revision, String fileName, DisplaySide side, int line) {
    Change.Id c = revision.getParentKey();
    StringBuilder p = new StringBuilder();
    p.append("/c/").append(c).append("/");
    if (diffBase != null) {
        p.append(diffBase.get()).append("..");
    }
    p.append(revision.getId()).append("/").append(KeyUtil.encode(fileName));
    if (type != null && !type.isEmpty() && (!"sidebyside".equals(type) || preferUnified())) {
        p.append(",").append(type);
    }
    if (side == DisplaySide.A && line > 0) {
        p.append("@a").append(line);
    } else if (line > 0) {
        p.append("@").append(line);
    }
    return p.toString();
}
#end_block

#method_before
public static String toGroup(final AccountGroup.Id id) {
    return "/admin/groups/" + id.toString();
}
#method_after
public static String toGroup(final AccountGroup.Id id) {
    return ADMIN_GROUPS + id.toString();
}
#end_block

#method_before
public static String toGroup(AccountGroup.Id id, String panel) {
    return "/admin/groups/" + id.toString() + "," + panel;
}
#method_after
public static String toGroup(AccountGroup.Id id, String panel) {
    return ADMIN_GROUPS + id.toString() + "," + panel;
}
#end_block

#method_before
public static String toProjectAdmin(Project.NameKey n, String panel) {
    if (panel == null || ProjectScreen.INFO.equals(panel)) {
        return "/admin/projects/" + n.toString();
    }
    return "/admin/projects/" + n.toString() + "," + panel;
}
#method_after
public static String toProjectAdmin(Project.NameKey n, String panel) {
    if (panel == null || ProjectScreen.INFO.equals(panel)) {
        return ADMIN_PROJECTS + n.toString();
    }
    return ADMIN_PROJECTS + n.toString() + "," + panel;
}
#end_block

#method_before
private static void select(final String token) {
    if (matchPrefix("/q/", token)) {
        query(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchExact(MINE, token)) {
        Gerrit.display(token, mine(token));
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (// 
    matchExact(SETTINGS, token) || // 
    matchPrefix("/settings/", token) || // 
    matchExact("register", token) || // 
    matchExact(REGISTER, token) || // 
    matchPrefix("/register/", token) || matchPrefix("/VE/", token) || // 
    matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else if (/* DEPRECATED URL */
    matchPrefix("/c2/", token)) {
        changeScreen2 = true;
        change(token);
    } else if (/* LEGACY URL */
    matchPrefix("all,", token)) {
        redirectFromLegacyToken(token, legacyAll(token));
    } else if (/* LEGACY URL */
    matchPrefix("mine,", token) || matchExact("mine", token)) {
        redirectFromLegacyToken(token, legacyMine(token));
    } else if (/* LEGACY URL */
    matchPrefix("project,", token)) {
        redirectFromLegacyToken(token, legacyProject(token));
    } else if (/* LEGACY URL */
    matchPrefix("change,", token)) {
        redirectFromLegacyToken(token, legacyChange(token));
    } else if (/* LEGACY URL */
    matchPrefix("patch,", token)) {
        redirectFromLegacyToken(token, legacyPatch(token));
    } else if (/* LEGACY URL */
    matchPrefix("admin,", token)) {
        redirectFromLegacyToken(token, legacyAdmin(token));
    } else if (/* LEGACY URL */
    matchPrefix("settings,", token) || matchPrefix("register,", token) || matchPrefix("q,", token)) {
        redirectFromLegacyToken(token, legacySettings(token));
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#method_after
private static void select(String token) {
    token = Gerrit.getUrlAliasMatcher().replace(token);
    if (matchPrefix(QUERY, token)) {
        query(token);
    } else if (matchPrefix("/Documentation/", token)) {
        docSearch(token);
    } else if (matchPrefix("/c/", token)) {
        change(token);
    } else if (matchPrefix("/x/", token)) {
        extension(token);
    } else if (matchExact(MINE, token)) {
        String defaultScreenToken = Gerrit.getDefaultScreenToken();
        if (defaultScreenToken != null && !MINE.equals(defaultScreenToken)) {
            select(defaultScreenToken);
        } else {
            Gerrit.display(token, mine());
        }
    } else if (matchPrefix("/dashboard/", token)) {
        dashboard(token);
    } else if (matchPrefix(PROJECTS, token)) {
        projects(token);
    } else if (matchExact(SETTINGS, token) || matchPrefix("/settings/", token) || matchExact(MY_GROUPS, token) || matchExact("register", token) || matchExact(REGISTER, token) || matchPrefix("/register/", token) || matchPrefix("/VE/", token) || matchPrefix("VE,", token) || matchPrefix("/SignInFailure,", token)) {
        settings(token);
    } else if (matchPrefix("/admin/", token)) {
        admin(token);
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void query(final String token) {
    final String s = skip(token);
    final int c = s.indexOf(',');
    Gerrit.display(token, new QueryScreen(s.substring(0, c), s.substring(c + 1)));
}
#method_after
private static void query(String token) {
    String s = skip(token);
    int c = s.indexOf(',');
    Screen screen;
    if (c >= 0) {
        String prefix = s.substring(0, c);
        if (s.substring(c).equals(",n,z")) {
            // Respect legacy token with max sortkey.
            screen = new QueryScreen(prefix, 0);
        } else {
            screen = new QueryScreen(prefix, Integer.parseInt(s.substring(c + 1)));
        }
    } else {
        screen = new QueryScreen(s, 0);
    }
    Gerrit.display(token, screen);
}
#end_block

#method_before
private static Screen mine(final String token) {
    if (Gerrit.isSignedIn()) {
        return new AccountDashboardScreen(Gerrit.getUserAccount().getId());
    } else {
        Screen r = new AccountDashboardScreen(null);
        r.setRequiresSignIn(true);
        return r;
    }
}
#method_after
private static Screen mine() {
    if (Gerrit.isSignedIn()) {
        return new AccountDashboardScreen(Gerrit.getUserAccount().getId());
    } else {
        Screen r = new AccountDashboardScreen(null);
        r.setRequiresSignIn(true);
        return r;
    }
}
#end_block

#method_before
private static void dashboard(final String token) {
    String rest = skip(token);
    if (rest.matches("[0-9]+")) {
        Gerrit.display(token, new AccountDashboardScreen(Account.Id.parse(rest)));
        return;
    }
    if (rest.startsWith("?")) {
        Gerrit.display(token, new CustomDashboardScreen(rest.substring(1)));
        return;
    }
    Gerrit.display(token, new NotFoundScreen());
}
#method_after
private static void dashboard(final String token) {
    String rest = skip(token);
    if (rest.matches("[0-9]+")) {
        Gerrit.display(token, new AccountDashboardScreen(Account.Id.parse(rest)));
        return;
    }
    if (rest.equals("self")) {
        if (Gerrit.isSignedIn()) {
            Gerrit.display(token, new AccountDashboardScreen(Gerrit.getUserAccount().getId()));
        } else {
            Screen s = new AccountDashboardScreen(null);
            s.setRequiresSignIn(true);
            Gerrit.display(token, s);
        }
        return;
    }
    if (rest.startsWith("?")) {
        Gerrit.display(token, new CustomDashboardScreen(rest.substring(1)));
        return;
    }
    Gerrit.display(token, new NotFoundScreen());
}
#end_block

#method_before
private static void projects(final String token) {
    String rest = skip(token);
    int c = rest.indexOf(DASHBOARDS);
    if (0 <= c) {
        final String project = URL.decodePathSegment(rest.substring(0, c));
        rest = rest.substring(c);
        if (matchPrefix(DASHBOARDS, rest)) {
            final String dashboardId = skip(rest);
            GerritCallback<DashboardInfo> cb = new GerritCallback<DashboardInfo>() {

                @Override
                public void onSuccess(DashboardInfo result) {
                    if (matchPrefix("/dashboard/", result.url())) {
                        String params = skip(result.url()).substring(1);
                        ProjectDashboardScreen dash = new ProjectDashboardScreen(new Project.NameKey(project), params);
                        Gerrit.display(token, dash);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    if ("default".equals(dashboardId) && RestApi.isNotFound(caught)) {
                        Gerrit.display(PageLinks.toChangeQuery(PageLinks.projectQuery(new Project.NameKey(project))));
                    } else {
                        super.onFailure(caught);
                    }
                }
            };
            if ("default".equals(dashboardId)) {
                DashboardList.getDefault(new Project.NameKey(project), cb);
                return;
            }
            c = dashboardId.indexOf(":");
            if (0 <= c) {
                final String ref = URL.decodeQueryString(dashboardId.substring(0, c));
                final String path = URL.decodeQueryString(dashboardId.substring(c + 1));
                DashboardList.get(new Project.NameKey(project), ref + ":" + path, cb);
                return;
            }
        }
    }
    Gerrit.display(token, new NotFoundScreen());
}
#method_after
private static void projects(final String token) {
    String rest = skip(token);
    int c = rest.indexOf(DASHBOARDS);
    if (0 <= c) {
        final String project = URL.decodePathSegment(rest.substring(0, c));
        rest = rest.substring(c);
        if (matchPrefix(DASHBOARDS, rest)) {
            final String dashboardId = skip(rest);
            GerritCallback<DashboardInfo> cb = new GerritCallback<DashboardInfo>() {

                @Override
                public void onSuccess(DashboardInfo result) {
                    if (matchPrefix("/dashboard/", result.url())) {
                        String params = skip(result.url()).substring(1);
                        ProjectDashboardScreen dash = new ProjectDashboardScreen(new Project.NameKey(project), params);
                        Gerrit.display(token, dash);
                    }
                }

                @Override
                public void onFailure(Throwable caught) {
                    if ("default".equals(dashboardId) && RestApi.isNotFound(caught)) {
                        Gerrit.display(toChangeQuery(PageLinks.projectQuery(new Project.NameKey(project))));
                    } else {
                        super.onFailure(caught);
                    }
                }
            };
            if ("default".equals(dashboardId)) {
                DashboardList.getDefault(new Project.NameKey(project), cb);
                return;
            }
            c = dashboardId.indexOf(":");
            if (0 <= c) {
                final String ref = URL.decodeQueryString(dashboardId.substring(0, c));
                final String path = URL.decodeQueryString(dashboardId.substring(c + 1));
                DashboardList.get(new Project.NameKey(project), ref + ":" + path, cb);
                return;
            }
        }
    }
    Gerrit.display(token, new NotFoundScreen());
}
#end_block

#method_before
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        Gerrit.display(token, panel == null ? (isChangeScreen2() ? new ChangeScreen2(id, null, false) : new ChangeScreen(id)) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(dotdot + 2)));
    } else {
        base = null;
        ps = new PatchSet.Id(id, Integer.parseInt(psIdStr));
    }
    if (!rest.isEmpty()) {
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, 0, null, null, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, isChangeScreen2() ? new ChangeScreen2(id, String.valueOf(ps.get()), false) : new ChangeScreen(id));
        } else if ("publish".equals(panel)) {
            publish(ps);
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#method_after
private static void change(final String token) {
    String rest = skip(token);
    int c = rest.lastIndexOf(',');
    String panel = null;
    if (0 <= c) {
        panel = rest.substring(c + 1);
        rest = rest.substring(0, c);
        int at = panel.lastIndexOf('@');
        if (at > 0) {
            rest += panel.substring(at);
            panel = panel.substring(0, at);
        }
    }
    Change.Id id;
    int s = rest.indexOf('/');
    if (0 <= s) {
        id = Change.Id.parse(rest.substring(0, s));
        rest = rest.substring(s + 1);
    } else {
        id = Change.Id.parse(rest);
        rest = "";
    }
    if (rest.isEmpty()) {
        FileTable.Mode mode = FileTable.Mode.REVIEW;
        if (panel != null && (panel.equals("edit") || panel.startsWith("edit/"))) {
            mode = FileTable.Mode.EDIT;
            panel = null;
        }
        Gerrit.display(token, panel == null ? new ChangeScreen(id, null, null, false, mode) : new NotFoundScreen());
        return;
    }
    String psIdStr;
    s = rest.indexOf('/');
    if (0 <= s) {
        psIdStr = rest.substring(0, s);
        rest = rest.substring(s + 1);
    } else {
        psIdStr = rest;
        rest = "";
    }
    PatchSet.Id base = null;
    PatchSet.Id ps;
    int dotdot = psIdStr.indexOf("..");
    if (1 <= dotdot) {
        base = new PatchSet.Id(id, Integer.parseInt(psIdStr.substring(0, dotdot)));
        psIdStr = psIdStr.substring(dotdot + 2);
    }
    ps = toPsId(id, psIdStr);
    if (!rest.isEmpty()) {
        DisplaySide side = DisplaySide.B;
        int line = 0;
        int at = rest.lastIndexOf('@');
        if (at > 0) {
            String l = rest.substring(at + 1);
            if (l.startsWith("a")) {
                side = DisplaySide.A;
                l = l.substring(1);
            }
            line = Integer.parseInt(l);
            rest = rest.substring(0, at);
        }
        Patch.Key p = new Patch.Key(ps, KeyUtil.decode(rest));
        patch(token, base, p, side, line, panel);
    } else {
        if (panel == null) {
            Gerrit.display(token, new ChangeScreen(id, base != null ? String.valueOf(base.get()) : null, String.valueOf(ps.get()), false, FileTable.Mode.REVIEW));
        } else {
            Gerrit.display(token, new NotFoundScreen());
        }
    }
}
#end_block

#method_before
public static void patch(String token, final PatchSet.Id baseId, final Patch.Key id, final int patchIndex, final PatchSetDetail patchSetDetail, final PatchTable patchTable, final PatchScreen.TopView topView, final String panelType) {
    final PatchScreen.TopView top = topView == null ? Gerrit.getPatchScreenTopView() : topView;
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (id != null) {
                String panel = panelType;
                if (panel == null) {
                    int c = token.lastIndexOf(',');
                    panel = 0 <= c ? token.substring(c + 1) : "";
                }
                if ("".equals(panel)) {
                    return new // 
                    PatchScreen.SideBySide(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    baseId);
                } else if ("unified".equals(panel)) {
                    return new // 
                    PatchScreen.Unified(// 
                    id, // 
                    patchIndex, // 
                    patchSetDetail, // 
                    patchTable, // 
                    top, // 
                    baseId);
                } else if ("cm".equals(panel)) {
                    if (Gerrit.isSignedIn() && DiffView.UNIFIED_DIFF.equals(Gerrit.getUserAccount().getGeneralPreferences().getDiffView())) {
                        return new // 
                        PatchScreen.Unified(// 
                        id, // 
                        patchIndex, // 
                        patchSetDetail, // 
                        patchTable, // 
                        top, // 
                        baseId);
                    }
                    return new SideBySide2(baseId, id.getParentKey(), id.get());
                } else if ("unified2".equals(panel)) {
                    return new Unified2(baseId, id.getParentKey(), id.get());
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void patch(String token, PatchSet.Id baseId, Patch.Key id, DisplaySide side, int line, String panelType) {
    String panel = panelType;
    if (panel == null) {
        int c = token.lastIndexOf(',');
        panel = 0 <= c ? token.substring(c + 1) : "";
    }
    if ("".equals(panel) || /* DEPRECATED URL */
    "cm".equals(panel)) {
        if (preferUnified()) {
            unified(token, baseId, id, side, line);
        } else {
            codemirror(token, baseId, id, side, line, false);
        }
    } else if ("sidebyside".equals(panel)) {
        codemirror(token, null, id, side, line, false);
    } else if ("unified".equals(panel)) {
        unified(token, baseId, id, side, line);
    } else if ("unified1".equals(panel)) {
        unified1(token, baseId, id);
    } else if ("edit".equals(panel)) {
        codemirror(token, null, id, side, line, true);
    } else {
        Gerrit.display(token, new NotFoundScreen());
    }
}
#end_block

#method_before
private static void settings(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (matchExact(SETTINGS, token)) {
                return new MyProfileScreen();
            }
            if (matchExact(SETTINGS_PREFERENCES, token)) {
                return new MyPreferencesScreen();
            }
            if (matchExact(SETTINGS_PROJECTS, token)) {
                return new MyWatchedProjectsScreen();
            }
            if (matchExact(SETTINGS_CONTACT, token)) {
                return new MyContactInformationScreen();
            }
            if (matchExact(SETTINGS_SSHKEYS, token)) {
                return new MySshKeysScreen();
            }
            if (matchExact(SETTINGS_WEBIDENT, token)) {
                return new MyIdentitiesScreen();
            }
            if (matchExact(SETTINGS_HTTP_PASSWORD, token)) {
                return new MyPasswordScreen();
            }
            if (matchExact(SETTINGS_MYGROUPS, token)) {
                return new MyGroupsScreen();
            }
            if (matchExact(SETTINGS_AGREEMENTS, token) && Gerrit.getConfig().isUseContributorAgreements()) {
                return new MyAgreementsScreen();
            }
            if (matchExact(REGISTER, token) || matchExact("/register/", token) || matchExact("register", token)) {
                return new RegisterScreen(MINE);
            } else if (matchPrefix("/register/", token)) {
                return new RegisterScreen("/" + skip(token));
            }
            if (matchPrefix("/VE/", token) || matchPrefix("VE,", token))
                return new ValidateEmailScreen(skip(token));
            if (matchExact(SETTINGS_NEW_AGREEMENT, token))
                return new NewAgreementScreen();
            if (matchPrefix(SETTINGS_NEW_AGREEMENT + "/", token)) {
                return new NewAgreementScreen(skip(token));
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void settings(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (matchExact(SETTINGS, token)) {
                return new MyProfileScreen();
            }
            if (matchExact(SETTINGS_PREFERENCES, token)) {
                return new MyPreferencesScreen();
            }
            if (matchExact(SETTINGS_DIFF_PREFERENCES, token)) {
                return new MyDiffPreferencesScreen();
            }
            if (matchExact(SETTINGS_EDIT_PREFERENCES, token)) {
                return new MyEditPreferencesScreen();
            }
            if (matchExact(SETTINGS_PROJECTS, token)) {
                return new MyWatchedProjectsScreen();
            }
            if (matchExact(SETTINGS_CONTACT, token)) {
                return new MyContactInformationScreen();
            }
            if (matchExact(SETTINGS_SSHKEYS, token)) {
                return new MySshKeysScreen();
            }
            if (matchExact(SETTINGS_GPGKEYS, token) && Gerrit.info().gerrit().editGpgKeys()) {
                return new MyGpgKeysScreen();
            }
            if (matchExact(SETTINGS_WEBIDENT, token)) {
                return new MyIdentitiesScreen();
            }
            if (matchExact(SETTINGS_HTTP_PASSWORD, token)) {
                return new MyPasswordScreen();
            }
            if (matchExact(MY_GROUPS, token) || matchExact(SETTINGS_MYGROUPS, token)) {
                return new MyGroupsScreen();
            }
            if (matchExact(SETTINGS_AGREEMENTS, token) && Gerrit.info().auth().useContributorAgreements()) {
                return new MyAgreementsScreen();
            }
            if (matchExact(REGISTER, token) || matchExact("/register/", token) || matchExact("register", token)) {
                return new RegisterScreen(MINE);
            } else if (matchPrefix("/register/", token)) {
                return new RegisterScreen("/" + skip(token));
            }
            if (matchPrefix("/VE/", token) || matchPrefix("VE,", token)) {
                return new ValidateEmailScreen(skip(token));
            }
            if (matchExact(SETTINGS_NEW_AGREEMENT, token)) {
                return new NewAgreementScreen();
            }
            if (matchPrefix(SETTINGS_NEW_AGREEMENT + "/", token)) {
                return new NewAgreementScreen(skip(token));
            }
            if (matchPrefix(SETTINGS_EXTENSION, token)) {
                ExtensionSettingsScreen view = new ExtensionSettingsScreen(skip(token));
                if (view.isFound()) {
                    return view;
                } else {
                    return new NotFoundScreen();
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix("/admin/groups/", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix("/admin/projects/", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix("/admin/groups/", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID()) && !AccountGroup.isSystemGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix("/admin/projects/", token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else if (AccountGroupScreen.AUDIT_LOG.equals(panel)) {
                        Gerrit.display(token, new AccountGroupAuditLogScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCHES.equals(panel) || matchPrefix(ProjectScreen.BRANCHES, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.TAGS.equals(panel) || matchPrefix(ProjectScreen.TAGS, panel)) {
                    return new ProjectTagsScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
public final void onFailure(Throwable reason) {
    if (!isReloadUi && "HTTP download failed with status 404".equals(reason.getMessage())) {
        // The server was upgraded since we last download the main script,
        // so the pointers to the splits aren't valid anymore.  Force the
        // page to reload itself and pick up the new code.
        // 
        Gerrit.upgradeUI(token);
    } else {
        new ErrorDialog(reason).center();
    }
}
#method_after
@Override
public final void onFailure(Throwable reason) {
    if (!isReloadUi && "HTTP download failed with status 404".equals(reason.getMessage())) {
        // The server was upgraded since we last download the main script,
        // so the pointers to the splits aren't valid anymore.  Force the
        // page to reload itself and pick up the new code.
        // 
        Gerrit.upgradeUI(token);
    } else {
        new ErrorDialog(reason).center();
    }
}
#end_block

#method_before
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equals(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnMergeBaseUpdate() && kind == MERGE_FIRST_PARENT_UPDATE) || (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE) || (type.isCopyAllScoresIfNoChange() && kind == NO_CHANGE);
}
#method_after
private static boolean canCopy(ProjectState project, PatchSetApproval psa, PatchSet.Id psId, NavigableSet<Integer> allPsIds, ChangeKind kind) {
    int n = psa.getKey().getParentKey().get();
    checkArgument(n != psId.get());
    LabelType type = project.getLabelTypes().byLabel(psa.getLabelId());
    if (type == null) {
        return false;
    } else if (Objects.equals(n, previous(allPsIds, psId.get())) && (type.isCopyMinScore() && type.isMaxNegative(psa) || type.isCopyMaxScore() && type.isMaxPositive(psa))) {
        // may not be psId.get() - 1).
        return true;
    }
    return (type.isCopyAllScoresOnMergeFirstParentUpdate() && kind == MERGE_FIRST_PARENT_UPDATE) || (type.isCopyAllScoresOnTrivialRebase() && kind == TRIVIAL_REBASE) || (type.isCopyAllScoresIfNoCodeChange() && kind == NO_CODE_CHANGE) || (type.isCopyAllScoresIfNoChange() && kind == NO_CHANGE);
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commitId);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommitId);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = GroupCollector.create(refsById, db, psUtil, notesFactory);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(rp.getRevWalk(), magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        SortedSetMultimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = ImmutableList.copyOf(groups.get(create.commitId));
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = ImmutableList.copyOf(groups.get(replace.newCommitId));
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = ImmutableList.copyOf((groups.get(update.commit)));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false, null);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        List<String> newGroups = groups;
        if (newGroups.isEmpty()) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : ImmutableList.<String>of();
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    if (magicBranch != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        // we cannot reconstruct the submit records for when this change was
        // submitted, this is why we must fix the status
        update.fixStatus(Change.Status.MERGED);
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
public void setCopyAllScoresOnMergeFirstParentUpdate(boolean copyAllScoresOnMergeFirstParentUpdate) {
    this.copyAllScoresOnMergeFirestParentUpdate = copyAllScoresOnMergeFirstParentUpdate;
}
#method_after
public void setCopyAllScoresOnMergeFirstParentUpdate(boolean copyAllScoresOnMergeFirstParentUpdate) {
    this.copyAllScoresOnMergeFirstParentUpdate = copyAllScoresOnMergeFirstParentUpdate;
}
#end_block

#method_before
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            } else {
                return ChangeKind.REWORK;
            }
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && (sameFirstParents(prior, next) || !sameRestOfParents(prior, next))) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // A trivial rebase can be detected by looking for the next commit
        // having the same tree as would exist when the prior commit is
        // cherry-picked onto the next commit's new first parent.
        ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, MergeUtil.createDryRunInserter(repo), key.strategyName);
        merger.setBase(prior.getParent(0));
        try {
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                } else {
                    return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
                }
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    }
}
#method_after
@Override
public ChangeKind call() throws IOException {
    if (Objects.equals(key.prior, key.next)) {
        return ChangeKind.NO_CODE_CHANGE;
    }
    try (RevWalk walk = new RevWalk(repo)) {
        RevCommit prior = walk.parseCommit(key.prior);
        walk.parseBody(prior);
        RevCommit next = walk.parseCommit(key.next);
        walk.parseBody(next);
        if (!next.getFullMessage().equals(prior.getFullMessage())) {
            if (isSameDeltaAndTree(prior, next)) {
                return ChangeKind.NO_CODE_CHANGE;
            } else {
                return ChangeKind.REWORK;
            }
        }
        if (isSameDeltaAndTree(prior, next)) {
            return ChangeKind.NO_CHANGE;
        }
        if ((prior.getParentCount() != 1 || next.getParentCount() != 1) && !onlyFirstParentChanged(prior, next)) {
            // Trivial rebases done by machine only work well on 1 parent.
            return ChangeKind.REWORK;
        }
        // A trivial rebase can be detected by looking for the next commit
        // having the same tree as would exist when the prior commit is
        // cherry-picked onto the next commit's new first parent.
        ThreeWayMerger merger = MergeUtil.newThreeWayMerger(repo, MergeUtil.createDryRunInserter(repo), key.strategyName);
        merger.setBase(prior.getParent(0));
        try {
            if (merger.merge(next.getParent(0), prior) && merger.getResultTreeId().equals(next.getTree())) {
                if (prior.getParentCount() == 1) {
                    return ChangeKind.TRIVIAL_REBASE;
                } else {
                    return ChangeKind.MERGE_FIRST_PARENT_UPDATE;
                }
            }
        } catch (LargeObjectException e) {
        // Some object is too large for the merge attempt to succeed. Assume
        // it was a rework.
        }
        return ChangeKind.REWORK;
    }
}
#end_block

#method_before
private static boolean sameRestOfParents(RevCommit prior, RevCommit next) {
    Set<RevCommit> priorRestParents = mergedInParents(prior.getParents());
    Set<RevCommit> nextRestParents = mergedInParents(next.getParents());
    return priorRestParents.equals(nextRestParents);
}
#method_after
private static boolean sameRestOfParents(RevCommit prior, RevCommit next) {
    Set<RevCommit> priorRestParents = allExceptFirstParent(prior.getParents());
    Set<RevCommit> nextRestParents = allExceptFirstParent(next.getParents());
    return priorRestParents.equals(nextRestParents);
}
#end_block

#method_before
public int shutdown() {
    int cnt = 0;
    if (pool != null) {
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#method_after
public int shutdown() {
    int cnt = 0;
    if (pool != null) {
        for (Runnable r : pool.getQueue()) {
            repLog.warn(String.format("Cancelling replication event %s", r));
        }
        cnt = pool.shutdownNow().size();
        pool.unregisterWorkQueue();
        pool = null;
    }
    return cnt;
}
#end_block

#method_before
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            Repository git;
            try {
                git = gitManager.openRepository(project);
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
            try {
                Ref head = git.getRef(Constants.HEAD);
                if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("cannot check type of project %s", project), err, state);
                return;
            } finally {
                git.close();
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#method_after
void schedule(final Project.NameKey project, final String ref, final URIish uri, ReplicationState state) {
    repLog.info("scheduling replication {}:{} => {}", project, ref, uri);
    if (!isVisible(project, state)) {
        return;
    }
    if (!replicatePermissions) {
        PushOne e;
        synchronized (stateLock) {
            e = pending.get(uri);
        }
        if (e == null) {
            try (Repository git = gitManager.openRepository(project)) {
                try {
                    Ref head = git.exactRef(Constants.HEAD);
                    if (head != null && head.isSymbolic() && RefNames.REFS_CONFIG.equals(head.getLeaf().getName())) {
                        return;
                    }
                } catch (IOException err) {
                    stateLog.error(String.format("cannot check type of project %s", project), err, state);
                    return;
                }
            } catch (IOException err) {
                stateLog.error(String.format("source project %s not available", project), err, state);
                return;
            }
        }
    }
    synchronized (stateLock) {
        PushOne e = pending.get(uri);
        if (e == null) {
            e = opFactory.create(project, uri);
            pool.schedule(e, delay, TimeUnit.SECONDS);
            pending.put(uri, e);
        }
        e.addRef(ref);
        state.increasePushTaskCount(project.get(), ref);
        e.addState(ref, state);
        repLog.info("scheduled {}:{} => {} to run after {}s", project, ref, e, delay);
    }
}
#end_block

#method_before
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, delay, TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, retryDelay, TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#method_after
void reschedule(PushOne pushOp, RetryReason reason) {
    synchronized (stateLock) {
        URIish uri = pushOp.getURI();
        PushOne pendingPushOp = pending.get(uri);
        if (pendingPushOp != null) {
            if (pendingPushOp.isRetrying()) {
                // The one pending is one already retrying, so it should
                // maintain it and add to it the refs of the one passed
                // as parameter to the method.
                // This scenario would happen if a PushOp has started running
                // and then before it failed due transport exception, another
                // one to same URI started. The first one would fail and would
                // be rescheduled, being present in pending list. When the
                // second one fails, it will also be rescheduled and then,
                // here, find out replication to its URI is already pending
                // for retry (blocking).
                pendingPushOp.addRefs(pushOp.getRefs());
                pendingPushOp.addStates(pushOp.getStates());
                pushOp.removeStates();
            } else {
                // The one pending is one that is NOT retrying, it was just
                // scheduled believing no problem would happen. The one pending
                // should be canceled, and this is done by setting its canceled
                // flag, removing it from pending list, and adding its refs to
                // the pushOp instance that should then, later, in this method,
                // be scheduled for retry.
                // Notice that the PushOp found pending will start running and,
                // when notifying it is starting (with pending lock protection),
                // it will see it was canceled and then it will do nothing with
                // pending list and it will not execute its run implementation.
                pendingPushOp.cancel();
                pending.remove(uri);
                pushOp.addRefs(pendingPushOp.getRefs());
                pushOp.addStates(pendingPushOp.getStates());
                pendingPushOp.removeStates();
            }
        }
        if (pendingPushOp == null || !pendingPushOp.isRetrying()) {
            pending.put(uri, pushOp);
            switch(reason) {
                case COLLISION:
                    pool.schedule(pushOp, delay, TimeUnit.SECONDS);
                    break;
                case TRANSPORT_ERROR:
                case REPOSITORY_MISSING:
                default:
                    pushOp.setToRetry();
                    pool.schedule(pushOp, retryDelay, TimeUnit.MINUTES);
                    break;
            }
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationSshSessionFactory.class).to(DefaultReplicationSshSessionFactory.class);
    EventTypes.registerClass(new RefReplicatedEvent(null, null, null, SUCCEEDED));
    EventTypes.registerClass(new RefReplicationDoneEvent(null, null, 0));
}
#method_after
@Override
protected void configure() {
    bind(ReplicationQueue.class).in(Scopes.SINGLETON);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), ProjectDeletedListener.class).to(ReplicationQueue.class);
    DynamicSet.bind(binder(), HeadUpdatedListener.class).to(ReplicationQueue.class);
    bind(OnStartStop.class).in(Scopes.SINGLETON);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(OnStartStop.class);
    bind(LifecycleListener.class).annotatedWith(UniqueAnnotations.create()).to(ReplicationLogFile.class);
    bind(CredentialsFactory.class).to(AutoReloadSecureCredentialsFactoryDecorator.class).in(Scopes.SINGLETON);
    bind(CapabilityDefinition.class).annotatedWith(Exports.named(START_REPLICATION)).to(StartReplicationCapability.class);
    install(new FactoryModuleBuilder().build(PushAll.Factory.class));
    install(new FactoryModuleBuilder().build(RemoteSiteUser.Factory.class));
    bind(ReplicationConfig.class).to(AutoReloadConfigDecorator.class);
    bind(ReplicationStateListener.class).to(ReplicationStateLogger.class);
    EventTypes.register(RefReplicatedEvent.TYPE, RefReplicatedEvent.class);
    EventTypes.register(RefReplicationDoneEvent.TYPE, RefReplicationDoneEvent.class);
    bind(SshSessionFactory.class).toProvider(ReplicationSshSessionFactoryProvider.class);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher, database));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#method_after
@Override
public void onGitReferenceUpdated(GitReferenceUpdatedListener.Event event) {
    ReplicationState state = new ReplicationState(new GitUpdateProcessing(dispatcher.get(), database));
    if (!running) {
        stateLog.warn("Replication plugin did not finish startup before event", state);
        return;
    }
    Project.NameKey project = new Project.NameKey(event.getProjectName());
    for (Destination cfg : config.getDestinations(FilterType.ALL)) {
        if (cfg.wouldPushProject(project) && cfg.wouldPushRef(event.getRefName())) {
            for (URIish uri : cfg.getURIs(project, null)) {
                cfg.schedule(project, event.getRefName(), uri, state);
            }
        }
    }
    state.markAllPushTasksScheduled();
}
#end_block

#method_before
public boolean createProject(Project.NameKey project, String head) {
    boolean success = false;
    for (URIish uri : getURIs(project, FilterType.PROJECT_CREATION)) {
        success &= createProject(uri, head);
    }
    return success;
}
#method_after
public boolean createProject(Project.NameKey project, String head) {
    boolean success = true;
    for (URIish uri : getURIs(project, FilterType.PROJECT_CREATION)) {
        success &= createProject(uri, head);
    }
    return success;
}
#end_block

#method_before
private static void createLocally(URIish uri, String head) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            repo.create(true);
            if (head != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.disableRefLog();
                u.link(head);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#method_after
private static void createLocally(URIish uri, String head) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        repo.create(true);
        if (head != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
        }
    } catch (IOException e) {
        repLog.error(String.format("Error creating local repository %s:\n", uri.getPath()), e);
    }
}
#end_block

#method_before
private static void updateHeadLocally(URIish uri, String newHead) {
    try {
        Repository repo = new FileRepository(uri.getPath());
        try {
            if (newHead != null) {
                RefUpdate u = repo.updateRef(Constants.HEAD);
                u.link(newHead);
            }
        } finally {
            repo.close();
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#method_after
private static void updateHeadLocally(URIish uri, String newHead) {
    try (Repository repo = new FileRepository(uri.getPath())) {
        if (newHead != null) {
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.link(newHead);
        }
    } catch (IOException e) {
        repLog.error(String.format("Failed to update HEAD of repository %s to %s", uri.getPath(), newHead), e);
    }
}
#end_block

#method_before
private RemoteSession connect(URIish uri) throws TransportException {
    return sshSessionFactory.create().getSession(uri, null, FS.DETECTED, 0);
}
#method_after
private RemoteSession connect(URIish uri) throws TransportException {
    return sshSessionFactoryProvider.get().getSession(uri, null, FS.DETECTED, SSH_REMOTE_TIMEOUT);
}
#end_block

#method_before
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && config.isReplicateAllOnPluginStart()) {
        ReplicationState state = new ReplicationState();
        pushAllFuture.set(pushAll.create(null, ReplicationFilter.all(), state).schedule(30, TimeUnit.SECONDS));
    }
}
#method_after
@Override
public void start() {
    queue.start();
    if (srvInfo.getState() == ServerInformation.State.STARTUP && config.isReplicateAllOnPluginStart()) {
        ReplicationState state = new ReplicationState(new GitUpdateProcessing(eventDispatcher.get(), database));
        pushAllFuture.set(pushAll.create(null, ReplicationFilter.all(), state).schedule(30, TimeUnit.SECONDS));
    }
}
#end_block

#method_before
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#method_after
@Override
public void doProjectCreatedHook(Project.NameKey project, String headName) {
    ProjectCreatedEvent event = new ProjectCreatedEvent();
    event.projectName = project.get();
    event.headName = headName;
    fireEvent(project, event);
    if (!projectCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.get());
    addArg(args, "--head", headName);
    runHook(project, projectCreatedHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    if (!commentAddedHook.isPresent()) {
        return;
    }
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval);
                }
                return r;
            }
            return null;
        }
    });
    fireEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    if (!changeMergedHook.isPresent()) {
        return;
    }
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reason = reason;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    fireEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.patchSet = asPatchSetAttribute(change, patchSet, db);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    // patchSetAttributeSupplier(change, patchSet, db);
    event.patchSet = null;
    // accountAttributeSupplier(account);
    event.reviewer = null;
    fireEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    if (!topicChangedHook.isPresent()) {
        return;
    }
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(db, change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
public CheckedFuture<?, IOException> indexAsync(Collection<Change.Id> ids) {
    List<ListenableFuture<?>> futures = new ArrayList<>(ids.size());
    for (Change.Id id : ids) {
        futures.add(indexAsync(id));
    }
    return allAsList(futures);
}
#method_after
public CheckedFuture<?, IOException> indexAsync(Project.NameKey project, Change.Id id) {
    return executor != null ? submit(new IndexTask(project, id)) : Futures.<Object, IOException>immediateCheckedFuture(null);
}
#end_block

#method_before
public void index(ChangeData cd) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd.getId());
}
#method_after
public void index(ChangeData cd) throws IOException {
    for (ChangeIndex i : getWriteIndexes()) {
        i.replace(cd);
    }
    fireChangeIndexedEvent(cd);
}
#end_block

#method_before
private void fireChangeIndexedEvent(Change.Id id) {
    Event indexEvent = createIndexEvent(id);
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeIndexed(indexEvent);
    }
}
#method_after
private void fireChangeIndexedEvent(ChangeData change) {
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeIndexed(change);
    }
}
#end_block

#method_before
private void fireChangeDeletedFromIndexEvent(Change.Id id) {
    Event indexEvent = createIndexEvent(id);
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeDeleted(indexEvent);
    }
}
#method_after
private void fireChangeDeletedFromIndexEvent(Change.Id id) {
    for (ChangeIndexedListener listener : indexedListener) {
        listener.onChangeDeleted(id);
    }
}
#end_block

#method_before
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        RequestContext newCtx = new RequestContext() {

            @Override
            public Provider<ReviewDb> getReviewDbProvider() {
                Provider<ReviewDb> db = dbRef.get();
                if (db == null) {
                    try {
                        db = Providers.of(schemaFactory.open());
                    } catch (OrmException e) {
                        ProvisionException pe = new ProvisionException("error opening ReviewDb");
                        pe.initCause(e);
                        throw pe;
                    }
                    dbRef.set(db);
                }
                return db;
            }

            @Override
            public CurrentUser getUser() {
                throw new OutOfScopeException("No user during ChangeIndexer");
            }
        };
        RequestContext oldCtx = context.setContext(newCtx);
        try {
            ChangeData cd = changeDataFactory.create(newCtx.getReviewDbProvider().get(), id);
            index(cd);
            return null;
        } finally {
            context.setContext(oldCtx);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d", id.get()), e);
        throw e;
    }
}
#method_after
@Override
public Void call() throws Exception {
    try {
        final AtomicReference<Provider<ReviewDb>> dbRef = Atomics.newReference();
        RequestContext newCtx = new RequestContext() {

            @Override
            public Provider<ReviewDb> getReviewDbProvider() {
                Provider<ReviewDb> db = dbRef.get();
                if (db == null) {
                    try {
                        db = Providers.of(schemaFactory.open());
                    } catch (OrmException e) {
                        ProvisionException pe = new ProvisionException("error opening ReviewDb");
                        pe.initCause(e);
                        throw pe;
                    }
                    dbRef.set(db);
                }
                return db;
            }

            @Override
            public CurrentUser getUser() {
                throw new OutOfScopeException("No user during ChangeIndexer");
            }
        };
        RequestContext oldCtx = context.setContext(newCtx);
        try {
            ChangeData cd = changeDataFactory.create(newCtx.getReviewDbProvider().get(), project, id);
            index(cd);
            return null;
        } finally {
            context.setContext(oldCtx);
            Provider<ReviewDb> db = dbRef.get();
            if (db != null) {
                db.get().close();
            }
        }
    } catch (Exception e) {
        log.error(String.format("Failed to index change %d", id.get()), e);
        throw e;
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    bind(Sequences.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(SubmitStrategy.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), ChangeIndexedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), UserScopedEventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    DynamicSet.setOf(binder(), AccountExternalIdCreator.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    factory(ReplaceOp.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        boolean symlinkCheck = cfg.getBoolean(KEY_CHECK_SYMLINK, false);
        if (symlinkCheck) {
            try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
                List<CommitValidationMessage> messages = new LinkedList<>();
                TreeWalk tw = new TreeWalk(repo);
                tw.setRecursive(true);
                tw.setFilter(TreeFilter.ANY_DIFF);
                if (receiveEvent.commit.getParentCount() > 1) {
                    List<RevTree> trees = new ArrayList<>();
                    trees.add(receiveEvent.commit.getTree());
                    for (RevCommit p : receiveEvent.commit.getParents()) {
                        trees.add(p.getTree());
                    }
                    tw.reset(trees.toArray(new AnyObjectId[trees.size()]));
                    while (tw.next()) {
                        boolean diff = true;
                        for (int p = 1; p < trees.size(); p++) {
                            if (tw.getObjectId(0).equals(tw.getObjectId(p))) {
                                diff = false;
                            }
                        }
                        if (((tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK) && diff) {
                            messages.add(new CommitValidationMessage("Symbolic links are not allowed: " + tw.getPathString(), true));
                        }
                    }
                    tw.close();
                } else {
                    tw.reset(receiveEvent.commit.getTree());
                    while (tw.next()) {
                        if ((tw.getRawMode(0) & FileMode.TYPE_MASK) == FileMode.TYPE_SYMLINK)
                            messages.add(new CommitValidationMessage("Symbolic links are not allowed: " + tw.getPathString(), true));
                    }
                }
                if (!messages.isEmpty()) {
                    throw new CommitValidationException("contains symbolic links", messages);
                }
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on invalid line endings", e);
    }
    return Collections.emptyList();
}
#method_after
@Override
public List<CommitValidationMessage> onCommitReceived(CommitReceivedEvent receiveEvent) throws CommitValidationException {
    try {
        PluginConfig cfg = cfgFactory.getFromProjectConfig(receiveEvent.project.getNameKey(), pluginName);
        boolean rejectSymlink = cfg.getBoolean(KEY_CHECK_SYMLINK, false);
        if (!rejectSymlink) {
            return Collections.emptyList();
        }
        try (Repository repo = repoManager.openRepository(receiveEvent.project.getNameKey())) {
            List<CommitValidationMessage> messages = performValidation(repo, receiveEvent.commit);
            if (!messages.isEmpty()) {
                throw new CommitValidationException("contains symbolic links", messages);
            }
        }
    } catch (NoSuchProjectException | IOException e) {
        throw new CommitValidationException("failed to check on symbolic links", e);
    }
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), CommitValidationListener.class).to(FileExtensionValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_BLOCKED_FILE_EXTENSION)).toInstance(new ProjectConfigEntry("Blocked File Extensions", null, ProjectConfigEntry.Type.ARRAY, null, false, "Forbidden file extensions. Pushes of commits that " + "contain files with these extensions will be rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(FooterValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_REQUIRED_FOOTER)).toInstance(new ProjectConfigEntry("Required Footers", null, ProjectConfigEntry.Type.ARRAY, null, false, "Required footers. Pushes of commits that miss any" + " of the footers will be rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(InvalidFilenameValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_INVALID_FILENAME_PATTERN)).toInstance(new ProjectConfigEntry("Invalid Filename Pattern", null, ProjectConfigEntry.Type.ARRAY, null, false, "Invalid filenames. Pushes of commits that " + "contain filenames which match one of these patterns " + "will be rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(SymlinkValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_CHECK_SYMLINK)).toInstance(new ProjectConfigEntry("Contains Symbolic Links", "false", ProjectConfigEntry.Type.BOOLEAN, null, false, "Symbolic Links. " + "Pushes of commits that include symbolic links will be " + "rejected."));
    DynamicSet.bind(binder(), CommitValidationListener.class).to(MaxPathLengthValidator.class);
    bind(ProjectConfigEntry.class).annotatedWith(Exports.named(KEY_MAX_PATH_LENGTH)).toInstance(new ProjectConfigEntry("Max Path Length", 0, false, "Maximum path length. Pushes of commits that " + "contain files with longer paths will be rejected. " + "'0' means no limit."));
}
#method_after
@Override
protected void configure() {
    install(FileExtensionValidator.module());
    install(FooterValidator.module());
    install(InvalidFilenameValidator.module());
    install(InvalidLineEndingValidator.module());
    install(MaxPathLengthValidator.module());
    install(SymlinkValidator.module());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(final Project project, final String refname, final Account uploader, final ObjectId oldId, final ObjectId newId) {
    final List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final DraftPublishedEvent event = new DraftPublishedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    dispatcher.get().postEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<String, Short> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval);
                }
                return r;
            }
            return null;
        }
    });
    dispatcher.get().postEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    dispatcher.get().postEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final MergeFailedEvent event = new MergeFailedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeRestoredEvent event = new ChangeRestoredEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    dispatcher.get().postEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final RefUpdate refUpdate, final Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#method_after
@Override
public void doRefUpdatedHook(Branch.NameKey refName, RefUpdate refUpdate, Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    dispatcher.get().postEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ReviewerAddedEvent event = new ReviewerAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    dispatcher.get().postEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(final Change change, final Account account, final String oldTopic, final ReviewDb db) throws OrmException {
    final TopicChangedEvent event = new TopicChangedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    dispatcher.get().postEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.get().postEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private String getDisplayName(final Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#method_after
private String getDisplayName(Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        final int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#method_after
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.toAbsolutePath().toString());
        argv.addAll(args);
        ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.toAbsolutePath().toString());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        String output = null;
        try (InputStream is = ps.getInputStream()) {
            output = readOutput(is);
        } finally {
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.toAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#end_block

#method_before
protected String getName() {
    return hook.getName();
}
#method_after
protected String getName() {
    return hook.getFileName().toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "hook " + hook.getName();
}
#method_after
@Override
public String toString() {
    return "hook " + hook.getFileName();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(final Project project, final String refname, final Account uploader, final ObjectId oldId, final ObjectId newId) {
    final List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final DraftPublishedEvent event = new DraftPublishedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent();
    AccountState uploader = accountCache.get(patchSet.getUploader());
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<String, Short> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(Change change, Account account, PatchSet patchSet, String comment, Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.newRev = mergeResultRev;
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final MergeFailedEvent event = new MergeFailedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeRestoredEvent event = new ChangeRestoredEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final RefUpdate refUpdate, final Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#method_after
@Override
public void doRefUpdatedHook(Branch.NameKey refName, RefUpdate refUpdate, Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(Branch.NameKey refName, ObjectId oldId, ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    dispatcher.postEvent(refName, event);
    List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ReviewerAddedEvent event = new ReviewerAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(final Change change, final Account account, final String oldTopic, final ReviewDb db) throws OrmException {
    final TopicChangedEvent event = new TopicChangedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    dispatcher.postEvent(change, event, db);
    List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
private String getDisplayName(final Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#method_after
private String getDisplayName(Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Path hook, List<String> args) {
    if (project != null && Files.exists(hook)) {
        hookQueue.execute(new AsyncHookTask(project, hook, args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Path hook, List<String> args) {
    if (!Files.exists(hook)) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        final int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#method_after
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.toAbsolutePath().toString());
        argv.addAll(args);
        ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.toAbsolutePath().toString());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        String output = null;
        try (InputStream is = ps.getInputStream()) {
            output = readOutput(is);
        } finally {
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.toAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#end_block

#method_before
protected String getName() {
    return hook.getName();
}
#method_after
protected String getName() {
    return hook.getFileName().toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "hook " + hook.getName();
}
#method_after
@Override
public String toString() {
    return "hook " + hook.getFileName();
}
#end_block

#method_before
public void fireEvent(Branch.NameKey branchName, final Event event) {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
private void fireEvent(Project.NameKey project, Event event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(project, event, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private boolean isVisibleTo(Branch.NameKey branchName, CurrentUser user) {
    final ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#method_after
private boolean isVisibleTo(Project.NameKey project, Event event, CurrentUser user) {
    ProjectState pe = projectCache.get(project);
    if (pe == null) {
        return false;
    }
    ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(((ProjectCreatedEvent) event).getHeadName()).isVisible();
}
#end_block

#method_before
public void fireEventForUnrestrictedListeners(final Event event) {
    for (ChangeListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#method_after
protected void fireEventForUnrestrictedListeners(final Event event) {
    for (EventListener listener : unrestrictedListeners) {
        listener.onEvent(event);
    }
}
#end_block

#method_before
public void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
protected void fireEvent(final Change change, final Event event, final ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
public void fireEvent(Branch.NameKey branchName, final Event event) {
    for (ChangeListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#method_after
protected void fireEvent(Branch.NameKey branchName, final Event event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private boolean isVisibleTo(Change change, CurrentUser user, ReviewDb db) throws OrmException {
    final ProjectState pe = projectCache.get(change.getProject());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlFor(change).isVisible(db);
}
#method_after
protected boolean isVisibleTo(Change change, CurrentUser user, ReviewDb db) throws OrmException {
    ProjectState pe = projectCache.get(change.getProject());
    if (pe == null) {
        return false;
    }
    ProjectControl pc = pe.controlFor(user);
    return pc.controlFor(change).isVisible(db);
}
#end_block

#method_before
private boolean isVisibleTo(Branch.NameKey branchName, CurrentUser user) {
    final ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    final ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#method_after
protected boolean isVisibleTo(Branch.NameKey branchName, CurrentUser user) {
    ProjectState pe = projectCache.get(branchName.getParentKey());
    if (pe == null) {
        return false;
    }
    ProjectControl pc = pe.controlFor(user);
    return pc.controlForRef(branchName).isVisible();
}
#end_block

#method_before
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            MergeOp.checkSubmitRule(c);
        }
        Boolean csIsMergeable = isPatchSetMergeable(cs);
        if (csIsMergeable == null) {
            return CLICK_FAILURE_TOOLTIP;
        } else if (!csIsMergeable) {
            return CHANGES_NOT_MERGEABLE;
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException | IOException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#method_after
private String problemsForSubmittingChangeset(ChangeSet cs, IdentifiedUser identifiedUser) {
    try {
        @SuppressWarnings("resource")
        ReviewDb db = dbProvider.get();
        for (ChangeData c : cs.changes()) {
            ChangeControl changeControl = c.changeControl(identifiedUser);
            if (!changeControl.isVisible(db)) {
                return BLOCKED_HIDDEN_SUBMIT_TOOLTIP;
            }
            if (!changeControl.canSubmit()) {
                return BLOCKED_SUBMIT_TOOLTIP;
            }
            // Recheck mergeability rather than using value stored in the index,
            // which may be stale.
            // TODO(dborowitz): This is ugly; consider providing a way to not read
            // stored fields from the index in the first place.
            c.setMergeable(null);
            Boolean mergeable = c.isMergeable();
            if (mergeable == null) {
                log.error("Ephemeral error checking if change is submittable");
                return CLICK_FAILURE_TOOLTIP;
            }
            if (!mergeable) {
                return CHANGES_NOT_MERGEABLE;
            }
            MergeOp.checkSubmitRule(c);
        }
    } catch (ResourceConflictException e) {
        return BLOCKED_SUBMIT_TOOLTIP;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    return null;
}
#end_block

#method_before
@Override
protected void configure() {
    if (ui) {
        DynamicSet.bind(binder(), TopMenu.class).to(ReviewersTopMenu.class);
    }
    DynamicSet.bind(binder(), EventListener.class).to(ChangeEventListener.class);
    factory(DefaultReviewers.Factory.class);
    factory(ReviewersConfig.Factory.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "reviewers").to(GetReviewers.class);
            put(PROJECT_KIND, "reviewers").to(PutReviewers.class);
            get(PROJECT_KIND, "suggest_reviewers").to(SuggestReviewers.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    if (ui) {
        DynamicSet.bind(binder(), TopMenu.class).to(ReviewersTopMenu.class);
    }
    DynamicSet.bind(binder(), EventListener.class).to(ChangeEventListener.class);
    factory(DefaultReviewers.Factory.class);
    factory(ReviewersConfig.Factory.class);
    install(new RestApiModule() {

        @Override
        protected void configure() {
            get(PROJECT_KIND, "reviewers").to(GetReviewers.class);
            put(PROJECT_KIND, "reviewers").to(PutReviewers.class);
            get(PROJECT_KIND, "suggest_reviewers").to(SuggestProjectReviewers.class);
        }
    });
}
#end_block

#method_before
Panel createInputPanel() {
    final NpTextBox filterBox = new NpTextBox();
    // TODO(davido): Remove hard coded start suggest char 3
    final ReviewerSuggestOracle oracle = new ReviewerSuggestOracle(3, projectName);
    final SuggestBox reviewerBox = new SuggestBox(oracle, new NpTextBox());
    filterBox.getElement().setPropertyString("placeholder", "filter");
    reviewerBox.getElement().setPropertyString("placeholder", "reviewer");
    Button addButton = new Button("Add");
    addButton.setStyleName("reviewers-addButton");
    addButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            ReviewerEntry e = new ReviewerEntry(filterBox.getValue(), reviewerBox.getValue());
            if (!rEntries.contains(e) && !e.filter.isEmpty() && !e.reviewer.isEmpty()) {
                doSave(Action.ADD, e);
            }
            filterBox.setText("");
            reviewerBox.setText("");
        }
    });
    filterBox.setEnabled(isOwner);
    reviewerBox.setEnabled(isOwner);
    addButton.setEnabled(isOwner);
    Panel p = new VerticalPanel();
    p.setStyleName("reviewers-inputPanel");
    p.add(filterBox);
    p.add(reviewerBox);
    p.add(addButton);
    return p;
}
#method_after
Panel createInputPanel() {
    Grid inputGrid = new Grid(2, 2);
    final NpTextBox filterBox = new NpTextBox();
    filterBox.getElement().setPropertyString("placeholder", "filter");
    inputGrid.setText(0, 0, "Filter: ");
    inputGrid.setWidget(0, 1, filterBox);
    // TODO(davido): Remove hard coded start suggest char 3
    final ReviewerSuggestOracle oracle = new ReviewerSuggestOracle(3, projectName);
    final SuggestBox reviewerBox = new SuggestBox(oracle, new NpTextBox());
    reviewerBox.getElement().setPropertyString("placeholder", "reviewer");
    inputGrid.setText(1, 0, "Reviewer: ");
    inputGrid.setWidget(1, 1, reviewerBox);
    Button addButton = new Button("Add");
    addButton.setStyleName("reviewers-addButton");
    addButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            ReviewerEntry e = new ReviewerEntry(filterBox.getValue(), reviewerBox.getValue());
            if (!rEntries.contains(e) && !e.filter.isEmpty() && !e.reviewer.isEmpty()) {
                doSave(Action.ADD, e);
            }
            filterBox.setText("");
            reviewerBox.setText("");
        }
    });
    filterBox.setEnabled(isOwner);
    reviewerBox.setEnabled(isOwner);
    addButton.setEnabled(isOwner);
    Panel p = new VerticalPanel();
    p.setStyleName("reviewers-inputPanel");
    p.add(inputGrid);
    p.add(addButton);
    return p;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(ChangeSuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestChangeReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        ChangeSuggestReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#method_after
private List<SuggestedReviewerInfo> suggestReviewers(SuggestedReviewersRequest r) throws RestApiException {
    try {
        SuggestChangeReviewers mySuggestReviewers = suggestReviewers.get();
        mySuggestReviewers.setQuery(r.getQuery());
        mySuggestReviewers.setLimit(r.getLimit());
        return mySuggestReviewers.apply(change);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot retrieve suggested reviewers", e);
    }
}
#end_block

#method_before
@Override
public String getChangeAvatarUrl(IdentifiedUser forUser) {
    return changeUrl;
}
#method_after
@Override
public String getChangeAvatarUrl(IdentifiedUser forUser) {
    return changeAvatarUrl;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangeHookRunner.class);
    bind(ChangeHooks.class).to(ChangeHookRunner.class);
    bind(EventDispatcher.class).to(ChangeHookRunner.class);
    bind(EventSource.class).to(ChangeHookRunner.class);
    DynamicSet.bind(binder(), NewProjectCreatedListener.class).to(ChangeHookRunner.class);
    listener().to(ChangeHookRunner.class);
}
#end_block

#method_before
private Repository openRepository(final Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#method_after
private Repository openRepository(Project.NameKey name) {
    try {
        return repoManager.openRepository(name);
    } catch (IOException err) {
        log.warn("Cannot open repository " + name.get(), err);
        return null;
    }
}
#end_block

#method_before
@Override
public HookResult doRefUpdateHook(final Project project, final String refname, final Account uploader, final ObjectId oldId, final ObjectId newId) {
    final List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#method_after
@Override
public HookResult doRefUpdateHook(Project project, String refname, Account uploader, ObjectId oldId, ObjectId newId) {
    if (!refUpdateHook.isPresent()) {
        return null;
    }
    List<String> args = new ArrayList<>();
    addArg(args, "--project", project.getName());
    addArg(args, "--refname", refname);
    addArg(args, "--uploader", getDisplayName(uploader));
    addArg(args, "--oldrev", oldId.getName());
    addArg(args, "--newrev", newId.getName());
    return runSyncHook(project.getNameKey(), refUpdateHook, args);
}
#end_block

#method_before
@Override
public void doPatchsetCreatedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final PatchSetCreatedEvent event = new PatchSetCreatedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(event.patchSet.kind));
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#method_after
@Override
public void doPatchsetCreatedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    PatchSetCreatedEvent event = new PatchSetCreatedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!patchsetCreatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", String.valueOf(patchSet.isDraft()));
    addArg(args, "--kind", String.valueOf(ps.kind));
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), patchsetCreatedHook, args);
}
#end_block

#method_before
@Override
public void doDraftPublishedHook(final Change change, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final DraftPublishedEvent event = new DraftPublishedEvent();
    final AccountState uploader = accountCache.get(patchSet.getUploader());
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.uploader = eventFactory.asAccountAttribute(uploader.getAccount());
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--uploader", getDisplayName(uploader.getAccount()));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--patchset", event.patchSet.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#method_after
@Override
public void doDraftPublishedHook(Change change, PatchSet patchSet, ReviewDb db) throws OrmException {
    DraftPublishedEvent event = new DraftPublishedEvent(change);
    Supplier<AccountState> uploader = getAccountSupplier(patchSet.getUploader());
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.uploader = accountAttributeSupplier(uploader);
    fireEvent(change, event, db);
    if (!draftPublishedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--uploader", getDisplayName(uploader.get().getAccount()));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--patchset", ps.number);
    runHook(change.getProject(), draftPublishedHook, args);
}
#end_block

#method_before
@Override
public void doCommentAddedHook(final Change change, final Account account, final PatchSet patchSet, final String comment, final Map<String, Short> approvals, final ReviewDb db) throws OrmException {
    final CommentAddedEvent event = new CommentAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.author = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.comment = comment;
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    if (approvals.size() > 0) {
        event.approvals = new ApprovalAttribute[approvals.size()];
        int i = 0;
        for (Map.Entry<String, Short> approval : approvals.entrySet()) {
            event.approvals[i++] = getApprovalAttribute(labelTypes, approval);
        }
    }
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#method_after
@Override
public void doCommentAddedHook(final Change change, Account account, PatchSet patchSet, String comment, final Map<String, Short> approvals, ReviewDb db) throws OrmException {
    CommentAddedEvent event = new CommentAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.author = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.comment = comment;
    event.approvals = Suppliers.memoize(new Supplier<ApprovalAttribute[]>() {

        @Override
        public ApprovalAttribute[] get() {
            LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
            if (approvals.size() > 0) {
                ApprovalAttribute[] r = new ApprovalAttribute[approvals.size()];
                int i = 0;
                for (Map.Entry<String, Short> approval : approvals.entrySet()) {
                    r[i++] = getApprovalAttribute(labelTypes, approval);
                }
                return r;
            }
            return null;
        }
    });
    fireEvent(change, event, db);
    if (!commentAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--is-draft", patchSet.isDraft() ? "true" : "false");
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--author", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--comment", comment == null ? "" : comment);
    LabelTypes labelTypes = projectCache.get(change.getProject()).getLabelTypes();
    for (Map.Entry<String, Short> approval : approvals.entrySet()) {
        LabelType lt = labelTypes.byLabel(approval.getKey());
        if (lt != null) {
            addArg(args, "--" + lt.getName(), Short.toString(approval.getValue()));
        }
    }
    runHook(change.getProject(), commentAddedHook, args);
}
#end_block

#method_before
@Override
public void doChangeMergedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ChangeMergedEvent event = new ChangeMergedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    runHook(change.getProject(), changeMergedHook, args);
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) throws OrmException {
    ChangeMergedEvent event = new ChangeMergedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.newRev = mergeResultRev;
    fireEvent(change, event, db);
    if (!changeMergedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--newrev", mergeResultRev);
    runHook(change.getProject(), changeMergedHook, args);
}
#end_block

#method_before
@Override
public void doMergeFailedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final MergeFailedEvent event = new MergeFailedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.submitter = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#method_after
@Override
public void doMergeFailedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    MergeFailedEvent event = new MergeFailedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.submitter = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!mergeFailedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--submitter", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), mergeFailedHook, args);
}
#end_block

#method_before
@Override
public void doChangeAbandonedHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeAbandonedEvent event = new ChangeAbandonedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.abandoner = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#method_after
@Override
public void doChangeAbandonedHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeAbandonedEvent event = new ChangeAbandonedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.abandoner = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeAbandonedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--abandoner", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeAbandonedHook, args);
}
#end_block

#method_before
@Override
public void doChangeRestoredHook(final Change change, final Account account, final PatchSet patchSet, final String reason, final ReviewDb db) throws OrmException {
    final ChangeRestoredEvent event = new ChangeRestoredEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.restorer = eventFactory.asAccountAttribute(account);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--topic", event.change.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", event.patchSet.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#method_after
@Override
public void doChangeRestoredHook(Change change, Account account, PatchSet patchSet, String reason, ReviewDb db) throws OrmException {
    ChangeRestoredEvent event = new ChangeRestoredEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.restorer = accountAttributeSupplier(account);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reason = reason;
    fireEvent(change, event, db);
    if (!changeRestoredHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    PatchSetAttribute ps = event.patchSet.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--topic", c.topic);
    addArg(args, "--restorer", getDisplayName(account));
    addArg(args, "--commit", ps.revision);
    addArg(args, "--reason", reason == null ? "" : reason);
    runHook(change.getProject(), changeRestoredHook, args);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final RefUpdate refUpdate, final Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#method_after
@Override
public void doRefUpdatedHook(Branch.NameKey refName, RefUpdate refUpdate, Account account) {
    doRefUpdatedHook(refName, refUpdate.getOldObjectId(), refUpdate.getNewObjectId(), account);
}
#end_block

#method_before
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, final Account account) {
    final RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = eventFactory.asAccountAttribute(account);
    }
    event.refUpdate = eventFactory.asRefUpdateAttribute(oldId, newId, refName);
    fireEvent(refName, event);
    final List<String> args = new ArrayList<>();
    addArg(args, "--oldrev", event.refUpdate.oldRev);
    addArg(args, "--newrev", event.refUpdate.newRev);
    addArg(args, "--refname", event.refUpdate.refName);
    addArg(args, "--project", event.refUpdate.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#method_after
@Override
public void doRefUpdatedHook(final Branch.NameKey refName, final ObjectId oldId, final ObjectId newId, Account account) {
    RefUpdatedEvent event = new RefUpdatedEvent();
    if (account != null) {
        event.submitter = accountAttributeSupplier(account);
    }
    event.refUpdate = Suppliers.memoize(new Supplier<RefUpdateAttribute>() {

        @Override
        public RefUpdateAttribute get() {
            return eventFactory.asRefUpdateAttribute(oldId, newId, refName);
        }
    });
    fireEvent(refName, event);
    if (!refUpdatedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    RefUpdateAttribute r = event.refUpdate.get();
    addArg(args, "--oldrev", r.oldRev);
    addArg(args, "--newrev", r.newRev);
    addArg(args, "--refname", r.refName);
    addArg(args, "--project", r.project);
    if (account != null) {
        addArg(args, "--submitter", getDisplayName(account));
    }
    runHook(refName.getParentKey(), refUpdatedHook, args);
}
#end_block

#method_before
@Override
public void doReviewerAddedHook(final Change change, final Account account, final PatchSet patchSet, final ReviewDb db) throws OrmException {
    final ReviewerAddedEvent event = new ReviewerAddedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.patchSet = eventFactory.asPatchSetAttribute(patchSet);
    event.reviewer = eventFactory.asAccountAttribute(account);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-url", event.change.url);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#method_after
@Override
public void doReviewerAddedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) throws OrmException {
    ReviewerAddedEvent event = new ReviewerAddedEvent(change);
    Supplier<AccountState> owner = getAccountSupplier(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.patchSet = patchSetAttributeSupplier(change, patchSet);
    event.reviewer = accountAttributeSupplier(account);
    fireEvent(change, event, db);
    if (!reviewerAddedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-url", c.url);
    addArg(args, "--change-owner", getDisplayName(owner.get().getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--reviewer", getDisplayName(account));
    runHook(change.getProject(), reviewerAddedHook, args);
}
#end_block

#method_before
@Override
public void doTopicChangedHook(final Change change, final Account account, final String oldTopic, final ReviewDb db) throws OrmException {
    final TopicChangedEvent event = new TopicChangedEvent();
    final AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.changer = eventFactory.asAccountAttribute(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", event.change.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#method_after
@Override
public void doTopicChangedHook(Change change, Account account, String oldTopic, ReviewDb db) throws OrmException {
    TopicChangedEvent event = new TopicChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.changer = accountAttributeSupplier(account);
    event.oldTopic = oldTopic;
    fireEvent(change, event, db);
    if (!topicChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--changer", getDisplayName(account));
    addArg(args, "--old-topic", oldTopic);
    addArg(args, "--new-topic", c.topic);
    runHook(change.getProject(), topicChangedHook, args);
}
#end_block

#method_before
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent();
    AccountState owner = accountCache.get(change.getOwner());
    event.change = eventFactory.asChangeAttribute(change);
    event.editor = eventFactory.asAccountAttribute(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    final List<String> args = new ArrayList<>();
    addArg(args, "--change", event.change.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", event.change.project);
    addArg(args, "--branch", event.change.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#method_after
@Override
public void doHashtagsChangedHook(Change change, Account account, Set<String> added, Set<String> removed, Set<String> hashtags, ReviewDb db) throws OrmException {
    HashtagsChangedEvent event = new HashtagsChangedEvent(change);
    AccountState owner = accountCache.get(change.getOwner());
    event.change = changeAttributeSupplier(change);
    event.editor = accountAttributeSupplier(account);
    event.hashtags = hashtagArray(hashtags);
    event.added = hashtagArray(added);
    event.removed = hashtagArray(removed);
    fireEvent(change, event, db);
    if (!hashtagsChangedHook.isPresent()) {
        return;
    }
    List<String> args = new ArrayList<>();
    ChangeAttribute c = event.change.get();
    addArg(args, "--change", c.id);
    addArg(args, "--change-owner", getDisplayName(owner.getAccount()));
    addArg(args, "--project", c.project);
    addArg(args, "--branch", c.branch);
    addArg(args, "--editor", getDisplayName(account));
    if (hashtags != null) {
        for (String hashtag : hashtags) {
            addArg(args, "--hashtag", hashtag);
        }
    }
    if (added != null) {
        for (String hashtag : added) {
            addArg(args, "--added", hashtag);
        }
    }
    if (removed != null) {
        for (String hashtag : removed) {
            addArg(args, "--removed", hashtag);
        }
    }
    runHook(change.getProject(), hashtagsChangedHook, args);
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
    if (account != null) {
        final List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", cla.getName());
        runHook(claSignedHook, args);
    }
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
    if (!claSignedHook.isPresent()) {
        return;
    }
    if (account != null) {
        List<String> args = new ArrayList<>();
        addArg(args, "--submitter", getDisplayName(account));
        addArg(args, "--user-id", account.getId().toString());
        addArg(args, "--cla-name", claName);
        runHook(claSignedHook, args);
    }
}
#end_block

#method_before
@Override
public void postEvent(final Change change, final ChangeEvent event, final ReviewDb db) throws OrmException {
    fireEvent(change, event, db);
}
#method_after
@Override
public void postEvent(Change change, ChangeEvent event, ReviewDb db) throws OrmException {
    fireEvent(change, event, db);
}
#end_block

#method_before
@Override
public void postEvent(final Branch.NameKey branchName, final RefEvent event) {
    fireEvent(branchName, event);
}
#method_after
@Override
public void postEvent(Branch.NameKey branchName, RefEvent event) {
    fireEvent(branchName, event);
}
#end_block

#method_before
@Override
public void postEvent(final Branch.NameKey branchName, final RefEvent event) {
    fireEvent(branchName, event);
}
#method_after
@Override
public void postEvent(com.google.gerrit.server.events.Event event, ReviewDb db) throws OrmException {
    fireEvent(event, db);
}
#end_block

#method_before
private void fireEvent(final Change change, final ChangeEvent event, final ReviewDb db) throws OrmException {
    dispatcher.fireEvent(change, event, db);
}
#method_after
private void fireEvent(Change change, ChangeEvent event, ReviewDb db) throws OrmException {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(change, holder.user, db)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final RefEvent event) {
    dispatcher.fireEvent(branchName, event);
}
#method_after
private void fireEvent(Project.NameKey project, ProjectEvent event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(project, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private void fireEvent(Branch.NameKey branchName, final RefEvent event) {
    dispatcher.fireEvent(branchName, event);
}
#method_after
private void fireEvent(Branch.NameKey branchName, RefEvent event) {
    for (EventListenerHolder holder : listeners.values()) {
        if (isVisibleTo(branchName, holder.user)) {
            holder.listener.onEvent(event);
        }
    }
    fireEventForUnrestrictedListeners(event);
}
#end_block

#method_before
private String getDisplayName(final Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#method_after
private String getDisplayName(Account account) {
    if (account != null) {
        String result = (account.getFullName() == null) ? anonymousCowardName : account.getFullName();
        if (account.getPreferredEmail() != null) {
            result += " (" + account.getPreferredEmail() + ")";
        }
        return result;
    }
    return anonymousCowardName;
}
#end_block

#method_before
private synchronized void runHook(File hook, List<String> args) {
    if (hook.exists()) {
        hookQueue.execute(new AsyncHookTask(null, hook, args));
    }
}
#method_after
private synchronized void runHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (project != null && hook.isPresent()) {
        hookQueue.execute(new AsyncHookTask(project, hook.get(), args));
    }
}
#end_block

#method_before
private HookResult runSyncHook(Project.NameKey project, File hook, List<String> args) {
    if (!hook.exists()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook, args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.getAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.getAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#method_after
private HookResult runSyncHook(Project.NameKey project, Optional<Path> hook, List<String> args) {
    if (!hook.isPresent()) {
        return null;
    }
    SyncHookTask syncHook = new SyncHookTask(project, hook.get(), args);
    FutureTask<HookResult> task = new FutureTask<>(syncHook);
    syncHookThreadPool.execute(task);
    String message;
    try {
        return task.get(syncHookTimeout, TimeUnit.SECONDS);
    } catch (TimeoutException e) {
        message = "Synchronous hook timed out " + hook.get().toAbsolutePath();
        log.error(message);
    } catch (Exception e) {
        message = "Error running hook " + hook.get().toAbsolutePath();
        log.error(message, e);
    }
    task.cancel(true);
    syncHook.cancel();
    return new HookResult(syncHook.getOutput(), message);
}
#end_block

#method_before
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        final List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.getAbsolutePath());
        argv.addAll(args);
        final ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        final Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.getAbsolutePath());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        InputStream is = ps.getInputStream();
        String output = null;
        try {
            output = readOutput(is);
        } finally {
            try {
                is.close();
            } catch (IOException closeErr) {
            }
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.getAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        final int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#method_after
protected HookResult runHook() {
    Repository repo = null;
    HookResult result = null;
    try {
        List<String> argv = new ArrayList<>(1 + args.size());
        argv.add(hook.toAbsolutePath().toString());
        argv.addAll(args);
        ProcessBuilder pb = new ProcessBuilder(argv);
        pb.redirectErrorStream(true);
        if (project != null) {
            repo = openRepository(project);
        }
        Map<String, String> env = pb.environment();
        env.put("GERRIT_SITE", sitePaths.site_path.toAbsolutePath().toString());
        if (repo != null) {
            pb.directory(repo.getDirectory());
            env.put("GIT_DIR", repo.getDirectory().getAbsolutePath());
        }
        ps = pb.start();
        ps.getOutputStream().close();
        String output = null;
        try (InputStream is = ps.getInputStream()) {
            output = readOutput(is);
        } finally {
            ps.waitFor();
            result = new HookResult(ps.exitValue(), output);
        }
    } catch (InterruptedException iex) {
    // InterruptedExeception - timeout or cancel
    } catch (Throwable err) {
        log.error("Error running hook " + hook.toAbsolutePath(), err);
    } finally {
        if (repo != null) {
            repo.close();
        }
    }
    if (result != null) {
        int exitValue = result.getExitValue();
        if (exitValue == 0) {
            log.debug("hook[" + getName() + "] exitValue:" + exitValue);
        } else {
            log.info("hook[" + getName() + "] exitValue:" + exitValue);
        }
        BufferedReader br = new BufferedReader(new StringReader(result.getOutput()));
        try {
            String line;
            while ((line = br.readLine()) != null) {
                log.info("hook[" + getName() + "] output: " + line);
            }
        } catch (IOException iox) {
            log.error("Error writing hook output", iox);
        }
    }
    return result;
}
#end_block

#method_before
protected String getName() {
    return hook.getName();
}
#method_after
protected String getName() {
    return hook.getFileName().toString();
}
#end_block

#method_before
@Override
public String toString() {
    return "hook " + hook.getName();
}
#method_after
@Override
public String toString() {
    return "hook " + hook.getFileName();
}
#end_block

#method_before
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db) {
}
#method_after
@Override
public void doChangeMergedHook(Change change, Account account, PatchSet patchSet, ReviewDb db, String mergeResultRev) {
}
#end_block

#method_before
@Override
public void doClaSignupHook(Account account, ContributorAgreement cla) {
}
#method_after
@Override
public void doClaSignupHook(Account account, String claName) {
}
#end_block

#method_before
@Override
public void postEvent(Branch.NameKey branchName, RefEvent event) {
}
#method_after
@Override
public void postEvent(Event event, ReviewDb db) {
}
#end_block

#method_before
private String replaceInUrl(String placeholder, String url, String replacement) {
    if (replacement == null || url == null || url.contains(placeholder) == false) {
        return url;
    }
    // as we can't assume anything of 'replacement', we're URL encoding it
    return url.replace(placeholder, Url.encode(replacement));
}
#method_after
private String replaceInUrl(String placeholder, String url, String replacement) {
    if (!url.contains(placeholder)) {
        return url;
    }
    // as we can't assume anything of 'replacement', we're URL encoding it
    return url.replace(placeholder, Url.encode(replacement));
}
#end_block

#method_before
private void saveCookie() {
    if (response == null) {
        return;
    }
    final String token;
    final int ageSeconds;
    if (key == null) {
        token = "";
        ageSeconds = 0;
    } else {
        token = key.getToken();
        ageSeconds = manager.getCookieAge(val);
    }
    String path = authConfig.getCookiePath();
    if (path == null || path.isEmpty()) {
        path = request.getContextPath();
        if (path == null || path.isEmpty()) {
            path = "/";
        }
    }
    if (outCookie != null) {
        throw new IllegalStateException("Cookie " + ACCOUNT_COOKIE + " was set");
    }
    outCookie = new Cookie(ACCOUNT_COOKIE, token);
    String domain = authConfig.getCookieDomain();
    if (domain != null && !domain.isEmpty()) {
        outCookie.setDomain(domain);
    }
    outCookie.setSecure(isSecure(request));
    outCookie.setPath(path);
    outCookie.setMaxAge(ageSeconds);
    outCookie.setSecure(authConfig.getCookieSecure());
    response.addCookie(outCookie);
}
#method_after
private void saveCookie() {
    if (response == null) {
        return;
    }
    final String token;
    final int ageSeconds;
    if (key == null) {
        token = "";
        ageSeconds = 0;
    } else {
        token = key.getToken();
        ageSeconds = manager.getCookieAge(val);
    }
    String path = authConfig.getCookiePath();
    if (Strings.isNullOrEmpty(path)) {
        path = request.getContextPath();
        if (Strings.isNullOrEmpty(path)) {
            path = "/";
        }
    }
    if (outCookie != null) {
        throw new IllegalStateException("Cookie " + ACCOUNT_COOKIE + " was set");
    }
    outCookie = new Cookie(ACCOUNT_COOKIE, token);
    String domain = authConfig.getCookieDomain();
    if (!Strings.isNullOrEmpty(domain)) {
        outCookie.setDomain(domain);
    }
    outCookie.setSecure(isSecure(request));
    outCookie.setPath(path);
    outCookie.setMaxAge(ageSeconds);
    outCookie.setSecure(authConfig.getCookieSecure());
    response.addCookie(outCookie);
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Patch Set 1: Reverted\n\n" + "A change to revert this patchset was created: %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Created a revert of this change as %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db.get())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Patch Set ").append(patchSetId.get()).append(": Reverted");
    msgBuf.append("\n\n");
    msgBuf.append("A change to revert this patchset was created: ").append("I").append(computedChangeId.name());
    changeMessage.setMessage(msgBuf.toString());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws Exception {
    Change change = ctx.getChange();
    PatchSet.Id patchSetId = change.currentPatchSetId();
    ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db.get())), ctx.getUser().getAccountId(), ctx.getWhen(), patchSetId);
    StringBuilder msgBuf = new StringBuilder();
    msgBuf.append("Created a revert of this change as ").append("I").append(computedChangeId.name());
    changeMessage.setMessage(msgBuf.toString());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getUpdate(patchSetId), changeMessage);
    return true;
}
#end_block

#method_before
@Before
public void setTimeForTesting() {
    systemTimeZone = System.setProperty("user.timezone", "US/Eastern");
    resetTimeWithClockStep(1, MILLISECONDS);
}
#method_after
@Before
public void setTimeForTesting() {
    resetTimeWithClockStep(1, MILLISECONDS);
}
#end_block

#method_before
private void resetTimeWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    // TODO(dborowitz): Figure out why tests fail when stubbing out
    // SystemReader.
    TestTimeUtil.resetWithClockStep(clockStep, clockStepUnit);
    SystemReader.setInstance(null);
}
#method_after
private void resetTimeWithClockStep(long clockStep, TimeUnit clockStepUnit) {
    systemTimeZone = System.setProperty("user.timezone", "US/Eastern");
    // TODO(dborowitz): Figure out why tests fail when stubbing out
    // SystemReader.
    TestTimeUtil.resetWithClockStep(clockStep, clockStepUnit);
    SystemReader.setInstance(null);
}
#end_block

#method_before
@Test
public void updatedOrderWithMinuteResolution() throws Exception {
    resetTimeWithClockStep(2, MINUTES);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).current().review(new ReviewInput());
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isGreaterThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#method_after
@Test
public void updatedOrderWithMinuteResolution() throws Exception {
    resetTimeWithClockStep(2, MINUTES);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).topic("new-topic");
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isGreaterThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#end_block

#method_before
@Test
public void updatedOrderWithSubMinuteResolution() throws Exception {
    resetTimeWithClockStep(1, SECONDS);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).current().review(new ReviewInput());
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isLessThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#method_after
@Test
public void updatedOrderWithSubMinuteResolution() throws Exception {
    resetTimeWithClockStep(1, SECONDS);
    TestRepository<Repo> repo = createProject("repo");
    ChangeInserter ins1 = newChange(repo);
    Change change1 = insert(repo, ins1);
    Change change2 = insert(repo, newChange(repo));
    assertThat(lastUpdatedMs(change1)).isLessThan(lastUpdatedMs(change2));
    assertQuery("status:new", change2, change1);
    gApi.changes().id(change1.getId().get()).topic("new-topic");
    change1 = notesFactory.create(db, change1.getProject(), change1.getId()).getChange();
    assertThat(lastUpdatedMs(change1)).isGreaterThan(lastUpdatedMs(change2));
    assertThat(lastUpdatedMs(change1) - lastUpdatedMs(change2)).isLessThan(MILLISECONDS.convert(1, MINUTES));
    // change1 moved to the top.
    assertQuery("status:new", change1, change2);
}
#end_block

#method_before
@Override
public void afterUpdateRepos() throws ResourceConflictException {
    try {
        markCleanMerges();
        checkCommitStatus();
        findUnmergedChanges();
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#method_after
@Override
public void afterUpdateRepos() throws ResourceConflictException {
    try {
        markCleanMerges();
        List<Change.Id> alreadyMerged = checkCommitStatus();
        findUnmergedChanges(alreadyMerged);
    } catch (IntegrationException e) {
        throw new ResourceConflictException(e.getMessage(), e);
    }
}
#end_block

#method_before
private void findUnmergedChanges() throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip());
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private void findUnmergedChanges(List<Change.Id> alreadyMerged) throws ResourceConflictException, IntegrationException {
    for (SubmitStrategy strategy : strategies) {
        if (strategy instanceof CherryPick) {
            // Might have picked a subset of changes, can't do this sanity check.
            continue;
        }
        SubmitStrategy.Arguments args = strategy.args;
        Set<Change.Id> unmerged = args.mergeUtil.findUnmergedChanges(args.commits.getChangeIds(args.destBranch), args.rw, args.canMergeFlag, args.mergeTip.getInitialTip(), args.mergeTip.getCurrentTip(), alreadyMerged);
        for (Change.Id id : unmerged) {
            commits.problem(id, "internal error: change not reachable from new branch tip");
        }
    }
    commits.maybeFailVerbose();
}
#end_block

#method_before
private void checkCommitStatus() throws ResourceConflictException {
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            return;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
            case ALREADY_MERGED:
                // Merge strategy accepted this change.
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
}
#method_after
private List<Change.Id> checkCommitStatus() throws ResourceConflictException {
    List<Change.Id> alreadyMerged = new ArrayList<>(commits.getChangeIds().size());
    for (Change.Id id : commits.getChangeIds()) {
        CodeReviewCommit commit = commits.get(id);
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            commits.problem(id, "internal error: change not processed by merge strategy");
            continue;
        }
        switch(s) {
            case CLEAN_MERGE:
            case CLEAN_REBASE:
            case CLEAN_PICK:
                // Merge strategy accepted this change.
                break;
            case ALREADY_MERGED:
                // Already an ancestor of tip.
                alreadyMerged.add(commit.getPatchsetId().getParentKey());
                break;
            case PATH_CONFLICT:
            case REBASE_MERGE_CONFLICT:
            case MANUAL_RECURSIVE_MERGE:
            case CANNOT_CHERRY_PICK_ROOT:
            case CANNOT_REBASE_ROOT:
            case NOT_FAST_FORWARD:
                // TODO(dborowitz): Reformat these messages to be more appropriate for
                // short problem descriptions.
                commits.problem(id, CharMatcher.is('\n').collapseFrom(s.getMessage(), ' '));
                break;
            case MISSING_DEPENDENCY:
                commits.problem(id, "depends on change that was not submitted");
                break;
            default:
                commits.problem(id, "unspecified merge failure: " + s);
                break;
        }
    }
    commits.maybeFailVerbose();
    return alreadyMerged;
}
#end_block

#method_before
void close() {
    if (update != null) {
        update.close();
    }
    ins.close();
    rw.close();
    repo.close();
}
#method_after
void close() {
    if (update != null) {
        update.close();
    }
    rw.close();
    reader.close();
    ins.close();
    repo.close();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    maximumPageSize = new ListBox();
    for (final int v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferencesInfo.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferencesInfo.DateFormat fmt : AccountGeneralPreferencesInfo.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferencesInfo.TimeFormat fmt : AccountGeneralPreferencesInfo.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    signedOffBy = new CheckBox(Util.C.signedOffBy());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, signedOffBy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(signedOffBy);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final int v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), GeneralPreferencesInfo.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), GeneralPreferencesInfo.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), GeneralPreferencesInfo.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), GeneralPreferencesInfo.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), GeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), GeneralPreferencesInfo.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), GeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), GeneralPreferencesInfo.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), GeneralPreferencesInfo.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (GeneralPreferencesInfo.DateFormat fmt : GeneralPreferencesInfo.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (GeneralPreferencesInfo.TimeFormat fmt : GeneralPreferencesInfo.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    signedOffBy = new CheckBox(Util.C.signedOffBy());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(12 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, signedOffBy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(signedOffBy);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<AccountPreferencesInfo>(this) {

        @Override
        public void preDisplay(AccountPreferencesInfo prefs) {
            display(prefs);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<GeneralPreferences>(this) {

        @Override
        public void preDisplay(GeneralPreferences prefs) {
            display(prefs);
        }
    });
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    signedOffBy.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    signedOffBy.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
    emailStrategy.setEnabled(on);
}
#end_block

#method_before
private void display(JsArray<TopMenuItem> items) {
    List<List<String>> values = new ArrayList<>();
    for (TopMenuItem item : Natives.asList(items)) {
        values.add(Arrays.asList(item.getName(), item.getUrl()));
    }
    myMenus.display(values);
}
#method_after
private void display(GeneralPreferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    GeneralPreferencesInfo.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    GeneralPreferencesInfo.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    signedOffBy.setValue(p.signedOffBy());
    setListBox(reviewCategoryStrategy, GeneralPreferencesInfo.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, p.diffView());
    setListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, p.emailStrategy());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    AccountPreferencesInfo p = AccountPreferencesInfo.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.copySelfOnEmail(copySelfOnEmails.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, AccountGeneralPreferencesInfo.DateFormat.STD, AccountGeneralPreferencesInfo.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, AccountGeneralPreferencesInfo.TimeFormat.HHMM_12, AccountGeneralPreferencesInfo.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.signedOffBy(signedOffBy.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, AccountGeneralPreferencesInfo.DiffView.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<AccountPreferencesInfo>() {

        @Override
        public void onSuccess(AccountPreferencesInfo prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    GeneralPreferences p = GeneralPreferences.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, GeneralPreferencesInfo.DateFormat.STD, GeneralPreferencesInfo.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, GeneralPreferencesInfo.TimeFormat.HHMM_12, GeneralPreferencesInfo.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.signedOffBy(signedOffBy.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, GeneralPreferencesInfo.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, GeneralPreferencesInfo.EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<GeneralPreferences>() {

        @Override
        public void onSuccess(GeneralPreferences prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<Change> changes = changeUtil.findChanges(input.baseChange);
            if (changes.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            Change change = Iterables.getOnlyElement(changes);
            if (!rsrc.getControl().controlFor(change).isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = db.get().patchSets().get(new PatchSet.Id(change.getId(), change.currentPatchSetId().get()));
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef == null) {
                throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
            }
            parentCommit = destRef.getObjectId();
            groups = null;
        }
        RevCommit mergeTip = rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        Account.Id userId = me.getAccountId();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountGeneralPreferencesInfo info = cache.get(userId).getAccount().getGeneralPreferencesInfo();
        ObjectId id = ChangeIdUtil.computeChangeId(mergeTip.getTree(), mergeTip, author, author, input.subject);
        String commitMessage = ChangeIdUtil.insertId(input.subject, id);
        if (info.signedOffBy != null && info.signedOffBy) {
            commitMessage += String.format("%s%s <%s>", SIGNED_OFF_BY_TAG, author.getName().trim(), author.getEmailAddress().trim());
        }
        try (ObjectInserter oi = git.newObjectInserter()) {
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change change = new Change(getChangeId(id, c), new Change.Id(db.get().nextChangeId()), userId, new Branch.NameKey(project, refName), now);
            ChangeInserter ins = changeInserterFactory.create(refControl, change, c).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSet().getPatchSetId()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            change.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(change.getId()));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                } else {
                    parentCommit = destRef.getObjectId();
                }
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        AccountState account = accountCache.get(me.getAccountId());
        GeneralPreferencesInfo info = account.getAccount().getGeneralPreferencesInfo();
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            if (Boolean.TRUE.equals(info.signedOffBy)) {
                commitMessage += String.format("%s%s", SIGNED_OFF_BY_TAG, account.getAccount().getNameEmail(anonymousCowardName));
            }
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(ins.getChange()));
        }
    }
}
#end_block

#method_before
private static RevCommit newCommit(ObjectInserter oi, RevWalk rw, PersonIdent authorIdent, RevCommit mergeTip, String commitMessage) throws IOException {
    CommitBuilder commit = new CommitBuilder();
    commit.setTreeId(mergeTip.getTree().getId());
    commit.setParentId(mergeTip);
    commit.setAuthor(authorIdent);
    commit.setCommitter(authorIdent);
    commit.setMessage(commitMessage);
    return rw.parseCommit(insert(oi, commit));
}
#method_after
private static RevCommit newCommit(ObjectInserter oi, RevWalk rw, PersonIdent authorIdent, RevCommit mergeTip, String commitMessage) throws IOException {
    CommitBuilder commit = new CommitBuilder();
    if (mergeTip == null) {
        commit.setTreeId(emptyTreeId(oi));
    } else {
        commit.setTreeId(mergeTip.getTree().getId());
        commit.setParentId(mergeTip);
    }
    commit.setAuthor(authorIdent);
    commit.setCommitter(authorIdent);
    commit.setMessage(commitMessage);
    return rw.parseCommit(insert(oi, commit));
}
#end_block

#method_before
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInfo input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                parentCommit = destRef.getObjectId();
            } else {
                if (input.newBranch) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(project, changeId));
        }
    }
}
#method_after
@Override
public Response<ChangeInfo> apply(TopLevelResource parent, ChangeInput input) throws OrmException, IOException, InvalidChangeOperationException, RestApiException, UpdateException {
    if (Strings.isNullOrEmpty(input.project)) {
        throw new BadRequestException("project must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.branch)) {
        throw new BadRequestException("branch must be non-empty");
    }
    if (Strings.isNullOrEmpty(input.subject)) {
        throw new BadRequestException("commit message must be non-empty");
    }
    if (input.status != null) {
        if (input.status != ChangeStatus.NEW && input.status != ChangeStatus.DRAFT) {
            throw new BadRequestException("unsupported change status");
        }
        if (!allowDrafts && input.status == ChangeStatus.DRAFT) {
            throw new MethodNotAllowedException("draft workflow is disabled");
        }
    }
    String refName = RefNames.fullName(input.branch);
    ProjectResource rsrc = projectsCollection.parse(input.project);
    Capable r = rsrc.getControl().canPushToAtLeastOneRef();
    if (r != Capable.OK) {
        throw new AuthException(r.getMessage());
    }
    RefControl refControl = rsrc.getControl().controlForRef(refName);
    if (!refControl.canUpload() || !refControl.canRead()) {
        throw new AuthException("cannot upload review");
    }
    Project.NameKey project = rsrc.getNameKey();
    try (Repository git = gitManager.openRepository(project);
        RevWalk rw = new RevWalk(git)) {
        ObjectId parentCommit;
        List<String> groups;
        if (input.baseChange != null) {
            List<ChangeControl> ctls = changeFinder.find(input.baseChange, rsrc.getControl().getUser());
            if (ctls.size() != 1) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            ChangeControl ctl = Iterables.getOnlyElement(ctls);
            if (!ctl.isVisible(db.get())) {
                throw new InvalidChangeOperationException("Base change not found: " + input.baseChange);
            }
            PatchSet ps = psUtil.current(db.get(), ctl.getNotes());
            parentCommit = ObjectId.fromString(ps.getRevision().get());
            groups = ps.getGroups();
        } else {
            Ref destRef = git.getRefDatabase().exactRef(refName);
            if (destRef != null) {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    throw new ResourceConflictException(String.format("Branch %s already exists.", refName));
                } else {
                    parentCommit = destRef.getObjectId();
                }
            } else {
                if (Boolean.TRUE.equals(input.newBranch)) {
                    parentCommit = null;
                } else {
                    throw new UnprocessableEntityException(String.format("Branch %s does not exist.", refName));
                }
            }
            groups = Collections.emptyList();
        }
        RevCommit mergeTip = parentCommit == null ? null : rw.parseCommit(parentCommit);
        Timestamp now = TimeUtil.nowTs();
        IdentifiedUser me = user.get().asIdentifiedUser();
        PersonIdent author = me.newCommitterIdent(now, serverTimeZone);
        try (ObjectInserter oi = git.newObjectInserter()) {
            ObjectId treeId = mergeTip == null ? emptyTreeId(oi) : mergeTip.getTree();
            ObjectId id = ChangeIdUtil.computeChangeId(treeId, mergeTip, author, author, input.subject);
            String commitMessage = ChangeIdUtil.insertId(input.subject, id);
            RevCommit c = newCommit(oi, rw, author, mergeTip, commitMessage);
            Change.Id changeId = new Change.Id(seq.nextChangeId());
            ChangeInserter ins = changeInserterFactory.create(changeId, c, refName).setValidatePolicy(CommitValidators.Policy.GERRIT);
            ins.setMessage(String.format("Uploaded patch set %s.", ins.getPatchSetId().get()));
            String topic = input.topic;
            if (topic != null) {
                topic = Strings.emptyToNull(topic.trim());
            }
            ins.setTopic(topic);
            ins.setDraft(input.status != null && input.status == ChangeStatus.DRAFT);
            ins.setGroups(groups);
            try (BatchUpdate bu = updateFactory.create(db.get(), project, me, now)) {
                bu.setRepository(git, rw, oi);
                bu.insertChange(ins);
                bu.execute();
            }
            ChangeJson json = jsonFactory.create(ChangeJson.NO_OPTIONS);
            return Response.created(json.format(project, changeId));
        }
    }
}
#end_block

#method_before
private static ObjectId emptyTreeId(ObjectInserter inserter) throws IOException {
    return inserter.insert(new TreeFormatter());
}
#method_after
private static ObjectId emptyTreeId(ObjectInserter inserter) throws IOException {
    ObjectId id = inserter.insert(new TreeFormatter());
    inserter.flush();
    return id;
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#end_block

#method_before
private void checkEnabled() throws ResourceNotFoundException {
    if (notesMigration.readChanges()) {
        throw new ResourceNotFoundException("check not implemented for notedb");
    }
}
#method_after
private void checkEnabled() throws NotImplementedException {
    if (notesMigration.readChanges()) {
        throw new NotImplementedException("check not implemented for notedb");
    }
}
#end_block

#method_before
@Override
public void registerKeys() {
    super.registerKeys();
    KeyMap localKeyMap = KeyMap.create();
    localKeyMap.on("Cmd-S", save());
    // TODO(davido): Find a better way to prevent key maps collisions
    if (prefs.keyMapType() != KeyMapType.EMACS) {
        localKeyMap.on("Ctrl-S", save());
    }
    cm.addKeyMap(localKeyMap);
}
#method_after
@Override
public void registerKeys() {
    super.registerKeys();
    KeyMap localKeyMap = KeyMap.create();
    localKeyMap.on("Ctrl-L", gotoLine()).on("Cmd-L", gotoLine()).on("Cmd-S", save());
    // TODO(davido): Find a better way to prevent key maps collisions
    if (prefs.keyMapType() != KeyMapType.EMACS) {
        localKeyMap.on("Ctrl-S", save());
    }
    cm.addKeyMap(localKeyMap);
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(state.db, change), ins.getPatchSet());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(db, change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = notesFactory.create(db, project.getNameKey(), cid).getChange();
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, ObjectId commitId) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = notesFactory.create(db, project.getNameKey(), cid).getChange();
    ChangeControl ctl = projectControl.controlFor(db, change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    RevCommit commit = rp.getRevWalk().parseCommit(commitId);
    rp.getRevWalk().parseBody(commit);
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws AuthException, BadRequestException, UnprocessableEntityException, UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#method_after
@Override
public PostResult apply(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, OrmException, RestApiException, IOException {
    if (input.reviewer == null) {
        throw new BadRequestException("missing reviewer field");
    }
    try {
        Account.Id accountId = accounts.parse(input.reviewer).getAccountId();
        return putAccount(reviewerFactory.create(rsrc, accountId));
    } catch (UnprocessableEntityException e) {
        try {
            return putGroup(rsrc, input);
        } catch (UnprocessableEntityException e2) {
            throw new UnprocessableEntityException(MessageFormat.format(ChangeMessages.get().reviewerNotFound, input.reviewer));
        }
    }
}
#end_block

#method_before
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, IOException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#method_after
private PostResult putAccount(ReviewerResource rsrc) throws OrmException, UpdateException, RestApiException {
    Account member = rsrc.getReviewerUser().getAccount();
    ChangeControl control = rsrc.getReviewerControl();
    PostResult result = new PostResult();
    if (isValidReviewer(member, control)) {
        addReviewers(rsrc.getChangeResource(), result, ImmutableMap.of(member.getId(), control));
    }
    return result;
}
#end_block

#method_before
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws BadRequestException, UpdateException, RestApiException, UnprocessableEntityException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#method_after
private PostResult putGroup(ChangeResource rsrc, AddReviewerInput input) throws UpdateException, RestApiException, OrmException, IOException {
    GroupDescription.Basic group = groupsCollection.parseInternal(input.reviewer);
    PostResult result = new PostResult();
    if (!isLegalReviewerGroup(group.getGroupUUID())) {
        result.error = MessageFormat.format(ChangeMessages.get().groupIsNotAllowed, group.getName());
        return result;
    }
    Map<Account.Id, ChangeControl> reviewers = Maps.newHashMap();
    ChangeControl control = rsrc.getControl();
    Set<Account> members;
    try {
        members = groupMembersFactory.create(control.getUser()).listAccounts(group.getGroupUUID(), control.getProject().getNameKey());
    } catch (NoSuchGroupException e) {
        throw new UnprocessableEntityException(e.getMessage());
    } catch (NoSuchProjectException e) {
        throw new BadRequestException(e.getMessage());
    }
    // if maxAllowed is set to 0, it is allowed to add any number of
    // reviewers
    int maxAllowed = cfg.getInt("addreviewer", "maxAllowed", DEFAULT_MAX_REVIEWERS);
    if (maxAllowed > 0 && members.size() > maxAllowed) {
        result.error = MessageFormat.format(ChangeMessages.get().groupHasTooManyMembers, group.getName());
        return result;
    }
    // if maxWithoutCheck is set to 0, we never ask for confirmation
    int maxWithoutConfirmation = cfg.getInt("addreviewer", "maxWithoutConfirmation", DEFAULT_MAX_REVIEWERS_WITHOUT_CHECK);
    if (!input.confirmed() && maxWithoutConfirmation > 0 && members.size() > maxWithoutConfirmation) {
        result.confirm = true;
        result.error = MessageFormat.format(ChangeMessages.get().groupManyMembersConfirmation, group.getName(), members.size());
        return result;
    }
    for (Account member : members) {
        if (isValidReviewer(member, control)) {
            reviewers.put(member.getId(), control);
        }
    }
    addReviewers(rsrc, result, reviewers);
    return result;
}
#end_block

#method_before
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, new Op(rsrc, result, reviewers));
        bu.execute();
    }
}
#method_after
private void addReviewers(ChangeResource rsrc, PostResult result, Map<Account.Id, ChangeControl> reviewers) throws OrmException, RestApiException, UpdateException {
    try (BatchUpdate bu = batchUpdateFactory.create(dbProvider.get(), rsrc.getProject(), rsrc.getUser(), TimeUtil.nowTs())) {
        Op op = new Op(rsrc, reviewers);
        Change.Id id = rsrc.getChange().getId();
        bu.addOp(id, op);
        bu.execute();
        result.reviewers = Lists.newArrayListWithCapacity(op.added.size());
        for (PatchSetApproval psa : op.added) {
            // New reviewers have value 0, don't bother normalizing.
            result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
        }
        // We don't do this inside Op, since the accounts are in a different
        // table.
        accountLoaderFactory.create(true).fill(result.reviewers);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    return !added.isEmpty();
}
#method_after
@Override
public boolean updateChange(BatchUpdate.ChangeContext ctx) throws RestApiException, OrmException, IOException {
    added = approvalsUtil.addReviewers(ctx.getDb(), ctx.getNotes(), ctx.getUpdate(ctx.getChange().currentPatchSetId()), rsrc.getControl().getLabelTypes(), rsrc.getChange(), reviewers.keySet());
    if (!added.isEmpty()) {
        patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
    }
    return !added.isEmpty();
}
#end_block

#method_before
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    result.reviewers = Lists.newArrayListWithCapacity(added.size());
    for (PatchSetApproval psa : added) {
        // New reviewers have value 0, don't bother normalizing.
        result.reviewers.add(json.format(new ReviewerInfo(psa.getAccountId()), reviewers.get(psa.getAccountId()), ImmutableList.of(psa)));
    }
    accountLoaderFactory.create(true).fill(result.reviewers);
    if (!added.isEmpty()) {
        PatchSet patchSet = psUtil.current(dbProvider.get(), rsrc.getNotes());
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
        }
    }
}
#method_after
@Override
public void postUpdate(BatchUpdate.Context ctx) throws Exception {
    emailReviewers(rsrc.getChange(), added);
    if (!added.isEmpty()) {
        for (PatchSetApproval psa : added) {
            Account account = accountCache.get(psa.getAccountId()).getAccount();
            hooks.doReviewerAddedHook(rsrc.getChange(), account, patchSet, dbProvider.get());
        }
    }
}
#end_block

#method_before
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#method_after
private void emailReviewers(Change change, List<PatchSetApproval> added) {
    if (added.isEmpty()) {
        return;
    }
    // Email the reviewers
    // 
    // The user knows they added themselves, don't bother emailing them.
    List<Account.Id> toMail = Lists.newArrayListWithCapacity(added.size());
    Account.Id userId = user.get().getAccountId();
    for (PatchSetApproval psa : added) {
        if (!psa.getAccountId().equals(userId)) {
            toMail.add(psa.getAccountId());
        }
    }
    if (!toMail.isEmpty()) {
        try {
            AddReviewerSender cm = addReviewerSenderFactory.create(change.getProject(), change.getId());
            cm.setFrom(userId);
            cm.addReviewers(toMail);
            cm.send();
        } catch (Exception err) {
            log.error("Cannot send email to new reviewers of change " + change.getId(), err);
        }
    }
}
#end_block

#method_before
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException {
    // Do not allow creating groups with the same name as system groups
    Map<String, GroupReference> sysGroupNames = SystemGroupBackend.getNames();
    if (sysGroupNames.containsKey(createGroupArgs.getGroupName().toLowerCase())) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#method_after
private AccountGroup createGroup(CreateGroupArgs createGroupArgs) throws OrmException, ResourceConflictException {
    // Do not allow creating groups with the same name as system groups
    List<String> sysGroupNames = SystemGroupBackend.getNames();
    for (String name : sysGroupNames) {
        if (name.toLowerCase(Locale.US).equals(createGroupArgs.getGroupName().toLowerCase(Locale.US))) {
            throw new ResourceConflictException("group '" + name + "' already exists");
        }
    }
    AccountGroup.Id groupId = new AccountGroup.Id(db.nextAccountGroupId());
    AccountGroup.UUID uuid = GroupUUID.make(createGroupArgs.getGroupName(), self.get().newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone()));
    AccountGroup group = new AccountGroup(createGroupArgs.getGroup(), groupId, uuid);
    group.setVisibleToAll(createGroupArgs.visibleToAll);
    if (createGroupArgs.ownerGroupId != null) {
        AccountGroup ownerGroup = groupCache.get(createGroupArgs.ownerGroupId);
        if (ownerGroup != null) {
            group.setOwnerGroupUUID(ownerGroup.getGroupUUID());
        }
    }
    if (createGroupArgs.groupDescription != null) {
        group.setDescription(createGroupArgs.groupDescription);
    }
    AccountGroupName gn = new AccountGroupName(group);
    // already been used to create another group
    try {
        db.accountGroupNames().insert(Collections.singleton(gn));
    } catch (OrmDuplicateKeyException e) {
        throw new ResourceConflictException("group '" + createGroupArgs.getGroupName() + "' already exists");
    }
    db.accountGroups().insert(Collections.singleton(group));
    addMembers.addMembers(groupId, createGroupArgs.initialMembers);
    groupCache.onCreateGroup(createGroupArgs.getGroup());
    return group;
}
#end_block

#method_before
public static boolean isSystemGroup(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:");
}
#method_after
public static boolean isSystemGroup(AccountGroup.UUID uuid) {
    return uuid.get().startsWith(SYSTEM_GROUP_SCHEME);
}
#end_block

#method_before
public static Map<String, GroupReference> getNames() {
    return names;
}
#method_after
public static List<String> getNames() {
    List<String> names = new ArrayList<>();
    for (AccountGroup.UUID uuid : all) {
        int c = uuid.get().indexOf(':');
        names.add(uuid.get().substring(c + 1).replace('-', ' '));
    }
    return names;
}
#end_block

#method_before
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    if (cd.getSubmitRecords() != null) {
        return cd.getSubmitRecords();
    }
    cd.setSubmitRecords(new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate());
    return cd.getSubmitRecords();
}
#method_after
private List<SubmitRecord> submitRecords(ChangeData cd) throws OrmException {
    // TODO(dborowitz): Handle this better at the ChangeData level.
    if (submitRecords == null) {
        submitRecords = new HashMap<>();
    }
    List<SubmitRecord> records = submitRecords.get(cd.getId());
    if (records == null) {
        records = new SubmitRuleEvaluator(cd).setFastEvalLabels(true).setAllowDraft(true).evaluate();
        submitRecords.put(cd.getId(), records);
    }
    return records;
}
#end_block

#method_before
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#method_after
private Map<String, LabelWithStatus> initLabels(ChangeData cd, LabelTypes labelTypes, boolean standard) throws OrmException {
    // Don't use Maps.newTreeMap(Comparator) due to OpenJDK bug 100167.
    Map<String, LabelWithStatus> labels = new TreeMap<>(labelTypes.nameComparator());
    for (SubmitRecord rec : submitRecords(cd)) {
        if (rec.labels == null) {
            continue;
        }
        for (SubmitRecord.Label r : rec.labels) {
            LabelWithStatus p = labels.get(r.label);
            if (p == null || p.status().compareTo(r.status) < 0) {
                LabelInfo n = new LabelInfo();
                if (standard) {
                    switch(r.status) {
                        case OK:
                            n.approved = accountLoader.get(r.appliedBy);
                            break;
                        case REJECT:
                            n.rejected = accountLoader.get(r.appliedBy);
                            n.blocking = true;
                            break;
                        case IMPOSSIBLE:
                        case MAY:
                        case NEED:
                        default:
                            break;
                    }
                }
                n.optional = r.status == SubmitRecord.Label.Status.MAY ? true : null;
                labels.put(r.label, LabelWithStatus.create(n, r.status));
            }
        }
    }
    return labels;
}
#end_block

#method_before
private Timestamp getSubmittedOn(ChangeData cd) throws OrmException {
    for (PatchSetApproval psa : cd.approvals().values()) {
        if (psa.getLabelId().equals(LabelId.SUBMIT)) {
            return psa.getGranted();
        }
    }
    return null;
}
#method_after
private Timestamp getSubmittedOn(ChangeData cd) throws OrmException {
    Optional<PatchSetApproval> s = cd.getSubmitApproval();
    return s.isPresent() ? s.get().getGranted() : null;
}
#end_block

#method_before
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getChange().getProject();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#method_after
CommitInfo toCommit(ChangeControl ctl, RevWalk rw, RevCommit commit, boolean addLinks) throws IOException {
    Project.NameKey project = ctl.getProject().getNameKey();
    CommitInfo info = new CommitInfo();
    info.parents = new ArrayList<>(commit.getParentCount());
    info.author = toGitPerson(commit.getAuthorIdent());
    info.committer = toGitPerson(commit.getCommitterIdent());
    info.subject = commit.getShortMessage();
    info.message = commit.getFullMessage();
    if (addLinks) {
        FluentIterable<WebLinkInfo> links = webLinks.getPatchSetLinks(project, commit.name());
        info.webLinks = links.isEmpty() ? null : links.toList();
    }
    for (RevCommit parent : commit.getParents()) {
        rw.parseBody(parent);
        CommitInfo i = new CommitInfo();
        i.commit = parent.name();
        i.subject = parent.getShortMessage();
        if (addLinks) {
            FluentIterable<WebLinkInfo> parentLinks = webLinks.getPatchSetLinks(project, parent.name());
            i.webLinks = parentLinks.isEmpty() ? null : parentLinks.toList();
        }
        info.parents.add(i);
    }
    return info;
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            loadConfigInfo(info, base);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group = new CallbackGroup();
    if (Gerrit.isSignedIn()) {
        ChangeList.query("change:" + changeId.get() + " has:draft", Collections.<ListChangesOption>emptySet(), group.add(new AsyncCallback<ChangeList>() {

            @Override
            public void onSuccess(ChangeList result) {
                hasDraftComments = result.length() > 0;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
        ChangeApi.editWithFiles(changeId.get(), group.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    loadChangeInfo(true, group.addFinal(new GerritCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            info.init();
            addExtensionPoints(info);
            loadConfigInfo(info, base);
        }
    }));
}
#end_block

#method_before
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.CHANGE_ACTIONS, ListChangesOption.ALL_REVISIONS));
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#method_after
void loadChangeInfo(boolean fg, AsyncCallback<ChangeInfo> cb) {
    RestApi call = ChangeApi.detail(changeId.get());
    EnumSet<ListChangesOption> opts = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS);
    if (enableSignedPush()) {
        opts.add(ListChangesOption.PUSH_CERTIFICATES);
    }
    ChangeList.addOptions(call, opts);
    if (!fg) {
        call.background();
    }
    call.get(cb);
}
#end_block

#method_before
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).is_edit()) {
        reply.setTitle(Gerrit.getConfig().getReplyTitle());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getConfig().getReplyLabel()).closeDiv());
        reply.setVisible(true);
    }
}
#method_after
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).isEdit()) {
        reply.setTitle(Gerrit.info().change().replyLabel());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.info().change().replyLabel()).closeDiv());
        if (hasDraftComments) {
            reply.setStyleName(style.highlight());
        }
        reply.setVisible(true);
    }
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.hasActions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    final String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (currentlyViewedPatchSet != Integer.toString(currentPatchSet)) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    if (isPatchSetCurrent) {
        patchSetsText.removeClassName(style.notCurrentPatchSet());
    } else {
        patchSetsText.addClassName(style.notCurrentPatchSet());
    }
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    boolean isPatchSetCurrent = true;
    String revisionId = info.revision(revision).id();
    if (revisionId.equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = revisionId;
        if (!currentlyViewedPatchSet.equals(Integer.toString(currentPatchSet))) {
            isPatchSetCurrent = false;
        }
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    updatePatchSetsTextStyle(isPatchSetCurrent);
    patchSetsAction = new PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.projectNameKey(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.is_edit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.current_revision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#method_after
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.isEdit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.currentRevision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#end_block

#method_before
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccountInfo()._account_id();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._account_id() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#method_after
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccount()._accountId();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._accountId() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#end_block

#method_before
private List<NativeMap<JsArray<CommentInfo>>> loadComments(RevisionInfo rev, CallbackGroup group) {
    final int id = rev._number();
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    ChangeApi.revision(changeId.get(), rev.name()).view("comments").get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            r.add(result);
            history.addComments(id, result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#method_after
private List<NativeMap<JsArray<CommentInfo>>> loadComments(final RevisionInfo rev, CallbackGroup group) {
    final List<NativeMap<JsArray<CommentInfo>>> r = new ArrayList<>(1);
    // TODO(dborowitz): Could eliminate this call by adding an option to include
    // inline comments in the change detail.
    ChangeApi.comments(changeId.get()).get(group.add(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            // Return value is used for populating the file table, so only count
            // comments for the current revision. Still include all comments in
            // the history table.
            r.add(filterForRevision(result, rev._number()));
            history.addComments(result);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    return r;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#method_after
private boolean isSubmittable(ChangeInfo info) {
    boolean canSubmit = info.status().isOpen() && revision.equals(info.currentRevision()) && !info.revision(revision).draft();
    if (canSubmit && info.status() == Change.Status.NEW) {
        for (String name : info.labels()) {
            LabelInfo label = info.label(name);
            switch(label.status()) {
                case NEED:
                    statusText.setInnerText("Needs " + name);
                    canSubmit = false;
                    break;
                case REJECT:
                case IMPOSSIBLE:
                    if (label.blocking()) {
                        statusText.setInnerText("Not " + name);
                        canSubmit = false;
                    }
                    break;
                default:
                    break;
            }
        }
    }
    return canSubmit;
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.current_revision()) || info.revision(revision).is_edit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    RevisionInfo revisionInfo = info.revision(revision);
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderUploader(info, revisionInfo);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || revisionInfo.isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        Status s = info.revision(revision).draft() ? Status.DRAFT : info.status();
        statusText.setInnerText(Util.toLongString(s));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = info.status().isOpen() && revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current && info.status() == Change.Status.NEW) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    initRevisionsAction(info, revision, actionMap);
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
    actions.reloadRevisionActions(actionMap);
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    initRevisionsAction(info, revision, actionMap);
    commit.setParentNotCurrent(actionMap.containsKey("rebase") && actionMap.get("rebase").enabled());
    actions.reloadRevisionActions(actionMap);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getConfig().getAnonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = name(info.owner());
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(email(info.owner(), name));
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._accountId()), Change.Status.NEW));
}
#end_block

#method_before
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getConfig().getChangeUpdateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.info().change().updateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static IndexConfig create(int maxLimit, int maxPages, int maxTerms, int maxPrefixTerms) {
    return new AutoValue_IndexConfig(checkLimit(maxLimit, "maxLimit", Integer.MAX_VALUE), checkLimit(maxPages, "maxPages", Integer.MAX_VALUE), checkLimit(maxTerms, "maxTerms", BooleanQuery.getMaxClauseCount()), checkLimit(maxPrefixTerms, "maxPrefixTerms", DEFAULT_MAX_PREFIX_TERMS));
}
#method_after
public static IndexConfig create(int maxLimit, int maxPages, int maxTerms, int maxPrefixTerms) {
    return new AutoValue_IndexConfig(checkLimit(maxLimit, "maxLimit", Integer.MAX_VALUE), checkLimit(maxPages, "maxPages", Integer.MAX_VALUE), checkLimit(maxTerms, "maxTerms", DEFAULT_MAX_TERMS), checkLimit(maxPrefixTerms, "maxPrefixTerms", DEFAULT_MAX_PREFIX_TERMS));
}
#end_block

#method_before
@Override
public PreferenceInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && self.get().getUserName() != rsrc.getUser().getUserName() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to administrator");
    }
    Account a = db.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException();
    }
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        return new PreferenceInfo(a.getGeneralPreferences(), p, git);
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("requires Modify Account capability");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    return readFromGit ? readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId);
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    EnumSet<ListChangesOption> options = EnumSet.allOf(ListChangesOption.class);
    options.remove(ListChangesOption.CHECK);
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(options).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).get());
    assertThat(result.labels).isNull();
    assertThat(result.messages).isNull();
    assertThat(result.actions).isNull();
    assertThat(result.revisions).isNull();
    EnumSet<ListChangesOption> options = EnumSet.of(ListChangesOption.ALL_REVISIONS, ListChangesOption.CHANGE_ACTIONS, ListChangesOption.CURRENT_ACTIONS, ListChangesOption.DETAILED_LABELS, ListChangesOption.MESSAGES);
    result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(options).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#method_after
private void insertChange(RequestState state) throws OrmException, IOException, RestApiException, UpdateException {
    RevCommit commit = state.rw.parseCommit(commitId);
    state.rw.parseBody(commit);
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (BatchUpdate bu = batchUpdateFactory.create(state.db, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(state.repo, state.rw, state.ins);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(true));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final RevCommit newCommit = state.rw.parseCommit(newCommitId);
    state.rw.parseBody(newCommit);
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, state.rw, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    if (magicBranch != null) {
                        cm.setNotify(magicBranch.notify);
                    }
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        if (!hashtags.isEmpty()) {
            ChangeNotes notes = changeCtl.getNotes().load();
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    if (runHooks) {
        ReviewDb db = ctx.getDb();
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (approvals != null && !approvals.isEmpty()) {
            hooks.doCommentAddedHook(change, user.getAccount(), patchSet, null, approvals, db);
        }
    }
}
#method_after
@Override
public void postUpdate(Context ctx) throws OrmException {
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change.getId());
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            sendEmailExecutor.submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    if (runHooks) {
        ReviewDb db = ctx.getDb();
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (approvals != null && !approvals.isEmpty()) {
            hooks.doCommentAddedHook(change, user.getAccount(), patchSet, null, approvals, db);
        }
    }
}
#end_block

#method_before
@Override
public void initConfig(Section databaseSection) {
    final String defInstanceNumber = "00";
    databaseSection.string("Server hostname", "hostname", "localhost");
    databaseSection.string("Instance number", "instance", defInstanceNumber, false);
    String instance = databaseSection.get("instance");
    try {
        int instanceNumber = Integer.parseInt(instance);
        if (instanceNumber < 0 || instanceNumber > 99) {
            instanceIsInvalid();
        }
    } catch (NumberFormatException ex) {
        instanceIsInvalid();
    }
    databaseSection.string("Database username", "username", username());
    databaseSection.password("username", "password");
}
#method_after
@Override
public void initConfig(Section databaseSection) {
    final String defInstanceNumber = "00";
    databaseSection.string("Server hostname", "hostname", "localhost");
    databaseSection.string("Instance number", "instance", defInstanceNumber, false);
    String instance = databaseSection.get("instance");
    Integer instanceNumber = Ints.tryParse(instance);
    if (instanceNumber == null || instanceNumber < 0 || instanceNumber > 99) {
        instanceIsInvalid();
    }
    databaseSection.string("Database username", "username", username());
    databaseSection.password("username", "password");
}
#end_block

#method_before
@Before
public void setup() throws ConfigInvalidException {
    config = new BlobBasedConfig(null, new byte[0]);
    config.setString("database", null, "hostname", "my.host");
    hana = new HANA(config);
}
#method_after
@Before
public void setup() {
    config = new Config();
    config.setString("database", null, "hostname", "my.host");
    hana = new HANA(config);
}
#end_block

#method_before
@Test
public void testGetUrl() throws Exception {
    config.setString("database", null, "instance", "3");
    assertThat(hana.getUrl(), equalTo("jdbc:sap://my.host:30315"));
    config.setString("database", null, "instance", "77");
    assertThat(hana.getUrl(), equalTo("jdbc:sap://my.host:37715"));
}
#method_after
@Test
public void testGetUrl() throws Exception {
    config.setString("database", null, "instance", "3");
    assertThat(hana.getUrl()).isEqualTo("jdbc:sap://my.host:30315");
    config.setString("database", null, "instance", "77");
    assertThat(hana.getUrl()).isEqualTo("jdbc:sap://my.host:37715");
}
#end_block

#method_before
@Test
public void testGetIndexScript() throws Exception {
    assertThat(hana.getIndexScript(), sameInstance(ScriptRunner.NOOP));
}
#method_after
@Test
public void testGetIndexScript() throws Exception {
    assertThat(hana.getIndexScript()).isEqualTo(sameInstance(ScriptRunner.NOOP));
}
#end_block

#method_before
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameField(e, table, from, to);
    }
}
#method_after
protected static void renameColumn(ReviewDb db, String table, String from, String to) throws OrmException {
    JdbcSchema s = (JdbcSchema) db;
    try (JdbcExecutor e = new JdbcExecutor(s)) {
        s.renameColumn(e, table, from, to);
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree() == priorCommit.getTree()) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#method_after
boolean validate(boolean autoClose) throws IOException, OrmException {
    if (!autoClose && inputCommand.getResult() != NOT_ATTEMPTED) {
        return false;
    } else if (change == null) {
        reject(inputCommand, "change " + ontoChange + " not found");
        return false;
    }
    priorPatchSet = change.currentPatchSetId();
    if (!revisions.containsValue(priorPatchSet)) {
        reject(inputCommand, "change " + ontoChange + " missing revisions");
        return false;
    }
    RevCommit newCommit = rp.getRevWalk().parseCommit(newCommitId);
    RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
    if (newCommit.equals(priorCommit)) {
        // Ignore requests to make the change its current state.
        skip = true;
        reject(inputCommand, "commit already exists (as current patchset)");
        return false;
    }
    changeCtl = projectControl.controlFor(change);
    if (!changeCtl.canAddPatchSet(db)) {
        String locked = ".";
        if (changeCtl.isPatchSetLocked(db)) {
            locked = ". Change is patch set locked.";
        }
        reject(inputCommand, "cannot replace " + ontoChange + locked);
        return false;
    } else if (change.getStatus().isClosed()) {
        reject(inputCommand, "change " + ontoChange + " closed");
        return false;
    } else if (revisions.containsKey(newCommit)) {
        reject(inputCommand, "commit already exists (in the change)");
        return false;
    }
    for (final Ref r : rp.getRepository().getRefDatabase().getRefs("refs/changes").values()) {
        if (r.getObjectId().equals(newCommit)) {
            reject(inputCommand, "commit already exists (in the project)");
            return false;
        }
    }
    for (RevCommit prior : revisions.keySet()) {
        // amending when trying to address review comments.
        if (rp.getRevWalk().isMergedInto(prior, newCommit)) {
            reject(inputCommand, "squash commits first");
            return false;
        }
    }
    if (!validCommit(rp.getRevWalk(), changeCtl.getRefControl(), inputCommand, newCommit)) {
        return false;
    }
    rp.getRevWalk().parseBody(priorCommit);
    // of the commit was modified.
    if (newCommit.getTree().equals(priorCommit.getTree())) {
        final boolean messageEq = eq(newCommit.getFullMessage(), priorCommit.getFullMessage());
        final boolean parentsEq = parentsEqual(newCommit, priorCommit);
        final boolean authorEq = authorEqual(newCommit, priorCommit);
        final ObjectReader reader = rp.getRevWalk().getObjectReader();
        if (messageEq && parentsEq && authorEq && !autoClose) {
            addMessage(String.format("(W) No changes between prior commit %s and new commit %s", reader.abbreviate(priorCommit).name(), reader.abbreviate(newCommit).name()));
            reject(inputCommand, "no changes made");
            return false;
        } else {
            StringBuilder msg = new StringBuilder();
            msg.append("(W) ");
            msg.append(reader.abbreviate(newCommit).name());
            msg.append(":");
            msg.append(" no files changed");
            if (!authorEq) {
                msg.append(", author changed");
            }
            if (!messageEq) {
                msg.append(", message updated");
            }
            if (!parentsEq) {
                msg.append(", was rebased");
            }
            addMessage(msg.toString());
        }
    }
    if (magicBranch != null && magicBranch.edit) {
        return newEdit();
    }
    newPatchSet();
    return true;
}
#end_block

#method_before
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS1").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getCurrentPatchSet().getRevision().get()).isEqualTo(commit.name());
    // new revId for the same patch set, ps1
    commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#method_after
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(ps).isNotNull();
    // new revId for the same patch set, ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1 again").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#end_block

#method_before
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1").create();
    update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(changeOwner.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
    // ps2 by other user
    incrementPatchSet(c);
    commit = tr.commit().message("PS2").create();
    update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    ps = notes.getCurrentPatchSet();
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
}
#method_after
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1 created by newChange()
    ChangeNotes notes = newNotes(c);
    PatchSet ps1 = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps1.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(ps1.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps1.getUploader()).isEqualTo(changeOwner.getAccountId());
    // ps2 by other user
    incrementPatchSet(c);
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    PatchSet ps2 = notes.getCurrentPatchSet();
    assertThat(ps2.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps2.getId());
    assertThat(ps2.getRevision().get()).isNotEqualTo(ps1.getRevision());
    assertThat(ps2.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps2.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps2.getCreatedOn()).isEqualTo(update.getWhen());
}
#end_block

#method_before
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    // ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, tr.commit().message("PS1").create());
    update.commit();
    // ps2
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.insertComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#method_after
@Test
public void patchSetStates() throws Exception {
    Change c = newChange();
    PatchSet.Id psId1 = c.currentPatchSetId();
    // ps2
    incrementPatchSet(c);
    PatchSet.Id psId2 = c.currentPatchSetId();
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.setPatchSetState(PatchSetState.DRAFT);
    update.putApproval("Code-Review", (short) 1);
    update.setChangeMessage("This is a message");
    update.insertComment(newPublishedComment(c.currentPatchSetId(), "a.txt", "uuid1", new CommentRange(1, 2, 3, 4), 1, changeOwner, null, TimeUtil.nowTs(), "Comment", (short) 1, commit.name()));
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isTrue();
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1, psId2);
    assertThat(notes.getApprovals()).isNotEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isNotEmpty();
    assertThat(notes.getChangeMessages()).isNotEmpty();
    assertThat(notes.getComments()).isNotEmpty();
    // publish ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.PUBLISHED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().get(psId2).isDraft()).isFalse();
    // delete ps2
    update = newUpdate(c, changeOwner);
    update.setPatchSetState(PatchSetState.DELETED);
    update.commit();
    notes = newNotes(c);
    assertThat(notes.getPatchSets().keySet()).containsExactly(psId1);
    assertThat(notes.getApprovals()).isEmpty();
    assertThat(notes.getChangeMessagesByPatchSet()).isEmpty();
    assertThat(notes.getChangeMessages()).isEmpty();
    assertThat(notes.getComments()).isEmpty();
}
#end_block

#method_before
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    psUtil.setDraft(ctx.getDb(), ctx.getUpdate(psId), patchSet, false);
    // Force ETag invalidation if not done already
    if (!wasDraftChange) {
        ctx.saveChange();
    }
}
#method_after
private void savePatchSet(ChangeContext ctx) throws RestApiException, OrmException {
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    psUtil.publish(ctx.getDb(), ctx.getUpdate(psId), patchSet);
    // Force ETag invalidation if not done already
    if (!wasDraftChange) {
        ctx.saveChange();
    }
}
#end_block

#method_before
@VisibleForTesting
void setSubject(String subject) {
    this.subject = subject;
}
#method_after
void setSubject(String subject) {
    this.subject = subject;
}
#end_block

#method_before
private void updatePatchSetStates() {
    Set<PatchSet.Id> deleted = Sets.newHashSetWithExpectedSize(patchSetStates.size());
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                deleted.add(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    if (deleted.isEmpty()) {
        return;
    }
    // Post-process other collections to remove items corresponding to deleted
    // patch sets. This is safer than trying to prevent insertion, as it will
    // also filter out items racily added after the patch set was deleted.
    patchSets.keySet().removeAll(deleted);
    approvals.keySet().removeAll(deleted);
    changeMessagesByPatchSet.keys().removeAll(deleted);
    for (Iterator<ChangeMessage> it = allChangeMessages.iterator(); it.hasNext(); ) {
        if (deleted.contains(it.next().getPatchSetId())) {
            it.remove();
        }
    }
    for (Iterator<PatchLineComment> it = comments.values().iterator(); it.hasNext(); ) {
        PatchSet.Id psId = it.next().getKey().getParentKey().getParentKey();
        if (deleted.contains(psId)) {
            it.remove();
        }
    }
}
#method_after
private void updatePatchSetStates() {
    Set<PatchSet.Id> deleted = Sets.newHashSetWithExpectedSize(patchSetStates.size());
    for (Map.Entry<PatchSet.Id, PatchSetState> e : patchSetStates.entrySet()) {
        switch(e.getValue()) {
            case PUBLISHED:
            default:
                break;
            case DELETED:
                deleted.add(e.getKey());
                break;
            case DRAFT:
                PatchSet ps = patchSets.get(e.getKey());
                if (ps != null) {
                    ps.setDraft(true);
                }
                break;
        }
    }
    if (deleted.isEmpty()) {
        return;
    }
    // Post-process other collections to remove items corresponding to deleted
    // patch sets. This is safer than trying to prevent insertion, as it will
    // also filter out items racily added after the patch set was deleted.
    patchSets.keySet().removeAll(deleted);
    if (!patchSets.keySet().isEmpty()) {
        currentPatchSetId = patchSets.navigableKeySet().last();
    } else {
        currentPatchSetId = null;
    }
    approvals.keySet().removeAll(deleted);
    changeMessagesByPatchSet.keys().removeAll(deleted);
    for (Iterator<ChangeMessage> it = allChangeMessages.iterator(); it.hasNext(); ) {
        if (deleted.contains(it.next().getPatchSetId())) {
            it.remove();
        }
    }
    for (Iterator<PatchLineComment> it = comments.values().iterator(); it.hasNext(); ) {
        PatchSet.Id psId = it.next().getKey().getParentKey().getParentKey();
        if (deleted.contains(psId)) {
            it.remove();
        }
    }
}
#end_block

#method_before
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#method_after
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#method_after
@Before
public void setUp() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports notedb.
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    ctx.getRevWalk().parseBody(commit);
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubjectForCommit("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getRevWalk(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#method_after
private void checkMandatoryFooters() throws ConfigInvalidException {
    List<FooterKey> missing = new ArrayList<>();
    if (branch == null) {
        missing.add(FOOTER_BRANCH);
    }
    if (originalSubject == null || subject == null) {
        missing.add(FOOTER_SUBJECT);
    }
    if (!missing.isEmpty()) {
        throw parseException("Missing footers: " + Joiner.on(", ").join(Lists.transform(missing, new Function<FooterKey, String>() {

            @Override
            public String apply(FooterKey input) {
                return input.getName();
            }
        })));
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#method_after
@Before
public void setUp() throws Exception {
    // TODO(dborowitz): Re-enable when ConsistencyChecker supports notedb.
    assume().that(notesMigration.enabled()).isFalse();
    // Ignore client clone of project; repurpose as server-side TestRepository.
    testRepo = new TestRepository<>((InMemoryRepository) repoManager.openRepository(project));
    tip = testRepo.getRevWalk().parseCommit(testRepo.getRepository().exactRef("HEAD").getObjectId());
    adminId = admin.getId();
    checker = checkerProvider.get();
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (RevWalk walk = new RevWalk(reader);
        ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        noteMap = parser.commentNoteMap;
        change.setDest(new Branch.NameKey(getProjectName(), parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // This is generally an error, but for now at least we support it in
            // tests.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    ObjectId rev = getRevision();
    if (rev == null) {
        loadDefaults();
        return;
    }
    try (RevWalk walk = new RevWalk(reader);
        ChangeNotesParser parser = new ChangeNotesParser(change, rev, walk, repoManager)) {
        parser.parseAll();
        if (parser.status != null) {
            change.setStatus(parser.status);
        }
        approvals = parser.buildApprovals();
        changeMessagesByPatchSet = parser.buildMessagesByPatchSet();
        allChangeMessages = parser.buildAllMessages();
        comments = ImmutableListMultimap.copyOf(parser.comments);
        noteMap = parser.commentNoteMap;
        change.setDest(new Branch.NameKey(getProjectName(), parser.branch));
        change.setTopic(Strings.emptyToNull(parser.topic));
        change.setCreatedOn(parser.createdOn);
        change.setLastUpdatedOn(parser.lastUpdatedOn);
        change.setOwner(parser.ownerId);
        change.setSubmissionId(parser.submissionId);
        patchSets = ImmutableSortedMap.copyOf(parser.patchSets, ReviewDbUtil.intKeyOrdering());
        if (!patchSets.isEmpty()) {
            change.setCurrentPatchSet(parser.currentPatchSetId, parser.subject, parser.originalSubject);
        } else {
            // TODO(dborowitz): This should be an error, but for now it's required
            // for some tests to pass.
            change.clearCurrentPatchSet();
        }
        if (parser.hashtags != null) {
            hashtags = ImmutableSet.copyOf(parser.hashtags);
        } else {
            hashtags = ImmutableSet.of();
        }
        ImmutableSetMultimap.Builder<ReviewerStateInternal, Account.Id> reviewers = ImmutableSetMultimap.builder();
        for (Map.Entry<Account.Id, ReviewerStateInternal> e : parser.reviewers.entrySet()) {
            reviewers.put(e.getValue(), e.getKey());
        }
        this.reviewers = reviewers.build();
        this.allPastReviewers = ImmutableList.copyOf(parser.allPastReviewers);
        submitRecords = ImmutableList.copyOf(parser.submitRecords);
    }
}
#end_block

#method_before
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    RevCommit commit = tr.commit().message("PS1").create();
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    assertThat(notes.getCurrentPatchSet().getRevision().get()).isEqualTo(commit.name());
    // new revId for the same patch set, ps1
    commit = tr.commit().message("PS2").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#method_after
@Test
public void commitChangeNotesUnique() throws Exception {
    // PatchSetId -> RevId must be a one to one mapping
    Change c = newChange();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(ps).isNotNull();
    // new revId for the same patch set, ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1 again").create();
    update.setCommit(rw, commit);
    update.commit();
    exception.expect(OrmException.class);
    exception.expectMessage("Multiple revisions parsed for patch set");
    notes = newNotes(c);
}
#end_block

#method_before
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1
    ChangeUpdate update = newUpdate(c, changeOwner);
    RevCommit commit = tr.commit().message("PS1").create();
    update = newUpdate(c, changeOwner);
    update.setCommit(rw, commit);
    update.commit();
    ChangeNotes notes = newNotes(c);
    PatchSet ps = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(changeOwner.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
    // ps2 by other user
    incrementPatchSet(c);
    commit = tr.commit().message("PS2").create();
    update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    ps = notes.getCurrentPatchSet();
    assertThat(ps.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("PS1");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps.getId());
    assertThat(ps.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps.getCreatedOn()).isEqualTo(update.getWhen());
}
#method_after
@Test
public void patchSetChangeNotes() throws Exception {
    Change c = newChange();
    // ps1 created by newChange()
    ChangeNotes notes = newNotes(c);
    PatchSet ps1 = notes.getCurrentPatchSet();
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps1.getId());
    assertThat(notes.getChange().getSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(ps1.getId()).isEqualTo(new PatchSet.Id(c.getId(), 1));
    assertThat(ps1.getUploader()).isEqualTo(changeOwner.getAccountId());
    // ps2 by other user
    incrementPatchSet(c);
    RevCommit commit = tr.commit().message("PS2").create();
    ChangeUpdate update = newUpdate(c, otherUser);
    update.setCommit(rw, commit);
    update.commit();
    notes = newNotes(c);
    PatchSet ps2 = notes.getCurrentPatchSet();
    assertThat(ps2.getId()).isEqualTo(new PatchSet.Id(c.getId(), 2));
    assertThat(notes.getChange().getSubject()).isEqualTo("PS2");
    assertThat(notes.getChange().getOriginalSubject()).isEqualTo("Change subject");
    assertThat(notes.getChange().currentPatchSetId()).isEqualTo(ps2.getId());
    assertThat(ps2.getRevision().get()).isNotEqualTo(ps1.getRevision());
    assertThat(ps2.getRevision().get()).isEqualTo(commit.name());
    assertThat(ps2.getUploader()).isEqualTo(otherUser.getAccountId());
    assertThat(ps2.getCreatedOn()).isEqualTo(update.getWhen());
}
#end_block

#method_before
protected Change newChange() throws IOException, OrmException, ConfigInvalidException {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#method_after
protected Change newChange() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId());
    ChangeUpdate u = newUpdate(c, changeOwner);
    u.setBranch(c.getDest().get());
    u.commit();
    return c;
}
#end_block

#method_before
protected ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws OrmException, IOException, ConfigInvalidException {
    ChangeUpdate update = TestChanges.newUpdate(injector, repoManager, MIGRATION, c, allUsers, user);
    try (Repository repo = repoManager.openMetadataRepository(c.getProject())) {
        update.load(repo);
    }
    return update;
}
#method_after
protected ChangeUpdate newUpdate(Change c, IdentifiedUser user) throws Exception {
    ChangeUpdate update = TestChanges.newUpdate(injector, repoManager, MIGRATION, c, allUsers, user);
    try (Repository repo = repoManager.openMetadataRepository(c.getProject())) {
        update.load(repo);
    }
    return update;
}
#end_block

#method_before
@VisibleForTesting
void setSubject(String subject) {
    this.subject = subject;
}
#method_after
void setSubject(String subject) {
    this.subject = subject;
}
#end_block

#method_before
@Test
public void approvalsCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) 1);
    update.putApproval("Code-Review", (short) -1);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.putReviewer(otherUser.getAccount().getId(), CC);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    RevCommit commit = parseCommit(update.getRevision());
    assertBodyEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Label: Code-Review=-1\n" + "Label: Verified=+1\n", commit);
    PersonIdent author = commit.getAuthorIdent();
    assertThat(author.getName()).isEqualTo("Change Owner");
    assertThat(author.getEmailAddress()).isEqualTo("1@gerrit");
    assertThat(author.getWhen()).isEqualTo(new Date(c.getCreatedOn().getTime() + 1000));
    assertThat(author.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT-7:00"));
    PersonIdent committer = commit.getCommitterIdent();
    assertThat(committer.getName()).isEqualTo("Gerrit Server");
    assertThat(committer.getEmailAddress()).isEqualTo("noreply@gerrit.com");
    assertThat(committer.getWhen()).isEqualTo(author.getWhen());
    assertThat(committer.getTimeZone()).isEqualTo(author.getTimeZone());
}
#method_after
@Test
public void approvalsCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.putApproval("Verified", (short) 1);
    update.putApproval("Code-Review", (short) -1);
    update.putReviewer(changeOwner.getAccount().getId(), REVIEWER);
    update.putReviewer(otherUser.getAccount().getId(), CC);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    RevCommit commit = parseCommit(update.getRevision());
    assertBodyEquals("Update patch set 1\n" + "\n" + "Patch-set: 1\n" + "Subject: Change subject\n" + "Branch: refs/heads/master\n" + "Commit: " + update.getCommit().name() + "\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Label: Code-Review=-1\n" + "Label: Verified=+1\n", commit);
    PersonIdent author = commit.getAuthorIdent();
    assertThat(author.getName()).isEqualTo("Change Owner");
    assertThat(author.getEmailAddress()).isEqualTo("1@gerrit");
    assertThat(author.getWhen()).isEqualTo(new Date(c.getCreatedOn().getTime() + 1000));
    assertThat(author.getTimeZone()).isEqualTo(TimeZone.getTimeZone("GMT-7:00"));
    PersonIdent committer = commit.getCommitterIdent();
    assertThat(committer.getName()).isEqualTo("Gerrit Server");
    assertThat(committer.getEmailAddress()).isEqualTo("noreply@gerrit.com");
    assertThat(committer.getWhen()).isEqualTo(author.getWhen());
    assertThat(committer.getTimeZone()).isEqualTo(author.getTimeZone());
}
#end_block

#method_before
@Test
public void changeMessageCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Just a little code change.\n" + "How about a new line");
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Just a little code change.\n" + "How about a new line\n" + "\n" + "Patch-set: 1\n", update.getRevision());
}
#method_after
@Test
public void changeMessageCommitFormatSimple() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Just a little code change.\n" + "How about a new line");
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Just a little code change.\n" + "How about a new line\n" + "\n" + "Patch-set: 1\n" + "Subject: Change subject\n" + "Branch: refs/heads/master\n" + "Commit: " + update.getCommit().name() + "\n", update.getRevision());
}
#end_block

#method_before
@Test
public void changeWithRevision() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Foo");
    RevCommit commit = tr.commit().message("Subject").create();
    update.setCommit(rw, commit);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Foo\n" + "\n" + "Patch-set: 1\n" + "Subject: Subject\n" + "Commit: " + commit.name() + "\n", update.getRevision());
}
#method_after
@Test
public void changeWithRevision() throws Exception {
    Change c = TestChanges.newChange(project, changeOwner.getAccountId(), 1);
    ChangeUpdate update = newUpdate(c, changeOwner);
    update.setChangeMessage("Foo");
    RevCommit commit = tr.commit().message("Subject").create();
    update.setCommit(rw, commit);
    update.commit();
    assertThat(update.getRefName()).isEqualTo("refs/changes/01/1/meta");
    assertBodyEquals("Update patch set 1\n" + "\n" + "Foo\n" + "\n" + "Patch-set: 1\n" + "Subject: Subject\n" + "Branch: refs/heads/master\n" + "Commit: " + commit.name() + "\n", update.getRevision());
}
#end_block

#method_before
public void putApproval(String label, short value) {
    approvals.put(label, Optional.of(value));
}
#method_after
public void putApproval(String label, short value) {
    putApprovalFor(getUser().getAccountId(), label, value);
}
#end_block

#method_before
public void removeApproval(String label) {
    approvals.put(label, Optional.<Short>absent());
}
#method_after
public void removeApproval(String label) {
    removeApprovalFor(getUser().getAccountId(), label);
}
#end_block

#method_before
public void merge(Iterable<SubmitRecord> submitRecords) {
    this.status = Change.Status.MERGED;
    this.submitRecords = ImmutableList.copyOf(submitRecords);
    checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time");
}
#method_after
public void merge(String submissionId, Iterable<SubmitRecord> submitRecords) {
    this.status = Change.Status.MERGED;
    this.submissionId = submissionId;
    this.submitRecords = ImmutableList.copyOf(submitRecords);
    checkArgument(!this.submitRecords.isEmpty(), "no submit records specified at submit time");
}
#end_block

#method_before
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        writeCommit(batch);
        if (draftUpdate != null) {
            draftUpdate.commit();
        }
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#method_after
public RevCommit commit() throws IOException {
    BatchMetaDataUpdate batch = openUpdate();
    try {
        writeCommit(batch);
        RevCommit c = batch.commit();
        return c;
    } catch (OrmException e) {
        throw new IOException(e);
    } finally {
        batch.close();
    }
}
#end_block

#method_before
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(this, builder);
}
#method_after
@Override
public void writeCommit(BatchMetaDataUpdate batch) throws OrmException, IOException {
    CommitBuilder builder = new CommitBuilder();
    if (migration.writeChanges()) {
        ObjectId treeId = storeCommentsInNotes();
        if (treeId != null) {
            builder.setTreeId(treeId);
        }
    }
    batch.write(this, builder);
    if (draftUpdate != null) {
        draftUpdate.commit();
    }
}
#end_block

#method_before
@Override
protected boolean onSave(CommitBuilder commit) {
    if (isEmpty()) {
        return false;
    }
    commit.setAuthor(newIdent(getUser().getAccount(), when));
    commit.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (subject != null) {
        msg.append(subject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (revId != null) {
        addFooter(msg, FOOTER_COMMIT, revId);
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        Account account = accountCache.get(e.getKey()).getAccount();
        PersonIdent ident = newIdent(account, when);
        addFooter(msg, e.getValue().getFooterKey()).append(ident.getName()).append(" <").append(ident.getEmailAddress()).append(">\n");
    }
    for (Map.Entry<String, Optional<Short>> e : approvals.entrySet()) {
        if (!e.getValue().isPresent()) {
            addFooter(msg, FOOTER_LABEL, '-', e.getKey());
        } else {
            addFooter(msg, FOOTER_LABEL, LabelVote.create(e.getKey(), e.getValue().get()).formatWithEquals());
        }
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    commit.setMessage(msg.toString());
    return true;
}
#method_after
@Override
protected boolean onSave(CommitBuilder cb) {
    if (getRevision() != null && isEmpty()) {
        return false;
    }
    cb.setAuthor(newIdent(getUser().getAccount(), when));
    cb.setCommitter(new PersonIdent(serverIdent, when));
    int ps = psId != null ? psId.get() : getChange().currentPatchSetId().get();
    StringBuilder msg = new StringBuilder();
    if (commitSubject != null) {
        msg.append(commitSubject);
    } else {
        msg.append("Update patch set ").append(ps);
    }
    msg.append("\n\n");
    if (changeMessage != null) {
        msg.append(changeMessage);
        msg.append("\n\n");
    }
    addFooter(msg, FOOTER_PATCH_SET, ps);
    if (subject != null) {
        addFooter(msg, FOOTER_SUBJECT, subject);
    }
    if (branch != null) {
        addFooter(msg, FOOTER_BRANCH, branch);
    }
    if (status != null) {
        addFooter(msg, FOOTER_STATUS, status.name().toLowerCase());
    }
    if (topic != null) {
        addFooter(msg, FOOTER_TOPIC, topic);
    }
    if (commit != null) {
        addFooter(msg, FOOTER_COMMIT, commit.name());
    }
    if (hashtags != null) {
        addFooter(msg, FOOTER_HASHTAGS, Joiner.on(",").join(hashtags));
    }
    for (Map.Entry<Account.Id, ReviewerStateInternal> e : reviewers.entrySet()) {
        addFooter(msg, e.getValue().getFooterKey());
        addIdent(msg, e.getKey()).append('\n');
    }
    for (Table.Cell<String, Account.Id, Optional<Short>> c : approvals.cellSet()) {
        addFooter(msg, FOOTER_LABEL);
        if (!c.getValue().isPresent()) {
            msg.append('-').append(c.getRowKey());
        } else {
            msg.append(LabelVote.create(c.getRowKey(), c.getValue().get()).formatWithEquals());
        }
        Account.Id id = c.getColumnKey();
        if (!id.equals(ctl.getUser().getAccountId())) {
            addIdent(msg.append(' '), id);
        }
        msg.append('\n');
    }
    if (submissionId != null) {
        addFooter(msg, FOOTER_SUBMISSION_ID, submissionId);
    }
    if (submitRecords != null) {
        for (SubmitRecord rec : submitRecords) {
            addFooter(msg, FOOTER_SUBMITTED_WITH).append(rec.status);
            if (rec.errorMessage != null) {
                msg.append(' ').append(sanitizeFooter(rec.errorMessage));
            }
            msg.append('\n');
            if (rec.labels != null) {
                for (SubmitRecord.Label label : rec.labels) {
                    addFooter(msg, FOOTER_SUBMITTED_WITH).append(label.status).append(": ").append(label.label);
                    if (label.appliedBy != null) {
                        PersonIdent ident = newIdent(accountCache.get(label.appliedBy).getAccount(), when);
                        msg.append(": ").append(ident.getName()).append(" <").append(ident.getEmailAddress()).append('>');
                    }
                    msg.append('\n');
                }
            }
        }
    }
    cb.setMessage(msg.toString());
    return true;
}
#end_block

#method_before
private boolean isEmpty() {
    return approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && status == null && subject == null && submitRecords == null && hashtags == null && topic == null;
}
#method_after
private boolean isEmpty() {
    return commitSubject == null && approvals.isEmpty() && changeMessage == null && comments.isEmpty() && reviewers.isEmpty() && branch == null && status == null && subject == null && submissionId == null && submitRecords == null && hashtags == null && topic == null && commit == null;
}
#end_block

#method_before
static PersonIdent newIdent(Account author, Date when, PersonIdent serverIdent, String anonymousCowardName) {
    return new PersonIdent(new AccountInfo(author).getName(anonymousCowardName), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone());
}
#method_after
@VisibleForTesting
public static PersonIdent newIdent(Account author, Date when, PersonIdent serverIdent, String anonymousCowardName) {
    return new PersonIdent(new AccountInfo(author).getName(anonymousCowardName), author.getId().get() + "@" + GERRIT_PLACEHOLDER_HOST, when, serverIdent.getTimeZone());
}
#end_block

#method_before
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#method_after
@Test
public void parseAuthor() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "owner@example.com", serverIdent.getWhen(), serverIdent.getTimeZone())));
    assertParseFails(writeCommit("Update change\n" + "\n" + "Patch-Set: 1\n", new PersonIdent("Change Owner", "x@gerrit", serverIdent.getWhen(), serverIdent.getTimeZone())));
}
#end_block

#method_before
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: new\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#method_after
@Test
public void parseStatus() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Status: new\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Status: NEW\n" + "Status: NEW\n");
}
#end_block

#method_before
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Patch-Set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: x\n");
}
#method_after
@Test
public void parsePatchSetId() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Patch-Set: 1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: x\n");
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#method_after
@Test
public void parseSubmitRecords() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Subject: This is a test change\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Code-Review\n" + "Submitted-with: NOT_READY\n" + "Submitted-with: OK: Verified: Change Owner <1@gerrit>\n" + "Submitted-with: NEED: Alternative-Code-Review\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OOPS\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: NEED: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: X+Y: Change Owner <1@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Submitted-with: OK: Code-Review: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: 1@gerrit\n");
}
#method_after
@Test
public void parseReviewer() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Reviewer: Change Owner <1@gerrit>\n" + "CC: Other Account <2@gerrit>\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Reviewer: 1@gerrit\n");
}
#end_block

#method_before
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic:");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#method_after
@Test
public void parseTopic() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Subject: This is a test change\n");
    assertParseSucceeds("Update change\n" + "\n" + "Branch: refs/heads/master\n" + "Patch-Set: 1\n" + "Topic:\n" + "Subject: This is a test change\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Topic: Some Topic\n" + "Topic: Other Topic");
}
#end_block

#method_before
@Test
public void parseCommit() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Commit: f11d66c4e8d1660f871b7ccf7df802a966975b85");
}
#method_after
@Test
public void parseCommit() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: abcd1234abcd1234abcd1234abcd1234abcd1234");
    assertParseFails("Update change\n" + "\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: abcd1234abcd1234abcd1234abcd1234abcd1234\n" + "Commit: deadbeefdeadbeefdeadbeefdeadbeefdeadbeef");
    assertParseFails("Update patch set 1\n" + "Uploaded patch set 1.\n" + "Patch-set: 1\n" + "Branch: refs/heads/master\n" + "Subject: Some subject of a change\n" + "Commit: beef");
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    return readFromGit ? readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId);
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    return readFromGit ? readFromGit(accountId, gitMgr, allUsersName, null) : readFromDb(accountId);
}
#end_block

#method_before
private AccountGeneralPreferencesInfo readFromDb(Id accountId) throws IOException, ConfigInvalidException, RepositoryNotFoundException, OrmException {
    Account a = db.get().accounts().get(accountId);
    AccountGeneralPreferencesInfo r = nullify(initFromDb(a.getGeneralPreferences()));
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(accountId);
        p.load(allUsers);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#method_after
private GeneralPreferencesInfo readFromDb(Account.Id accountId) throws IOException, ConfigInvalidException, RepositoryNotFoundException, OrmException {
    Account a = db.get().accounts().get(accountId);
    GeneralPreferencesInfo r = nullify(initFromDb(a.getGeneralPreferences()));
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(accountId);
        p.load(allUsers);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#end_block

#method_before
public static AccountGeneralPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, AccountGeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        AccountGeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new AccountGeneralPreferencesInfo(), AccountGeneralPreferencesInfo.defaults(), in);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#method_after
public static GeneralPreferencesInfo readFromGit(Account.Id id, GitRepositoryManager gitMgr, AllUsersName allUsersName, GeneralPreferencesInfo in) throws IOException, ConfigInvalidException, RepositoryNotFoundException {
    try (Repository allUsers = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(id);
        p.load(allUsers);
        GeneralPreferencesInfo r = loadSection(p.getConfig(), UserConfigSections.GENERAL, null, new GeneralPreferencesInfo(), GeneralPreferencesInfo.defaults(), in);
        return loadFromAllUsers(r, p, allUsers);
    }
}
#end_block

#method_before
public static AccountGeneralPreferencesInfo loadFromAllUsers(AccountGeneralPreferencesInfo r, VersionedAccountPreferences v, Repository allUsers) {
    r.my = my(v);
    if (r.my.isEmpty() && !v.isDefaults()) {
        try {
            VersionedAccountPreferences d = VersionedAccountPreferences.forDefault();
            d.load(allUsers);
            r.my = my(d);
        } catch (ConfigInvalidException | IOException e) {
            log.warn("cannot read default preferences", e);
        }
    }
    if (r.my.isEmpty()) {
        r.my.add(new MenuItem("Changes", "#/dashboard/self", null));
        r.my.add(new MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        r.my.add(new MenuItem("Draft Comments", "#/q/has:draft", null));
        r.my.add(new MenuItem("Edits", "#/q/has:edit", null));
        r.my.add(new MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        r.my.add(new MenuItem("Starred Changes", "#/q/is:starred", null));
        r.my.add(new MenuItem("Groups", "#/groups/self", null));
    }
    r.urlAliases = urlAliases(v);
    return r;
}
#method_after
public static GeneralPreferencesInfo loadFromAllUsers(GeneralPreferencesInfo r, VersionedAccountPreferences v, Repository allUsers) {
    r.my = my(v);
    if (r.my.isEmpty() && !v.isDefaults()) {
        try {
            VersionedAccountPreferences d = VersionedAccountPreferences.forDefault();
            d.load(allUsers);
            r.my = my(d);
        } catch (ConfigInvalidException | IOException e) {
            log.warn("cannot read default preferences", e);
        }
    }
    if (r.my.isEmpty()) {
        r.my.add(new MenuItem("Changes", "#/dashboard/self", null));
        r.my.add(new MenuItem("Drafts", "#/q/owner:self+is:draft", null));
        r.my.add(new MenuItem("Draft Comments", "#/q/has:draft", null));
        r.my.add(new MenuItem("Edits", "#/q/has:edit", null));
        r.my.add(new MenuItem("Watched Changes", "#/q/is:watched+is:open", null));
        r.my.add(new MenuItem("Starred Changes", "#/q/is:starred", null));
        r.my.add(new MenuItem("Groups", "#/groups/self", null));
    }
    r.urlAliases = urlAliases(v);
    return r;
}
#end_block

#method_before
static AccountGeneralPreferencesInfo initFromDb(AccountGeneralPreferences a) {
    AccountGeneralPreferencesInfo p = AccountGeneralPreferencesInfo.defaults();
    if (a != null) {
        p.changesPerPage = (int) a.getMaximumPageSize();
        p.showSiteHeader = a.isShowSiteHeader();
        p.useFlashClipboard = a.isUseFlashClipboard();
        p.downloadScheme = a.getDownloadUrl();
        if (a.getDownloadCommand() != null) {
            p.downloadCommand = DownloadCommand.valueOf(a.getDownloadCommand().name());
        }
        p.emailStrategy = EmailStrategy.valueOf(a.getEmailStrategy().name());
        p.dateFormat = DateFormat.valueOf(a.getDateFormat().name());
        p.timeFormat = TimeFormat.valueOf(a.getTimeFormat().name());
        p.relativeDateInChangeTable = a.isRelativeDateInChangeTable();
        p.sizeBarInChangeTable = a.isSizeBarInChangeTable();
        p.legacycidInChangeTable = a.isLegacycidInChangeTable();
        p.muteCommonPathPrefixes = a.isMuteCommonPathPrefixes();
        p.reviewCategoryStrategy = ReviewCategoryStrategy.valueOf(a.getReviewCategoryStrategy().name());
        p.diffView = DiffView.valueOf(a.getDiffView().name());
    }
    return p;
}
#method_after
static GeneralPreferencesInfo initFromDb(AccountGeneralPreferences a) {
    GeneralPreferencesInfo p = GeneralPreferencesInfo.defaults();
    if (a != null) {
        p.changesPerPage = (int) a.getMaximumPageSize();
        p.showSiteHeader = a.isShowSiteHeader();
        p.useFlashClipboard = a.isUseFlashClipboard();
        p.downloadScheme = a.getDownloadUrl();
        if (a.getDownloadCommand() != null) {
            p.downloadCommand = DownloadCommand.valueOf(a.getDownloadCommand().name());
        }
        p.emailStrategy = EmailStrategy.valueOf(a.getEmailStrategy().name());
        p.dateFormat = DateFormat.valueOf(a.getDateFormat().name());
        p.timeFormat = TimeFormat.valueOf(a.getTimeFormat().name());
        p.relativeDateInChangeTable = a.isRelativeDateInChangeTable();
        p.sizeBarInChangeTable = a.isSizeBarInChangeTable();
        p.legacycidInChangeTable = a.isLegacycidInChangeTable();
        p.muteCommonPathPrefixes = a.isMuteCommonPathPrefixes();
        p.reviewCategoryStrategy = ReviewCategoryStrategy.valueOf(a.getReviewCategoryStrategy().name());
        p.diffView = DiffView.valueOf(a.getDiffView().name());
    }
    return p;
}
#end_block

#method_before
private static AccountGeneralPreferencesInfo nullify(AccountGeneralPreferencesInfo p) {
    p.showSiteHeader = b(p.showSiteHeader);
    p.useFlashClipboard = b(p.useFlashClipboard);
    p.relativeDateInChangeTable = b(p.relativeDateInChangeTable);
    p.legacycidInChangeTable = b(p.legacycidInChangeTable);
    p.muteCommonPathPrefixes = b(p.muteCommonPathPrefixes);
    return p;
}
#method_after
private static GeneralPreferencesInfo nullify(GeneralPreferencesInfo p) {
    p.showSiteHeader = b(p.showSiteHeader);
    p.useFlashClipboard = b(p.useFlashClipboard);
    p.relativeDateInChangeTable = b(p.relativeDateInChangeTable);
    p.legacycidInChangeTable = b(p.legacycidInChangeTable);
    p.muteCommonPathPrefixes = b(p.muteCommonPathPrefixes);
    p.sizeBarInChangeTable = b(p.sizeBarInChangeTable);
    return p;
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(ConfigResource rsrc, AccountGeneralPreferencesInfo i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        AccountGeneralPreferencesInfo a = new AccountGeneralPreferencesInfo();
        return loadFromAllUsers(a, p, md.getRepository());
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(ConfigResource rsrc, GeneralPreferencesInfo i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        GeneralPreferencesInfo a = new GeneralPreferencesInfo();
        return loadFromAllUsers(a, p, md.getRepository());
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final int v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), AccountGeneralPreferencesInfo.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), AccountGeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), AccountGeneralPreferencesInfo.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferencesInfo.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferencesInfo.DateFormat fmt : AccountGeneralPreferencesInfo.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferencesInfo.TimeFormat fmt : AccountGeneralPreferencesInfo.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final int v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), GeneralPreferencesInfo.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), GeneralPreferencesInfo.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), GeneralPreferencesInfo.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), GeneralPreferencesInfo.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), GeneralPreferencesInfo.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), GeneralPreferencesInfo.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), GeneralPreferencesInfo.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), GeneralPreferencesInfo.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), GeneralPreferencesInfo.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (GeneralPreferencesInfo.DateFormat fmt : GeneralPreferencesInfo.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (GeneralPreferencesInfo.TimeFormat fmt : GeneralPreferencesInfo.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<AccountPreferencesInfo>(this) {

        @Override
        public void preDisplay(AccountPreferencesInfo prefs) {
            display(prefs);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<GeneralPreferences>(this) {

        @Override
        public void preDisplay(GeneralPreferences prefs) {
            display(prefs);
        }
    });
}
#end_block

#method_before
private void display(JsArray<TopMenuItem> items) {
    List<List<String>> values = new ArrayList<>();
    for (TopMenuItem item : Natives.asList(items)) {
        values.add(Arrays.asList(item.getName(), item.getUrl()));
    }
    myMenus.display(values);
}
#method_after
private void display(GeneralPreferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    GeneralPreferencesInfo.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    GeneralPreferencesInfo.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, GeneralPreferencesInfo.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, p.diffView());
    setListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, p.emailStrategy());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    AccountPreferencesInfo p = AccountPreferencesInfo.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, AccountGeneralPreferencesInfo.DateFormat.STD, AccountGeneralPreferencesInfo.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, AccountGeneralPreferencesInfo.TimeFormat.HHMM_12, AccountGeneralPreferencesInfo.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, AccountGeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, AccountGeneralPreferencesInfo.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, AccountGeneralPreferencesInfo.EmailStrategy.ENABLED, AccountGeneralPreferencesInfo.EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<AccountPreferencesInfo>() {

        @Override
        public void onSuccess(AccountPreferencesInfo prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    GeneralPreferences p = GeneralPreferences.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, GeneralPreferencesInfo.DateFormat.STD, GeneralPreferencesInfo.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, GeneralPreferencesInfo.TimeFormat.HHMM_12, GeneralPreferencesInfo.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, GeneralPreferencesInfo.DiffView.SIDE_BY_SIDE, GeneralPreferencesInfo.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, GeneralPreferencesInfo.EmailStrategy.ENABLED, GeneralPreferencesInfo.EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<GeneralPreferences>() {

        @Override
        public void onSuccess(GeneralPreferences prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(AccountResource rsrc, AccountGeneralPreferencesInfo i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    checkDownloadScheme(i);
    Account.Id id = rsrc.getUser().getAccountId();
    AccountGeneralPreferencesInfo n = readFromGit ? readFromGit(id, gitMgr, allUsersName, i) : merge(initFromDb(db.get().accounts().get(id).getGeneralPreferences()), i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    writeToDb(id, n);
    return GetPreferences.readFromGit(id, gitMgr, allUsersName, null);
}
#method_after
@Override
public GeneralPreferencesInfo apply(AccountResource rsrc, GeneralPreferencesInfo i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    checkDownloadScheme(i.downloadScheme);
    Account.Id id = rsrc.getUser().getAccountId();
    GeneralPreferencesInfo n = readFromGit ? readFromGit(id, gitMgr, allUsersName, i) : merge(initFromDb(db.get().accounts().get(id).getGeneralPreferences()), i);
    n.my = i.my;
    n.urlAliases = i.urlAliases;
    writeToGit(id, n);
    writeToDb(id, n);
    cache.evict(id);
    return GetPreferences.readFromGit(id, gitMgr, allUsersName, null);
}
#end_block

#method_before
private void writeToGit(Account.Id id, AccountGeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, AccountGeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
        cache.evict(id);
    }
}
#method_after
private void writeToGit(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, ConfigInvalidException {
    VersionedAccountPreferences prefs;
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        prefs = VersionedAccountPreferences.forUser(id);
        prefs.load(md);
        storeSection(prefs.getConfig(), UserConfigSections.GENERAL, null, i, GeneralPreferencesInfo.defaults());
        storeMyMenus(prefs, i.my);
        storeUrlAliases(prefs, i.urlAliases);
        prefs.commit(md);
    }
}
#end_block

#method_before
private void writeToDb(Account.Id id, AccountGeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, OrmException, ConfigInvalidException {
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    db.get().accounts().beginTransaction(id);
    try {
        Account a = db.get().accounts().get(id);
        versionedPrefs = VersionedAccountPreferences.forUser(id);
        versionedPrefs.load(md);
        AccountGeneralPreferences p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        p = initAccountGeneralPreferences(p, i);
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
        cache.evict(id);
    } finally {
        db.get().rollback();
    }
}
#method_after
private void writeToDb(Account.Id id, GeneralPreferencesInfo i) throws RepositoryNotFoundException, IOException, OrmException, ConfigInvalidException {
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    db.get().accounts().beginTransaction(id);
    try {
        Account a = db.get().accounts().get(id);
        VersionedAccountPreferences versionedPrefs = VersionedAccountPreferences.forUser(id);
        versionedPrefs.load(md);
        AccountGeneralPreferences p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        initAccountGeneralPreferences(p, i);
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
    } finally {
        db.get().rollback();
    }
}
#end_block

#method_before
private void checkDownloadScheme(AccountGeneralPreferencesInfo p) throws BadRequestException {
    if (Strings.isNullOrEmpty(p.downloadScheme)) {
        return;
    }
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        if (e.getExportName().equals(p.downloadScheme) && e.getProvider().get().isEnabled()) {
            return;
        }
    }
    throw new BadRequestException("Unsupported download scheme: " + p.downloadScheme);
}
#method_after
private void checkDownloadScheme(String downloadScheme) throws BadRequestException {
    if (Strings.isNullOrEmpty(downloadScheme)) {
        return;
    }
    for (DynamicMap.Entry<DownloadScheme> e : downloadSchemes) {
        if (e.getExportName().equals(downloadScheme) && e.getProvider().get().isEnabled()) {
            return;
        }
    }
    throw new BadRequestException("Unsupported download scheme: " + downloadScheme);
}
#end_block

#method_before
private AccountGeneralPreferencesInfo merge(AccountGeneralPreferencesInfo p, AccountGeneralPreferencesInfo i) {
    if (i.changesPerPage != null) {
        p.changesPerPage = i.changesPerPage;
    }
    if (i.showSiteHeader != null) {
        p.showSiteHeader = i.showSiteHeader;
    }
    if (i.useFlashClipboard != null) {
        p.useFlashClipboard = i.useFlashClipboard;
    }
    if (i.downloadScheme != null) {
        p.downloadScheme = i.downloadScheme;
    }
    if (i.downloadCommand != null) {
        p.downloadCommand = i.downloadCommand;
    }
    if (i.dateFormat != null) {
        p.dateFormat = i.dateFormat;
    }
    if (i.timeFormat != null) {
        p.timeFormat = i.timeFormat;
    }
    if (i.relativeDateInChangeTable != null) {
        p.relativeDateInChangeTable = i.relativeDateInChangeTable;
    }
    if (i.sizeBarInChangeTable != null) {
        p.sizeBarInChangeTable = i.sizeBarInChangeTable;
    }
    if (i.legacycidInChangeTable != null) {
        p.legacycidInChangeTable = i.legacycidInChangeTable;
    }
    if (i.muteCommonPathPrefixes != null) {
        p.muteCommonPathPrefixes = i.muteCommonPathPrefixes;
    }
    if (i.reviewCategoryStrategy != null) {
        p.reviewCategoryStrategy = i.reviewCategoryStrategy;
    }
    if (i.diffView != null) {
        p.diffView = i.diffView;
    }
    if (i.emailStrategy != null) {
        p.emailStrategy = i.emailStrategy;
    }
    return p;
}
#method_after
private GeneralPreferencesInfo merge(GeneralPreferencesInfo p, GeneralPreferencesInfo i) {
    if (i.changesPerPage != null) {
        p.changesPerPage = i.changesPerPage;
    }
    if (i.showSiteHeader != null) {
        p.showSiteHeader = i.showSiteHeader;
    }
    if (i.useFlashClipboard != null) {
        p.useFlashClipboard = i.useFlashClipboard;
    }
    if (i.downloadScheme != null) {
        p.downloadScheme = i.downloadScheme;
    }
    if (i.downloadCommand != null) {
        p.downloadCommand = i.downloadCommand;
    }
    if (i.dateFormat != null) {
        p.dateFormat = i.dateFormat;
    }
    if (i.timeFormat != null) {
        p.timeFormat = i.timeFormat;
    }
    if (i.relativeDateInChangeTable != null) {
        p.relativeDateInChangeTable = i.relativeDateInChangeTable;
    }
    if (i.sizeBarInChangeTable != null) {
        p.sizeBarInChangeTable = i.sizeBarInChangeTable;
    }
    if (i.legacycidInChangeTable != null) {
        p.legacycidInChangeTable = i.legacycidInChangeTable;
    }
    if (i.muteCommonPathPrefixes != null) {
        p.muteCommonPathPrefixes = i.muteCommonPathPrefixes;
    }
    if (i.reviewCategoryStrategy != null) {
        p.reviewCategoryStrategy = i.reviewCategoryStrategy;
    }
    if (i.diffView != null) {
        p.diffView = i.diffView;
    }
    if (i.emailStrategy != null) {
        p.emailStrategy = i.emailStrategy;
    }
    return p;
}
#end_block

#method_before
private static AccountGeneralPreferences initAccountGeneralPreferences(AccountGeneralPreferences a, AccountGeneralPreferencesInfo i) {
    if (a == null) {
        a = AccountGeneralPreferences.createDefault();
    }
    a.setMaximumPageSize((short) (int) i.changesPerPage);
    a.setShowSiteHeader(b(i.showSiteHeader));
    a.setUseFlashClipboard(i.useFlashClipboard);
    a.setDownloadUrl(i.downloadScheme);
    if (i.downloadCommand != null) {
        a.setDownloadCommand(DownloadCommand.valueOf(i.downloadCommand.name()));
    }
    a.setEmailStrategy(EmailStrategy.valueOf(i.getEmailStrategy().name()));
    a.setDateFormat(DateFormat.valueOf(i.getDateFormat().name()));
    a.setTimeFormat(TimeFormat.valueOf(i.getTimeFormat().name()));
    a.setRelativeDateInChangeTable(b(i.relativeDateInChangeTable));
    a.setSizeBarInChangeTable(b(i.sizeBarInChangeTable));
    a.setLegacycidInChangeTable(b(i.legacycidInChangeTable));
    a.setMuteCommonPathPrefixes(b(i.muteCommonPathPrefixes));
    a.setReviewCategoryStrategy(ReviewCategoryStrategy.valueOf(i.getReviewCategoryStrategy().name()));
    a.setDiffView(DiffView.valueOf(i.getDiffView().name()));
    return a;
}
#method_after
private static void initAccountGeneralPreferences(AccountGeneralPreferences a, GeneralPreferencesInfo i) {
    if (a == null) {
        a = AccountGeneralPreferences.createDefault();
    }
    a.setMaximumPageSize((short) (int) i.changesPerPage);
    a.setShowSiteHeader(b(i.showSiteHeader));
    a.setUseFlashClipboard(b(i.useFlashClipboard));
    a.setDownloadUrl(i.downloadScheme);
    if (i.downloadCommand != null) {
        a.setDownloadCommand(DownloadCommand.valueOf(i.downloadCommand.name()));
    }
    a.setEmailStrategy(EmailStrategy.valueOf(i.getEmailStrategy().name()));
    a.setDateFormat(DateFormat.valueOf(i.getDateFormat().name()));
    a.setTimeFormat(TimeFormat.valueOf(i.getTimeFormat().name()));
    a.setRelativeDateInChangeTable(b(i.relativeDateInChangeTable));
    a.setSizeBarInChangeTable(b(i.sizeBarInChangeTable));
    a.setLegacycidInChangeTable(b(i.legacycidInChangeTable));
    a.setMuteCommonPathPrefixes(b(i.muteCommonPathPrefixes));
    a.setReviewCategoryStrategy(ReviewCategoryStrategy.valueOf(i.getReviewCategoryStrategy().name()));
    a.setDiffView(DiffView.valueOf(i.getDiffView().name()));
}
#end_block

#method_before
@Override
public AccountGeneralPreferencesInfo apply(ConfigResource rsrc) throws IOException, ConfigInvalidException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(git);
        AccountGeneralPreferencesInfo a = new AccountGeneralPreferencesInfo();
        return loadFromAllUsers(a, p, git);
    }
}
#method_after
@Override
public GeneralPreferencesInfo apply(ConfigResource rsrc) throws IOException, ConfigInvalidException {
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forDefault();
        p.load(git);
        GeneralPreferencesInfo a = new GeneralPreferencesInfo();
        return loadFromAllUsers(a, p, git);
    }
}
#end_block

#method_before
void close() {
    ins.close();
    rw.close();
    repo.close();
}
#method_after
void close() {
    if (update != null) {
        update.close();
    }
    ins.close();
    rw.close();
    repo.close();
}
#end_block

#method_before
boolean isOk() {
    return problems.isEmpty();
}
#method_after
public boolean isOk() {
    return problems.isEmpty();
}
#end_block

#method_before
ImmutableMultimap<Change.Id, String> getProblems() {
    return ImmutableMultimap.copyOf(problems);
}
#method_after
public ImmutableMultimap<Change.Id, String> getProblems() {
    return ImmutableMultimap.copyOf(problems);
}
#end_block

#method_before
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = cd.getSubmitRecords();
    if (results == null) {
        results = new SubmitRuleEvaluator(cd).evaluate();
        cd.setSubmitRecords(results);
    }
    if (findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case OK:
                throw new IllegalStateException(String.format("Unexpected OK result in SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
            default:
                throw new IllegalStateException(String.format("Unsupported SubmitRecord %s for %s in %s", record, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#method_after
public static void checkSubmitRule(ChangeData cd) throws ResourceConflictException, OrmException {
    PatchSet patchSet = cd.currentPatchSet();
    if (patchSet == null) {
        throw new ResourceConflictException("missing current patch set for change " + cd.getId());
    }
    List<SubmitRecord> results = getSubmitRecords(cd);
    if (findOkRecord(results).isPresent()) {
        // Rules supplied a valid solution.
        return;
    } else if (results.isEmpty()) {
        throw new IllegalStateException(String.format("SubmitRuleEvaluator.evaluate for change %s " + "returned empty list for %s in %s", cd.getId(), patchSet.getId(), cd.change().getProject().get()));
    }
    for (SubmitRecord record : results) {
        switch(record.status) {
            case CLOSED:
                throw new ResourceConflictException("change is closed");
            case RULE_ERROR:
                throw new ResourceConflictException("submit rule error: " + record.errorMessage);
            case NOT_READY:
                throw new ResourceConflictException(describeLabels(cd, record.labels));
            case FORCED:
            case OK:
            default:
                throw new IllegalStateException(String.format("Unexpected SubmitRecord status %s for %s in %s", record.status, patchSet.getId().getId(), cd.change().getProject().get()));
        }
    }
    throw new IllegalStateException();
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules) throws OrmException, ResourceConflictException {
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change);
        reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules) throws OrmException, RestApiException {
    this.caller = caller;
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change);
        this.commits = new CommitStatus(cs);
        reloadChanges(cs);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
            // Done checks that don't involve opening repo.
            failFast(cs);
        } else {
            logDebug("Bypassing submit rules");
            bypassSubmitRules(cs);
        }
        try {
            integrateIntoHistory(cs);
        } catch (IntegrationException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        openRepos(br.keySet());
        for (Branch.NameKey branch : cbb.keySet()) {
            OpenRepo or = getRepo(branch.getParentKey());
            toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
        }
        // Done checks that don't involve running submit strategies.
        failFast(cs);
        for (Branch.NameKey branch : cbb.keySet()) {
            OpenRepo or = getRepo(branch.getParentKey());
            OpenBranch ob = or.getBranch(branch);
            BranchBatch submitting = toSubmit.get(branch);
            SubmitStrategy strategy = createStrategy(or, branch, submitting.submitType(), ob.oldTip);
            ob.mergeTip = preMerge(strategy, submitting.changes(), ob.oldTip);
        }
        checkMergeStrategyResults(cs, toSubmit.values());
        for (Project.NameKey project : br.keySet()) {
            getRepo(project).ins.flush();
        }
        Set<Branch.NameKey> done = Sets.newHashSetWithExpectedSize(cbb.keySet().size());
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            OpenRepo or = getRepo(project);
            for (Branch.NameKey branch : br.get(project)) {
                OpenBranch ob = or.getBranch(branch);
                boolean updated = updateBranch(or, branch);
                BranchBatch submitting = toSubmit.get(branch);
                updateChangeStatus(ob, submitting.changes());
                updateSubmoduleSubscriptions(ob, subOp);
                if (updated) {
                    fireRefUpdated(ob);
                }
                done.add(branch);
            }
        }
        updateSuperProjects(subOp, br.values());
        checkState(done.equals(cbb.keySet()), "programmer error: did not process" + " all branches in input set.\nExpected: %s\nActual: %s", done, cbb.keySet());
    } catch (OrmException e) {
        throw new IntegrationException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrationException("Cannot query the database", e);
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs) throws IntegrationException, RestApiException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, BranchBatch> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        Set<Project.NameKey> projects = br.keySet();
        Collection<Branch.NameKey> branches = cbb.keySet();
        openRepos(projects);
        for (Branch.NameKey branch : branches) {
            OpenRepo or = getRepo(branch.getParentKey());
            toSubmit.put(branch, validateChangeList(or, cbb.get(branch)));
        }
        // Done checks that don't involve running submit strategies.
        failFast(cs);
        List<SubmitStrategy> strategies = new ArrayList<>(branches.size());
        for (Branch.NameKey branch : branches) {
            OpenRepo or = getRepo(branch.getParentKey());
            OpenBranch ob = or.getBranch(branch);
            BranchBatch submitting = toSubmit.get(branch);
            Set<CodeReviewCommit> commitsToSubmit = commits(submitting.changes());
            ob.mergeTip = new MergeTip(ob.oldTip, commitsToSubmit);
            SubmitStrategy strategy = createStrategy(or, ob.mergeTip, branch, submitting.submitType(), ob.oldTip);
            strategies.add(strategy);
            strategy.addOps(or.getUpdate(), commitsToSubmit);
        }
        BatchUpdate.execute(batchUpdates(projects), new SubmitStrategyListener(strategies, commits));
        SubmoduleOp subOp = subOpProvider.get();
        for (Branch.NameKey branch : branches) {
            OpenBranch ob = getRepo(branch.getParentKey()).getBranch(branch);
            updateSubmoduleSubscriptions(ob, subOp);
        }
        updateSuperProjects(subOp, br.values());
    } catch (UpdateException | OrmException e) {
        throw new IntegrationException("Error submitting changes", e);
    }
}
#end_block

#method_before
private SubmitStrategy createStrategy(OpenRepo or, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, commits);
}
#method_after
private SubmitStrategy createStrategy(OpenRepo or, MergeTip mergeTip, Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws IntegrationException {
    return submitStrategyFactory.create(submitType, db, or.repo, or.rw, or.ins, or.canMergeFlag, getAlreadyAccepted(or, branchTip), destBranch, caller, mergeTip, commits, submissionId);
}
#end_block

#method_before
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    ChangeUpdate update = updateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#method_after
private void abandonOneChange(Change change) throws OrmException, NoSuchChangeException, IOException {
    db.changes().beginTransaction(change.getId());
    // TODO(dborowitz): support InternalUser in ChangeUpdate
    ChangeControl control = changeControlFactory.controlFor(change, identifiedUserFactory.create(change.getOwner()));
    // TODO(dborowitz): Convert to BatchUpdate.
    ChangeUpdate update = changeUpdateFactory.create(control);
    try {
        change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setStatus(Change.Status.ABANDONED);
                    return change;
                }
                return null;
            }
        });
        if (change != null) {
            ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), null, change.getLastUpdatedOn(), change.currentPatchSetId());
            msg.setMessage("Project was deleted.");
            // TODO(yyonas): atomic change is not propagated.
            cmUtil.addChangeMessage(db, update, msg);
            db.commit();
            indexer.index(db, change);
        }
    } finally {
        db.rollback();
    }
    update.commit();
}
#end_block

#method_before
private static String status(Status status) {
    switch(status) {
        case ABANDONED:
            return "status:abandoned";
        case DRAFT:
            return "status:draft";
        case MERGED:
            return "status:merged";
        case NEW:
        default:
            return "status:open";
    }
}
#method_after
private static String status(Status status) {
    switch(status) {
        case ABANDONED:
            return "status:abandoned";
        case MERGED:
            return "status:merged";
        case DRAFT:
        case NEW:
        default:
            return "status:open";
    }
}
#end_block

#method_before
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.created;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#method_after
private void reportMessages() {
    Iterable<CreateRequest> created = Iterables.filter(newChanges, new Predicate<CreateRequest>() {

        @Override
        public boolean apply(CreateRequest input) {
            return input.change != null;
        }
    });
    if (!Iterables.isEmpty(created)) {
        addMessage("");
        addMessage("New Changes:");
        for (CreateRequest c : created) {
            addMessage(formatChangeUrl(canonicalWebUrl, c.change, false));
        }
        addMessage("");
    }
    List<ReplaceRequest> updated = FluentIterable.from(replaceByChange.values()).filter(new Predicate<ReplaceRequest>() {

        @Override
        public boolean apply(ReplaceRequest input) {
            return !input.skip && input.inputCommand.getResult() == OK;
        }
    }).toSortedList(Ordering.natural().onResultOf(new Function<ReplaceRequest, Integer>() {

        @Override
        public Integer apply(ReplaceRequest in) {
            return in.change.getId().get();
        }
    }));
    if (!updated.isEmpty()) {
        addMessage("");
        addMessage("Updated Changes:");
        boolean edit = magicBranch != null && magicBranch.edit;
        for (ReplaceRequest u : updated) {
            addMessage(formatChangeUrl(canonicalWebUrl, u.change, edit));
        }
        addMessage("");
    }
}
#end_block

#method_before
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            Change.Key changeKey = new Change.Key("I" + c.name());
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(magicBranch.ctl, c, changeKey));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            changeKey = new Change.Key(idStr);
            pending.add(new ChangeLookup(c, changeKey));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(magicBranch.ctl, p.commit, p.changeKey));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#method_after
private void selectNewAndReplacedChangesFromMagicBranch() {
    newChanges = Lists.newArrayList();
    SetMultimap<ObjectId, Ref> existing = changeRefsById();
    GroupCollector groupCollector = new GroupCollector(refsById, db);
    rp.getRevWalk().reset();
    rp.getRevWalk().sort(RevSort.TOPO);
    rp.getRevWalk().sort(RevSort.REVERSE, true);
    try {
        rp.getRevWalk().markStart(rp.getRevWalk().parseCommit(magicBranch.cmd.getNewId()));
        if (magicBranch.baseCommit != null) {
            for (RevCommit c : magicBranch.baseCommit) {
                rp.getRevWalk().markUninteresting(c);
            }
            Ref targetRef = allRefs.get(magicBranch.ctl.getRefName());
            if (targetRef != null) {
                rp.getRevWalk().markUninteresting(rp.getRevWalk().parseCommit(targetRef.getObjectId()));
            }
        } else {
            markHeadsAsUninteresting(rp.getRevWalk(), magicBranch.ctl != null ? magicBranch.ctl.getRefName() : null);
        }
        List<ChangeLookup> pending = Lists.newArrayList();
        final Set<Change.Key> newChangeIds = new HashSet<>();
        final int maxBatchChanges = receiveConfig.getEffectiveMaxBatchChangesLimit(user);
        for (; ; ) {
            final RevCommit c = rp.getRevWalk().next();
            if (c == null) {
                break;
            }
            groupCollector.visit(c);
            Collection<Ref> existingRefs = existing.get(c);
            if (!existingRefs.isEmpty()) {
                // A's group.
                for (Ref ref : existingRefs) {
                    updateGroups.add(new UpdateGroupsRequest(ref, c));
                }
                continue;
            }
            if (!validCommit(magicBranch.ctl, magicBranch.cmd, c)) {
                // Not a change the user can propose? Abort as early as possible.
                newChanges = Collections.emptyList();
                return;
            }
            // Don't allow merges to be uploaded in commit chain via all-not-in-target
            if (newChangeForAllNotInTarget && c.getParentCount() > 1) {
                reject(magicBranch.cmd, "Pushing merges in commit chains with 'all not in target' is not allowed,\n" + "to override please set the base manually");
            }
            final List<String> idList = c.getFooterLines(CHANGE_ID);
            if (idList.isEmpty()) {
                newChanges.add(new CreateRequest(c, magicBranch.dest.get()));
                continue;
            }
            final String idStr = idList.get(idList.size() - 1).trim();
            if (idStr.matches("^I00*$")) {
                // Reject this invalid line from EGit.
                reject(magicBranch.cmd, "invalid Change-Id");
                newChanges = Collections.emptyList();
                return;
            }
            pending.add(new ChangeLookup(c, new Change.Key(idStr)));
            if (maxBatchChanges != 0 && pending.size() + newChanges.size() > maxBatchChanges) {
                reject(magicBranch.cmd, "the number of pushed changes in a batch exceeds the max limit " + maxBatchChanges);
                newChanges = Collections.emptyList();
                return;
            }
        }
        for (ChangeLookup p : pending) {
            if (newChangeIds.contains(p.changeKey)) {
                reject(magicBranch.cmd, "squash commits first");
                newChanges = Collections.emptyList();
                return;
            }
            List<ChangeData> changes = p.destChanges;
            if (changes.size() > 1) {
                // WTF, multiple changes in this project have the same key?
                // Since the commit is new, the user should recreate it with
                // a different Change-Id. In practice, we should never see
                // this error message as Change-Id should be unique.
                // 
                reject(magicBranch.cmd, p.changeKey.get() + " has duplicates");
                newChanges = Collections.emptyList();
                return;
            }
            if (changes.size() == 1) {
                // 
                if (requestReplace(magicBranch.cmd, false, changes.get(0).change(), p.commit)) {
                    continue;
                } else {
                    newChanges = Collections.emptyList();
                    return;
                }
            }
            if (changes.size() == 0) {
                if (!isValidChangeId(p.changeKey.get())) {
                    reject(magicBranch.cmd, "invalid Change-Id");
                    newChanges = Collections.emptyList();
                    return;
                }
                newChangeIds.add(p.changeKey);
            }
            newChanges.add(new CreateRequest(p.commit, magicBranch.dest.get()));
        }
    } catch (IOException e) {
        // Should never happen, the core receive process would have
        // identified the missing object earlier before we got control.
        // 
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
        newChanges = Collections.emptyList();
        return;
    } catch (OrmException e) {
        log.error("Cannot query database to locate prior changes", e);
        reject(magicBranch.cmd, "database error");
        newChanges = Collections.emptyList();
        return;
    }
    if (newChanges.isEmpty() && replaceByChange.isEmpty()) {
        reject(magicBranch.cmd, "no new changes");
        return;
    }
    if (!newChanges.isEmpty() && magicBranch.edit) {
        reject(magicBranch.cmd, "edit is not supported for new changes");
        return;
    }
    try {
        Multimap<ObjectId, String> groups = groupCollector.getGroups();
        for (CreateRequest create : newChanges) {
            batch.addCommand(create.cmd);
            create.groups = groups.get(create.commit);
        }
        for (ReplaceRequest replace : replaceByChange.values()) {
            replace.groups = groups.get(replace.newCommit);
        }
        for (UpdateGroupsRequest update : updateGroups) {
            update.groups = Sets.newHashSet(groups.get(update.commit));
        }
    } catch (OrmException e) {
        log.error("Error collecting groups for changes", e);
        reject(magicBranch.cmd, "internal server error");
        return;
    }
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, change.getProject(), user, change.getCreatedOn())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(ins.getChange().getId(), hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(ins.getChange().getId(), new BatchUpdate.Op() {

                    @Override
                    public void updateChange(ChangeContext ctx) throws Exception {
                        ctx.getUpdate(ps.getId()).setTopic(magicBranch.topic);
                    }
                });
            }
        }
        bu.execute();
    }
    created = true;
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, ResourceConflictException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#method_after
private void submit(ChangeControl changeCtl, PatchSet ps) throws OrmException, RestApiException {
    Submit submit = submitProvider.get();
    RevisionResource rsrc = new RevisionResource(changes.parse(changeCtl), ps);
    try (MergeOp op = mergeOpProvider.get()) {
        op.merge(db, rsrc.getChange(), changeCtl.getUser().asIdentifiedUser(), false);
    }
    addMessage("");
    Change c = db.changes().get(rsrc.getChange().getId());
    switch(c.getStatus()) {
        case MERGED:
            addMessage("Change " + c.getChangeId() + " merged.");
            break;
        case NEW:
            ChangeMessage msg = submit.getConflictMessage(rsrc);
            if (msg != null) {
                addMessage("Change " + c.getChangeId() + ": " + msg.getMessage());
                break;
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            addMessage("change " + c.getChangeId() + " is " + c.getStatus().name().toLowerCase());
    }
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName());
}
#end_block

#method_before
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, NoSuchChangeException, ResourceConflictException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#method_after
CheckedFuture<PatchSet.Id, RestApiException> insertPatchSet() throws IOException {
    rp.getRevWalk().parseBody(newCommit);
    final Thread caller = Thread.currentThread();
    ListenableFuture<PatchSet.Id> future = changeUpdateExector.submit(requestScopePropagator.wrap(new Callable<PatchSet.Id>() {

        @Override
        public PatchSet.Id call() throws OrmException, IOException, RestApiException {
            try {
                if (magicBranch != null && magicBranch.edit) {
                    return upsertEdit();
                } else if (caller == Thread.currentThread()) {
                    return insertPatchSet(db);
                } else {
                    try (ReviewDb db = schemaFactory.open()) {
                        return insertPatchSet(db);
                    }
                }
            } finally {
                synchronizedIncrement(replaceProgress);
            }
        }
    }));
    return Futures.makeChecked(future, INSERT_EXCEPTION);
}
#end_block

#method_before
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId());
    msg.setMessage(renderMessageWithApprovals(newPatchSet.getPatchSetId(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#method_after
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), createdOn, psId);
    msg.setMessage(renderMessageWithApprovals(psId.get(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, RestApiException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubject("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, RevCommit commit) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = db.changes().get(cid);
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    CurrentUser currentUser = user.get();
    if (!currentUser.isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    return byChange(change, currentUser.asIdentifiedUser());
}
#method_after
public Optional<ChangeEdit> byChange(Change change) throws AuthException, IOException {
    try {
        return byChange(changeControlFactory.controlFor(change, user.get()));
    } catch (NoSuchChangeException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
public Optional<ChangeEdit> byChange(Change change, IdentifiedUser user) throws IOException {
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(user.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.absent();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(change, ref);
            return Optional.of(new ChangeEdit(user, change, ref, commit, basePs));
        }
    }
}
#method_after
public Optional<ChangeEdit> byChange(ChangeControl ctl) throws AuthException, IOException {
    if (!ctl.getUser().isIdentifiedUser()) {
        throw new AuthException("Authentication required");
    }
    IdentifiedUser u = ctl.getUser().asIdentifiedUser();
    Change change = ctl.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject())) {
        int n = change.currentPatchSetId().get();
        String[] refNames = new String[n];
        for (int i = n; i > 0; i--) {
            refNames[i - 1] = RefNames.refsEdit(u.getAccountId(), change.getId(), new PatchSet.Id(change.getId(), i));
        }
        Ref ref = repo.getRefDatabase().firstExactRef(refNames);
        if (ref == null) {
            return Optional.absent();
        }
        try (RevWalk rw = new RevWalk(repo)) {
            RevCommit commit = rw.parseCommit(ref.getObjectId());
            PatchSet basePs = getBasePatchSet(ctl, ref);
            return Optional.of(new ChangeEdit(u, change, ref, commit, basePs));
        }
    }
}
#end_block

#method_before
private PatchSet getBasePatchSet(Change change, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return db.get().patchSets().get(new PatchSet.Id(change.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#method_after
private PatchSet getBasePatchSet(ChangeControl ctl, Ref ref) throws IOException {
    try {
        int pos = ref.getName().lastIndexOf("/");
        checkArgument(pos > 0, "invalid edit ref: %s", ref.getName());
        String psId = ref.getName().substring(pos + 1);
        return psUtil.get(db.get(), ctl.getNotes(), new PatchSet.Id(ctl.getId(), Integer.parseInt(psId)));
    } catch (OrmException | NumberFormatException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    if (Objects.equals(commit, currPsCommit)) {
        // Caller gave us latest patch set SHA-1; verified in checkPatchSets.
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change.getDest().get(), tip.name()));
            return;
        }
        RevId revId = new RevId(commit.name());
        List<PatchSet> patchSets = FluentIterable.from(db.get().patchSets().byRevision(revId)).filter(new Predicate<PatchSet>() {

            @Override
            public boolean apply(PatchSet ps) {
                try {
                    Change c = db.get().changes().get(ps.getId().getParentKey());
                    return c != null && c.getDest().equals(change.getDest());
                } catch (OrmException e) {
                    warn(e);
                    // Should cause an error below, that's good.
                    return true;
                }
            }
        }).toSortedList(ChangeUtil.PS_ID_ORDER);
        switch(patchSets.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change.getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change.getKey().get()));
                    return;
                }
                PatchSet.Id psId = insertPatchSet(commit);
                if (psId != null) {
                    checkMergedBitMatchesStatus(psId, commit, true);
                }
                break;
            case 1:
                // Existing patch set of this commit; check that it is the current
                // patch set.
                // TODO(dborowitz): This could be fixed if it's an older patch set of
                // the current change.
                PatchSet.Id id = patchSets.get(0).getId();
                if (!id.equals(change.currentPatchSetId())) {
                    problem(String.format("Expected merged commit %s corresponds to" + " patch set %s, which is not the current patch set %s", commit.name(), id, change.currentPatchSetId()));
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), patchSets));
                break;
        }
    } catch (OrmException | IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#method_after
private void checkExpectMergedAs() {
    ObjectId objId = parseObjectId(fix.expectMergedAs, "expected merged commit");
    RevCommit commit = parseCommit(objId, "expected merged commit");
    if (commit == null) {
        return;
    }
    if (Objects.equals(commit, currPsCommit)) {
        // Caller gave us latest patch set SHA-1; verified in checkPatchSets.
        return;
    }
    try {
        if (!rw.isMergedInto(commit, tip)) {
            problem(String.format("Expected merged commit %s is not merged into" + " destination ref %s (%s)", commit.name(), change.getDest().get(), tip.name()));
            return;
        }
        List<PatchSet.Id> psIds = new ArrayList<>();
        for (Ref ref : repo.getRefDatabase().getRefs(REFS_CHANGES).values()) {
            if (!ref.getObjectId().equals(commit)) {
                continue;
            }
            PatchSet.Id psId = PatchSet.Id.fromRef(ref.getName());
            if (psId == null) {
                continue;
            }
            try {
                Change c = db.get().changes().get(psId.getParentKey());
                if (c == null || !c.getDest().equals(change.getDest())) {
                    continue;
                }
            } catch (OrmException e) {
                warn(e);
            // Include this patch set; should cause an error below, which is good.
            }
            psIds.add(psId);
        }
        switch(psIds.size()) {
            case 0:
                // No patch set for this commit; insert one.
                rw.parseBody(commit);
                String changeId = Iterables.getFirst(commit.getFooterLines(FooterConstants.CHANGE_ID), null);
                // Missing Change-Id footer is ok, but mismatched is not.
                if (changeId != null && !changeId.equals(change.getKey().get())) {
                    problem(String.format("Expected merged commit %s has Change-Id: %s," + " but expected %s", commit.name(), changeId, change.getKey().get()));
                    return;
                }
                PatchSet.Id psId = insertPatchSet(commit);
                if (psId != null) {
                    checkMergedBitMatchesStatus(psId, commit, true);
                }
                break;
            case 1:
                // Existing patch set of this commit; check that it is the current
                // patch set.
                // TODO(dborowitz): This could be fixed if it's an older patch set of
                // the current change.
                PatchSet.Id id = psIds.get(0);
                if (!id.equals(change.currentPatchSetId())) {
                    problem(String.format("Expected merged commit %s corresponds to" + " patch set %s, which is not the current patch set %s", commit.name(), id, change.currentPatchSetId()));
                }
                break;
            default:
                problem(String.format("Multiple patch sets for expected merged commit %s: %s", commit.name(), intKeyOrdering().sortedCopy(psIds)));
                break;
        }
    } catch (IOException e) {
        error("Error looking up expected merged commit " + fix.expectMergedAs, e);
    }
}
#end_block

#method_before
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setUploader(user.get().getAccountId()).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#method_after
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#end_block

#method_before
private void deletePatchSet(ProblemInfo p, PatchSet.Id psId) {
    ReviewDb db = this.db.get();
    Change.Id cid = psId.getParentKey();
    try {
        db.changes().beginTransaction(cid);
        try {
            Change c = db.changes().get(cid);
            if (c == null) {
                throw new OrmException("Change missing: " + cid);
            }
            if (psId.equals(c.currentPatchSetId())) {
                List<PatchSet> all = Lists.newArrayList(db.patchSets().byChange(cid));
                if (all.size() == 1 && all.get(0).getId().equals(psId)) {
                    p.status = Status.FIX_FAILED;
                    p.outcome = "Cannot delete patch set; no patch sets would remain";
                    return;
                }
                // If there were multiple missing patch sets, assumes deletePatchSet
                // has been called in decreasing order, so the max remaining PatchSet
                // is the effective current patch set.
                Collections.sort(all, PS_ID_ORDER.reverse());
                PatchSet.Id latest = null;
                for (PatchSet ps : all) {
                    latest = ps.getId();
                    if (!ps.getId().equals(psId)) {
                        break;
                    }
                }
                c.setCurrentPatchSet(patchSetInfoFactory.get(db, latest));
                db.changes().update(Collections.singleton(c));
            }
            // Delete dangling primary key references. Don't delete ChangeMessages,
            // which don't use patch sets as a primary key, and may provide useful
            // historical information.
            db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(psId));
            db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
            db.patchComments().delete(db.patchComments().byPatchSet(psId));
            db.patchSets().deleteKeys(Collections.singleton(psId));
            db.commit();
            p.status = Status.FIXED;
            p.outcome = "Deleted patch set";
        } finally {
            db.rollback();
        }
    } catch (PatchSetInfoNotAvailableException | OrmException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + ' ' + psId, e);
        p.status = Status.FIX_FAILED;
        p.outcome = msg;
    }
}
#method_after
private void deletePatchSet(ProblemInfo p, PatchSet.Id psId) {
    ReviewDb db = this.db.get();
    Change.Id cid = psId.getParentKey();
    try {
        db.changes().beginTransaction(cid);
        try {
            Change c = db.changes().get(cid);
            if (c == null) {
                throw new OrmException("Change missing: " + cid);
            }
            ChangeNotes notes = notesFactory.create(c);
            if (psId.equals(c.currentPatchSetId())) {
                List<PatchSet> all = Lists.newArrayList(db.patchSets().byChange(cid));
                if (all.size() == 1 && all.get(0).getId().equals(psId)) {
                    p.status = Status.FIX_FAILED;
                    p.outcome = "Cannot delete patch set; no patch sets would remain";
                    return;
                }
                // If there were multiple missing patch sets, assumes deletePatchSet
                // has been called in decreasing order, so the max remaining PatchSet
                // is the effective current patch set.
                Collections.sort(all, PS_ID_ORDER.reverse());
                PatchSet.Id latest = null;
                for (PatchSet ps : all) {
                    latest = ps.getId();
                    if (!ps.getId().equals(psId)) {
                        break;
                    }
                }
                c.setCurrentPatchSet(patchSetInfoFactory.get(db, notes, latest));
                db.changes().update(Collections.singleton(c));
            }
            // Delete dangling primary key references. Don't delete ChangeMessages,
            // which don't use patch sets as a primary key, and may provide useful
            // historical information.
            db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(psId));
            db.patchSetApprovals().delete(db.patchSetApprovals().byPatchSet(psId));
            db.patchComments().delete(db.patchComments().byPatchSet(psId));
            db.patchSets().deleteKeys(Collections.singleton(psId));
            db.commit();
            p.status = Status.FIXED;
            p.outcome = "Deleted patch set";
        } finally {
            db.rollback();
        }
    } catch (PatchSetInfoNotAvailableException | OrmException e) {
        String msg = "Error deleting patch set";
        log.warn(msg + ' ' + psId, e);
        p.status = Status.FIX_FAILED;
        p.outcome = msg;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = control.getUser().asIdentifiedUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    try (MergeOp op = mergeOpProvider.get()) {
        ReviewDb db = dbProvider.get();
        op.merge(db, change, caller, true);
        change = db.changes().get(change.getId());
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        case ABANDONED:
        case DRAFT:
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource rsrc, SubmitInput input) throws RestApiException, RepositoryNotFoundException, IOException, OrmException {
    PatchSet ps = dbProvider.get().patchSets().get(rsrc.getChange().currentPatchSetId());
    if (ps == null) {
        throw new ResourceConflictException("current revision is missing");
    } else if (!rsrc.getControl().isPatchVisible(ps, dbProvider.get())) {
        throw new AuthException("current revision not accessible");
    }
    Output out = submit.apply(new RevisionResource(rsrc, ps), input);
    return json.create(ChangeJson.NO_OPTIONS).format(out.change);
}
#end_block

#method_before
private List<RevisionResource> find(ChangeResource change, String id) throws OrmException, IOException, AuthException {
    if (id.equals("0")) {
        return loadEdit(change, null);
    } else if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) {
        // Legacy patch set number syntax.
        return byLegacyPatchSetId(change, id);
    } else if (id.length() < 4 || id.length() > RevId.LEN) {
        // Impossibly long identifier will never match.
        return Collections.emptyList();
    } else {
        List<RevisionResource> out = Lists.newArrayList();
        for (PatchSet ps : dbProvider.get().patchSets().byChange(change.getId())) {
            if (ps.getRevision() != null && ps.getRevision().get().startsWith(id)) {
                out.add(new RevisionResource(change, ps));
            }
        }
        return out.isEmpty() ? loadEdit(change, new RevId(id)) : out;
    }
}
#method_after
private List<RevisionResource> find(ChangeResource change, String id) throws OrmException, IOException, AuthException {
    if (id.equals("0")) {
        return loadEdit(change, null);
    } else if (id.length() < 6 && id.matches("^[1-9][0-9]{0,4}$")) {
        // Legacy patch set number syntax.
        return byLegacyPatchSetId(change, id);
    } else if (id.length() < 4 || id.length() > RevId.LEN) {
        // Impossibly long identifier will never match.
        return Collections.emptyList();
    } else {
        List<RevisionResource> out = Lists.newArrayList();
        for (PatchSet ps : dbProvider.get().patchSets().byChange(change.getId())) {
            if (ps.getRevision() != null && ps.getRevision().get().startsWith(id)) {
                out.add(new RevisionResource(change, ps));
            }
        }
        // Not an existing patch set on a change, but might be an edit.
        if (out.isEmpty() && id.length() == RevId.LEN) {
            return loadEdit(change, new RevId(id));
        }
        return out;
    }
}
#end_block

#method_before
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubject("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(RequestState state) throws OrmException, IOException, RestApiException {
    ReviewDb db = state.db;
    Repository repo = state.repo;
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubjectForCommit("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    sendEmailExecutor.submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private RequestState requestState(Thread caller) throws RepositoryNotFoundException, OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk(), false);
    }
    @SuppressWarnings("resource")
    Repository localRepo = repoManager.openRepository(project.getNameKey());
    ReviewDb db;
    try {
        db = schemaFactory.open();
    } catch (OrmException e) {
        localRepo.close();
        throw e;
    }
    return new RequestState(db, localRepo, new RevWalk(localRepo), true);
}
#method_after
private RequestState requestState(Thread caller) throws OrmException, IOException {
    if (caller == Thread.currentThread()) {
        return new RequestState(db, repo, rp.getRevWalk());
    } else {
        return new RequestState(project.getNameKey());
    }
}
#end_block

#method_before
@Override
public void onHeadUpdated(HeadUpdatedListener.Event event) {
    for (URIish uri : getURIs(new Project.NameKey(event.getProjectName()), FilterType.ALL)) {
        updateHead(uri, event.getNewHeadName());
    }
}
#method_after
@Override
public void onHeadUpdated(HeadUpdatedListener.Event event) {
    updateHead(new Project.NameKey(event.getProjectName()), event.getNewHeadName());
}
#end_block

#method_before
void updateHead(URIish replicateURI, String newHead) {
    if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#method_after
void updateHead(Project.NameKey project, String newHeadName) {
    for (URIish uri : getURIs(project, FilterType.ALL)) {
        updateHead(uri, newHeadName);
    }
}
#end_block

#method_before
void updateHead(URIish replicateURI, String newHead) {
    if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#method_after
private void updateHead(URIish replicateURI, String newHead) {
    if (!replicateURI.isRemote()) {
        updateHeadLocally(replicateURI, newHead);
    } else if (isSSH(replicateURI)) {
        updateHeadRemoteSsh(replicateURI, newHead);
    } else {
        repLog.warn(String.format("Cannot update HEAD of project on remote site %s." + " Only local paths and SSH URLs are supported" + " for remote HEAD update.", replicateURI));
    }
}
#end_block

#method_before
private void updateHead() throws IOException {
    replicationQueue.updateHead(uri, git.getRef(Constants.HEAD).getTarget().getName());
}
#method_after
private void updateHead() throws IOException {
    replicationQueue.updateHead(projectName, git.getRef(Constants.HEAD).getTarget().getName());
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<PatchLineComment> maybeComment = plcUtil.get(ctx.getDb(), ctx.getNotes(), key);
    if (!maybeComment.isPresent()) {
        // because the input might be missing required fields. Just give up.
        throw new ResourceNotFoundException("comment not found: " + key);
    }
    comment = maybeComment.get();
    PatchSet.Id psId = comment.getKey().getParentKey().getParentKey();
    ChangeUpdate update = ctx.getUpdate(psId);
    PatchSet ps = ctx.getDb().patchSets().get(psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    if (in.path != null && !in.path.equals(comment.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        plcUtil.deleteComments(ctx.getDb(), update, Collections.singleton(comment));
        comment = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, in.path), comment.getKey().get()), comment.getLine(), ctx.getUser().getAccountId(), comment.getParentUuid(), ctx.getWhen());
        setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
        plcUtil.insertComments(ctx.getDb(), update, Collections.singleton(update(comment, in)));
    } else {
        if (comment.getRevId() == null) {
            setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
        }
        plcUtil.updateComments(ctx.getDb(), update, Collections.singleton(update(comment, in)));
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<PatchLineComment> maybeComment = plcUtil.get(ctx.getDb(), ctx.getNotes(), key);
    if (!maybeComment.isPresent()) {
        // because the input might be missing required fields. Just give up.
        throw new ResourceNotFoundException("comment not found: " + key);
    }
    comment = maybeComment.get();
    PatchSet.Id psId = comment.getKey().getParentKey().getParentKey();
    ChangeUpdate update = ctx.getUpdate(psId);
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    if (in.path != null && !in.path.equals(comment.getKey().getParentKey().getFileName())) {
        // Updating the path alters the primary key, which isn't possible.
        // Delete then recreate the comment instead of an update.
        plcUtil.deleteComments(ctx.getDb(), update, Collections.singleton(comment));
        comment = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(psId, in.path), comment.getKey().get()), comment.getLine(), ctx.getUser().getAccountId(), comment.getParentUuid(), ctx.getWhen());
        setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
        plcUtil.insertComments(ctx.getDb(), update, Collections.singleton(update(comment, in)));
    } else {
        if (comment.getRevId() == null) {
            setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
        }
        plcUtil.updateComments(ctx.getDb(), update, Collections.singleton(update(comment, in)));
    }
    return true;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, toMerge)) {
        toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
        mergeTip.moveTipTo(toMerge, toMerge);
        acceptMergeTip(mergeTip);
        return;
    }
    rebaseOp = args.rebaseFactory.create(toMerge.getControl(), // Racy read of patch set is ok; see comments in RebaseChangeOp.
    args.db.patchSets().get(toMerge.getPatchsetId()), mergeTip.getCurrentTip().name()).setRunHooks(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try {
        rebaseOp.updateRepo(ctx);
    } catch (MergeConflictException e) {
        toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
        throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, toMerge)) {
        toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
        mergeTip.moveTipTo(toMerge, toMerge);
        acceptMergeTip(mergeTip);
        return;
    }
    // Stale read of patch set is ok; see comments in RebaseChangeOp.
    PatchSet origPs = args.psUtil.get(ctx.getDb(), toMerge.getControl().getNotes(), toMerge.getPatchsetId());
    rebaseOp = args.rebaseFactory.create(toMerge.getControl(), origPs, mergeTip.getCurrentTip().name()).setRunHooks(false).setCopyApprovals(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try {
        rebaseOp.updateRepo(ctx);
    } catch (MergeConflictException e) {
        toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
        throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
    }
    newCommit = args.rw.parseCommit(rebaseOp.getRebasedCommit());
    newCommit.copyFrom(toMerge);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    newCommit.setPatchsetId(rebaseOp.getPatchSetId());
    mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(mergeTip.getCurrentTip());
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    if (rebaseOp == null) {
        // Took the fast-forward option, nothing to do.
        return false;
    }
    rebaseOp.updateChange(ctx);
    PatchSet newPatchSet = rebaseOp.getPatchSet();
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(ctx.getDb(), toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
    }
    args.db.patchSetApprovals().insert(approvals);
    // TODO(dborowitz): Make RevWalk available via BatchUpdate.
    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
    mergeTip.moveTipTo(newTip, newTip);
    toMerge.change().setCurrentPatchSet(args.patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
    mergeTip.getCurrentTip().copyFrom(toMerge);
    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.commits.put(mergeTip.getCurrentTip());
    acceptMergeTip(mergeTip);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    if (rebaseOp == null) {
        // Took the fast-forward option, nothing to do.
        return false;
    }
    rebaseOp.updateChange(ctx);
    PatchSet.Id newPatchSetId = rebaseOp.getPatchSetId();
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(ctx.getDb(), toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(newPatchSetId, a));
    }
    args.db.patchSetApprovals().insert(approvals);
    toMerge.change().setCurrentPatchSet(args.patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSetId));
    newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    return true;
}
#end_block

#method_before
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet ps = ins.setGroups(groups).getPatchSet();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, ps, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(ps.getPatchSetId(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(ps.getId()).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ps);
    }
}
#method_after
private void insertChange(ReviewDb threadLocalDb) throws OrmException, RestApiException, UpdateException {
    final PatchSet.Id psId = ins.setGroups(groups).getPatchSetId();
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = commit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
    }
    recipients.add(getRecipientsFromFooters(accountResolver, magicBranch.draft, footerLines));
    recipients.remove(me);
    String msg = renderMessageWithApprovals(psId.get(), null, approvals, Collections.<String, PatchSetApproval>emptyMap());
    try (ObjectInserter oi = repo.newObjectInserter();
        BatchUpdate bu = batchUpdateFactory.create(threadLocalDb, magicBranch.dest.getParentKey(), user, TimeUtil.nowTs())) {
        bu.setRepository(repo, rp.getRevWalk(), oi);
        bu.insertChange(ins.setReviewers(recipients.getReviewers()).setExtraCC(recipients.getCcOnly()).setApprovals(approvals).setMessage(msg).setRequestScopePropagator(requestScopePropagator).setSendMail(true).setUpdateRef(false));
        if (magicBranch != null) {
            bu.addOp(changeId, hashtagsFactory.create(new HashtagsInput(magicBranch.hashtags)).setRunHooks(false));
            if (!Strings.isNullOrEmpty(magicBranch.topic)) {
                bu.addOp(changeId, new BatchUpdate.Op() {

                    @Override
                    public boolean updateChange(ChangeContext ctx) {
                        ctx.getUpdate(psId).setTopic(magicBranch.topic);
                        return true;
                    }
                });
            }
        }
        bu.execute();
    }
    change = ins.getChange();
    if (magicBranch != null && magicBranch.submit) {
        submit(projectControl.controlFor(change), ins.getPatchSet());
    }
}
#end_block

#method_before
private boolean newEdit() {
    newPatchSet = new PatchSet(change.currentPatchSetId());
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(change, user);
    } catch (IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(newPatchSet.getId())) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#method_after
private boolean newEdit() {
    psId = change.currentPatchSetId();
    Optional<ChangeEdit> edit = null;
    try {
        edit = editUtil.byChange(changeCtl);
    } catch (AuthException | IOException e) {
        log.error("Cannt retrieve edit", e);
        return false;
    }
    if (edit.isPresent()) {
        if (edit.get().getBasePatchSet().getId().equals(psId)) {
            // replace edit
            cmd = new ReceiveCommand(edit.get().getRef().getObjectId(), newCommit, edit.get().getRefName());
        } else {
            // delete old edit ref on rebase
            prev = new ReceiveCommand(edit.get().getRef().getObjectId(), ObjectId.zeroId(), edit.get().getRefName());
            createEditCommand();
        }
    } else {
        createEditCommand();
    }
    return true;
}
#end_block

#method_before
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), newPatchSet.getId()));
}
#method_after
private void createEditCommand() {
    // create new edit
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, RefNames.refsEdit(user.getAccountId(), change.getId(), psId));
}
#end_block

#method_before
private void newPatchSet() throws IOException {
    PatchSet.Id id = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    newPatchSet = new PatchSet(id);
    newPatchSet.setCreatedOn(TimeUtil.nowTs());
    newPatchSet.setUploader(user.getAccountId());
    newPatchSet.setRevision(toRevId(newCommit));
    newPatchSet.setGroups(groups);
    if (rp.getPushCertificate() != null) {
        newPatchSet.setPushCertificate(rp.getPushCertificate().toTextWithSignature());
    }
    if (magicBranch != null && magicBranch.draft) {
        newPatchSet.setDraft(true);
    }
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, newPatchSet.getId());
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, newPatchSet.getRefName());
}
#method_after
private void newPatchSet() throws IOException {
    psId = ChangeUtil.nextPatchSetId(allRefs, change.currentPatchSetId());
    info = patchSetInfoFactory.get(rp.getRevWalk(), newCommit, psId);
    cmd = new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName());
}
#end_block

#method_before
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), newPatchSet.getCreatedOn(), newPatchSet.getId());
    msg.setMessage(renderMessageWithApprovals(newPatchSet.getPatchSetId(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#method_after
private ChangeMessage newChangeMessage(ReviewDb db, ChangeKind changeKind, Map<String, Short> approvals) throws OrmException {
    msg = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), createdOn, psId);
    msg.setMessage(renderMessageWithApprovals(psId.get(), changeKindMessage(changeKind), approvals, scanLabels(db, approvals)));
    return msg;
}
#end_block

#method_before
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id upsertEdit() {
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    return psId;
}
#end_block

#method_before
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, newPatchSet.getCreatedOn());
    update.setSubject("Create patch set " + newPatchSet.getId().get());
    update.setPatchSetId(newPatchSet.getId());
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    recipients.add(getRecipientsFromFooters(accountResolver, newPatchSet, footerLines));
    recipients.remove(me);
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        if (newPatchSet.getGroups() == null) {
            newPatchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
        }
        db.patchSets().insert(Collections.singleton(newPatchSet));
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, this, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(ReplaceRequest.this);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#method_after
PatchSet.Id insertPatchSet(ReviewDb db) throws OrmException, IOException, ResourceConflictException {
    final Account.Id me = user.getAccountId();
    final List<FooterLine> footerLines = newCommit.getFooterLines();
    final MailRecipients recipients = new MailRecipients();
    final PatchSet newPatchSet;
    Map<String, Short> approvals = new HashMap<>();
    ChangeUpdate update = updateFactory.create(changeCtl, createdOn);
    update.setSubject("Create patch set " + psId.get());
    update.setPatchSetId(psId);
    if (magicBranch != null) {
        recipients.add(magicBranch.getMailRecipients());
        approvals = magicBranch.labels;
        Set<String> hashtags = magicBranch.hashtags;
        ChangeNotes notes = changeCtl.getNotes().load();
        if (!hashtags.isEmpty()) {
            hashtags.addAll(notes.getHashtags());
            update.setHashtags(hashtags);
        }
        if (magicBranch.topic != null && !magicBranch.topic.equals(notes.getChange().getTopic())) {
            update.setTopic(magicBranch.topic);
        }
    }
    db.changes().beginTransaction(change.getId());
    ChangeKind changeKind = ChangeKind.REWORK;
    try {
        change = db.changes().get(change.getId());
        if (change == null || change.getStatus().isClosed()) {
            reject(inputCommand, "change is closed");
            return null;
        }
        Iterable<String> newGroups = groups;
        if (newGroups == null) {
            PatchSet prevPs = psUtil.current(db, update.getChangeNotes());
            newGroups = prevPs != null ? prevPs.getGroups() : null;
        }
        boolean draft = magicBranch != null && magicBranch.draft;
        newPatchSet = psUtil.insert(db, update, psId, newCommit, draft, newGroups, rp.getPushCertificate() != null ? rp.getPushCertificate().toTextWithSignature() : null);
        if (checkMergedInto) {
            final Ref mergedInto = findMergedInto(change.getDest().get(), newCommit);
            mergedIntoRef = mergedInto != null ? mergedInto.getName() : null;
        }
        recipients.add(getRecipientsFromFooters(accountResolver, draft, footerLines));
        recipients.remove(me);
        ChangeData cd = changeDataFactory.create(db, changeCtl);
        MailRecipients oldRecipients = getRecipientsFromReviewers(cd.reviewers());
        approvalCopier.copy(db, changeCtl, newPatchSet);
        approvalsUtil.addReviewers(db, update, labelTypes, change, newPatchSet, info, recipients.getReviewers(), oldRecipients.getAll());
        approvalsUtil.addApprovals(db, update, labelTypes, newPatchSet, changeCtl, approvals);
        recipients.add(oldRecipients);
        RevCommit priorCommit = revisions.inverse().get(priorPatchSet);
        changeKind = changeKindCache.getChangeKind(projectControl.getProjectState(), repo, priorCommit, newCommit);
        cmUtil.addChangeMessage(db, update, newChangeMessage(db, changeKind, approvals));
        if (mergedIntoRef == null) {
            // Change should be new, so it can go through review again.
            // 
            change = db.changes().atomicUpdate(change.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change change) {
                    if (change.getStatus().isClosed()) {
                        return null;
                    }
                    if (!change.currentPatchSetId().equals(priorPatchSet)) {
                        return change;
                    }
                    if (magicBranch != null && magicBranch.topic != null) {
                        change.setTopic(magicBranch.topic);
                    }
                    if (change.getStatus() == Change.Status.DRAFT && newPatchSet.isDraft()) {
                    // Leave in draft status.
                    } else {
                        change.setStatus(Change.Status.NEW);
                    }
                    change.setCurrentPatchSet(info);
                    final List<String> idList = newCommit.getFooterLines(CHANGE_ID);
                    if (idList.isEmpty()) {
                        change.setKey(new Change.Key("I" + newCommit.name()));
                    } else {
                        change.setKey(new Change.Key(idList.get(idList.size() - 1).trim()));
                    }
                    ChangeUtil.updated(change);
                    return change;
                }
            });
            if (change == null) {
                db.patchSets().delete(Collections.singleton(newPatchSet));
                db.changeMessages().delete(Collections.singleton(msg));
                reject(inputCommand, "change is closed");
                return null;
            }
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (mergedIntoRef != null) {
        // Change was already submitted to a branch, close it.
        // 
        markChangeMergedByPush(db, info, mergedIntoRef, changeCtl);
    }
    if (cmd.getResult() == NOT_ATTEMPTED) {
        cmd.execute(rp);
    }
    indexer.index(db, change);
    if (changeKind != ChangeKind.TRIVIAL_REBASE) {
        workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

            @Override
            public void run() {
                try {
                    ReplacePatchSetSender cm = replacePatchSetFactory.create(change.getId());
                    cm.setFrom(me);
                    cm.setPatchSet(newPatchSet, info);
                    cm.setChangeMessage(msg);
                    cm.addReviewers(recipients.getReviewers());
                    cm.addExtraCC(recipients.getCcOnly());
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new patch set " + newPatchSet.getId(), e);
                }
                if (mergedIntoRef != null) {
                    sendMergedEmail(newPatchSet, info);
                }
            }

            @Override
            public String toString() {
                return "send-email newpatchset";
            }
        }));
    }
    gitRefUpdated.fire(project.getNameKey(), newPatchSet.getRefName(), ObjectId.zeroId(), newCommit);
    hooks.doPatchsetCreatedHook(change, newPatchSet, db);
    if (mergedIntoRef != null) {
        hooks.doChangeMergedHook(change, user.getAccount(), newPatchSet, db, newCommit.getName());
    }
    if (!approvals.isEmpty()) {
        hooks.doCommentAddedHook(change, user.getAccount(), newPatchSet, null, approvals, db);
    }
    if (magicBranch != null && magicBranch.submit) {
        submit(changeCtl, newPatchSet);
    }
    return newPatchSet.getId();
}
#end_block

#method_before
private Change.Key closeChange(final ReceiveCommand cmd, final PatchSet.Id psi, final RevCommit commit) throws OrmException, IOException {
    final String refName = cmd.getRefName();
    final Change.Id cid = psi.getParentKey();
    final Change change = db.changes().get(cid);
    final PatchSet ps = db.patchSets().get(psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    ReplaceRequest result = new ReplaceRequest(cid, commit, cmd, false);
    result.change = change;
    result.changeCtl = projectControl.controlFor(change);
    result.newPatchSet = ps;
    result.info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    result.mergedIntoRef = refName;
    markChangeMergedByPush(db, result, result.changeCtl);
    hooks.doChangeMergedHook(change, user.getAccount(), result.newPatchSet, db, commit.getName());
    sendMergedEmail(result);
    return change.getKey();
}
#method_after
private Change.Key closeChange(ReceiveCommand cmd, PatchSet.Id psi, RevCommit commit) throws OrmException, IOException {
    String refName = cmd.getRefName();
    Change.Id cid = psi.getParentKey();
    Change change = db.changes().get(cid);
    ChangeControl ctl = projectControl.controlFor(change);
    PatchSet ps = psUtil.get(db, ctl.getNotes(), psi);
    if (change == null || ps == null) {
        log.warn(project.getName() + " " + psi + " is missing");
        return null;
    }
    if (change.getStatus() == Change.Status.MERGED || change.getStatus() == Change.Status.ABANDONED || !change.getDest().get().equals(refName)) {
        // 
        return null;
    }
    PatchSetInfo info = patchSetInfoFactory.get(rp.getRevWalk(), commit, psi);
    markChangeMergedByPush(db, info, refName, ctl);
    hooks.doChangeMergedHook(change, user.getAccount(), ps, db, commit.getName());
    sendMergedEmail(ps, info);
    return change.getKey();
}
#end_block

#method_before
private void markChangeMergedByPush(ReviewDb db, final ReplaceRequest result, ChangeControl control) throws OrmException, IOException {
    Change.Id id = result.change.getId();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(result.info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        String mergedIntoRef = result.mergedIntoRef;
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), result.info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#method_after
private void markChangeMergedByPush(ReviewDb db, final PatchSetInfo info, String mergedIntoRef, ChangeControl control) throws OrmException, IOException {
    Change.Id id = info.getKey().getParentKey();
    db.changes().beginTransaction(id);
    Change change;
    ChangeUpdate update;
    try {
        change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

            @Override
            public Change update(Change change) {
                if (change.getStatus().isOpen()) {
                    change.setCurrentPatchSet(info);
                    change.setStatus(Change.Status.MERGED);
                    ChangeUtil.updated(change);
                }
                return change;
            }
        });
        StringBuilder msgBuf = new StringBuilder();
        msgBuf.append("Change has been successfully pushed");
        if (!mergedIntoRef.equals(change.getDest().get())) {
            msgBuf.append(" into ");
            if (mergedIntoRef.startsWith(Constants.R_HEADS)) {
                msgBuf.append("branch ");
                msgBuf.append(Repository.shortenRefName(mergedIntoRef));
            } else {
                msgBuf.append(mergedIntoRef);
            }
        }
        msgBuf.append(".");
        ChangeMessage msg = new ChangeMessage(new ChangeMessage.Key(id, ChangeUtil.messageUUID(db)), user.getAccountId(), change.getLastUpdatedOn(), info.getKey());
        msg.setMessage(msgBuf.toString());
        update = updateFactory.create(control, change.getLastUpdatedOn());
        cmUtil.addChangeMessage(db, update, msg);
        db.commit();
    } finally {
        db.rollback();
    }
    indexer.index(db, change);
    update.commit();
}
#end_block

#method_before
private void sendMergedEmail(final ReplaceRequest result) {
    final Change.Id id = result.change.getId();
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                final MergedSender cm = mergedSenderFactory.create(id);
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(result.newPatchSet, result.info);
                cm.send();
            } catch (Exception e) {
                final PatchSet.Id psi = result.newPatchSet.getId();
                log.error("Cannot send email for submitted patch set " + psi, e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final PatchSet ps, final PatchSetInfo info) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            try {
                MergedSender cm = mergedSenderFactory.create(ps.getId().getParentKey());
                cm.setFrom(user.getAccountId());
                cm.setPatchSet(ps, info);
                cm.send();
            } catch (Exception e) {
                log.error("Cannot send email for submitted patch set " + ps.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<PatchLineComment> maybeComment = plcUtil.get(ctx.getDb(), ctx.getNotes(), key);
    if (!maybeComment.isPresent()) {
        // Nothing to do.
        return false;
    }
    PatchSet.Id psId = key.getParentKey().getParentKey();
    PatchSet ps = ctx.getDb().patchSets().get(psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    PatchLineComment c = maybeComment.get();
    setCommentRevId(c, patchListCache, ctx.getChange(), ps);
    plcUtil.deleteComments(ctx.getDb(), ctx.getUpdate(psId), Collections.singleton(c));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    Optional<PatchLineComment> maybeComment = plcUtil.get(ctx.getDb(), ctx.getNotes(), key);
    if (!maybeComment.isPresent()) {
        // Nothing to do.
        return false;
    }
    PatchSet.Id psId = key.getParentKey().getParentKey();
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    PatchLineComment c = maybeComment.get();
    setCommentRevId(c, patchListCache, ctx.getChange(), ps);
    plcUtil.deleteComments(ctx.getDb(), ctx.getUpdate(psId), Collections.singleton(c));
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    ReviewDb db = ctx.getDb();
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ctx.getDb().patchSets().byChange(id).toList();
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(ps.getId()));
    }
    // No need to delete from notedb; draft patch sets will be filtered out.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(patchSets);
    db.changeMessages().delete(db.changeMessages().byChange(id));
    starredChangesUtil.unstarAll(id);
    ctx.deleteChange();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException {
    checkState(ctx.getOrder() == BatchUpdate.Order.DB_BEFORE_REPO, "must use DeleteDraftChangeOp with DB_BEFORE_REPO");
    checkState(id == null, "cannot reuse DeleteDraftChangeOp");
    Change change = ctx.getChange();
    id = change.getId();
    ReviewDb db = ctx.getDb();
    if (change.getStatus() != Change.Status.DRAFT) {
        throw new ResourceConflictException("Change is not a draft: " + id);
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft change");
    }
    List<PatchSet> patchSets = ImmutableList.copyOf(psUtil.byChange(ctx.getDb(), ctx.getNotes()));
    for (PatchSet ps : patchSets) {
        if (!ps.isDraft()) {
            throw new ResourceConflictException("Cannot delete draft change " + id + ": patch set " + ps.getPatchSetId() + " is not a draft");
        }
        db.accountPatchReviews().delete(db.accountPatchReviews().byPatchSet(ps.getId()));
    }
    // No need to delete from notedb; draft patch sets will be filtered out.
    db.patchComments().delete(db.patchComments().byChange(id));
    db.patchSetApprovals().delete(db.patchSetApprovals().byChange(id));
    db.patchSets().delete(patchSets);
    db.changeMessages().delete(db.changeMessages().byChange(id));
    starredChangesUtil.unstarAll(id);
    ctx.deleteChange();
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubject("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ChangeUtil.updated(change);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    ChangeControl ctl = ctx.getControl();
    change = ctx.getChange();
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubject("Create patch set " + psId.get());
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        PatchSet prevPs = psUtil.current(ctx.getDb(), ctx.getNotes());
        newGroups = prevPs != null ? prevPs.getGroups() : null;
    }
    patchSet = psUtil.insert(ctx.getDb(), ctx.getUpdate(psId), psId, commit, draft, newGroups, null);
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
        change.setStatus(Change.Status.NEW);
    }
    change.setCurrentPatchSet(patchSetInfo);
    ChangeUtil.updated(change);
    ctx.saveChange();
    if (copyApprovals) {
        approvalCopier.copy(db, ctl, patchSet);
    }
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(psId);
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.saveChange();
    update.setStatus(change.getStatus());
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.saveChange();
    update.setStatus(change.getStatus());
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getUser().getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(ctx.getUser().getAccountId());
    return change;
}
#method_after
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getUser().getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    return change;
}
#end_block

#method_before
public ChangeInserter setStatus(Change.Status status) {
    checkState(change == null, "setStatus(Change.Status) only valid before creating change");
    this.status = status;
    if (Change.Status.DRAFT.equals(status)) {
        patchSet.setDraft(true);
    }
    return this;
}
#method_after
public ChangeInserter setStatus(Change.Status status) {
    checkState(change == null, "setStatus(Change.Status) only valid before creating change");
    this.status = status;
    return this;
}
#end_block

#method_before
public ChangeInserter setGroups(Iterable<String> groups) {
    patchSet.setGroups(groups);
    return this;
}
#method_after
public ChangeInserter setGroups(Iterable<String> groups) {
    checkState(patchSet == null, "setGroups(Iterable<String>) only valid before creating change");
    this.groups = groups;
    return this;
}
#end_block

#method_before
public PatchSet getPatchSet() {
    return patchSet;
}
#method_after
public PatchSet getPatchSet() {
    checkState(patchSet != null, "getPatchSet() only valid after creating change");
    return patchSet;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, patchSet.getRefName()));
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws ResourceConflictException, IOException {
    validate(ctx);
    if (!updateRef) {
        return;
    }
    ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), commit, psId.toRefName()));
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(patchSet.getId());
    update.setSubject("Create change");
    update.setTopic(change.getTopic());
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    ctx.saveChange();
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getControl();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    ChangeUpdate update = ctx.getUpdate(psId);
    update.setSubject("Create change");
    update.setTopic(change.getTopic());
    boolean draft = status == Change.Status.DRAFT;
    Iterable<String> newGroups = groups;
    if (newGroups == null) {
        newGroups = GroupCollector.getDefaultGroups(commit);
    }
    patchSet = psUtil.insert(ctx.getDb(), update, psId, commit, draft, newGroups, null);
    ctx.saveChange();
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ctx.getUser().getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
    return true;
}
#end_block

#method_before
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
        String refName = patchSet.getId().toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getUser().asIdentifiedUser());
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
private void validate(RepoContext ctx) throws IOException, ResourceConflictException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    try {
        RefControl refControl = projectControlFactory.controlFor(ctx.getProject(), ctx.getUser()).controlForRef(refName);
        CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), ctx.getRepository());
        String refName = psId.toRefName();
        CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), change.getDest().get(), commit, ctx.getUser().asIdentifiedUser());
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(ctx.getRepository(), ctx.getRevWalk());
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new ResourceConflictException(e.getFullMessage());
    } catch (NoSuchProjectException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw);
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
        patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IOException {
    // If there is only one parent, a cherry-pick can be done by taking the
    // delta relative to that one parent and redoing that on the current merge
    // tip.
    args.rw.parseBody(toMerge);
    psId = ChangeUtil.nextPatchSetId(args.repo, toMerge.change().currentPatchSetId());
    String cherryPickCmtMsg = args.mergeUtil.createCherryPickCommitMessage(toMerge);
    PersonIdent committer = args.caller.newCommitterIdent(ctx.getWhen(), args.serverIdent.getTimeZone());
    try {
        newCommit = args.mergeUtil.createCherryPickFromCommit(args.repo, args.inserter, mergeTip.getCurrentTip(), toMerge, committer, cherryPickCmtMsg, args.rw);
        newCommit.copyFrom(toMerge);
        newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
        mergeTip.moveTipTo(newCommit, newCommit);
        args.commits.put(newCommit);
        ctx.addRefUpdate(new ReceiveCommand(ObjectId.zeroId(), newCommit, psId.toRefName()));
        patchSetInfo = args.patchSetInfoFactory.get(ctx.getRevWalk(), newCommit, psId);
    } catch (MergeConflictException mce) {
        // Keep going in the case of a single merge failure; the goal is to
        // cherry-pick as many commits as possible.
        toMerge.setStatusCode(CommitMergeStatus.PATH_CONFLICT);
    } catch (MergeIdenticalTreeException mie) {
        toMerge.setStatusCode(CommitMergeStatus.ALREADY_MERGED);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, NoSuchChangeException {
    if (newCommit == null) {
        // Merge conflict; don't update change.
        return false;
    }
    PatchSet ps = new PatchSet(psId);
    ps.setCreatedOn(ctx.getWhen());
    ps.setUploader(args.caller.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    Change c = toMerge.change();
    ps.setGroups(GroupCollector.getCurrentGroups(args.db, c));
    args.db.patchSets().insert(Collections.singleton(ps));
    c.setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
        ctx.getUpdate(psId).putApproval(a.getLabel(), a.getValue());
    }
    args.db.patchSetApprovals().insert(approvals);
    newCommit.copyFrom(toMerge);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(newCommit);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, NoSuchChangeException {
    if (newCommit == null) {
        // Merge conflict; don't update change.
        return false;
    }
    PatchSet prevPs = args.psUtil.current(ctx.getDb(), ctx.getNotes());
    args.psUtil.insert(ctx.getDb(), ctx.getUpdate(psId), psId, newCommit, false, prevPs != null ? prevPs.getGroups() : null, null);
    toMerge.change().setCurrentPatchSet(patchSetInfo);
    ctx.saveChange();
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(psId, a));
        ctx.getUpdate(psId).putApproval(a.getLabel(), a.getValue());
    }
    args.db.patchSetApprovals().insert(approvals);
    newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    PatchSet ps = ctx.getDb().patchSets().get(psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.endLine : 0;
    comment = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(ps.getId(), in.path), ChangeUtil.messageUUID(ctx.getDb())), line, ctx.getUser().getAccountId(), Url.decode(in.inReplyTo), ctx.getWhen());
    comment.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    comment.setMessage(in.message.trim());
    comment.setRange(in.range);
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    plcUtil.insertComments(ctx.getDb(), ctx.getUpdate(psId), Collections.singleton(comment));
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws ResourceNotFoundException, OrmException {
    PatchSet ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (ps == null) {
        throw new ResourceNotFoundException("patch set not found: " + psId);
    }
    int line = in.line != null ? in.line : in.range != null ? in.range.endLine : 0;
    comment = new PatchLineComment(new PatchLineComment.Key(new Patch.Key(ps.getId(), in.path), ChangeUtil.messageUUID(ctx.getDb())), line, ctx.getUser().getAccountId(), Url.decode(in.inReplyTo), ctx.getWhen());
    comment.setSide(in.side == Side.PARENT ? (short) 0 : (short) 1);
    comment.setMessage(in.message.trim());
    comment.setRange(in.range);
    setCommentRevId(comment, patchListCache, ctx.getChange(), ps);
    plcUtil.insertComments(ctx.getDb(), ctx.getUpdate(psId), Collections.singleton(comment));
    return true;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    ps = ctx.getDb().patchSets().get(psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    if (change.getLastUpdatedOn().before(ctx.getWhen())) {
        change.setLastUpdatedOn(ctx.getWhen());
    }
    if (dirty) {
        ctx.saveChange();
    }
    return dirty;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    user = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    ps = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    boolean dirty = false;
    dirty |= insertComments(ctx);
    dirty |= updateLabels(ctx);
    dirty |= insertMessage(ctx);
    if (change.getLastUpdatedOn().before(ctx.getWhen())) {
        change.setLastUpdatedOn(ctx.getWhen());
    }
    if (dirty) {
        ctx.saveChange();
    }
    return dirty;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit;
    if (baseCommitish != null) {
        baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish));
    } else {
        baseCommit = rw.parseCommit(RebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk(), ctx.getDb()));
    }
    ObjectId newId = rebaseCommit(ctx, original, baseCommit);
    rebasedCommit = rw.parseCommit(newId);
    rebasedPatchSetId = ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl.getRefControl(), rebasedPatchSetId, rebasedCommit).setDraft(originalPatchSet.isDraft()).setUploader(ctx.getUser().getAccountId()).setSendMail(false).setRunHooks(runHooks).setCopyApprovals(copyApprovals).setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    if (validate != null) {
        patchSetInserter.setValidatePolicy(validate);
    }
    patchSetInserter.updateRepo(ctx);
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws MergeConflictException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // Ok that originalPatchSet was not read in a transaction, since we just
    // need its revision.
    RevId oldRev = originalPatchSet.getRevision();
    RevWalk rw = ctx.getRevWalk();
    RevCommit original = rw.parseCommit(ObjectId.fromString(oldRev.get()));
    rw.parseBody(original);
    RevCommit baseCommit;
    if (baseCommitish != null) {
        baseCommit = rw.parseCommit(ctx.getRepository().resolve(baseCommitish));
    } else {
        baseCommit = rw.parseCommit(rebaseUtil.findBaseRevision(originalPatchSet, ctl.getChange().getDest(), ctx.getRepository(), ctx.getRevWalk()));
    }
    ObjectId newId = rebaseCommit(ctx, original, baseCommit);
    rebasedCommit = rw.parseCommit(newId);
    rebasedPatchSetId = ChangeUtil.nextPatchSetId(ctx.getRepository(), ctl.getChange().currentPatchSetId());
    patchSetInserter = patchSetInserterFactory.create(ctl.getRefControl(), rebasedPatchSetId, rebasedCommit).setDraft(originalPatchSet.isDraft()).setSendMail(false).setRunHooks(runHooks).setCopyApprovals(copyApprovals).setMessage("Patch Set " + rebasedPatchSetId.get() + ": Patch Set " + originalPatchSet.getId().get() + " was rebased");
    if (validate != null) {
        patchSetInserter.setValidatePolicy(validate);
    }
    patchSetInserter.updateRepo(ctx);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    patchSetInserter.updateChange(ctx);
    rebasedPatchSet = patchSetInserter.getPatchSet();
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException, IOException {
    boolean ret = patchSetInserter.updateChange(ctx);
    rebasedPatchSet = patchSetInserter.getPatchSet();
    return ret;
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    patchSet = ctx.getDb().patchSets().get(psId);
    if (patchSet == null) {
        // Nothing to do.
        return false;
    }
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft patch set");
    }
    deleteDraftPatchSet(patchSet, ctx);
    deleteOrUpdateDraftChange(ctx);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    if (patchSet == null) {
        // Nothing to do.
        return false;
    }
    if (!patchSet.isDraft()) {
        throw new ResourceConflictException("Patch set is not a draft");
    }
    if (!allowDrafts) {
        throw new MethodNotAllowedException("Draft workflow is disabled");
    }
    if (!ctx.getControl().canDeleteDraft(ctx.getDb())) {
        throw new AuthException("Not permitted to delete this draft patch set");
    }
    deleteDraftPatchSet(patchSet, ctx);
    deleteOrUpdateDraftChange(ctx);
    return true;
}
#end_block

#method_before
private void deleteOrUpdateDraftChange(ChangeContext ctx) throws OrmException, RestApiException {
    Change c = ctx.getChange();
    if (Iterables.isEmpty(ctx.getDb().patchSets().byChange(c.getId()))) {
        deleteChangeOp = deleteChangeOpProvider.get();
        deleteChangeOp.updateChange(ctx);
        return;
    }
    if (c.currentPatchSetId().equals(psId)) {
        c.setCurrentPatchSet(previousPatchSetInfo(ctx));
    }
    ChangeUtil.updated(c);
    ctx.saveChange();
}
#method_after
private void deleteOrUpdateDraftChange(ChangeContext ctx) throws OrmException, RestApiException {
    Change c = ctx.getChange();
    if (Iterables.isEmpty(psUtil.byChange(ctx.getDb(), ctx.getNotes()))) {
        deleteChangeOp = deleteChangeOpProvider.get();
        deleteChangeOp.updateChange(ctx);
        return;
    }
    if (c.currentPatchSetId().equals(psId)) {
        c.setCurrentPatchSet(previousPatchSetInfo(ctx));
    }
    ChangeUtil.updated(c);
    ctx.saveChange();
}
#end_block

#method_before
private PatchSetInfo previousPatchSetInfo(ChangeContext ctx) throws OrmException {
    try {
        // the repo after the updateRepo phase.
        return patchSetInfoFactory.get(ctx.getDb(), new PatchSet.Id(psId.getParentKey(), psId.get() - 1));
    } catch (PatchSetInfoNotAvailableException e) {
        throw new OrmException(e);
    }
}
#method_after
private PatchSetInfo previousPatchSetInfo(ChangeContext ctx) throws OrmException {
    try {
        // the repo after the updateRepo phase.
        return patchSetInfoFactory.get(ctx.getDb(), ctx.getNotes(), new PatchSet.Id(psId.getParentKey(), psId.get() - 1));
    } catch (PatchSetInfoNotAvailableException e) {
        throw new OrmException(e);
    }
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!ctx.getControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    if (patchSet == null) {
        patchSet = ctx.getDb().patchSets().get(psId);
        if (patchSet == null) {
            throw new ResourceNotFoundException(psId.toString());
        }
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws RestApiException, OrmException, IOException {
    if (!ctx.getControl().canPublish(ctx.getDb())) {
        throw new AuthException("Cannot publish this draft patch set");
    }
    if (patchSet == null) {
        patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
        if (patchSet == null) {
            throw new ResourceNotFoundException(psId.toString());
        }
    }
    saveChange(ctx);
    savePatchSet(ctx);
    addReviewers(ctx);
    return true;
}
#end_block

#method_before
private void addReviewers(ChangeContext ctx) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).values();
    RevCommit commit = ctx.getRevWalk().parseCommit(ObjectId.fromString(patchSet.getRevision().get()));
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet, footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getUpdate(psId), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#method_after
private void addReviewers(ChangeContext ctx) throws OrmException, IOException {
    LabelTypes labelTypes = ctx.getControl().getLabelTypes();
    Collection<Account.Id> oldReviewers = approvalsUtil.getReviewers(ctx.getDb(), ctx.getNotes()).values();
    RevCommit commit = ctx.getRevWalk().parseCommit(ObjectId.fromString(patchSet.getRevision().get()));
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, psId);
    List<FooterLine> footerLines = commit.getFooterLines();
    recipients = getRecipientsFromFooters(accountResolver, patchSet.isDraft(), footerLines);
    recipients.remove(ctx.getUser().getAccountId());
    approvalsUtil.addReviewers(ctx.getDb(), ctx.getUpdate(psId), labelTypes, change, patchSet, patchSetInfo, recipients.getReviewers(), oldReviewers);
}
#end_block

#method_before
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = ctx.getDb().patchSets().get(psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.saveChange();
    update.setStatus(change.getStatus());
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#method_after
@Override
public boolean updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    change = ctx.getChange();
    PatchSet.Id psId = change.currentPatchSetId();
    ChangeUpdate update = ctx.getUpdate(psId);
    if (change == null || !change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (change.getStatus() == Change.Status.DRAFT) {
        throw new ResourceConflictException("draft changes cannot be abandoned");
    }
    patchSet = psUtil.get(ctx.getDb(), ctx.getNotes(), psId);
    change.setStatus(Change.Status.ABANDONED);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.saveChange();
    update.setStatus(change.getStatus());
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), update, message);
    return true;
}
#end_block

#method_before
@Override
public Change createChange(Context ctx) {
    try {
        change = new Change(getChangeKey(commit), changeId, ctx.getUser().getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
        change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
        change.setTopic(topic);
        patchSet.setCreatedOn(ctx.getWhen());
        patchSet.setUploader(ctx.getUser().getAccountId());
        return change;
    } catch (IOException e) {
        throw new IllegalStateException(e);
    }
}
#method_after
@Override
public Change createChange(Context ctx) {
    change = new Change(getChangeKey(commit), changeId, ctx.getUser().getAccountId(), new Branch.NameKey(ctx.getProject(), refName), ctx.getWhen());
    change.setStatus(MoreObjects.firstNonNull(status, Change.Status.NEW));
    change.setTopic(topic);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(ctx.getUser().getAccountId());
    return change;
}
#end_block

#method_before
private static Change.Key getChangeKey(RevCommit commit) throws IOException {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    ObjectId id = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
    StringBuilder changeId = new StringBuilder();
    changeId.append("I").append(ObjectId.toString(id));
    return new Change.Key(changeId.toString());
}
#method_after
private static Change.Key getChangeKey(RevCommit commit) {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    if (!idList.isEmpty()) {
        return new Change.Key(idList.get(idList.size() - 1).trim());
    }
    try {
        ObjectId id = ChangeIdUtil.computeChangeId(commit.getTree(), commit, commit.getAuthorIdent(), commit.getCommitterIdent(), commit.getShortMessage());
        StringBuilder changeId = new StringBuilder();
        changeId.append("I").append(ObjectId.toString(id));
        return new Change.Key(changeId.toString());
    } catch (IOException e) {
        throw new IllegalStateException(e);
    }
}
#end_block

#method_before
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    db.get().accounts().beginTransaction(accountId);
    try {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            setDownloadScheme(p, i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.copySelfOnEmail != null) {
            p.setCopySelfOnEmails(i.copySelfOnEmail);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.muteCommonPathPrefixes != null) {
            p.setMuteCommonPathPrefixes(i.muteCommonPathPrefixes);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.get().rollback();
    }
}
#method_after
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    db.get().accounts().beginTransaction(accountId);
    try (MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName)) {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            setDownloadScheme(p, i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.muteCommonPathPrefixes != null) {
            p.setMuteCommonPathPrefixes(i.muteCommonPathPrefixes);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.emailStrategy != null) {
            p.setEmailStrategy(i.emailStrategy);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        db.get().rollback();
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, NoSuchChangeException {
    if (newCommit == null) {
        // Merge conflict; don't update change.
        return;
    }
    PatchSet ps = new PatchSet(psId);
    ps.setCreatedOn(ctx.getWhen());
    ps.setUploader(args.caller.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    Change c = toMerge.change();
    ps.setGroups(GroupCollector.getCurrentGroups(args.db, c));
    args.db.patchSets().insert(Collections.singleton(ps));
    c.setCurrentPatchSet(patchSetInfo);
    args.db.changes().update(Collections.singletonList(c));
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
        ctx.getUpdate(psId).putApproval(a.getLabel(), a.getValue());
    }
    args.db.patchSetApprovals().insert(approvals);
    newCommit.copyFrom(toMerge);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    mergeTip.moveTipTo(newCommit, newCommit);
    args.commits.put(newCommit);
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, NoSuchChangeException {
    if (newCommit == null) {
        // Merge conflict; don't update change.
        return;
    }
    ctx.getChangeUpdate().setPatchSetId(psId);
    PatchSet ps = new PatchSet(psId);
    ps.setCreatedOn(ctx.getWhen());
    ps.setUploader(args.caller.getAccountId());
    ps.setRevision(new RevId(newCommit.getId().getName()));
    Change c = toMerge.change();
    ps.setGroups(GroupCollector.getCurrentGroups(args.db, c));
    args.db.patchSets().insert(Collections.singleton(ps));
    c.setCurrentPatchSet(patchSetInfo);
    args.db.changes().update(Collections.singletonList(c));
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(ps.getId(), a));
        ctx.getChangeUpdate().putApproval(a.getLabel(), a.getValue());
    }
    args.db.patchSetApprovals().insert(approvals);
    newCommit.copyFrom(toMerge);
    newCommit.setStatusCode(CommitMergeStatus.CLEAN_PICK);
    newCommit.setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    mergeTip.moveTipTo(newCommit, newCommit);
    newCommits.put(c.getId(), newCommit);
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, toMerge)) {
        toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
        mergeTip.moveTipTo(toMerge, toMerge);
        acceptMergeTip(mergeTip);
        return;
    }
    rebaseOp = args.rebaseFactory.create(toMerge.getControl(), // Racy read of patch set is ok; see comments in RebaseChangeOp.
    args.db.patchSets().get(toMerge.getPatchsetId()), mergeTip.getCurrentTip().name()).setRunHooks(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try {
        rebaseOp.updateRepo(ctx);
    } catch (MergeConflictException e) {
        toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
        throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
    }
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IntegrationException, InvalidChangeOperationException, RestApiException, IOException, OrmException {
    // BatchUpdate how to produce CodeReviewRevWalks.
    if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, toMerge)) {
        toMerge.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
        mergeTip.moveTipTo(toMerge, toMerge);
        acceptMergeTip(mergeTip);
        return;
    }
    rebaseOp = args.rebaseFactory.create(toMerge.getControl(), // Racy read of patch set is ok; see comments in RebaseChangeOp.
    args.db.patchSets().get(toMerge.getPatchsetId()), mergeTip.getCurrentTip().name()).setCommitterIdent(args.serverIdent).setRunHooks(false).setValidatePolicy(CommitValidators.Policy.NONE);
    try {
        rebaseOp.updateRepo(ctx);
    } catch (MergeConflictException e) {
        toMerge.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
        throw new IntegrationException("Cannot rebase " + toMerge.name() + ": " + e.getMessage(), e);
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    if (rebaseOp == null) {
        // Took the fast-forward option, nothing to do.
        return;
    }
    rebaseOp.updateChange(ctx);
    PatchSet newPatchSet = rebaseOp.getPatchSet();
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(ctx.getDb(), toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
    }
    // rebaseOp may already have copied some approvals; use upsert, not
    // insert, to avoid constraint violation on database.
    args.db.patchSetApprovals().upsert(approvals);
    // TODO(dborowitz): Make RevWalk available via BatchUpdate.
    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
    mergeTip.moveTipTo(newTip, newTip);
    toMerge.change().setCurrentPatchSet(args.patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
    mergeTip.getCurrentTip().copyFrom(toMerge);
    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    args.commits.put(mergeTip.getCurrentTip());
    acceptMergeTip(mergeTip);
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws NoSuchChangeException, InvalidChangeOperationException, OrmException, IOException {
    if (rebaseOp == null) {
        // Took the fast-forward option, nothing to do.
        return;
    }
    rebaseOp.updateChange(ctx);
    PatchSet newPatchSet = rebaseOp.getPatchSet();
    List<PatchSetApproval> approvals = Lists.newArrayList();
    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(ctx.getDb(), toMerge.getControl(), toMerge.getPatchsetId())) {
        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
    }
    // rebaseOp may already have copied some approvals; use upsert, not
    // insert, to avoid constraint violation on database.
    args.db.patchSetApprovals().upsert(approvals);
    // TODO(dborowitz): Make RevWalk available via BatchUpdate.
    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
    mergeTip.moveTipTo(newTip, newTip);
    toMerge.change().setCurrentPatchSet(args.patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
    mergeTip.getCurrentTip().copyFrom(toMerge);
    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(toMerge.change(), args.caller));
    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
    acceptMergeTip(mergeTip);
}
#end_block

#method_before
private void add(ReceiveCommand cmd) {
    checkArgument(!cmd.getOldId().equals(cmd.getNewId()), "ref update is a no-op: %s", cmd);
    ReceiveCommand old = commands.get(cmd.getRefName());
    if (old == null) {
        commands.put(cmd.getRefName(), cmd);
        return;
    }
    checkArgument(old.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED, "cannot chain ref update %s after update %s with result %s", cmd, old, old.getResult());
    checkArgument(cmd.getOldId().equals(old.getNewId()), "cannot chain ref update %s after update %s with different new ID");
    commands.put(cmd.getRefName(), new ReceiveCommand(old.getOldId(), cmd.getNewId(), cmd.getRefName()));
}
#method_after
private void add(ReceiveCommand cmd) {
    checkArgument(!cmd.getOldId().equals(cmd.getNewId()), "ref update is a no-op: %s", cmd);
    ReceiveCommand old = commands.get(cmd.getRefName());
    if (old == null) {
        commands.put(cmd.getRefName(), cmd);
        return;
    }
    checkArgument(old.getResult() == ReceiveCommand.Result.NOT_ATTEMPTED, "cannot chain ref update %s after update %s with result %s", cmd, old, old.getResult());
    checkArgument(cmd.getOldId().equals(old.getNewId()), "cannot chain ref update %s after update %s with different new ID", cmd, old);
    commands.put(cmd.getRefName(), new ReceiveCommand(old.getOldId(), cmd.getNewId(), cmd.getRefName()));
}
#end_block

#method_before
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (repo == null || commands.isEmpty()) {
        return;
    }
    inserter.flush();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#method_after
private void executeRefUpdates() throws IOException, UpdateException, RestApiException {
    try {
        RepoContext ctx = new RepoContext();
        for (Op op : ops.values()) {
            op.updateRepo(ctx);
        }
    } catch (Exception e) {
        Throwables.propagateIfPossible(e, RestApiException.class);
        throw new UpdateException(e);
    }
    if (commands.isEmpty()) {
        return;
    }
    // May not be opened if the caller added ref updates but no new objects.
    initRepository();
    inserter.flush();
    batchRefUpdate = repo.getRefDatabase().newBatchUpdate();
    commands.addTo(batchRefUpdate);
    batchRefUpdate.execute(revWalk, NullProgressMonitor.INSTANCE);
    boolean ok = true;
    for (ReceiveCommand cmd : batchRefUpdate.getCommands()) {
        if (cmd.getResult() != ReceiveCommand.Result.OK) {
            ok = false;
            break;
        }
    }
    if (!ok) {
        throw new UpdateException("BatchRefUpdate failed: " + batchRefUpdate);
    }
}
#end_block

#method_before
@Override
public List<EmailInfo> apply(AccountResource rsrc) throws AuthException, OrmException {
    if (self.get() != rsrc.getUser() && self.get().getUserName() != rsrc.getUser().getUserName() && !self.get().getCapabilities().canViewAllAccounts()) {
        throw new AuthException("not allowed to list email addresses");
    }
    List<EmailInfo> emails = Lists.newArrayList();
    for (String email : rsrc.getUser().getEmailAddresses()) {
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.preferred(rsrc.getUser().getAccount().getPreferredEmail());
            emails.add(e);
        }
    }
    Collections.sort(emails, new Comparator<EmailInfo>() {

        @Override
        public int compare(EmailInfo a, EmailInfo b) {
            return a.email.compareTo(b.email);
        }
    });
    return emails;
}
#method_after
@Override
public List<EmailInfo> apply(AccountResource rsrc) {
    List<EmailInfo> emails = Lists.newArrayList();
    for (String email : rsrc.getUser().getEmailAddresses()) {
        if (email != null) {
            EmailInfo e = new EmailInfo();
            e.email = email;
            e.preferred(rsrc.getUser().getAccount().getPreferredEmail());
            emails.add(e);
        }
    }
    Collections.sort(emails, new Comparator<EmailInfo>() {

        @Override
        public int compare(EmailInfo a, EmailInfo b) {
            return a.email.compareTo(b.email);
        }
    });
    return emails;
}
#end_block

#method_before
@Override
public MergeTip run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        // Start with the first fast-forward. This may create the branch if it did
        // not exist.
        // TODO(dborowitz): currently no tests for the empty branch case.
        CodeReviewCommit firstFastForward;
        if (branchTip == null) {
            firstFastForward = sorted.remove(0);
        } else {
            firstFastForward = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
            mergeTip = new MergeTip(branchTip, toMerge);
        }
        if (!firstFastForward.equals(branchTip)) {
            u.addOp(firstFastForward.change().getId(), new FastForwardOp(mergeTip, firstFastForward));
        }
        // For every other commit do a pair-wise merge.
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            u.addOp(n.change().getId(), new MergeOneOp(args, mergeTip, n));
        }
        u.addOp(anyChangeId(toMerge), new MarkCleanMergesOp(args, mergeTip));
        u.execute();
    } catch (UpdateException e) {
        if (e.getCause() instanceof IntegrationException) {
            throw new IntegrationException(e.getCause().getMessage(), e);
        }
        throw new IntegrationException("Cannot merge into " + args.destBranch);
    } catch (RestApiException e) {
        throw new IntegrationException("Cannot merge into " + args.destBranch);
    }
    return mergeTip;
}
#method_after
@Override
public MergeTip run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        // Start with the first fast-forward. This may create the branch if it did
        // not exist.
        CodeReviewCommit firstFastForward;
        if (branchTip == null) {
            firstFastForward = sorted.remove(0);
        } else {
            firstFastForward = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
        }
        if (!firstFastForward.equals(branchTip)) {
            u.addOp(firstFastForward.change().getId(), new FastForwardOp(mergeTip, firstFastForward));
        }
        // For every other commit do a pair-wise merge.
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            u.addOp(n.change().getId(), new MergeOneOp(args, mergeTip, n));
        }
        u.addOp(anyChangeId(toMerge), new MarkCleanMergesOp(args, mergeTip));
        u.execute();
    } catch (RestApiException | UpdateException e) {
        if (e.getCause() instanceof IntegrationException) {
            throw new IntegrationException(e.getCause().getMessage(), e);
        }
        throw new IntegrationException("Cannot merge into " + args.destBranch);
    }
    return mergeTip;
}
#end_block

#method_before
@Override
public MergeTip run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        if (branchTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            CodeReviewCommit first = sorted.remove(0);
            u.addOp(first.change().getId(), new FastForwardOp(mergeTip, first));
        }
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            u.addOp(n.change().getId(), new MergeOneOp(args, mergeTip, n));
        }
        u.addOp(anyChangeId(toMerge), new MarkCleanMergesOp(args, mergeTip));
        u.execute();
    } catch (UpdateException e) {
        if (e.getCause() instanceof IntegrationException) {
            throw new IntegrationException(e.getCause().getMessage(), e);
        }
        throw new IntegrationException("Cannot merge into " + args.destBranch);
    } catch (RestApiException e) {
        throw new IntegrationException("Cannot merge into " + args.destBranch);
    }
    return mergeTip;
}
#method_after
@Override
public MergeTip run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        if (branchTip == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            CodeReviewCommit first = sorted.remove(0);
            u.addOp(first.change().getId(), new FastForwardOp(mergeTip, first));
        }
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            u.addOp(n.change().getId(), new MergeOneOp(args, mergeTip, n));
        }
        u.addOp(anyChangeId(toMerge), new MarkCleanMergesOp(args, mergeTip));
        u.execute();
    } catch (RestApiException | UpdateException e) {
        if (e.getCause() instanceof IntegrationException) {
            throw new IntegrationException(e.getCause().getMessage(), e);
        }
        throw new IntegrationException("Cannot merge into " + args.destBranch);
    }
    return mergeTip;
}
#end_block

#method_before
@Override
public MergeTip run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        CodeReviewCommit newTipCommit = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
        if (!newTipCommit.equals(branchTip)) {
            u.addOp(newTipCommit.change().getId(), new FastForwardOp(mergeTip, newTipCommit));
        }
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            u.addOp(n.change().getId(), new NotFastForwardOp(n));
        }
        u.addOp(anyChangeId(toMerge), new MarkCleanMergesOp(args, mergeTip));
        u.execute();
    } catch (UpdateException e) {
        if (e.getCause() instanceof IntegrationException) {
            throw new IntegrationException(e.getCause().getMessage(), e);
        }
        throw new IntegrationException("Cannot fast-forward into " + args.destBranch);
    } catch (RestApiException e) {
        throw new IntegrationException("Cannot fast-forward into " + args.destBranch);
    }
    return mergeTip;
}
#method_after
@Override
public MergeTip run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        CodeReviewCommit newTipCommit = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
        if (!newTipCommit.equals(branchTip)) {
            u.addOp(newTipCommit.change().getId(), new FastForwardOp(mergeTip, newTipCommit));
        }
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            u.addOp(n.change().getId(), new NotFastForwardOp(n));
        }
        u.addOp(anyChangeId(toMerge), new MarkCleanMergesOp(args, mergeTip));
        u.execute();
    } catch (RestApiException | UpdateException e) {
        if (e.getCause() instanceof IntegrationException) {
            throw new IntegrationException(e.getCause().getMessage(), e);
        }
        throw new IntegrationException("Cannot fast-forward into " + args.destBranch);
    }
    return mergeTip;
}
#end_block

#method_before
private void validate() throws IOException, InvalidChangeOperationException {
    if (validated || validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    String refName = patchSet.getId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, user);
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(git, revWalk);
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
    validated = true;
}
#method_after
private void validate() throws IOException, InvalidChangeOperationException {
    if (validatePolicy == CommitValidators.Policy.NONE) {
        return;
    }
    CommitValidators cv = commitValidatorsFactory.create(refControl, new NoSshInfo(), git);
    String refName = patchSet.getId().toRefName();
    CommitReceivedEvent event = new CommitReceivedEvent(new ReceiveCommand(ObjectId.zeroId(), commit.getId(), refName), refControl.getProjectControl().getProject(), refControl.getRefName(), commit, user);
    try {
        switch(validatePolicy) {
            case RECEIVE_COMMITS:
                NoteMap rejectCommits = BanCommit.loadRejectCommitsMap(git, revWalk);
                cv.validateForReceiveCommits(event, rejectCommits);
                break;
            case GERRIT:
                cv.validateForGerritCommits(event);
                break;
            case NONE:
                break;
        }
    } catch (CommitValidationException e) {
        throw new InvalidChangeOperationException(e.getMessage());
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    update.setTopic(change.getTopic());
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    update.setTopic(change.getTopic());
    /* TODO: fixStatus is used here because the tests
     * (byStatusClosed() in AbstractQueryChangesTest)
     * insert changes that are already merged,
     * and setStatus may not be used to set the Status to merged
     *
     * is it possible to make the tests use the merge code path,
     * instead of setting the status directly?
     */
    update.fixStatus(change.getStatus());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#end_block

#method_before
@Override
protected FileTime getLastModifiedTime(Path p) {
    // since the GWT outputs from the build process all have mtimes of 1980/1/1.
    return now;
}
#method_after
@Override
protected FileTime getLastModifiedTime(Path p) {
    // build process all have mtimes of 1980/1/1.
    return NOW;
}
#end_block

#method_before
protected static String contentType(final String name) {
    int dot = name.lastIndexOf('.');
    String ext = 0 < dot ? name.substring(dot + 1) : "";
    String type = MIME_TYPES.get(ext);
    return type != null ? type : "application/octet-stream";
}
#method_after
protected static String contentType(String name) {
    int dot = name.lastIndexOf('.');
    String ext = 0 < dot ? name.substring(dot + 1) : "";
    String type = MIME_TYPES.get(ext);
    return type != null ? type : "application/octet-stream";
}
#end_block

#method_before
protected FileTime getLastModifiedTime(Path p) {
    try {
        return Files.getLastModifiedTime(p);
    } catch (IOException e) {
        return FileTime.fromMillis(0);
    }
}
#method_after
protected FileTime getLastModifiedTime(Path p) throws IOException {
    return Files.getLastModifiedTime(p);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    if (r == null && maybeStream(p, req, rsp)) {
        return;
    }
    if (r == null) {
        Callable<Resource> loader = newLoader(p);
        try {
            r = cache.get(p, loader);
            if (refresh && r.isStale(p, this)) {
                cache.invalidate(p);
                r = cache.get(p, loader);
            }
        } catch (ExecutionException e) {
            log.warn("Cannot load static resource " + req.getPathInfo(), e);
            CacheHeaders.setNotCacheable(rsp);
            rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
    }
    if (r == Resource.NOT_FOUND) {
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    rsp.setHeader(ETAG, r.etag);
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    String name = CharMatcher.is('/').trimFrom(req.getPathInfo());
    if (isUnreasonableName(name)) {
        notFound(rsp);
        return;
    }
    Path p = getResourcePath(name);
    if (p == null) {
        notFound(rsp);
        return;
    }
    Resource r = cache.getIfPresent(p);
    if (r == null && maybeStream(p, req, rsp)) {
        return;
    }
    if (r == null) {
        Callable<Resource> loader = newLoader(p);
        try {
            r = cache.get(p, loader);
            if (refresh && r.isStale(p, this)) {
                cache.invalidate(p);
                r = cache.get(p, loader);
            }
        } catch (ExecutionException | IOException e) {
            log.warn("Cannot load static resource " + req.getPathInfo(), e);
            CacheHeaders.setNotCacheable(rsp);
            rsp.setStatus(SC_INTERNAL_SERVER_ERROR);
            return;
        }
    }
    if (r == Resource.NOT_FOUND) {
        notFound(rsp);
        return;
    }
    String e = req.getParameter("e");
    if (e != null && !r.etag.equals(e)) {
        CacheHeaders.setNotCacheable(rsp);
        rsp.setStatus(SC_NOT_FOUND);
        return;
    } else if (r.etag.equals(req.getHeader(IF_NONE_MATCH))) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return;
    }
    byte[] tosend = r.raw;
    if (!r.contentType.equals(JS) && RPCServletUtils.acceptsGzipEncoding(req)) {
        byte[] gz = HtmlDomUtil.compress(tosend);
        if ((gz.length + 24) < tosend.length) {
            rsp.setHeader(CONTENT_ENCODING, "gzip");
            tosend = gz;
        }
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        if (e != null && r.etag.equals(e)) {
            CacheHeaders.setCacheable(req, rsp, 360, DAYS, false);
        } else {
            CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
        }
    }
    rsp.setHeader(ETAG, r.etag);
    rsp.setContentType(r.contentType);
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private boolean maybeStream(Path p, HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    try {
        if (Files.size(p) < CACHE_FILE_SIZE_LIMIT_BYTES) {
            return false;
        }
    } catch (FileNotFoundException e) {
        cache.put(p, Resource.NOT_FOUND);
        notFound(rsp);
        return true;
    }
    long lastModified = FileUtil.lastModified(p);
    if (req.getDateHeader(IF_MODIFIED_SINCE) >= lastModified) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return true;
    }
    if (lastModified > 0) {
        rsp.setDateHeader(LAST_MODIFIED, lastModified);
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
    }
    rsp.setContentType(contentType(p.toString()));
    OutputStream out = rsp.getOutputStream();
    GZIPOutputStream gz = null;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader(CONTENT_ENCODING, "gzip");
        gz = new GZIPOutputStream(out);
        out = gz;
    }
    Files.copy(p, out);
    if (gz != null) {
        gz.finish();
    }
    return true;
}
#method_after
private boolean maybeStream(Path p, HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    try {
        if (Files.size(p) < CACHE_FILE_SIZE_LIMIT_BYTES) {
            return false;
        }
    } catch (NoSuchFileException e) {
        cache.put(p, Resource.NOT_FOUND);
        notFound(rsp);
        return true;
    }
    long lastModified = FileUtil.lastModified(p);
    if (req.getDateHeader(IF_MODIFIED_SINCE) >= lastModified) {
        rsp.setStatus(SC_NOT_MODIFIED);
        return true;
    }
    if (lastModified > 0) {
        rsp.setDateHeader(LAST_MODIFIED, lastModified);
    }
    if (!CacheHeaders.hasCacheHeader(rsp)) {
        CacheHeaders.setCacheable(req, rsp, 15, MINUTES, refresh);
    }
    rsp.setContentType(contentType(p.toString()));
    OutputStream out = rsp.getOutputStream();
    GZIPOutputStream gz = null;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader(CONTENT_ENCODING, "gzip");
        gz = new GZIPOutputStream(out);
        out = gz;
    }
    Files.copy(p, out);
    if (gz != null) {
        gz.finish();
    }
    return true;
}
#end_block

#method_before
private Callable<Resource> newLoader(final Path p) {
    return new Callable<Resource>() {

        @Override
        public Resource call() throws IOException {
            try {
                return new Resource(getLastModifiedTime(p), contentType(p.toString()), Files.readAllBytes(p));
            } catch (FileNotFoundException e) {
                return Resource.NOT_FOUND;
            }
        }
    };
}
#method_after
private Callable<Resource> newLoader(final Path p) {
    return new Callable<Resource>() {

        @Override
        public Resource call() throws IOException {
            try {
                return new Resource(getLastModifiedTime(p), contentType(p.toString()), Files.readAllBytes(p));
            } catch (NoSuchFileException e) {
                return Resource.NOT_FOUND;
            }
        }
    };
}
#end_block

#method_before
boolean isStale(Path p, ResourceServlet rs) {
    FileTime t = rs.getLastModifiedTime(p);
    return t.toMillis() == 0 || lastModified.toMillis() == 0 || !lastModified.equals(t);
}
#method_after
boolean isStale(Path p, ResourceServlet rs) throws IOException {
    FileTime t = rs.getLastModifiedTime(p);
    return t.toMillis() == 0 || lastModified.toMillis() == 0 || !lastModified.equals(t);
}
#end_block

#method_before
@Override
protected FileTime getLastModifiedTime(Path p) {
    // since the GWT outputs from the build process all have mtimes of 1980/1/1.
    return now;
}
#method_after
@Override
protected FileTime getLastModifiedTime(Path p) {
    // build process all have mtimes of 1980/1/1.
    return NOW;
}
#end_block

#method_before
public static File getDistributionArchive() throws FileNotFoundException, IOException {
    File result = myArchive;
    if (result == null) {
        synchronized (GerritLauncher.class) {
            result = myArchive;
            if (result == null) {
                result = locateMyArchive();
                myArchiveFs = FileSystems.newFileSystem(URI.create("jar:" + result.toPath().toUri()), Collections.<String, String>emptyMap());
                myArchive = result;
            }
        }
    }
    return result;
}
#method_after
public static File getDistributionArchive() throws FileNotFoundException, IOException {
    File result = myArchive;
    if (result == null) {
        synchronized (GerritLauncher.class) {
            result = myArchive;
            if (result != null) {
                return result;
            }
            result = locateMyArchive();
            myArchiveFs = FileSystems.newFileSystem(URI.create("jar:" + result.toPath().toUri()), Collections.<String, String>emptyMap());
            myArchive = result;
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    FormatType format = getFormat(req);
    if (format == null) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format) {
        case HTML:
            doGetHtml(req, res);
            break;
        case TEXT:
            doGetText(req, res);
            break;
        case JSON:
            doGetJson(req, res);
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format.get()) {
        case HTML:
            doGetHtml(req, res);
            break;
        case TEXT:
            doGetText(req, res);
            break;
        case JSON:
            doGetJson(req, res);
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
protected FormatType getFormat(HttpServletRequest req) {
    FormatType format;
    try {
        format = FormatType.getFormatType(req);
    } catch (IllegalArgumentException err) {
        return null;
    }
    if (format == DEFAULT) {
        return getDefaultFormat(req);
    }
    return format;
}
#method_after
protected Optional<FormatType> getFormat(HttpServletRequest req) {
    Optional<FormatType> format = FormatType.getFormatType(req);
    if (format.isPresent() && format.get() == DEFAULT) {
        return Optional.of(getDefaultFormat(req));
    }
    return format;
}
#end_block

#method_before
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    // If the repository didn't exist a prior filter would have 404 replied.
    FormatType format = getFormat(req);
    if (format == null) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format) {
        case HTML:
        case JSON:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.getMimeType());
            break;
        case TEXT:
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    // If the repository didn't exist a prior filter would have 404 replied.
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    switch(format.get()) {
        case HTML:
        case JSON:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        case TEXT:
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    FormatType format = getFormat(req);
    if (format == null) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.getMimeType());
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#method_after
@Override
protected void doHead(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Optional<FormatType> format = getFormat(req);
    if (!format.isPresent()) {
        res.sendError(SC_BAD_REQUEST);
        return;
    }
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    if (prefix != null) {
        Map<String, RepositoryDescription> descs = list(req, res, prefix, Collections.<String>emptySet());
        if (descs == null) {
            return;
        }
    }
    switch(format.get()) {
        case HTML:
        case JSON:
        case TEXT:
            res.setStatus(HttpServletResponse.SC_OK);
            res.setContentType(format.get().getMimeType());
            break;
        default:
            res.sendError(SC_BAD_REQUEST);
            break;
    }
}
#end_block

#method_before
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                return null;
            }
            try (Repository repo = repoManager.openRepository(c.getProject())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord rec = new SubmitRuleEvaluator(this).getSubmitType();
                if (rec.status != SubmitTypeRecord.Status.OK) {
                    throw new OrmException("Error in mergeability check: " + rec.errorMessage);
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, rec.type, mergeStrategy, c.getDest(), repo, db);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#method_after
public Boolean isMergeable() throws OrmException {
    if (mergeable == null) {
        Change c = change();
        if (c == null) {
            return null;
        }
        if (c.getStatus() == Change.Status.MERGED) {
            mergeable = true;
        } else {
            PatchSet ps = currentPatchSet();
            if (ps == null || !changeControl().isPatchVisible(ps, db)) {
                return null;
            }
            try (Repository repo = repoManager.openRepository(c.getProject())) {
                Ref ref = repo.getRefDatabase().exactRef(c.getDest().get());
                SubmitTypeRecord rec = new SubmitRuleEvaluator(this).getSubmitType();
                if (rec.status != SubmitTypeRecord.Status.OK) {
                    throw new OrmException("Error in mergeability check: " + rec.errorMessage);
                }
                String mergeStrategy = mergeUtilFactory.create(projectCache.get(c.getProject())).mergeStrategyName();
                mergeable = mergeabilityCache.get(ObjectId.fromString(ps.getRevision().get()), ref, rec.type, mergeStrategy, c.getDest(), repo);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
    }
    return mergeable;
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitStrategyFactory, conflictsCache, trackingFooters, index, indexConfig, listMembers, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitDryRun, conflictsCache, trackingFooters, index, indexConfig, listMembers, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(args.getSchema(), Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("reviewed".equalsIgnoreCase(statusName)) {
        return IsReviewedPredicate.create(args.getSchema());
    } else {
        return ChangeStatusPredicate.parse(statusName);
    }
}
#method_after
@Operator
public Predicate<ChangeData> status(String statusName) {
    if ("reviewed".equalsIgnoreCase(statusName)) {
        return IsReviewedPredicate.create();
    } else {
        return ChangeStatusPredicate.parse(statusName);
    }
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("draft".equalsIgnoreCase(value)) {
        return new HasDraftByPredicate(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> has(String value) throws QueryParseException {
    if ("star".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("draft".equalsIgnoreCase(value)) {
        return draftby(self());
    }
    if ("edit".equalsIgnoreCase(value)) {
        return new EditByPredicate(self());
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create(args.getSchema());
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#method_after
@Operator
public Predicate<ChangeData> is(String value) throws QueryParseException {
    if ("starred".equalsIgnoreCase(value)) {
        return new IsStarredByPredicate(args);
    }
    if ("watched".equalsIgnoreCase(value)) {
        return new IsWatchedByPredicate(args, false);
    }
    if ("visible".equalsIgnoreCase(value)) {
        return is_visible();
    }
    if ("reviewed".equalsIgnoreCase(value)) {
        return IsReviewedPredicate.create();
    }
    if ("owner".equalsIgnoreCase(value)) {
        return new OwnerPredicate(self());
    }
    if ("reviewer".equalsIgnoreCase(value)) {
        return new ReviewerPredicate(self(), args.allowsDrafts);
    }
    if ("mergeable".equalsIgnoreCase(value)) {
        return new IsMergeablePredicate(args.fillArgs);
    }
    try {
        return status(value);
    } catch (IllegalArgumentException e) {
    // not status: alias?
    }
    throw new IllegalArgumentException();
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> topic(String name) {
    return new ExactTopicPredicate(args.getSchema(), name);
}
#method_after
@Operator
public Predicate<ChangeData> topic(String name) {
    return new ExactTopicPredicate(name);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> intopic(String name) {
    if (name.startsWith("^")) {
        return new RegexTopicPredicate(args.getSchema(), name);
    }
    if (name.isEmpty()) {
        return new ExactTopicPredicate(args.getSchema(), name);
    }
    return new FuzzyTopicPredicate(args.getSchema(), name, args.index);
}
#method_after
@Operator
public Predicate<ChangeData> intopic(String name) {
    if (name.startsWith("^")) {
        return new RegexTopicPredicate(name);
    }
    if (name.isEmpty()) {
        return new ExactTopicPredicate(name);
    }
    return new FuzzyTopicPredicate(name, args.index);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<HasDraftByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(new HasDraftByPredicate(id));
    }
    return Predicate.or(p);
}
#method_after
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<Predicate<ChangeData>> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(draftby(id));
    }
    return Predicate.or(p);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> draftby(String who) throws QueryParseException, OrmException {
    Set<Account.Id> m = parseAccount(who);
    List<HasDraftByPredicate> p = Lists.newArrayListWithCapacity(m.size());
    for (Account.Id id : m) {
        p.add(new HasDraftByPredicate(id));
    }
    return Predicate.or(p);
}
#method_after
private Predicate<ChangeData> draftby(Account.Id who) {
    return args.getSchema().hasField(ChangeField.DRAFTBY) ? new HasDraftByPredicate(who) : new HasDraftByLegacyPredicate(args, who);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> reviewedby(String who) throws QueryParseException, OrmException {
    return IsReviewedPredicate.create(args.getSchema(), parseAccount(who));
}
#method_after
@Operator
public Predicate<ChangeData> reviewedby(String who) throws QueryParseException, OrmException {
    return IsReviewedPredicate.create(parseAccount(who));
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    change.setCurrentPatchSet(patchSetInfo);
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    update.setTopic(change.getTopic());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, IOException {
    // Use defensive copy created by ChangeControl.
    change = ctx.getChange();
    ReviewDb db = ctx.getDb();
    ChangeControl ctl = ctx.getChangeControl();
    ChangeUpdate update = ctx.getChangeUpdate();
    patchSetInfo = patchSetInfoFactory.get(ctx.getRevWalk(), commit, patchSet.getId());
    ctx.getChange().setCurrentPatchSet(patchSetInfo);
    if (patchSet.getGroups() == null) {
        patchSet.setGroups(GroupCollector.getDefaultGroups(patchSet));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    db.changes().insert(Collections.singleton(change));
    update.setTopic(change.getTopic());
    LabelTypes labelTypes = ctl.getProjectControl().getLabelTypes();
    approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
    approvalsUtil.addApprovals(db, update, labelTypes, patchSet, ctx.getChangeControl(), approvals);
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), patchSet.getCreatedOn(), patchSet.getId());
        changeMessage.setMessage(message);
        cmUtil.addChangeMessage(db, update, changeMessage);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        Set<RevCommit> accepted = SubmitDryRun.getAlreadyAccepted(repo, rw);
        RevCommit c = rw.parseCommit(key.commit);
        accepted.addAll(Arrays.asList(c.getParents()));
        return submitDryRun.dryRun(key.submitType, repo, rw, dest, key.into, key.commit, accepted);
    }
}
#method_after
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        Set<RevCommit> accepted = SubmitDryRun.getAlreadyAccepted(repo, rw);
        accepted.add(rw.parseCommit(key.into));
        accepted.addAll(Arrays.asList(rw.parseCommit(key.commit).getParents()));
        return submitDryRun.run(key.submitType, repo, rw, dest, key.into, key.commit, accepted);
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.dryRun(submitType, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    conflicts = !args.submitDryRun.run(submitType, repo, rw, otherChange.getDest(), changeDataCache.getTestAgainst(), other, getAlreadyAccepted(repo, rw));
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw) throws IntegrationException {
                try {
                    Set<RevCommit> accepted = new HashSet<>();
                    SubmitDryRun.addCommits(changeDataCache.getAlreadyAccepted(repo), rw, accepted);
                    ObjectId tip = changeDataCache.getTestAgainst();
                    if (tip != null) {
                        accepted.add(rw.parseCommit(tip));
                    }
                    return accepted;
                } catch (OrmException | IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
public RefUpdateAttribute asRefUpdateAttribute(final ObjectId oldId, final ObjectId newId, final Branch.NameKey refName) {
    RefUpdateAttribute ru = new RefUpdateAttribute();
    ru.newRev = newId != null ? newId.getName() : ObjectId.zeroId().getName();
    ru.oldRev = oldId != null ? oldId.getName() : ObjectId.zeroId().getName();
    ru.project = refName.getParentKey().get();
    ru.ref = refName.get();
    ru.refName = refName.getShortName();
    return ru;
}
#method_after
public RefUpdateAttribute asRefUpdateAttribute(final ObjectId oldId, final ObjectId newId, final Branch.NameKey refName) {
    RefUpdateAttribute ru = new RefUpdateAttribute();
    ru.newRev = newId != null ? newId.getName() : ObjectId.zeroId().getName();
    ru.oldRev = oldId != null ? oldId.getName() : ObjectId.zeroId().getName();
    ru.project = refName.getParentKey().get();
    ru.refName = refName.get();
    return ru;
}
#end_block

#method_before
public void close() {
    getRepository().close();
}
#method_after
@Override
public void close() {
    getRepository().close();
}
#end_block

#method_before
ImmutableListMultimap<PatchSet.Id, PatchSetApproval> buildApprovals() {
    Multimap<PatchSet.Id, PatchSetApproval> result = ArrayListMultimap.create(approvals.keySet().size(), 3);
    for (Table<?, ?, Optional<PatchSetApproval>> curr : approvals.values()) {
        for (PatchSetApproval psa : Optional.presentInstances(curr.values())) {
            result.put(psa.getPatchSetId(), psa);
        }
    }
    for (Collection<PatchSetApproval> v : result.asMap().values()) {
        Collections.sort((List<PatchSetApproval>) v, ChangeNotes.PSA_BY_TIME);
    }
    return ImmutableListMultimap.copyOf(result);
}
#method_after
ImmutableListMultimap<PatchSet.Id, PatchSetApproval> buildApprovals() {
    Multimap<PatchSet.Id, PatchSetApproval> result = ArrayListMultimap.create(approvals.keySet().size(), 3);
    for (Table<?, ?, PatchSetApproval> curr : approvals.values()) {
        for (PatchSetApproval psa : curr.values()) {
            result.put(psa.getPatchSetId(), psa);
        }
    }
    for (Collection<PatchSetApproval> v : result.asMap().values()) {
        Collections.sort((List<PatchSetApproval>) v, ChangeNotes.PSA_BY_TIME);
    }
    return ImmutableListMultimap.copyOf(result);
}
#end_block

#method_before
private void parseApproval(PatchSet.Id psId, Account.Id accountId, RevCommit commit, String line) throws ConfigInvalidException {
    Table<Account.Id, String, Optional<PatchSetApproval>> curr = approvals.get(psId);
    if (line.startsWith("-")) {
        String label = line.substring(1);
        if (curr == null || !curr.contains(accountId, label)) {
            parseRemoveApproval(psId, accountId, label);
        }
        return;
    }
    if (curr == null) {
        curr = Tables.newCustomTable(Maps.<Account.Id, Map<String, Optional<PatchSetApproval>>>newHashMapWithExpectedSize(2), new Supplier<Map<String, Optional<PatchSetApproval>>>() {

            @Override
            public Map<String, Optional<PatchSetApproval>> get() {
                return Maps.newLinkedHashMap();
            }
        });
        approvals.put(psId, curr);
    }
    LabelVote l;
    try {
        l = LabelVote.parseWithEquals(line);
    } catch (IllegalArgumentException e) {
        ConfigInvalidException pe = parseException("invalid %s: %s", FOOTER_LABEL, line);
        pe.initCause(e);
        throw pe;
    }
    if (!curr.contains(accountId, l.label()) && !isApprovalRemoved(psId, accountId, l.label())) {
        curr.put(accountId, l.label(), Optional.of(new PatchSetApproval(new PatchSetApproval.Key(psId, accountId, new LabelId(l.label())), l.value(), new Timestamp(commit.getCommitterIdent().getWhen().getTime()))));
    }
}
#method_after
private void parseApproval(PatchSet.Id psId, Account.Id accountId, RevCommit commit, String line) throws ConfigInvalidException {
    if (line.startsWith("-")) {
        parseRemoveApproval(psId, accountId, line);
    } else {
        parseAddApproval(psId, accountId, commit, line);
    }
}
#end_block

#method_before
private void parseRemoveApproval(PatchSet.Id psId, Account.Id accountId, String line) throws ConfigInvalidException {
    Multimap<Account.Id, String> curr = removedApprovals.get(psId);
    if (curr == null) {
        curr = HashMultimap.create(1, 1);
        removedApprovals.put(psId, curr);
    }
    String label;
    Account.Id removedAccountId;
    int s = line.indexOf(' ');
    if (s > 0) {
        // Leading '-' already trimmed by caller.
        label = line.substring(0, s);
        PersonIdent ident = RawParseUtils.parsePersonIdent(line.substring(s + 1));
        checkFooter(ident != null, FOOTER_LABEL, line);
        removedAccountId = parseIdent(ident);
    } else {
        label = line;
        removedAccountId = accountId;
    }
    curr.put(removedAccountId, label);
}
#method_after
private void parseRemoveApproval(PatchSet.Id psId, Account.Id accountId, String line) throws ConfigInvalidException {
    Multimap<Account.Id, String> curr = removedApprovals.get(psId);
    if (curr == null) {
        curr = HashMultimap.create(1, 1);
        removedApprovals.put(psId, curr);
    }
    String label;
    Account.Id removedAccountId;
    line = line.substring(1);
    int s = line.indexOf(' ');
    if (s > 0) {
        label = line.substring(0, s);
        PersonIdent ident = RawParseUtils.parsePersonIdent(line.substring(s + 1));
        checkFooter(ident != null, FOOTER_LABEL, line);
        removedAccountId = parseIdent(ident);
    } else {
        label = line;
        removedAccountId = accountId;
    }
    Table<Account.Id, String, PatchSetApproval> added = approvals.get(psId);
    if (added != null && added.contains(accountId, label)) {
        return;
    }
    try {
        curr.put(removedAccountId, LabelType.checkNameInternal(label));
    } catch (IllegalArgumentException e) {
        ConfigInvalidException pe = parseException("invalid %s: %s", FOOTER_LABEL, line);
        pe.initCause(e);
        throw pe;
    }
}
#end_block

#method_before
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
}
#method_after
@Test
public void parseApproval() throws Exception {
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=+1\n" + "Label: Label2=1\n" + "Label: Label3=0\n" + "Label: Label4=-1\n");
    assertParseSucceeds("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label1\n" + "Label: -Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1=X\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 = 1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: X+Y\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: Label1 Other Account <2@gerrit>\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1\n");
    assertParseFails("Update change\n" + "\n" + "Patch-Set: 1\n" + "Label: -Label!1 Other Account <2@gerrit>\n");
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted, hence there is no dummy 0 approval left when a vote is
        // deleted.
        assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
    }
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(user.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
    // When notedb is enabled each reviewer is explicitly recorded in the
    // notedb and this record stays even when all votes of that user have been
    // deleted, hence there is no dummy 0 approval left when a vote is
    // deleted.
    // TODO(dborowitz): Support modifying other users' labels in notedb
    // format.
    // assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    ChangeMessageInfo message = Iterables.getLast(c.messages);
    assertThat(message.author._accountId).isEqualTo(admin.getId().get());
    assertThat(message.message).isEqualTo("Removed Code-Review+1 by User <user@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
    }
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    Change change = ctx.getChange();
    ChangeControl ctl = ctx.getChangeControl();
    PatchSet.Id psId = change.currentPatchSetId();
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getChangeUpdate().setPatchSetId(psId);
                ctx.getChangeUpdate().removeApproval(label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ChangeUtil.bumpRowVersionNotLastUpdatedOn(change.getId(), ctx.getDb());
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, AuthException, ResourceNotFoundException {
    IdentifiedUser user = ctx.getUser().asIdentifiedUser();
    Change change = ctx.getChange();
    ChangeControl ctl = ctx.getChangeControl();
    PatchSet.Id psId = change.currentPatchSetId();
    PatchSetApproval psa = null;
    StringBuilder msg = new StringBuilder();
    for (PatchSetApproval a : approvalsUtil.byPatchSetUser(ctx.getDb(), ctl, psId, accountId)) {
        if (ctl.canRemoveReviewer(a)) {
            if (a.getLabel().equals(label)) {
                msg.append("Removed ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(a.getAccountId()).getNameEmail()).append("\n");
                psa = a;
                a.setValue((short) 0);
                ctx.getChangeUpdate().setPatchSetId(psId);
                // TODO(dborowitz): Support modifying other users' labels in notedb
                // format.
                ctx.getChangeUpdate().removeApproval(label);
                break;
            }
        } else {
            throw new AuthException("delete not permitted");
        }
    }
    if (psa == null) {
        throw new ResourceNotFoundException();
    }
    ChangeUtil.bumpRowVersionNotLastUpdatedOn(change.getId(), ctx.getDb());
    ctx.getDb().patchSetApprovals().update(Collections.singleton(psa));
    if (msg.length() > 0) {
        ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(ctx.getDb())), user.getAccountId(), ctx.getWhen(), change.currentPatchSetId());
        changeMessage.setMessage(msg.toString());
        cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), changeMessage);
    }
}
#end_block

#method_before
@Override
public boolean match(final ChangeData object) throws OrmException {
    try {
        return object.getAuthor().getEmailAddress().equalsIgnoreCase(getValue());
    } catch (IOException e) {
        return false;
    }
}
#method_after
@Override
public boolean match(ChangeData object) throws OrmException {
    return ChangeField.getAuthorParts(object).contains(getValue().toLowerCase());
}
#end_block

#method_before
@Test
public void byAuthor() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = newChange(repo, null, null, userId.get(), null).insert();
    assertQuery("author:jauthor@example.com", change1);
    assertQuery("author:user@example.com");
}
#method_after
@Test
public void byAuthor() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    Change change1 = newChange(repo, null, null, userId.get(), null).insert();
    // By exact email address
    assertQuery("author:jauthor@example.com", change1);
    // By email address part
    assertQuery("author:jauthor", change1);
    assertQuery("author:example", change1);
    assertQuery("author:example.com", change1);
    // By name part
    assertQuery("author:Author", change1);
    // By non-existing email address / name / part
    assertQuery("author:jcommitter@example.com");
    assertQuery("author:somewhere.com");
    assertQuery("author:jcommitter");
    assertQuery("author:Committer");
}
#end_block

#method_before
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = newChange(repo, commit1, null, null, null).insert();
    Change change2 = newChange(repo, commit2, null, null, null).insert();
    assertQuery("added:>4");
    assertQuery("added:3", change1);
    assertQuery("added:>2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("added:<1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("deleted:>3");
    assertQuery("deleted:2", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#method_after
@Test
public void bySize() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    // added = 3, deleted = 0, delta = 3
    RevCommit commit1 = repo.parseBody(repo.commit().add("file1", "foo\n\foo\nfoo").create());
    // added = 0, deleted = 2, delta = 2
    RevCommit commit2 = repo.parseBody(repo.commit().parent(commit1).add("file1", "foo").create());
    Change change1 = newChange(repo, commit1, null, null, null).insert();
    Change change2 = newChange(repo, commit2, null, null, null).insert();
    assertQuery("added:>4");
    assertQuery("-added:<=4");
    assertQuery("added:3", change1);
    assertQuery("-(added:<3 OR added>3)", change1);
    assertQuery("added:>2", change1);
    assertQuery("-added:<=2", change1);
    assertQuery("added:>=3", change1);
    assertQuery("-added:<3", change1);
    assertQuery("added:<1", change2);
    assertQuery("-added:>=1", change2);
    assertQuery("added:<=0", change2);
    assertQuery("-added:>0", change2);
    assertQuery("deleted:>3");
    assertQuery("-deleted:<=3");
    assertQuery("deleted:2", change2);
    assertQuery("-(deleted:<2 OR deleted>2)", change2);
    assertQuery("deleted:>1", change2);
    assertQuery("-deleted:<=1", change2);
    assertQuery("deleted:>=2", change2);
    assertQuery("-deleted:<2", change2);
    assertQuery("deleted:<1", change1);
    assertQuery("-deleted:>=1", change1);
    assertQuery("deleted:<=0", change1);
    for (String str : Lists.newArrayList("delta", "size")) {
        assertQuery(str + ":<2");
        assertQuery(str + ":3", change1);
        assertQuery(str + ":>2", change1);
        assertQuery(str + ":>=3", change1);
        assertQuery(str + ":<3", change2);
        assertQuery(str + ":<=2", change2);
    }
}
#end_block

#method_before
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo, null, null, null, null);
        ins.insert();
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getPatchSet().getRevision().get());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(new Function<ChangeData, Integer>() {

            @Override
            public Integer apply(ChangeData in) {
                return in.getId().get();
            }
        });
        String name = "batch size " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#method_after
@Test
public void byCommitsOnBranchNotMerged() throws Exception {
    TestRepository<Repo> repo = createProject("repo");
    int n = 10;
    List<String> shas = new ArrayList<>(n);
    List<Integer> expectedIds = new ArrayList<>(n);
    Branch.NameKey dest = null;
    for (int i = 0; i < n; i++) {
        ChangeInserter ins = newChange(repo, null, null, null, null);
        ins.insert();
        if (dest == null) {
            dest = ins.getChange().getDest();
        }
        shas.add(ins.getPatchSet().getRevision().get());
        expectedIds.add(ins.getChange().getId().get());
    }
    for (int i = 1; i <= 11; i++) {
        Iterable<ChangeData> cds = internalChangeQuery.byCommitsOnBranchNotMerged(indexes.getSearchIndex().getSchema(), dest, shas, i);
        Iterable<Integer> ids = FluentIterable.from(cds).transform(new Function<ChangeData, Integer>() {

            @Override
            public Integer apply(ChangeData in) {
                return in.getId().get();
            }
        });
        String name = "batch size " + i;
        assertThat(ids).named(name).hasSize(n);
        assertThat(ids).named(name).containsExactlyElementsIn(expectedIds);
    }
}
#end_block

#method_before
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
    }
    return true;
}
#method_after
private boolean loadCommitData() throws OrmException, RepositoryNotFoundException, IOException, MissingObjectException, IncorrectObjectTypeException {
    PatchSet ps = currentPatchSet();
    if (ps == null) {
        return false;
    }
    String sha1 = ps.getRevision().get();
    try (Repository repo = repoManager.openRepository(change().getProject());
        RevWalk walk = new RevWalk(repo)) {
        RevCommit c = walk.parseCommit(ObjectId.fromString(sha1));
        commitMessage = c.getFullMessage();
        commitFooters = c.getFooterLines();
        author = c.getAuthorIdent();
        committer = c.getCommitterIdent();
    }
    return true;
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#method_after
@Operator
public Predicate<ChangeData> change(String query) throws QueryParseException {
    if (PAT_LEGACY_ID.matcher(query).matches()) {
        return new LegacyChangeIdPredicate(args.getSchema(), Change.Id.parse(query));
    } else if (PAT_CHANGE_ID.matcher(query).matches()) {
        return new ChangeIdPredicate(parseChangeId(query));
    }
    Optional<ChangeTriplet> triplet = ChangeTriplet.parse(query);
    if (triplet.isPresent()) {
        return Predicate.and(project(triplet.get().project().get()), branch(triplet.get().branch().get()), new ChangeIdPredicate(parseChangeId(triplet.get().id().get())));
    }
    throw new QueryParseException("Invalid change format");
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> commit(String id) {
    if (id.length() == Constants.OBJECT_ID_STRING_LENGTH) {
        return new ExactCommitPredicate(id);
    }
    return new CommitPrefixPredicate(id);
}
#method_after
@Operator
public Predicate<ChangeData> commit(String id) {
    return new CommitPredicate(args.getSchema(), id);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) {
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    if (Strings.isNullOrEmpty(gitOAuthProvider)) {
        pickOnlyProvider();
    } else {
        pickConfiguredProvider();
    }
}
#end_block

#method_before
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(LIT_BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    byte[] decoded = Base64.decodeBase64(hdr.substring(LIT_BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    String username = usernamePassword.substring(0, splitPos);
    String tokenOrPassword = usernamePassword.substring(splitPos + 1);
    if (Strings.isNullOrEmpty(tokenOrPassword)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    if (authConfig.isUserNameToLowerCase()) {
        username = username.toLowerCase(Locale.US);
    }
    AccountState who = accountCache.getByUsername(username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest authRequest = AuthRequest.forExternalUser(username);
    authRequest.setEmailAddress(who.getAccount().getPreferredEmail());
    authRequest.setDisplayName(who.getAccount().getFullName());
    authRequest.setPassword(tokenOrPassword);
    try {
        AuthResult authResult = accountManager.authenticate(authRequest);
        WebSession ws = session.get();
        ws.setUserAccountId(authResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#method_after
private boolean verify(HttpServletRequest req, Response rsp) throws IOException {
    String hdr = req.getHeader(AUTHORIZATION);
    if (hdr == null || !hdr.startsWith(BASIC)) {
        // session cookie instead of basic authentication.
        return true;
    }
    byte[] decoded = Base64.decodeBase64(hdr.substring(BASIC.length()));
    String usernamePassword = new String(decoded, encoding(req));
    int splitPos = usernamePassword.indexOf(':');
    if (splitPos < 1) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthInfo authInfo = new AuthInfo(usernamePassword.substring(0, splitPos), usernamePassword.substring(splitPos + 1), defaultAuthPlugin, defaultAuthProvider);
    if (Strings.isNullOrEmpty(authInfo.tokenOrSecret)) {
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AccountState who = accountCache.getByUsername(authInfo.username);
    if (who == null || !who.getAccount().isActive()) {
        log.warn("Authentication failed for " + authInfo.username + ": account inactive or not provisioned in Gerrit");
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
    AuthRequest authRequest = AuthRequest.forExternalUser(authInfo.username);
    authRequest.setEmailAddress(who.getAccount().getPreferredEmail());
    authRequest.setDisplayName(who.getAccount().getFullName());
    authRequest.setPassword(authInfo.tokenOrSecret);
    authRequest.setAuthPlugin(authInfo.pluginName);
    authRequest.setAuthProvider(authInfo.exportName);
    try {
        AuthResult authResult = accountManager.authenticate(authRequest);
        WebSession ws = session.get();
        ws.setUserAccountId(authResult.getAccountId());
        ws.setAccessPathOk(AccessPath.GIT, true);
        ws.setAccessPathOk(AccessPath.REST_API, true);
        return true;
    } catch (AccountException e) {
        log.warn("Authentication failed for " + authInfo.username, e);
        rsp.sendError(SC_UNAUTHORIZED);
        return false;
    }
}
#end_block

#method_before
private String encoding(HttpServletRequest req) {
    return MoreObjects.firstNonNull(req.getCharacterEncoding(), "UTF-8");
}
#method_after
private static String encoding(HttpServletRequest req) {
    return MoreObjects.firstNonNull(req.getCharacterEncoding(), UTF_8.name());
}
#end_block

#method_before
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(LIT_BASIC);
        v.append("realm=\"").append(REALM_NAME).append("\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#method_after
private void status(int sc) {
    if (sc == SC_UNAUTHORIZED) {
        StringBuilder v = new StringBuilder();
        v.append(BASIC);
        v.append("realm=\"").append(REALM_NAME).append("\"");
        setHeader(WWW_AUTHENTICATE, v.toString());
    } else if (containsHeader(WWW_AUTHENTICATE)) {
        setHeader(WWW_AUTHENTICATE, null);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicItem.itemOf(binder(), OAuthLoginService.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    DynamicMap.mapOf(binder(), OAuthLoginProvider.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (who.getPassword() == null && who.getEmailAddress() != null) {
        return who;
    }
    if (loginService.get() == null) {
        log.warn("no implementation of OAuthLoginService available");
        return who;
    }
    OAuthUserInfo userInfo = loginService.get().login(who.getUserName(), who.getPassword());
    if (userInfo.getEmailAddress() != null) {
        who.setEmailAddress(userInfo.getEmailAddress());
    }
    if (userInfo.getDisplayName() != null) {
        who.setDisplayName(userInfo.getDisplayName());
    }
    return who;
}
#method_after
@Override
public AuthRequest authenticate(AuthRequest who) throws AccountException {
    if (Strings.isNullOrEmpty(who.getPassword()) && !Strings.isNullOrEmpty(who.getEmailAddress())) {
        return who;
    }
    if (Strings.isNullOrEmpty(who.getAuthPlugin()) || Strings.isNullOrEmpty(who.getAuthProvider())) {
        throw new AccountException("Cannot authenticate");
    }
    OAuthLoginProvider loginProvider = loginProviders.get(who.getAuthPlugin(), who.getAuthProvider());
    if (loginProvider == null) {
        throw new AccountException("Cannot authenticate");
    }
    OAuthUserInfo userInfo;
    try {
        userInfo = loginProvider.login(who.getUserName(), who.getPassword());
    } catch (IOException e) {
        throw new AccountException("Cannot authenticate", e);
    }
    if (userInfo == null) {
        throw new AccountException("Cannot authenticate");
    }
    if (!Strings.isNullOrEmpty(userInfo.getEmailAddress())) {
        who.setEmailAddress(userInfo.getEmailAddress());
    }
    if (!Strings.isNullOrEmpty(userInfo.getDisplayName())) {
        who.setDisplayName(userInfo.getDisplayName());
    }
    return who;
}
#end_block

#method_before
@Override
public AuthRequest link(ReviewDb db, Id to, AuthRequest who) {
    return who;
}
#method_after
@Override
public AuthRequest link(ReviewDb db, Account.Id to, AuthRequest who) {
    return who;
}
#end_block

#method_before
@Override
public AuthRequest unlink(ReviewDb db, Id to, AuthRequest who) throws AccountException {
    return who;
}
#method_after
@Override
public AuthRequest unlink(ReviewDb db, Account.Id to, AuthRequest who) throws AccountException {
    return who;
}
#end_block

#method_before
@Override
public Id lookup(String accountName) {
    return null;
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    return null;
}
#end_block

#method_before
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    setRangeHighlight(edit);
    if (edit) {
        String msg = comment.message();
        editArea.setValue(msg);
        cancel.setVisible(!isNew());
        expandText();
        editAreaHeight = editArea.getOffsetHeight();
        final int len = msg.length();
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                editArea.setFocus(true);
                if (len > 0) {
                    editArea.setCursorPos(len);
                }
            }
        });
    } else {
        expandTimer.cancel();
        resizeTimer.cancel();
    }
    getCommentManager().setUnsaved(this, edit);
    getCommentGroup().resize();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    setRangeHighlight(edit);
    if (edit) {
        String msg = comment.message() != null ? comment.message() : "";
        editArea.setValue(msg);
        cancel.setVisible(!isNew());
        expandText();
        editAreaHeight = editArea.getOffsetHeight();
        final int len = msg.length();
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                editArea.setFocus(true);
                if (len > 0) {
                    editArea.setCursorPos(len);
                }
            }
        });
    } else {
        expandTimer.cancel();
        resizeTimer.cancel();
    }
    getCommentManager().setUnsaved(this, edit);
    getCommentGroup().resize();
}
#end_block

#method_before
public DownloadScheme getDownloadUrl() {
    if (downloadUrl == null) {
        return null;
    }
    return DownloadScheme.valueOf(downloadUrl);
}
#method_after
public String getDownloadUrl() {
    // if accompanied by a 2-phase schema upgrade.)
    if (downloadUrl != null) {
        switch(downloadUrl) {
            case "ANON_GIT":
                return CoreDownloadSchemes.ANON_GIT;
            case "ANON_HTTP":
                return CoreDownloadSchemes.ANON_HTTP;
            case "HTTP":
                return CoreDownloadSchemes.HTTP;
            case "SSH":
                return CoreDownloadSchemes.SSH;
            case "REPO_DOWNLOAD":
                return CoreDownloadSchemes.REPO_DOWNLOAD;
        }
    }
    return downloadUrl;
}
#end_block

#method_before
public void setDownloadUrl(DownloadScheme url) {
    if (url != null) {
        downloadUrl = url.name();
    } else {
        downloadUrl = null;
    }
}
#method_after
public void setDownloadUrl(String url) {
    // if accompanied by a 2-phase schema upgrade.)
    if (downloadUrl != null) {
        switch(url) {
            case CoreDownloadSchemes.ANON_GIT:
                url = "ANON_GIT";
                break;
            case CoreDownloadSchemes.ANON_HTTP:
                url = "ANON_HTTP";
                break;
            case CoreDownloadSchemes.HTTP:
                url = "HTTP";
                break;
            case CoreDownloadSchemes.SSH:
                url = "SSH";
                break;
            case CoreDownloadSchemes.REPO_DOWNLOAD:
                url = "REPO_DOWNLOAD";
                break;
        }
    }
    downloadUrl = url;
}
#end_block

#method_before
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    reversePatchSetOrder = false;
    reviewCategoryStrategy = null;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    commentVisibilityStrategy = null;
    diffView = null;
    changeScreen = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
    emailingOptionsStrategy = null;
}
#method_after
public void resetToDefaults() {
    maximumPageSize = DEFAULT_PAGESIZE;
    showSiteHeader = true;
    useFlashClipboard = true;
    reviewCategoryStrategy = null;
    downloadUrl = null;
    downloadCommand = null;
    dateFormat = null;
    timeFormat = null;
    relativeDateInChangeTable = false;
    diffView = null;
    sizeBarInChangeTable = true;
    legacycidInChangeTable = false;
    muteCommonPathPrefixes = true;
    emailStrategy = null;
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    reversePatchSetOrder = new CheckBox(Util.C.reversePatchSetOrder());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    commentVisibilityStrategy = new ListBox();
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCollapseAll(), AccountGeneralPreferences.CommentVisibilityStrategy.COLLAPSE_ALL.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandMostRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_MOST_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandRecent(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_RECENT.name());
    commentVisibilityStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageExpandAll(), AccountGeneralPreferences.CommentVisibilityStrategy.EXPAND_ALL.name());
    emailingOptionsStrategy = new ListBox();
    emailingOptionsStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageDefaultNone(), AccountGeneralPreferences.EmailingOptionsStrategy.NONE.name());
    emailingOptionsStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageCCMeOnMyComments(), AccountGeneralPreferences.EmailingOptionsStrategy.CC_ME_ON_COMMENTS_I_WRITE.name());
    emailingOptionsStrategy.addItem(com.google.gerrit.client.changes.Util.C.messageDisableEmailNotifications(), AccountGeneralPreferences.EmailingOptionsStrategy.DISABLE_EMAIL_NOTIFICATIONS.name());
    changeScreen = new ListBox();
    changeScreen.addItem(Util.M.changeScreenServerDefault(getLabel(Gerrit.getConfig().getChangeScreen())), "");
    changeScreen.addItem(Util.C.changeScreenOldUi(), AccountGeneralPreferences.ChangeScreen.OLD_UI.name());
    changeScreen.addItem(Util.C.changeScreenNewUi(), AccountGeneralPreferences.ChangeScreen.CHANGE_SCREEN2.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx, fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    final Grid formGrid = new Grid(13, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, useFlashClipboard);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, reversePatchSetOrder);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
        row++;
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.commentVisibilityLabel());
    formGrid.setWidget(row, fieldIdx, commentVisibilityStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailingOptionsFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailingOptionsStrategy);
    row++;
    if (Gerrit.getConfig().getNewFeatures()) {
        formGrid.setText(row, labelIdx, Util.C.changeScreenLabel());
        formGrid.setWidget(row, fieldIdx, changeScreen);
        row++;
        formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
        formGrid.setWidget(row, fieldIdx, diffView);
    }
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(reversePatchSetOrder);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(commentVisibilityStrategy);
    e.listenTo(changeScreen);
    e.listenTo(diffView);
    e.listenTo(emailingOptionsStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferences.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    emailStrategy = new ListBox();
    emailStrategy.addItem(Util.C.messageEnabled(), AccountGeneralPreferences.EmailStrategy.ENABLED.name());
    emailStrategy.addItem(Util.C.messageCCMeOnMyComments(), AccountGeneralPreferences.EmailStrategy.CC_ON_OWN_COMMENTS.name());
    emailStrategy.addItem(Util.C.messageDisabled(), AccountGeneralPreferences.EmailStrategy.DISABLED.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(11 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.emailFieldLabel());
    formGrid.setWidget(row, fieldIdx, emailStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
    e.listenTo(emailStrategy);
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<Preferences>(this) {

        @Override
        public void preDisplay(Preferences prefs) {
            display(prefs);
        }
    });
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    ExtensionPanel extensionPanel = createExtensionPoint(GerritUiExtensionPoint.PREFERENCES_SCREEN_BOTTOM);
    extensionPanel.addStyleName(Gerrit.RESOURCES.css().extensionPanel());
    add(extensionPanel);
    AccountApi.self().view("preferences").get(new ScreenLoadCallback<AccountPreferencesInfo>(this) {

        @Override
        public void preDisplay(AccountPreferencesInfo prefs) {
            display(prefs);
        }
    });
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    reversePatchSetOrder.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    commentVisibilityStrategy.setEnabled(on);
    changeScreen.setEnabled(on);
    diffView.setEnabled(on);
    emailingOptionsStrategy.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
    emailStrategy.setEnabled(on);
}
#end_block

#method_before
private void display(JsArray<TopMenuItem> items) {
    List<List<String>> values = new ArrayList<>();
    for (TopMenuItem item : Natives.asList(items)) {
        values.add(Arrays.asList(item.getName(), item.getUrl()));
    }
    myMenus.display(values);
}
#method_after
private void display(AccountPreferencesInfo p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    setListBox(emailStrategy, AccountGeneralPreferences.EmailStrategy.ENABLED, p.emailStrategy());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setReversePatchSetOrder(reversePatchSetOrder.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setCommentVisibilityStrategy(getListBox(commentVisibilityStrategy, CommentVisibilityStrategy.EXPAND_RECENT, CommentVisibilityStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.setEmailingOptionsStrategy(getListBox(emailingOptionsStrategy, EmailingOptionsStrategy.NONE, EmailingOptionsStrategy.values()));
    p.setChangeScreen(getListBox(changeScreen, null, AccountGeneralPreferences.ChangeScreen.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").post(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            Dispatcher.changeScreen2 = false;
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    AccountPreferencesInfo p = AccountPreferencesInfo.create();
    p.showSiteHeader(showSiteHeader.getValue());
    p.useFlashClipboard(useFlashClipboard.getValue());
    p.changesPerPage(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.dateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.timeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.relativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.sizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.legacycidInChangeTable(legacycidInChangeTable.getValue());
    p.muteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.reviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.diffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    p.emailStrategy(getListBox(emailStrategy, EmailStrategy.ENABLED, EmailStrategy.values()));
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    p.setMyMenus(items);
    enable(false);
    save.setEnabled(false);
    AccountApi.self().view("preferences").put(p, new GerritCallback<AccountPreferencesInfo>() {

        @Override
        public void onSuccess(AccountPreferencesInfo prefs) {
            Gerrit.setUserPreferences(prefs);
            enable(true);
            display(prefs);
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    db.get().accounts().beginTransaction(accountId);
    try {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            p.setDownloadUrl(i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.reversePatchSetOrder != null) {
            p.setReversePatchSetOrder(i.reversePatchSetOrder);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.commentVisibilityStrategy != null) {
            p.setCommentVisibilityStrategy(i.commentVisibilityStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.emailingOptionsStrategy != null) {
            p.setEmailingOptionsStrategy(i.emailingOptionsStrategy);
        }
        if (i.changeScreen != null) {
            p.setChangeScreen(i.changeScreen);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.get().rollback();
    }
}
#method_after
@Override
public GetPreferences.PreferenceInfo apply(AccountResource rsrc, Input i) throws AuthException, ResourceNotFoundException, BadRequestException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canModifyAccount()) {
        throw new AuthException("restricted to members of Modify Accounts");
    }
    if (i == null) {
        i = new Input();
    }
    Account.Id accountId = rsrc.getUser().getAccountId();
    AccountGeneralPreferences p;
    VersionedAccountPreferences versionedPrefs;
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    db.get().accounts().beginTransaction(accountId);
    try {
        Account a = db.get().accounts().get(accountId);
        if (a == null) {
            throw new ResourceNotFoundException();
        }
        versionedPrefs = VersionedAccountPreferences.forUser(accountId);
        versionedPrefs.load(md);
        p = a.getGeneralPreferences();
        if (p == null) {
            p = new AccountGeneralPreferences();
            a.setGeneralPreferences(p);
        }
        if (i.changesPerPage != null) {
            p.setMaximumPageSize(i.changesPerPage);
        }
        if (i.showSiteHeader != null) {
            p.setShowSiteHeader(i.showSiteHeader);
        }
        if (i.useFlashClipboard != null) {
            p.setUseFlashClipboard(i.useFlashClipboard);
        }
        if (i.downloadScheme != null) {
            setDownloadScheme(p, i.downloadScheme);
        }
        if (i.downloadCommand != null) {
            p.setDownloadCommand(i.downloadCommand);
        }
        if (i.dateFormat != null) {
            p.setDateFormat(i.dateFormat);
        }
        if (i.timeFormat != null) {
            p.setTimeFormat(i.timeFormat);
        }
        if (i.relativeDateInChangeTable != null) {
            p.setRelativeDateInChangeTable(i.relativeDateInChangeTable);
        }
        if (i.sizeBarInChangeTable != null) {
            p.setSizeBarInChangeTable(i.sizeBarInChangeTable);
        }
        if (i.legacycidInChangeTable != null) {
            p.setLegacycidInChangeTable(i.legacycidInChangeTable);
        }
        if (i.muteCommonPathPrefixes != null) {
            p.setMuteCommonPathPrefixes(i.muteCommonPathPrefixes);
        }
        if (i.reviewCategoryStrategy != null) {
            p.setReviewCategoryStrategy(i.reviewCategoryStrategy);
        }
        if (i.diffView != null) {
            p.setDiffView(i.diffView);
        }
        if (i.emailStrategy != null) {
            p.setEmailStrategy(i.emailStrategy);
        }
        db.get().accounts().update(Collections.singleton(a));
        db.get().commit();
        storeMyMenus(versionedPrefs, i.my);
        storeUrlAliases(versionedPrefs, i.urlAliases);
        versionedPrefs.commit(md);
        cache.evict(accountId);
        return new GetPreferences.PreferenceInfo(p, versionedPrefs, md.getRepository());
    } finally {
        md.close();
        db.get().rollback();
    }
}
#end_block

#method_before
public static void storeMyMenus(VersionedAccountPreferences prefs, List<TopMenu.MenuItem> my) {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, MY);
        for (TopMenu.MenuItem item : my) {
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#method_after
public static void storeMyMenus(VersionedAccountPreferences prefs, List<TopMenu.MenuItem> my) {
    Config cfg = prefs.getConfig();
    if (my != null) {
        unsetSection(cfg, UserConfigSections.MY);
        for (TopMenu.MenuItem item : my) {
            set(cfg, item.name, KEY_URL, item.url);
            set(cfg, item.name, KEY_TARGET, item.target);
            set(cfg, item.name, KEY_ID, item.id);
        }
    }
}
#end_block

#method_before
private static void set(Config cfg, String section, String key, String val) {
    if (Strings.isNullOrEmpty(val)) {
        cfg.unset(MY, section, key);
    } else {
        cfg.setString(MY, section, key, val);
    }
}
#method_after
private static void set(Config cfg, String section, String key, String val) {
    if (Strings.isNullOrEmpty(val)) {
        cfg.unset(UserConfigSections.MY, section, key);
    } else {
        cfg.setString(UserConfigSections.MY, section, key, val);
    }
}
#end_block

#method_before
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(velocifyFile("Footer.vm"));
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            EmailingOptionsStrategy selectedEmailOption = fromUser.getGeneralPreferences().getEmailingOptionsStrategy();
            if (selectedEmailOption.equals(EmailingOptionsStrategy.CC_ME_ON_COMMENTS_I_WRITE)) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (selectedEmailOption.equals(EmailingOptionsStrategy.DISABLE_EMAIL_NOTIFICATIONS) || rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                final String fromEmail = fromUser.getPreferredEmail();
                for (Iterator<Address> i = smtpRcptTo.iterator(); i.hasNext(); ) {
                    if (i.next().email.equals(fromEmail)) {
                        i.remove();
                    }
                }
                for (EmailHeader hdr : headers.values()) {
                    if (hdr instanceof AddressList) {
                        ((AddressList) hdr).remove(fromEmail);
                    }
                }
            }
            // his email notifications then drop him from recipients' list
            for (Iterator<Account.Id> i = rcptTo.iterator(); i.hasNext(); ) {
                Account.Id id = i.next();
                Account thisUser = args.accountCache.get(id).getAccount();
                if (thisUser.getGeneralPreferences().getEmailingOptionsStrategy().equals(EmailingOptionsStrategy.DISABLE_EMAIL_NOTIFICATIONS)) {
                    final String fromEmail = thisUser.getPreferredEmail();
                    for (Iterator<Address> j = smtpRcptTo.iterator(); j.hasNext(); ) {
                        if (j.next().email.equals(fromEmail)) {
                            j.remove();
                        }
                    }
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        args.emailSender.send(smtpFromAddress, smtpRcptTo, headers, body.toString());
    }
}
#method_after
public void send() throws EmailException {
    if (!args.emailSender.isEnabled()) {
        // 
        return;
    }
    init();
    format();
    appendText(velocifyFile("Footer.vm"));
    if (shouldSendMessage()) {
        if (fromId != null) {
            final Account fromUser = args.accountCache.get(fromId).getAccount();
            EmailStrategy strategy = fromUser.getGeneralPreferences().getEmailStrategy();
            if (strategy == EmailStrategy.CC_ON_OWN_COMMENTS) {
                // If we are impersonating a user, make sure they receive a CC of
                // this message so they can always review and audit what we sent
                // on their behalf to others.
                // 
                add(RecipientType.CC, fromId);
            } else if (rcptTo.remove(fromId)) {
                // If they don't want a copy, but we queued one up anyway,
                // drop them from the recipient lists.
                // 
                removeUser(fromUser);
            }
            // his email notifications then drop him from recipients' list
            for (Account.Id id : rcptTo) {
                Account thisUser = args.accountCache.get(id).getAccount();
                if (thisUser.getGeneralPreferences().getEmailStrategy() == EmailStrategy.DISABLED) {
                    removeUser(thisUser);
                }
                if (smtpRcptTo.isEmpty()) {
                    return;
                }
            }
        }
        OutgoingEmailValidationListener.Args va = new OutgoingEmailValidationListener.Args();
        va.messageClass = messageClass;
        va.smtpFromAddress = smtpFromAddress;
        va.smtpRcptTo = smtpRcptTo;
        va.headers = headers;
        va.body = body.toString();
        for (OutgoingEmailValidationListener validator : args.outgoingEmailValidationListeners) {
            try {
                validator.validateOutgoingEmail(va);
            } catch (ValidationException e) {
                return;
            }
        }
        args.emailSender.send(va.smtpFromAddress, va.smtpRcptTo, va.headers, va.body);
    }
}
#end_block

#method_before
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return args.anonymousCowardName;
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = args.anonymousCowardName + " #" + accountId;
    }
    return name;
}
#method_after
protected String getNameFor(final Account.Id accountId) {
    if (accountId == null) {
        return args.gerritPersonIdent.getName();
    }
    final Account userAccount = args.accountCache.get(accountId).getAccount();
    String name = userAccount.getFullName();
    if (name == null) {
        name = userAccount.getPreferredEmail();
    }
    if (name == null) {
        name = args.anonymousCowardName + " #" + accountId;
    }
    return name;
}
#end_block

#method_before
protected String velocifyFile(String name) throws EmailException {
    try {
        RuntimeInstance runtime = args.velocityRuntime;
        if (runtime.getLoaderNameForResource(name) == null) {
            name = "com/google/gerrit/server/mail/" + name;
        }
        Template template = runtime.getTemplate(name, "UTF-8");
        StringWriter w = new StringWriter();
        template.merge(velocityContext, w);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Cannot format velocity template " + name, e);
    }
}
#method_after
protected String velocifyFile(String name) throws EmailException {
    try {
        RuntimeInstance runtime = args.velocityRuntime;
        if (runtime.getLoaderNameForResource(name) == null) {
            name = "com/google/gerrit/server/mail/" + name;
        }
        Template template = runtime.getTemplate(name, UTF_8.name());
        StringWriter w = new StringWriter();
        template.merge(velocityContext, w);
        return w.toString();
    } catch (Exception e) {
        throw new EmailException("Cannot format velocity template " + name, e);
    }
}
#end_block

#method_before
@Override
public PreferenceInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account a = db.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException();
    }
    Repository git = gitMgr.openRepository(allUsersName);
    try {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        return new PreferenceInfo(a.getGeneralPreferences(), p, git);
    } finally {
        git.close();
    }
}
#method_after
@Override
public PreferenceInfo apply(AccountResource rsrc) throws AuthException, ResourceNotFoundException, OrmException, IOException, ConfigInvalidException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account a = db.get().accounts().get(rsrc.getUser().getAccountId());
    if (a == null) {
        throw new ResourceNotFoundException();
    }
    try (Repository git = gitMgr.openRepository(allUsersName)) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        return new PreferenceInfo(a.getGeneralPreferences(), p, git);
    }
}
#end_block

#method_before
private List<TopMenu.MenuItem> my(VersionedAccountPreferences v) {
    List<TopMenu.MenuItem> my = new ArrayList<>();
    Config cfg = v.getConfig();
    for (String subsection : cfg.getSubsections(MY)) {
        String url = my(cfg, subsection, KEY_URL, "#/");
        String target = my(cfg, subsection, KEY_TARGET, url.startsWith("#") ? null : "_blank");
        my.add(new TopMenu.MenuItem(subsection, url, target, my(cfg, subsection, KEY_ID, null)));
    }
    return my;
}
#method_after
private List<TopMenu.MenuItem> my(VersionedAccountPreferences v) {
    List<TopMenu.MenuItem> my = new ArrayList<>();
    Config cfg = v.getConfig();
    for (String subsection : cfg.getSubsections(UserConfigSections.MY)) {
        String url = my(cfg, subsection, KEY_URL, "#/");
        String target = my(cfg, subsection, KEY_TARGET, url.startsWith("#") ? null : "_blank");
        my.add(new TopMenu.MenuItem(subsection, url, target, my(cfg, subsection, KEY_ID, null)));
    }
    return my;
}
#end_block

#method_before
private static String my(Config cfg, String subsection, String key, String defaultValue) {
    String val = cfg.getString(MY, subsection, key);
    return !Strings.isNullOrEmpty(val) ? val : defaultValue;
}
#method_after
private static String my(Config cfg, String subsection, String key, String defaultValue) {
    String val = cfg.getString(UserConfigSections.MY, subsection, key);
    return !Strings.isNullOrEmpty(val) ? val : defaultValue;
}
#end_block

#method_before
@Override
public Object apply(ConfigResource rsrc, Input i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.reversePatchSetOrder != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.reviewCategoryStrategy != null || i.commentVisibilityStrategy != null || i.diffView != null || i.emailingOptionsStrategy != null || i.changeScreen != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        return new PreferenceInfo(null, p, md.getRepository());
    } finally {
        md.close();
    }
}
#method_after
@Override
public Object apply(ConfigResource rsrc, Input i) throws BadRequestException, IOException, ConfigInvalidException {
    if (i.changesPerPage != null || i.showSiteHeader != null || i.useFlashClipboard != null || i.downloadScheme != null || i.downloadCommand != null || i.dateFormat != null || i.timeFormat != null || i.relativeDateInChangeTable != null || i.sizeBarInChangeTable != null || i.legacycidInChangeTable != null || i.muteCommonPathPrefixes != null || i.reviewCategoryStrategy != null || i.emailStrategy != null) {
        throw new BadRequestException("unsupported option");
    }
    VersionedAccountPreferences p;
    MetaDataUpdate md = metaDataUpdateFactory.get().create(allUsersName);
    try {
        p = VersionedAccountPreferences.forDefault();
        p.load(md);
        com.google.gerrit.server.account.SetPreferences.storeMyMenus(p, i.my);
        p.commit(md);
        return new PreferenceInfo(null, p, md.getRepository());
    } finally {
        md.close();
    }
}
#end_block

#method_before
@Override
public boolean allowsEdit(final Account.FieldName field) {
    if (authConfig.getAuthType() == AuthType.HTTP) {
        switch(field) {
            case USER_NAME:
                return false;
            case FULL_NAME:
                return Strings.emptyToNull(authConfig.getHttpDisplaynameHeader()) == null;
            case REGISTER_NEW_EMAIL:
                return emailSettings.allowRegisterNewEmail && Strings.emptyToNull(authConfig.getHttpEmailHeader()) == null;
            default:
                return true;
        }
    } else {
        return true;
    }
}
#method_after
@Override
public boolean allowsEdit(final Account.FieldName field) {
    if (authConfig.getAuthType() == AuthType.HTTP) {
        switch(field) {
            case USER_NAME:
                return false;
            case FULL_NAME:
                return Strings.emptyToNull(authConfig.getHttpDisplaynameHeader()) == null;
            case REGISTER_NEW_EMAIL:
                return emailSettings.allowRegisterNewEmail && Strings.emptyToNull(authConfig.getHttpEmailHeader()) == null;
            default:
                return true;
        }
    } else {
        switch(field) {
            case REGISTER_NEW_EMAIL:
                return emailSettings.allowRegisterNewEmail;
            default:
                return true;
        }
    }
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, userFactory, Providers.of(otherUser), capabilityControlFactory, groupDetailFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, patchListCache, repoManager, projectCache, groupCache, listChildProjects, indexes, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, userFactory, Providers.of(otherUser), capabilityControlFactory, groupDetailFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, patchListCache, repoManager, projectCache, groupCache, listChildProjects, indexes, submitStrategyFactory, conflictsCache, trackingFooters, indexConfig, allowsDrafts);
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                // convert to account
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand group predicate into multiple user predicates
    if (group != null) {
        final Set<Account.Id> memberIds = getMemberIds(group, new HashSet<AccountGroup.UUID>());
        accounts = memberIds;
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#method_after
@Operator
public Predicate<ChangeData> label(String name) throws QueryParseException, OrmException {
    Set<Account.Id> accounts = null;
    AccountGroup.UUID group = null;
    // Parse for:
    // label:CodeReview=1,user=jsmith or
    // label:CodeReview=1,jsmith or
    // label:CodeReview=1,group=android_approvers or
    // label:CodeReview=1,android_approvers
    // user/groups without a label will first attempt to match user
    String[] splitReviewer = name.split(",", 2);
    // remove all but the vote piece, e.g.'CodeReview=1'
    name = splitReviewer[0];
    if (splitReviewer.length == 2) {
        // process the user/group piece
        PredicateArgs lblArgs = new PredicateArgs(splitReviewer[1]);
        for (Map.Entry<String, String> pair : lblArgs.keyValue.entrySet()) {
            if (pair.getKey().equalsIgnoreCase(ARG_ID_USER)) {
                accounts = parseAccount(pair.getValue());
            } else if (pair.getKey().equalsIgnoreCase(ARG_ID_GROUP)) {
                group = parseGroup(pair.getValue()).getUUID();
            } else {
                throw new QueryParseException("Invalid argument identifier '" + pair.getKey() + "'");
            }
        }
        for (String value : lblArgs.positional) {
            if (accounts != null || group != null) {
                throw new QueryParseException("more than one user/group specified (" + value + ")");
            }
            try {
                accounts = parseAccount(value);
            } catch (QueryParseException qpex) {
                // (accounts get precedence)
                try {
                    group = parseGroup(value).getUUID();
                } catch (QueryParseException e) {
                    throw error("Neither user nor group " + value + " found");
                }
            }
        }
    }
    // expand a group predicate into multiple user predicates
    if (group != null) {
        Set<Account.Id> allMembers = getMemberIds(group, new HashSet<AccountGroup.UUID>());
        int maxTerms = args.indexConfig.maxLimit();
        if (allMembers.size() > maxTerms) {
            // limit the number of query terms otherwise Gerrit will barf
            accounts = ImmutableSet.copyOf(Iterables.limit(allMembers, maxTerms));
        } else {
            accounts = allMembers;
        }
    }
    return new LabelPredicate(args.projectCache, args.changeControlGenericFactory, args.userFactory, args.db, name, accounts, group);
}
#end_block

#method_before
private Set<Account.Id> getMemberIds(final AccountGroup.UUID groupUUID, final HashSet<AccountGroup.UUID> seenGroups) throws OrmException {
    seenGroups.add(groupUUID);
    final Set<Account.Id> members = new HashSet<Account.Id>();
    final AccountGroup group = args.groupCache.get(groupUUID);
    if (group == null) {
        // the included group is an external group and can't be resolved
        return new HashSet<Account.Id>();
    }
    final GroupDetail groupDetail;
    try {
        groupDetail = args.groupDetailFactory.create(group.getId()).call();
    } catch (NoSuchGroupException e) {
        // the included group is not visible
        return new HashSet<Account.Id>();
    }
    if (groupDetail.members != null) {
        for (final AccountGroupMember m : groupDetail.members) {
            if (!members.contains(m.getAccountId())) {
                members.add(m.getAccountId());
            }
        }
    }
    // get members of subgroups
    if (groupDetail.includes != null) {
        for (final AccountGroupById includedGroup : groupDetail.includes) {
            if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                members.addAll(getMemberIds(includedGroup.getIncludeUUID(), seenGroups));
            }
        }
    }
    return members;
}
#method_after
private Set<Account.Id> getMemberIds(AccountGroup.UUID groupUUID, Set<AccountGroup.UUID> seenGroups) throws OrmException {
    seenGroups.add(groupUUID);
    Set<Account.Id> members = new HashSet<>();
    AccountGroup group = args.groupCache.get(groupUUID);
    if (group != null) {
        try {
            GroupDetail groupDetail = args.groupDetailFactory.create(group.getId()).call();
            if (groupDetail.members != null) {
                for (AccountGroupMember m : groupDetail.members) {
                    if (!members.contains(m.getAccountId())) {
                        members.add(m.getAccountId());
                    }
                }
            }
            // Get members of subgroups
            if (groupDetail.includes != null) {
                for (AccountGroupById includedGroup : groupDetail.includes) {
                    if (!seenGroups.contains(includedGroup.getIncludeUUID())) {
                        members.addAll(getMemberIds(includedGroup.getIncludeUUID(), seenGroups));
                    }
                }
            }
        } catch (NoSuchGroupException e) {
        // The included group is not visible
        }
    }
    return members;
}
#end_block

#method_before
private String createGroup(String name, String owner) throws Exception {
    GroupInput in = new GroupInput();
    in.name = name;
    in.ownerId = owner;
    gApi.groups().create(in);
    return name;
}
#method_after
private void createGroup(String name, AccountGroup.Id owner, Account.Id member) throws Exception {
    CreateGroupArgs args = new CreateGroupArgs();
    args.setGroupName(name);
    args.ownerGroupId = owner;
    args.initialMembers = ImmutableList.of(member);
    performCreateGroupFactory.create(args).createGroup();
}
#end_block

#method_before
@Test
public void byLabelGroup() throws Exception {
    Account.Id user1 = accountManager.authenticate(AuthRequest.forUser("user1")).getAccountId();
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("user2")).getAccountId();
    TestRepository<Repo> repo = createProject("repo");
    // create group and add users
    String g1 = createGroup("group1", "Administrators");
    String g2 = createGroup("group2", "Administrators");
    gApi.groups().id(g1).addMembers("user1");
    gApi.groups().id(g2).addMembers("user2");
    // create a change
    ChangeInserter ins = newChange(repo, null, null, user1.get(), null);
    Change change1 = insert(ins);
    // post a review with user1
    requestContext.setContext(newRequestContext(user1));
    gApi.changes().id(change1.getId().get()).current().review(new ReviewInput().label("Code-Review", 1));
    // verify that query with user1 will return results.
    requestContext.setContext(newRequestContext(userId));
    assertQuery("label:Code-Review=+1,group1", change1);
    assertQuery("label:Code-Review=+1,group=group1", change1);
    assertQuery("label:Code-Review=+1,user=user1", change1);
    assertQuery("label:Code-Review=+1,user=user2");
    assertQuery("label:Code-Review=+1,group=group2");
}
#method_after
@Test
public void byLabelGroup() throws Exception {
    Account.Id user1 = accountManager.authenticate(AuthRequest.forUser("user1")).getAccountId();
    Account.Id user2 = accountManager.authenticate(AuthRequest.forUser("user2")).getAccountId();
    TestRepository<InMemoryRepository> repo = createProject("repo");
    // create group and add users
    AccountGroup.Id adminGroup = groupCache.get(new AccountGroup.NameKey("Administrators")).getId();
    createGroup("group1", adminGroup, user1);
    createGroup("group2", adminGroup, user2);
    // create a change
    ChangeInserter ins = newChange(repo, null, null, user1.get(), null);
    Change change1 = ins.insert();
    // post a review with user1
    requestContext.setContext(newRequestContext(user1));
    ReviewInput input = new ReviewInput();
    input.labels = ImmutableMap.<String, Short>of("Code-Review", (short) 1);
    postReview.apply(new RevisionResource(changes.parse(change1.getId()), ins.getPatchSet()), input);
    // verify that query with user1 will return results.
    requestContext.setContext(newRequestContext(userId));
    assertResultEquals(change1, queryOne("label:Code-Review=+1,group1"));
    assertResultEquals(change1, queryOne("label:Code-Review=+1,group=group1"));
    assertResultEquals(change1, queryOne("label:Code-Review=+1,user=user1"));
    assertThat(query("label:Code-Review=+1,user=user2")).isEmpty();
    assertThat(query("label:Code-Review=+1,group=group2")).isEmpty();
}
#end_block

#method_before
private void doSearch() {
    final String query = searchBox.getText().trim();
    if ("".equals(query)) {
        return;
    }
    searchBox.setFocus(false);
    switch(dropdown.getSelectedIndex()) {
        case 0:
            // changes
            if (query.matches("^[1-9][0-9]*$")) {
                Gerrit.display(PageLinks.toChange(Change.Id.parse(query)));
            } else {
                Gerrit.display(PageLinks.toChangeQuery(query), QueryScreen.forQuery(query));
            }
            break;
        case 1:
            // doc
            Gerrit.display(PageLinks.toDocumentationQuery(query));
            break;
    }
}
#method_after
private void doSearch() {
    final String query = searchBox.getText().trim();
    if ("".equals(query)) {
        return;
    }
    searchBox.setFocus(false);
    if (dropdown != null && dropdown.getSelectedValue().equals(Gerrit.C.searchDropdownDoc())) {
        // doc
        Gerrit.display(PageLinks.toDocumentationQuery(query));
    } else {
        // changes
        if (query.matches("^[1-9][0-9]*$")) {
            Gerrit.display(PageLinks.toChange(Change.Id.parse(query)));
        } else {
            Gerrit.display(PageLinks.toChangeQuery(query), QueryScreen.forQuery(query));
        }
    }
}
#end_block

#method_before
@Override
public void deleteVote(String vote) throws RestApiException {
    try {
        deleteVote.apply(new VoteResource(reviewer, vote), null);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot delete vote", e);
    }
}
#method_after
@Override
public void deleteVote(String label) throws RestApiException {
    try {
        deleteVote.apply(new VoteResource(reviewer, label), null);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot delete vote", e);
    }
}
#end_block

#method_before
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    for (PatchSetApproval psa : approvalsUtil.byChangeUser(db.get(), rsrc.getNotes(), rsrc.getUser().getAccountId())) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#method_after
@Override
public Map<String, Short> apply(ReviewerResource rsrc) throws OrmException {
    Map<String, Short> votes = new TreeMap<>();
    Iterable<PatchSetApproval> byPatchSetUser = approvalsUtil.byPatchSetUser(db.get(), rsrc.getControl(), rsrc.getChange().currentPatchSetId(), rsrc.getUser().getAccountId());
    for (PatchSetApproval psa : byPatchSetUser) {
        votes.put(psa.getLabel(), psa.getValue());
    }
    return votes;
}
#end_block

#method_before
@Override
public String id() {
    return Integer.toString(change.getChange().getId().get());
}
#method_after
@Override
public String id() {
    return Integer.toString(change.getId().get());
}
#end_block

#method_before
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#method_after
@Override
public RevisionApi revision(String id) throws RestApiException {
    try {
        return revisionApi.create(revisions.parse(change, IdString.fromDecoded(id)));
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot parse revision", e);
    }
}
#end_block

#method_before
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#method_after
@Override
public void abandon(AbandonInput in) throws RestApiException {
    try {
        abandon.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot abandon change", e);
    }
}
#end_block

#method_before
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#method_after
@Override
public void restore(RestoreInput in) throws RestApiException {
    try {
        restore.apply(change, in);
    } catch (OrmException | UpdateException e) {
        throw new RestApiException("Cannot restore change", e);
    }
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        return changeJson.get().addOptions(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        CurrentUser u = user.get();
        if (u.isIdentifiedUser()) {
            u.asIdentifiedUser().clearStarredChanges();
        }
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(Changes.class).to(ChangesImpl.class);
    factory(ChangeApiImpl.Factory.class);
    factory(RevisionApiImpl.Factory.class);
    factory(ReviewerApiImpl.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(Changes.class).to(ChangesImpl.class);
    factory(ChangeApiImpl.Factory.class);
    factory(CommentApiImpl.Factory.class);
    factory(DraftApiImpl.Factory.class);
    factory(RevisionApiImpl.Factory.class);
    factory(FileApiImpl.Factory.class);
    factory(ReviewerApiImpl.Factory.class);
}
#end_block

#method_before
@Test
public void get() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = "p~master~" + r.getChangeId();
    ChangeInfo c = info(triplet);
    assertThat(c.id).isEqualTo(triplet);
    assertThat(c.project).isEqualTo("p");
    assertThat(c.branch).isEqualTo("master");
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
    assertThat(c.subject).isEqualTo("test commit");
    assertThat(c.mergeable).isTrue();
    assertThat(c.changeId).isEqualTo(r.getChangeId());
    assertThat(c.created).isEqualTo(c.updated);
    assertThat(c._number).is(1);
    assertThat(c.owner._accountId).is(admin.getId().get());
    assertThat(c.owner.name).isNull();
    assertThat(c.owner.email).isNull();
    assertThat(c.owner.username).isNull();
    assertThat(c.owner.avatars).isNull();
}
#method_after
@Test
public void get() throws Exception {
    PushOneCommit.Result r = createChange();
    String triplet = project.get() + "~master~" + r.getChangeId();
    ChangeInfo c = info(triplet);
    assertThat(c.id).isEqualTo(triplet);
    assertThat(c.project).isEqualTo(project.get());
    assertThat(c.branch).isEqualTo("master");
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
    assertThat(c.subject).isEqualTo("test commit");
    assertThat(c.mergeable).isTrue();
    assertThat(c.changeId).isEqualTo(r.getChangeId());
    assertThat(c.created).isEqualTo(c.updated);
    assertThat(c._number).isEqualTo(r.getChange().getId().get());
    assertThat(c.owner._accountId).isEqualTo(admin.getId().get());
    assertThat(c.owner.name).isNull();
    assertThat(c.owner.email).isNull();
    assertThat(c.owner.username).isNull();
    assertThat(c.owner.avatars).isNull();
}
#end_block

#method_before
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).abandon();
}
#method_after
@Test
public void abandon() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(r.getChangeId()).abandon();
    ChangeInfo info = get(r.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.ABANDONED);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("abandoned");
}
#end_block

#method_before
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).abandon();
    gApi.changes().id(r.getChangeId()).restore();
}
#method_after
@Test
public void restore() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.NEW);
    gApi.changes().id(r.getChangeId()).abandon();
    assertThat(info(r.getChangeId()).status).isEqualTo(ChangeStatus.ABANDONED);
    gApi.changes().id(r.getChangeId()).restore();
    ChangeInfo info = get(r.getChangeId());
    assertThat(info.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info.messages).message.toLowerCase()).contains("restored");
}
#end_block

#method_before
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    gApi.changes().id(r.getChangeId()).revert();
}
#method_after
@Test
public void revert() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo revertChange = gApi.changes().id(r.getChangeId()).revert().get();
    // expected messages on source change:
    // 1. Uploaded patch set 1.
    // 2. Patch Set 1: Code-Review+2
    // 3. Change has been successfully merged by Administrator
    // 4. Patch Set 1: Reverted
    List<ChangeMessageInfo> sourceMessages = new ArrayList<>(gApi.changes().id(r.getChangeId()).get().messages);
    assertThat(sourceMessages).hasSize(4);
    String expectedMessage = String.format("Patch Set 1: Reverted\n\n" + "This patchset was reverted in change: %s", revertChange.changeId);
    assertThat(sourceMessages.get(3).message).isEqualTo(expectedMessage);
    assertThat(revertChange.messages).hasSize(1);
    assertThat(revertChange.messages.iterator().next().message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test(expected = ResourceConflictException.class)
public void rebase() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).rebase();
}
#method_after
@Test
public void rebase() throws Exception {
    // Create two changes both with the same parent
    PushOneCommit.Result r = createChange();
    testRepo.reset("HEAD~1");
    PushOneCommit.Result r2 = createChange();
    // Approve and submit the first change
    RevisionApi revision = gApi.changes().id(r.getChangeId()).current();
    revision.review(ReviewInput.approve());
    revision.submit();
    // Rebase the second change
    gApi.changes().id(r2.getChangeId()).current().rebase();
    // Second change should have 2 patch sets
    assertThat(r2.getPatchSetId().get()).isEqualTo(2);
    // ...and the committer should be correct
    ChangeInfo info = gApi.changes().id(r2.getChangeId()).get(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT));
    GitPerson committer = info.revisions.get(info.currentRevision).commit.committer;
    assertThat(committer.name).isEqualTo(admin.fullName);
    assertThat(committer.email).isEqualTo(admin.email);
}
#end_block

#method_before
@Test
public void addReviewer() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(user.id));
}
#method_after
@Test
public void addReviewer() throws Exception {
    PushOneCommit.Result r = createChange();
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    // When notedb is enabled adding a reviewer records that user as reviewer
    // in notedb. When notedb is disabled adding a reviewer results in a dummy 0
    // approval on the change which is treated as CC when the ChangeInfo is
    // created.
    Collection<AccountInfo> reviewers = isNoteDbTestEnabled() ? c.reviewers.get(REVIEWER) : c.reviewers.get(CC);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(user.getId().get());
}
#end_block

#method_before
@Test
public void addReviewerToClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.id));
}
#method_after
@Test
public void addReviewerToClosedChange() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).submit();
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    Collection<AccountInfo> reviewers = c.reviewers.get(REVIEWER);
    assertThat(reviewers).hasSize(1);
    assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get());
    assertThat(c.reviewers).doesNotContainKey(CC);
    AddReviewerInput in = new AddReviewerInput();
    in.reviewer = user.email;
    gApi.changes().id(r.getChangeId()).addReviewer(in);
    c = gApi.changes().id(r.getChangeId()).get();
    reviewers = c.reviewers.get(REVIEWER);
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled adding a reviewer records that user as reviewer
        // in notedb.
        assertThat(reviewers).hasSize(2);
        Iterator<AccountInfo> reviewerIt = reviewers.iterator();
        assertThat(reviewerIt.next()._accountId).isEqualTo(admin.getId().get());
        assertThat(reviewerIt.next()._accountId).isEqualTo(user.getId().get());
        assertThat(c.reviewers).doesNotContainKey(CC);
    } else {
        // When notedb is disabled adding a reviewer results in a dummy 0 approval
        // on the change which is treated as CC when the ChangeInfo is created.
        assertThat(reviewers).hasSize(1);
        assertThat(reviewers.iterator().next()._accountId).isEqualTo(admin.getId().get());
        Collection<AccountInfo> ccs = c.reviewers.get(CC);
        assertThat(ccs).hasSize(1);
        assertThat(ccs.iterator().next()._accountId).isEqualTo(user.getId().get());
    }
}
#end_block

#method_before
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    assertThat(m).containsEntry("Code-Review", new Short((short) 2));
    setApiUser(user);
    try {
        gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review+2");
        fail("AuthException (delete not permitted) expected");
    } catch (AuthException e) {
        assertThat(e.getMessage()).isEqualTo("delete not permitted");
    }
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review+2");
    m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    assertThat(getReviewers(r.getChangeId())).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
}
#method_after
@Test
public void deleteVote() throws Exception {
    PushOneCommit.Result r = createChange();
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.approve());
    setApiUser(user);
    gApi.changes().id(r.getChangeId()).revision(r.getCommit().name()).review(ReviewInput.recommend());
    setApiUser(admin);
    gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).deleteVote("Code-Review");
    Map<String, Short> m = gApi.changes().id(r.getChangeId()).reviewer(admin.getId().toString()).votes();
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted, hence there is no dummy 0 approval left when a vote is
        // deleted.
        assertThat(m).isEmpty();
    } else {
        // When notedb is disabled there is a dummy 0 approval on the change so
        // that the user is still returned as CC when all votes of that user have
        // been deleted.
        assertThat(m).containsEntry("Code-Review", new Short((short) 0));
    }
    ChangeInfo c = gApi.changes().id(r.getChangeId()).get();
    assertThat(Iterables.getLast(c.messages).message).isEqualTo("Removed Code-Review+2 by Administrator <admin@example.com>\n");
    if (isNoteDbTestEnabled()) {
        // When notedb is enabled each reviewer is explicitly recorded in the
        // notedb and this record stays even when all votes of that user have been
        // deleted.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(admin.getId(), user.getId()));
    } else {
        // When notedb is disabled users that have only dummy 0 approvals on the
        // change are returned as CC and not as REVIEWER.
        assertThat(getReviewers(c.reviewers.get(REVIEWER))).containsExactlyElementsIn(ImmutableSet.of(user.getId()));
        assertThat(getReviewers(c.reviewers.get(CC))).containsExactlyElementsIn(ImmutableSet.of(admin.getId()));
    }
}
#end_block

#method_before
@Test
public void createEmptyChange() throws Exception {
    ChangeInfo in = new ChangeInfo();
    in.branch = Constants.MASTER;
    in.subject = "Create a change from the API";
    in.project = project.get();
    ChangeInfo info = gApi.changes().create(in).get();
    assertThat(info.project).isEqualTo(in.project);
    assertThat(info.branch).isEqualTo(in.branch);
    assertThat(info.subject).isEqualTo(in.subject);
}
#method_after
@Test
public void createEmptyChange() throws Exception {
    ChangeInfo in = new ChangeInfo();
    in.branch = Constants.MASTER;
    in.subject = "Create a change from the API";
    in.project = project.get();
    ChangeInfo info = gApi.changes().create(in).get();
    assertThat(info.project).isEqualTo(in.project);
    assertThat(info.branch).isEqualTo(in.branch);
    assertThat(info.subject).isEqualTo(in.subject);
    assertThat(Iterables.getOnlyElement(info.messages).message).isEqualTo("Uploaded patch set 1.");
}
#end_block

#method_before
@Test
public void queryChangesNoQuery() throws Exception {
    PushOneCommit.Result r1 = createChange();
    PushOneCommit.Result r2 = createChange();
    List<ChangeInfo> results = gApi.changes().query().get();
    assertThat(results).hasSize(2);
    assertThat(results.get(0).changeId).isEqualTo(r2.getChangeId());
    assertThat(results.get(1).changeId).isEqualTo(r1.getChangeId());
}
#method_after
@Test
public void queryChangesNoQuery() throws Exception {
    PushOneCommit.Result r = createChange();
    List<ChangeInfo> results = gApi.changes().query().get();
    assertThat(results.size()).isAtLeast(1);
    List<Integer> ids = new ArrayList<>(results.size());
    for (int i = 0; i < results.size(); i++) {
        ChangeInfo info = results.get(i);
        if (i == 0) {
            assertThat(info._number).isEqualTo(r.getChange().getId().get());
        }
        assertThat(Change.Status.forChangeStatus(info.status).isOpen()).isTrue();
        ids.add(info._number);
    }
    assertThat(ids).contains(r.getChange().getId().get());
}
#end_block

#method_before
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    List<ChangeInfo> results = query("status:open");
    assertThat(results).hasSize(1);
    results = query("status:closed");
    assertThat(results).isEmpty();
}
#method_after
@Test
public void queryChangesNoResults() throws Exception {
    createChange();
    assertThat(query("message:test")).isNotEmpty();
    assertThat(query("message:{" + getClass().getName() + "fhqwhgads}")).isEmpty();
}
#end_block

#method_before
@Test
public void queryChangesStart() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query().withStart(1).get();
    assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId());
}
#method_after
@Test
public void queryChangesStart() throws Exception {
    PushOneCommit.Result r1 = createChange();
    createChange();
    List<ChangeInfo> results = gApi.changes().query("project:{" + project.get() + "}").withStart(1).get();
    assertThat(Iterables.getOnlyElement(results).changeId).isEqualTo(r1.getChangeId());
}
#end_block

#method_before
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#method_after
@Test
public void queryChangesOptions() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeInfo result = Iterables.getOnlyElement(gApi.changes().query(r.getChangeId()).withOptions(EnumSet.allOf(ListChangesOption.class)).get());
    assertThat(Iterables.getOnlyElement(result.labels.keySet())).isEqualTo("Code-Review");
    assertThat(result.messages).hasSize(1);
    assertThat(result.actions).isNotEmpty();
    RevisionInfo rev = Iterables.getOnlyElement(result.revisions.values());
    assertThat(rev._number).isEqualTo(r.getPatchSetId().get());
    assertThat(rev.created).isNotNull();
    assertThat(rev.uploader._accountId).isEqualTo(admin.getId().get());
    assertThat(rev.ref).isEqualTo(r.getPatchSetId().toRefName());
    assertThat(rev.actions).isNotEmpty();
}
#end_block

#method_before
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#method_after
@Test
public void queryChangesOwnerWithDifferentUsers() throws Exception {
    PushOneCommit.Result r = createChange();
    assertThat(Iterables.getOnlyElement(query("project:{" + project.get() + "} owner:self")).changeId).isEqualTo(r.getChangeId());
    setApiUser(user);
    assertThat(query("owner:self")).isEmpty();
}
#end_block

#method_before
private Set<Account.Id> getReviewers(String changeId) throws Exception {
    ChangeInfo ci = gApi.changes().id(changeId).get();
    Set<Account.Id> result = Sets.newHashSet();
    for (LabelInfo li : ci.labels.values()) {
        for (ApprovalInfo ai : li.all) {
            result.add(new Account.Id(ai._accountId));
        }
    }
    return result;
}
#method_after
private static Iterable<Account.Id> getReviewers(Collection<AccountInfo> r) {
    return Iterables.transform(r, new Function<AccountInfo, Account.Id>() {

        @Override
        public Account.Id apply(AccountInfo account) {
            return new Account.Id(account._accountId);
        }
    });
}
#end_block

#method_before
private static void onRemoveReviewer(NativeEvent event) {
    Integer user = getDataId(event);
    if (user != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemoveReviewer(NativeEvent event) {
    Integer user = getDataId(event);
    if (user != null) {
        final ChangeScreen screen = ChangeScreen.get(event);
        ChangeApi.reviewer(screen.getChangeId().get(), user).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private static void onRemoveVote(NativeEvent event) {
    Integer user = getDataId(event);
    String vote = getVoteId(event);
    if (user != null && vote != null) {
        final ChangeScreen2 screen = ChangeScreen2.get(event);
        ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#method_after
private static void onRemoveVote(NativeEvent event) {
    Integer user = getDataId(event);
    String vote = getVoteId(event);
    if (user != null && vote != null) {
        final ChangeScreen screen = ChangeScreen.get(event);
        ChangeApi.vote(screen.getChangeId().get(), user, vote).delete(new GerritCallback<JavaScriptObject>() {

            @Override
            public void onSuccess(JavaScriptObject result) {
                if (screen.isCurrentView()) {
                    Gerrit.display(PageLinks.toChange(screen.getChangeId()));
                }
            }
        });
    }
}
#end_block

#method_before
private static String getVoteId(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    while (e != null) {
        String v = e.getAttribute(VOTE_ID);
        if (!v.isEmpty()) {
            return v;
        }
        e = e.getParentElement();
    }
    return null;
}
#method_after
private static String getVoteId(NativeEvent event) {
    Element e = event.getEventTarget().cast();
    while (e != null) {
        String v = e.getAttribute(DATA_VOTE);
        if (!v.isEmpty()) {
            return v;
        }
        e = e.getParentElement();
    }
    return null;
}
#end_block

#method_before
void set(ChangeInfo info) {
    List<String> names = new ArrayList<>(info.labels());
    Set<Integer> removable = info.removable();
    Collections.sort(names);
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label, removable));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
    }
}
#method_after
void set(ChangeInfo info) {
    List<String> names = new ArrayList<>(info.labels());
    Set<Integer> removable = info.removableReviewerIds();
    Collections.sort(names);
    resize(names.size(), 2);
    for (int row = 0; row < names.size(); row++) {
        String name = names.get(row);
        LabelInfo label = info.label(name);
        setText(row, 0, name);
        if (label.all() != null) {
            setWidget(row, 1, renderUsers(label, removable));
        }
        getCellFormatter().setStyleName(row, 0, style.labelName());
        getCellFormatter().addStyleName(row, 0, getStyleForLabel(label));
    }
}
#end_block

#method_before
private Widget renderUsers(LabelInfo label, Set<Integer> removable) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0, rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.value_text(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), removable, label.name() + val, null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#method_after
private Widget renderUsers(LabelInfo label, Set<Integer> removable) {
    Map<Integer, List<ApprovalInfo>> m = new HashMap<>(4);
    int approved = 0;
    int rejected = 0;
    for (ApprovalInfo ai : Natives.asList(label.all())) {
        if (ai.value() != 0) {
            List<ApprovalInfo> l = m.get(Integer.valueOf(ai.value()));
            if (l == null) {
                l = new ArrayList<>(label.all().length());
                m.put(Integer.valueOf(ai.value()), l);
            }
            l.add(ai);
            if (isRejected(label, ai)) {
                rejected = ai.value();
            } else if (isApproved(label, ai)) {
                approved = ai.value();
            }
        }
    }
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    for (Integer v : sort(m.keySet(), approved, rejected)) {
        if (!html.isEmpty()) {
            html.br();
        }
        String val = LabelValue.formatValue(v.shortValue());
        html.openSpan();
        html.setAttribute("title", label.valueText(val));
        if (v.intValue() == approved) {
            html.setStyleName(style.label_ok());
        } else if (v.intValue() == rejected) {
            html.setStyleName(style.label_reject());
        }
        html.append(val).append(" ");
        html.append(formatUserList(style, m.get(v), removable, label.name(), null));
        html.closeSpan();
    }
    return html.toBlockWidget();
}
#end_block

#method_before
private static boolean isApproved(LabelInfo label, ApprovalInfo ai) {
    return label.approved() != null && label.approved()._account_id() == ai._account_id();
}
#method_after
private static boolean isApproved(LabelInfo label, ApprovalInfo ai) {
    return label.approved() != null && label.approved()._accountId() == ai._accountId();
}
#end_block

#method_before
private static boolean isRejected(LabelInfo label, ApprovalInfo ai) {
    return label.rejected() != null && label.rejected()._account_id() == ai._account_id();
}
#method_after
private static boolean isRejected(LabelInfo label, ApprovalInfo ai) {
    return label.rejected() != null && label.rejected()._accountId() == ai._accountId();
}
#end_block

#method_before
static SafeHtml formatUserList(ChangeScreen2.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, String labelVote, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._account_id());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._account_id()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._account_id()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (labelVote != null) {
            html.setAttribute(VOTE_ID, labelVote);
        }
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._account_id())) {
            html.openElement("button");
            if (labelVote != null) {
                html.setAttribute("title", Util.M.removeVote(labelVote)).setAttribute("onclick", REMOVE_VOTE + "(event)");
            } else {
                html.setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE_REVIEWER + "(event)");
            }
            html.append(new ImageResourceRenderer().render(Gerrit.RESOURCES.removeReviewer())).closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#method_after
static SafeHtml formatUserList(ChangeScreen.Style style, Collection<? extends AccountInfo> in, Set<Integer> removable, String label, Map<Integer, VotableInfo> votable) {
    List<AccountInfo> users = new ArrayList<>(in);
    Collections.sort(users, new Comparator<AccountInfo>() {

        @Override
        public int compare(AccountInfo a, AccountInfo b) {
            String as = name(a);
            String bs = name(b);
            if (as.isEmpty()) {
                return 1;
            } else if (bs.isEmpty()) {
                return -1;
            }
            return as.compareTo(bs);
        }

        private String name(AccountInfo a) {
            if (a.name() != null) {
                return a.name();
            } else if (a.email() != null) {
                return a.email();
            }
            return "";
        }
    });
    SafeHtmlBuilder html = new SafeHtmlBuilder();
    Iterator<? extends AccountInfo> itr = users.iterator();
    while (itr.hasNext()) {
        AccountInfo ai = itr.next();
        AvatarInfo img = ai.avatar(AvatarInfo.DEFAULT_SIZE);
        String name;
        if (ai.name() != null) {
            name = ai.name();
        } else if (ai.email() != null) {
            name = ai.email();
        } else {
            name = Integer.toString(ai._accountId());
        }
        String votableCategories = "";
        if (votable != null) {
            Set<String> s = votable.get(ai._accountId()).votableLabels();
            if (!s.isEmpty()) {
                StringBuilder sb = new StringBuilder(Util.C.votable());
                sb.append(" ");
                for (Iterator<String> it = s.iterator(); it.hasNext(); ) {
                    sb.append(it.next());
                    if (it.hasNext()) {
                        sb.append(", ");
                    }
                }
                votableCategories = sb.toString();
            }
        }
        html.openSpan().setAttribute("role", "listitem").setAttribute(DATA_ID, ai._accountId()).setAttribute("title", getTitle(ai, votableCategories)).setStyleName(style.label_user());
        if (label != null) {
            html.setAttribute(DATA_VOTE, label);
        }
        if (img != null) {
            html.openElement("img").setStyleName(style.avatar()).setAttribute("src", img.url());
            if (img.width() > 0) {
                html.setAttribute("width", img.width());
            }
            if (img.height() > 0) {
                html.setAttribute("height", img.height());
            }
            html.closeSelf();
        }
        html.append(name);
        if (removable.contains(ai._accountId())) {
            html.openElement("button");
            if (label != null) {
                html.setAttribute("title", Util.M.removeVote(label)).setAttribute("onclick", REMOVE_VOTE + "(event)");
            } else {
                html.setAttribute("title", Util.M.removeReviewer(name)).setAttribute("onclick", REMOVE_REVIEWER + "(event)");
            }
            html.append("").closeElement("button");
        }
        html.closeSpan();
        if (itr.hasNext()) {
            html.append(' ');
        }
    }
    return html;
}
#end_block

#method_before
void init(ChangeScreen2.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#method_after
void init(ChangeScreen.Style style, Element ccText) {
    this.style = style;
    this.ccText = ccText;
}
#end_block

#method_before
void set(ChangeInfo info) {
    this.changeId = info.legacy_id();
    display(info);
    reviewerSuggestOracle.setChange(changeId);
    openForm.setVisible(Gerrit.isSignedIn());
}
#method_after
void set(ChangeInfo info) {
    this.changeId = info.legacyId();
    display(info);
    reviewerSuggestOracle.setChange(changeId);
    openForm.setVisible(Gerrit.isSignedIn());
}
#end_block

#method_before
@UiHandler("add")
void onAdd(@SuppressWarnings("unused") ClickEvent e) {
    String reviewer = suggestBox.getText();
    if (!reviewer.isEmpty()) {
        addReviewer(reviewer, false);
    }
}
#method_after
@UiHandler("add")
void onAdd(@SuppressWarnings("unused") ClickEvent e) {
    addReviewer(suggestBox.getText(), false);
}
#end_block

#method_before
@UiHandler("addMe")
void onAddMe(@SuppressWarnings("unused") ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccountInfo()._account_id());
    addReviewer(accountId, false);
}
#method_after
@UiHandler("addMe")
void onAddMe(@SuppressWarnings("unused") ClickEvent e) {
    String accountId = String.valueOf(Gerrit.getUserAccount()._accountId());
    addReviewer(accountId, false);
}
#end_block

#method_before
private void addReviewer(final String reviewer, boolean confirmed) {
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            nameTxtBox.setEnabled(true);
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                nameTxtBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            UIObject.setVisible(error, true);
            error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            nameTxtBox.setEnabled(true);
        }
    });
}
#method_after
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isSigninFailure(err)) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#end_block

#method_before
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.all_labels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._account_id(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    cc.remove(info.owner()._account_id());
    Set<Integer> removable = info.removable();
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, null, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, null, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
    if (Gerrit.isSignedIn()) {
        int currentUser = Gerrit.getUserAccountInfo()._account_id();
        boolean showAddMeButton = info.owner()._account_id() != currentUser && !cc.containsKey(currentUser) && !r.containsKey(currentUser);
        addMe.setVisible(showAddMeButton);
    }
}
#method_after
private void display(ChangeInfo info) {
    Map<Integer, AccountInfo> r = new HashMap<>();
    Map<Integer, AccountInfo> cc = new HashMap<>();
    for (LabelInfo label : Natives.asList(info.allLabels().values())) {
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                (ai.value() != 0 ? r : cc).put(ai._accountId(), ai);
            }
        }
    }
    for (Integer i : r.keySet()) {
        cc.remove(i);
    }
    cc.remove(info.owner()._accountId());
    Set<Integer> removable = info.removableReviewerIds();
    Map<Integer, VotableInfo> votable = votable(info);
    SafeHtml rHtml = Labels.formatUserList(style, r.values(), removable, null, votable);
    SafeHtml ccHtml = Labels.formatUserList(style, cc.values(), removable, null, votable);
    reviewersText.setInnerSafeHtml(rHtml);
    ccText.setInnerSafeHtml(ccHtml);
    if (Gerrit.isSignedIn()) {
        int currentUser = Gerrit.getUserAccount()._accountId();
        boolean showAddMeButton = info.owner()._accountId() != currentUser && !cc.containsKey(currentUser) && !r.containsKey(currentUser);
        addMe.setVisible(showAddMeButton);
    }
}
#end_block

#method_before
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._account_id();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.has_value()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#method_after
private static Map<Integer, VotableInfo> votable(ChangeInfo change) {
    Map<Integer, VotableInfo> d = new HashMap<>();
    for (String name : change.labels()) {
        LabelInfo label = change.label(name);
        if (label.all() != null) {
            for (ApprovalInfo ai : Natives.asList(label.all())) {
                int id = ai._accountId();
                VotableInfo ad = d.get(id);
                if (ad == null) {
                    ad = new VotableInfo();
                    d.put(id, ad);
                }
                if (ai.hasValue()) {
                    ad.votable(name);
                }
            }
        }
    }
    return d;
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(Drafts.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(Publish.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(Publish.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    post(REVISION_KIND, "message").to(EditMessage.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(Drafts.class);
    put(REVISION_KIND, "drafts").to(CreateDraft.class);
    get(DRAFT_KIND).to(GetDraft.class);
    put(DRAFT_KIND).to(PutDraft.class);
    delete(DRAFT_KIND).to(DeleteDraft.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "type").to(GetContentType.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "type").to(ChangeEdits.GetType.class);
    install(new FactoryModule() {

        @Override
        protected void configure() {
            factory(ReviewerResource.Factory.class);
            factory(AccountLoader.Factory.class);
            factory(EmailReviewComments.Factory.class);
            factory(ChangeInserter.Factory.class);
            factory(PatchSetInserter.Factory.class);
            factory(ChangeEdits.Create.Factory.class);
            factory(ChangeEdits.DeleteFile.Factory.class);
        }
    });
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    bind(Votes.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    DynamicMap.mapOf(binder(), VOTE_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(REVIEWER_KIND, "votes").to(Votes.class);
    delete(VOTE_KIND).to(DeleteVote.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(AccountLoader.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(RebaseChangeOp.Factory.class);
    factory(ReviewerResource.Factory.class);
    factory(SetHashtagsOp.Factory.class);
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.base_change(emptyToNull(base));
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String topic, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.topic(emptyToNull(topic));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    if (Gerrit.info().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameter("list", true).get(cb);
}
#method_after
public static void editWithFiles(int id, AsyncCallback<EditInfo> cb) {
    edit(id).addParameterTrue("list").get(cb);
}
#end_block

#method_before
public static RestApi editWithCommands(int id) {
    return edit(id).addParameter("download-commands", true);
}
#method_after
public static RestApi editWithCommands(int id) {
    return edit(id).addParameterTrue("download-commands");
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.wait_for_merge(true);
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.waitForMerge(true);
    call(id, commit, "submit").post(in, cb);
}
#end_block

#method_before
public static void rebase(int id, String commit, AsyncCallback<ChangeInfo> cb) {
    JavaScriptObject in = JavaScriptObject.createObject();
    call(id, commit, "rebase").post(in, cb);
}
#method_after
public static void rebase(int id, String commit, String base, AsyncCallback<ChangeInfo> cb) {
    RebaseInput rebaseInput = RebaseInput.create();
    rebaseInput.setBase(base);
    call(id, commit, "rebase").post(rebaseInput, cb);
}
#end_block

#method_before
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws AuthException, ResourceNotFoundException, OrmException, IOException {
    ChangeControl control = rsrc.getReviewer().getControl();
    Change change = rsrc.getReviewer().getChange();
    Change.Id changeId = change.getId();
    ReviewDb db = dbProvider.get();
    ChangeUpdate update = updateFactory.create(control);
    LabelVote labelVote = rsrc.getVote();
    Account.Id accountId = rsrc.getReviewer().getUser().getAccountId();
    StringBuilder msg = new StringBuilder();
    db.changes().beginTransaction(changeId);
    try {
        PatchSetApproval psa = null;
        for (PatchSetApproval a : approvalsUtil.byChangeUser(db, update.getChangeNotes(), accountId)) {
            // implementing ctl.canRemoveVote(v) method.
            if (control.canRemoveReviewer(a)) {
                if (a.getLabel().equals(labelVote.getLabel()) && a.getValue() == rsrc.getVote().getValue()) {
                    msg.append("Removed the following vote:\n\n");
                    msg.append("* ").append(a.getLabel()).append(formatLabelValue(a.getValue())).append(" by ").append(userFactory.create(accountId).getNameEmail()).append("\n");
                    psa = a;
                    a.setValue((short) 0);
                    break;
                }
            } else {
                throw new AuthException("delete not permitted");
            }
        }
        if (psa == null) {
            throw new ResourceNotFoundException();
        }
        ChangeUtil.bumpRowVersionNotLastUpdatedOn(changeId, db);
        db.patchSetApprovals().update(Collections.singleton(psa));
        if (msg.length() > 0) {
            ChangeMessage changeMessage = new ChangeMessage(new ChangeMessage.Key(change.getId(), ChangeUtil.messageUUID(db)), ((IdentifiedUser) control.getCurrentUser()).getAccountId(), TimeUtil.nowTs(), change.currentPatchSetId());
            changeMessage.setMessage(msg.toString());
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, change);
    return Response.none();
}
#method_after
@Override
public Response<?> apply(VoteResource rsrc, Input input) throws RestApiException, UpdateException {
    ReviewerResource r = rsrc.getReviewer();
    ChangeControl ctl = r.getControl();
    Change change = r.getChange();
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), change.getProject(), ctl.getUser().asIdentifiedUser(), TimeUtil.nowTs())) {
        bu.addOp(change.getId(), new Op(r.getUser().getAccountId(), rsrc.getLabel()));
        bu.execute();
    }
    return Response.none();
}
#end_block

#method_before
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = Paths.get(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            List<String> pluginsToInstall;
            String installPlugins = System.getProperty("gerrit.install_plugins");
            if (installPlugins == null) {
                pluginsToInstall = null;
            } else {
                pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins);
            }
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext), pluginsToInstall).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setDbCfgInjector(dbInjector, cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#method_after
private synchronized void init() {
    if (manager == null) {
        final String path = System.getProperty("gerrit.site_path");
        if (path != null) {
            sitePath = Paths.get(path);
        }
        if (System.getProperty("gerrit.init") != null) {
            List<String> pluginsToInstall;
            String installPlugins = System.getProperty("gerrit.install_plugins");
            if (installPlugins == null) {
                pluginsToInstall = null;
            } else {
                pluginsToInstall = Splitter.on(",").trimResults().omitEmptyStrings().splitToList(installPlugins);
            }
            new SiteInitializer(path, System.getProperty("gerrit.init_path"), new UnzippedDistribution(servletContext), pluginsToInstall).init();
        }
        try {
            dbInjector = createDbInjector();
        } catch (CreationException ce) {
            final Message first = ce.getErrorMessages().iterator().next();
            final StringBuilder buf = new StringBuilder();
            buf.append(first.getMessage());
            Throwable why = first.getCause();
            while (why != null) {
                buf.append("\n  caused by ");
                buf.append(why.toString());
                why = why.getCause();
            }
            if (first.getCause() != null) {
                buf.append("\n");
                buf.append("\nResolve above errors before continuing.");
                buf.append("\nComplete stack trace follows:");
            }
            log.error(buf.toString(), first.getCause());
            throw new CreationException(Collections.singleton(first));
        }
        cfgInjector = createCfgInjector();
        initIndexType();
        config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
        sysInjector = createSysInjector();
        if (!sshdOff()) {
            sshInjector = createSshInjector();
        }
        webInjector = createWebInjector();
        PluginGuiceEnvironment env = sysInjector.getInstance(PluginGuiceEnvironment.class);
        env.setDbCfgInjector(dbInjector, cfgInjector);
        if (sshInjector != null) {
            env.setSshInjector(sshInjector);
        }
        env.setHttpInjector(webInjector);
        // Push the Provider<HttpServletRequest> down into the canonical
        // URL provider. Its optional for that provider, but since we can
        // supply one we should do so, in case the administrator has not
        // setup the canonical URL in the configuration file.
        // 
        // Note we have to do this manually as Guice failed to do the
        // injection here because the HTTP environment is not visible
        // to the core server modules.
        // 
        sysInjector.getInstance(HttpCanonicalWebUrlProvider.class).setHttpServletRequest(webInjector.getProvider(HttpServletRequest.class));
        filter = webInjector.getInstance(GuiceFilter.class);
        manager = new LifecycleManager();
        manager.add(dbInjector);
        manager.add(cfgInjector);
        manager.add(sysInjector);
        if (sshInjector != null) {
            manager.add(sshInjector);
        }
        manager.add(webInjector);
    }
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(false));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    IndexType indexType = IndexModule.getIndexType(cfgInjector);
    switch(indexType) {
        case LUCENE:
            modules.add(new LuceneIndexModule());
            modules.add(new IndexCommandsModule());
            break;
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(false));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    modules.add(new SmtpEmailSender.Module());
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    switch(indexType) {
        case LUCENE:
            modules.add(new LuceneIndexModule());
            break;
        default:
            throw new IllegalStateException("unsupported index.type = " + indexType);
    }
    modules.add(new CanonicalWebUrlModule() {

        @Override
        protected Class<? extends Provider<String>> provider() {
            return HttpCanonicalWebUrlProvider.class;
        }
    });
    modules.add(SshKeyCacheImpl.module());
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(false, false));
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class)));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    modules.add(new SshHostKeyModule());
    modules.add(new DefaultCommandModule(false, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#method_after
@VisibleForTesting
public void start() throws IOException {
    if (dbInjector == null) {
        dbInjector = createDbInjector(MULTI_USER);
    }
    cfgInjector = createCfgInjector();
    config = cfgInjector.getInstance(Key.get(Config.class, GerritServerConfig.class));
    initIndexType();
    sysInjector = createSysInjector();
    sysInjector.getInstance(PluginGuiceEnvironment.class).setDbCfgInjector(dbInjector, cfgInjector);
    manager.add(dbInjector, cfgInjector, sysInjector);
    if (!consoleLog) {
        manager.add(ErrorLogFile.start(getSitePath(), config));
    }
    sshd &= !sshdOff();
    if (sshd) {
        initSshd();
    }
    if (MoreObjects.firstNonNull(httpd, true)) {
        initHttpd();
    }
    manager.start();
}
#end_block

#method_before
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    addIndexModules(modules);
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#method_after
private Injector createSysInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(SchemaVersionCheck.module());
    modules.add(new LogFileCompressor.Module());
    modules.add(new WorkQueue.Module());
    modules.add(new ChangeHookRunner.Module());
    modules.add(new ReceiveCommitsExecutorModule());
    modules.add(new DiffExecutorModule());
    modules.add(new MimeUtil2Module());
    modules.add(cfgInjector.getInstance(GerritGlobalModule.class));
    modules.add(new ChangeCacheImplModule(slave));
    modules.add(new InternalAccountDirectory.Module());
    modules.add(new DefaultCacheFactory.Module());
    if (emailModule != null) {
        modules.add(emailModule);
    } else {
        modules.add(new SmtpEmailSender.Module());
    }
    modules.add(new SignedTokenEmailTokenVerifier.Module());
    modules.add(new PluginRestApiModule());
    modules.add(new RestCacheAdminModule());
    modules.add(new GpgModule(config));
    modules.add(createIndexModule());
    if (MoreObjects.firstNonNull(httpd, true)) {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return HttpCanonicalWebUrlProvider.class;
            }
        });
    } else {
        modules.add(new CanonicalWebUrlModule() {

            @Override
            protected Class<? extends Provider<String>> provider() {
                return CanonicalWebUrlProvider.class;
            }
        });
    }
    if (sshd) {
        modules.add(SshKeyCacheImpl.module());
    } else {
        modules.add(NoSshKeyCache.module());
    }
    modules.add(new AbstractModule() {

        @Override
        protected void configure() {
            bind(GerritOptions.class).toInstance(new GerritOptions(headless, slave));
            if (test) {
                bind(String.class).annotatedWith(SecureStoreClassName.class).toInstance(DefaultSecureStore.class.getName());
                bind(SecureStore.class).toProvider(SecureStoreProvider.class);
            }
        }
    });
    modules.add(new GarbageCollectionModule());
    modules.add(new ChangeCleanupRunner.Module());
    return cfgInjector.createChildInjector(modules);
}
#end_block

#method_before
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    return sysInjector.createChildInjector(modules);
}
#method_after
private Injector createSshInjector() {
    final List<Module> modules = new ArrayList<>();
    modules.add(sysInjector.getInstance(SshModule.class));
    if (!test) {
        modules.add(new SshHostKeyModule());
    }
    modules.add(new DefaultCommandModule(slave, sysInjector.getInstance(DownloadConfig.class)));
    if (indexType == IndexType.LUCENE) {
        modules.add(new IndexCommandsModule());
    }
    return sysInjector.createChildInjector(modules);
}
#end_block

#method_before
private DataSource open(final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    String interceptor = dbs.optional("dataSourceInterceptorClass");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(threadSettingsConfig.getDatabasePoolLimit());
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        return intercept(interceptor, ds);
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return intercept(interceptor, new SimpleDataSource(p));
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#method_after
private DataSource open(final Config cfg, final Context context, final DataSourceType dst) {
    ConfigSection dbs = new ConfigSection(cfg, "database");
    String driver = dbs.optional("driver");
    if (Strings.isNullOrEmpty(driver)) {
        driver = dst.getDriver();
    }
    String url = dbs.optional("url");
    if (Strings.isNullOrEmpty(url)) {
        url = dst.getUrl();
    }
    String username = dbs.optional("username");
    String password = dbs.optional("password");
    String interceptor = dbs.optional("dataSourceInterceptorClass");
    boolean usePool;
    if (context == Context.SINGLE_USER) {
        usePool = false;
    } else {
        usePool = cfg.getBoolean("database", "connectionpool", dst.usePool());
    }
    if (usePool) {
        final BasicDataSource ds = new BasicDataSource();
        ds.setDriverClassName(driver);
        ds.setUrl(url);
        if (username != null && !username.isEmpty()) {
            ds.setUsername(username);
        }
        if (password != null && !password.isEmpty()) {
            ds.setPassword(password);
        }
        ds.setMaxActive(threadSettingsConfig.getDatabasePoolLimit());
        ds.setMinIdle(cfg.getInt("database", "poolminidle", 4));
        ds.setMaxIdle(cfg.getInt("database", "poolmaxidle", 4));
        ds.setMaxWait(ConfigUtil.getTimeUnit(cfg, "database", null, "poolmaxwait", MILLISECONDS.convert(30, SECONDS), MILLISECONDS));
        ds.setInitialSize(ds.getMinIdle());
        exportPoolMetrics(ds);
        return intercept(interceptor, ds);
    } else {
        // 
        try {
            final Properties p = new Properties();
            p.setProperty("driver", driver);
            p.setProperty("url", url);
            if (username != null) {
                p.setProperty("user", username);
            }
            if (password != null) {
                p.setProperty("password", password);
            }
            return intercept(interceptor, new SimpleDataSource(p));
        } catch (SQLException se) {
            throw new ProvisionException("Database unavailable", se);
        }
    }
}
#end_block

#method_before
@Override
public List<Change> load(Project.NameKey key) throws Exception {
    Repository repo = repoManager.openRepository(key);
    try (ManualRequestContext ctx = requestContext.open()) {
        return scan(repo, ctx.getReviewDbProvider().get());
    } finally {
        repo.close();
    }
}
#method_after
@Override
public List<Change> load(Project.NameKey key) throws Exception {
    try (Repository repo = repoManager.openRepository(key);
        ManualRequestContext ctx = requestContext.open()) {
        return scan(repo, ctx.getReviewDbProvider().get());
    }
}
#end_block

#method_before
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    setRangeHighlight(edit);
    if (edit) {
        String replyMessage = Cookies.getCookie(getCookieName());
        if (comment.inReplyTo() != null && replyMessage != null) {
            comment.message(replyMessage);
            Cookies.removeCookie(getCookieName());
        }
        String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        cancel.setVisible(!isNew());
        expandText();
        editAreaHeight = editArea.getOffsetHeight();
        final int len = msg.length();
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                editArea.setFocus(true);
                if (len > 0) {
                    editArea.setCursorPos(len);
                }
            }
        });
    } else {
        expandTimer.cancel();
        resizeTimer.cancel();
    }
    getCommentManager().setUnsaved(this, edit);
    getCommentGroup().resize();
}
#method_after
void setEdit(boolean edit) {
    UIObject.setVisible(summary, false);
    UIObject.setVisible(p_view, !edit);
    UIObject.setVisible(p_edit, edit);
    setRangeHighlight(edit);
    if (edit) {
        String msg = comment.message() != null ? comment.message().trim() : "";
        editArea.setValue(msg);
        cancel.setVisible(!isNew());
        expandText();
        editAreaHeight = editArea.getOffsetHeight();
        final int len = msg.length();
        Scheduler.get().scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                editArea.setFocus(true);
                if (len > 0) {
                    editArea.setCursorPos(len);
                }
            }
        });
    } else {
        expandTimer.cancel();
        resizeTimer.cancel();
    }
    getCommentManager().setUnsaved(this, edit);
    getCommentGroup().resize();
}
#end_block

#method_before
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            if (RestApi.isNotSignedIn(e)) {
                Cookies.setCookie(getCookieName(), editArea.getValue().trim());
            }
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#method_after
void save(CallbackGroup group) {
    if (pendingGroup != null) {
        pendingGroup.addListener(group);
        return;
    }
    String message = editArea.getValue().trim();
    if (message.length() == 0) {
        return;
    }
    CommentInfo input = CommentInfo.copy(comment);
    input.message(message);
    enableEdit(false);
    pendingGroup = group;
    final LocalComments lc = new LocalComments(psId);
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            enableEdit(true);
            pendingGroup = null;
            set(result);
            setEdit(false);
            if (autoClosed) {
                setOpen(false);
            }
            getCommentManager().setUnsaved(DraftBox.this, false);
        }

        @Override
        public void onFailure(Throwable e) {
            enableEdit(true);
            pendingGroup = null;
            if (RestApi.isNotSignedIn(e)) {
                CommentInfo saved = CommentInfo.copy(comment);
                saved.message(editArea.getValue().trim());
                lc.setInlineComment(saved);
            }
            super.onFailure(e);
        }
    };
    if (input.id() == null) {
        CommentApi.createDraft(psId, input, group.add(cb));
    } else {
        CommentApi.updateDraft(psId, input.id(), input, group.add(cb));
    }
    CodeMirror cm = getCm();
    cm.vim().handleKey("<Esc>");
    cm.focus();
}
#end_block

#method_before
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    String savedMessage = Cookies.getCookie(getCookieName());
    if (savedMessage != null) {
        message.setText(savedMessage);
        Cookies.removeCookie(getCookieName());
    }
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#method_after
@Override
protected void onLoad() {
    commentsPanel.setVisible(false);
    post.setEnabled(false);
    if (lc.hasReplyComment()) {
        message.setText(lc.getReplyComment());
        lc.removeReplyComment();
    }
    ChangeApi.drafts(psId.getParentKey().get()).get(new AsyncCallback<NativeMap<JsArray<CommentInfo>>>() {

        @Override
        public void onSuccess(NativeMap<JsArray<CommentInfo>> result) {
            displayComments(result);
            post.setEnabled(true);
        }

        @Override
        public void onFailure(Throwable caught) {
            post.setEnabled(true);
        }
    });
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            message.setFocus(true);
        }
    });
    Scheduler.get().scheduleFixedDelay(new RepeatingCommand() {

        @Override
        public boolean execute() {
            String t = message.getText();
            if (t != null) {
                message.setCursorPos(t.length());
            }
            return false;
        }
    }, 0);
}
#end_block

#method_before
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (RestApi.isNotSignedIn(caught)) {
                Cookies.setCookie(getCookieName(), message.getText().trim());
            }
            super.onFailure(caught);
        }
    });
    hide();
}
#method_after
private void postReview() {
    in.message(message.getText().trim());
    // Don't send any comments in the request; just publish everything, even if
    // e.g. a draft was modified in another tab since we last looked it up.
    in.drafts(DraftHandling.PUBLISH_ALL_REVISIONS);
    in.prePost();
    ChangeApi.revision(psId.getParentKey().get(), revision).view("review").post(in, new GerritCallback<ReviewInput>() {

        @Override
        public void onSuccess(ReviewInput result) {
            Gerrit.display(PageLinks.toChange(psId.getParentKey(), String.valueOf(psId.get())));
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (RestApi.isNotSignedIn(caught)) {
                lc.setReplyComment(message.getText());
            }
            super.onFailure(caught);
        }
    });
    hide();
}
#end_block

#method_before
private void onSave(final AsyncCallback<VoidResult> onSave) {
    expandTimer.cancel();
    final String txt = text.getText().trim();
    if ("".equals(txt)) {
        return;
    }
    comment.setMessage(txt);
    text.setFocus(false);
    text.setReadOnly(true);
    save.setEnabled(false);
    cancel.setEnabled(false);
    discard.setEnabled(false);
    final PatchSet.Id psId = comment.getKey().getParentKey().getParentKey();
    final boolean wasNew = isNew();
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            notifyDraftDelta(wasNew ? 1 : 0);
            comment = toComment(psId, comment.getKey().getParentKey().get(), result);
            text.setReadOnly(false);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            render();
            onSave.onSuccess(VoidResult.INSTANCE);
        }

        @Override
        public void onFailure(final Throwable caught) {
            text.setReadOnly(false);
            text.setFocus(true);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            Cookies.setCookie("patchComment-" + psId.getParentKey().toString() + "-" + psId.getId() + "-" + btoa(comment.getKey().getParentKey().get()) + "-" + comment.getSide() + "-" + comment.getLine(), comment.getMessage());
            super.onFailure(caught);
            onSave.onFailure(caught);
        }
    };
    CommentInfo input = toInput(comment);
    if (wasNew) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, input.id(), input, cb);
    }
}
#method_after
private void onSave(final AsyncCallback<VoidResult> onSave) {
    expandTimer.cancel();
    final String txt = text.getText().trim();
    if ("".equals(txt)) {
        return;
    }
    comment.setMessage(txt);
    text.setFocus(false);
    text.setReadOnly(true);
    save.setEnabled(false);
    cancel.setEnabled(false);
    discard.setEnabled(false);
    final PatchSet.Id psId = comment.getKey().getParentKey().getParentKey();
    final LocalComments lc = new LocalComments(psId);
    final boolean wasNew = isNew();
    GerritCallback<CommentInfo> cb = new GerritCallback<CommentInfo>() {

        @Override
        public void onSuccess(CommentInfo result) {
            notifyDraftDelta(wasNew ? 1 : 0);
            comment = toComment(psId, comment.getKey().getParentKey().get(), result);
            text.setReadOnly(false);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            render();
            onSave.onSuccess(VoidResult.INSTANCE);
        }

        @Override
        public void onFailure(final Throwable caught) {
            text.setReadOnly(false);
            text.setFocus(true);
            save.setEnabled(true);
            cancel.setEnabled(true);
            discard.setEnabled(true);
            lc.setInlineComment(toInput(comment));
            super.onFailure(caught);
            onSave.onFailure(caught);
        }
    };
    CommentInfo input = toInput(comment);
    if (wasNew) {
        CommentApi.createDraft(psId, input, cb);
    } else {
        CommentApi.updateDraft(psId, input.id(), input, cb);
    }
}
#end_block

#method_before
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isNotSignedIn(err) || isInvalidXSRF(err) || (isNoSuchEntity(err) && !Gerrit.isSignedIn())) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#method_after
private void addReviewer(final String reviewer, boolean confirmed) {
    if (reviewer.isEmpty()) {
        return;
    }
    ChangeApi.reviewers(changeId.get()).post(PostInput.create(reviewer, confirmed), new GerritCallback<PostResult>() {

        @Override
        public void onSuccess(PostResult result) {
            if (result.confirm()) {
                askForConfirmation(result.error());
            } else if (result.error() != null) {
                UIObject.setVisible(error, true);
                error.setInnerText(result.error());
            } else {
                UIObject.setVisible(error, false);
                error.setInnerText("");
                suggestBox.setText("");
                if (result.reviewers() != null && result.reviewers().length() > 0) {
                    updateReviewerList();
                }
            }
        }

        private void askForConfirmation(String text) {
            new ConfirmationDialog(Util.C.approvalTableAddManyReviewersConfirmationDialogTitle(), new SafeHtmlBuilder().append(text), new ConfirmationCallback() {

                @Override
                public void onOk() {
                    addReviewer(reviewer, true);
                }
            }).center();
        }

        @Override
        public void onFailure(Throwable err) {
            if (isSigninFailure(err)) {
                new NotSignedInDialog().center();
            } else {
                UIObject.setVisible(error, true);
                error.setInnerText(err instanceof StatusCodeException ? ((StatusCodeException) err).getEncodedResponse() : err.getMessage());
            }
        }
    });
}
#end_block

#method_before
public static void showFailure(Throwable caught) {
    if (isNotSignedIn(caught) || isInvalidXSRF(caught)) {
        new NotSignedInDialog().center();
    } else if (isNoSuchEntity(caught)) {
        if (Gerrit.isSignedIn()) {
            new ErrorDialog(Gerrit.C.notFoundBody()).center();
        } else {
            new NotSignedInDialog().center();
        }
    } else if (isInactiveAccount(caught)) {
        new ErrorDialog(Gerrit.C.inactiveAccountBody()).center();
    } else if (isNoSuchAccount(caught)) {
        final String msg = caught.getMessage();
        final String who = msg.substring(NoSuchAccountException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchAccountMessage(who));
        d.setText(Gerrit.C.noSuchAccountTitle());
        d.center();
    } else if (isNameAlreadyUsed(caught)) {
        final String msg = caught.getMessage();
        final String alreadyUsedName = msg.substring(NameAlreadyUsedException.MESSAGE.length());
        new ErrorDialog(Gerrit.M.nameAlreadyUsedBody(alreadyUsedName)).center();
    } else if (isNoSuchGroup(caught)) {
        final String msg = caught.getMessage();
        final String group = msg.substring(NoSuchGroupException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchGroupMessage(group));
        d.setText(Gerrit.C.noSuchGroupTitle());
        d.center();
    } else if (caught instanceof ServerUnavailableException) {
        new ErrorDialog(RpcConstants.C.errorServerUnavailable()).center();
    } else {
        new ErrorDialog(caught).center();
    }
}
#method_after
public static void showFailure(Throwable caught) {
    if (isSigninFailure(caught)) {
        new NotSignedInDialog().center();
    } else if (isNoSuchEntity(caught)) {
        new ErrorDialog(Gerrit.C.notFoundBody()).center();
    } else if (isInactiveAccount(caught)) {
        new ErrorDialog(Gerrit.C.inactiveAccountBody()).center();
    } else if (isNoSuchAccount(caught)) {
        final String msg = caught.getMessage();
        final String who = msg.substring(NoSuchAccountException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchAccountMessage(who));
        d.setText(Gerrit.C.noSuchAccountTitle());
        d.center();
    } else if (isNameAlreadyUsed(caught)) {
        final String msg = caught.getMessage();
        final String alreadyUsedName = msg.substring(NameAlreadyUsedException.MESSAGE.length());
        new ErrorDialog(Gerrit.M.nameAlreadyUsedBody(alreadyUsedName)).center();
    } else if (isNoSuchGroup(caught)) {
        final String msg = caught.getMessage();
        final String group = msg.substring(NoSuchGroupException.MESSAGE.length());
        final ErrorDialog d = new ErrorDialog(Gerrit.M.noSuchGroupMessage(group));
        d.setText(Gerrit.C.noSuchGroupTitle());
        d.center();
    } else if (caught instanceof ServerUnavailableException) {
        new ErrorDialog(RpcConstants.C.errorServerUnavailable()).center();
    } else {
        new ErrorDialog(caught).center();
    }
}
#end_block

#method_before
@Override
public void onEvent(Event event) {
    RefUpdatedEvent refUpdate = (RefUpdatedEvent) event;
    if (refUpdate != null) {
        if ((protectDeleted || protectFastForward) && isRelevantRef(refUpdate)) {
            Project.NameKey nameKey = refUpdate.getProjectNameKey();
            try {
                ProjectResource project = new ProjectResource(projectControl.controlFor(nameKey, user));
                if ((protectDeleted && isRefDeleted(refUpdate)) || (protectFastForward && isNonFastForwardUpdate(refUpdate, project))) {
                    backupBranch.createBackup(refUpdate, project);
                }
            } catch (NoSuchProjectException | IOException e) {
                log.error(e.getMessage(), e);
            }
        }
    }
}
#method_after
@Override
public void onEvent(Event event) {
    if (event instanceof RefUpdatedEvent) {
        RefUpdatedEvent refUpdate = (RefUpdatedEvent) event;
        if ((protectDeleted || protectFastForward) && isRelevantRef(refUpdate)) {
            Project.NameKey nameKey = refUpdate.getProjectNameKey();
            try {
                ProjectResource project = new ProjectResource(projectControl.controlFor(nameKey, user));
                if ((protectDeleted && isRefDeleted(refUpdate)) || (protectFastForward && isNonFastForwardUpdate(refUpdate, project))) {
                    backupRef.createBackup(refUpdate, project);
                }
            } catch (NoSuchProjectException | IOException e) {
                log.error(e.getMessage(), e);
            }
        }
    }
}
#end_block

#method_before
private boolean isNonFastForwardUpdate(RefUpdatedEvent event, ProjectResource project) throws RepositoryNotFoundException, IOException {
    try (Repository repo = repoManager.openRepository(project.getNameKey())) {
        try (RevWalk walk = new RevWalk(repo)) {
            RevCommit oldCommit = walk.parseCommit(repo.resolve(event.refUpdate.oldRev));
            RevCommit newCommit = walk.parseCommit(repo.resolve(event.refUpdate.newRev));
            return !walk.isMergedInto(oldCommit, newCommit);
        }
    }
}
#method_after
private boolean isNonFastForwardUpdate(RefUpdatedEvent event, ProjectResource project) throws RepositoryNotFoundException, IOException {
    if (isRefDeleted(event)) {
        // attempting a check would cause a MissingObjectException.
        return false;
    }
    try (Repository repo = repoManager.openRepository(project.getNameKey())) {
        try (RevWalk walk = new RevWalk(repo)) {
            RevCommit oldCommit = walk.parseCommit(repo.resolve(event.refUpdate.oldRev));
            RevCommit newCommit = walk.parseCommit(repo.resolve(event.refUpdate.newRev));
            return !walk.isMergedInto(oldCommit, newCommit);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), EventListener.class).to(RefUpdateListener.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), EventListener.class).to(RefUpdateListener.class);
    requestStaticInjection(BackupRef.class);
}
#end_block

#method_before
@Override
public void onGitReferenceUpdated(final Event event) {
    if (isRelevantRef(event)) {
        Project.NameKey nameKey = new Project.NameKey(event.getProjectName());
        try {
            ProjectResource project = new ProjectResource(projectControl.controlFor(nameKey, user));
            boolean protectDeleted = cfg.getFromGerritConfig(RefProtectionModule.NAME).getBoolean("protectDeleted", true);
            boolean protectFastForward = cfg.getFromGerritConfig(RefProtectionModule.NAME).getBoolean("protectFastForward", true);
            if ((protectDeleted && isRefDeleted(event)) || (protectFastForward && isNonFastForwardUpdate(event, project))) {
                backupBranch.createBackup(event, project);
            }
        } catch (NoSuchProjectException | IOException e) {
            log.error(e.getMessage(), e);
        }
    }
}
#method_after
@Override
public void onGitReferenceUpdated(final Event event) {
    if ((protectDeleted || protectFastForward) && isRelevantRef(event)) {
        Project.NameKey nameKey = new Project.NameKey(event.getProjectName());
        try {
            ProjectResource project = new ProjectResource(projectControl.controlFor(nameKey, user));
            if ((protectDeleted && isRefDeleted(event)) || (protectFastForward && isNonFastForwardUpdate(event, project))) {
                backupRef.createBackup(event, project);
            }
        } catch (NoSuchProjectException | IOException e) {
            log.error(e.getMessage(), e);
        }
    }
}
#end_block

#method_before
private boolean isNonFastForwardUpdate(Event event, ProjectResource project) throws RepositoryNotFoundException, IOException {
    try (Repository repo = repoManager.openRepository(project.getNameKey())) {
        try (RevWalk walk = new RevWalk(repo)) {
            RevCommit oldCommit = walk.parseCommit(repo.resolve(event.getOldObjectId()));
            RevCommit newCommit = walk.parseCommit(repo.resolve(event.getNewObjectId()));
            return !walk.isMergedInto(oldCommit, newCommit);
        }
    }
}
#method_after
private boolean isNonFastForwardUpdate(Event event, ProjectResource project) throws RepositoryNotFoundException, IOException {
    if (isRefDeleted(event)) {
        // attempting a check would cause a MissingObjectException.
        return false;
    }
    try (Repository repo = repoManager.openRepository(project.getNameKey())) {
        try (RevWalk walk = new RevWalk(repo)) {
            RevCommit oldCommit = walk.parseCommit(repo.resolve(event.getOldObjectId()));
            RevCommit newCommit = walk.parseCommit(repo.resolve(event.getNewObjectId()));
            return !walk.isMergedInto(oldCommit, newCommit);
        }
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicSet.setOf(binder(), ChangeQueryBuilder.DynamicBuilder.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(BatchUpdate.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.bind(binder(), EventListener.class).to(EventsMetrics.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    DynamicMap.mapOf(binder(), ChangeQueryBuilder.ChangeOperatorFactory.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
protected Predicate<T> operator(final String name, final String value) throws QueryParseException {
    @SuppressWarnings("rawtypes")
    OperatorFactory f = opFactories.get(name);
    if (f == null) {
        f = getDynamicDefinition().getOperatorFactory(name);
    }
    if (f != null) {
        return f.create(this, value);
    }
    throw error("Unsupported operator " + name + ":" + value);
}
#method_after
@SuppressWarnings("unchecked")
private Predicate<T> operator(final String name, final String value) throws QueryParseException {
    @SuppressWarnings("rawtypes")
    OperatorFactory f = opFactories.get(name);
    if (f == null) {
        throw error("Unsupported operator " + name + ":" + value);
    }
    return f.create(this, value);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public Predicate<T> create(Q builder, String value) throws QueryParseException {
    try {
        return (Predicate<T>) method.invoke((dBuilder == null) ? builder : dBuilder, value);
    } catch (RuntimeException | IllegalAccessException e) {
        throw error("Error in operator " + name + ":" + value, e);
    } catch (InvocationTargetException e) {
        throw error("Error in operator " + name + ":" + value, e.getCause());
    }
}
#method_after
@SuppressWarnings("unchecked")
@Override
public Predicate<T> create(Q builder, String value) throws QueryParseException {
    try {
        return (Predicate<T>) method.invoke(builder, value);
    } catch (RuntimeException | IllegalAccessException e) {
        throw error("Error in operator " + name + ":" + value, e);
    } catch (InvocationTargetException e) {
        throw error("Error in operator " + name + ":" + value, e.getCause());
    }
}
#end_block

#method_before
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, builders, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts, index);
}
#method_after
Arguments asUser(CurrentUser otherUser) {
    return new Arguments(db, queryProvider, rewriter, opFactories, userFactory, Providers.of(otherUser), capabilityControlFactory, changeControlGenericFactory, changeDataFactory, fillArgs, plcUtil, accountResolver, groupBackend, allProjectsName, allUsersName, patchListCache, repoManager, projectCache, listChildProjects, submitStrategyFactory, conflictsCache, trackingFooters, allowsDrafts, index);
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (isGetOrHead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isGetOrHead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req);
                    viewData = new ViewData(null, null);
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                        status = SC_CREATED;
                    } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                        @SuppressWarnings("unchecked")
                        AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                        status = SC_NO_CONTENT;
                    } else {
                        throw e;
                    }
                }
                if (viewData.view == null) {
                    viewData = view(rsrc, c, req.getMethod(), path);
                }
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && "GET".equals(req.getMethod())) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        replyError(req, res, status = 422, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        if (viewData != null) {
            String metric = globals.metrics.view(viewData);
            globals.metrics.count.increment(metric);
            if (status >= SC_BAD_REQUEST) {
                globals.metrics.errorCount.increment(metric, status);
            }
            globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        }
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    final long startNanos = System.nanoTime();
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (isGetOrHead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isGetOrHead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req);
                    viewData = new ViewData(null, null);
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                        status = SC_CREATED;
                    } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                        @SuppressWarnings("unchecked")
                        AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                        status = SC_NO_CONTENT;
                    } else {
                        throw e;
                    }
                }
                if (viewData.view == null) {
                    viewData = view(rsrc, c, req.getMethod(), path);
                }
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && "GET".equals(req.getMethod())) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, viewData.view, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        replyError(req, res, status = 422, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        String metric = viewData != null && viewData.view != null ? globals.metrics.view(viewData) : "_unknown";
        globals.metrics.count.increment(metric);
        if (status >= SC_BAD_REQUEST) {
            globals.metrics.errorCount.increment(metric, status);
        }
        globals.metrics.serverLatency.record(metric, System.nanoTime() - startNanos, TimeUnit.NANOSECONDS);
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#end_block

#method_before
private void initPageHeader() {
    parseToken();
    HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(match);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            Query q = new Query(filterTxt.getValue());
            if (match.equals(q.qMatch)) {
                q.start(start);
            }
            if (!match.equals(q.qMatch)) {
                if (query == null) {
                    q.run();
                }
                query = q;
            }
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#method_after
private void initPageHeader() {
    parseToken();
    HorizontalPanel hp = new HorizontalPanel();
    hp.setStyleName(Gerrit.RESOURCES.css().projectFilterPanel());
    Label filterLabel = new Label(Util.C.projectFilter());
    filterLabel.setStyleName(Gerrit.RESOURCES.css().projectFilterLabel());
    hp.add(filterLabel);
    filterTxt = new NpTextBox();
    filterTxt.setValue(match);
    filterTxt.addKeyUpHandler(new KeyUpHandler() {

        @Override
        public void onKeyUp(KeyUpEvent event) {
            Query q = new Query(filterTxt.getValue());
            if (match.equals(q.qMatch)) {
                q.start(start);
            } else {
                if (query == null) {
                    q.run();
                }
                query = q;
            }
        }
    });
    hp.add(filterTxt);
    add(hp);
}
#end_block

#method_before
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
    if (!realm.allowsEdit(Account.FieldName.FULL_NAME) && who.getDisplayName() != null && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME) && !eq(user.getUserName(), who.getUserName())) {
        changeUserNameFactory.create(db, user, who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
    if (!realm.allowsEdit(Account.FieldName.FULL_NAME) && !Strings.isNullOrEmpty(who.getDisplayName()) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME) && !eq(user.getUserName(), who.getUserName())) {
        changeUserNameFactory.create(db, user, who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
@Override
public void onEvent(com.google.gerrit.server.events.Event event) {
    counter1.incrementBy(event.getType(), 1);
}
#method_after
@Override
public void onEvent(com.google.gerrit.server.events.Event event) {
    events.increment(event.getType());
}
#end_block

#method_before
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, getRefControl().forUser(who), notes);
}
#method_after
public ChangeControl forUser(final CurrentUser who) {
    if (getUser().equals(who)) {
        return this;
    }
    return new ChangeControl(changeDataFactory, approvalsUtil, getRefControl().forUser(who), notes);
}
#end_block

#method_before
public boolean canAbandon(ReviewDb db) throws OrmException {
    if (isPatchSetLocked(db)) {
        return false;
    }
    return // owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon();
}
#method_after
public boolean canAbandon(ReviewDb db) throws OrmException {
    return (// owner (aka creator) of the change can abandon
    isOwner() || // branch owner can abandon
    getRefControl().isOwner() || // project owner can abandon
    getProjectControl().isOwner() || // site administers are god
    getUser().getCapabilities().canAdministrateServer() || // user can abandon a specific ref
    getRefControl().canAbandon()) && !isPatchSetLocked(db);
}
#end_block

#method_before
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    final List<PatchSetApproval> psApprovals = db.patchSetApprovals().byPatchSet(getChange().currentPatchSetId()).toList();
    for (final PatchSetApproval ap : psApprovals) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null) {
            if (type.getFunctionName().equalsIgnoreCase("PatchSetLock") && ap.getValue() == 1) {
                return true;
            }
        }
    }
    return false;
}
#method_after
public boolean isPatchSetLocked(ReviewDb db) throws OrmException {
    if (getChange().getStatus() == Change.Status.MERGED) {
        return false;
    }
    for (PatchSetApproval ap : approvalsUtil.byPatchSet(db, this, getChange().currentPatchSetId())) {
        LabelType type = getLabelTypes().byLabel(ap.getLabel());
        if (type != null && ap.getValue() == 1 && type.getFunctionName().equalsIgnoreCase("PatchSetLock")) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void commit() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void commit() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void rollback() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void rollback() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void updateSchema(StatementExecutor e) {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void updateSchema(StatementExecutor e) {
    throw new Disabled();
}
#end_block

#method_before
@Override
public void pruneSchema(StatementExecutor e) {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public void pruneSchema(StatementExecutor e) {
    throw new Disabled();
}
#end_block

#method_before
@Override
public Access<?, ?>[] allRelations() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public Access<?, ?>[] allRelations() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SchemaVersionAccess schemaVersion() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SchemaVersionAccess schemaVersion() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SystemConfigAccess systemConfig() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SystemConfigAccess systemConfig() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountAccess accounts() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountAccess accounts() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountExternalIdAccess accountExternalIds() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountExternalIdAccess accountExternalIds() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountSshKeyAccess accountSshKeys() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountSshKeyAccess accountSshKeys() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupAccess accountGroups() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupAccess accountGroups() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupNameAccess accountGroupNames() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupNameAccess accountGroupNames() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupMemberAccess accountGroupMembers() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupMemberAccess accountGroupMembers() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupMemberAuditAccess accountGroupMembersAudit() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupMemberAuditAccess accountGroupMembersAudit() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public StarredChangeAccess starredChanges() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public StarredChangeAccess starredChanges() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountProjectWatchAccess accountProjectWatches() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountProjectWatchAccess accountProjectWatches() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountPatchReviewAccess accountPatchReviews() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountPatchReviewAccess accountPatchReviews() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public ChangeAccess changes() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public ChangeAccess changes() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchSetApprovalAccess patchSetApprovals() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchSetApprovalAccess patchSetApprovals() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public ChangeMessageAccess changeMessages() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public ChangeMessageAccess changeMessages() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchSetAccess patchSets() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchSetAccess patchSets() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public PatchLineCommentAccess patchComments() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public PatchLineCommentAccess patchComments() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public SubmoduleSubscriptionAccess submoduleSubscriptions() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public SubmoduleSubscriptionAccess submoduleSubscriptions() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupByIdAccess accountGroupById() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupByIdAccess accountGroupById() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public AccountGroupByIdAudAccess accountGroupByIdAud() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public AccountGroupByIdAudAccess accountGroupByIdAud() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextAccountId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextAccountId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextAccountGroupId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextAccountGroupId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextChangeId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextChangeId() {
    throw new Disabled();
}
#end_block

#method_before
@Override
public int nextChangeMessageId() {
    throw new AssertionError(MESSAGE);
}
#method_after
@Override
public int nextChangeMessageId() {
    throw new Disabled();
}
#end_block

#method_before
private static int getPluginsLoadTimeout(final Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#method_after
private static int getPluginsLoadTimeout(Config cfg) {
    long cfgValue = ConfigUtil.getTimeUnit(cfg, "plugins", null, "jsLoadTimeout", DEFAULT_JS_LOAD_TIMEOUT, TimeUnit.MILLISECONDS);
    if (cfgValue < 0) {
        return 0;
    }
    return (int) cfgValue;
}
#end_block

#method_before
private void json(final Object data, final StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#method_after
private void json(Object data, StringWriter w) {
    JsonServlet.defaultGsonBuilder().create().toJson(data, w);
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException {
    final Page.Content page = select(req);
    final StringWriter w = new StringWriter();
    final CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        w.write(HPD_ID + ".xGerritAuth=");
        json(session.get().getXGerritAuth(), w);
        w.write(";");
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences((IdentifiedUser) user), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    final byte[] hpd = w.toString().getBytes("UTF-8");
    final byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    final byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse rsp) throws IOException {
    Page.Content page = select(req);
    StringWriter w = new StringWriter();
    CurrentUser user = currentUser.get();
    if (user.isIdentifiedUser()) {
        setXGerritAuthCookie(req, rsp, session.get());
        w.write(HPD_ID + ".accountDiffPref=");
        json(getDiffPreferences(user.asIdentifiedUser()), w);
        w.write(";");
        w.write(HPD_ID + ".theme=");
        json(signedInTheme, w);
        w.write(";");
    } else {
        setXGerritAuthCookie(req, rsp, null);
        w.write(HPD_ID + ".theme=");
        json(signedOutTheme, w);
        w.write(";");
    }
    plugins(w);
    messages(w);
    byte[] hpd = w.toString().getBytes(UTF_8);
    byte[] raw = Bytes.concat(page.part1, hpd, page.part2);
    byte[] tosend;
    if (RPCServletUtils.acceptsGzipEncoding(req)) {
        rsp.setHeader("Content-Encoding", "gzip");
        tosend = HtmlDomUtil.compress(raw);
    } else {
        tosend = raw;
    }
    CacheHeaders.setNotCacheable(rsp);
    rsp.setContentType("text/html");
    rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
    rsp.setContentLength(tosend.length);
    try (OutputStream out = rsp.getOutputStream()) {
        out.write(tosend);
    }
}
#end_block

#method_before
private void asScript(final Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#method_after
private void asScript(Element scriptNode) {
    scriptNode.setAttribute("type", "text/javascript");
    scriptNode.setAttribute("language", "javascript");
}
#end_block

#method_before
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#method_after
private FileInfo injectCssFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    String css = HtmlDomUtil.readFile(src.getParent(), src.getFileName().toString());
    if (css == null) {
        return info;
    }
    banner.appendChild(hostDoc.createCDATASection("\n" + css + "\n"));
    return info;
}
#end_block

#method_before
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    final FileInfo info = new FileInfo(src);
    final Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#method_after
private FileInfo injectXmlFile(Document hostDoc, String id, Path src) throws IOException {
    FileInfo info = new FileInfo(src);
    Element banner = HtmlDomUtil.find(hostDoc, id);
    if (banner == null) {
        return info;
    }
    while (banner.getFirstChild() != null) {
        banner.removeChild(banner.getFirstChild());
    }
    Document html = HtmlDomUtil.parseFile(src);
    if (html == null) {
        return info;
    }
    Element content = html.getDocumentElement();
    insertETags(content);
    banner.appendChild(hostDoc.importNode(content, true));
    return info;
}
#end_block

#method_before
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    try (Repository git = gitMgr.openRepository(allUsersName.get())) {
        VersionedAccountPreferences p = VersionedAccountPreferences.forUser(rsrc.getUser().getAccountId());
        p.load(git);
        DiffPreferencesInfo prefs = new DiffPreferencesInfo();
        loadSection(p.getConfig(), UserConfigSections.DIFF, null, prefs, DiffPreferencesInfo.defaults());
        // Reset the migrated flag to prevent it from being sent over the wire.
        prefs.migrated = null;
        return prefs;
    }
}
#method_after
@Override
public DiffPreferencesInfo apply(AccountResource rsrc) throws AuthException, ConfigInvalidException, IOException {
    if (self.get() != rsrc.getUser() && !self.get().getCapabilities().canAdministrateServer()) {
        throw new AuthException("restricted to administrator");
    }
    Account.Id id = rsrc.getUser().getAccountId();
    return readFromGit(id, gitMgr, allUsersName.get(), null);
}
#end_block

#method_before
@Nullable
private GroupBackend backend(AccountGroup.UUID uuid) {
    for (GroupBackend g : backends) {
        if (g.handles(uuid)) {
            return g;
        }
    }
    return null;
}
#method_after
@Nullable
private GroupBackend backend(AccountGroup.UUID uuid) {
    if (uuid != null) {
        for (GroupBackend g : backends) {
            if (g.handles(uuid)) {
                return g;
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    return requireBackend(uuid).get(uuid);
}
#method_after
@Override
public GroupDescription.Basic get(AccountGroup.UUID uuid) {
    GroupBackend b = backend(uuid);
    if (b == null) {
        log.warn("Unknown GroupBackend for UUID: " + uuid);
        return null;
    }
    return b.get(uuid);
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    return new UniversalGroupMembership(user);
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    return new UniversalGroupMembership(user);
}
#end_block

#method_before
@Nullable
private GroupMembership membership(AccountGroup.UUID uuid) {
    for (Map.Entry<GroupBackend, GroupMembership> m : memberships.entrySet()) {
        if (m.getKey().handles(uuid)) {
            return m.getValue();
        }
    }
    return null;
}
#method_after
@Nullable
private GroupMembership membership(AccountGroup.UUID uuid) {
    if (uuid != null) {
        for (Map.Entry<GroupBackend, GroupMembership> m : memberships.entrySet()) {
            if (m.getKey().handles(uuid)) {
                return m.getValue();
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean contains(AccountGroup.UUID uuid) {
    return requireMembership(uuid).contains(uuid);
}
#method_after
@Override
public boolean contains(AccountGroup.UUID uuid) {
    GroupMembership m = membership(uuid);
    if (m == null) {
        log.warn("Unknown GroupMembership for UUID: " + uuid);
        return false;
    }
    return m.contains(uuid);
}
#end_block

#method_before
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        lookups.put(requireMembership(uuid), uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        if (entry.getKey().containsAnyOf(entry.getValue())) {
            return true;
        }
    }
    return false;
}
#method_after
@Override
public boolean containsAnyOf(Iterable<AccountGroup.UUID> uuids) {
    Multimap<GroupMembership, AccountGroup.UUID> lookups = ArrayListMultimap.create();
    for (AccountGroup.UUID uuid : uuids) {
        GroupMembership m = membership(uuid);
        if (m == null) {
            log.warn("Unknown GroupMembership for UUID: " + uuid);
            continue;
        }
        lookups.put(m, uuid);
    }
    for (Map.Entry<GroupMembership, Collection<AccountGroup.UUID>> entry : lookups.asMap().entrySet()) {
        if (entry.getKey().containsAnyOf(entry.getValue())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup.Id groupId) throws NoSuchGroupException {
    final AccountGroup group = groupCache.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final ExtGroup group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup.UUID groupId) throws NoSuchGroupException {
    final GroupDescription.Basic group = groupBackend.get(groupId);
    if (group == null) {
        throw new NoSuchGroupException(groupId);
    }
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(groupCache, user.get(), group);
}
#method_after
public GroupControl controlFor(final AccountGroup group) {
    return new GroupControl(user.get(), group);
}
#end_block

#method_before
public boolean isOwner() {
    if (!group.hasOwnerGroupId()) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup g = groupCache.get(group.getOwnerGroupId());
        AccountGroup.UUID ownerUUID = g != null ? g.getGroupUUID() : null;
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#method_after
public boolean isOwner() {
    AccountGroup accountGroup = GroupDescriptions.toAccountGroup(group);
    if (accountGroup == null) {
        isOwner = false;
    } else if (isOwner == null) {
        AccountGroup.UUID ownerUUID = accountGroup.getOwnerGroupUUID();
        isOwner = getCurrentUser().getEffectiveGroups().contains(ownerUUID) || getCurrentUser().getCapabilities().canAdministrateServer();
    }
    return isOwner;
}
#end_block

#method_before
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            Multibinder.newSetBinder(binder(), GroupBackend.class).addBinding().to(InternalGroupBackend.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    factory(SecureCredentialsProvider.Factory.class);
    factory(PushAllProjectsOp.Factory.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    factory(ReplicationUser.Factory.class);
}
#method_after
@Override
protected void configure() {
    switch(loginType) {
        case HTTP_LDAP:
        case LDAP:
        case LDAP_BIND:
        case CLIENT_SSL_CERT_LDAP:
            install(new LdapModule());
            break;
        case CUSTOM_EXTENSION:
            break;
        default:
            bind(Realm.class).to(DefaultRealm.class);
            break;
    }
    bind(ApprovalTypes.class).toProvider(ApprovalTypesProvider.class).in(SINGLETON);
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new GitModule());
    install(new PrologModule());
    install(ThreadLocalRequestContext.module());
    factory(AccountInfoCacheFactory.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(InternalUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(IncludingGroupMembership.Factory.class);
    bind(InternalGroupBackend.class).in(SINGLETON);
    bind(GroupBackend.class).to(UniversalGroupBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), GroupBackend.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(InternalGroupBackend.class);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    factory(ReloadSubmitQueueOp.Factory.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    factory(FunctionState.Factory.class);
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    bind(AnonymousUser.class);
}
#end_block

#method_before
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    return changeControl.forUser(who).isVisible(reviewDbProvider.get());
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#method_after
@Override
public void suggestChangeReviewer(final Change.Id change, final String query, final int limit, final AsyncCallback<List<ReviewerInfo>> callback) {
    run(callback, new Action<List<ReviewerInfo>>() {

        public List<ReviewerInfo> run(final ReviewDb db) throws OrmException {
            final ChangeControl changeControl;
            try {
                changeControl = changeControlFactory.controlFor(change);
            } catch (NoSuchChangeException e) {
                return Collections.emptyList();
            }
            VisibilityControl visibilityControl = new VisibilityControl() {

                @Override
                public boolean isVisible(Account account) throws OrmException {
                    IdentifiedUser who = identifiedUserFactory.create(reviewDbProvider, account.getId());
                    // to drafts
                    return changeControl.forUser(who).isRefVisible();
                }
            };
            final List<AccountInfo> suggestedAccounts = suggestAccount(db, query, Boolean.TRUE, limit, visibilityControl);
            final List<ReviewerInfo> reviewer = new ArrayList<ReviewerInfo>(suggestedAccounts.size());
            for (final AccountInfo a : suggestedAccounts) {
                reviewer.add(new ReviewerInfo(a));
            }
            final List<GroupReference> suggestedAccountGroups = suggestAccountGroup(query, limit);
            for (final GroupReference g : suggestedAccountGroups) {
                if (suggestGroupAsReviewer(changeControl.getProject().getNameKey(), g)) {
                    reviewer.add(new ReviewerInfo(g));
                }
            }
            Collections.sort(reviewer);
            if (reviewer.size() <= limit) {
                return reviewer;
            } else {
                return reviewer.subList(0, limit);
            }
        }
    });
}
#end_block

#method_before
private GroupReference groupReference(LdapQuery.Result res) throws NamingException {
    String name = Objects.firstNonNull(res.get("cn"), res.getDN());
    return new GroupReference(new AccountGroup.UUID(LDAP_UUID + res.getDN()), LDAP_NAME + name);
}
#method_after
private static GroupReference groupReference(LdapQuery.Result res) throws NamingException {
    return new GroupReference(new AccountGroup.UUID(LDAP_UUID + res.getDN()), LDAP_NAME + cnFor(res.getDN()));
}
#end_block

#method_before
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return internalBackend.handles(uuid) || isLdapUUID(uuid);
}
#method_after
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return isLdapUUID(uuid);
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    if (isLdapUUID(uuid)) {
        // First see if there is a legacy LDAP UUID stored in the database.
        AccountGroup.ExternalNameKey ext = externalNameKey(uuid);
        for (AccountGroup g : groupCache.get(ext)) {
            if (g.getGroupUUID() != null) {
                return ExtGroups.forAccountGroup(g);
            }
        }
        // Otherwise generate a GroupReference if the name is valid.
        return lookup(ext);
    } else {
        return internalBackend.get(uuid);
    }
}
#method_after
@Override
public GroupDescription.Basic get(final AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    String groupDn = uuid.get().substring(LDAP_UUID.length());
    CurrentUser user = userProvider.get();
    if (!(user instanceof IdentifiedUser) || !membershipsOf((IdentifiedUser) user).contains(uuid)) {
        try {
            if (!existsCache.get(groupDn)) {
                return null;
            }
        } catch (ExecutionException e) {
            log.warn(String.format("Cannot lookup group %s in LDAP", groupDn), e);
            return null;
        }
    }
    final String name = LDAP_NAME + cnFor(groupDn);
    return new GroupDescription.Basic() {

        @Override
        public AccountGroup.UUID getGroupUUID() {
            return uuid;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public boolean isVisibleToAll() {
            return true;
        }
    };
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(String name) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(name);
    if (isLdapUUID(uuid)) {
        ExtGroup g = get(uuid);
        if (g == null) {
            return Collections.emptySet();
        }
        return Collections.singleton(GroupReference.forGroup(g));
    } else if (name.startsWith(LDAP_NAME)) {
        return suggestLdap(name.substring(LDAP_NAME.length()));
    }
    return internalBackend.suggest(name);
}
#method_after
@Override
public Collection<GroupReference> suggest(String name) {
    AccountGroup.UUID uuid = new AccountGroup.UUID(name);
    if (isLdapUUID(uuid)) {
        GroupDescription.Basic g = get(uuid);
        if (g == null) {
            return Collections.emptySet();
        }
        return Collections.singleton(GroupReference.forGroup(g));
    } else if (name.startsWith(LDAP_NAME)) {
        return suggestLdap(name.substring(LDAP_NAME.length()));
    }
    return Collections.emptySet();
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    // TODO(cranger): update to support ldapgroup UUID
    return groupMembershipFactory.create(Iterables.concat(membershipCache.get(findId(user.getExternalIds())), user.getInternalGroups()));
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    String id = findId(user.state().getExternalIds());
    if (id == null) {
        return GroupMembership.EMPTY;
    }
    try {
        return new ListGroupMembership(membershipCache.get(id));
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup membershipsOf %s in LDAP", id), e);
        return GroupMembership.EMPTY;
    }
}
#end_block

#method_before
private Set<GroupReference> suggestLdap(String name) {
    Set<GroupReference> out = Sets.newTreeSet(GROUP_REF_NAME_COMPARATOR);
    try {
        final DirContext ctx = helper.open();
        try {
            final LdapSchema schema = helper.getSchema(ctx);
            final ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            final Set<String> returnAttrs = Collections.<String>emptySet();
            final Map<String, String> params = Collections.emptyMap();
            for (String groupBase : schema.groupBases) {
                LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, returnAttrs);
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(groupReference(res));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#method_after
private Set<GroupReference> suggestLdap(String name) {
    if (name.isEmpty()) {
        return Collections.emptySet();
    }
    Set<GroupReference> out = Sets.newTreeSet(GROUP_REF_NAME_COMPARATOR);
    try {
        DirContext ctx = helper.open();
        try {
            // Do exact lookups until there are at least 3 characters.
            name = Rdn.escapeValue(name) + ((name.length() >= 3) ? "*" : "");
            LdapSchema schema = helper.getSchema(ctx);
            ParameterizedString filter = ParameterizedString.asis(schema.groupPattern.replace(GROUPNAME, name).toString());
            Set<String> returnAttrs = Collections.<String>emptySet();
            Map<String, String> params = Collections.emptyMap();
            for (String groupBase : schema.groupBases) {
                LdapQuery query = new LdapQuery(groupBase, schema.groupScope, filter, returnAttrs);
                for (LdapQuery.Result res : query.query(ctx, params)) {
                    out.add(groupReference(res));
                }
            }
        } finally {
            try {
                ctx.close();
            } catch (NamingException e) {
                log.warn("Cannot close LDAP query handle", e);
            }
        }
    } catch (NamingException e) {
        log.warn("Cannot query LDAP for groups matching requested name", e);
    }
    return out;
}
#end_block

#method_before
@Nullable
public static GroupReference findBestSuggestion(GroupBackend groupBackend, String name) {
    Collection<GroupReference> refs = groupBackend.suggest(name);
    if (refs.size() == 1) {
        return refs.iterator().next();
    }
    for (GroupReference ref : refs) {
        if (ref.getName().equals(name) || ref.getUUID().get().equals(name)) {
            return ref;
        }
    }
    return null;
}
#method_after
@Nullable
public static GroupReference findBestSuggestion(GroupBackend groupBackend, String name) {
    Collection<GroupReference> refs = groupBackend.suggest(name);
    if (refs.size() == 1) {
        return Iterables.getOnlyElement(refs);
    }
    for (GroupReference ref : refs) {
        if (isExactSuggestion(ref, name)) {
            return ref;
        }
    }
    return null;
}
#end_block

#method_before
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:") || uuid.get().indexOf(':') < 0;
}
#method_after
@Override
public boolean handles(AccountGroup.UUID uuid) {
    return uuid.get().startsWith("global:") || uuid.get().matches("[0-9a-f]{40}");
}
#end_block

#method_before
@Override
public ExtGroup get(AccountGroup.UUID uuid) {
    checkArgument(handles(uuid), "internal groups system does not handle UUID: %s", uuid);
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return ExtGroups.forAccountGroup(g);
}
#method_after
@Override
public GroupDescription.Internal get(AccountGroup.UUID uuid) {
    if (!handles(uuid)) {
        return null;
    }
    AccountGroup g = groupCache.get(uuid);
    if (g == null) {
        return null;
    }
    return GroupDescriptions.forAccountGroup(g);
}
#end_block

#method_before
@Override
public Collection<GroupReference> suggest(final String name) {
    Iterable<AccountGroup> filtered = Iterables.filter(groupCache.all(), new Predicate<AccountGroup>() {

        @Override
        public boolean apply(AccountGroup group) {
            return group.getName().startsWith(name);
        }
    });
    return Lists.newArrayList(Iterables.transform(filtered, ACT_GROUP_TO_GROUP_REF));
}
#method_after
@Override
public Collection<GroupReference> suggest(final String name) {
    Iterable<AccountGroup> filtered = Iterables.filter(groupCache.all(), new Predicate<AccountGroup>() {

        @Override
        public boolean apply(AccountGroup group) {
            // startsWithIgnoreCase
            return group.getName().regionMatches(true, 0, name, 0, name.length());
        }
    });
    return Lists.newArrayList(Iterables.transform(filtered, ACT_GROUP_TO_GROUP_REF));
}
#end_block

#method_before
@Override
public GroupMembership membershipsOf(AccountState user) {
    return groupMembershipFactory.create(user.getInternalGroups());
}
#method_after
@Override
public GroupMembership membershipsOf(IdentifiedUser user) {
    return groupMembershipFactory.create(user.state().getInternalGroups());
}
#end_block

#method_before
@Override
protected void configure() {
    final TypeLiteral<Cache<String, Set<AccountGroup.UUID>>> groups = new TypeLiteral<Cache<String, Set<AccountGroup.UUID>>>() {
    };
    // 
    core(groups, GROUP_CACHE).maxAge(1, HOURS).populateWith(LdapRealm.MemberLoader.class);
    final TypeLiteral<Cache<String, Account.Id>> usernames = new TypeLiteral<Cache<String, Account.Id>>() {
    };
    // 
    core(usernames, USERNAME_CACHE).populateWith(LdapRealm.UserLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    Multibinder.newSetBinder(binder(), GroupBackend.class).addBinding().to(LdapGroupBackend.class);
}
#method_after
@Override
protected void configure() {
    cache(GROUP_CACHE, String.class, new TypeLiteral<Set<AccountGroup.UUID>>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.MemberLoader.class);
    cache(USERNAME_CACHE, String.class, new TypeLiteral<Optional<Account.Id>>() {
    }).loader(LdapRealm.UserLoader.class);
    cache(GROUP_EXIST_CACHE, String.class, new TypeLiteral<Boolean>() {
    }).expireAfterWrite(1, HOURS).loader(LdapRealm.ExistenceLoader.class);
    bind(Realm.class).to(LdapRealm.class).in(Scopes.SINGLETON);
    bind(Helper.class);
    DynamicSet.bind(binder(), GroupBackend.class).to(LdapGroupBackend.class);
}
#end_block

#method_before
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || pc.controlForRef(GitRepositoryManager.REF_CONFIG).isVisible());
    return detail;
}
#method_after
@Override
public ProjectAccess call() throws NoSuchProjectException, IOException, ConfigInvalidException {
    pc = open();
    // Load the current configuration from the repository, ensuring its the most
    // recent version available. If it differs from what was in the project
    // state, force a cache flush now.
    // 
    ProjectConfig config;
    MetaDataUpdate md = metaDataUpdateFactory.create(projectName);
    try {
        config = ProjectConfig.read(md);
        if (config.updateGroupNames(groupBackend)) {
            md.setMessage("Update group names\n");
            if (config.commit(md)) {
                projectCache.evict(config.getProject());
                pc = open();
            }
        } else if (config.getRevision() != null && !config.getRevision().equals(pc.getProjectState().getConfig().getRevision())) {
            projectCache.evict(config.getProject());
            pc = open();
        }
    } finally {
        md.close();
    }
    final RefControl metaConfigControl = pc.controlForRef(GitRepositoryManager.REF_CONFIG);
    List<AccessSection> local = new ArrayList<AccessSection>();
    Set<String> ownerOf = new HashSet<String>();
    Map<AccountGroup.UUID, Boolean> visibleGroups = new HashMap<AccountGroup.UUID, Boolean>();
    for (AccessSection section : config.getAccessSections()) {
        String name = section.getName();
        if (AccessSection.GLOBAL_CAPABILITIES.equals(name)) {
            if (pc.isOwner()) {
                local.add(section);
                ownerOf.add(name);
            }
        } else if (RefConfigSection.isValid(name)) {
            RefControl rc = pc.controlForRef(name);
            if (rc.isOwner() || metaConfigControl.isVisible()) {
                local.add(section);
                ownerOf.add(name);
            } else if (rc.isVisible()) {
                // Filter the section to only add rules describing groups that
                // are visible to the current-user. This includes any group the
                // user is a member of, as well as groups they own or that
                // are visible to all users.
                AccessSection dst = null;
                for (Permission srcPerm : section.getPermissions()) {
                    Permission dstPerm = null;
                    for (PermissionRule srcRule : srcPerm.getRules()) {
                        AccountGroup.UUID group = srcRule.getGroup().getUUID();
                        if (group == null) {
                            continue;
                        }
                        Boolean canSeeGroup = visibleGroups.get(group);
                        if (canSeeGroup == null) {
                            try {
                                canSeeGroup = groupControlFactory.controlFor(group).isVisible();
                            } catch (NoSuchGroupException e) {
                                canSeeGroup = Boolean.FALSE;
                            }
                            visibleGroups.put(group, canSeeGroup);
                        }
                        if (canSeeGroup) {
                            if (dstPerm == null) {
                                if (dst == null) {
                                    dst = new AccessSection(name);
                                    local.add(dst);
                                }
                                dstPerm = dst.getPermission(srcPerm.getName(), true);
                            }
                            dstPerm.add(srcRule);
                        }
                    }
                }
            }
        }
    }
    if (ownerOf.isEmpty() && pc.isOwnerAnyRef()) {
        // Special case: If the section list is empty, this project has no current
        // access control information. Rely on what ProjectControl determines
        // is ownership, which probably means falling back to site administrators.
        ownerOf.add(AccessSection.ALL);
    }
    final ProjectAccess detail = new ProjectAccess();
    detail.setProjectName(projectName);
    if (config.getRevision() != null) {
        detail.setRevision(config.getRevision().name());
    }
    detail.setInheritsFrom(config.getProject().getParent(allProjectsName));
    if (projectName.equals(allProjectsName)) {
        if (pc.isOwner()) {
            ownerOf.add(AccessSection.GLOBAL_CAPABILITIES);
        }
    }
    detail.setLocal(local);
    detail.setOwnerOf(ownerOf);
    detail.setConfigVisible(pc.isOwner() || metaConfigControl.isVisible());
    return detail;
}
#end_block

#method_before
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch;
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            replication.replicateNewProject(nameKey, head);
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommit(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (RepositoryNotFoundException doesNotExist) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, err);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#method_after
public void createProject() throws ProjectCreationFailedException {
    validateParameters();
    final Project.NameKey nameKey = createProjectArgs.getProject();
    try {
        final String head = createProjectArgs.permissionsOnly ? GitRepositoryManager.REF_CONFIG : createProjectArgs.branch.get(0);
        final Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                l.onNewProjectCreated(event);
            }
            final RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig();
            if (!createProjectArgs.permissionsOnly && createProjectArgs.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, createProjectArgs.branch);
            }
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.", e);
    } catch (RepositoryNotFoundException badName) {
        throw new ProjectCreationFailedException("Cannot create " + nameKey, badName);
    } catch (IllegalStateException err) {
        try {
            final Repository repo = repoManager.openRepository(nameKey);
            try {
                if (repo.getObjectDatabase().exists()) {
                    throw new ProjectCreationFailedException("project \"" + nameKey + "\" exists");
                }
            } finally {
                repo.close();
            }
        } catch (IOException ioErr) {
            final String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw new ProjectCreationFailedException(msg, ioErr);
        }
    } catch (Exception e) {
        final String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw new ProjectCreationFailedException(msg, e);
    }
}
#end_block

#method_before
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                ExtGroup g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    replication.scheduleUpdate(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#method_after
private void createProjectConfig() throws IOException, ConfigInvalidException {
    final MetaDataUpdate md = metaDataUpdateFactory.create(createProjectArgs.getProject());
    try {
        final ProjectConfig config = ProjectConfig.read(md);
        config.load(md);
        Project newProject = config.getProject();
        newProject.setDescription(createProjectArgs.projectDescription);
        newProject.setSubmitType(createProjectArgs.submitType);
        newProject.setUseContributorAgreements(createProjectArgs.contributorAgreements);
        newProject.setUseSignedOffBy(createProjectArgs.signedOffBy);
        newProject.setUseContentMerge(createProjectArgs.contentMerge);
        newProject.setRequireChangeID(createProjectArgs.changeIdRequired);
        if (createProjectArgs.newParent != null) {
            newProject.setParentName(createProjectArgs.newParent.getProject().getNameKey());
        }
        if (!createProjectArgs.ownerIds.isEmpty()) {
            final AccessSection all = config.getAccessSection(AccessSection.ALL, true);
            for (AccountGroup.UUID ownerId : createProjectArgs.ownerIds) {
                GroupDescription.Basic g = groupBackend.get(ownerId);
                if (g != null) {
                    GroupReference group = config.resolve(GroupReference.forGroup(g));
                    all.getPermission(Permission.OWNER, true).add(new PermissionRule(group));
                }
            }
        }
        md.setMessage("Created project\n");
        if (!config.commit(md)) {
            throw new IOException("Cannot create " + createProjectArgs.getProjectName());
        }
    } finally {
        md.close();
    }
    projectCache.onCreateProject(createProjectArgs.getProject());
    repoManager.setProjectDescription(createProjectArgs.getProject(), createProjectArgs.projectDescription);
    referenceUpdated.fire(createProjectArgs.getProject(), GitRepositoryManager.REF_CONFIG);
}
#end_block

#method_before
private void validateParameters() throws ProjectCreationFailedException {
    if (createProjectArgs.getProjectName() == null || createProjectArgs.getProjectName().isEmpty()) {
        throw new ProjectCreationFailedException("Project name is required");
    }
    if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) {
        createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, createProjectArgs.getProjectName().length() - Constants.DOT_GIT_EXT.length()));
    }
    if (!currentUser.getCapabilities().canCreateProject()) {
        throw new ProjectCreationFailedException(String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName()));
    }
    if (createProjectArgs.ownerIds == null || createProjectArgs.ownerIds.isEmpty()) {
        createProjectArgs.ownerIds = new ArrayList<AccountGroup.UUID>(projectOwnerGroups);
    }
    while (createProjectArgs.branch.startsWith("/")) {
        createProjectArgs.branch = createProjectArgs.branch.substring(1);
    }
    if (!createProjectArgs.branch.startsWith(Constants.R_HEADS)) {
        createProjectArgs.branch = Constants.R_HEADS + createProjectArgs.branch;
    }
    if (!Repository.isValidRefName(createProjectArgs.branch)) {
        throw new ProjectCreationFailedException(String.format("Branch \"%s\" is not a valid name.", createProjectArgs.branch));
    }
}
#method_after
private void validateParameters() throws ProjectCreationFailedException {
    if (createProjectArgs.getProjectName() == null || createProjectArgs.getProjectName().isEmpty()) {
        throw new ProjectCreationFailedException("Project name is required");
    }
    if (createProjectArgs.getProjectName().endsWith(Constants.DOT_GIT_EXT)) {
        createProjectArgs.setProjectName(createProjectArgs.getProjectName().substring(0, createProjectArgs.getProjectName().length() - Constants.DOT_GIT_EXT.length()));
    }
    if (!currentUser.getCapabilities().canCreateProject()) {
        throw new ProjectCreationFailedException(String.format("%s does not have \"Create Project\" capability.", currentUser.getUserName()));
    }
    if (createProjectArgs.ownerIds == null || createProjectArgs.ownerIds.isEmpty()) {
        createProjectArgs.ownerIds = new ArrayList<AccountGroup.UUID>(projectOwnerGroups);
    }
    List<String> transformedBranches = new ArrayList<String>();
    if (createProjectArgs.branch == null || createProjectArgs.branch.isEmpty()) {
        createProjectArgs.branch = Collections.singletonList(Constants.MASTER);
    }
    for (String branch : createProjectArgs.branch) {
        while (branch.startsWith("/")) {
            branch = branch.substring(1);
        }
        if (!branch.startsWith(Constants.R_HEADS)) {
            branch = Constants.R_HEADS + branch;
        }
        if (!Repository.isValidRefName(branch)) {
            throw new ProjectCreationFailedException(String.format("Branch \"%s\" is not a valid name.", branch));
        }
        if (!transformedBranches.contains(branch)) {
            transformedBranches.add(branch);
        }
    }
    createProjectArgs.branch = transformedBranches;
}
#end_block

#method_before
private AccountState state() {
    if (state == null) {
        state = accountCache.get(getAccountId());
    }
    return state;
}
#method_after
public AccountState state() {
    if (state == null) {
        state = accountCache.get(getAccountId());
    }
    return state;
}
#end_block

#method_before
@Override
public GroupMembership getEffectiveGroups() {
    if (effectiveGroups == null) {
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            effectiveGroups = groupBackend.membershipsOf(state());
        } else {
            effectiveGroups = registeredGroups;
        }
    }
    return effectiveGroups;
}
#method_after
@Override
public GroupMembership getEffectiveGroups() {
    if (effectiveGroups == null) {
        if (authConfig.isIdentityTrustable(state().getExternalIds())) {
            effectiveGroups = groupBackend.membershipsOf(this);
        } else {
            effectiveGroups = registeredGroups;
        }
    }
    return effectiveGroups;
}
#end_block

#method_before
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = groupCache.get(groupId);
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    detail.setOwnerGroup(groupCache.get(group.getOwnerGroupId()));
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#method_after
@Override
public GroupDetail call() throws OrmException, NoSuchGroupException {
    control = groupControl.validateFor(groupId);
    final AccountGroup group = groupCache.get(groupId);
    final GroupDetail detail = new GroupDetail();
    detail.setGroup(group);
    GroupDescription.Basic ownerGroup = groupBackend.get(group.getOwnerGroupUUID());
    if (ownerGroup != null) {
        detail.setOwnerGroup(GroupReference.forGroup(ownerGroup));
    }
    switch(group.getType()) {
        case INTERNAL:
            detail.setMembers(loadMembers());
            detail.setIncludes(loadIncludes());
            break;
    }
    detail.setAccounts(aic.create());
    detail.setCanModify(control.isOwner());
    detail.setGroups(gic.create());
    return detail;
}
#end_block

#method_before
public void changeGroupOwner(final AccountGroup.Id groupId, final String newOwnerName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            final AccountGroup owner = groupCache.get(new AccountGroup.NameKey(newOwnerName));
            if (owner == null) {
                throw new Failure(new NoSuchEntityException());
            }
            group.setOwnerGroupId(owner.getId());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#method_after
public void changeGroupOwner(final AccountGroup.Id groupId, final String newOwnerName, final AsyncCallback<VoidResult> callback) {
    run(callback, new Action<VoidResult>() {

        public VoidResult run(final ReviewDb db) throws OrmException, Failure {
            final AccountGroup group = db.accountGroups().get(groupId);
            assertAmGroupOwner(db, group);
            GroupReference owner = GroupBackends.findExactSuggestion(groupBackend, newOwnerName);
            if (owner == null) {
                throw new Failure(new NoSuchEntityException());
            }
            group.setOwnerGroupUUID(owner.getUUID());
            db.accountGroups().update(Collections.singleton(group));
            groupCache.evict(group);
            return VoidResult.INSTANCE;
        }
    });
}
#end_block

#method_before
public boolean updateGroupNames(GroupBackend groupBackend) {
    boolean dirty = false;
    for (GroupReference ref : groupsByUUID.values()) {
        ExtGroup g = groupBackend.get(ref.getUUID());
        if (g != null && !g.getName().equals(ref.getName())) {
            dirty = true;
            ref.setName(g.getName());
        }
    }
    return dirty;
}
#method_after
public boolean updateGroupNames(GroupBackend groupBackend) {
    boolean dirty = false;
    for (GroupReference ref : groupsByUUID.values()) {
        GroupDescription.Basic g = groupBackend.get(ref.getUUID());
        if (g != null && !g.getName().equals(ref.getName())) {
            dirty = true;
            ref.setName(g.getName());
        }
    }
    return dirty;
}
#end_block

#method_before
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
}
#method_after
@Override
protected void onLoad() throws IOException, ConfigInvalidException {
    Map<String, GroupReference> groupsByName = readGroupList();
    rulesId = getObjectId("rules.pl");
    Config rc = readConfig(PROJECT_CONFIG);
    project = new Project(projectName);
    Project p = project;
    p.setDescription(rc.getString(PROJECT, null, KEY_DESCRIPTION));
    if (p.getDescription() == null) {
        p.setDescription("");
    }
    p.setParentName(rc.getString(ACCESS, null, KEY_INHERIT_FROM));
    p.setUseContributorAgreements(getBoolean(rc, RECEIVE, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, false));
    p.setUseSignedOffBy(getBoolean(rc, RECEIVE, KEY_REQUIRE_SIGNED_OFF_BY, false));
    p.setRequireChangeID(getBoolean(rc, RECEIVE, KEY_REQUIRE_CHANGE_ID, false));
    p.setSubmitType(getEnum(rc, SUBMIT, null, KEY_ACTION, defaultSubmitAction));
    p.setUseContentMerge(getBoolean(rc, SUBMIT, KEY_MERGE_CONTENT, false));
    p.setState(getEnum(rc, PROJECT, null, KEY_STATE, defaultStateValue));
    loadAccountsSection(rc, groupsByName);
    loadContributorAgreements(rc, groupsByName);
    loadAccessSections(rc, groupsByName);
    loadNotifySections(rc, groupsByName);
}
#end_block

#method_before
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#method_after
@Override
protected void onSave(CommitBuilder commit) throws IOException, ConfigInvalidException {
    if (commit.getMessage() == null || "".equals(commit.getMessage())) {
        commit.setMessage("Updated project configuration\n");
    }
    Config rc = readConfig(PROJECT_CONFIG);
    Project p = project;
    if (p.getDescription() != null && !p.getDescription().isEmpty()) {
        rc.setString(PROJECT, null, KEY_DESCRIPTION, p.getDescription());
    } else {
        rc.unset(PROJECT, null, KEY_DESCRIPTION);
    }
    set(rc, ACCESS, null, KEY_INHERIT_FROM, p.getParentName());
    set(rc, RECEIVE, null, KEY_REQUIRE_CONTRIBUTOR_AGREEMENT, p.isUseContributorAgreements());
    set(rc, RECEIVE, null, KEY_REQUIRE_SIGNED_OFF_BY, p.isUseSignedOffBy());
    set(rc, RECEIVE, null, KEY_REQUIRE_CHANGE_ID, p.isRequireChangeID());
    set(rc, SUBMIT, null, KEY_ACTION, p.getSubmitType(), defaultSubmitAction);
    set(rc, SUBMIT, null, KEY_MERGE_CONTENT, p.isUseContentMerge());
    set(rc, PROJECT, null, KEY_STATE, p.getState(), null);
    Set<AccountGroup.UUID> keepGroups = new HashSet<AccountGroup.UUID>();
    saveAccountsSection(rc, keepGroups);
    saveContributorAgreements(rc, keepGroups);
    saveAccessSections(rc, keepGroups);
    saveNotifySections(rc, keepGroups);
    groupsByUUID.keySet().retainAll(keepGroups);
    saveConfig(PROJECT_CONFIG, rc);
    saveGroupList();
}
#end_block

#method_before
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), account.getId());
}
#method_after
@Override
public void onCreateAccount(final AuthRequest who, final Account account) {
    usernameCache.put(who.getLocalUser(), Optional.of(account.getId()));
}
#end_block

#method_before
@Override
public Account.Id lookup(final String accountName) {
    return usernameCache.get(accountName);
}
#method_after
@Override
public Account.Id lookup(String accountName) {
    if (Strings.isNullOrEmpty(accountName)) {
        return null;
    }
    try {
        Optional<Account.Id> id = usernameCache.get(accountName);
        return id != null ? id.orNull() : null;
    } catch (ExecutionException e) {
        log.warn(String.format("Cannot lookup account %s in LDAP", accountName), e);
        return null;
    }
}
#end_block

#method_before
public static GroupReference forGroup(ExtGroup group) {
    return new GroupReference(group.getGroupUUID(), group.getName());
}
#method_after
public static GroupReference forGroup(GroupDescription.Basic group) {
    return new GroupReference(group.getGroupUUID(), group.getName());
}
#end_block

#method_before
public final MergeTip run(final CodeReviewCommit currentTip, final Collection<CodeReviewCommit> toMerge) throws IntegrateException {
    refLogIdent = null;
    checkState(args.caller != null);
    return _run(currentTip, toMerge);
}
#method_after
public final MergeTip run(final CodeReviewCommit currentTip, final Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    refLogIdent = null;
    checkState(args.caller != null);
    return _run(currentTip, toMerge);
}
#end_block

#method_before
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws IntegrateException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = sort(toMerge);
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (mergeTip.getCurrentTip() == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            mergeTip.moveTipTo(n, n);
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.setStatusCode(CommitMergeStatus.CANNOT_REBASE_ROOT);
        } else if (n.getParentCount() == 1) {
            if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, n)) {
                n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                mergeTip.moveTipTo(n, n);
            } else {
                try {
                    PatchSet newPatchSet = rebase(n, mergeTip);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, n.getControl(), n.getPatchsetId())) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    // rebaseChange.rebase() may already have copied some approvals,
                    // use upsert, not insert, to avoid constraint violation on database
                    args.db.patchSetApprovals().upsert(approvals);
                    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    mergeTip.moveTipTo(newTip, newTip);
                    n.change().setCurrentPatchSet(patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
                    mergeTip.getCurrentTip().copyFrom(n);
                    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(n.change(), args.caller));
                    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
                    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
                    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
                    setRefLogIdent();
                } catch (MergeConflictException e) {
                    n.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
                    throw new IntegrateException("Cannot rebase " + n.name(), e);
                } catch (NoSuchChangeException | OrmException | IOException | RestApiException | UpdateException e) {
                    // so it can turn into a 409.
                    throw new IntegrateException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(mergeTip.getCurrentTip(), n)) {
                    mergeTip.moveTipTo(n, n);
                } else {
                    PersonIdent myIdent = args.serverIdent.get();
                    mergeTip.moveTipTo(args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n);
                }
                args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
                setRefLogIdent();
            } catch (IOException e) {
                throw new IntegrateException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(mergeTip.getCurrentTip());
    }
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = sort(toMerge);
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (mergeTip.getCurrentTip() == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            mergeTip.moveTipTo(n, n);
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.setStatusCode(CommitMergeStatus.CANNOT_REBASE_ROOT);
        } else if (n.getParentCount() == 1) {
            if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, n)) {
                n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                mergeTip.moveTipTo(n, n);
            } else {
                try {
                    PatchSet newPatchSet = rebase(n, mergeTip);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, n.getControl(), n.getPatchsetId())) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    // rebaseChange.rebase() may already have copied some approvals,
                    // use upsert, not insert, to avoid constraint violation on database
                    args.db.patchSetApprovals().upsert(approvals);
                    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    mergeTip.moveTipTo(newTip, newTip);
                    n.change().setCurrentPatchSet(patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
                    mergeTip.getCurrentTip().copyFrom(n);
                    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(n.change(), args.caller));
                    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
                    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
                    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
                    setRefLogIdent();
                } catch (MergeConflictException e) {
                    n.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
                    throw new IntegrationException("Cannot rebase " + n.name() + ": " + e.getMessage(), e);
                } catch (NoSuchChangeException | OrmException | IOException | RestApiException | UpdateException e) {
                    throw new IntegrationException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(mergeTip.getCurrentTip(), n)) {
                    mergeTip.moveTipTo(n, n);
                } else {
                    PersonIdent myIdent = args.serverIdent.get();
                    mergeTip.moveTipTo(args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n);
                }
                args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
                setRefLogIdent();
            } catch (IOException e) {
                throw new IntegrationException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(mergeTip.getCurrentTip());
    }
    return mergeTip;
}
#end_block

#method_before
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrateException {
    try {
        List<CodeReviewCommit> result = new RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag).sort(toSort);
        Collections.sort(result, CodeReviewCommit.ORDER);
        return result;
    } catch (IOException e) {
        throw new IntegrateException("Commit sorting failed", e);
    }
}
#method_after
private List<CodeReviewCommit> sort(Collection<CodeReviewCommit> toSort) throws IntegrationException {
    try {
        List<CodeReviewCommit> result = new RebaseSorter(args.rw, args.alreadyAccepted, args.canMergeFlag).sort(toSort);
        Collections.sort(result, CodeReviewCommit.ORDER);
        return result;
    } catch (IOException e) {
        throw new IntegrationException("Commit sorting failed", e);
    }
}
#end_block

#method_before
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrateException {
    return !args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge) && args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge);
}
#method_after
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    return !args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge) && args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge);
}
#end_block

#method_before
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws IntegrateException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    final CodeReviewCommit newMergeTipCommit = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
    mergeTip.moveTipTo(newMergeTipCommit, newMergeTipCommit);
    while (!sorted.isEmpty()) {
        final CodeReviewCommit n = sorted.remove(0);
        n.setStatusCode(CommitMergeStatus.NOT_FAST_FORWARD);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, newMergeTipCommit, args.alreadyAccepted);
    setRefLogIdent();
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    final CodeReviewCommit newMergeTipCommit = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
    mergeTip.moveTipTo(newMergeTipCommit, newMergeTipCommit);
    while (!sorted.isEmpty()) {
        final CodeReviewCommit n = sorted.remove(0);
        n.setStatusCode(CommitMergeStatus.NOT_FAST_FORWARD);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, newMergeTipCommit, args.alreadyAccepted);
    setRefLogIdent();
    return mergeTip;
}
#end_block

#method_before
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrateException {
    return args.mergeUtil.canFastForward(args.mergeSorter, mergeTip, args.rw, toMerge);
}
#method_after
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    return args.mergeUtil.canFastForward(args.mergeSorter, mergeTip, args.rw, toMerge);
}
#end_block

#method_before
@Override
protected MergeTip _run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrateException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip;
    if (branchTip == null) {
        // The branch is unborn. Take a fast-forward resolution to
        // create the branch.
        mergeTip = new MergeTip(sorted.get(0), toMerge);
        sorted.remove(0);
    } else {
        mergeTip = new MergeTip(branchTip, toMerge);
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit mergedFrom = sorted.remove(0);
        PersonIdent serverIdent = args.serverIdent.get();
        PersonIdent caller = args.caller.newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(caller, serverIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), mergedFrom);
        mergeTip.moveTipTo(newTip, mergedFrom);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    setRefLogIdent();
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip;
    if (branchTip == null) {
        // The branch is unborn. Take a fast-forward resolution to
        // create the branch.
        mergeTip = new MergeTip(sorted.get(0), toMerge);
        sorted.remove(0);
    } else {
        mergeTip = new MergeTip(branchTip, toMerge);
    }
    while (!sorted.isEmpty()) {
        CodeReviewCommit mergedFrom = sorted.remove(0);
        PersonIdent serverIdent = args.serverIdent.get();
        PersonIdent caller = args.caller.newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
        CodeReviewCommit newTip = args.mergeUtil.mergeOneCommit(caller, serverIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), mergedFrom);
        mergeTip.moveTipTo(newTip, mergedFrom);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    setRefLogIdent();
    return mergeTip;
}
#end_block

#method_before
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrateException {
    return args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge);
}
#method_after
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    return args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge);
}
#end_block

#method_before
@Override
protected MergeTip _run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrateException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip;
    if (branchTip == null) {
        // The branch is unborn. Take a fast-forward resolution to
        // create the branch.
        mergeTip = new MergeTip(sorted.get(0), toMerge);
        branchTip = sorted.remove(0);
    } else {
        mergeTip = new MergeTip(branchTip, toMerge);
        branchTip = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
    }
    mergeTip.moveTipTo(branchTip, branchTip);
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit mergedFrom = sorted.remove(0);
        PersonIdent serverIdent = args.serverIdent.get();
        PersonIdent caller = args.caller.newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
        branchTip = args.mergeUtil.mergeOneCommit(caller, serverIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, branchTip, mergedFrom);
        mergeTip.moveTipTo(branchTip, mergedFrom);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, branchTip, args.alreadyAccepted);
    setRefLogIdent();
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    List<CodeReviewCommit> sorted = args.mergeUtil.reduceToMinimalMerge(args.mergeSorter, toMerge);
    MergeTip mergeTip;
    if (branchTip == null) {
        // The branch is unborn. Take a fast-forward resolution to
        // create the branch.
        mergeTip = new MergeTip(sorted.get(0), toMerge);
        branchTip = sorted.remove(0);
    } else {
        mergeTip = new MergeTip(branchTip, toMerge);
        branchTip = args.mergeUtil.getFirstFastForward(branchTip, args.rw, sorted);
    }
    mergeTip.moveTipTo(branchTip, branchTip);
    // For every other commit do a pair-wise merge.
    while (!sorted.isEmpty()) {
        CodeReviewCommit mergedFrom = sorted.remove(0);
        PersonIdent serverIdent = args.serverIdent.get();
        PersonIdent caller = args.caller.newCommitterIdent(serverIdent.getWhen(), serverIdent.getTimeZone());
        branchTip = args.mergeUtil.mergeOneCommit(caller, serverIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, branchTip, mergedFrom);
        mergeTip.moveTipTo(branchTip, mergedFrom);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, branchTip, args.alreadyAccepted);
    setRefLogIdent();
    return mergeTip;
}
#end_block

#method_before
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrateException {
    return args.mergeUtil.canFastForward(args.mergeSorter, mergeTip, args.rw, toMerge) || args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge);
}
#method_after
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    return args.mergeUtil.canFastForward(args.mergeSorter, mergeTip, args.rw, toMerge) || args.mergeUtil.canMerge(args.mergeSorter, args.repo, mergeTip, toMerge);
}
#end_block

#method_before
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrateException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(git)) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try (ObjectInserter oi = git.newObjectInserter()) {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, oi, destChanges.get(0).change(), cherryPickCommit, refControl, identifiedUser);
            } else {
                // Change key not found on destination branch. We can create a new
                // change.
                String newTopic = null;
                if (!Strings.isNullOrEmpty(change.getTopic())) {
                    newTopic = change.getTopic() + "-" + newDest.getShortName();
                }
                Change newChange = createNewChange(git, revWalk, oi, changeKey, project, destRef, cherryPickCommit, refControl, identifiedUser, newTopic, change.getDest());
                addMessageToSourceChange(change, patch.getId(), destinationBranch, cherryPickCommit, identifiedUser, refControl);
                return newChange.getId();
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrateException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#method_after
public Change.Id cherryPick(Change change, PatchSet patch, final String message, final String ref, final RefControl refControl) throws NoSuchChangeException, OrmException, MissingObjectException, IncorrectObjectTypeException, IOException, InvalidChangeOperationException, IntegrationException, UpdateException, RestApiException {
    if (Strings.isNullOrEmpty(ref)) {
        throw new InvalidChangeOperationException("Cherry Pick: Destination branch cannot be null or empty");
    }
    Project.NameKey project = change.getProject();
    String destinationBranch = RefNames.shortName(ref);
    IdentifiedUser identifiedUser = user.get();
    try (Repository git = gitManager.openRepository(project);
        CodeReviewRevWalk revWalk = CodeReviewCommit.newRevWalk(git)) {
        Ref destRef = git.getRefDatabase().exactRef(ref);
        if (destRef == null) {
            throw new InvalidChangeOperationException(String.format("Branch %s does not exist.", destinationBranch));
        }
        CodeReviewCommit mergeTip = revWalk.parseCommit(destRef.getObjectId());
        CodeReviewCommit commitToCherryPick = revWalk.parseCommit(ObjectId.fromString(patch.getRevision().get()));
        PersonIdent committerIdent = identifiedUser.newCommitterIdent(TimeUtil.nowTs(), serverTimeZone);
        final ObjectId computedChangeId = ChangeIdUtil.computeChangeId(commitToCherryPick.getTree(), mergeTip, commitToCherryPick.getAuthorIdent(), committerIdent, message);
        String commitMessage = ChangeIdUtil.insertId(message, computedChangeId).trim() + '\n';
        CodeReviewCommit cherryPickCommit;
        try (ObjectInserter oi = git.newObjectInserter()) {
            ProjectState projectState = refControl.getProjectControl().getProjectState();
            cherryPickCommit = mergeUtilFactory.create(projectState).createCherryPickFromCommit(git, oi, mergeTip, commitToCherryPick, committerIdent, commitMessage, revWalk);
            Change.Key changeKey;
            final List<String> idList = cherryPickCommit.getFooterLines(FooterConstants.CHANGE_ID);
            if (!idList.isEmpty()) {
                final String idStr = idList.get(idList.size() - 1).trim();
                changeKey = new Change.Key(idStr);
            } else {
                changeKey = new Change.Key("I" + computedChangeId.name());
            }
            Branch.NameKey newDest = new Branch.NameKey(change.getProject(), destRef.getName());
            List<ChangeData> destChanges = queryProvider.get().setLimit(2).byBranchKey(newDest, changeKey);
            if (destChanges.size() > 1) {
                throw new InvalidChangeOperationException("Several changes with key " + changeKey + " reside on the same branch. " + "Cannot create a new patch set.");
            } else if (destChanges.size() == 1) {
                // will be added as a new patch set.
                return insertPatchSet(git, revWalk, oi, destChanges.get(0).change(), cherryPickCommit, refControl, identifiedUser);
            } else {
                // Change key not found on destination branch. We can create a new
                // change.
                String newTopic = null;
                if (!Strings.isNullOrEmpty(change.getTopic())) {
                    newTopic = change.getTopic() + "-" + newDest.getShortName();
                }
                Change newChange = createNewChange(git, revWalk, oi, changeKey, project, destRef, cherryPickCommit, refControl, identifiedUser, newTopic, change.getDest());
                addMessageToSourceChange(change, patch.getId(), destinationBranch, cherryPickCommit, identifiedUser, refControl);
                return newChange.getId();
            }
        } catch (MergeIdenticalTreeException | MergeConflictException e) {
            throw new IntegrationException("Cherry pick failed: " + e.getMessage());
        }
    } catch (RepositoryNotFoundException e) {
        throw new NoSuchChangeException(change.getId(), e);
    }
}
#end_block

#method_before
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller) throws IntegrateException, NoSuchProjectException {
    ProjectState project = getProject(destBranch);
    SubmitStrategy.Arguments args = new SubmitStrategy.Arguments(identifiedUserFactory, myIdent, db, batchUpdateFactory, changeControlFactory, repo, rw, inserter, canMergeFlag, alreadyAccepted, destBranch, approvalsUtil, mergeUtilFactory.create(project), indexer, caller);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args, patchSetInfoFactory);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args, patchSetInfoFactory, rebaseFactory);
        default:
            final String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrateException(errorMsg);
    }
}
#method_after
public SubmitStrategy create(SubmitType submitType, ReviewDb db, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Set<RevCommit> alreadyAccepted, Branch.NameKey destBranch, IdentifiedUser caller) throws IntegrationException, NoSuchProjectException {
    ProjectState project = getProject(destBranch);
    SubmitStrategy.Arguments args = new SubmitStrategy.Arguments(identifiedUserFactory, myIdent, db, batchUpdateFactory, changeControlFactory, repo, rw, inserter, canMergeFlag, alreadyAccepted, destBranch, approvalsUtil, mergeUtilFactory.create(project), indexer, caller);
    switch(submitType) {
        case CHERRY_PICK:
            return new CherryPick(args, patchSetInfoFactory);
        case FAST_FORWARD_ONLY:
            return new FastForwardOnly(args);
        case MERGE_ALWAYS:
            return new MergeAlways(args);
        case MERGE_IF_NECESSARY:
            return new MergeIfNecessary(args);
        case REBASE_IF_NECESSARY:
            return new RebaseIfNecessary(args, patchSetInfoFactory, rebaseFactory);
        default:
            final String errorMsg = "No submit strategy for: " + submitType;
            log.error(errorMsg);
            throw new IntegrationException(errorMsg);
    }
}
#end_block

#method_before
@Override
public Boolean call() throws NoSuchProjectException, IntegrateException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    RefDatabase refDatabase = repo.getRefDatabase();
    Iterable<Ref> refs = Iterables.concat(refDatabase.getRefs(Constants.R_HEADS).values(), refDatabase.getRefs(Constants.R_TAGS).values());
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = rw.parseCommit(key.commit);
        rev.add(canMerge);
        CodeReviewCommit tip = rw.parseCommit(key.into);
        Set<RevCommit> accepted = alreadyAccepted(rw, refs);
        accepted.add(tip);
        accepted.addAll(Arrays.asList(rev.getParents()));
        return submitStrategyFactory.create(key.submitType, db, repo, rw, null, /*inserter*/
        canMerge, accepted, dest, null).dryRun(tip, rev);
    }
}
#method_after
@Override
public Boolean call() throws NoSuchProjectException, IntegrationException, IOException {
    if (key.into.equals(ObjectId.zeroId())) {
        // Assume yes on new branch.
        return true;
    }
    RefDatabase refDatabase = repo.getRefDatabase();
    Iterable<Ref> refs = Iterables.concat(refDatabase.getRefs(Constants.R_HEADS).values(), refDatabase.getRefs(Constants.R_TAGS).values());
    try (CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
        RevFlag canMerge = rw.newFlag("CAN_MERGE");
        CodeReviewCommit rev = rw.parseCommit(key.commit);
        rev.add(canMerge);
        CodeReviewCommit tip = rw.parseCommit(key.into);
        Set<RevCommit> accepted = alreadyAccepted(rw, refs);
        accepted.add(tip);
        accepted.addAll(Arrays.asList(rev.getParents()));
        return submitStrategyFactory.create(key.submitType, db, repo, rw, null, /*inserter*/
        canMerge, accepted, dest, null).dryRun(tip, rev);
    }
}
#end_block

#method_before
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                    CodeReviewCommit commit = rw.parseCommit(changeDataCache.getTestAgainst());
                    SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest(), null);
                    CodeReviewCommit otherCommit = rw.parseCommit(other);
                    otherCommit.add(canMergeFlag);
                    conflicts = !strategy.dryRun(commit, otherCommit);
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrateException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws IntegrateException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new IntegrateException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#method_after
private static List<Predicate<ChangeData>> predicates(final Arguments args, String value, List<Change> changes) throws OrmException {
    List<Predicate<ChangeData>> changePredicates = Lists.newArrayListWithCapacity(changes.size());
    final Provider<ReviewDb> db = args.db;
    for (final Change c : changes) {
        final ChangeDataCache changeDataCache = new ChangeDataCache(c, db, args.changeDataFactory, args.projectCache);
        List<String> files = listFiles(c, args, changeDataCache);
        List<Predicate<ChangeData>> filePredicates = Lists.newArrayListWithCapacity(files.size());
        for (String file : files) {
            filePredicates.add(new EqualsPathPredicate(ChangeQueryBuilder.FIELD_PATH, file));
        }
        List<Predicate<ChangeData>> predicatesForOneChange = Lists.newArrayListWithCapacity(5);
        predicatesForOneChange.add(not(new LegacyChangeIdPredicate(args.getSchema(), c.getId())));
        predicatesForOneChange.add(new ProjectPredicate(c.getProject().get()));
        predicatesForOneChange.add(new RefPredicate(c.getDest().get()));
        predicatesForOneChange.add(or(or(filePredicates), new IsMergePredicate(args, value)));
        predicatesForOneChange.add(new OperatorPredicate<ChangeData>(ChangeQueryBuilder.FIELD_CONFLICTS, value) {

            @Override
            public boolean match(ChangeData object) throws OrmException {
                Change otherChange = object.change();
                if (otherChange == null) {
                    return false;
                }
                if (!otherChange.getDest().equals(c.getDest())) {
                    return false;
                }
                SubmitType submitType = getSubmitType(object);
                if (submitType == null) {
                    return false;
                }
                ObjectId other = ObjectId.fromString(object.currentPatchSet().getRevision().get());
                ConflictKey conflictsKey = new ConflictKey(changeDataCache.getTestAgainst(), other, submitType, changeDataCache.getProjectState().isUseContentMerge());
                Boolean conflicts = args.conflictsCache.getIfPresent(conflictsKey);
                if (conflicts != null) {
                    return conflicts;
                }
                try (Repository repo = args.repoManager.openRepository(otherChange.getProject());
                    CodeReviewRevWalk rw = CodeReviewCommit.newRevWalk(repo)) {
                    RevFlag canMergeFlag = rw.newFlag("CAN_MERGE");
                    CodeReviewCommit commit = rw.parseCommit(changeDataCache.getTestAgainst());
                    SubmitStrategy strategy = args.submitStrategyFactory.create(submitType, db.get(), repo, rw, null, canMergeFlag, getAlreadyAccepted(repo, rw, commit), otherChange.getDest(), null);
                    CodeReviewCommit otherCommit = rw.parseCommit(other);
                    otherCommit.add(canMergeFlag);
                    conflicts = !strategy.dryRun(commit, otherCommit);
                    args.conflictsCache.put(conflictsKey, conflicts);
                    return conflicts;
                } catch (IntegrationException | NoSuchProjectException | IOException e) {
                    throw new IllegalStateException(e);
                }
            }

            @Override
            public int getCost() {
                return 5;
            }

            private SubmitType getSubmitType(ChangeData cd) throws OrmException {
                SubmitTypeRecord r = new SubmitRuleEvaluator(cd).getSubmitType();
                if (r.status != SubmitTypeRecord.Status.OK) {
                    return null;
                }
                return r.type;
            }

            private Set<RevCommit> getAlreadyAccepted(Repository repo, RevWalk rw, CodeReviewCommit tip) throws IntegrationException {
                Set<RevCommit> alreadyAccepted = Sets.newHashSet();
                if (tip != null) {
                    alreadyAccepted.add(tip);
                }
                try {
                    for (ObjectId id : changeDataCache.getAlreadyAccepted(repo)) {
                        try {
                            alreadyAccepted.add(rw.parseCommit(id));
                        } catch (IncorrectObjectTypeException iote) {
                        // Not a commit? Skip over it.
                        }
                    }
                } catch (IOException e) {
                    throw new IntegrationException("Failed to determine already accepted commits.", e);
                }
                return alreadyAccepted;
            }
        });
        changePredicates.add(and(predicatesForOneChange));
    }
    return changePredicates;
}
#end_block

#method_before
@Override
protected MergeTip _run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrateException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = CodeReviewCommit.ORDER.sortedCopy(toMerge);
    boolean first = true;
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            Change.Id cid = n.change().getId();
            if (first && branchTip == null) {
                u.addOp(cid, new CherryPickUnbornRootOp(mergeTip, n));
            } else if (n.getParentCount() == 0) {
                u.addOp(cid, new CherryPickRootOp(n));
            } else if (n.getParentCount() == 1) {
                u.addOp(cid, new CherryPickOneOp(mergeTip, n));
            } else {
                u.addOp(cid, new CherryPickMultipleParentsOp(mergeTip, n));
            }
            first = false;
        }
        u.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IntegrateException("Cannot cherry-pick onto " + args.destBranch);
    }
    // mutating a single shared MergeTip passed in from the caller.
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(CodeReviewCommit branchTip, Collection<CodeReviewCommit> toMerge) throws IntegrationException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = CodeReviewCommit.ORDER.sortedCopy(toMerge);
    boolean first = true;
    try (BatchUpdate u = args.newBatchUpdate(TimeUtil.nowTs())) {
        while (!sorted.isEmpty()) {
            CodeReviewCommit n = sorted.remove(0);
            Change.Id cid = n.change().getId();
            if (first && branchTip == null) {
                u.addOp(cid, new CherryPickUnbornRootOp(mergeTip, n));
            } else if (n.getParentCount() == 0) {
                u.addOp(cid, new CherryPickRootOp(n));
            } else if (n.getParentCount() == 1) {
                u.addOp(cid, new CherryPickOneOp(mergeTip, n));
            } else {
                u.addOp(cid, new CherryPickMultipleParentsOp(mergeTip, n));
            }
            first = false;
        }
        u.execute();
    } catch (UpdateException | RestApiException e) {
        throw new IntegrationException("Cannot cherry-pick onto " + args.destBranch);
    }
    // mutating a single shared MergeTip passed in from the caller.
    return mergeTip;
}
#end_block

#method_before
@Override
public void updateRepo(RepoContext ctx) throws IntegrateException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // was configured.
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent.get(), ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(result, toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    setRefLogIdent();
}
#method_after
@Override
public void updateRepo(RepoContext ctx) throws IntegrationException, IOException {
    if (args.mergeUtil.hasMissingDependencies(args.mergeSorter, toMerge)) {
        // on the commit so we have nothing further to perform at this time.
        return;
    }
    // was configured.
    if (args.rw.isMergedInto(mergeTip.getCurrentTip(), toMerge)) {
        mergeTip.moveTipTo(toMerge, toMerge);
    } else {
        PersonIdent myIdent = new PersonIdent(args.serverIdent.get(), ctx.getWhen());
        CodeReviewCommit result = args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), toMerge);
        mergeTip.moveTipTo(result, toMerge);
    }
    args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
    setRefLogIdent();
}
#end_block

#method_before
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrateException {
    return args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge);
}
#method_after
@Override
public boolean dryRun(CodeReviewCommit mergeTip, CodeReviewCommit toMerge) throws IntegrationException {
    return args.mergeUtil.canCherryPick(args.mergeSorter, args.repo, mergeTip, args.rw, toMerge);
}
#end_block

#method_before
private void setDestProject(Branch.NameKey destBranch) throws IntegrateException {
    destProject = projectCache.get(destBranch.getParentKey());
    if (destProject == null) {
        throw new IntegrateException("No such project: " + destBranch.getParentKey());
    }
}
#method_after
private void setDestProject(Branch.NameKey destBranch) throws IntegrationException {
    destProject = projectCache.get(destBranch.getParentKey());
    if (destProject == null) {
        throw new IntegrationException("No such project: " + destBranch.getParentKey());
    }
}
#end_block

#method_before
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (IntegrateException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, Change change, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    updateSubmissionId(change);
    this.db = db;
    logDebug("Beginning integration of {}", change);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, change);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (IntegrationException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws IntegrateException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, ListMultimap<SubmitType, ChangeData>> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        for (Project.NameKey project : br.keySet()) {
            openRepository(project);
            for (Branch.NameKey branch : br.get(project)) {
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = validateChangeList(cbb.get(branch));
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch), caller);
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    updateChangeStatus(submitting.get(submitType), branch, true, caller);
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            openRepository(project);
            for (Branch.NameKey branch : br.get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false, caller);
                    updateSubmoduleSubscriptions(subOp, branch, getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(subOp, br.values());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new IntegrateException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrateException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws IntegrationException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, ListMultimap<SubmitType, ChangeData>> toSubmit = new HashMap<>();
    logDebug("Perform the merges");
    try {
        Multimap<Project.NameKey, Branch.NameKey> br = cs.branchesByProject();
        Multimap<Branch.NameKey, ChangeData> cbb = cs.changesByBranch();
        for (Project.NameKey project : br.keySet()) {
            openRepository(project);
            for (Branch.NameKey branch : br.get(project)) {
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = validateChangeList(cbb.get(branch));
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch), caller);
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    updateChangeStatus(submitting.get(submitType), branch, true, caller);
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : br.keySet()) {
            openRepository(project);
            for (Branch.NameKey branch : br.get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false, caller);
                    updateSubmoduleSubscriptions(subOp, branch, getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(subOp, br.values());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new IntegrationException("Cannot query the database", e);
    } catch (IOException e) {
        throw new IntegrationException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#end_block

#method_before
private MergeTip preMerge(SubmitStrategy strategy, List<ChangeData> submitted, CodeReviewCommit branchTip) throws IntegrateException, OrmException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (ChangeData cd : submitted) {
        CodeReviewCommit commit = commits.get(cd.change().getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", cd.change().getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#method_after
private MergeTip preMerge(SubmitStrategy strategy, List<ChangeData> submitted, CodeReviewCommit branchTip) throws IntegrationException, OrmException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (ChangeData cd : submitted) {
        CodeReviewCommit commit = commits.get(cd.change().getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", cd.change().getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#end_block

#method_before
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, IdentifiedUser caller) throws IntegrateException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, caller);
}
#method_after
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, IdentifiedUser caller) throws IntegrationException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, caller);
}
#end_block

#method_before
private void openRepository(Project.NameKey name) throws IntegrateException, NoSuchProjectException {
    try {
        repo = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(name, notFound);
    } catch (IOException err) {
        String m = "Error opening repository \"" + name.get() + '"';
        throw new IntegrateException(m, err);
    }
    rw = CodeReviewCommit.newRevWalk(repo);
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    rw.setRetainBody(false);
    canMergeFlag = rw.newFlag("CAN_MERGE");
    inserter = repo.newObjectInserter();
}
#method_after
private void openRepository(Project.NameKey name) throws IntegrationException, NoSuchProjectException {
    try {
        repo = repoManager.openRepository(name);
    } catch (RepositoryNotFoundException notFound) {
        throw new NoSuchProjectException(name, notFound);
    } catch (IOException err) {
        String m = "Error opening repository \"" + name.get() + '"';
        throw new IntegrationException(m, err);
    }
    rw = CodeReviewCommit.newRevWalk(repo);
    rw.sort(RevSort.TOPO);
    rw.sort(RevSort.COMMIT_TIME_DESC, true);
    rw.setRetainBody(false);
    canMergeFlag = rw.newFlag("CAN_MERGE");
    inserter = repo.newObjectInserter();
}
#end_block

#method_before
private RefUpdate getPendingRefUpdate(Branch.NameKey destBranch) throws IntegrateException {
    if (pendingRefUpdates.containsKey(destBranch)) {
        logDebug("Access cached open branch {}: {}", destBranch.get(), openBranches.get(destBranch));
        return pendingRefUpdates.get(destBranch);
    }
    try {
        RefUpdate branchUpdate = repo.updateRef(destBranch.get());
        CodeReviewCommit branchTip;
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = rw.parseCommit(branchUpdate.getOldObjectId());
        } else if (Objects.equals(repo.getFullBranch(), destBranch.get())) {
            branchTip = null;
            branchUpdate.setExpectedOldObjectId(ObjectId.zeroId());
        } else {
            throw new IntegrateException("The destination branch " + destBranch.get() + " does not exist anymore.");
        }
        logDebug("Opened branch {}: {}", destBranch.get(), branchTip);
        pendingRefUpdates.put(destBranch, branchUpdate);
        openBranches.put(destBranch, branchTip);
        return branchUpdate;
    } catch (IOException e) {
        throw new IntegrateException("Cannot open branch", e);
    }
}
#method_after
private RefUpdate getPendingRefUpdate(Branch.NameKey destBranch) throws IntegrationException {
    if (pendingRefUpdates.containsKey(destBranch)) {
        logDebug("Access cached open branch {}: {}", destBranch.get(), openBranches.get(destBranch));
        return pendingRefUpdates.get(destBranch);
    }
    try {
        RefUpdate branchUpdate = repo.updateRef(destBranch.get());
        CodeReviewCommit branchTip;
        if (branchUpdate.getOldObjectId() != null) {
            branchTip = rw.parseCommit(branchUpdate.getOldObjectId());
        } else if (Objects.equals(repo.getFullBranch(), destBranch.get())) {
            branchTip = null;
            branchUpdate.setExpectedOldObjectId(ObjectId.zeroId());
        } else {
            throw new IntegrationException("The destination branch " + destBranch.get() + " does not exist anymore.");
        }
        logDebug("Opened branch {}: {}", destBranch.get(), branchTip);
        pendingRefUpdates.put(destBranch, branchUpdate);
        openBranches.put(destBranch, branchTip);
        return branchUpdate;
    } catch (IOException e) {
        throw new IntegrationException("Cannot open branch", e);
    }
}
#end_block

#method_before
private CodeReviewCommit getBranchTip(Branch.NameKey destBranch) throws IntegrateException {
    if (openBranches.containsKey(destBranch)) {
        return openBranches.get(destBranch);
    } else {
        getPendingRefUpdate(destBranch);
        return openBranches.get(destBranch);
    }
}
#method_after
private CodeReviewCommit getBranchTip(Branch.NameKey destBranch) throws IntegrationException {
    if (openBranches.containsKey(destBranch)) {
        return openBranches.get(destBranch);
    } else {
        getPendingRefUpdate(destBranch);
        return openBranches.get(destBranch);
    }
}
#end_block

#method_before
private Set<RevCommit> getAlreadyAccepted(CodeReviewCommit branchTip) throws IntegrateException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrateException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#method_after
private Set<RevCommit> getAlreadyAccepted(CodeReviewCommit branchTip) throws IntegrationException {
    Set<RevCommit> alreadyAccepted = new HashSet<>();
    if (branchTip != null) {
        alreadyAccepted.add(branchTip);
    }
    try {
        for (Ref r : repo.getRefDatabase().getRefs(Constants.R_HEADS).values()) {
            try {
                alreadyAccepted.add(rw.parseCommit(r.getObjectId()));
            } catch (IncorrectObjectTypeException iote) {
            // Not a commit? Skip over it.
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Failed to determine already accepted commits.", e);
    }
    logDebug("Found {} existing heads", alreadyAccepted.size());
    return alreadyAccepted;
}
#end_block

#method_before
private ListMultimap<SubmitType, ChangeData> validateChangeList(Collection<ChangeData> submitted) throws IntegrateException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, ChangeData> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new IntegrateException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new IntegrateException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new IntegrateException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, cd);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, ChangeData> validateChangeList(Collection<ChangeData> submitted) throws IntegrationException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, ChangeData> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new IntegrationException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new IntegrationException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new IntegrationException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, cd);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#end_block

#method_before
private RefUpdate updateBranch(Branch.NameKey destBranch) throws IntegrateException {
    RefUpdate branchUpdate = getPendingRefUpdate(destBranch);
    CodeReviewCommit branchTip = getBranchTip(destBranch);
    MergeTip mergeTip = mergeTips.get(destBranch);
    CodeReviewCommit currentTip = mergeTip != null ? mergeTip.getCurrentTip() : null;
    if (Objects.equals(branchTip, currentTip)) {
        if (currentTip != null) {
            logDebug("Branch already at merge tip {}, no update to perform", currentTip.name());
        } else {
            logDebug("Both branch and merge tip are nonexistent, no update");
        }
        return null;
    } else if (currentTip == null) {
        logDebug("No merge tip, no update to perform");
        return null;
    }
    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
        logDebug("Loading new configuration from {}", RefNames.REFS_CONFIG);
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, currentTip);
        } catch (Exception e) {
            throw new IntegrateException("Submit would store invalid" + " project configuration " + currentTip.name() + " for " + destProject.getProject().getName(), e);
        }
    }
    branchUpdate.setRefLogIdent(refLogIdent);
    branchUpdate.setForceUpdate(false);
    branchUpdate.setNewObjectId(currentTip);
    branchUpdate.setRefLogMessage("merged", true);
    try {
        RefUpdate.Result result = branchUpdate.update(rw);
        logDebug("Update of {}: {}..{} returned status {}", branchUpdate.getName(), branchUpdate.getOldObjectId(), branchUpdate.getNewObjectId(), result);
        switch(result) {
            case NEW:
            case FAST_FORWARD:
                if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                    tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), currentTip);
                }
                if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                    Project p = destProject.getProject();
                    projectCache.evict(p);
                    destProject = projectCache.get(p.getNameKey());
                    repoManager.setProjectDescription(p.getNameKey(), p.getDescription());
                }
                return branchUpdate;
            case LOCK_FAILURE:
                throw new IntegrateException("Failed to lock " + branchUpdate.getName());
            default:
                throw new IOException(branchUpdate.getResult().name() + '\n' + branchUpdate);
        }
    } catch (IOException e) {
        throw new IntegrateException("Cannot update " + branchUpdate.getName(), e);
    }
}
#method_after
private RefUpdate updateBranch(Branch.NameKey destBranch) throws IntegrationException {
    RefUpdate branchUpdate = getPendingRefUpdate(destBranch);
    CodeReviewCommit branchTip = getBranchTip(destBranch);
    MergeTip mergeTip = mergeTips.get(destBranch);
    CodeReviewCommit currentTip = mergeTip != null ? mergeTip.getCurrentTip() : null;
    if (Objects.equals(branchTip, currentTip)) {
        if (currentTip != null) {
            logDebug("Branch already at merge tip {}, no update to perform", currentTip.name());
        } else {
            logDebug("Both branch and merge tip are nonexistent, no update");
        }
        return null;
    } else if (currentTip == null) {
        logDebug("No merge tip, no update to perform");
        return null;
    }
    if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
        logDebug("Loading new configuration from {}", RefNames.REFS_CONFIG);
        try {
            ProjectConfig cfg = new ProjectConfig(destProject.getProject().getNameKey());
            cfg.load(repo, currentTip);
        } catch (Exception e) {
            throw new IntegrationException("Submit would store invalid" + " project configuration " + currentTip.name() + " for " + destProject.getProject().getName(), e);
        }
    }
    branchUpdate.setRefLogIdent(refLogIdent);
    branchUpdate.setForceUpdate(false);
    branchUpdate.setNewObjectId(currentTip);
    branchUpdate.setRefLogMessage("merged", true);
    try {
        RefUpdate.Result result = branchUpdate.update(rw);
        logDebug("Update of {}: {}..{} returned status {}", branchUpdate.getName(), branchUpdate.getOldObjectId(), branchUpdate.getNewObjectId(), result);
        switch(result) {
            case NEW:
            case FAST_FORWARD:
                if (branchUpdate.getResult() == RefUpdate.Result.FAST_FORWARD) {
                    tagCache.updateFastForward(destBranch.getParentKey(), branchUpdate.getName(), branchUpdate.getOldObjectId(), currentTip);
                }
                if (RefNames.REFS_CONFIG.equals(branchUpdate.getName())) {
                    Project p = destProject.getProject();
                    projectCache.evict(p);
                    destProject = projectCache.get(p.getNameKey());
                    repoManager.setProjectDescription(p.getNameKey(), p.getDescription());
                }
                return branchUpdate;
            case LOCK_FAILURE:
                throw new IntegrationException("Failed to lock " + branchUpdate.getName());
            default:
                throw new IOException(branchUpdate.getResult().name() + '\n' + branchUpdate);
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot update " + branchUpdate.getName(), e);
    }
}
#end_block

#method_before
private void updateChangeStatus(List<ChangeData> submitted, Branch.NameKey destBranch, boolean dryRun, IdentifiedUser caller) throws NoSuchChangeException, IntegrateException, ResourceConflictException, OrmException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (ChangeData cd : submitted) {
        Change c = cd.change();
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        if (!dryRun) {
            try {
                setApproval(cd, caller);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new IntegrateException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new IntegrateException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new IntegrateException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(List<ChangeData> submitted, Branch.NameKey destBranch, boolean dryRun, IdentifiedUser caller) throws NoSuchChangeException, IntegrationException, ResourceConflictException, OrmException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (ChangeData cd : submitted) {
        Change c = cd.change();
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        if (!dryRun) {
            try {
                setApproval(cd, caller);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new IntegrationException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new IntegrationException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new IntegrationException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
public CodeReviewCommit getFirstFastForward(final CodeReviewCommit mergeTip, final RevWalk rw, final List<CodeReviewCommit> toMerge) throws IntegrateException {
    for (final Iterator<CodeReviewCommit> i = toMerge.iterator(); i.hasNext(); ) {
        try {
            final CodeReviewCommit n = i.next();
            if (mergeTip == null || rw.isMergedInto(mergeTip, n)) {
                i.remove();
                return n;
            }
        } catch (IOException e) {
            throw new IntegrateException("Cannot fast-forward test during merge", e);
        }
    }
    return mergeTip;
}
#method_after
public CodeReviewCommit getFirstFastForward(final CodeReviewCommit mergeTip, final RevWalk rw, final List<CodeReviewCommit> toMerge) throws IntegrationException {
    for (final Iterator<CodeReviewCommit> i = toMerge.iterator(); i.hasNext(); ) {
        try {
            final CodeReviewCommit n = i.next();
            if (mergeTip == null || rw.isMergedInto(mergeTip, n)) {
                i.remove();
                return n;
            }
        } catch (IOException e) {
            throw new IntegrationException("Cannot fast-forward test during merge", e);
        }
    }
    return mergeTip;
}
#end_block

#method_before
public List<CodeReviewCommit> reduceToMinimalMerge(MergeSorter mergeSorter, Collection<CodeReviewCommit> toSort) throws IntegrateException {
    List<CodeReviewCommit> result = new ArrayList<>();
    try {
        result.addAll(mergeSorter.sort(toSort));
    } catch (IOException e) {
        throw new IntegrateException("Branch head sorting failed", e);
    }
    Collections.sort(result, CodeReviewCommit.ORDER);
    return result;
}
#method_after
public List<CodeReviewCommit> reduceToMinimalMerge(MergeSorter mergeSorter, Collection<CodeReviewCommit> toSort) throws IntegrationException {
    List<CodeReviewCommit> result = new ArrayList<>();
    try {
        result.addAll(mergeSorter.sort(toSort));
    } catch (IOException e) {
        throw new IntegrationException("Branch head sorting failed", e);
    }
    Collections.sort(result, CodeReviewCommit.ORDER);
    return result;
}
#end_block

#method_before
public boolean canMerge(final MergeSorter mergeSorter, final Repository repo, final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws IntegrateException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo));
    try {
        return m.merge(new AnyObjectId[] { mergeTip, toMerge });
    } catch (LargeObjectException e) {
        log.warn("Cannot merge due to LargeObjectException: " + toMerge.name());
        return false;
    } catch (NoMergeBaseException e) {
        return false;
    } catch (IOException e) {
        throw new IntegrateException("Cannot merge " + toMerge.name(), e);
    }
}
#method_after
public boolean canMerge(final MergeSorter mergeSorter, final Repository repo, final CodeReviewCommit mergeTip, final CodeReviewCommit toMerge) throws IntegrationException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo));
    try {
        return m.merge(new AnyObjectId[] { mergeTip, toMerge });
    } catch (LargeObjectException e) {
        log.warn("Cannot merge due to LargeObjectException: " + toMerge.name());
        return false;
    } catch (NoMergeBaseException e) {
        return false;
    } catch (IOException e) {
        throw new IntegrationException("Cannot merge " + toMerge.name(), e);
    }
}
#end_block

#method_before
public boolean canFastForward(MergeSorter mergeSorter, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrateException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try {
        return mergeTip == null || rw.isMergedInto(mergeTip, toMerge);
    } catch (IOException e) {
        throw new IntegrateException("Cannot fast-forward test during merge", e);
    }
}
#method_after
public boolean canFastForward(MergeSorter mergeSorter, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrationException {
    if (hasMissingDependencies(mergeSorter, toMerge)) {
        return false;
    }
    try {
        return mergeTip == null || rw.isMergedInto(mergeTip, toMerge);
    } catch (IOException e) {
        throw new IntegrationException("Cannot fast-forward test during merge", e);
    }
}
#end_block

#method_before
public boolean canCherryPick(MergeSorter mergeSorter, Repository repo, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrateException {
    if (mergeTip == null) {
        // 
        return true;
    }
    if (toMerge.getParentCount() == 0) {
        // 
        return false;
    }
    if (toMerge.getParentCount() == 1) {
        // 
        try {
            ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo));
            m.setBase(toMerge.getParent(0));
            return m.merge(mergeTip, toMerge);
        } catch (IOException e) {
            throw new IntegrateException("Cannot merge " + toMerge.name(), e);
        }
    }
    // 
    return canFastForward(mergeSorter, mergeTip, rw, toMerge) || canMerge(mergeSorter, repo, mergeTip, toMerge);
}
#method_after
public boolean canCherryPick(MergeSorter mergeSorter, Repository repo, CodeReviewCommit mergeTip, CodeReviewRevWalk rw, CodeReviewCommit toMerge) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return true;
    }
    if (toMerge.getParentCount() == 0) {
        // 
        return false;
    }
    if (toMerge.getParentCount() == 1) {
        // 
        try {
            ThreeWayMerger m = newThreeWayMerger(repo, createDryRunInserter(repo));
            m.setBase(toMerge.getParent(0));
            return m.merge(mergeTip, toMerge);
        } catch (IOException e) {
            throw new IntegrationException("Cannot merge " + toMerge.name(), e);
        }
    }
    // 
    return canFastForward(mergeSorter, mergeTip, rw, toMerge) || canMerge(mergeSorter, repo, mergeTip, toMerge);
}
#end_block

#method_before
public boolean hasMissingDependencies(final MergeSorter mergeSorter, final CodeReviewCommit toMerge) throws IntegrateException {
    try {
        return !mergeSorter.sort(Collections.singleton(toMerge)).contains(toMerge);
    } catch (IOException e) {
        throw new IntegrateException("Branch head sorting failed", e);
    }
}
#method_after
public boolean hasMissingDependencies(final MergeSorter mergeSorter, final CodeReviewCommit toMerge) throws IntegrationException {
    try {
        return !mergeSorter.sort(Collections.singleton(toMerge)).contains(toMerge);
    } catch (IOException e) {
        throw new IntegrationException("Branch head sorting failed", e);
    }
}
#end_block

#method_before
public CodeReviewCommit mergeOneCommit(PersonIdent author, PersonIdent committer, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Branch.NameKey destBranch, CodeReviewCommit mergeTip, CodeReviewCommit n) throws IntegrateException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(author, committer, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (NoMergeBaseException e) {
        try {
            failed(rw, canMergeFlag, mergeTip, n, getCommitMergeStatus(e.getReason()));
        } catch (IOException e2) {
            throw new IntegrateException("Cannot merge " + n.name(), e);
        }
    } catch (IOException e) {
        throw new IntegrateException("Cannot merge " + n.name(), e);
    }
    return mergeTip;
}
#method_after
public CodeReviewCommit mergeOneCommit(PersonIdent author, PersonIdent committer, Repository repo, CodeReviewRevWalk rw, ObjectInserter inserter, RevFlag canMergeFlag, Branch.NameKey destBranch, CodeReviewCommit mergeTip, CodeReviewCommit n) throws IntegrationException {
    final ThreeWayMerger m = newThreeWayMerger(repo, inserter);
    try {
        if (m.merge(new AnyObjectId[] { mergeTip, n })) {
            return writeMergeCommit(author, committer, rw, inserter, canMergeFlag, destBranch, mergeTip, m.getResultTreeId(), n);
        } else {
            failed(rw, canMergeFlag, mergeTip, n, CommitMergeStatus.PATH_CONFLICT);
        }
    } catch (NoMergeBaseException e) {
        try {
            failed(rw, canMergeFlag, mergeTip, n, getCommitMergeStatus(e.getReason()));
        } catch (IOException e2) {
            throw new IntegrationException("Cannot merge " + n.name(), e);
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot merge " + n.name(), e);
    }
    return mergeTip;
}
#end_block

#method_before
public void markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws IntegrateException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            }
        }
    } catch (IOException e) {
        throw new IntegrateException("Cannot mark clean merges", e);
    }
}
#method_after
public void markCleanMerges(final RevWalk rw, final RevFlag canMergeFlag, final CodeReviewCommit mergeTip, final Set<RevCommit> alreadyAccepted) throws IntegrationException {
    if (mergeTip == null) {
        // 
        return;
    }
    try {
        rw.resetRetain(canMergeFlag);
        rw.sort(RevSort.TOPO);
        rw.sort(RevSort.REVERSE, true);
        rw.markStart(mergeTip);
        for (RevCommit c : alreadyAccepted) {
            rw.markUninteresting(c);
        }
        CodeReviewCommit c;
        while ((c = (CodeReviewCommit) rw.next()) != null) {
            if (c.getPatchsetId() != null) {
                c.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            }
        }
    } catch (IOException e) {
        throw new IntegrationException("Cannot mark clean merges", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    final ChangeControl control = revision.getControl();
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    @SuppressWarnings("resource")
    ReviewDb db = dbProvider.get();
    if (!control.isVisible(db)) {
        throw new AuthException("Cherry pick not permitted");
    }
    String refName = RefNames.fullName(input.destination);
    RefControl refControl = control.getProjectControl().controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + input.destination);
    }
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(revision.getChange(), revision.getPatchSet(), input.message, refName, refControl);
        return json.create(ChangeJson.NO_OPTIONS).format(cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrateException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#method_after
@Override
public ChangeInfo apply(RevisionResource revision, CherryPickInput input) throws OrmException, IOException, UpdateException, RestApiException {
    final ChangeControl control = revision.getControl();
    if (input.message == null || input.message.trim().isEmpty()) {
        throw new BadRequestException("message must be non-empty");
    } else if (input.destination == null || input.destination.trim().isEmpty()) {
        throw new BadRequestException("destination must be non-empty");
    }
    @SuppressWarnings("resource")
    ReviewDb db = dbProvider.get();
    if (!control.isVisible(db)) {
        throw new AuthException("Cherry pick not permitted");
    }
    String refName = RefNames.fullName(input.destination);
    RefControl refControl = control.getProjectControl().controlForRef(refName);
    if (!refControl.canUpload()) {
        throw new AuthException("Not allowed to cherry pick " + revision.getChange().getId().toString() + " to " + input.destination);
    }
    try {
        Change.Id cherryPickedChangeId = cherryPickChange.cherryPick(revision.getChange(), revision.getPatchSet(), input.message, refName, refControl);
        return json.create(ChangeJson.NO_OPTIONS).format(cherryPickedChangeId);
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    } catch (IntegrationException | NoSuchChangeException e) {
        throw new ResourceConflictException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws MergeException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = sort(toMerge);
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (mergeTip.getCurrentTip() == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            mergeTip.moveTipTo(n, n);
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.setStatusCode(CommitMergeStatus.CANNOT_REBASE_ROOT);
        } else if (n.getParentCount() == 1) {
            if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, n)) {
                n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                mergeTip.moveTipTo(n, n);
            } else {
                try {
                    PatchSet newPatchSet = rebase(n, mergeTip);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, n.getControl(), n.getPatchsetId())) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    // rebaseChange.rebase() may already have copied some approvals,
                    // use upsert, not insert, to avoid constraint violation on database
                    args.db.patchSetApprovals().upsert(approvals);
                    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    mergeTip.moveTipTo(newTip, newTip);
                    n.change().setCurrentPatchSet(patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
                    mergeTip.getCurrentTip().copyFrom(n);
                    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(n.change(), args.caller));
                    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
                    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
                    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
                    setRefLogIdent();
                } catch (MergeConflictException e) {
                    n.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
                    throw new MergeException("Cannot rebase " + n.name(), e);
                } catch (NoSuchChangeException | OrmException | IOException | RestApiException | UpdateException e) {
                    // so it can turn into a 409.
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(mergeTip.getCurrentTip(), n)) {
                    mergeTip.moveTipTo(n, n);
                } else {
                    PersonIdent myIdent = args.serverIdent.get();
                    mergeTip.moveTipTo(args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n);
                }
                args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
                setRefLogIdent();
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(mergeTip.getCurrentTip());
    }
    return mergeTip;
}
#method_after
@Override
protected MergeTip _run(final CodeReviewCommit branchTip, final Collection<CodeReviewCommit> toMerge) throws MergeException {
    MergeTip mergeTip = new MergeTip(branchTip, toMerge);
    List<CodeReviewCommit> sorted = sort(toMerge);
    while (!sorted.isEmpty()) {
        CodeReviewCommit n = sorted.remove(0);
        if (mergeTip.getCurrentTip() == null) {
            // The branch is unborn. Take a fast-forward resolution to
            // create the branch.
            // 
            n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
            mergeTip.moveTipTo(n, n);
        } else if (n.getParentCount() == 0) {
            // Refuse to merge a root commit into an existing branch,
            // we cannot obtain a delta for the rebase to apply.
            // 
            n.setStatusCode(CommitMergeStatus.CANNOT_REBASE_ROOT);
        } else if (n.getParentCount() == 1) {
            if (args.mergeUtil.canFastForward(args.mergeSorter, mergeTip.getCurrentTip(), args.rw, n)) {
                n.setStatusCode(CommitMergeStatus.CLEAN_MERGE);
                mergeTip.moveTipTo(n, n);
            } else {
                try {
                    PatchSet newPatchSet = rebase(n, mergeTip);
                    List<PatchSetApproval> approvals = Lists.newArrayList();
                    for (PatchSetApproval a : args.approvalsUtil.byPatchSet(args.db, n.getControl(), n.getPatchsetId())) {
                        approvals.add(new PatchSetApproval(newPatchSet.getId(), a));
                    }
                    // rebaseChange.rebase() may already have copied some approvals,
                    // use upsert, not insert, to avoid constraint violation on database
                    args.db.patchSetApprovals().upsert(approvals);
                    CodeReviewCommit newTip = args.rw.parseCommit(ObjectId.fromString(newPatchSet.getRevision().get()));
                    mergeTip.moveTipTo(newTip, newTip);
                    n.change().setCurrentPatchSet(patchSetInfoFactory.get(args.rw, mergeTip.getCurrentTip(), newPatchSet.getId()));
                    mergeTip.getCurrentTip().copyFrom(n);
                    mergeTip.getCurrentTip().setControl(args.changeControlFactory.controlFor(n.change(), args.caller));
                    mergeTip.getCurrentTip().setPatchsetId(newPatchSet.getId());
                    mergeTip.getCurrentTip().setStatusCode(CommitMergeStatus.CLEAN_REBASE);
                    newCommits.put(newPatchSet.getId().getParentKey(), mergeTip.getCurrentTip());
                    setRefLogIdent();
                } catch (MergeConflictException e) {
                    n.setStatusCode(CommitMergeStatus.REBASE_MERGE_CONFLICT);
                    throw new MergeException("Cannot rebase " + n.name() + ": " + e.getMessage(), e);
                } catch (NoSuchChangeException | OrmException | IOException | RestApiException | UpdateException e) {
                    throw new MergeException("Cannot rebase " + n.name(), e);
                }
            }
        } else if (n.getParentCount() > 1) {
            // 
            try {
                if (args.rw.isMergedInto(mergeTip.getCurrentTip(), n)) {
                    mergeTip.moveTipTo(n, n);
                } else {
                    PersonIdent myIdent = args.serverIdent.get();
                    mergeTip.moveTipTo(args.mergeUtil.mergeOneCommit(myIdent, myIdent, args.repo, args.rw, args.inserter, args.canMergeFlag, args.destBranch, mergeTip.getCurrentTip(), n), n);
                }
                args.mergeUtil.markCleanMerges(args.rw, args.canMergeFlag, mergeTip.getCurrentTip(), args.alreadyAccepted);
                setRefLogIdent();
            } catch (IOException e) {
                throw new MergeException("Cannot merge " + n.name(), e);
            }
        }
        args.alreadyAccepted.add(mergeTip.getCurrentTip());
    }
    return mergeTip;
}
#end_block

#method_before
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    return apply(revision, input, TimeUtil.nowTs());
}
#method_after
@Override
public Output apply(RevisionResource revision, ReviewInput input) throws RestApiException, UpdateException, OrmException {
    return apply(revision, input, TimeUtil.nowTs());
}
#end_block

#method_before
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws AuthException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException, IOException {
    timestamp = ts;
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    db.get().changes().beginTransaction(revision.getChange().getId());
    boolean dirty = false;
    try {
        change = db.get().changes().get(revision.getChange().getId());
        if (change.getLastUpdatedOn().before(timestamp)) {
            change.setLastUpdatedOn(timestamp);
        }
        ChangeUpdate update = updateFactory.create(revision.getControl(), timestamp);
        update.setPatchSetId(revision.getPatchSet().getId());
        dirty |= insertComments(revision, update, input.comments, input.drafts, input.omitDuplicateComments);
        dirty |= updateLabels(revision, update, input.labels);
        dirty |= insertMessage(revision, input.message, update);
        if (dirty) {
            db.get().changes().update(Collections.singleton(change));
            db.get().commit();
        }
        update.commit();
    } finally {
        db.get().rollback();
    }
    if (dirty) {
        indexer.index(db.get(), change);
    }
    if (message != null && input.notify.compareTo(NotifyHandling.NONE) > 0) {
        email.create(input.notify, change, revision.getPatchSet(), revision.getAccountId(), message, comments).sendAsync();
    }
    Output output = new Output();
    output.labels = input.labels;
    if (message != null) {
        fireCommentAddedHook(revision);
    }
    return output;
}
#method_after
public Output apply(RevisionResource revision, ReviewInput input, Timestamp ts) throws RestApiException, UpdateException, OrmException {
    if (revision.getEdit().isPresent()) {
        throw new ResourceConflictException("cannot post review on edit");
    }
    if (input.onBehalfOf != null) {
        revision = onBehalfOf(revision, input);
    }
    if (input.labels != null) {
        checkLabels(revision, input.strictLabels, input.labels);
    }
    if (input.comments != null) {
        checkComments(revision, input.comments);
    }
    if (input.notify == null) {
        log.warn("notify = null; assuming notify = NONE");
        input.notify = NotifyHandling.NONE;
    }
    try (BatchUpdate bu = batchUpdateFactory.create(db.get(), revision.getChange().getProject(), revision.getUser(), ts)) {
        bu.addOp(revision.getChange().getId(), new Op(revision.getPatchSet().getId(), input));
        bu.execute();
    }
    Output output = new Output();
    output.labels = input.labels;
    return output;
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException {
    change = ctx.readChange();
    Change.Id id = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(TimeUtil.nowTs());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getChange().getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    // TODO(dborowitz): Throw ResourceConflictException instead of using
    // AtomicUpdate.
    change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isClosed() && !allowClosed) {
                return null;
            }
            if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                return null;
            }
            if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                change.setStatus(Change.Status.NEW);
            }
            change.setCurrentPatchSet(patchSetInfoFactory.get(commit, psId));
            ChangeUtil.updated(change);
            return change;
        }
    });
    if (change == null) {
        throw new ChangeModifiedException(String.format("Change %s was modified", id));
    }
    approvalCopier.copy(db, ctl, patchSet);
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, ctx.getChangeUpdate(), changeMessage);
    }
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, InvalidChangeOperationException {
    change = ctx.readChange();
    Change.Id id = change.getId();
    final PatchSet.Id currentPatchSetId = change.currentPatchSetId();
    if (!change.getStatus().isOpen() && !allowClosed) {
        throw new InvalidChangeOperationException(String.format("Change %s is closed", change.getId()));
    }
    patchSet = new PatchSet(psId);
    patchSet.setCreatedOn(ctx.getWhen());
    patchSet.setUploader(firstNonNull(uploader, ctl.getChange().getOwner()));
    patchSet.setRevision(new RevId(commit.name()));
    patchSet.setDraft(draft);
    ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
    if (groups != null) {
        patchSet.setGroups(groups);
    } else {
        patchSet.setGroups(GroupCollector.getCurrentGroups(db, change));
    }
    db.patchSets().insert(Collections.singleton(patchSet));
    if (sendMail) {
        oldReviewers = approvalsUtil.getReviewers(db, ctl.getNotes());
    }
    if (message != null) {
        changeMessage = new ChangeMessage(new ChangeMessage.Key(ctl.getChange().getId(), ChangeUtil.messageUUID(db)), user.getAccountId(), ctx.getWhen(), patchSet.getId());
        changeMessage.setMessage(message);
    }
    // TODO(dborowitz): Throw ResourceConflictException instead of using
    // AtomicUpdate.
    change = db.changes().atomicUpdate(id, new AtomicUpdate<Change>() {

        @Override
        public Change update(Change change) {
            if (change.getStatus().isClosed() && !allowClosed) {
                return null;
            }
            if (!change.currentPatchSetId().equals(currentPatchSetId)) {
                return null;
            }
            if (change.getStatus() != Change.Status.DRAFT && !allowClosed) {
                change.setStatus(Change.Status.NEW);
            }
            change.setCurrentPatchSet(patchSetInfoFactory.get(commit, psId));
            ChangeUtil.updated(change);
            return change;
        }
    });
    if (change == null) {
        throw new ChangeModifiedException(String.format("Change %s was modified", id));
    }
    approvalCopier.copy(db, ctl, patchSet);
    if (changeMessage != null) {
        cmUtil.addChangeMessage(db, ctx.getChangeUpdate(), changeMessage);
    }
}
#end_block

#method_before
@Test
public void revokedByKeyNotPresentInStore() throws Exception {
    TestKey k = add(revokedCompromisedKey());
    save();
    assertProblems(k);
}
#method_after
@Test
public void revokedByKeyNotPresentInStore() throws Exception {
    TestKey k = add(revokedCompromisedKey());
    save();
    assertProblems(k, "Key is revoked (key material has been compromised):" + " test6 compromised");
}
#end_block

#method_before
private void checkRevocations(PGPPublicKey key, List<PGPSignature> revocations, Map<Long, RevocationKey> revokers, List<String> problems) throws PGPException, IOException {
    for (PGPSignature revocation : revocations) {
        RevocationKey revoker = revokers.get(revocation.getKeyID());
        if (revoker == null) {
            // Not a designated revoker.
            continue;
        }
        PGPPublicKeyRing revokerKeyRing = store.get(revoker.getFingerprint());
        if (revokerKeyRing == null) {
            // signature.
            continue;
        }
        PGPPublicKey rk = revokerKeyRing.getPublicKey();
        if (rk.getAlgorithm() != revoker.getAlgorithm()) {
            continue;
        }
        if (!checkBasic(rk, revocation.getCreationTime()).isOk()) {
            // revocation is invalid.
            continue;
        }
        revocation.init(new BcPGPContentVerifierBuilderProvider(), rk);
        if (revocation.verifyCertification(key)) {
            problems.add(reasonToString(getRevocationReason(revocation)));
        }
    }
}
#method_after
private void checkRevocations(PGPPublicKey key, List<PGPSignature> revocations, Map<Long, RevocationKey> revokers, List<String> problems) throws PGPException, IOException {
    for (PGPSignature revocation : revocations) {
        RevocationKey revoker = revokers.get(revocation.getKeyID());
        if (revoker == null) {
            // Not a designated revoker.
            continue;
        }
        byte[] rfp = revoker.getFingerprint();
        PGPPublicKeyRing revokerKeyRing = store.get(rfp);
        if (revokerKeyRing == null) {
            // Revoker is authorized and there is a revocation signature by this
            // revoker, but the key is not in the store so we can't verify the
            // signature.
            log.info("Key " + Fingerprint.toString(key.getFingerprint()) + " is revoked by " + Fingerprint.toString(rfp) + ", which is not in the store. Assuming revocation is valid.");
            problems.add(reasonToString(getRevocationReason(revocation)));
            continue;
        }
        PGPPublicKey rk = revokerKeyRing.getPublicKey();
        if (rk.getAlgorithm() != revoker.getAlgorithm()) {
            continue;
        }
        if (!checkBasic(rk, revocation.getCreationTime()).isOk()) {
            // revocation is invalid.
            continue;
        }
        revocation.init(new BcPGPContentVerifierBuilderProvider(), rk);
        if (revocation.verifyCertification(key)) {
            problems.add(reasonToString(getRevocationReason(revocation)));
        }
    }
}
#end_block

#method_before
public final CheckResult check(PGPPublicKey key) {
    if (store == null && trusted != null) {
        throw new IllegalStateException("PublicKeyStore is required");
    } else if (store != null && trusted == null) {
        throw new IllegalStateException("at least one trusted key is required");
    }
    return check(key, 0, true, store != null ? new HashSet<Fingerprint>() : null);
}
#method_after
public final CheckResult check(PGPPublicKey key) {
    if (store == null && trusted != null) {
        throw new IllegalStateException("PublicKeyStore is required");
    }
    return check(key, 0, true, trusted != null ? new HashSet<Fingerprint>() : null);
}
#end_block

#method_before
private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen) {
    if (store == null) {
        // Trust checking not configured, server trusts all OK keys.
        return CheckResult.trusted();
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return CheckResult.ok("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.trusted();
    } else if (depth >= maxTrustDepth) {
        return CheckResult.ok("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            String subpacketProblem = checkTrustSubpacket(sig, depth);
            if (subpacketProblem == null) {
                CheckResult signerResult = check(signer, depth + 1, false, seen);
                if (signerResult.isTrusted()) {
                    return CheckResult.trusted();
                }
            }
            signerResults.add(CheckResult.ok("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        problems.addAll(signerResult.getProblems());
    }
    return CheckResult.create(OK, problems);
}
#method_after
private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen) {
    if (trusted == null) {
        // Trust checking not configured, server trusts all OK keys.
        return CheckResult.trusted();
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return CheckResult.ok("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.trusted();
    } else if (depth >= maxTrustDepth) {
        return CheckResult.ok("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            String subpacketProblem = checkTrustSubpacket(sig, depth);
            if (subpacketProblem == null) {
                CheckResult signerResult = check(signer, depth + 1, false, seen);
                if (signerResult.isTrusted()) {
                    return CheckResult.trusted();
                }
            }
            signerResults.add(CheckResult.ok("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        problems.addAll(signerResult.getProblems());
    }
    return CheckResult.create(OK, problems);
}
#end_block

#method_before
private Project fetchGerritProject(ProjectCache projectCache, String organisation, String repoName) {
    NameKey projectNameKey = Project.NameKey.parse(organisation + "/" + repoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#method_after
private Project fetchGerritProject(ProjectCache projectCache, String fetchOrganisation, String fetchRepoName) {
    NameKey projectNameKey = Project.NameKey.parse(fetchOrganisation + "/" + fetchRepoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#end_block

#method_before
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, pr.getNumber()));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#method_after
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, new Integer(pr.getNumber())));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#end_block

#method_before
private com.google.gerrit.reviewdb.client.Account.Id getOrRegisterAccount(ReviewDb db, String login, String name, String email) throws OrmException, BadRequestException, ResourceConflictException, UnprocessableEntityException, IOException {
    AccountExternalId.Key userExtKey = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, login);
    AccountExternalIdAccess gerritExtIds = db.accountExternalIds();
    AccountExternalId userExtId = gerritExtIds.get(userExtKey);
    if (userExtId == null) {
        return accountImporter.importAccount(login, name, email);
    } else {
        return userExtId.getAccountId();
    }
}
#method_after
private com.google.gerrit.reviewdb.client.Account.Id getOrRegisterAccount(ReviewDb db, String login, String name, String email) throws OrmException, BadRequestException, ResourceConflictException, UnprocessableEntityException, IOException {
    AccountExternalId.Key userExtKey = new AccountExternalId.Key(AccountExternalId.SCHEME_USERNAME, login);
    AccountExternalIdAccess gerritExtIds = db.accountExternalIds();
    AccountExternalId userExtId = gerritExtIds.get(userExtKey);
    if (userExtId == null) {
        return accountImporter.importAccount(login, name, email);
    }
    return userExtId.getAccountId();
}
#end_block

#method_before
public GHRepository getGHRepository() throws IOException {
    if (ghLogin.getMyself().getLogin().equals(organisation)) {
        return ghLogin.getMyself().getRepository(repoName);
    } else {
        return ghLogin.getHub().getOrganization(organisation).getRepository(repoName);
    }
}
#method_after
public GHRepository getGHRepository() throws IOException {
    if (ghLogin.getMyself().getLogin().equals(organisation)) {
        return ghLogin.getMyself().getRepository(repoName);
    }
    return ghLogin.getHub().getOrganization(organisation).getRepository(repoName);
}
#end_block

#method_before
@Override
public void beginTask(String task, int totalUnits) {
    this.currTask++;
    this.task = task;
    this.totUnits = totalUnits;
    this.currUnit = 0;
    this.lastPercentage = 0;
    status.update(Code.SYNC, status.getShortDescription(), getStatusDescription());
}
#method_after
@Override
public void beginTask(String taskName, int totalUnits) {
    this.currTask++;
    this.task = taskName;
    this.totUnits = totalUnits;
    this.currUnit = 0;
    this.lastPercentage = 0;
    status.update(Code.SYNC, status.getShortDescription(), getStatusDescription());
}
#end_block

#method_before
private Map<String, List<Scope>> getScopes(Config config) {
    Map<String, List<Scope>> scopes = Maps.newHashMap();
    Set<String> configKeys = config.getNames(CONF_SECTION, true);
    for (String key : configKeys) {
        if (key.startsWith("scopes")) {
            String scopesString = config.getString(CONF_SECTION, null, key);
            scopes.put(key, parseScopesString(scopesString));
        }
    }
    return scopes;
}
#method_after
private Map<String, List<Scope>> getScopes(Config config) {
    Map<String, List<Scope>> result = Maps.newHashMap();
    Set<String> configKeys = config.getNames(CONF_SECTION, true);
    for (String key : configKeys) {
        if (key.startsWith("scopes")) {
            String scopesString = config.getString(CONF_SECTION, null, key);
            result.put(key, parseScopesString(scopesString));
        }
    }
    return result;
}
#end_block

#method_before
private List<Scope> parseScopesString(String scopesString) {
    ArrayList<Scope> scopes = new ArrayList<>();
    if (Strings.emptyToNull(scopesString) != null) {
        String[] scopesStrings = scopesString.split(",");
        for (String scope : scopesStrings) {
            scopes.add(Enum.valueOf(Scope.class, scope.trim()));
        }
    }
    return scopes;
}
#method_after
private List<Scope> parseScopesString(String scopesString) {
    ArrayList<Scope> result = new ArrayList<>();
    if (Strings.emptyToNull(scopesString) != null) {
        String[] scopesStrings = scopesString.split(",");
        for (String scope : scopesStrings) {
            result.add(Enum.valueOf(Scope.class, scope.trim()));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    String organisation = req.getParameter("organisation");
    JsonArray jsonRepos = new JsonArray();
    int numRepos = 0;
    PagedIterator<GHRepository> repoIter = getRepositories(hubLogin, organisation).iterator();
    while (repoIter.hasNext() && numRepos < config.repositoryListLimit) {
        GHRepository ghRepository = repoIter.next();
        if (ghRepository.hasPushAccess() && ghRepository.hasPullAccess()) {
            JsonObject repository = new JsonObject();
            String projectName = organisation + "/" + ghRepository.getName();
            if (projects.get(Project.NameKey.parse(projectName)) == null) {
                repository.add("name", new JsonPrimitive(ghRepository.getName()));
                repository.add("organisation", new JsonPrimitive(organisation));
                repository.add("description", new JsonPrimitive(Strings.nullToEmpty(ghRepository.getDescription())));
                repository.add("private", new JsonPrimitive(ghRepository.isPrivate()));
                jsonRepos.add(repository);
                numRepos++;
            }
        } else {
            log.warn("Skipping repository {} because user {} has no push/pull access to it", ghRepository.getName(), user.getUserName());
        }
    }
    resp.getWriter().println(jsonRepos.toString());
}
#method_after
@Override
public void doAction(IdentifiedUser user, GitHubLogin hubLogin, HttpServletRequest req, HttpServletResponse resp, ControllerErrors errors) throws ServletException, IOException {
    String organisation = req.getParameter("organisation");
    JsonArray jsonRepos = new JsonArray();
    int numRepos = 0;
    PagedIterator<GHRepository> repoIter = getRepositories(hubLogin, organisation).iterator();
    while (repoIter.hasNext() && numRepos < config.repositoryListLimit) {
        GHRepository ghRepository = repoIter.next();
        if (ghRepository.hasPushAccess() && ghRepository.hasPullAccess()) {
            JsonObject repository = new JsonObject();
            String projectName = organisation + "/" + ghRepository.getName();
            if (projects.get(Project.NameKey.parse(projectName)) == null) {
                repository.add("name", new JsonPrimitive(ghRepository.getName()));
                repository.add("organisation", new JsonPrimitive(organisation));
                repository.add("description", new JsonPrimitive(Strings.nullToEmpty(ghRepository.getDescription())));
                repository.add("private", new JsonPrimitive(new Boolean(ghRepository.isPrivate())));
                jsonRepos.add(repository);
                numRepos++;
            }
        } else {
            log.warn("Skipping repository {} because user {} has no push/pull access to it", ghRepository.getName(), user.getUserName());
        }
    }
    resp.getWriter().println(jsonRepos.toString());
}
#end_block

#method_before
public Account.Id importAccount(String login, String name, String email) throws IOException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException {
    try (ReviewDb db = schema.get()) {
        CreateAccount createAccount = createAccountFactory.create(login);
        CreateAccount.Input accountInput = new CreateAccount.Input();
        accountInput.email = email;
        accountInput.username = login;
        accountInput.name = MoreObjects.firstNonNull(name, login);
        Response<AccountInfo> accountResponse = createAccount.apply(TopLevelResource.INSTANCE, accountInput);
        if (accountResponse.statusCode() == HttpStatus.SC_CREATED) {
            Id accountId = new Account.Id(accountResponse.value()._accountId);
            db.accountExternalIds().insert(Arrays.asList(new AccountExternalId(accountId, new AccountExternalId.Key(AccountExternalId.SCHEME_GERRIT, login))));
            return accountId;
        }
        throw new IOException("Cannot import GitHub account " + login + ": HTTP Status " + accountResponse.statusCode());
    }
}
#method_after
public Account.Id importAccount(String login, String name, String email) throws IOException, BadRequestException, ResourceConflictException, UnprocessableEntityException, OrmException {
    try (ReviewDb db = schema.get()) {
        CreateAccount createAccount = createAccountFactory.create(login);
        CreateAccount.Input accountInput = new CreateAccount.Input();
        accountInput.email = email;
        accountInput.username = login;
        accountInput.name = MoreObjects.firstNonNull(name, login);
        Response<AccountInfo> accountResponse = createAccount.apply(TopLevelResource.INSTANCE, accountInput);
        if (accountResponse.statusCode() != HttpStatus.SC_CREATED) {
            throw new IOException("Cannot import GitHub account " + login + ": HTTP Status " + accountResponse.statusCode());
        }
        Id accountId = new Account.Id(accountResponse.value()._accountId.intValue());
        db.accountExternalIds().insert(Arrays.asList(new AccountExternalId(accountId, new AccountExternalId.Key(AccountExternalId.SCHEME_GERRIT, login))));
        return accountId;
    }
}
#end_block

#method_before
private Project fetchGerritProject(ProjectCache projectCache, String organisation, String repoName) {
    NameKey projectNameKey = Project.NameKey.parse(organisation + "/" + repoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#method_after
private Project fetchGerritProject(ProjectCache projectCache, String fetchOrganisation, String fetchRepoName) {
    NameKey projectNameKey = Project.NameKey.parse(fetchOrganisation + "/" + fetchRepoName);
    ProjectState projectState = projectCache.get(projectNameKey);
    return projectState.getProject();
}
#end_block

#method_before
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, pr.getNumber()));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#method_after
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, new Integer(pr.getNumber())));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#end_block

#method_before
@Override
public boolean doAction(PullRequest payload) throws IOException {
    String action = payload.getAction();
    if (action.equals("opened") || action.equals("synchronize")) {
        GHRepository repository = payload.getRepository();
        int prNumber = payload.getNumber();
        PullRequestImporter prImporter = prImportProvider.get();
        String organization = repository.getOwnerName();
        String name = repository.getName();
        logger.info("Importing {}/{}#{}", organization, name, prNumber);
        prImporter.importPullRequest(0, organization, name, prNumber, PullRequestImportType.Commits);
        logger.info("Imported {}/{}#{}", organization, name, prNumber);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean doAction(PullRequest payload) throws IOException {
    String action = payload.getAction();
    if (action.equals("opened") || action.equals("synchronize")) {
        GHRepository repository = payload.getRepository();
        Integer prNumber = new Integer(payload.getNumber());
        PullRequestImporter prImporter = prImportProvider.get();
        String organization = repository.getOwnerName();
        String name = repository.getName();
        logger.info("Importing {}/{}#{}", organization, name, prNumber);
        prImporter.importPullRequest(0, organization, name, prNumber.intValue(), PullRequestImportType.Commits);
        logger.info("Imported {}/{}#{}", organization, name, prNumber);
        return true;
    }
    return false;
}
#end_block

#method_before
public CredentialsProvider getCredentialsProvider() {
    return new CredentialsProvider() {

        @Override
        public boolean supports(CredentialItem... items) {
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    continue;
                } else if (i instanceof CredentialItem.Password) {
                    continue;
                } else {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isInteractive() {
            return false;
        }

        @Override
        public boolean get(URIish uri, CredentialItem... items) throws UnsupportedCredentialItem {
            String _username = uri.getUser();
            if (_username == null) {
                _username = GitHubRepository.this.username;
            }
            if (_username == null) {
                return false;
            }
            String _password = GitHubRepository.this.password;
            if (password == null) {
                return false;
            }
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    ((CredentialItem.Username) i).setValue(_username);
                } else if (i instanceof CredentialItem.Password) {
                    ((CredentialItem.Password) i).setValue(_password.toCharArray());
                } else {
                    throw new UnsupportedCredentialItem(uri, i.getPromptText());
                }
            }
            return true;
        }
    };
}
#method_after
public CredentialsProvider getCredentialsProvider() {
    return new CredentialsProvider() {

        @Override
        public boolean supports(CredentialItem... items) {
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    continue;
                } else if (i instanceof CredentialItem.Password) {
                    continue;
                } else {
                    return false;
                }
            }
            return true;
        }

        @Override
        public boolean isInteractive() {
            return false;
        }

        @Override
        public boolean get(URIish uri, CredentialItem... items) throws UnsupportedCredentialItem {
            String user = uri.getUser();
            if (user == null) {
                user = GitHubRepository.this.username;
            }
            if (user == null) {
                return false;
            }
            String passwd = GitHubRepository.this.password;
            if (passwd == null) {
                return false;
            }
            for (CredentialItem i : items) {
                if (i instanceof CredentialItem.Username) {
                    ((CredentialItem.Username) i).setValue(user);
                } else if (i instanceof CredentialItem.Password) {
                    ((CredentialItem.Password) i).setValue(passwd.toCharArray());
                } else {
                    throw new UnsupportedCredentialItem(uri, i.getPromptText());
                }
            }
            return true;
        }
    };
}
#end_block

#method_before
private List<Destination> getDestinations(Path cfgPath) throws ConfigInvalidException, IOException {
    if (!Files.exists(cfgPath) || Files.size(cfgPath) == 0) {
        return Collections.emptyList();
    }
    FileBasedConfig cfg = new FileBasedConfig(cfgPath.toFile(), FS.DETECTED);
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, database, replicationUserFactory, pluginUser, gitRepositoryManager, groupBackend));
    }
    return dest.build();
}
#method_after
private List<Destination> getDestinations(Path cfgPath) throws ConfigInvalidException, IOException {
    if (!Files.exists(cfgPath) || Files.size(cfgPath) == 0) {
        return Collections.emptyList();
    }
    FileBasedConfig cfg = new FileBasedConfig(cfgPath.toFile(), FS.DETECTED);
    try {
        cfg.load();
    } catch (ConfigInvalidException e) {
        throw new ConfigInvalidException(String.format("Config file %s is invalid: %s", cfg.getFile(), e.getMessage()), e);
    } catch (IOException e) {
        throw new IOException(String.format("Cannot read %s: %s", cfg.getFile(), e.getMessage()), e);
    }
    ImmutableList.Builder<Destination> dest = ImmutableList.builder();
    for (RemoteConfig c : allRemotes(cfg)) {
        if (c.getURIs().isEmpty()) {
            continue;
        }
        for (URIish u : c.getURIs()) {
            if (u.getPath() == null || !u.getPath().contains("${name}")) {
                throw new ConfigInvalidException(String.format("remote.%s.url \"%s\" lacks ${name} placeholder in %s", c.getName(), u, cfg.getFile()));
            }
        }
        // If destination for push is not set assume equal to source.
        for (RefSpec ref : c.getPushRefSpecs()) {
            if (ref.getDestination() == null) {
                ref.setDestination(ref.getSource());
            }
        }
        if (c.getPushRefSpecs().isEmpty()) {
            c.addPushRefSpec(new RefSpec().setSourceDestination("refs/*", "refs/*").setForceUpdate(true));
        }
        dest.add(new Destination(injector, c, cfg, replicationUserFactory, pluginUser, groupBackend));
    }
    return dest.build();
}
#end_block

#method_before
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, pr.getNumber()));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#method_after
private List<Id> addPullRequestToChange(ReviewDb db, GHPullRequest pr, Repository gitRepo) throws Exception {
    String destinationBranch = REFS_HEADS + pr.getBase().getRef();
    List<Id> prChanges = Lists.newArrayList();
    ObjectId baseObjectId = ObjectId.fromString(pr.getBase().getSha());
    ObjectId prHeadObjectId = ObjectId.fromString(pr.getHead().getSha());
    try (RevWalk walk = new RevWalk(gitRepo)) {
        walk.markUninteresting(walk.lookupCommit(baseObjectId));
        walk.markStart(walk.lookupCommit(prHeadObjectId));
        walk.sort(RevSort.REVERSE);
        int patchNr = 1;
        for (GHPullRequestCommitDetail ghCommitDetail : pr.listCommits()) {
            status.update(Code.SYNC, "Patch #" + patchNr, "Patch#" + patchNr + ": Inserting PullRequest into Gerrit");
            RevCommit revCommit = walk.parseCommit(ObjectId.fromString(ghCommitDetail.getSha()));
            GHUser prUser = pr.getUser();
            GitUser commitAuthor = ghCommitDetail.getCommit().getAuthor();
            GitHubUser gitHubUser = GitHubUser.from(prUser, commitAuthor);
            Account.Id pullRequestOwner = getOrRegisterAccount(db, gitHubUser);
            Id changeId = createChange.addCommitToChange(db, project, gitRepo, destinationBranch, pullRequestOwner, revCommit, getChangeMessage(pr), String.format(TOPIC_FORMAT, new Integer(pr.getNumber())));
            if (changeId != null) {
                prChanges.add(changeId);
            }
        }
        return prChanges;
    }
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    log.debug("OAuthWebFilter(" + httpRequest.getRequestURL() + ") code=" + request.getParameter("code"));
    Cookie gerritCookie = getGerritCookie(httpRequest);
    try {
        GitHubLogin ghLogin = loginProvider.get(httpRequest);
        if (OAuthProtocol.isOAuthRequest(httpRequest)) {
            login(request, httpRequest, httpResponse, ghLogin);
        } else {
            if (OAuthProtocol.isOAuthLogout(httpRequest)) {
                response = logout(request, response, chain, httpRequest);
            }
            if (ghLogin != null && ghLogin.isLoggedIn()) {
                httpRequest = new AuthenticatedHttpRequest(httpRequest, config.httpHeader, ghLogin.getMyself().getLogin(), config.oauthHttpHeader, GITHUB_EXT_ID + ghLogin.getToken().accessToken);
            }
            chain.doFilter(httpRequest, response);
        }
    } finally {
        HttpSession httpSession = httpRequest.getSession();
        if (gerritCookie != null && httpSession != null) {
            String gerritCookieValue = gerritCookie.getValue();
            String gerritSessionValue = (String) httpSession.getAttribute("GerritAccount");
            if (gerritSessionValue == null) {
                httpSession.setAttribute("GerritAccount", gerritCookieValue);
            } else if (!gerritSessionValue.equals(gerritCookieValue)) {
                httpSession.invalidate();
            }
        }
    }
}
#method_after
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpRequest = (HttpServletRequest) request;
    HttpServletResponse httpResponse = (HttpServletResponse) response;
    log.debug("OAuthWebFilter(" + httpRequest.getRequestURL() + ") code=" + request.getParameter("code"));
    Cookie gerritCookie = getGerritCookie(httpRequest);
    try {
        GitHubLogin ghLogin = loginProvider.get(httpRequest);
        if (OAuthProtocol.isOAuthRequest(httpRequest)) {
            login(request, httpRequest, httpResponse, ghLogin);
        } else {
            if (OAuthProtocol.isOAuthLogout(httpRequest)) {
                httpResponse = (HttpServletResponse) logout(request, httpResponse, chain, httpRequest);
            }
            if (ghLogin != null && ghLogin.isLoggedIn()) {
                httpRequest = new AuthenticatedHttpRequest(httpRequest, config.httpHeader, ghLogin.getMyself().getLogin(), config.oauthHttpHeader, GITHUB_EXT_ID + ghLogin.getToken().accessToken);
            }
            chain.doFilter(httpRequest, httpResponse);
        }
    } finally {
        HttpSession httpSession = httpRequest.getSession();
        if (gerritCookie != null && httpSession != null) {
            String gerritCookieValue = gerritCookie.getValue();
            String gerritSessionValue = (String) httpSession.getAttribute("GerritAccount");
            if (gerritSessionValue == null) {
                httpSession.setAttribute("GerritAccount", gerritCookieValue);
            } else if (!gerritSessionValue.equals(gerritCookieValue)) {
                httpSession.invalidate();
            }
        }
    }
}
#end_block

#method_before
private ServletResponse logout(ServletRequest request, ServletResponse response, FilterChain chain, HttpServletRequest httpRequest) throws IOException, ServletException {
    getGitHubLogin(request).logout();
    return new GitHubLogoutServletResponse((HttpServletResponse) response, config.logoutRedirectUrl);
}
#method_after
private ServletResponse logout(ServletRequest request, ServletResponse response, FilterChain chain, HttpServletRequest httpRequest) {
    getGitHubLogin(request).logout();
    return new GitHubLogoutServletResponse((HttpServletResponse) response, config.logoutRedirectUrl);
}
#end_block

#method_before
@Override
public Multimap<String, String> load(String username) throws Exception {
    Multimap<String, String> orgsTeams = HashMultimap.create();
    GitHubLogin ghLogin = ghLoginProvider.get(username);
    if (ghLogin == null) {
        log.warn("Cannot login to GitHub on behalf of '{}'", username);
        return orgsTeams;
    }
    try {
        loadOrganisationsAndTeams(username, orgsTeams, ghLogin);
    } catch (FileNotFoundException teamsNotFound) {
        log.info("Cannot access teams for user '{}': falling back to list of public organisations", username);
        loadOrganisations(username, orgsTeams, ghLogin);
    }
    log.debug("GitHub user '{}' belongs to: {}", username, orgsTeams);
    return orgsTeams;
}
#method_after
@Override
public Multimap<String, String> load(String username) throws Exception {
    Multimap<String, String> orgsTeams = HashMultimap.create();
    GitHubLogin ghLogin = ghLoginProvider.get(username);
    if (ghLogin == null) {
        logger.warn("Cannot login to GitHub on behalf of '{}'", username);
        return orgsTeams;
    }
    try {
        loadOrganisationsAndTeams(username, orgsTeams, ghLogin);
    } catch (FileNotFoundException teamsNotFound) {
        logger.info("Cannot access teams for user '{}': falling back to list of public organisations", username);
        loadOrganisations(username, orgsTeams, ghLogin);
    }
    logger.debug("GitHub user '{}' belongs to: {}", username, orgsTeams);
    return orgsTeams;
}
#end_block

#method_before
private void loadOrganisationsAndTeams(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    log.debug("Getting list of organisations/teams for user '{}'", username);
    Map<String, Set<GHTeam>> myOrganisationsLogins = ghLogin.getHub().getMyTeams();
    for (Entry<String, Set<GHTeam>> teamsOrg : myOrganisationsLogins.entrySet()) {
        orgsTeams.put(teamsOrg.getKey(), EVERYONE_TEAM_NAME);
        for (GHTeam team : teamsOrg.getValue()) {
            orgsTeams.put(teamsOrg.getKey(), team.getName());
        }
    }
}
#method_after
private void loadOrganisationsAndTeams(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    logger.debug("Getting list of organisations/teams for user '{}'", username);
    Map<String, Set<GHTeam>> myOrganisationsLogins = ghLogin.getHub().getMyTeams();
    for (Entry<String, Set<GHTeam>> teamsOrg : myOrganisationsLogins.entrySet()) {
        orgsTeams.put(teamsOrg.getKey(), EVERYONE_TEAM_NAME);
        for (GHTeam team : teamsOrg.getValue()) {
            orgsTeams.put(teamsOrg.getKey(), team.getName());
        }
    }
}
#end_block

#method_before
private void loadOrganisations(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    log.debug("Getting list of public organisations for user '{}'", username);
    Set<String> organisations = ghLogin.getMyOrganisationsLogins();
    for (String org : organisations) {
        orgsTeams.put(org, EVERYONE_TEAM_NAME);
    }
}
#method_after
private void loadOrganisations(String username, Multimap<String, String> orgsTeams, GitHubLogin ghLogin) throws IOException {
    logger.debug("Getting list of public organisations for user '{}'", username);
    Set<String> organisations = ghLogin.getMyOrganisationsLogins();
    for (String org : organisations) {
        orgsTeams.put(org, EVERYONE_TEAM_NAME);
    }
}
#end_block

#method_before
private Runnable save() {
    return new Runnable() {

        @Override
        public void run() {
            if (!cm.isClean(generation)) {
                close.setEnabled(false);
                String text = cm.getValue();
                if (Patch.COMMIT_MSG.equals(path)) {
                    String newText = text.trim();
                    if (!newText.equals(text)) {
                        text = newText;
                        cm.setValue(text);
                    }
                }
                final int g = cm.changeGeneration(false);
                ChangeEditApi.put(revision.getParentKey().get(), path, text, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                        generation = g;
                        setClean(cm.isClean(g));
                    }

                    @Override
                    public void onFailure(final Throwable caught) {
                        close.setEnabled(true);
                    }
                });
            }
        }
    };
}
#method_after
private Runnable save() {
    return new Runnable() {

        @Override
        public void run() {
            if (!cm.isClean(generation)) {
                close.setEnabled(false);
                String text = cm.getValue();
                if (Patch.COMMIT_MSG.equals(path)) {
                    String trimmed = text.trim() + "\r";
                    if (!trimmed.equals(text)) {
                        text = trimmed;
                        cm.setValue(text);
                    }
                }
                final int g = cm.changeGeneration(false);
                ChangeEditApi.put(revision.getParentKey().get(), path, text, new GerritCallback<VoidResult>() {

                    @Override
                    public void onSuccess(VoidResult result) {
                        generation = g;
                        setClean(cm.isClean(g));
                    }

                    @Override
                    public void onFailure(final Throwable caught) {
                        close.setEnabled(true);
                    }
                });
            }
        }
    };
}
#end_block

#method_before
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#method_after
@Override
public ChangeApi revert(RevertInput in) throws RestApiException {
    try {
        return changeApi.id(revert.apply(change, in)._number);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot revert change", e);
    }
}
#end_block

#method_before
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (OrmException | IOException | UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#method_after
@Override
public void topic(String topic) throws RestApiException {
    PutTopic.Input in = new PutTopic.Input();
    in.topic = topic;
    try {
        putTopic.apply(change, in);
    } catch (UpdateException e) {
        throw new RestApiException("Cannot set topic", e);
    }
}
#end_block

#method_before
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | EmailException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#method_after
@Override
public void addReviewer(AddReviewerInput in) throws RestApiException {
    try {
        postReviewers.apply(change, in);
    } catch (OrmException | IOException e) {
        throw new RestApiException("Cannot add change reviewer", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        CurrentUser u = user.get();
        if (u.isIdentifiedUser()) {
            ((IdentifiedUser) u).clearStarredChanges();
        }
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#method_after
@Override
public ChangeInfo get(EnumSet<ListChangesOption> s) throws RestApiException {
    try {
        CurrentUser u = user.get();
        if (u.isIdentifiedUser()) {
            u.asIdentifiedUser().clearStarredChanges();
        }
        return changeJson.create(s).format(change);
    } catch (OrmException e) {
        throw new RestApiException("Cannot retrieve change", e);
    }
}
#end_block

#method_before
@Override
public EditInfo getEdit() throws RestApiException {
    try {
        Response<EditInfo> edit = editDetail.apply(change);
        return edit.isNone() ? null : edit.value();
    } catch (IOException | OrmException | InvalidChangeOperationException e) {
        throw new RestApiException("Cannot retrieve change edit", e);
    }
}
#method_after
@Override
public EditInfo getEdit() throws RestApiException {
    try {
        Response<EditInfo> edit = editDetail.apply(change);
        return edit.isNone() ? null : edit.value();
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot retrieve change edit", e);
    }
}
#end_block

#method_before
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (IOException | OrmException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#method_after
@Override
public void setHashtags(HashtagsInput input) throws RestApiException {
    try {
        postHashtags.apply(change, input);
    } catch (RestApiException | UpdateException e) {
        throw new RestApiException("Cannot post hashtags", e);
    }
}
#end_block

#method_before
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore()) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), TimeUtil.nowTs())) {
        u.addOp(ctl, op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#method_after
@Override
public ChangeInfo apply(ChangeResource req, RestoreInput input) throws RestApiException, UpdateException, OrmException {
    ChangeControl ctl = req.getControl();
    if (!ctl.canRestore()) {
        throw new AuthException("restore not permitted");
    }
    Op op = new Op(input);
    try (BatchUpdate u = batchUpdateFactory.create(dbProvider.get(), req.getChange().getProject(), ctl.getUser(), TimeUtil.nowTs())) {
        u.addOp(req.getChange().getId(), op).execute();
    }
    return json.create(ChangeJson.NO_OPTIONS).format(op.change);
}
#end_block

#method_before
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = (IdentifiedUser) ctx.getUser();
    change = ctx.readChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#method_after
@Override
public void updateChange(ChangeContext ctx) throws OrmException, ResourceConflictException {
    caller = ctx.getUser().asIdentifiedUser();
    change = ctx.getChange();
    if (change == null || change.getStatus() != Status.ABANDONED) {
        throw new ResourceConflictException("change is " + status(change));
    }
    patchSet = ctx.getDb().patchSets().get(change.currentPatchSetId());
    change.setStatus(Status.NEW);
    change.setLastUpdatedOn(ctx.getWhen());
    ctx.getDb().changes().update(Collections.singleton(change));
    message = newMessage(ctx.getDb());
    cmUtil.addChangeMessage(ctx.getDb(), ctx.getChangeUpdate(), message);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    db = DriverManager.getConnection("jdbc:derby:memory:DialectDerbyTest;create=true");
    executor = new JdbcExecutor(db);
    dialect = new DialectDerby().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.apache.derby.jdbc.EmbeddedDriver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#method_after
@Before
public void setUp() throws Exception {
    db = DriverManager.getConnection(CONNECT + ";create=true");
    executor = new JdbcExecutor(db);
    dialect = new DialectDerby().refine(db);
    final Properties p = new Properties();
    p.setProperty("driver", org.apache.derby.jdbc.EmbeddedDriver.class.getName());
    p.setProperty("url", db.getMetaData().getURL());
    phoneBook = new Database<>(new SimpleDataSource(p), PhoneBookDb.class);
    phoneBook2 = new Database<>(new SimpleDataSource(p), PhoneBookDb2.class);
}
#end_block

#method_before
@After
public void tearDown() {
    try {
        DriverManager.getConnection("jdbc:derby:memory:DialectDerbyTest;drop=true");
    } catch (SQLException e) {
    }
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#method_after
@After
public void tearDown() {
    try {
        DriverManager.getConnection(CONNECT + ";drop=true");
    } catch (SQLException e) {
    /* as stated in the derby reference manual,
       * section "Setting attributes for the database connection URL"
       * https://db.apache.org/derby/docs/10.11/ref/rrefattribdrop.html
       * "The attribute generates the SQLException 08006 if successful.
       *  If the database does not exist, it generates an error
       *  reporting that the database could not be found."
       *  So we can safely ignore this SQLException here.
       */
    }
    if (executor != null) {
        executor.close();
    }
    executor = null;
    if (db != null) {
        try {
            db.close();
        } catch (SQLException e) {
            throw new RuntimeException("Cannot close database", e);
        }
    }
    db = null;
}
#end_block

#method_before
@Test
public void testUpgradeSchema() throws SQLException, OrmException {
    final PhoneBookDb p = phoneBook.open();
    try {
        p.updateSchema(executor);
        execute("CREATE SEQUENCE cnt");
        execute("CREATE TABLE foo (cnt INT)");
        execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)");
        execute("ALTER TABLE people DROP COLUMN registered");
        Set<String> sequences, tables;
        p.updateSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertTrue(sequences.contains("cnt"));
        assertTrue(tables.contains("foo"));
        assertTrue(sequences.contains("address_id"));
        assertTrue(tables.contains("addresses"));
        p.pruneSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertFalse(sequences.contains("cnt"));
        assertFalse(tables.contains("foo"));
        final Person.Key pk = new Person.Key("Bob");
        final Person bob = new Person(pk, p.nextAddressId());
        p.people().insert(Collections.singleton(bob));
        final Address addr = new Address(new Address.Key(pk, "home"), "some place");
        p.addresses().insert(Collections.singleton(addr));
    } finally {
        p.close();
    }
// constraint violation for rename column :-(
// final PhoneBookDb2 p2 = phoneBook2.open();
// try {
// ((JdbcSchema) p2).renameField(executor, "people", "registered",
// "isRegistered");
// } finally {
// p2.close();
// }
}
#method_after
@Test
public void testUpgradeSchema() throws SQLException, OrmException {
    final PhoneBookDb p = phoneBook.open();
    try {
        p.updateSchema(executor);
        execute("CREATE SEQUENCE cnt");
        execute("CREATE TABLE foo (cnt INT)");
        execute("ALTER TABLE people ADD COLUMN fake_name VARCHAR(20)");
        execute("ALTER TABLE people DROP COLUMN registered");
        Set<String> sequences, tables;
        p.updateSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertTrue(sequences.contains("cnt"));
        assertTrue(tables.contains("foo"));
        assertTrue(sequences.contains("address_id"));
        assertTrue(tables.contains("addresses"));
        p.pruneSchema(executor);
        sequences = dialect.listSequences(db);
        tables = dialect.listTables(db);
        assertFalse(sequences.contains("cnt"));
        assertFalse(tables.contains("foo"));
        final Person.Key pk = new Person.Key("Bob");
        final Person bob = new Person(pk, p.nextAddressId());
        p.people().insert(Collections.singleton(bob));
        final Address addr = new Address(new Address.Key(pk, "home"), "some place");
        p.addresses().insert(Collections.singleton(addr));
    } finally {
        p.close();
    }
    /* rename a column in an existing table to match the new schema */
    final PhoneBookDb2 p2 = phoneBook2.open();
    /* As Apache Derby doesn't support renaming a column as long as a constraint
     * exists on the column, we need to drop the constraint manually.
     * Currently a CHECK constraint is created by gwtorm for all fields with
     * type SqlBooleanTypeInfo.
     * See also https://db.apache.org/derby/docs/10.11/ref/rrefsqljrenamecolumnstatement.html
     * for more information about the restriction of the RENAME COLUMN command.
     */
    String sqlCatalog = "select c.constraintname, ch.checkdefinition" + " from sys.sysconstraints c, sys.systables t, sys.syschecks ch" + " WHERE c.tableid = t.tableid" + "   and t.tablename = ?" + "   and c.constraintid = ch.constraintid";
    PreparedStatement ps = db.prepareStatement(sqlCatalog);
    String tableName = "PEOPLE";
    ps.setString(1, tableName);
    try {
        ResultSet rs = ps.executeQuery();
        List<String> constraintNames = new ArrayList<>();
        List<String> checkDefs = new ArrayList<>();
        while (rs.next()) {
            if (rs.getString(2).contains("registered")) {
                constraintNames.add(rs.getString(1));
                checkDefs.add(rs.getString(2).replace("registered", "is_registered"));
                break;
            }
        }
        rs.close();
        ps.close();
        if (constraintNames.isEmpty()) {
            fail("Constraint not found");
        }
        for (String c : constraintNames) {
            execute("alter table " + tableName + " drop check " + c);
        }
        ((JdbcSchema) p2).renameField(executor, "people", "registered", "isRegistered");
        for (String cd : checkDefs) {
            execute("alter table " + tableName + " add check " + cd);
        }
    } catch (OrmException e) {
        fail(e.getMessage());
    } finally {
        p2.close();
    }
}
#end_block

#method_before
public String getCreateSequenceSql(final SequenceModel seq) {
    final Sequence s = seq.getSequence();
    final StringBuilder r = new StringBuilder();
    r.append("CREATE SEQUENCE ");
    r.append(seq.getSequenceName());
    if (s.startWith() > 0) {
        r.append(" START WITH ");
        r.append(s.startWith());
    }
    if (s.cache() > 0) {
        r.append(" CACHE ");
        r.append(s.cache());
    }
    return r.toString();
}
#method_after
public String getCreateSequenceSql(final SequenceModel seq) {
    final Sequence s = seq.getSequence();
    final StringBuilder r = new StringBuilder();
    r.append("CREATE SEQUENCE ");
    r.append(seq.getSequenceName());
    /*
     * Some gwtorm users seems to imply a start of 1, enforce this constraint
     * here explicitly
     */
    r.append(" START WITH ");
    r.append(s.startWith() > 0 ? s.startWith() : 1);
    if (s.cache() > 0) {
        r.append(" CACHE ");
        r.append(s.cache());
    }
    return r.toString();
}
#end_block

#method_before
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setUploader(user.get().getAccountId()).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#method_after
private PatchSet.Id insertPatchSet(RevCommit commit) {
    ProblemInfo p = problem("No patch set found for merged commit " + commit.name());
    if (!user.get().isIdentifiedUser()) {
        p.status = Status.FIX_FAILED;
        p.outcome = "Must be called by an identified user to insert new patch set";
        return null;
    }
    try {
        RefControl ctl = projectControlFactory.controlFor(change.getProject(), user.get()).controlForRef(change.getDest());
        PatchSet.Id psId = ChangeUtil.nextPatchSetId(repo, change.currentPatchSetId());
        PatchSetInserter inserter = patchSetInserterFactory.create(ctl, psId, commit);
        try (BatchUpdate bu = updateFactory.create(db.get(), change.getProject(), ctl.getUser(), TimeUtil.nowTs());
            ObjectInserter oi = repo.newObjectInserter()) {
            bu.setRepository(repo, rw, oi);
            bu.addOp(change.getId(), inserter.setValidatePolicy(CommitValidators.Policy.NONE).setRunHooks(false).setSendMail(false).setAllowClosed(true).setUploader(user.get().getAccountId()).setMessage("Patch set for merged commit inserted by consistency checker"));
            bu.execute();
        }
        change = inserter.getChange();
        p.status = Status.FIXED;
        p.outcome = "Inserted as patch set " + psId.get();
        return psId;
    } catch (IOException | NoSuchProjectException | UpdateException | RestApiException e) {
        warn(e);
        p.status = Status.FIX_FAILED;
        p.outcome = "Error inserting new patch set";
        return null;
    }
}
#end_block

#method_before
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init           Initialize a Gerrit installation");
        System.err.println("  reindex        Rebuild the secondary index");
        System.err.println("  RebuildNotedb  Rebuild Notedb");
        System.err.println("  daemon         Run the Gerrit network daemons");
        System.err.println("  gsql           Run the interactive query console");
        System.err.println("  version        Display the build version number");
        System.err.println();
        System.err.println("  ls             List files available for cat");
        System.err.println("  cat FILE       Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#method_after
public static int mainImpl(final String[] argv) throws Exception {
    if (argv.length == 0) {
        File me;
        try {
            me = getDistributionArchive();
        } catch (FileNotFoundException e) {
            me = null;
        }
        String jar = me != null ? me.getName() : "gerrit.war";
        System.err.println("Gerrit Code Review " + getVersion(me));
        System.err.println("usage: java -jar " + jar + " command [ARG ...]");
        System.err.println();
        System.err.println("The most commonly used commands are:");
        System.err.println("  init            Initialize a Gerrit installation");
        System.err.println("  rebuild-notedb  Rebuild the review notes database");
        System.err.println("  reindex         Rebuild the secondary index");
        System.err.println("  daemon          Run the Gerrit network daemons");
        System.err.println("  gsql            Run the interactive query console");
        System.err.println("  version         Display the build version number");
        System.err.println();
        System.err.println("  ls              List files available for cat");
        System.err.println("  cat FILE        Display a file from the archive");
        System.err.println();
        return 1;
    }
    // 
    if ("-v".equals(argv[0]) || "--version".equals(argv[0])) {
        argv[0] = "version";
    } else if ("-p".equals(argv[0]) || "--cat".equals(argv[0])) {
        argv[0] = "cat";
    } else if ("-l".equals(argv[0]) || "--ls".equals(argv[0])) {
        argv[0] = "ls";
    }
    // Run the application class
    // 
    final ClassLoader cl = libClassLoader(isProlog(programClassName(argv[0])));
    Thread.currentThread().setContextClassLoader(cl);
    return invokeProgram(cl, argv);
}
#end_block

#method_before
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                PatchListEntry e = newEntry(aTree, fh);
                if (com.google.gerrit.reviewdb.client.Patch.PatchType.BINARY.equals(e.getPatchType())) {
                    e.setSizeDelta(getFileSize(repo, reader, diffEntry.getNewPath(), bTree) - getFileSize(repo, reader, diffEntry.getOldPath(), aTree));
                }
                entries.add(e);
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#method_after
private PatchList readPatchList(final PatchListKey key, final Repository repo) throws IOException, PatchListNotAvailableException {
    final RawTextComparator cmp = comparatorFor(key.getWhitespace());
    try (ObjectReader reader = repo.newObjectReader();
        RevWalk rw = new RevWalk(reader);
        DiffFormatter df = new DiffFormatter(DisabledOutputStream.INSTANCE)) {
        final RevCommit b = rw.parseCommit(key.getNewId());
        final RevObject a = aFor(key, repo, rw, b);
        if (a == null) {
            // TODO(sop) Remove this case.
            // This is a merge commit, compared to its ancestor.
            // 
            final PatchListEntry[] entries = new PatchListEntry[1];
            entries[0] = newCommitMessage(cmp, reader, null, b);
            return new PatchList(a, b, true, entries);
        }
        final boolean againstParent = b.getParentCount() > 0 && b.getParent(0) == a;
        RevCommit aCommit = a instanceof RevCommit ? (RevCommit) a : null;
        RevTree aTree = rw.parseTree(a);
        RevTree bTree = b.getTree();
        df.setRepository(repo);
        df.setDiffComparator(cmp);
        df.setDetectRenames(true);
        List<DiffEntry> diffEntries = df.scan(aTree, bTree);
        Set<String> paths = null;
        if (key.getOldId() != null) {
            PatchListKey newKey = new PatchListKey(null, key.getNewId(), key.getWhitespace());
            PatchListKey oldKey = new PatchListKey(null, key.getOldId(), key.getWhitespace());
            paths = FluentIterable.from(patchListCache.get(newKey, project).getPatches()).append(patchListCache.get(oldKey, project).getPatches()).transform(new Function<PatchListEntry, String>() {

                @Override
                public String apply(PatchListEntry entry) {
                    return entry.getNewName();
                }
            }).toSet();
        }
        int cnt = diffEntries.size();
        List<PatchListEntry> entries = new ArrayList<>();
        entries.add(newCommitMessage(cmp, reader, againstParent ? null : aCommit, b));
        for (int i = 0; i < cnt; i++) {
            DiffEntry diffEntry = diffEntries.get(i);
            if (paths == null || paths.contains(diffEntry.getNewPath()) || paths.contains(diffEntry.getOldPath())) {
                FileHeader fh = toFileHeader(key, df, diffEntry);
                long sizeDelta = getFileSize(repo, reader, diffEntry.getNewPath(), bTree) - getFileSize(repo, reader, diffEntry.getOldPath(), aTree);
                entries.add(newEntry(aTree, fh, sizeDelta));
            }
        }
        return new PatchList(a, b, againstParent, entries.toArray(new PatchListEntry[entries.size()]));
    }
}
#end_block

#method_before
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes("UTF-8");
    RawText aRawText = new RawText(aText.getContent());
    RawText bRawText = new RawText(bText.getContent());
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits);
}
#method_after
private PatchListEntry newCommitMessage(final RawTextComparator cmp, final ObjectReader reader, final RevCommit aCommit, final RevCommit bCommit) throws IOException {
    StringBuilder hdr = new StringBuilder();
    hdr.append("diff --git");
    if (aCommit != null) {
        hdr.append(" a/").append(Patch.COMMIT_MSG);
    } else {
        hdr.append(" ").append(FileHeader.DEV_NULL);
    }
    hdr.append(" b/").append(Patch.COMMIT_MSG);
    hdr.append("\n");
    if (aCommit != null) {
        hdr.append("--- a/").append(Patch.COMMIT_MSG).append("\n");
    } else {
        hdr.append("--- ").append(FileHeader.DEV_NULL).append("\n");
    }
    hdr.append("+++ b/").append(Patch.COMMIT_MSG).append("\n");
    Text aText = aCommit != null ? Text.forCommit(reader, aCommit) : Text.EMPTY;
    Text bText = Text.forCommit(reader, bCommit);
    byte[] rawHdr = hdr.toString().getBytes("UTF-8");
    byte[] aContent = aText.getContent();
    byte[] bContent = bText.getContent();
    long sizeDelta = bContent.length - aContent.length;
    RawText aRawText = new RawText(aContent);
    RawText bRawText = new RawText(bContent);
    EditList edits = new HistogramDiff().diff(cmp, aRawText, bRawText);
    FileHeader fh = new FileHeader(rawHdr, edits, PatchType.UNIFIED);
    return new PatchListEntry(fh, edits, sizeDelta);
}
#end_block

#method_before
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList());
    } else {
        return new PatchListEntry(fileHeader, edits);
    }
}
#method_after
private PatchListEntry newEntry(RevTree aTree, FileHeader fileHeader, long sizeDelta) {
    final FileMode oldMode = fileHeader.getOldMode();
    final FileMode newMode = fileHeader.getNewMode();
    if (oldMode == FileMode.GITLINK || newMode == FileMode.GITLINK) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    if (// want combined diff
    aTree == null || fileHeader.getPatchType() != PatchType.UNIFIED || fileHeader.getHunks().isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    }
    List<Edit> edits = fileHeader.toEditList();
    if (edits.isEmpty()) {
        return new PatchListEntry(fileHeader, Collections.<Edit>emptyList(), sizeDelta);
    } else {
        return new PatchListEntry(fileHeader, edits, sizeDelta);
    }
}
#end_block

#method_before
Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base) throws PatchListNotAvailableException {
    ObjectId a = (base == null) ? null : ObjectId.fromString(base.getRevision().get());
    ObjectId b = ObjectId.fromString(revision.get());
    PatchList list = patchListCache.get(new PatchListKey(a, b, Whitespace.IGNORE_NONE), change.getProject());
    Map<String, FileInfo> files = Maps.newTreeMap();
    for (PatchListEntry e : list.getPatches()) {
        FileInfo d = new FileInfo();
        d.status = e.getChangeType() != Patch.ChangeType.MODIFIED ? e.getChangeType().getCode() : null;
        d.oldPath = e.getOldName();
        if (e.getPatchType() == Patch.PatchType.BINARY) {
            d.binary = true;
            d.sizeDelta = e.getSizeDelta() != null ? e.getSizeDelta() : null;
        } else {
            d.linesInserted = e.getInsertions() > 0 ? e.getInsertions() : null;
            d.linesDeleted = e.getDeletions() > 0 ? e.getDeletions() : null;
        }
        FileInfo o = files.put(e.getNewName(), d);
        if (o != null) {
            // This should only happen on a delete-add break created by JGit
            // when the file was rewritten and too little content survived. Write
            // a single record with data from both sides.
            d.status = Patch.ChangeType.REWRITE.getCode();
            if (o.binary != null && o.binary) {
                d.binary = true;
                d.sizeDelta = o.sizeDelta;
            }
            if (o.linesInserted != null) {
                d.linesInserted = o.linesInserted;
            }
            if (o.linesDeleted != null) {
                d.linesDeleted = o.linesDeleted;
            }
        }
    }
    return files;
}
#method_after
Map<String, FileInfo> toFileInfoMap(Change change, RevId revision, @Nullable PatchSet base) throws PatchListNotAvailableException {
    ObjectId a = (base == null) ? null : ObjectId.fromString(base.getRevision().get());
    ObjectId b = ObjectId.fromString(revision.get());
    PatchList list = patchListCache.get(new PatchListKey(a, b, Whitespace.IGNORE_NONE), change.getProject());
    Map<String, FileInfo> files = Maps.newTreeMap();
    for (PatchListEntry e : list.getPatches()) {
        FileInfo d = new FileInfo();
        d.status = e.getChangeType() != Patch.ChangeType.MODIFIED ? e.getChangeType().getCode() : null;
        d.oldPath = e.getOldName();
        d.sizeDelta = e.getSizeDelta();
        if (e.getPatchType() == Patch.PatchType.BINARY) {
            d.binary = true;
        } else {
            d.linesInserted = e.getInsertions() > 0 ? e.getInsertions() : null;
            d.linesDeleted = e.getDeletions() > 0 ? e.getDeletions() : null;
        }
        FileInfo o = files.put(e.getNewName(), d);
        if (o != null) {
            // This should only happen on a delete-add break created by JGit
            // when the file was rewritten and too little content survived. Write
            // a single record with data from both sides.
            d.status = Patch.ChangeType.REWRITE.getCode();
            d.sizeDelta = o.sizeDelta;
            if (o.binary != null && o.binary) {
                d.binary = true;
            }
            if (o.linesInserted != null) {
                d.linesInserted = o.linesInserted;
            }
            if (o.linesDeleted != null) {
                d.linesDeleted = o.linesDeleted;
            }
        }
    }
    return files;
}
#end_block

#method_before
static PatchListEntry empty(final String fileName) {
    return new PatchListEntry(ChangeType.MODIFIED, PatchType.UNIFIED, null, fileName, EMPTY_HEADER, Collections.<Edit>emptyList(), 0, 0);
}
#method_after
static PatchListEntry empty(final String fileName) {
    return new PatchListEntry(ChangeType.MODIFIED, PatchType.UNIFIED, null, fileName, EMPTY_HEADER, Collections.<Edit>emptyList(), 0, 0, 0);
}
#end_block

#method_before
public Long getSizeDelta() {
    return sizeDelta;
}
#method_after
public long getSizeDelta() {
    return sizeDelta;
}
#end_block

#method_before
void writeTo(final OutputStream out) throws IOException {
    writeEnum(out, changeType);
    writeEnum(out, patchType);
    writeString(out, oldName);
    writeString(out, newName);
    writeBytes(out, header);
    writeVarInt32(out, insertions);
    writeVarInt32(out, deletions);
    writeVarInt32(out, edits.size());
    for (final Edit e : edits) {
        writeVarInt32(out, e.getBeginA());
        writeVarInt32(out, e.getEndA());
        writeVarInt32(out, e.getBeginB());
        writeVarInt32(out, e.getEndB());
    }
}
#method_after
void writeTo(OutputStream out) throws IOException {
    writeEnum(out, changeType);
    writeEnum(out, patchType);
    writeString(out, oldName);
    writeString(out, newName);
    writeBytes(out, header);
    writeVarInt32(out, insertions);
    writeVarInt32(out, deletions);
    writeFixInt64(out, sizeDelta);
    writeVarInt32(out, edits.size());
    for (final Edit e : edits) {
        writeVarInt32(out, e.getBeginA());
        writeVarInt32(out, e.getEndA());
        writeVarInt32(out, e.getBeginB());
        writeVarInt32(out, e.getEndB());
    }
}
#end_block

#method_before
static PatchListEntry readFrom(final InputStream in) throws IOException {
    final ChangeType changeType = readEnum(in, ChangeType.values());
    final PatchType patchType = readEnum(in, PatchType.values());
    final String oldName = readString(in);
    final String newName = readString(in);
    final byte[] hdr = readBytes(in);
    final int ins = readVarInt32(in);
    final int del = readVarInt32(in);
    final int editCount = readVarInt32(in);
    final Edit[] editArray = new Edit[editCount];
    for (int i = 0; i < editCount; i++) {
        int beginA = readVarInt32(in);
        int endA = readVarInt32(in);
        int beginB = readVarInt32(in);
        int endB = readVarInt32(in);
        editArray[i] = new Edit(beginA, endA, beginB, endB);
    }
    return new PatchListEntry(changeType, patchType, oldName, newName, hdr, toList(editArray), ins, del);
}
#method_after
static PatchListEntry readFrom(InputStream in) throws IOException {
    ChangeType changeType = readEnum(in, ChangeType.values());
    PatchType patchType = readEnum(in, PatchType.values());
    String oldName = readString(in);
    String newName = readString(in);
    byte[] hdr = readBytes(in);
    int ins = readVarInt32(in);
    int del = readVarInt32(in);
    long sizeDelta = readFixInt64(in);
    int editCount = readVarInt32(in);
    Edit[] editArray = new Edit[editCount];
    for (int i = 0; i < editCount; i++) {
        int beginA = readVarInt32(in);
        int endA = readVarInt32(in);
        int beginB = readVarInt32(in);
        int endB = readVarInt32(in);
        editArray[i] = new Edit(beginA, endA, beginB, endB);
    }
    return new PatchListEntry(changeType, patchType, oldName, newName, hdr, toList(editArray), ins, del, sizeDelta);
}
#end_block

#method_before
private static void settings(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (matchExact(SETTINGS, token)) {
                return new MyProfileScreen();
            }
            if (matchExact(SETTINGS_PREFERENCES, token)) {
                return new MyPreferencesScreen();
            }
            if (matchExact(SETTINGS_DIFF_PREFERENCES, token)) {
                return new MyDiffPreferencesScreen();
            }
            if (matchExact(SETTINGS_PROJECTS, token)) {
                return new MyWatchedProjectsScreen();
            }
            if (matchExact(SETTINGS_CONTACT, token)) {
                return new MyContactInformationScreen();
            }
            if (matchExact(SETTINGS_SSHKEYS, token)) {
                return new MySshKeysScreen();
            }
            if (matchExact(SETTINGS_GPGKEYS, token)) {
                return new MyGpgKeysScreen();
            }
            if (matchExact(SETTINGS_WEBIDENT, token)) {
                return new MyIdentitiesScreen();
            }
            if (matchExact(SETTINGS_HTTP_PASSWORD, token)) {
                return new MyPasswordScreen();
            }
            if (matchExact(MY_GROUPS, token) || matchExact(SETTINGS_MYGROUPS, token)) {
                return new MyGroupsScreen();
            }
            if (matchExact(SETTINGS_AGREEMENTS, token) && Gerrit.info().auth().useContributorAgreements()) {
                return new MyAgreementsScreen();
            }
            if (matchExact(REGISTER, token) || matchExact("/register/", token) || matchExact("register", token)) {
                return new RegisterScreen(MINE);
            } else if (matchPrefix("/register/", token)) {
                return new RegisterScreen("/" + skip(token));
            }
            if (matchPrefix("/VE/", token) || matchPrefix("VE,", token)) {
                return new ValidateEmailScreen(skip(token));
            }
            if (matchExact(SETTINGS_NEW_AGREEMENT, token)) {
                return new NewAgreementScreen();
            }
            if (matchPrefix(SETTINGS_NEW_AGREEMENT + "/", token)) {
                return new NewAgreementScreen(skip(token));
            }
            if (matchPrefix(SETTINGS_EXTENSION, token)) {
                ExtensionSettingsScreen view = new ExtensionSettingsScreen(skip(token));
                if (view.isFound()) {
                    return view;
                } else {
                    return new NotFoundScreen();
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void settings(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            Gerrit.display(token, select());
        }

        private Screen select() {
            if (matchExact(SETTINGS, token)) {
                return new MyProfileScreen();
            }
            if (matchExact(SETTINGS_PREFERENCES, token)) {
                return new MyPreferencesScreen();
            }
            if (matchExact(SETTINGS_DIFF_PREFERENCES, token)) {
                return new MyDiffPreferencesScreen();
            }
            if (matchExact(SETTINGS_PROJECTS, token)) {
                return new MyWatchedProjectsScreen();
            }
            if (matchExact(SETTINGS_CONTACT, token)) {
                return new MyContactInformationScreen();
            }
            if (matchExact(SETTINGS_SSHKEYS, token)) {
                return new MySshKeysScreen();
            }
            if (matchExact(SETTINGS_GPGKEYS, token) && Gerrit.info().gerrit().editGpgKeys()) {
                return new MyGpgKeysScreen();
            }
            if (matchExact(SETTINGS_WEBIDENT, token)) {
                return new MyIdentitiesScreen();
            }
            if (matchExact(SETTINGS_HTTP_PASSWORD, token)) {
                return new MyPasswordScreen();
            }
            if (matchExact(MY_GROUPS, token) || matchExact(SETTINGS_MYGROUPS, token)) {
                return new MyGroupsScreen();
            }
            if (matchExact(SETTINGS_AGREEMENTS, token) && Gerrit.info().auth().useContributorAgreements()) {
                return new MyAgreementsScreen();
            }
            if (matchExact(REGISTER, token) || matchExact("/register/", token) || matchExact("register", token)) {
                return new RegisterScreen(MINE);
            } else if (matchPrefix("/register/", token)) {
                return new RegisterScreen("/" + skip(token));
            }
            if (matchPrefix("/VE/", token) || matchPrefix("VE,", token)) {
                return new ValidateEmailScreen(skip(token));
            }
            if (matchExact(SETTINGS_NEW_AGREEMENT, token)) {
                return new NewAgreementScreen();
            }
            if (matchPrefix(SETTINGS_NEW_AGREEMENT + "/", token)) {
                return new NewAgreementScreen(skip(token));
            }
            if (matchPrefix(SETTINGS_EXTENSION, token)) {
                ExtensionSettingsScreen view = new ExtensionSettingsScreen(skip(token));
                if (view.isFound()) {
                    return view;
                } else {
                    return new NotFoundScreen();
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    NotesMigration notesMigration = sysInjector.getInstance(NotesMigration.class);
    if (!notesMigration.enabled()) {
        die("Notedb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the notedb");
    ChangeRebuilder rebuilder = sysInjector.getInstance(ChangeRebuilder.class);
    Multimap<Project.NameKey, Change> changesByProject = getChangesByProject();
    final AtomicBoolean ok = new AtomicBoolean(true);
    Stopwatch sw = Stopwatch.createStarted();
    GitRepositoryManager repoManager = sysInjector.getInstance(GitRepositoryManager.class);
    final Project.NameKey allUsersName = sysInjector.getInstance(AllUsersName.class);
    try (Repository allUsersRepo = repoManager.openMetadataRepository(allUsersName)) {
        deleteDraftRefs(allUsersRepo);
        for (final Project.NameKey project : changesByProject.keySet()) {
            try (Repository repo = repoManager.openMetadataRepository(project)) {
                final BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
                final BatchRefUpdate bruForDrafts = allUsersRepo.getRefDatabase().newBatchUpdate();
                List<ListenableFuture<?>> futures = Lists.newArrayList();
                // Here, we elide the project name to 50 characters to ensure that
                // the whole monitor line for a project fits on one line (<80 chars).
                final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, elide(project.get()));
                final Task doneTask = mpm.beginSubTask("done", changesByProject.get(project).size());
                final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
                for (final Change c : changesByProject.get(project)) {
                    final ListenableFuture<?> future = rebuilder.rebuildAsync(c, executor, bru, bruForDrafts, repo, allUsersRepo);
                    futures.add(future);
                    future.addListener(new RebuildListener(c.getId(), future, ok, doneTask, failedTask), MoreExecutors.directExecutor());
                }
                mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

                    @Override
                    public ListenableFuture<Void> apply(List<?> input) throws Exception {
                        execute(bru, repo);
                        execute(bruForDrafts, allUsersRepo);
                        mpm.end();
                        return Futures.immediateFuture(null);
                    }
                }));
            } catch (Exception e) {
                log.error("Error rebuilding notedb", e);
                ok.set(false);
                break;
            }
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok.get() ? 0 : 1;
}
#method_after
@Override
public int run() throws Exception {
    mustHaveValidSite();
    dbInjector = createDbInjector(MULTI_USER);
    threads = ThreadLimiter.limitThreads(dbInjector, threads);
    LifecycleManager dbManager = new LifecycleManager();
    dbManager.add(dbInjector);
    dbManager.start();
    sysInjector = createSysInjector();
    NotesMigration notesMigration = sysInjector.getInstance(NotesMigration.class);
    if (!notesMigration.enabled()) {
        die("Notedb is not enabled.");
    }
    LifecycleManager sysManager = new LifecycleManager();
    sysManager.add(sysInjector);
    sysManager.start();
    ListeningExecutorService executor = newExecutor();
    System.out.println("Rebuilding the notedb");
    ChangeRebuilder rebuilder = sysInjector.getInstance(ChangeRebuilder.class);
    Multimap<Project.NameKey, Change> changesByProject = getChangesByProject();
    final AtomicBoolean ok = new AtomicBoolean(true);
    Stopwatch sw = Stopwatch.createStarted();
    GitRepositoryManager repoManager = sysInjector.getInstance(GitRepositoryManager.class);
    final Project.NameKey allUsersName = sysInjector.getInstance(AllUsersName.class);
    try (Repository allUsersRepo = repoManager.openMetadataRepository(allUsersName)) {
        deleteDraftRefs(allUsersRepo);
        for (final Project.NameKey project : changesByProject.keySet()) {
            try (Repository repo = repoManager.openMetadataRepository(project)) {
                final BatchRefUpdate bru = repo.getRefDatabase().newBatchUpdate();
                final BatchRefUpdate bruForDrafts = allUsersRepo.getRefDatabase().newBatchUpdate();
                List<ListenableFuture<?>> futures = Lists.newArrayList();
                // Here, we elide the project name to 50 characters to ensure that
                // the whole monitor line for a project fits on one line (<80 chars).
                final MultiProgressMonitor mpm = new MultiProgressMonitor(System.out, FormatUtil.elide(project.get(), 50));
                final Task doneTask = mpm.beginSubTask("done", changesByProject.get(project).size());
                final Task failedTask = mpm.beginSubTask("failed", MultiProgressMonitor.UNKNOWN);
                for (final Change c : changesByProject.get(project)) {
                    final ListenableFuture<?> future = rebuilder.rebuildAsync(c, executor, bru, bruForDrafts, repo, allUsersRepo);
                    futures.add(future);
                    future.addListener(new RebuildListener(c.getId(), future, ok, doneTask, failedTask), MoreExecutors.directExecutor());
                }
                mpm.waitFor(Futures.transformAsync(Futures.successfulAsList(futures), new AsyncFunction<List<?>, Void>() {

                    @Override
                    public ListenableFuture<Void> apply(List<?> input) throws Exception {
                        execute(bru, repo);
                        execute(bruForDrafts, allUsersRepo);
                        mpm.end();
                        return Futures.immediateFuture(null);
                    }
                }));
            } catch (Exception e) {
                log.error("Error rebuilding notedb", e);
                ok.set(false);
                break;
            }
        }
    }
    double t = sw.elapsed(TimeUnit.MILLISECONDS) / 1000d;
    System.out.format("Rebuild %d changes in %.01fs (%.01f/s)\n", changesByProject.size(), t, changesByProject.size() / t);
    return ok.get() ? 0 : 1;
}
#end_block

#method_before
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = projectControl.controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = projectControl.getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change);
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (!hashtags.isEmpty()) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
        if (!approvals.isEmpty()) {
            hooks.doCommentAddedHook(change, ((IdentifiedUser) ctl.getCurrentUser()).getAccount(), patchSet, null, approvals, db);
        }
    }
    return change;
}
#method_after
public Change insert() throws OrmException, IOException {
    ReviewDb db = dbProvider.get();
    ChangeControl ctl = projectControl.controlFor(change);
    ChangeUpdate update = updateFactory.create(ctl, change.getCreatedOn());
    db.changes().beginTransaction(change.getId());
    try {
        ChangeUtil.insertAncestors(db, patchSet.getId(), commit);
        db.patchSets().insert(Collections.singleton(patchSet));
        db.changes().insert(Collections.singleton(change));
        LabelTypes labelTypes = projectControl.getLabelTypes();
        approvalsUtil.addReviewers(db, update, labelTypes, change, patchSet, patchSetInfo, reviewers, Collections.<Account.Id>emptySet());
        approvalsUtil.addApprovals(db, update, labelTypes, patchSet, patchSetInfo, ctl, approvals);
        if (messageIsForChange()) {
            cmUtil.addChangeMessage(db, update, changeMessage);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    if (hashtags != null && hashtags.size() > 0) {
        try {
            HashtagsInput input = new HashtagsInput();
            input.add = hashtags;
            hashtagsUtil.setHashtags(ctl, input, false, false);
        } catch (ValidationException | AuthException e) {
            log.error("Cannot add hashtags to change " + change.getId(), e);
        }
    }
    CheckedFuture<?, IOException> f = indexer.indexAsync(change.getId());
    if (!messageIsForChange()) {
        commitMessageNotForChange();
    }
    if (sendMail) {
        Runnable sender = new Runnable() {

            @Override
            public void run() {
                try {
                    CreateChangeSender cm = createChangeSenderFactory.create(change);
                    cm.setFrom(change.getOwner());
                    cm.setPatchSet(patchSet, patchSetInfo);
                    cm.addReviewers(reviewers);
                    cm.addExtraCC(extraCC);
                    cm.send();
                } catch (Exception e) {
                    log.error("Cannot send email for new change " + change.getId(), e);
                }
            }

            @Override
            public String toString() {
                return "send-email newchange";
            }
        };
        if (requestScopePropagator != null) {
            workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(sender));
        } else {
            sender.run();
        }
    }
    f.checkedGet();
    gitRefUpdated.fire(change.getProject(), patchSet.getRefName(), ObjectId.zeroId(), commit);
    if (runHooks) {
        hooks.doPatchsetCreatedHook(change, patchSet, db);
        if (hashtags != null && hashtags.size() > 0) {
            hooks.doHashtagsChangedHook(change, accountCache.get(change.getOwner()).getAccount(), hashtags, null, hashtags, db);
        }
        if (approvals != null && !approvals.isEmpty()) {
            hooks.doCommentAddedHook(change, ((IdentifiedUser) ctl.getCurrentUser()).getAccount(), patchSet, null, approvals, db);
        }
    }
    return change;
}
#end_block

#method_before
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.linesInserted() + info.linesDeleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.linesInserted()).append(" lines");
            } else {
                sb.append("+").append(info.linesInserted()).append(", -").append(info.linesDeleted());
            }
        }
    } else if (info.binary()) {
        sb.append(formatBytes(info.sizeDelta()));
    }
    sb.closeTd();
}
#method_after
private void columnDelta1(SafeHtmlBuilder sb, FileInfo info) {
    sb.openTd().setStyleName(R.css().deltaColumn1());
    if (!Patch.COMMIT_MSG.equals(info.path()) && !info.binary()) {
        if (showChangeSizeBars) {
            sb.append(info.linesInserted() + info.linesDeleted());
        } else if (!ChangeType.DELETED.matches(info.status())) {
            if (ChangeType.ADDED.matches(info.status())) {
                sb.append(info.linesInserted()).append(" lines");
            } else {
                sb.append("+").append(info.linesInserted()).append(", -").append(info.linesDeleted());
            }
        }
    } else if (info.binary()) {
        sb.append(FormatUtil.formatBytes(info.sizeDelta()));
    }
    sb.closeTd();
}
#end_block

#method_before
public final long sizeDelta() {
    return (long) _sizeDelta();
}
#method_after
// JSNI methods cannot have 'long' as a parameter type or a return type and
// it's suggested to use double in this case:
public final long sizeDelta() {
    return (long) _sizeDelta();
}
#end_block

#method_before
public boolean isDraftVisible(ReviewDb db, ChangeData cd) throws OrmException {
    return isOwner() || isReviewer(db, cd) || getRefControl().canViewDrafts() || getCurrentUser() instanceof InternalUser;
}
#method_after
public boolean isDraftVisible(ReviewDb db, ChangeData cd) throws OrmException {
    return isOwner() || isReviewer(db, cd) || getRefControl().canViewDrafts() || getCurrentUser().isInternalUser();
}
#end_block

#method_before
private void checkSignature(PGPSignature sig, PushCertificate cert, PublicKeyStore store, List<String> problems) throws PGPException, IOException {
    PGPPublicKeyRingCollection keys = store.get(sig.getKeyID());
    if (!keys.getKeyRings().hasNext()) {
        problems.add("No public keys found for key ID " + keyIdToString(sig.getKeyID()));
        return;
    }
    PGPPublicKey signer = PublicKeyStore.getSigner(keys, sig, Constants.encode(cert.toText()));
    if (signer == null) {
        problems.add("Signature by " + keyIdToString(sig.getKeyID()) + " is not valid");
        return;
    }
    CheckResult result = publicKeyChecker.check(signer, store);
    if (!result.isOk()) {
        problems.add(new StringBuilder("Invalid public key ").append(keyToString(signer)).append(":\n  ").append(Joiner.on("\n  ").join(result.getProblems())).toString());
    }
}
#method_after
private void checkSignature(PGPSignature sig, PushCertificate cert, PublicKeyStore store, List<String> problems) throws PGPException, IOException {
    PGPPublicKeyRingCollection keys = store.get(sig.getKeyID());
    if (!keys.getKeyRings().hasNext()) {
        problems.add("No public keys found for key ID " + keyIdToString(sig.getKeyID()));
        return;
    }
    PGPPublicKey signer = PublicKeyStore.getSigner(keys, sig, Constants.encode(cert.toText()));
    if (signer == null) {
        problems.add("Signature by " + keyIdToString(sig.getKeyID()) + " is not valid");
        return;
    }
    CheckResult result = publicKeyChecker.check(signer, store);
    if (!result.isOk()) {
        problems.add("Invalid public key " + keyToString(signer) + ":\n  " + Joiner.on("\n  ").join(result.getProblems()));
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(Q.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
}
#method_after
@Before
public void setUp() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    AccountGroup.UUID anonymousUsers = SystemGroupBackend.getGroup(ANONYMOUS_USERS).getUUID();
    Util.allow(cfg, Permission.forLabel(Q.getName()), -1, 1, anonymousUsers, "refs/heads/*");
    Util.allow(cfg, Permission.forLabel(P.getName()), 0, 1, anonymousUsers, "refs/heads/*");
    saveProjectConfig(cfg);
}
#end_block

#method_before
private void saveLabelConfig() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.getLabelSections().put(Q.getName(), Q);
    saveProjectConfig(cfg);
}
#method_after
private void saveLabelConfig() throws Exception {
    ProjectConfig cfg = projectCache.checkedGet(allProjects).getConfig();
    cfg.getLabelSections().put(Q.getName(), Q);
    cfg.getLabelSections().put(P.getName(), P);
    saveProjectConfig(cfg);
}
#end_block

#method_before
@Override
protected Change.Id updateProjectConfig(ProjectControl ctl, ProjectConfig config, MetaDataUpdate md, String message, boolean parentProjectUpdate) throws IOException, OrmException {
    RevCommit baseCommit = getBaseCommit(config);
    ObjectId id = ChangeIdUtil.computeChangeId(baseCommit.getTree(), baseCommit, metaDataUpdateFactory.getUserPersonIdent(), serverIdent, message);
    md.setMessage(ChangeIdUtil.insertId(message, id));
    Change.Id changeId = new Change.Id(db.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    Change change = new Change(getChangeId(id, commit), changeId, user.getAccountId(), new Branch.NameKey(config.getProject().getNameKey(), RefNames.REFS_CONFIG), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(ctl, change, commit);
    ins.insert();
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#method_after
@Override
protected Change.Id updateProjectConfig(ProjectControl ctl, ProjectConfig config, MetaDataUpdate md, boolean parentProjectUpdate) throws IOException, OrmException {
    md.setInsertChangeId(true);
    Change.Id changeId = new Change.Id(db.nextChangeId());
    RevCommit commit = config.commitToNewRef(md, new PatchSet.Id(changeId, Change.INITIAL_PATCH_SET_ID).toRefName());
    if (commit.getId().equals(base)) {
        return null;
    }
    Change change = new Change(getChangeId(commit), changeId, user.getAccountId(), new Branch.NameKey(config.getProject().getNameKey(), RefNames.REFS_CONFIG), TimeUtil.nowTs());
    ChangeInserter ins = changeInserterFactory.create(ctl, change, commit);
    ins.insert();
    ChangeResource rsrc;
    try {
        rsrc = changes.parse(changeId);
    } catch (ResourceNotFoundException e) {
        throw new IOException(e);
    }
    addProjectOwnersAsReviewers(rsrc);
    if (parentProjectUpdate) {
        addAdministratorsAsReviewers(rsrc);
    }
    return changeId;
}
#end_block

#method_before
private static Change.Key getChangeId(ObjectId id, RevCommit emptyCommit) {
    List<String> idList = emptyCommit.getFooterLines(FooterConstants.CHANGE_ID);
    Change.Key changeKey = !idList.isEmpty() ? new Change.Key(idList.get(idList.size() - 1).trim()) : new Change.Key("I" + id.name());
    return changeKey;
}
#method_after
private static Change.Key getChangeId(RevCommit commit) {
    List<String> idList = commit.getFooterLines(FooterConstants.CHANGE_ID);
    Change.Key changeKey = !idList.isEmpty() ? new Change.Key(idList.get(idList.size() - 1).trim()) : new Change.Key("I" + commit.name());
    return changeKey;
}
#end_block

#method_before
private void addProjectOwnersAsReviewers(ChangeResource rsrc) {
    final String projectOwners = groupBackend.get(SystemGroupBackend.PROJECT_OWNERS).getName();
    try {
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = projectOwners;
        reviewersProvider.get().apply(rsrc, input);
    } catch (Exception e) {
    // one of the owner groups is not visible to the user and this it why it
    // can't be added as reviewer
    }
}
#method_after
private void addProjectOwnersAsReviewers(ChangeResource rsrc) {
    final String projectOwners = groupBackend.get(SystemGroupBackend.PROJECT_OWNERS).getName();
    try {
        AddReviewerInput input = new AddReviewerInput();
        input.reviewer = projectOwners;
        reviewersProvider.get().apply(rsrc, input);
    } catch (IOException | OrmException | RestApiException | EmailException e) {
    // one of the owner groups is not visible to the user and this it why it
    // can't be added as reviewer
    }
}
#end_block

#method_before
private void addAdministratorsAsReviewers(ChangeResource rsrc) {
    List<PermissionRule> adminRules = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER).getRules();
    for (PermissionRule r : adminRules) {
        try {
            AddReviewerInput input = new AddReviewerInput();
            input.reviewer = r.getGroup().getUUID().get();
            reviewersProvider.get().apply(rsrc, input);
        } catch (Exception e) {
        // ignore
        }
    }
}
#method_after
private void addAdministratorsAsReviewers(ChangeResource rsrc) {
    List<PermissionRule> adminRules = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER).getRules();
    for (PermissionRule r : adminRules) {
        try {
            AddReviewerInput input = new AddReviewerInput();
            input.reviewer = r.getGroup().getUUID().get();
            reviewersProvider.get().apply(rsrc, input);
        } catch (IOException | OrmException | RestApiException | EmailException e) {
        // ignore
        }
    }
}
#end_block

#method_before
private List<TagInfo> listTags() throws RestApiException {
    ListTags list = listTagsProvider.get();
    try {
        return list.apply(checkExists());
    } catch (IOException e) {
        throw new RestApiException("Cannot list tags", e);
    }
}
#method_after
private List<TagInfo> listTags() throws RestApiException {
    try {
        return listTags.apply(checkExists());
    } catch (IOException e) {
        throw new RestApiException("Cannot list tags", e);
    }
}
#end_block

#method_before
@Override
public boolean apply(T in) {
    if (!in.ref.startsWith(prefix)) {
        return a.run(in.ref);
    } else {
        return a.run(in.ref.substring(prefix.length()));
    }
}
#method_after
@Override
public boolean apply(T in) {
    String ref = in.ref;
    if (ref.startsWith(prefix)) {
        ref = ref.substring(prefix.length());
    }
    return a.run(ref);
}
#end_block

#method_before
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    post(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.user").to(GetUserPreferences.class);
    put(ACCOUNT_KIND, "preferences.user").to(SetUserPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    install(new FactoryModuleBuilder().build(CreateAccount.Factory.class));
    install(new FactoryModuleBuilder().build(CreateEmail.Factory.class));
}
#method_after
@Override
protected void configure() {
    bind(AccountsCollection.class);
    bind(Capabilities.class);
    DynamicMap.mapOf(binder(), ACCOUNT_KIND);
    DynamicMap.mapOf(binder(), CAPABILITY_KIND);
    DynamicMap.mapOf(binder(), EMAIL_KIND);
    DynamicMap.mapOf(binder(), SSH_KEY_KIND);
    DynamicMap.mapOf(binder(), STARRED_CHANGE_KIND);
    put(ACCOUNT_KIND).to(PutAccount.class);
    get(ACCOUNT_KIND).to(GetAccount.class);
    get(ACCOUNT_KIND, "detail").to(GetDetail.class);
    get(ACCOUNT_KIND, "name").to(GetName.class);
    put(ACCOUNT_KIND, "name").to(PutName.class);
    delete(ACCOUNT_KIND, "name").to(PutName.class);
    get(ACCOUNT_KIND, "username").to(GetUsername.class);
    put(ACCOUNT_KIND, "username").to(PutUsername.class);
    get(ACCOUNT_KIND, "active").to(GetActive.class);
    put(ACCOUNT_KIND, "active").to(PutActive.class);
    delete(ACCOUNT_KIND, "active").to(DeleteActive.class);
    child(ACCOUNT_KIND, "emails").to(Emails.class);
    get(EMAIL_KIND).to(GetEmail.class);
    put(EMAIL_KIND).to(PutEmail.class);
    delete(EMAIL_KIND).to(DeleteEmail.class);
    put(EMAIL_KIND, "preferred").to(PutPreferred.class);
    get(ACCOUNT_KIND, "password.http").to(GetHttpPassword.class);
    put(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    delete(ACCOUNT_KIND, "password.http").to(PutHttpPassword.class);
    child(ACCOUNT_KIND, "sshkeys").to(SshKeys.class);
    post(ACCOUNT_KIND, "sshkeys").to(AddSshKey.class);
    get(SSH_KEY_KIND).to(GetSshKey.class);
    delete(SSH_KEY_KIND).to(DeleteSshKey.class);
    get(ACCOUNT_KIND, "avatar").to(GetAvatar.class);
    get(ACCOUNT_KIND, "avatar.change.url").to(GetAvatarChangeUrl.class);
    child(ACCOUNT_KIND, "capabilities").to(Capabilities.class);
    get(ACCOUNT_KIND, "groups").to(GetGroups.class);
    get(ACCOUNT_KIND, "preferences").to(GetPreferences.class);
    put(ACCOUNT_KIND, "preferences").to(SetPreferences.class);
    get(ACCOUNT_KIND, "preferences.diff").to(GetDiffPreferences.class);
    put(ACCOUNT_KIND, "preferences.diff").to(SetDiffPreferences.class);
    get(ACCOUNT_KIND, "preferences.edit").to(GetEditPreferences.class);
    put(ACCOUNT_KIND, "preferences.edit").to(SetEditPreferences.class);
    get(CAPABILITY_KIND).to(GetCapabilities.CheckOne.class);
    child(ACCOUNT_KIND, "starred.changes").to(StarredChanges.class);
    put(STARRED_CHANGE_KIND).to(StarredChanges.Put.class);
    delete(STARRED_CHANGE_KIND).to(StarredChanges.Delete.class);
    bind(StarredChanges.Create.class);
    factory(CreateAccount.Factory.class);
    factory(CreateEmail.Factory.class);
}
#end_block

#method_before
public static EditPreferencesInfo defaults() {
    EditPreferencesInfo i = new EditPreferencesInfo();
    i.tabSize = 8;
    i.lineLength = 100;
    i.cursorBlinkRate = 0;
    i.hideTopMenu = false;
    i.showTabs = true;
    i.showWhitespaceErrors = false;
    i.syntaxHighlighting = true;
    i.hideLineNumbers = false;
    i.matchBrackets = false;
    i.theme = Theme.DEFAULT;
    i.keyMapType = KeyMapType.DEFAULT;
    return i;
}
#method_after
public static EditPreferencesInfo defaults() {
    EditPreferencesInfo i = new EditPreferencesInfo();
    i.tabSize = 8;
    i.lineLength = 100;
    i.cursorBlinkRate = 0;
    i.hideTopMenu = false;
    i.showTabs = true;
    i.showWhitespaceErrors = false;
    i.syntaxHighlighting = true;
    i.hideLineNumbers = false;
    i.matchBrackets = true;
    i.theme = Theme.DEFAULT;
    i.keyMapType = KeyMapType.DEFAULT;
    return i;
}
#end_block

#method_before
@Test
public void getSetEditPreferences() throws Exception {
    String endPoint = "/accounts/" + admin.email + "/preferences.edit";
    RestResponse r = adminSession.get(endPoint);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    EditPreferencesInfo out = getEditPrefInfo(r);
    assertThat(out.lineLength).isEqualTo(100);
    assertThat(out.tabSize).isEqualTo(8);
    assertThat(out.cursorBlinkRate).isEqualTo(0);
    assertThat(out.hideTopMenu).isNull();
    assertThat(out.showTabs).isTrue();
    assertThat(out.showWhitespaceErrors).isNull();
    assertThat(out.syntaxHighlighting).isTrue();
    assertThat(out.hideLineNumbers).isNull();
    assertThat(out.matchBrackets).isNull();
    assertThat(out.theme).isEqualTo(Theme.DEFAULT);
    assertThat(out.keyMapType).isEqualTo(KeyMapType.DEFAULT);
    // change some default values
    out.lineLength = 80;
    out.tabSize = 4;
    out.cursorBlinkRate = 500;
    out.hideTopMenu = true;
    out.showTabs = false;
    out.showWhitespaceErrors = true;
    out.syntaxHighlighting = false;
    out.hideLineNumbers = true;
    out.matchBrackets = false;
    out.theme = Theme.TWILIGHT;
    out.keyMapType = KeyMapType.EMACS;
    r = adminSession.put(endPoint, out);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_NO_CONTENT);
    r = adminSession.get(endPoint);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    EditPreferencesInfo info = getEditPrefInfo(r);
    assertEditPreferences(info, out);
}
#method_after
@Test
public void getSetEditPreferences() throws Exception {
    String endPoint = "/accounts/" + admin.email + "/preferences.edit";
    RestResponse r = adminSession.get(endPoint);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    EditPreferencesInfo out = getEditPrefInfo(r);
    assertThat(out.lineLength).isEqualTo(100);
    assertThat(out.tabSize).isEqualTo(8);
    assertThat(out.cursorBlinkRate).isEqualTo(0);
    assertThat(out.hideTopMenu).isNull();
    assertThat(out.showTabs).isTrue();
    assertThat(out.showWhitespaceErrors).isNull();
    assertThat(out.syntaxHighlighting).isTrue();
    assertThat(out.hideLineNumbers).isNull();
    assertThat(out.matchBrackets).isTrue();
    assertThat(out.theme).isEqualTo(Theme.DEFAULT);
    assertThat(out.keyMapType).isEqualTo(KeyMapType.DEFAULT);
    // change some default values
    out.lineLength = 80;
    out.tabSize = 4;
    out.cursorBlinkRate = 500;
    out.hideTopMenu = true;
    out.showTabs = false;
    out.showWhitespaceErrors = true;
    out.syntaxHighlighting = false;
    out.hideLineNumbers = true;
    out.matchBrackets = false;
    out.theme = Theme.TWILIGHT;
    out.keyMapType = KeyMapType.EMACS;
    r = adminSession.put(endPoint, out);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_NO_CONTENT);
    r = adminSession.get(endPoint);
    assertThat(r.getStatusCode()).isEqualTo(HttpStatus.SC_OK);
    EditPreferencesInfo info = getEditPrefInfo(r);
    assertEditPreferences(info, out);
}
#end_block

#method_before
private void assertEditPreferences(EditPreferencesInfo out, EditPreferencesInfo in) {
    assertThat(out.lineLength).isEqualTo(in.lineLength);
    assertThat(out.tabSize).isEqualTo(in.tabSize);
    assertThat(out.cursorBlinkRate).isEqualTo(in.cursorBlinkRate);
    assertThat(out.hideTopMenu).isEqualTo(in.hideTopMenu);
    assertThat(out.showTabs).isNull();
    assertThat(out.showWhitespaceErrors).isEqualTo(in.showWhitespaceErrors);
    assertThat(out.syntaxHighlighting).isNull();
    assertThat(out.hideLineNumbers).isEqualTo(in.hideLineNumbers);
    assertThat(out.matchBrackets).isEqualTo(in.matchBrackets);
    assertThat(out.theme).isEqualTo(in.theme);
    assertThat(out.keyMapType).isEqualTo(in.keyMapType);
}
#method_after
private void assertEditPreferences(EditPreferencesInfo out, EditPreferencesInfo in) {
    assertThat(out.lineLength).isEqualTo(in.lineLength);
    assertThat(out.tabSize).isEqualTo(in.tabSize);
    assertThat(out.cursorBlinkRate).isEqualTo(in.cursorBlinkRate);
    assertThat(out.hideTopMenu).isEqualTo(in.hideTopMenu);
    assertThat(out.showTabs).isNull();
    assertThat(out.showWhitespaceErrors).isEqualTo(in.showWhitespaceErrors);
    assertThat(out.syntaxHighlighting).isNull();
    assertThat(out.hideLineNumbers).isEqualTo(in.hideLineNumbers);
    assertThat(out.matchBrackets).isNull();
    assertThat(out.theme).isEqualTo(in.theme);
    assertThat(out.keyMapType).isEqualTo(in.keyMapType);
}
#end_block

#method_before
@UiHandler("cursorBlinkRate")
void onCursoBlinkRate(ValueChangeEvent<String> e) {
    String v = e.getValue();
    if (v != null && v.length() > 0) {
        // A negative value hides the cursor entirely:
        // don't let user shot himself in the foot.
        prefs.cursorBlinkRate(Math.max(0, Integer.parseInt(v)));
        view.getEditor().setOption("cursorBlinkRate", prefs.cursorBlinkRate());
    }
}
#method_after
@UiHandler("cursorBlinkRate")
void onCursoBlinkRate(ValueChangeEvent<String> e) {
    String v = e.getValue();
    if (v != null && v.length() > 0) {
        // A negative value hides the cursor entirely:
        // don't let user shoot himself in the foot.
        prefs.cursorBlinkRate(Math.max(0, Integer.parseInt(v)));
        view.getEditor().setOption("cursorBlinkRate", prefs.cursorBlinkRate());
    }
}
#end_block

#method_before
private void onLoad2() {
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
            group2.done();
            group3.done();
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (revision.get() == 0) {
        ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() {

            @Override
            public void onSuccess(EditFileInfo editInfo) {
                editFileInfo = editInfo;
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    } else {
        // TODO(davido): We probably want to create dedicated GET EditScreenMeta
        // REST endpoint. Abuse GET diff for now, as it retrieves links we need.
        DiffApi.diff(revision, path).base(base).webLinksOnly().get(group1.add(new AsyncCallback<DiffInfo>() {

            @Override
            public void onSuccess(DiffInfo diffInfo) {
                diffLinks = diffInfo.web_links();
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    }
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            renderLinks(editFileInfo, diffLinks);
            editFileInfo = null;
            diffLinks = null;
        }
    });
    group1.done();
}
#method_after
private void onLoad2() {
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    final CallbackGroup group3 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group3.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
            group2.done();
            group3.done();
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ChangeApi.detail(revision.getParentKey().get(), group1.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo c) {
            project.setInnerText(c.project());
            SafeHtml.setInnerHTML(filePath, Header.formatPath(path, null, null));
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    if (revision.get() == 0) {
        ChangeEditApi.getMeta(revision, path, group1.add(new AsyncCallback<EditFileInfo>() {

            @Override
            public void onSuccess(EditFileInfo editInfo) {
                editFileInfo = editInfo;
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    } else {
        // TODO(davido): We probably want to create dedicated GET EditScreenMeta
        // REST endpoint. Abuse GET diff for now, as it retrieves links we need.
        DiffApi.diff(revision, path).base(base).webLinksOnly().get(group1.add(new AsyncCallback<DiffInfo>() {

            @Override
            public void onSuccess(DiffInfo diffInfo) {
                diffLinks = diffInfo.webLinks();
            }

            @Override
            public void onFailure(Throwable e) {
            }
        }));
    }
    ChangeEditApi.get(revision, path, group2.add(new HttpCallback<NativeString>() {

        final AsyncCallback<Void> modeCallback = group3.addEmpty();

        @Override
        public void onSuccess(HttpResponse<NativeString> fc) {
            content = fc;
            if (prefs.syntaxHighlighting()) {
                injectMode(fc.getContentType(), modeCallback);
            } else {
                modeCallback.onSuccess(null);
            }
        }

        @Override
        public void onFailure(Throwable e) {
            // "Not Found" means it's a new file.
            if (RestApi.isNotFound(e)) {
                content = null;
                modeCallback.onSuccess(null);
            } else {
                GerritCallback.showFailure(e);
            }
        }
    }));
    group3.addListener(new ScreenLoadCallback<Void>(this) {

        @Override
        protected void preDisplay(Void result) {
            initEditor(content);
            renderLinks(editFileInfo, diffLinks);
            editFileInfo = null;
            diffLinks = null;
        }
    });
    group1.done();
}
#end_block

#method_before
private void renderLinks(EditFileInfo editInfo, JsArray<DiffWebLinkInfo> diffLinks) {
    renderLinksToDiff();
    if (editInfo != null) {
        renderLinks(Natives.asList(editInfo.web_links()));
    } else if (diffLinks != null) {
        renderLinks(Natives.asList(diffLinks));
    }
}
#method_after
private void renderLinks(EditFileInfo editInfo, JsArray<DiffWebLinkInfo> diffLinks) {
    renderLinksToDiff();
    if (editInfo != null) {
        renderLinks(Natives.asList(editInfo.webLinks()));
    } else if (diffLinks != null) {
        renderLinks(Natives.asList(diffLinks));
    }
}
#end_block

#method_before
public static PatchScreen.TopView getPatchScreenTopView() {
    if (patchScreen == null) {
        return null;
    }
    return patchScreen.getTopView();
}
#method_after
public static UnifiedPatchScreen.TopView getPatchScreenTopView() {
    if (patchScreen == null) {
        return null;
    }
    return patchScreen.getTopView();
}
#end_block

#method_before
public static void updateMenus(Screen view) {
    LinkMenuBar diffBar = menuBars.get(GerritTopMenu.DIFFERENCES.menuName);
    if (view instanceof PatchScreen) {
        patchScreen = (PatchScreen) view;
        menuLeft.setVisible(diffBar, true);
        menuLeft.selectTab(menuLeft.getWidgetIndex(diffBar));
    } else {
        if (patchScreen != null && menuLeft.getSelectedWidget() == diffBar) {
            menuLeft.selectTab(isSignedIn() ? 1 : 0);
        }
        patchScreen = null;
        menuLeft.setVisible(diffBar, false);
    }
}
#method_after
public static void updateMenus(Screen view) {
    LinkMenuBar diffBar = menuBars.get(GerritTopMenu.DIFFERENCES.menuName);
    if (view instanceof UnifiedPatchScreen) {
        patchScreen = (UnifiedPatchScreen) view;
        menuLeft.setVisible(diffBar, true);
        menuLeft.selectTab(menuLeft.getWidgetIndex(diffBar));
    } else {
        if (patchScreen != null && menuLeft.getSelectedWidget() == diffBar) {
            menuLeft.selectTab(isSignedIn() ? 1 : 0);
        }
        patchScreen = null;
        menuLeft.setVisible(diffBar, false);
    }
}
#end_block

#method_before
public static void setHeaderVisible(boolean visible) {
    topMenu.setVisible(visible);
    siteHeader.setVisible(visible && (myAccount != null ? myAccount.getGeneralPreferences().isShowSiteHeader() : true));
}
#method_after
public static void setHeaderVisible(boolean visible) {
    topMenu.setVisible(visible);
    siteHeader.setVisible(visible && getUserPreferences().showSiteHeader());
}
#end_block

#method_before
public static Account getUserAccount() {
    return myAccount;
}
#method_after
public static AccountInfo getUserAccount() {
    return myAccount;
}
#end_block

#method_before
public static boolean isSignedIn() {
    return getUserAccount() != null;
}
#method_after
public static boolean isSignedIn() {
    return xGerritAuth != null;
}
#end_block

#method_before
static void deleteSessionCookie() {
    myAccount = null;
    myAccountDiffPref = null;
    xGerritAuth = null;
    refreshMenuBar();
    // If the cookie was HttpOnly, this request to delete it will
    // most likely not be successful.  We can try anyway though.
    // 
    Cookies.removeCookie("GerritAccount");
}
#method_after
static void deleteSessionCookie() {
    myAccount = AccountInfo.create(0, null, null, null);
    myAccountDiffPref = null;
    myPrefs = AccountPreferencesInfo.createDefault();
    urlAliasMatcher.clearUserAliases();
    xGerritAuth = null;
    refreshMenuBar();
    // If the cookie was HttpOnly, this request to delete it will
    // most likely not be successful.  We can try anyway though.
    // 
    Cookies.removeCookie("GerritAccount");
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    getDocIndex(cbg.add(new GerritCallback<DocInfo>() {

        @Override
        public void onSuccess(DocInfo indexInfo) {
            hasDocumentation = indexInfo != null;
            docUrl = selfRedirect("/Documentation/");
        }
    }));
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
            urlAliasMatcher = new UrlAliasMatcher(info.urlAliases());
            String du = info.gerrit().docUrl();
            if (du != null && !du.isEmpty()) {
                hasDocumentation = true;
                docUrl = du;
            }
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
            }
            if (result.xGerritAuth != null) {
                xGerritAuth = result.xGerritAuth;
                // TODO: Support options on the GetDetail REST endpoint so that it can
                // also return the preferences. Then we can fetch everything with a
                // single request and we don't need the callback group anymore.
                CallbackGroup cbg = new CallbackGroup();
                AccountApi.self().view("detail").get(cbg.add(new GerritCallback<AccountInfo>() {

                    @Override
                    public void onSuccess(AccountInfo result) {
                        myAccount = result;
                    }
                }));
                AccountApi.self().view("preferences").get(cbg.addFinal(new GerritCallback<AccountPreferencesInfo>() {

                    @Override
                    public void onSuccess(AccountPreferencesInfo prefs) {
                        myPrefs = prefs;
                        onModuleLoad2(result);
                    }
                }));
            } else {
                myAccount = AccountInfo.create(0, null, null, null);
                myPrefs = AccountPreferencesInfo.createDefault();
                onModuleLoad2(result);
            }
        }
    }));
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    final String reportBugText = getConfig().getReportBugText();
    Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, getConfig().getReportBugUrl());
    a.setTarget("_blank");
    a.setStyleName("");
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(a);
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    RpcStatus.INSTANCE = new RpcStatus();
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar(false);
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    CallbackGroup cbg = new CallbackGroup();
    if (isSignedIn()) {
        AccountApi.self().view("preferences").get(cbg.add(createMyMenuBarCallback()));
    }
    PluginLoader.load(hpd.plugins, cbg.addFinal(new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    }));
}
#method_after
private void onModuleLoad2(HostPageData hpd) {
    RESOURCES.gwt_override().ensureInjected();
    RESOURCES.css().ensureInjected();
    topMenu = RootPanel.get("gerrit_topmenu");
    final RootPanel gStarting = RootPanel.get("gerrit_startinggerrit");
    final RootPanel gBody = RootPanel.get("gerrit_body");
    bottomMenu = RootPanel.get("gerrit_btmmenu");
    topMenu.setStyleName(RESOURCES.css().gerritTopMenu());
    gBody.setStyleName(RESOURCES.css().gerritBody());
    final Grid menuLine = new Grid(1, 3);
    menuLeft = new MorphingTabPanel();
    menuRight = new LinkMenuBar();
    searchPanel = new SearchPanel();
    menuLeft.setStyleName(RESOURCES.css().topmenuMenuLeft());
    menuLine.setStyleName(RESOURCES.css().topmenu());
    topMenu.add(menuLine);
    final FlowPanel menuRightPanel = new FlowPanel();
    menuRightPanel.setStyleName(RESOURCES.css().topmenuMenuRight());
    menuRightPanel.add(searchPanel);
    menuRightPanel.add(menuRight);
    menuLine.setWidget(0, 0, menuLeft);
    menuLine.setWidget(0, 1, new FlowPanel());
    menuLine.setWidget(0, 2, menuRightPanel);
    final CellFormatter fmt = menuLine.getCellFormatter();
    fmt.setStyleName(0, 0, RESOURCES.css().topmenuTDmenu());
    fmt.setStyleName(0, 1, RESOURCES.css().topmenuTDglue());
    fmt.setStyleName(0, 2, RESOURCES.css().topmenuTDmenu());
    siteHeader = RootPanel.get("gerrit_header");
    siteFooter = RootPanel.get("gerrit_footer");
    body = new ViewSite<Screen>() {

        @Override
        protected void onShowView(Screen view) {
            String token = view.getToken();
            History.newItem(token, false);
            dispatchHistoryHooks(token);
            if (view instanceof ChangeListScreen) {
                lastChangeListToken = token;
            }
            super.onShowView(view);
            view.onShowView();
            lastViewToken = token;
        }
    };
    gBody.add(body);
    JsonUtil.addRpcStartHandler(RpcStatus.INSTANCE);
    JsonUtil.addRpcCompleteHandler(RpcStatus.INSTANCE);
    JsonUtil.setDefaultXsrfManager(new XsrfManager() {

        @Override
        public String getToken(JsonDefTarget proxy) {
            return xGerritAuth;
        }

        @Override
        public void setToken(JsonDefTarget proxy, String token) {
        // Ignore the request, we always rely upon the cookie.
        }
    });
    gStarting.getElement().getParentElement().removeChild(gStarting.getElement());
    RootPanel.detachNow(gStarting);
    ApiGlue.init();
    applyUserPreferences();
    populateBottomMenu(bottomMenu, hpd);
    refreshMenuBar();
    History.addValueChangeHandler(new ValueChangeHandler<String>() {

        @Override
        public void onValueChange(ValueChangeEvent<String> event) {
            display(event.getValue());
        }
    });
    JumpKeys.register(body);
    saveDefaultTheme();
    if (hpd.messages != null) {
        new MessageOfTheDayBar(hpd.messages).show();
    }
    PluginLoader.load(hpd.plugins, hpd.pluginsLoadTimeout, new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            String token = History.getToken();
            if (token.isEmpty()) {
                token = isSignedIn() ? PageLinks.MINE : PageLinks.toChangeQuery("status:open");
            }
            display(token);
        }
    });
}
#end_block

#method_before
public static void refreshMenuBar() {
    refreshMenuBar(true);
}
#method_after
public static void refreshMenuBar() {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (myPrefs.my() != null) {
            myBar.clear();
            String url = null;
            List<TopMenuItem> myMenuItems = Natives.asList(myPrefs.my());
            if (!myMenuItems.isEmpty()) {
                if (myMenuItems.get(0).getUrl().startsWith("#")) {
                    url = myMenuItems.get(0).getUrl().substring(1);
                }
                for (TopMenuItem item : myMenuItems) {
                    addExtensionLink(myBar, item);
                }
            }
            defaultScreenToken = url;
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCHES));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (hasDocumentation) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
public static void applyUserPreferences() {
    if (myAccount != null) {
        final AccountGeneralPreferences p = myAccount.getGeneralPreferences();
        CopyableLabel.setFlashEnabled(p.isUseFlashClipboard());
        if (siteHeader != null) {
            siteHeader.setVisible(p.isShowSiteHeader());
        }
        if (siteFooter != null) {
            siteFooter.setVisible(p.isShowSiteHeader());
        }
        FormatUtil.setPreferences(myAccount.getGeneralPreferences());
    }
}
#method_after
private static void applyUserPreferences() {
    CopyableLabel.setFlashEnabled(myPrefs.useFlashClipboard());
    if (siteHeader != null) {
        siteHeader.setVisible(myPrefs.showSiteHeader());
    }
    if (siteFooter != null) {
        siteFooter.setVisible(myPrefs.showSiteHeader());
    }
    FormatUtil.setPreferences(myPrefs);
    urlAliasMatcher.updateUserAliases(myPrefs.urlAliases());
}
#end_block

#method_before
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccountInfo();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#method_after
private static void whoAmI(boolean canLogOut) {
    AccountInfo account = getUserAccount();
    final UserPopupPanel userPopup = new UserPopupPanel(account, canLogOut, true);
    final FlowPanel userSummaryPanel = new FlowPanel();
    class PopupHandler implements KeyDownHandler, ClickHandler {

        private void showHidePopup() {
            if (userPopup.isShowing() && userPopup.isVisible()) {
                userPopup.hide();
            } else {
                userPopup.showRelativeTo(userSummaryPanel);
            }
        }

        @Override
        public void onClick(ClickEvent event) {
            showHidePopup();
        }

        @Override
        public void onKeyDown(KeyDownEvent event) {
            if (event.getNativeKeyCode() == KeyCodes.KEY_ENTER) {
                showHidePopup();
                event.preventDefault();
            }
        }
    }
    final PopupHandler popupHandler = new PopupHandler();
    final InlineLabel l = new InlineLabel(FormatUtil.name(account));
    l.setStyleName(RESOURCES.css().menuBarUserName());
    final AvatarImage avatar = new AvatarImage(account, 26, false);
    avatar.setStyleName(RESOURCES.css().menuBarUserNameAvatar());
    userSummaryPanel.setStyleName(RESOURCES.css().menuBarUserNamePanel());
    userSummaryPanel.add(l);
    userSummaryPanel.add(avatar);
    // "BLACK DOWN-POINTING SMALL TRIANGLE"
    userSummaryPanel.add(new InlineLabel(" \u25be"));
    userPopup.addAutoHidePartner(userSummaryPanel.getElement());
    FocusPanel fp = new FocusPanel(userSummaryPanel);
    fp.setStyleName(RESOURCES.css().menuBarUserNameFocusPanel());
    fp.addKeyDownHandler(popupHandler);
    fp.addClickHandler(popupHandler);
    menuRight.add(fp);
}
#end_block

#method_before
private static void addDiffLink(final LinkMenuBar m, final String text, final PatchScreen.Type type) {
    m.addItem(new LinkMenuItem(text, "") {

        @Override
        public void go() {
            if (patchScreen != null) {
                patchScreen.setTopView(PatchScreen.TopView.MAIN);
                if (type == patchScreen.getPatchScreenType()) {
                    AnchorElement.as(getElement()).blur();
                } else {
                    new PatchLink("", type, patchScreen).go();
                }
            }
        }
    });
}
#method_after
private static void addDiffLink(final LinkMenuBar m, final String text, final UnifiedPatchScreen.TopView tv) {
    m.addItem(new LinkMenuItem(text, "") {

        @Override
        public void go() {
            if (patchScreen != null) {
                patchScreen.setTopView(tv);
            }
            AnchorElement.as(getElement()).blur();
        }
    });
}
#end_block

#method_before
private static void addDocLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, selfRedirect("/Documentation/" + href));
    atag.setTarget("_blank");
    m.add(atag);
}
#method_after
private static void addDocLink(final LinkMenuBar m, final String text, final String href) {
    final Anchor atag = anchor(text, docUrl + href);
    atag.setTarget("_blank");
    m.add(atag);
}
#end_block

#method_before
void set(EditPreferences prefs) {
    this.prefs = prefs;
    tabWidth.setIntValue(prefs.tabSize());
    lineLength.setIntValue(prefs.lineLength());
    lineWrapping.setValue(prefs.lineWrapping());
    syntaxHighlighting.setValue(prefs.syntaxHighlighting());
    showTabs.setValue(prefs.showTabs());
    showTrailingSpace.setValue(prefs.showTrailingSpace());
    lineNumbers.setValue(prefs.showLineNumbers());
    setKeyMap(prefs.keyMap());
    setTheme(prefs.theme());
}
#method_after
void set(EditPreferences prefs) {
    this.prefs = prefs;
    tabWidth.setIntValue(prefs.tabSize());
    lineLength.setIntValue(prefs.lineLength());
    topMenu.setValue(!prefs.hideTopMenu());
    syntaxHighlighting.setValue(prefs.syntaxHighlighting());
    showTabs.setValue(prefs.showTabs());
    whitespaceErrors.setValue(prefs.showWhitespaceErrors());
    lineNumbers.setValue(prefs.hideLineNumbers());
    setTheme(prefs.theme());
}
#end_block

#method_before
@UiHandler("showTrailingSpace")
void onshowTrailingSpace(ValueChangeEvent<Boolean> e) {
    prefs.showTrailingSpace(e.getValue());
    view.setShowTrailingSpace(prefs.showTrailingSpace());
}
#method_after
@UiHandler("whitespaceErrors")
void onshowTrailingSpace(ValueChangeEvent<Boolean> e) {
    prefs.showWhitespaceErrors(e.getValue());
    view.setShowWhitespaceErrors(prefs.showWhitespaceErrors());
}
#end_block

#method_before
@UiHandler("lineNumbers")
void onLineNumbers(ValueChangeEvent<Boolean> e) {
    prefs.showLineNumbers(e.getValue());
    view.setShowLineNumbers(prefs.showLineNumbers());
}
#method_after
@UiHandler("lineNumbers")
void onLineNumbers(ValueChangeEvent<Boolean> e) {
    prefs.hideLineNumbers(e.getValue());
    view.setShowLineNumbers(prefs.hideLineNumbers());
}
#end_block

#method_before
@UiHandler("theme")
void onTheme(@SuppressWarnings("unused") ChangeEvent e) {
    prefs.theme(Theme.valueOf(theme.getValue(theme.getSelectedIndex())));
    String t = prefs.theme().name().toLowerCase();
    view.getEditor().setOption("theme", t);
}
#method_after
@UiHandler("theme")
void onTheme(@SuppressWarnings("unused") ChangeEvent e) {
    final Theme newTheme = Theme.valueOf(theme.getValue(theme.getSelectedIndex()));
    prefs.theme(newTheme);
    ThemeLoader.loadTheme(newTheme, new GerritCallback<Void>() {

        @Override
        public void onSuccess(Void result) {
            view.getEditor().operation(new Runnable() {

                @Override
                public void run() {
                    String t = newTheme.name().toLowerCase();
                    view.getEditor().setOption("theme", t);
                }
            });
        }
    });
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setHeaderVisible(false);
    setWindowTitle(FileInfo.getFileName(path));
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    final CallbackGroup cmGroup = new CallbackGroup();
    CodeMirror.initLibrary(cmGroup.add(CallbackGroup.<Void>emptyCallback()));
    CallbackGroup group = new CallbackGroup();
    final AsyncCallback<Void> modeInjectorCb = group.add(CallbackGroup.<Void>emptyCallback());
    EditPreferencesInfo current = Gerrit.getEditPreferences();
    if (current == null) {
        AccountApi.getEditPreferences(cmGroup.addFinal(new GerritCallback<EditPreferences>() {

            @Override
            public void onSuccess(EditPreferences r) {
                prefs = r;
                EditPreferencesInfo global = new EditPreferencesInfo();
                r.copyTo(global);
                Gerrit.setEditPreferences(global);
                initContentType(modeInjectorCb);
            }
        }));
    } else {
        prefs = EditPreferences.create(current);
        cmGroup.addFinal(CallbackGroup.<Void>emptyCallback());
        initContentType(modeInjectorCb);
    }
    ChangeFileApi.getContentOrMessage(revision, path, group.addFinal(new ScreenLoadCallback<String>(this) {

        @Override
        protected void preDisplay(String content) {
            display(content);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    EditPreferencesInfo current = Gerrit.getEditPreferences();
    if (current == null) {
        AccountApi.getEditPreferences(new GerritCallback<EditPreferences>() {

            @Override
            public void onSuccess(EditPreferences r) {
                prefs = r;
                EditPreferencesInfo global = new EditPreferencesInfo();
                r.copyTo(global);
                Gerrit.setEditPreferences(global);
                onLoad2();
            }
        });
    } else {
        prefs = EditPreferences.create(current);
        onLoad2();
    }
}
#end_block

#method_before
@Override
public void onShowView() {
    super.onShowView();
    int rest = Gerrit.getHeaderFooterHeight() + // Estimate
    30;
    cm.setHeight(Window.getClientHeight() - rest);
    cm.refresh();
    cm.focus();
    setLineLength(prefs.lineLength());
}
#method_after
@Override
public void onShowView() {
    super.onShowView();
    Window.enableScrolling(false);
    JumpKeys.enable(false);
    if (prefs.hideTopMenu()) {
        Gerrit.setHeaderVisible(false);
    }
    resizeHandler = Window.addResizeHandler(new ResizeHandler() {

        @Override
        public void onResize(ResizeEvent event) {
            cm.adjustHeight(header.getOffsetHeight());
        }
    });
    closeHandler = Window.addWindowClosingHandler(new ClosingHandler() {

        @Override
        public void onWindowClosing(ClosingEvent event) {
            if (!cm.isClean(generation)) {
                event.setMessage(EditConstants.I.closeUnsavedChanges());
            }
        }
    });
    generation = cm.changeGeneration(true);
    setClean(true);
    cm.on(new ChangesHandler() {

        @Override
        public void handle(CodeMirror cm) {
            setClean(cm.isClean(generation));
        }
    });
    cm.adjustHeight(header.getOffsetHeight());
    cm.on("cursorActivity", updateCursorPosition());
    setShowTabs(prefs.showTabs());
    setLineLength(prefs.lineLength());
    cm.refresh();
    cm.focus();
    if (startLine > 0) {
        cm.scrollToLine(startLine);
    }
    updateActiveLine();
    editPrefsAction = new EditPreferencesAction(this, prefs);
}
#end_block

#method_before
@UiHandler("save")
void onSave(@SuppressWarnings("unused") ClickEvent e) {
    ChangeFileApi.putContentOrMessage(revision, path, cm.getValue(), new GerritCallback<VoidResult>() {

        @Override
        public void onSuccess(VoidResult result) {
            Gerrit.display(PageLinks.toChangeInEditMode(revision.getParentKey()));
        }
    });
}
#method_after
@UiHandler("save")
void onSave(@SuppressWarnings("unused") ClickEvent e) {
    save().run();
}
#end_block

#method_before
void setLineLength(int columns) {
    double w = columns * getCharWidthPx();
    columnMargin.getStyle().setMarginLeft(w, Style.Unit.PX);
}
#method_after
void setLineLength(int length) {
    cm.extras().lineLength(Patch.COMMIT_MSG.equals(path) ? 72 : length);
}
#end_block

#method_before
void setShowLineNumbers(boolean b) {
    cm.setOption("lineNumbers", b);
    if (b) {
        panel.addStyleName(style.showLineNumbers());
    } else {
        panel.removeStyleName(style.showLineNumbers());
    }
}
#method_after
void setShowLineNumbers(boolean show) {
    cm.setOption("lineNumbers", show);
}
#end_block

#method_before
void setShowTabs(boolean b) {
    if (b) {
        panel.addStyleName(style.showTabs());
    } else {
        panel.removeStyleName(style.showTabs());
    }
}
#method_after
void setShowTabs(boolean show) {
    cm.extras().showTabs(show);
}
#end_block

#method_before
void setSyntaxHighlighting(boolean b) {
    if (b) {
        final AsyncCallback<Void> cb = new AsyncCallback<Void>() {

            @Override
            public void onSuccess(Void result) {
                if (prefs.syntaxHighlighting()) {
                    cm.setOption("mode", type);
                }
            }

            @Override
            public void onFailure(Throwable caught) {
                prefs.syntaxHighlighting(false);
            }
        };
        // When content type retrieval was skipped, we have to do it now
        if (type == null) {
            ChangeFileApi.getContentType(revision, path, new GerritCallback<String>() {

                @Override
                public void onSuccess(String result) {
                    type = result;
                    injectMode(result, cb);
                }
            });
        } else {
            injectMode(type, cb);
        }
    } else {
        cm.setOption("mode", (String) null);
    }
}
#method_after
void setSyntaxHighlighting(boolean b) {
    ModeInfo modeInfo = ModeInfo.findMode(content.getContentType(), path);
    final String mode = modeInfo != null ? modeInfo.mode() : null;
    if (b && mode != null && !mode.isEmpty()) {
        injectMode(mode, new AsyncCallback<Void>() {

            @Override
            public void onSuccess(Void result) {
                cm.setOption("mode", mode);
            }

            @Override
            public void onFailure(Throwable caught) {
                prefs.syntaxHighlighting(false);
            }
        });
    } else {
        cm.setOption("mode", (String) null);
    }
}
#end_block

#method_before
public static EditPreferences create(EditPreferencesInfo in) {
    EditPreferences p = createObject().cast();
    p.tabSize(in.tabSize);
    p.lineLength(in.lineLength);
    p.lineWrapping(in.lineWrapping);
    p.showTabs(in.showTabs);
    p.showTrailingSpace(in.showTrailingSpace);
    p.syntaxHighlighting(in.syntaxHighlighting);
    p.hideLineNumbers(in.hideLineNumbers);
    p.keyMap(in.keyMap);
    p.theme(in.theme);
    return p;
}
#method_after
public static EditPreferences create(EditPreferencesInfo in) {
    EditPreferences p = createObject().cast();
    p.tabSize(in.tabSize);
    p.lineLength(in.lineLength);
    p.hideTopMenu(in.hideTopMenu);
    p.showTabs(in.showTabs);
    p.showWhitespaceErrors(in.showWhitespaceErrors);
    p.syntaxHighlighting(in.syntaxHighlighting);
    p.hideLineNumbers(in.hideLineNumbers);
    p.theme(in.theme);
    return p;
}
#end_block

#method_before
public final void copyTo(EditPreferencesInfo p) {
    p.tabSize = tabSize();
    p.lineLength = lineLength();
    p.lineWrapping = lineWrapping();
    p.showTabs = showTabs();
    p.showTrailingSpace = showTrailingSpace();
    p.syntaxHighlighting = syntaxHighlighting();
    p.hideLineNumbers = hideLineNumbers();
    p.keyMap = keyMap();
    p.theme = theme();
}
#method_after
public final void copyTo(EditPreferencesInfo p) {
    p.tabSize = tabSize();
    p.lineLength = lineLength();
    p.hideTopMenu = hideTopMenu();
    p.showTabs = showTabs();
    p.showWhitespaceErrors = showWhitespaceErrors();
    p.syntaxHighlighting = syntaxHighlighting();
    p.hideLineNumbers = hideLineNumbers();
    p.theme = theme();
}
#end_block

#method_before
static ParameterizedString paramString(Config c, String n, String d) throws IllegalArgumentException {
    String expression = optdef(c, n, d);
    if (expression == null) {
        return null;
    } else if (expression.contains("${")) {
        return new ParameterizedString(expression);
    } else {
        return new ParameterizedString("${" + expression + "}");
    }
}
#method_after
static ParameterizedString paramString(Config c, String n, String d) {
    String expression = optdef(c, n, d);
    if (expression == null) {
        return null;
    } else if (expression.contains("${")) {
        return new ParameterizedString(expression);
    } else {
        return new ParameterizedString("${" + expression + "}");
    }
}
#end_block

#method_before
private static void checkBackendCompliance(String configOption, String suppliedValue, boolean disabledByBackend) {
    if (disabledByBackend && !Strings.isNullOrEmpty(suppliedValue)) {
        String msg = String.format("LDAP backend doesn't support: ldap.%s", configOption);
        log.error(msg);
        throw new IllegalStateException(msg);
    }
}
#method_after
private static void checkBackendCompliance(String configOption, String suppliedValue, boolean disabledByBackend) {
    if (disabledByBackend && !Strings.isNullOrEmpty(suppliedValue)) {
        String msg = String.format("LDAP backend doesn't support: ldap.%s", configOption);
        log.error(msg);
        throw new IllegalArgumentException(msg);
    }
}
#end_block

#method_before
@Override
public Optional<Account.Id> load(String username) throws Exception {
    final ReviewDb db = schema.open();
    try {
        final AccountExternalId extId = db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_GERRIT, username));
        if (extId != null) {
            return Optional.of(extId.getAccountId());
        }
        return Optional.absent();
    } finally {
        db.close();
    }
}
#method_after
@Override
public Optional<Account.Id> load(String username) throws Exception {
    try (ReviewDb db = schema.open()) {
        final AccountExternalId extId = db.accountExternalIds().get(new AccountExternalId.Key(SCHEME_GERRIT, username));
        if (extId != null) {
            return Optional.of(extId.getAccountId());
        }
        return Optional.absent();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    DynamicSet.bind(binder(), BranchWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), FileWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(GitilesWeblinks.class);
    bind(GitilesAccess.Factory.class).to(GerritGitilesAccess.Factory.class);
    bind(new TypeLiteral<RepositoryResolver<HttpServletRequest>>() {
    }).to(Resolver.class);
    listener().to(Lifecycle.class);
}
#method_after
@Override
protected void configure() {
    DynamicSet.bind(binder(), BranchWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), FileHistoryWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), FileWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), PatchSetWebLink.class).to(GitilesWeblinks.class);
    DynamicSet.bind(binder(), ProjectWebLink.class).to(GitilesWeblinks.class);
    bind(GitilesAccess.Factory.class).to(GerritGitilesAccess.Factory.class);
    bind(new TypeLiteral<RepositoryResolver<HttpServletRequest>>() {
    }).to(Resolver.class);
    listener().to(Lifecycle.class);
}
#end_block

#method_before
private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen) {
    if (trusted == null || store == null) {
        // Trust checking not configured.
        return CheckResult.OK;
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return new CheckResult("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.OK;
    } else if (depth >= maxTrustDepth) {
        return new CheckResult("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            CheckResult signerResult = checkTrustSubpacket(sig, depth);
            if (signerResult.isOk()) {
                signerResult = check(signer, store, depth + 1, false, seen);
                if (signerResult.isOk()) {
                    return CheckResult.OK;
                }
            }
            signerResults.add(new CheckResult("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        if (signerResult.isOk()) {
            return CheckResult.OK;
        }
        problems.addAll(signerResult.getProblems());
    }
    return new CheckResult(problems);
}
#method_after
private CheckResult checkWebOfTrust(PGPPublicKey key, PublicKeyStore store, int depth, Set<Fingerprint> seen) {
    if (trusted == null || store == null) {
        // Trust checking not configured.
        return CheckResult.OK;
    }
    Fingerprint fp = new Fingerprint(key.getFingerprint());
    if (seen.contains(fp)) {
        return new CheckResult("Key is trusted in a cycle");
    }
    seen.add(fp);
    Fingerprint trustedFp = trusted.get(key.getKeyID());
    if (trustedFp != null && trustedFp.equals(fp)) {
        // Directly trusted.
        return CheckResult.OK;
    } else if (depth >= maxTrustDepth) {
        return new CheckResult("No path of depth <= " + maxTrustDepth + " to a trusted key");
    }
    List<CheckResult> signerResults = new ArrayList<>();
    @SuppressWarnings("unchecked")
    Iterator<String> userIds = key.getUserIDs();
    while (userIds.hasNext()) {
        String userId = userIds.next();
        @SuppressWarnings("unchecked")
        Iterator<PGPSignature> sigs = key.getSignaturesForID(userId);
        while (sigs.hasNext()) {
            PGPSignature sig = sigs.next();
            // TODO(dborowitz): Handle CERTIFICATION_REVOCATION.
            if (sig.getSignatureType() != PGPSignature.DEFAULT_CERTIFICATION && sig.getSignatureType() != PGPSignature.POSITIVE_CERTIFICATION) {
                // Not a certification.
                continue;
            }
            PGPPublicKey signer = getSigner(store, sig, userId, key, signerResults);
            // TODO(dborowitz): Require self certification.
            if (signer == null || Arrays.equals(signer.getFingerprint(), key.getFingerprint())) {
                continue;
            }
            CheckResult signerResult = checkTrustSubpacket(sig, depth);
            if (signerResult.isOk()) {
                signerResult = check(signer, store, depth + 1, false, seen);
                if (signerResult.isOk()) {
                    return CheckResult.OK;
                }
            }
            signerResults.add(new CheckResult("Certification by " + keyToString(signer) + " is valid, but key is not trusted"));
        }
    }
    List<String> problems = new ArrayList<>();
    problems.add("No path to a trusted key");
    for (CheckResult signerResult : signerResults) {
        problems.addAll(signerResult.getProblems());
    }
    return new CheckResult(problems);
}
#end_block

#method_before
private void storeKeys(AccountResource rsrc, List<PGPPublicKeyRing> keyRings, Set<Fingerprint> toRemove) throws BadRequestException, ResourceConflictException, PGPException, IOException {
    try (PublicKeyStore store = storeProvider.get()) {
        for (PGPPublicKeyRing keyRing : keyRings) {
            PGPPublicKey key = keyRing.getPublicKey();
            // Don't check web of trust; admins can fill in certifications later.
            CheckResult result = checker.check(key);
            if (!result.isOk()) {
                throw new BadRequestException(String.format("Problems with public key %s:\n%s", keyToString(key), Joiner.on('\n').join(result.getProblems())));
            }
            store.add(keyRing);
        }
        for (Fingerprint fp : toRemove) {
            store.remove(fp.get());
        }
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NEW:
            case FAST_FORWARD:
            case FORCED:
            case NO_CHANGE:
                break;
            default:
                // TODO(dborowitz): Backoff and retry on LOCK_FAILURE.
                throw new ResourceConflictException("Failed to save public keys: " + saveResult);
        }
    }
}
#method_after
private void storeKeys(AccountResource rsrc, List<PGPPublicKeyRing> keyRings, Set<Fingerprint> toRemove) throws BadRequestException, ResourceConflictException, PGPException, IOException {
    try (PublicKeyStore store = storeProvider.get()) {
        List<String> addedKeys = new ArrayList<>();
        for (PGPPublicKeyRing keyRing : keyRings) {
            PGPPublicKey key = keyRing.getPublicKey();
            // Don't check web of trust; admins can fill in certifications later.
            CheckResult result = checker.check(key);
            if (!result.isOk()) {
                throw new BadRequestException(String.format("Problems with public key %s:\n%s", keyToString(key), Joiner.on('\n').join(result.getProblems())));
            }
            addedKeys.add(PublicKeyStore.keyToString(key));
            store.add(keyRing);
        }
        for (Fingerprint fp : toRemove) {
            store.remove(fp.get());
        }
        CommitBuilder cb = new CommitBuilder();
        PersonIdent committer = serverIdent.get();
        cb.setAuthor(rsrc.getUser().newCommitterIdent(committer.getWhen(), committer.getTimeZone()));
        cb.setCommitter(committer);
        RefUpdate.Result saveResult = store.save(cb);
        switch(saveResult) {
            case NEW:
            case FAST_FORWARD:
            case FORCED:
                try {
                    addKeyFactory.create(rsrc.getUser(), addedKeys).send();
                } catch (EmailException e) {
                    log.error("Cannot send GPG key added message to " + rsrc.getUser().getAccount().getPreferredEmail(), e);
                }
                break;
            case NO_CHANGE:
                break;
            default:
                // TODO(dborowitz): Backoff and retry on LOCK_FAILURE.
                throw new ResourceConflictException("Failed to save public keys: " + saveResult);
        }
    }
}
#end_block

#method_before
private void deleteFromNotes(ObjectInserter ins, Fingerprint fp) throws PGPException, IOException {
    long keyId = fp.getId();
    PGPPublicKeyRingCollection existing = get(keyId);
    List<PGPPublicKeyRing> toWrite = new ArrayList<>(existing.size());
    for (PGPPublicKeyRing kr : existing) {
        if (!fp.equalsBytes(kr.getPublicKey().getFingerprint())) {
            toWrite.add(kr);
        }
    }
    if (toWrite.size() == existing.size()) {
        return;
    } else if (toWrite.size() > 0) {
        notes.set(keyObjectId(keyId), ins.insert(OBJ_BLOB, keysToArmored(toWrite)));
    } else {
        notes.remove(keyObjectId(keyId));
    }
}
#method_after
private void deleteFromNotes(ObjectInserter ins, Fingerprint fp) throws PGPException, IOException {
    long keyId = fp.getId();
    PGPPublicKeyRingCollection existing = get(keyId);
    List<PGPPublicKeyRing> toWrite = new ArrayList<>(existing.size());
    for (PGPPublicKeyRing kr : existing) {
        if (!fp.equalsBytes(kr.getPublicKey().getFingerprint())) {
            toWrite.add(kr);
        }
    }
    if (toWrite.size() == existing.size()) {
        return;
    } else if (!toWrite.isEmpty()) {
        notes.set(keyObjectId(keyId), ins.insert(OBJ_BLOB, keysToArmored(toWrite)));
    } else {
        notes.remove(keyObjectId(keyId));
    }
}
#end_block

#method_before
private void checkSignature(PGPSignature sig, PushCertificate cert, PublicKeyStore store, List<String> problems) throws PGPException, IOException {
    PGPPublicKeyRingCollection keys = store.get(sig.getKeyID());
    if (!keys.getKeyRings().hasNext()) {
        problems.add("No public keys found for key ID " + keyIdToString(sig.getKeyID()));
        return;
    }
    PGPPublicKey signer = PublicKeyStore.getSigner(keys, sig, Constants.encode(cert.toText()));
    if (signer == null) {
        problems.add("Signature by " + keyIdToString(sig.getKeyID()) + " is not valid");
        return;
    }
    CheckResult result = publicKeyChecker.check(signer, store);
    if (!result.isOk()) {
        StringBuilder err = new StringBuilder("Invalid public key ").append(keyToString(signer)).append(":");
        for (int i = 0; i < result.getProblems().size(); i++) {
            err.append('\n').append("  ").append(result.getProblems().get(i));
        }
        problems.add(err.toString());
    }
}
#method_after
private void checkSignature(PGPSignature sig, PushCertificate cert, PublicKeyStore store, List<String> problems) throws PGPException, IOException {
    PGPPublicKeyRingCollection keys = store.get(sig.getKeyID());
    if (!keys.getKeyRings().hasNext()) {
        problems.add("No public keys found for key ID " + keyIdToString(sig.getKeyID()));
        return;
    }
    PGPPublicKey signer = PublicKeyStore.getSigner(keys, sig, Constants.encode(cert.toText()));
    if (signer == null) {
        problems.add("Signature by " + keyIdToString(sig.getKeyID()) + " is not valid");
        return;
    }
    CheckResult result = publicKeyChecker.check(signer, store);
    if (!result.isOk()) {
        StringBuilder err = new StringBuilder("Invalid public key ").append(keyToString(signer)).append(":");
        for (String problem : result.getProblems()) {
            err.append("\n  ").append(problem);
        }
        problems.add(err.toString());
    }
}
#end_block

#method_before
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    ResultSet<AccountSshKey> byAccountLast = dbProvider.get().accountSshKeys().byAccountLast(user.getAccountId());
    AccountSshKey last = Iterables.getOnlyElement(byAccountLast, null);
    int max = last == null ? 0 : last.getKey().get();
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
        dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
        try {
            addSshKeyFactory.create(user, sshKey).send();
        } catch (EmailException | RuntimeException e) {
            log.error("Cannot send SSH key added message to " + email, e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
public Response<SshKeyInfo> apply(IdentifiedUser user, Input input) throws BadRequestException, OrmException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.raw == null) {
        throw new BadRequestException("SSH public key missing");
    }
    ResultSet<AccountSshKey> byAccountLast = dbProvider.get().accountSshKeys().byAccountLast(user.getAccountId());
    AccountSshKey last = Iterables.getOnlyElement(byAccountLast, null);
    int max = last == null ? 0 : last.getKey().get();
    final RawInput rawKey = input.raw;
    String sshPublicKey = new ByteSource() {

        @Override
        public InputStream openStream() throws IOException {
            return rawKey.getInputStream();
        }
    }.asCharSource(UTF_8).read();
    try {
        AccountSshKey sshKey = sshKeyCache.create(new AccountSshKey.Id(user.getAccountId(), max + 1), sshPublicKey);
        dbProvider.get().accountSshKeys().insert(Collections.singleton(sshKey));
        try {
            addKeyFactory.create(user, sshKey).send();
        } catch (EmailException e) {
            log.error("Cannot send SSH key added message to " + user.getAccount().getPreferredEmail(), e);
        }
        sshKeyCache.evict(user.getUserName());
        return Response.<SshKeyInfo>created(new SshKeyInfo(sshKey));
    } catch (InvalidSshKeyException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(new SignedPushModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddSshKeySender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(AddKeySender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(ChangeJson.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(EmailMerge.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitwebConfig.class);
    bind(GcConfig.class);
    bind(ChangeCleanupConfig.class);
    bind(ApprovalsUtil.class);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), CloneCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), FileHistoryWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Test
public void testParseSimple() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseSimple() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParseWHeader() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, HEADER + F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseWHeader() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, HEADER + F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParseWComments() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, C1 + F_SIMPLE + C2, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParseWComments() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, C1 + F_SIMPLE + C2, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParsePaddedFronts() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_F, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParsePaddedFronts() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_F, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParsePaddedEnds() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_E, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
}
#method_after
@Test
public void testParsePaddedEnds() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_PAD_E, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
}
#end_block

#method_before
@Test
public void testParse2Labels() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
    dl.parseLabel(LABEL2, L_COMPLEX, null);
    branches = dl.getDestinations(LABEL);
    assertThat(D_SIMPLE).containsExactlyElementsIn(branches);
    branches = dl.getDestinations(LABEL2);
    assertThat(branches).contains(B_COMPLEX);
}
#method_after
@Test
public void testParse2Labels() throws Exception {
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    Set<Branch.NameKey> branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
    dl.parseLabel(LABEL2, L_COMPLEX, null);
    branches = dl.getDestinations(LABEL);
    assertThat(branches).containsExactlyElementsIn(D_SIMPLE);
    branches = dl.getDestinations(LABEL2);
    assertThat(branches).contains(B_COMPLEX);
}
#end_block

#method_before
@Test
public void testAsText() throws Exception {
    String text = HEADER_PROPER + "#\n" + F_PROPER;
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    String asText = dl.asText(LABEL);
    assertThat(text).isEqualTo(asText);
    dl.parseLabel(LABEL2, asText, null);
    String asText2 = dl.asText(LABEL2);
    assertThat(text).isEqualTo(asText2);
}
#method_after
@Test
public void testAsText() throws Exception {
    String text = HEADER_PROPER + "#\n" + F_PROPER;
    DestinationList dl = new DestinationList();
    dl.parseLabel(LABEL, F_SIMPLE, null);
    String asText = dl.asText(LABEL);
    assertThat(text).isEqualTo(asText);
    dl.parseLabel(LABEL2, asText, null);
    assertThat(text).isEqualTo(dl.asText(LABEL2));
}
#end_block

#method_before
@Operator
public Predicate<ChangeData> destination(String name) throws QueryParseException, OrmException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountDestinations d = VersionedAccountDestinations.forUser(self());
        d.load(git);
        Set<Branch.NameKey> destinations = d.getDestinationList().getDestinations(name);
        if (destinations != null) {
            return new DestinationPredicate(destinations, name);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named destination (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named destination: " + name, e);
    }
    throw new QueryParseException("Unknown named destination: " + name);
}
#method_after
@Operator
public Predicate<ChangeData> destination(String name) throws QueryParseException {
    AllUsersName allUsers = args.allUsersName.get();
    try (Repository git = args.repoManager.openRepository(allUsers)) {
        VersionedAccountDestinations d = VersionedAccountDestinations.forUser(self());
        d.load(git);
        Set<Branch.NameKey> destinations = d.getDestinationList().getDestinations(name);
        if (destinations != null) {
            return new DestinationPredicate(destinations, name);
        }
    } catch (RepositoryNotFoundException e) {
        throw new QueryParseException("Unknown named destination (no " + allUsers.get() + " repo): " + name, e);
    } catch (IOException | ConfigInvalidException e) {
        throw new QueryParseException("Error parsing named destination: " + name, e);
    }
    throw new QueryParseException("Unknown named destination: " + name);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#method_after
@Override
protected Predicate<ChangeData> defaultField(String query) throws QueryParseException {
    if (query.startsWith("refs/")) {
        return ref(query);
    } else if (DEF_CHANGE.matcher(query).matches()) {
        try {
            return change(query);
        } catch (QueryParseException e) {
        // Skip.
        }
    }
    List<Predicate<ChangeData>> predicates = Lists.newArrayListWithCapacity(9);
    try {
        predicates.add(commit(query));
    } catch (IllegalArgumentException e) {
    // Skip.
    }
    try {
        predicates.add(owner(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    try {
        predicates.add(reviewer(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(file(query));
    try {
        predicates.add(label(query));
    } catch (OrmException | QueryParseException e) {
    // Skip.
    }
    predicates.add(message(query));
    predicates.add(comment(query));
    predicates.add(projects(query));
    predicates.add(ref(query));
    predicates.add(branch(query));
    predicates.add(topic(query));
    return Predicate.or(predicates);
}
#end_block

#method_before
public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException {
    destinations.put(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors)));
}
#method_after
public void parseLabel(String label, String text, ValidationError.Sink errors) throws IOException {
    destinations.replaceValues(label, toSet(parse(text, DIR_NAME + label, TRIM, null, errors)));
}
#end_block

#method_before
public BinaryResult getContent(ProjectState project, ObjectId revstr, String path) throws ResourceNotFoundException, IOException {
    try (Repository repo = openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(revstr);
        ObjectReader reader = rw.getObjectReader();
        TreeWalk tw = TreeWalk.forPath(reader, path, commit.getTree());
        if (tw == null) {
            throw new ResourceNotFoundException();
        }
        org.eclipse.jgit.lib.FileMode mode = tw.getFileMode(0);
        ObjectId id = tw.getObjectId(0);
        if (mode == org.eclipse.jgit.lib.FileMode.GITLINK) {
            return BinaryResult.create(id.name()).setContentType(X_GIT_GITLINK).base64();
        }
        final ObjectLoader obj = repo.open(id, OBJ_BLOB);
        byte[] raw;
        try {
            raw = obj.getCachedBytes(MAX_SIZE);
        } catch (LargeObjectException e) {
            raw = null;
        }
        String type;
        if (mode == org.eclipse.jgit.lib.FileMode.SYMLINK) {
            type = X_GIT_SYMLINK;
        } else {
            type = registry.getMimeType(path, raw).toString();
            type = resolveContentType(project, path, FileMode.FILE, type);
        }
        return asBinaryResult(raw, obj).setContentType(type).base64();
    }
}
#method_after
public BinaryResult getContent(ProjectState project, ObjectId revstr, String path) throws ResourceNotFoundException, IOException {
    try (Repository repo = openRepository(project);
        RevWalk rw = new RevWalk(repo)) {
        RevCommit commit = rw.parseCommit(revstr);
        ObjectReader reader = rw.getObjectReader();
        TreeWalk tw = TreeWalk.forPath(reader, path, commit.getTree());
        if (tw == null) {
            throw new ResourceNotFoundException();
        }
        org.eclipse.jgit.lib.FileMode mode = tw.getFileMode(0);
        ObjectId id = tw.getObjectId(0);
        if (mode == org.eclipse.jgit.lib.FileMode.GITLINK) {
            return BinaryResult.create(id.name()).setContentType(X_GIT_GITLINK).base64();
        }
        ObjectLoader obj = repo.open(id, OBJ_BLOB);
        byte[] raw;
        try {
            raw = obj.getCachedBytes(MAX_SIZE);
        } catch (LargeObjectException e) {
            raw = null;
        }
        String type;
        if (mode == org.eclipse.jgit.lib.FileMode.SYMLINK) {
            type = X_GIT_SYMLINK;
        } else {
            type = registry.getMimeType(path, raw).toString();
            type = resolveContentType(project, path, FileMode.FILE, type);
        }
        return asBinaryResult(raw, obj).setContentType(type).base64();
    }
}
#end_block

#method_before
private BinaryResult wrapBlob(ProjectState project, String path, final ObjectLoader obj, byte[] raw, MimeType contentType, @Nullable String side) {
    BinaryResult result;
    if (raw != null) {
        result = BinaryResult.create(raw);
    } else {
        result = new BinaryResult() {

            @Override
            public void writeTo(OutputStream os) throws IOException {
                obj.copyTo(os);
            }
        };
        result.setContentLength(obj.getSize());
    }
    result.setContentType(resolveContentType(project, path, FileMode.FILE, contentType.toString())).setAttachmentName(safeFileName(path, side));
    return result;
}
#method_after
private BinaryResult wrapBlob(ProjectState project, String path, final ObjectLoader obj, byte[] raw, MimeType contentType, @Nullable String suffix) {
    return asBinaryResult(raw, obj).setContentType(contentType.toString()).setAttachmentName(safeFileName(path, suffix));
}
#end_block

#method_before
private BinaryResult zipBlob(final String path, final ObjectLoader obj, final String commitName, final long when, @Nullable final String side) {
    BinaryResult result = new BinaryResult() {

        @Override
        public void writeTo(OutputStream os) throws IOException {
            ZipOutputStream zipOut = new ZipOutputStream(os);
            String suffix = side != null ? side + '-' + randSuffix() : randSuffix();
            ZipEntry e = new ZipEntry(safeFileName(path, suffix));
            e.setComment(commitName + ":" + path);
            e.setSize(obj.getSize());
            e.setTime(when);
            zipOut.putNextEntry(e);
            obj.copyTo(zipOut);
            zipOut.closeEntry();
            zipOut.close();
        }
    };
    result.setContentType(ZIP.toString()).setAttachmentName(safeFileName(path, side) + ".zip").setContentLength(// it is not practical to determine this
    -1).disableGzip();
    return result;
}
#method_after
private BinaryResult zipBlob(final String path, final ObjectLoader obj, RevCommit commit, @Nullable final String suffix) {
    final String commitName = commit.getName();
    final long when = commit.getCommitTime() * 1000L;
    return new BinaryResult() {

        @Override
        public void writeTo(OutputStream os) throws IOException {
            try (ZipOutputStream zipOut = new ZipOutputStream(os)) {
                String decoration = randSuffix();
                if (!Strings.isNullOrEmpty(suffix)) {
                    decoration = suffix + '-' + decoration;
                }
                ZipEntry e = new ZipEntry(safeFileName(path, decoration));
                e.setComment(commitName + ":" + path);
                e.setSize(obj.getSize());
                e.setTime(when);
                zipOut.putNextEntry(e);
                obj.copyTo(zipOut);
                zipOut.closeEntry();
            }
        }
    }.setContentType(ZIP_TYPE).setAttachmentName(safeFileName(path, suffix) + ".zip").disableGzip();
}
#end_block

#method_before
private static String safeFileName(String fileName, @Nullable String suffix) {
    // Convert a file path (e.g. "src/Init.c") to a safe file name with
    // no meta-characters that might be unsafe on any given platform.
    // 
    final int slash = fileName.lastIndexOf('/');
    fileName = fileName.substring(slash + 1);
    if (slash >= 0) {
    }
    final StringBuilder r = new StringBuilder(fileName.length());
    for (int i = 0; i < fileName.length(); i++) {
        final char c = fileName.charAt(i);
        if (c == '_' || c == '-' || c == '.' || c == '@') {
            r.append(c);
        } else if ('0' <= c && c <= '9') {
            r.append(c);
        } else if ('A' <= c && c <= 'Z') {
            r.append(c);
        } else if ('a' <= c && c <= 'z') {
            r.append(c);
        } else if (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
            r.append('-');
        } else {
            r.append('_');
        }
    }
    fileName = r.toString();
    final int ext = fileName.lastIndexOf('.');
    if (suffix == null) {
        return fileName;
    } else if (ext <= 0) {
        return fileName + "_" + suffix;
    } else {
        return fileName.substring(0, ext) + "_" + suffix + fileName.substring(ext);
    }
}
#method_after
private static String safeFileName(String fileName, @Nullable String suffix) {
    // Convert a file path (e.g. "src/Init.c") to a safe file name with
    // no meta-characters that might be unsafe on any given platform.
    // 
    int slash = fileName.lastIndexOf('/');
    if (slash >= 0) {
        fileName = fileName.substring(slash + 1);
    }
    StringBuilder r = new StringBuilder(fileName.length());
    for (int i = 0; i < fileName.length(); i++) {
        final char c = fileName.charAt(i);
        if (c == '_' || c == '-' || c == '.' || c == '@') {
            r.append(c);
        } else if ('0' <= c && c <= '9') {
            r.append(c);
        } else if ('A' <= c && c <= 'Z') {
            r.append(c);
        } else if ('a' <= c && c <= 'z') {
            r.append(c);
        } else if (c == ' ' || c == '\n' || c == '\r' || c == '\t') {
            r.append('-');
        } else {
            r.append('_');
        }
    }
    fileName = r.toString();
    int ext = fileName.lastIndexOf('.');
    if (suffix == null) {
        return fileName;
    } else if (ext <= 0) {
        return fileName + "_" + suffix;
    } else {
        return fileName.substring(0, ext) + "_" + suffix + fileName.substring(ext);
    }
}
#end_block

#method_before
private static String randSuffix() {
    // Produce a random suffix that is difficult (or nearly impossible)
    // for an attacker to guess in advance. This reduces the risk that
    // an attacker could upload a *.class file and have us send a ZIP
    // that can be invoked through an applet tag in the victim's browser.
    // 
    final MessageDigest md = Constants.newMessageDigest();
    final byte[] buf = new byte[8];
    NB.encodeInt64(buf, 0, TimeUtil.nowMs());
    md.update(buf, 0, 8);
    rng.nextBytes(buf);
    md.update(buf, 0, 8);
    return ObjectId.fromRaw(md.digest()).name();
}
#method_after
private static String randSuffix() {
    // Produce a random suffix that is difficult (or nearly impossible)
    // for an attacker to guess in advance. This reduces the risk that
    // an attacker could upload a *.class file and have us send a ZIP
    // that can be invoked through an applet tag in the victim's browser.
    // 
    Hasher h = Hashing.md5().newHasher();
    byte[] buf = new byte[8];
    NB.encodeInt64(buf, 0, TimeUtil.nowMs());
    h.putBytes(buf);
    rng.nextBytes(buf);
    h.putBytes(buf);
    return h.hash().toString();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "safe_content").to(GetSafeContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(ReviewerResource.Factory.class);
    factory(AccountLoader.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
}
#method_after
@Override
protected void configure() {
    bind(ChangesCollection.class);
    bind(Revisions.class);
    bind(Reviewers.class);
    bind(DraftComments.class);
    bind(Comments.class);
    bind(Files.class);
    DynamicMap.mapOf(binder(), CHANGE_KIND);
    DynamicMap.mapOf(binder(), COMMENT_KIND);
    DynamicMap.mapOf(binder(), DRAFT_COMMENT_KIND);
    DynamicMap.mapOf(binder(), FILE_KIND);
    DynamicMap.mapOf(binder(), REVIEWER_KIND);
    DynamicMap.mapOf(binder(), REVISION_KIND);
    DynamicMap.mapOf(binder(), CHANGE_EDIT_KIND);
    get(CHANGE_KIND).to(GetChange.class);
    get(CHANGE_KIND, "detail").to(GetDetail.class);
    get(CHANGE_KIND, "topic").to(GetTopic.class);
    get(CHANGE_KIND, "in").to(IncludedIn.class);
    get(CHANGE_KIND, "hashtags").to(GetHashtags.class);
    get(CHANGE_KIND, "comments").to(ListChangeComments.class);
    get(CHANGE_KIND, "drafts").to(ListChangeDrafts.class);
    get(CHANGE_KIND, "check").to(Check.class);
    post(CHANGE_KIND, "check").to(Check.class);
    put(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND, "topic").to(PutTopic.class);
    delete(CHANGE_KIND).to(DeleteDraftChange.class);
    post(CHANGE_KIND, "abandon").to(Abandon.class);
    post(CHANGE_KIND, "hashtags").to(PostHashtags.class);
    post(CHANGE_KIND, "publish").to(PublishDraftPatchSet.CurrentRevision.class);
    post(CHANGE_KIND, "restore").to(Restore.class);
    post(CHANGE_KIND, "revert").to(Revert.class);
    post(CHANGE_KIND, "submit").to(Submit.CurrentRevision.class);
    get(CHANGE_KIND, "submitted_together").to(SubmittedTogether.class);
    post(CHANGE_KIND, "rebase").to(Rebase.CurrentRevision.class);
    post(CHANGE_KIND, "index").to(Index.class);
    post(CHANGE_KIND, "reviewers").to(PostReviewers.class);
    get(CHANGE_KIND, "suggest_reviewers").to(SuggestReviewers.class);
    child(CHANGE_KIND, "reviewers").to(Reviewers.class);
    get(REVIEWER_KIND).to(GetReviewer.class);
    delete(REVIEWER_KIND).to(DeleteReviewer.class);
    child(CHANGE_KIND, "revisions").to(Revisions.class);
    get(REVISION_KIND, "actions").to(GetRevisionActions.class);
    post(REVISION_KIND, "cherrypick").to(CherryPick.class);
    get(REVISION_KIND, "commit").to(GetCommit.class);
    delete(REVISION_KIND).to(DeleteDraftPatchSet.class);
    get(REVISION_KIND, "mergeable").to(Mergeable.class);
    post(REVISION_KIND, "publish").to(PublishDraftPatchSet.class);
    get(REVISION_KIND, "related").to(GetRelated.class);
    get(REVISION_KIND, "review").to(GetReview.class);
    post(REVISION_KIND, "review").to(PostReview.class);
    post(REVISION_KIND, "submit").to(Submit.class);
    post(REVISION_KIND, "rebase").to(Rebase.class);
    get(REVISION_KIND, "patch").to(GetPatch.class);
    get(REVISION_KIND, "submit_type").to(TestSubmitType.Get.class);
    post(REVISION_KIND, "test.submit_rule").to(TestSubmitRule.class);
    post(REVISION_KIND, "test.submit_type").to(TestSubmitType.class);
    get(REVISION_KIND, "archive").to(GetArchive.class);
    child(REVISION_KIND, "drafts").to(DraftComments.class);
    put(REVISION_KIND, "drafts").to(CreateDraftComment.class);
    get(DRAFT_COMMENT_KIND).to(GetDraftComment.class);
    put(DRAFT_COMMENT_KIND).to(PutDraftComment.class);
    delete(DRAFT_COMMENT_KIND).to(DeleteDraftComment.class);
    child(REVISION_KIND, "comments").to(Comments.class);
    get(COMMENT_KIND).to(GetComment.class);
    child(REVISION_KIND, "files").to(Files.class);
    put(FILE_KIND, "reviewed").to(PutReviewed.class);
    delete(FILE_KIND, "reviewed").to(DeleteReviewed.class);
    get(FILE_KIND, "content").to(GetContent.class);
    get(FILE_KIND, "download").to(DownloadContent.class);
    get(FILE_KIND, "diff").to(GetDiff.class);
    child(CHANGE_KIND, "edit").to(ChangeEdits.class);
    delete(CHANGE_KIND, "edit").to(DeleteChangeEdit.class);
    child(CHANGE_KIND, "edit:publish").to(PublishChangeEdit.class);
    child(CHANGE_KIND, "edit:rebase").to(RebaseChangeEdit.class);
    put(CHANGE_KIND, "edit:message").to(ChangeEdits.EditMessage.class);
    get(CHANGE_KIND, "edit:message").to(ChangeEdits.GetMessage.class);
    put(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Put.class);
    delete(CHANGE_EDIT_KIND).to(ChangeEdits.DeleteContent.class);
    get(CHANGE_EDIT_KIND, "/").to(ChangeEdits.Get.class);
    get(CHANGE_EDIT_KIND, "meta").to(ChangeEdits.GetMeta.class);
    factory(ReviewerResource.Factory.class);
    factory(AccountLoader.Factory.class);
    factory(EmailReviewComments.Factory.class);
    factory(ChangeInserter.Factory.class);
    factory(PatchSetInserter.Factory.class);
    factory(ChangeEdits.Create.Factory.class);
    factory(ChangeEdits.DeleteFile.Factory.class);
}
#end_block

#method_before
public static ServletModule module() {
    return new ServletModule() {

        @Override
        protected void configureServlets() {
            DynamicSet.setOf(binder(), AllRequestFilter.class);
            filter("/*").through(FilterProxy.class);
        }
    };
}
#method_after
public static ServletModule module() {
    return new ServletModule() {

        @Override
        protected void configureServlets() {
            DynamicSet.setOf(binder(), AllRequestFilter.class);
            filter("/*").through(FilterProxy.class);
            bind(StopPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(FilterProxy.class);
        }
    };
}
#end_block

#method_before
@Override
public void doFilter(ServletRequest req, ServletResponse res, final FilterChain last) throws IOException, ServletException {
    final Iterator<AllRequestFilter> itr = filters.iterator();
    new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {
            if (itr.hasNext()) {
                AllRequestFilter filter = itr.next();
                if (!initializedFilters.contains(filter)) {
                    initFilter(filter);
                }
                filter.doFilter(req, res, this);
            } else {
                last.doFilter(req, res);
            }
        }
    }.doFilter(req, res);
}
#method_after
@Override
public void doFilter(ServletRequest req, ServletResponse res, final FilterChain last) throws IOException, ServletException {
    final Iterator<AllRequestFilter> itr = filters.iterator();
    new FilterChain() {

        @Override
        public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {
            while (itr.hasNext()) {
                AllRequestFilter filter = itr.next();
                // webrequests.
                if (initializedFilters.contains(filter) || initFilterIfNeeded(filter)) {
                    filter.doFilter(req, res, this);
                    return;
                }
            }
            last.doFilter(req, res);
        }
    }.doFilter(req, res);
}
#end_block

#method_before
@Override
public void init(FilterConfig config) throws ServletException {
    // Plugins that provide AllRequestFilters might get loaded later at
    // runtime, long after this init method had been called. To allow to
    // correctly init such plugins' AllRequestFilters, we keep the
    // FilterConfig around, and reuse it to lazy init the AllRequestFilters.
    filterConfig = config;
    for (AllRequestFilter f : filters) {
        initFilter(f);
    }
}
#method_after
@Override
public void init(FilterConfig config) throws ServletException {
    // Plugins that provide AllRequestFilters might get loaded later at
    // runtime, long after this init method had been called. To allow to
    // correctly init such plugins' AllRequestFilters, we keep the
    // FilterConfig around, and reuse it to lazy init the AllRequestFilters.
    filterConfig = config;
    for (AllRequestFilter f : filters) {
        initFilterIfNeeded(f);
    }
}
#end_block

#method_before
@Override
public void destroy() {
    for (AllRequestFilter f : filters) {
        f.destroy();
    }
}
#method_after
@Override
public synchronized void destroy() {
    Iterable<AllRequestFilter> filtersToDestroy = initializedFilters;
    initializedFilters = new DynamicSet<>();
    for (AllRequestFilter filter : filtersToDestroy) {
        filter.destroy();
    }
}
#end_block

#method_before
private void addFilter(final AllRequestFilter filter) {
    filters.add(filter);
}
#method_after
private ReloadableRegistrationHandle<AllRequestFilter> addFilter(final AllRequestFilter filter) {
    Key<AllRequestFilter> key = Key.get(AllRequestFilter.class);
    return filters.add(key, Providers.of(filter));
}
#end_block

#method_before
private GitilesView.Builder parseNoCommand(HttpServletRequest req, String repoName) {
    if (req.getAttribute(ATTRIBUTE_REPOSITORY) == null) {
        return GitilesView.hostIndex().setRepositoryName(repoName);
    }
    return GitilesView.repositoryIndex().setRepositoryName(repoName);
}
#method_after
private GitilesView.Builder parseNoCommand(HttpServletRequest req, String repoName) {
    if (req.getAttribute(ATTRIBUTE_REPOSITORY) == null) {
        return GitilesView.hostIndex().setRepositoryPrefix(repoName);
    }
    return GitilesView.repositoryIndex().setRepositoryName(repoName);
}
#end_block

#method_before
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(accessFactory, resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    ServletBinder root = serveRegex(ROOT_REGEX).through(viewFilter);
    if (gitwebRedirect != null) {
        root.through(gitwebRedirect);
    }
    root.through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#method_after
@Override
public synchronized void init(FilterConfig config) throws ServletException {
    super.init(config);
    setDefaultFields(config);
    for (GitilesView.Type type : GitilesView.Type.values()) {
        if (!servlets.containsKey(type)) {
            servlets.put(type, getDefaultHandler(type));
        }
    }
    Filter repositoryFilter = new RepositoryFilter(resolver);
    Filter viewFilter = new ViewFilter(accessFactory, urls, visibilityCache);
    Filter dispatchFilter = new DispatchFilter(filters, servlets);
    ServletBinder root = serveRegex(ROOT_REGEX).through(viewFilter);
    if (gitwebRedirect != null) {
        root.through(gitwebRedirect);
    }
    root.through(dispatchFilter);
    serveRegex(REPO_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    serveRegex(REPO_PATH_REGEX).through(repositoryFilter).through(viewFilter).through(dispatchFilter);
    initialized = true;
}
#end_block

#method_before
public Builder copyFrom(GitilesView other) {
    if (type == Type.DOC && other.type == Type.ROOTED_DOC) {
        type = Type.ROOTED_DOC;
    }
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
        case DOC:
        case ROOTED_DOC:
        case ARCHIVE:
        case BLAME:
        case SHOW:
            path = other.path;
        // Fallthrough.
        case REVISION:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (other.type == type) {
        // Only copy params for matching type.
        params.putAll(other.params);
        if (type == Type.ARCHIVE) {
            extension = other.extension;
        }
    }
    return this;
}
#method_after
public Builder copyFrom(GitilesView other) {
    if (type == Type.DOC && other.type == Type.ROOTED_DOC) {
        type = Type.ROOTED_DOC;
    }
    hostName = other.hostName;
    servletPath = other.servletPath;
    switch(type) {
        case HOST_INDEX:
            repositoryPrefix = other.repositoryPrefix;
            break;
        case LOG:
        case DIFF:
            oldRevision = other.oldRevision;
        // Fallthrough.
        case PATH:
        case DOC:
        case ROOTED_DOC:
        case ARCHIVE:
        case BLAME:
        case SHOW:
            path = other.path;
        // Fallthrough.
        case REVISION:
            revision = other.revision;
        // Fallthrough.
        case DESCRIBE:
        case REFS:
        case REPOSITORY_INDEX:
            repositoryName = other.repositoryName;
        // Fallthrough.
        default:
            break;
    }
    if (other.type == type) {
        // Only copy params for matching type.
        params.putAll(other.params);
        if (type == Type.ARCHIVE) {
            extension = other.extension;
        }
    }
    return this;
}
#end_block

#method_before
public Builder setRepositoryName(String repositoryName) {
    this.repositoryName = checkNotNull(repositoryName);
    return this;
}
#method_after
public Builder setRepositoryName(String repositoryName) {
    switch(type) {
        case HOST_INDEX:
            throw new IllegalStateException(String.format("cannot set repository name on %s view", type));
        default:
            this.repositoryName = checkNotNull(repositoryName);
            return this;
    }
}
#end_block

#method_before
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
        case SHOW:
        case DOC:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
        case BLAME:
            checkBlame();
            break;
        case ROOTED_DOC:
            checkRootedDoc();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#method_after
public GitilesView build() {
    switch(type) {
        case HOST_INDEX:
            checkHostIndex();
            break;
        case REPOSITORY_INDEX:
            checkRepositoryIndex();
            break;
        case REFS:
            checkRefs();
            break;
        case DESCRIBE:
            checkDescribe();
            break;
        case REVISION:
            checkRevision();
            break;
        case PATH:
        case SHOW:
        case DOC:
            checkPath();
            break;
        case DIFF:
            checkDiff();
            break;
        case LOG:
            checkLog();
            break;
        case ARCHIVE:
            checkArchive();
            break;
        case BLAME:
            checkBlame();
            break;
        case ROOTED_DOC:
            checkRootedDoc();
            break;
    }
    return new GitilesView(type, hostName, servletPath, repositoryPrefix, repositoryName, revision, oldRevision, path, extension, params, anchor);
}
#end_block

#method_before
@Override
public String toString() {
    ToStringHelper b = toStringHelper(type.toString()).omitNullValues().add("host", hostName).add("servlet", servletPath).add("repo", repositoryName).add("rev", revision).add("old", oldRevision).add("path", path).add("extension", extension);
    if (!params.isEmpty()) {
        b.add("params", params);
    }
    b.add("anchor", anchor);
    return b.toString();
}
#method_after
@Override
public String toString() {
    ToStringHelper b = toStringHelper(type.toString()).omitNullValues().add("host", hostName).add("servlet", servletPath).add("prefix", repositoryPrefix).add("repo", repositoryName).add("rev", revision).add("old", oldRevision).add("path", path).add("extension", extension);
    if (!params.isEmpty()) {
        b.add("params", params);
    }
    b.add("anchor", anchor);
    return b.toString();
}
#end_block

#method_before
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            params = LinkedListMultimap.create();
            if (!this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            url.append(firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case SHOW:
            url.append(repositoryName).append("/+show/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        case BLAME:
            url.append(repositoryName).append("/+blame/").append(revision.getName()).append('/').append(path);
            break;
        case DOC:
            url.append(repositoryName);
            if (path != null && path.endsWith(".md")) {
                url.append("/+/");
            } else {
                url.append("/+doc/");
            }
            url.append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            break;
        case ROOTED_DOC:
            if (path != null) {
                url.append(path);
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url;
}
#method_after
public String toUrl() {
    StringBuilder url = new StringBuilder(servletPath).append('/');
    ListMultimap<String, String> params = this.params;
    switch(type) {
        case HOST_INDEX:
            if (repositoryPrefix != null) {
                url.append(repositoryPrefix).append('/');
            }
            params = LinkedListMultimap.create();
            if (repositoryPrefix == null && !this.params.containsKey("format")) {
                params.put("format", FormatType.HTML.toString());
            }
            params.putAll(this.params);
            break;
        case REPOSITORY_INDEX:
            url.append(repositoryName).append('/');
            break;
        case REFS:
            url.append(repositoryName).append("/+refs");
            break;
        case DESCRIBE:
            url.append(repositoryName).append("/+describe");
            break;
        case REVISION:
            url.append(repositoryName).append("/+/").append(revision.getName());
            break;
        case ARCHIVE:
            url.append(repositoryName).append("/+archive/").append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            url.append(firstNonNull(extension, DEFAULT_ARCHIVE_EXTENSION));
            break;
        case PATH:
            url.append(repositoryName).append("/+/").append(revision.getName()).append('/').append(path);
            break;
        case SHOW:
            url.append(repositoryName).append("/+show/").append(revision.getName()).append('/').append(path);
            break;
        case DIFF:
            url.append(repositoryName).append("/+/");
            if (isFirstParent(revision, oldRevision)) {
                url.append(revision.getName()).append("^!");
            } else {
                url.append(oldRevision.getName()).append("..").append(revision.getName());
            }
            url.append('/').append(path);
            break;
        case LOG:
            url.append(repositoryName).append("/+log");
            if (revision != Revision.NULL) {
                url.append('/');
                if (oldRevision != Revision.NULL) {
                    url.append(oldRevision.getName()).append("..");
                }
                url.append(revision.getName());
                if (path != null) {
                    url.append('/').append(path);
                }
            }
            break;
        case BLAME:
            url.append(repositoryName).append("/+blame/").append(revision.getName()).append('/').append(path);
            break;
        case DOC:
            url.append(repositoryName);
            if (path != null && path.endsWith(".md")) {
                url.append("/+/");
            } else {
                url.append("/+doc/");
            }
            url.append(revision.getName());
            if (path != null) {
                url.append('/').append(path);
            }
            break;
        case ROOTED_DOC:
            if (path != null) {
                url.append(path);
            }
            break;
        default:
            throw new IllegalStateException("Unknown view type: " + type);
    }
    String baseUrl = NAME_ESCAPER.apply(url.toString());
    url = new StringBuilder();
    if (!params.isEmpty()) {
        url.append('?').append(paramsToString(params));
    }
    if (!Strings.isNullOrEmpty(anchor)) {
        url.append('#').append(NAME_ESCAPER.apply(anchor));
    }
    return baseUrl + url;
}
#end_block

#method_before
public List<Map<String, String>> getBreadcrumbs(List<Boolean> hasSingleTree) {
    checkArgument(!NON_HTML_TYPES.contains(type), "breadcrumbs for %s view not supported", type);
    checkArgument(type != Type.REFS || Strings.isNullOrEmpty(path), "breadcrumbs for REFS view with path not supported");
    checkArgument(hasSingleTree == null || type == Type.PATH, "hasSingleTree must be null for %s view", type);
    String path = this.path;
    ImmutableList.Builder<Map<String, String>> breadcrumbs = ImmutableList.builder();
    breadcrumbs.add(breadcrumb(hostName, hostIndex().copyFrom(this)));
    if (repositoryName != null) {
        List<String> parts = Splitter.on('/').splitToList(repositoryName);
        for (int i = 0; i < parts.size(); i++) {
            String s = Joiner.on('/').join(parts.subList(0, i + 1));
            breadcrumbs.add(breadcrumb(parts.get(i), repositoryIndex().copyFrom(this).setRepositoryName(s)));
        }
    }
    if (type == Type.DIFF) {
        // TODO(dborowitz): Tweak the breadcrumbs template to allow us to render
        // separate links in "old..new".
        breadcrumbs.add(breadcrumb(getRevisionRange(), diff().copyFrom(this).setPathPart("")));
    } else if (type == Type.LOG) {
        if (revision != Revision.NULL) {
            // a breadcrumb) to allow switching between /+log/ and /+/.
            if (oldRevision == Revision.NULL) {
                breadcrumbs.add(breadcrumb(revision.getName(), log().copyFrom(this).setPathPart(null)));
            } else {
                breadcrumbs.add(breadcrumb(getRevisionRange(), log().copyFrom(this).setPathPart(null)));
            }
        } else {
            breadcrumbs.add(breadcrumb(Constants.HEAD, log().copyFrom(this)));
        }
        path = Strings.emptyToNull(path);
    } else if (revision != Revision.NULL) {
        breadcrumbs.add(breadcrumb(revision.getName(), revision().copyFrom(this)));
    }
    if (path != null) {
        if (type != Type.LOG && type != Type.REFS) {
            // The "." breadcrumb would be no different for LOG or REFS.
            breadcrumbs.add(breadcrumb(".", copyWithPath(false).setPathPart("")));
        }
        StringBuilder cur = new StringBuilder();
        List<String> parts = PathUtil.SPLITTER.omitEmptyStrings().splitToList(path);
        checkArgument(hasSingleTree == null || (parts.isEmpty() && hasSingleTree.isEmpty()) || hasSingleTree.size() == parts.size() - 1, "hasSingleTree has wrong number of entries");
        for (int i = 0; i < parts.size(); i++) {
            String part = parts.get(i);
            cur.append(part).append('/');
            String curPath = cur.toString();
            boolean isLeaf = i == parts.size() - 1;
            Builder builder = copyWithPath(isLeaf).setPathPart(curPath);
            if (hasSingleTree != null && i < parts.size() - 1 && hasSingleTree.get(i)) {
                builder.replaceParam(PathServlet.AUTODIVE_PARAM, PathServlet.NO_AUTODIVE_VALUE);
            }
            breadcrumbs.add(breadcrumb(part, builder));
        }
    }
    return breadcrumbs.build();
}
#method_after
public List<Map<String, String>> getBreadcrumbs(List<Boolean> hasSingleTree) {
    checkArgument(!NON_HTML_TYPES.contains(type), "breadcrumbs for %s view not supported", type);
    checkArgument(type != Type.REFS || Strings.isNullOrEmpty(path), "breadcrumbs for REFS view with path not supported");
    checkArgument(hasSingleTree == null || type == Type.PATH, "hasSingleTree must be null for %s view", type);
    String path = this.path;
    ImmutableList.Builder<Map<String, String>> breadcrumbs = ImmutableList.builder();
    breadcrumbs.add(breadcrumb(hostName, hostIndex().copyFrom(this).setRepositoryPrefix(null)));
    if (repositoryPrefix != null) {
        breadcrumbs.addAll(hostIndexBreadcrumbs(repositoryPrefix));
    } else if (repositoryName != null) {
        breadcrumbs.addAll(hostIndexBreadcrumbs(repositoryName));
    }
    if (type == Type.DIFF) {
        // TODO(dborowitz): Tweak the breadcrumbs template to allow us to render
        // separate links in "old..new".
        breadcrumbs.add(breadcrumb(getRevisionRange(), diff().copyFrom(this).setPathPart("")));
    } else if (type == Type.LOG) {
        if (revision != Revision.NULL) {
            // a breadcrumb) to allow switching between /+log/ and /+/.
            if (oldRevision == Revision.NULL) {
                breadcrumbs.add(breadcrumb(revision.getName(), log().copyFrom(this).setPathPart(null)));
            } else {
                breadcrumbs.add(breadcrumb(getRevisionRange(), log().copyFrom(this).setPathPart(null)));
            }
        } else {
            breadcrumbs.add(breadcrumb(Constants.HEAD, log().copyFrom(this)));
        }
        path = Strings.emptyToNull(path);
    } else if (revision != Revision.NULL) {
        breadcrumbs.add(breadcrumb(revision.getName(), revision().copyFrom(this)));
    }
    if (path != null) {
        if (type != Type.LOG && type != Type.REFS) {
            // The "." breadcrumb would be no different for LOG or REFS.
            breadcrumbs.add(breadcrumb(".", copyWithPath(false).setPathPart("")));
        }
        StringBuilder cur = new StringBuilder();
        List<String> parts = PathUtil.SPLITTER.omitEmptyStrings().splitToList(path);
        checkArgument(hasSingleTree == null || (parts.isEmpty() && hasSingleTree.isEmpty()) || hasSingleTree.size() == parts.size() - 1, "hasSingleTree has wrong number of entries");
        for (int i = 0; i < parts.size(); i++) {
            String part = parts.get(i);
            cur.append(part).append('/');
            String curPath = cur.toString();
            boolean isLeaf = i == parts.size() - 1;
            Builder builder = copyWithPath(isLeaf).setPathPart(curPath);
            if (hasSingleTree != null && i < parts.size() - 1 && hasSingleTree.get(i)) {
                builder.replaceParam(PathServlet.AUTODIVE_PARAM, PathServlet.NO_AUTODIVE_VALUE);
            }
            breadcrumbs.add(breadcrumb(part, builder));
        }
    }
    return breadcrumbs.build();
}
#end_block

#method_before
private SoyMapData toSoyMapData(RepositoryDescription desc, String prefix, GitilesView view) {
    return new SoyMapData("name", desc.name.substring(prefix.length()), "description", Strings.nullToEmpty(desc.description), "url", GitilesView.repositoryIndex().copyFrom(view).setRepositoryName(desc.name).toUrl());
}
#method_after
private SoyMapData toSoyMapData(RepositoryDescription desc, @Nullable String prefix, GitilesView view) {
    return new SoyMapData("name", stripPrefix(prefix, desc.name), "description", Strings.nullToEmpty(desc.description), "url", GitilesView.repositoryIndex().copyFrom(view).setRepositoryName(desc.name).toUrl());
}
#end_block

#method_before
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, RepositoryDescription> descs = getDescriptions(req, res);
    if (descs == null) {
        return;
    }
    String prefix = Strings.nullToEmpty(getPrefix(req));
    GitilesView view = ViewFilter.getView(req);
    SoyListData repos = new SoyListData();
    for (RepositoryDescription desc : descs.values()) {
        repos.add(toSoyMapData(desc, prefix, view));
    }
    String hostName = urls.getHostName(req);
    List<Map<String, String>> breadcrumbs = null;
    if (!prefix.isEmpty()) {
        hostName = hostName + '/' + CharMatcher.is('/').trimFrom(prefix);
        breadcrumbs = view.getBreadcrumbs();
    }
    renderHtml(req, res, "gitiles.hostIndex", ImmutableMap.of("hostName", hostName, "breadcrumbs", SoyData.createFromExistingData(breadcrumbs), "baseUrl", urls.getBaseGitUrl(req), "prefix", prefix, "repositories", repos));
}
#method_after
@Override
protected void doGetHtml(HttpServletRequest req, HttpServletResponse res) throws IOException {
    GitilesView view = ViewFilter.getView(req);
    String prefix = view.getRepositoryPrefix();
    Map<String, RepositoryDescription> descs = list(req, res, prefix, parseShowBranch(req));
    if (descs == null) {
        return;
    }
    SoyListData repos = new SoyListData();
    for (RepositoryDescription desc : descs.values()) {
        repos.add(toSoyMapData(desc, prefix, view));
    }
    String hostName = urls.getHostName(req);
    List<Map<String, String>> breadcrumbs = null;
    if (prefix != null) {
        hostName = hostName + '/' + prefix;
        breadcrumbs = view.getBreadcrumbs();
    }
    renderHtml(req, res, "gitiles.hostIndex", ImmutableMap.of("hostName", hostName, "breadcrumbs", SoyData.createFromExistingData(breadcrumbs), "baseUrl", urls.getBaseGitUrl(req), "prefix", prefix != null ? prefix + '/' : "", "repositories", repos));
}
#end_block

#method_before
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Set<String> branches = parseShowBranch(req);
    int prefix = Strings.nullToEmpty(getPrefix(req)).length();
    Map<String, RepositoryDescription> descs = getDescriptions(req, res, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(repo.name.substring(prefix)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#method_after
@Override
protected void doGetText(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Set<String> branches = parseShowBranch(req);
    Map<String, RepositoryDescription> descs = list(req, res, prefix, branches);
    if (descs == null) {
        return;
    }
    Writer writer = startRenderText(req, res);
    for (RepositoryDescription repo : descs.values()) {
        for (String name : branches) {
            String ref = repo.branches.get(name);
            if (ref == null) {
                // Print stub (forty '-' symbols)
                ref = "----------------------------------------";
            }
            writer.write(ref);
            writer.write(' ');
        }
        writer.write(GitilesUrls.NAME_ESCAPER.apply(stripPrefix(prefix, repo.name)));
        writer.write('\n');
    }
    writer.flush();
    writer.close();
}
#end_block

#method_before
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    Map<String, RepositoryDescription> descs = getDescriptions(req, res);
    if (descs == null) {
        return;
    }
    int prefix = Strings.nullToEmpty(getPrefix(req)).length();
    if (prefix > 0) {
        Map<String, RepositoryDescription> r = new LinkedHashMap<>();
        for (Map.Entry<String, RepositoryDescription> e : descs.entrySet()) {
            r.put(e.getKey().substring(prefix), e.getValue());
        }
    }
    renderJson(req, res, descs, new TypeToken<Map<String, RepositoryDescription>>() {
    }.getType());
}
#method_after
@Override
protected void doGetJson(HttpServletRequest req, HttpServletResponse res) throws IOException {
    String prefix = ViewFilter.getView(req).getRepositoryPrefix();
    Map<String, RepositoryDescription> descs = list(req, res, prefix, parseShowBranch(req));
    if (descs == null) {
        return;
    }
    if (prefix != null) {
        Map<String, RepositoryDescription> r = new LinkedHashMap<>();
        for (Map.Entry<String, RepositoryDescription> e : descs.entrySet()) {
            r.put(stripPrefix(prefix, e.getKey()), e.getValue());
        }
        descs = r;
    }
    renderJson(req, res, descs, new TypeToken<Map<String, RepositoryDescription>>() {
    }.getType());
}
#end_block

#method_before
@Override
public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) throws IOException {
    // TODO(sop) take advantage of prefix to narrow scan of repositories.
    prefix = Strings.emptyToNull(prefix);
    if (prefix != null && !prefix.endsWith("/")) {
        prefix += '/';
    }
    Map<String, RepositoryDescription> repos = Maps.newTreeMap(US_COLLATOR);
    for (Repository repo : scanRepositories(basePath, req)) {
        String name = getRepositoryName(repo);
        if (prefix == null || name.startsWith(prefix)) {
            repos.put(name, buildDescription(repo, branches));
        }
        repo.close();
    }
    return repos;
}
#method_after
@Override
public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) throws IOException {
    Map<String, RepositoryDescription> repos = Maps.newTreeMap(US_COLLATOR);
    for (Repository repo : scanRepositories(basePath, prefix, req)) {
        repos.put(getRepositoryName(repo), buildDescription(repo, branches));
        repo.close();
    }
    return repos;
}
#end_block

#method_before
private Collection<Repository> scanRepositories(final File basePath, final HttpServletRequest req) throws IOException {
    List<Repository> repos = Lists.newArrayList();
    Queue<File> todo = Queues.newArrayDeque();
    File[] baseFiles = basePath.listFiles();
    if (baseFiles == null) {
        throw new IOException("base path is not a directory: " + basePath.getPath());
    }
    Collections.addAll(todo, baseFiles);
    while (!todo.isEmpty()) {
        File file = todo.remove();
        try {
            repos.add(resolver.open(req, getRelativePath(file.getPath())));
        } catch (RepositoryNotFoundException e) {
            File[] children = file.listFiles();
            if (children != null) {
                Collections.addAll(todo, children);
            }
        } catch (ServiceNotEnabledException e) {
            throw new IOException(e);
        }
    }
    return repos;
}
#method_after
private Collection<Repository> scanRepositories(File basePath, String prefix, HttpServletRequest req) throws IOException {
    List<Repository> repos = Lists.newArrayList();
    Queue<File> todo = initScan(basePath, prefix);
    while (!todo.isEmpty()) {
        File file = todo.remove();
        try {
            repos.add(resolver.open(req, getRelativePath(file.getPath())));
        } catch (RepositoryNotFoundException e) {
            File[] children = file.listFiles();
            if (children != null) {
                Collections.addAll(todo, children);
            }
        } catch (ServiceNotEnabledException e) {
            throw new IOException(e);
        }
    }
    return repos;
}
#end_block

#method_before
@Override
public GitilesAccess forRequest(final HttpServletRequest req) {
    return new GitilesAccess() {

        @Override
        public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) {
            if (branches != null && !branches.isEmpty()) {
                throw new UnsupportedOperationException("branches set not yet supported");
            }
            RepositoryDescription desc = new RepositoryDescription();
            desc.name = repo.getDescription().getRepositoryName();
            desc.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + desc.name;
            return ImmutableMap.of(desc.name, desc);
        }

        @Override
        public Object getUserKey() {
            return "a user";
        }

        @Override
        public String getRepositoryName() {
            return repo.getDescription().getRepositoryName();
        }

        @Override
        public RepositoryDescription getRepositoryDescription() {
            RepositoryDescription d = new RepositoryDescription();
            d.name = getRepositoryName();
            d.description = "a test data set";
            d.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + d.name;
            return d;
        }

        @Override
        public Config getConfig() {
            return new Config();
        }
    };
}
#method_after
@Override
public GitilesAccess forRequest(final HttpServletRequest req) {
    return new GitilesAccess() {

        @Override
        public Map<String, RepositoryDescription> listRepositories(String prefix, Set<String> branches) {
            String name = repo.getDescription().getRepositoryName();
            if (prefix != null) {
                String pattern = CharMatcher.is('/').trimFrom(prefix) + '/';
                if (!name.startsWith(pattern)) {
                    return Collections.emptyMap();
                }
            }
            if (branches != null && !branches.isEmpty()) {
                throw new UnsupportedOperationException("branches set not yet supported");
            }
            RepositoryDescription desc = new RepositoryDescription();
            desc.name = name;
            desc.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + desc.name;
            return ImmutableMap.of(desc.name, desc);
        }

        @Override
        public Object getUserKey() {
            return "a user";
        }

        @Override
        public String getRepositoryName() {
            return repo.getDescription().getRepositoryName();
        }

        @Override
        public RepositoryDescription getRepositoryDescription() {
            RepositoryDescription d = new RepositoryDescription();
            d.name = getRepositoryName();
            d.description = "a test data set";
            d.cloneUrl = TestGitilesUrls.URLS.getBaseGitUrl(req) + "/" + d.name;
            return d;
        }

        @Override
        public Config getConfig() {
            return new Config();
        }
    };
}
#end_block

#method_before
private void display(final Preferences info) {
    HorizontalPanel p = new HorizontalPanel();
    add(p);
    Label label = new Label("Change Screen:");
    p.add(label);
    label.getElement().getStyle().setMarginRight(5, Unit.PX);
    label.getElement().getStyle().setMarginTop(2, Unit.PX);
    final ListBox box = new ListBox();
    p.add(box);
    box.addItem(DEFAULT, DEFAULT);
    box.addItem(COOKBOOK, COOKBOOK);
    String selected = DEFAULT;
    if (info.urlAliases().containsKey(DEFAULT_URL_PATH)) {
        String urlPath = info.urlAliases().get(DEFAULT_URL_PATH);
        if (urlPath.equals(COOKBOOK_URL_PATH)) {
            selected = COOKBOOK;
        } else if (!urlPath.equals(DEFAULT_URL_PATH)) {
            box.addItem(OTHER, OTHER);
            selected = OTHER;
        }
    }
    for (int i = 0; i < box.getItemCount(); i++) {
        if (selected.equals(box.getValue(i))) {
            box.setSelectedIndex(i);
            break;
        }
    }
    box.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            if (box.getSelectedValue().equals(OTHER)) {
                return;
            }
            Map<String, String> urlAliases = info.urlAliases();
            if (box.getSelectedValue().equals(COOKBOOK)) {
                urlAliases.put(DEFAULT_URL_PATH, COOKBOOK_URL_PATH);
            } else {
                urlAliases.remove(DEFAULT_URL_PATH);
            }
            info.setUrlAliases(urlAliases);
            new RestApi("accounts").id("self").view("preferences").put(info, new AsyncCallback<Preferences>() {

                @Override
                public void onSuccess(Preferences result) {
                    Plugin.get().refreshUrlAliases();
                }

                @Override
                public void onFailure(Throwable caught) {
                // never invoked
                }
            });
        }
    });
}
#method_after
private void display(final AccountPreferencesInfo info) {
    Label heading = new Label(Plugin.get().getName() + " plugin");
    heading.setStyleName("smallHeading");
    add(heading);
    HorizontalPanel p = new HorizontalPanel();
    add(p);
    Label label = new Label("Change Screen:");
    p.add(label);
    label.getElement().getStyle().setMarginRight(5, Unit.PX);
    label.getElement().getStyle().setMarginTop(2, Unit.PX);
    final ListBox box = new ListBox();
    p.add(box);
    savedLabel = new Label("Saved");
    savedLabel.getElement().getStyle().setMarginLeft(5, Unit.PX);
    savedLabel.getElement().getStyle().setMarginTop(2, Unit.PX);
    savedLabel.setVisible(false);
    p.add(savedLabel);
    box.addItem(DEFAULT, DEFAULT);
    box.addItem(COOKBOOK, COOKBOOK);
    String selected = DEFAULT;
    if (info.urlAliases().containsKey(DEFAULT_URL_MATCH)) {
        String token = info.urlAliases().get(DEFAULT_URL_MATCH);
        if (token.equals(COOKBOOK_URL_TOKEN)) {
            selected = COOKBOOK;
        } else if (!token.equals(DEFAULT_URL_MATCH)) {
            box.addItem(OTHER, OTHER);
            selected = OTHER;
        }
    }
    for (int i = 0; i < box.getItemCount(); i++) {
        if (selected.equals(box.getValue(i))) {
            box.setSelectedIndex(i);
            break;
        }
    }
    box.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            savedLabel.setVisible(false);
            if (box.getSelectedValue().equals(OTHER)) {
                return;
            }
            Map<String, String> urlAliases = info.urlAliases();
            if (box.getSelectedValue().equals(COOKBOOK)) {
                urlAliases.put(DEFAULT_URL_MATCH, COOKBOOK_URL_TOKEN);
            } else {
                urlAliases.remove(DEFAULT_URL_MATCH);
            }
            info.setUrlAliases(urlAliases);
            new RestApi("accounts").id("self").view("preferences").put(info, new AsyncCallback<AccountPreferencesInfo>() {

                @Override
                public void onSuccess(AccountPreferencesInfo result) {
                    Plugin.get().refreshUserPreferences();
                    showSavedStatus();
                }

                @Override
                public void onFailure(Throwable caught) {
                // never invoked
                }
            });
        }
    });
}
#end_block

#method_before
public Account.Id lookup(final String externalId) throws AccountException {
    try {
        final ReviewDb db = schema.open();
        try {
            final AccountExternalId ext = db.accountExternalIds().get(new AccountExternalId.Key(externalId));
            return ext != null ? ext.getAccountId() : null;
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#method_after
public Account.Id lookup(String externalId) throws AccountException {
    try {
        ReviewDb db = schema.open();
        try {
            AccountExternalId ext = db.accountExternalIds().get(new AccountExternalId.Key(externalId));
            return ext != null ? ext.getAccountId() : null;
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        throw new AccountException("Cannot lookup account " + externalId, e);
    }
}
#end_block

#method_before
public AuthResult authenticate(AuthRequest who) throws AccountException {
    who = realm.authenticate(who);
    try {
        final ReviewDb db = schema.open();
        try {
            final AccountExternalId.Key key = id(who);
            final AccountExternalId id = db.accountExternalIds().get(key);
            if (id == null) {
                // 
                return create(db, who);
            } else {
                // Account exists
                Account act = byIdCache.get(id.getAccountId()).getAccount();
                if (act == null || !act.isActive()) {
                    throw new AccountException("Authentication error, account inactive");
                }
                // return the identity to the caller.
                update(db, who, id);
                return new AuthResult(id.getAccountId(), key, false);
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        throw new AccountException("Authentication error", e);
    }
}
#method_after
public AuthResult authenticate(AuthRequest who) throws AccountException {
    who = realm.authenticate(who);
    try {
        ReviewDb db = schema.open();
        try {
            AccountExternalId.Key key = id(who);
            AccountExternalId id = db.accountExternalIds().get(key);
            if (id == null) {
                // 
                return create(db, who);
            } else {
                // Account exists
                Account act = byIdCache.get(id.getAccountId()).getAccount();
                if (!act.isActive()) {
                    throw new AccountException("Authentication error, account inactive");
                }
                // return the identity to the caller.
                update(db, who, id);
                return new AuthResult(id.getAccountId(), key, false);
            }
        } finally {
            db.close();
        }
    } catch (OrmException e) {
        throw new AccountException("Authentication error", e);
    }
}
#end_block

#method_before
private void update(final ReviewDb db, final AuthRequest who, final AccountExternalId extId) throws OrmException {
    final IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    final String newEmail = who.getEmailAddress();
    final String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
    if (!realm.allowsEdit(Account.FieldName.FULL_NAME) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME) && !eq(user.getUserName(), who.getUserName())) {
        changeUserNameFactory.create(db, user, who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#method_after
private void update(ReviewDb db, AuthRequest who, AccountExternalId extId) throws OrmException {
    IdentifiedUser user = userFactory.create(extId.getAccountId());
    Account toUpdate = null;
    // If the email address was modified by the authentication provider,
    // update our records to match the changed email.
    // 
    String newEmail = who.getEmailAddress();
    String oldEmail = extId.getEmailAddress();
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        if (oldEmail != null && oldEmail.equals(user.getAccount().getPreferredEmail())) {
            toUpdate = load(toUpdate, user.getAccountId(), db);
            toUpdate.setPreferredEmail(newEmail);
        }
        extId.setEmailAddress(newEmail);
        db.accountExternalIds().update(Collections.singleton(extId));
    }
    if (!realm.allowsEdit(Account.FieldName.FULL_NAME) && !eq(user.getAccount().getFullName(), who.getDisplayName())) {
        toUpdate = load(toUpdate, user.getAccountId(), db);
        toUpdate.setFullName(who.getDisplayName());
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME) && !eq(user.getUserName(), who.getUserName())) {
        changeUserNameFactory.create(db, user, who.getUserName());
    }
    if (toUpdate != null) {
        db.accounts().update(Collections.singleton(toUpdate));
    }
    if (newEmail != null && !newEmail.equals(oldEmail)) {
        byEmailCache.evict(oldEmail);
        byEmailCache.evict(newEmail);
    }
    if (toUpdate != null) {
        byIdCache.evict(toUpdate.getId());
    }
}
#end_block

#method_before
private static boolean eq(final String a, final String b) {
    return (a == null && b == null) || (a != null && a.equals(b));
}
#method_after
private static boolean eq(String a, String b) {
    return (a == null && b == null) || (a != null && a.equals(b));
}
#end_block

#method_before
private AuthResult create(final ReviewDb db, final AuthRequest who) throws OrmException, AccountException {
    final Account.Id newId = new Account.Id(db.nextAccountId());
    final Account account = new Account(newId, TimeUtil.nowTs());
    final AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    final boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        db.accountExternalIds().upsert(Collections.singleton(extId));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        final AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        final AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        final AccountGroup.Id adminId = g.getId();
        final AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            final String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            final String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            final String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#method_after
private AuthResult create(ReviewDb db, AuthRequest who) throws OrmException, AccountException {
    Account.Id newId = new Account.Id(db.nextAccountId());
    Account account = new Account(newId, TimeUtil.nowTs());
    AccountExternalId extId = createId(newId, who);
    extId.setEmailAddress(who.getEmailAddress());
    account.setFullName(who.getDisplayName());
    account.setPreferredEmail(extId.getEmailAddress());
    boolean isFirstAccount = awaitsFirstAccountCheck.getAndSet(false) && db.accounts().anyAccounts().toList().isEmpty();
    try {
        db.accounts().upsert(Collections.singleton(account));
        db.accountExternalIds().upsert(Collections.singleton(extId));
    } finally {
        // If adding the account failed, it may be that it actually was the
        // first account. So we reset the 'check for first account'-guard, as
        // otherwise the first account would not get administration permissions.
        awaitsFirstAccountCheck.set(isFirstAccount);
    }
    if (isFirstAccount) {
        // This is the first user account on our site. Assume this user
        // is going to be the site's administrator and just make them that
        // to bootstrap the authentication database.
        // 
        Permission admin = projectCache.getAllProjects().getConfig().getAccessSection(AccessSection.GLOBAL_CAPABILITIES).getPermission(GlobalCapability.ADMINISTRATE_SERVER);
        AccountGroup.UUID uuid = admin.getRules().get(0).getGroup().getUUID();
        AccountGroup g = db.accountGroups().byUUID(uuid).iterator().next();
        AccountGroup.Id adminId = g.getId();
        AccountGroupMember m = new AccountGroupMember(new AccountGroupMember.Key(newId, adminId));
        auditService.dispatchAddAccountsToGroup(newId, Collections.singleton(m));
        db.accountGroupMembers().insert(Collections.singleton(m));
    }
    if (who.getUserName() != null) {
        // Only set if the name hasn't been used yet, but was given to us.
        // 
        IdentifiedUser user = userFactory.create(newId);
        try {
            changeUserNameFactory.create(db, user, who.getUserName()).call();
        } catch (NameAlreadyUsedException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name already in use.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (InvalidUserNameException e) {
            String message = "Cannot assign user name \"" + who.getUserName() + "\" to account " + newId + "; name does not conform.";
            handleSettingUserNameFailure(db, account, extId, message, e, false);
        } catch (OrmException e) {
            String message = "Cannot assign user name";
            handleSettingUserNameFailure(db, account, extId, message, e, true);
        }
    }
    byEmailCache.evict(account.getPreferredEmail());
    realm.onCreateAccount(who, account);
    return new AuthResult(newId, extId.getKey(), true);
}
#end_block

#method_before
private void handleSettingUserNameFailure(final ReviewDb db, final Account account, final AccountExternalId extId, final String errorMessage, final Exception e, final boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        throw new AccountUserNameException(errorMessage, e);
    }
}
#method_after
private void handleSettingUserNameFailure(ReviewDb db, Account account, AccountExternalId extId, String errorMessage, Exception e, boolean logException) throws AccountUserNameException, OrmException {
    if (logException) {
        log.error(errorMessage, e);
    } else {
        log.error(errorMessage);
    }
    if (!realm.allowsEdit(Account.FieldName.USER_NAME)) {
        // setting the given user name has failed, but the realm does not
        // allow the user to manually set a user name,
        // this means we would end with an account without user name
        // (without 'username:<USERNAME>' entry in
        // account_external_ids table),
        // such an account cannot be used for uploading changes,
        // this is why the best we can do here is to fail early and cleanup
        // the database
        db.accounts().delete(Collections.singleton(account));
        db.accountExternalIds().delete(Collections.singleton(extId));
        throw new AccountUserNameException(errorMessage, e);
    }
}
#end_block

#method_before
private static AccountExternalId createId(final Account.Id newId, final AuthRequest who) {
    final String ext = who.getExternalId();
    return new AccountExternalId(newId, new AccountExternalId.Key(ext));
}
#method_after
private static AccountExternalId createId(Account.Id newId, AuthRequest who) {
    String ext = who.getExternalId();
    return new AccountExternalId(newId, new AccountExternalId.Key(ext));
}
#end_block

#method_before
public AuthResult link(final Account.Id to, AuthRequest who) throws AccountException, OrmException {
    final ReviewDb db = schema.open();
    try {
        who = realm.link(db, to, who);
        final AccountExternalId.Key key = id(who);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                final Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(to);
            }
        }
        return new AuthResult(to, key, false);
    } finally {
        db.close();
    }
}
#method_after
public AuthResult link(Account.Id to, AuthRequest who) throws AccountException, OrmException {
    ReviewDb db = schema.open();
    try {
        who = realm.link(db, to, who);
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(to)) {
                throw new AccountException("Identity in use by another account");
            }
            update(db, who, extId);
        } else {
            extId = createId(to, who);
            extId.setEmailAddress(who.getEmailAddress());
            db.accountExternalIds().insert(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(to);
                if (a.getPreferredEmail() == null) {
                    a.setPreferredEmail(who.getEmailAddress());
                    db.accounts().update(Collections.singleton(a));
                }
            }
            if (who.getEmailAddress() != null) {
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(to);
            }
        }
        return new AuthResult(to, key, false);
    } finally {
        db.close();
    }
}
#end_block

#method_before
public AuthResult unlink(final Account.Id from, AuthRequest who) throws AccountException, OrmException {
    final ReviewDb db = schema.open();
    try {
        who = realm.unlink(db, from, who);
        final AccountExternalId.Key key = id(who);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                final Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity not found");
        }
        return new AuthResult(from, key, false);
    } finally {
        db.close();
    }
}
#method_after
public AuthResult unlink(Account.Id from, AuthRequest who) throws AccountException, OrmException {
    ReviewDb db = schema.open();
    try {
        who = realm.unlink(db, from, who);
        AccountExternalId.Key key = id(who);
        AccountExternalId extId = db.accountExternalIds().get(key);
        if (extId != null) {
            if (!extId.getAccountId().equals(from)) {
                throw new AccountException("Identity in use by another account");
            }
            db.accountExternalIds().delete(Collections.singleton(extId));
            if (who.getEmailAddress() != null) {
                Account a = db.accounts().get(from);
                if (a.getPreferredEmail() != null && a.getPreferredEmail().equals(who.getEmailAddress())) {
                    a.setPreferredEmail(null);
                    db.accounts().update(Collections.singleton(a));
                }
                byEmailCache.evict(who.getEmailAddress());
                byIdCache.evict(from);
            }
        } else {
            throw new AccountException("Identity not found");
        }
        return new AuthResult(from, key, false);
    } finally {
        db.close();
    }
}
#end_block

#method_before
private static AccountExternalId.Key id(final AuthRequest who) {
    return new AccountExternalId.Key(who.getExternalId());
}
#method_after
private static AccountExternalId.Key id(AuthRequest who) {
    return new AccountExternalId.Key(who.getExternalId());
}
#end_block

#method_before
// Plugin enablement --------------------------------------------------------
public boolean isEnabled(Event event) {
    if (event instanceof PatchSetCreatedEvent) {
        PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof CommentAddedEvent) {
        CommentAddedEvent e = (CommentAddedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeMergedEvent) {
        ChangeMergedEvent e = (ChangeMergedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeAbandonedEvent) {
        ChangeAbandonedEvent e = (ChangeAbandonedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeRestoredEvent) {
        ChangeRestoredEvent e = (ChangeRestoredEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof DraftPublishedEvent) {
        DraftPublishedEvent e = (DraftPublishedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof RefUpdatedEvent) {
        RefUpdatedEvent e = (RefUpdatedEvent) event;
        return isEnabled(e.refUpdate.project, e.refUpdate.refName);
    } else {
        log.debug("Event " + event.getType() + " not recognised and ignored");
        return false;
    }
}
#method_after
// Plugin enablement --------------------------------------------------------
public boolean isEnabled(Event event) {
    if (event instanceof PatchSetCreatedEvent) {
        PatchSetCreatedEvent e = (PatchSetCreatedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof CommentAddedEvent) {
        CommentAddedEvent e = (CommentAddedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeMergedEvent) {
        ChangeMergedEvent e = (ChangeMergedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeAbandonedEvent) {
        ChangeAbandonedEvent e = (ChangeAbandonedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof ChangeRestoredEvent) {
        ChangeRestoredEvent e = (ChangeRestoredEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof DraftPublishedEvent) {
        DraftPublishedEvent e = (DraftPublishedEvent) event;
        return isEnabled(e.change.project, e.getRefName());
    } else if (event instanceof RefUpdatedEvent) {
        RefUpdatedEvent e = (RefUpdatedEvent) event;
        return isEnabled(e.refUpdate.project, e.refUpdate.refName);
    } else {
        log.debug("Event " + event + " not recognised and ignored");
        return false;
    }
}
#end_block

#method_before
public void testIsIgnoredTopicChangedEvent() {
    TopicChangedEvent event = new TopicChangedEvent();
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertFalse(itsConfig.isEnabled(event));
    assertLogMessageContains("Event " + event.getType() + " not recognised and ignored");
}
#method_after
public void testIsIgnoredTopicChangedEvent() {
    TopicChangedEvent event = new TopicChangedEvent();
    ItsConfig itsConfig = createItsConfig();
    replayMocks();
    assertFalse(itsConfig.isEnabled(event));
    assertLogMessageContains("not recognised and ignored");
}
#end_block

#method_before
@Test
public void constructorCreateDir() throws IOException {
    Path testtDir = Paths.get("tmp");
    flatFileWebSessionCache = new FlatFileWebSessionCache(testtDir);
    assertThat(Files.exists(testtDir)).isTrue();
    Files.deleteIfExists(testtDir);
}
#method_after
@Test
public void constructorCreateDir() throws IOException {
    Path testDir = Paths.get("tmp");
    flatFileWebSessionCache = new FlatFileWebSessionCache(testDir);
    assertThat(Files.exists(testDir)).isTrue();
    Files.deleteIfExists(testDir);
}
#end_block

#method_before
@Test
public void invalidateTest() throws Exception {
    Path fileToDelete = Files.createFile(dir.resolve(key));
    assertThat(Files.exists(fileToDelete));
    flatFileWebSessionCache.invalidate(key);
    assertThat(Files.notExists(fileToDelete));
}
#method_after
@Test
public void invalidateTest() throws Exception {
    Path fileToDelete = Files.createFile(dir.resolve(key));
    assertThat(Files.exists(fileToDelete)).isTrue();
    flatFileWebSessionCache.invalidate(key);
    assertThat(Files.exists(fileToDelete)).isFalse();
}
#end_block

#method_before
@Test
public void invalidateTestObjectNotString() throws Exception {
    flatFileWebSessionCache.invalidate(new Object());
}
#method_after
@Test
public void invalidateTestObjectNotString() throws Exception {
    createKeysCollection();
    assertThat(flatFileWebSessionCache.size()).isEqualTo(DEFAULT_KEYS_SIZE);
    flatFileWebSessionCache.invalidate(new Object());
    assertThat(flatFileWebSessionCache.size()).isEqualTo(DEFAULT_KEYS_SIZE);
}
#end_block

#method_before
@Test
public void putAllTest() throws Exception {
    loadExistingKeyToCacheDir();
    Val val = flatFileWebSessionCache.getIfPresent(existingKey);
    String newKey = "abcde12345";
    Map<String, Val> sessions = new HashMap<>();
    sessions.put(newKey, val);
    flatFileWebSessionCache.putAll(sessions);
    assertThat(flatFileWebSessionCache.asMap()).containsKey(newKey);
}
#method_after
@Test
public void putAllTest() throws Exception {
    loadExistingKeyToCacheDir();
    Val val = flatFileWebSessionCache.getIfPresent(existingKey);
    String newKey = "abcde12345";
    Map<String, Val> sessions = ImmutableMap.of(newKey, val);
    flatFileWebSessionCache.putAll(sessions);
    assertThat(flatFileWebSessionCache.asMap()).containsKey(newKey);
}
#end_block

#method_before
private InputStream loadFile(String file) {
    return ClassLoader.getSystemResourceAsStream(file);
}
#method_after
private InputStream loadFile(String file) {
    return this.getClass().getResourceAsStream("/" + file);
}
#end_block

#method_before
public static Term idTerm(Change.Id id) {
    return intTerm(ID_FIELD, id.get());
}
#method_after
public static Term idTerm(Schema<ChangeData> schema, ChangeData cd) {
    return intTerm(idField(schema).getName(), cd.getId().get());
}
#end_block

#method_before
private SearcherFactory newSearcherFactory() {
    if (useDocValuesForSorting) {
        return new SearcherFactory();
    }
    final Map<String, UninvertingReader.Type> mapping = ImmutableMap.of(ChangeField.LEGACY_ID2.getName(), UninvertingReader.Type.INTEGER, ChangeField.UPDATED.getName(), UninvertingReader.Type.LONG);
    return new SearcherFactory() {

        @Override
        public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {
            checkState(reader instanceof DirectoryReader, "expected DirectoryReader, found %s", reader.getClass().getName());
            return new IndexSearcher(UninvertingReader.wrap((DirectoryReader) reader, mapping));
        }
    };
}
#method_after
private SearcherFactory newSearcherFactory() {
    if (useDocValuesForSorting) {
        return new SearcherFactory();
    }
    @SuppressWarnings("deprecation")
    final Map<String, UninvertingReader.Type> mapping = ImmutableMap.of(ChangeField.LEGACY_ID.getName(), UninvertingReader.Type.INTEGER, ChangeField.UPDATED.getName(), UninvertingReader.Type.LONG);
    return new SearcherFactory() {

        @Override
        public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {
            checkState(reader instanceof DirectoryReader, "expected DirectoryReader, found %s", reader.getClass().getName());
            return new IndexSearcher(UninvertingReader.wrap((DirectoryReader) reader, mapping));
        }
    };
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void replace(ChangeData cd) throws IOException {
    Term id = QueryBuilder.idTerm(schema, cd);
    Document doc = toDocument(cd);
    try {
        if (cd.change().getStatus().isOpen()) {
            Futures.allAsList(closedIndex.delete(id), openIndex.replace(id, doc)).get();
        } else {
            Futures.allAsList(openIndex.delete(id), closedIndex.replace(id, doc)).get();
        }
    } catch (OrmException | ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public void delete(Change.Id id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#method_after
@Override
public void delete(Change.Id id) throws IOException {
    Term idTerm = QueryBuilder.idTerm(schema, id);
    try {
        Futures.allAsList(openIndex.delete(idTerm), closedIndex.delete(idTerm)).get();
    } catch (ExecutionException | InterruptedException e) {
        throw new IOException(e);
    }
}
#end_block

#method_before
private Sort getSort() {
    if (useDocValuesForSorting) {
        return new Sort(new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(ID_SORT_FIELD, SortField.Type.LONG, true));
    } else {
        return new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.LONG, true), new SortField(ChangeField.LEGACY_ID2.getName(), SortField.Type.INT, true));
    }
}
#method_after
@SuppressWarnings("deprecation")
private Sort getSort() {
    if (useDocValuesForSorting) {
        return new Sort(new SortField(UPDATED_SORT_FIELD, SortField.Type.LONG, true), new SortField(idSortField, SortField.Type.LONG, true));
    } else {
        return new Sort(new SortField(ChangeField.UPDATED.getName(), SortField.Type.LONG, true), new SortField(ChangeField.LEGACY_ID.getName(), SortField.Type.INT, true));
    }
}
#end_block

#method_before
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (useDocValuesForSorting) {
        if (values.getField() == ChangeField.LEGACY_ID2) {
            int v = (Integer) getOnlyElement(values.getValues());
            doc.add(new NumericDocValuesField(ID_SORT_FIELD, v));
        } else if (values.getField() == ChangeField.UPDATED) {
            long t = ((Timestamp) getOnlyElement(values.getValues())).getTime();
            doc.add(new NumericDocValuesField(UPDATED_SORT_FIELD, t));
        }
    }
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw FieldType.badFieldType(type);
    }
}
#method_after
@SuppressWarnings("deprecation")
private void add(Document doc, Values<ChangeData> values) {
    String name = values.getField().getName();
    FieldType<?> type = values.getField().getType();
    Store store = store(values.getField());
    if (useDocValuesForSorting) {
        FieldDef<ChangeData, ?> f = values.getField();
        if (f == ChangeField.LEGACY_ID || f == ChangeField.LEGACY_ID2) {
            int v = (Integer) getOnlyElement(values.getValues());
            doc.add(new NumericDocValuesField(sortFieldName(f), v));
        } else if (f == ChangeField.UPDATED) {
            long t = ((Timestamp) getOnlyElement(values.getValues())).getTime();
            doc.add(new NumericDocValuesField(UPDATED_SORT_FIELD, t));
        }
    }
    if (type == FieldType.INTEGER || type == FieldType.INTEGER_RANGE) {
        for (Object value : values.getValues()) {
            doc.add(new IntField(name, (Integer) value, store));
        }
    } else if (type == FieldType.LONG) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, (Long) value, store));
        }
    } else if (type == FieldType.TIMESTAMP) {
        for (Object value : values.getValues()) {
            doc.add(new LongField(name, ((Timestamp) value).getTime(), store));
        }
    } else if (type == FieldType.EXACT || type == FieldType.PREFIX) {
        for (Object value : values.getValues()) {
            doc.add(new StringField(name, (String) value, store));
        }
    } else if (type == FieldType.FULL_TEXT) {
        for (Object value : values.getValues()) {
            doc.add(new TextField(name, (String) value, store));
        }
    } else if (type == FieldType.STORED_ONLY) {
        for (Object value : values.getValues()) {
            doc.add(new StoredField(name, (byte[]) value));
        }
    } else {
        throw FieldType.badFieldType(type);
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferences.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    final Grid formGrid = new Grid(11, 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(copySelfOnEmails);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    showSiteHeader = new CheckBox(Util.C.showSiteHeader());
    useFlashClipboard = new CheckBox(Util.C.useFlashClipboard());
    copySelfOnEmails = new CheckBox(Util.C.copySelfOnEmails());
    maximumPageSize = new ListBox();
    for (final short v : PAGESIZE_CHOICES) {
        maximumPageSize.addItem(Util.M.rowsPerPage(v), String.valueOf(v));
    }
    reviewCategoryStrategy = new ListBox();
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryNone(), AccountGeneralPreferences.ReviewCategoryStrategy.NONE.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryName(), AccountGeneralPreferences.ReviewCategoryStrategy.NAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryEmail(), AccountGeneralPreferences.ReviewCategoryStrategy.EMAIL.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryUsername(), AccountGeneralPreferences.ReviewCategoryStrategy.USERNAME.name());
    reviewCategoryStrategy.addItem(Util.C.messageShowInReviewCategoryAbbrev(), AccountGeneralPreferences.ReviewCategoryStrategy.ABBREV.name());
    diffView = new ListBox();
    diffView.addItem(com.google.gerrit.client.changes.Util.C.sideBySide(), AccountGeneralPreferences.DiffView.SIDE_BY_SIDE.name());
    diffView.addItem(com.google.gerrit.client.changes.Util.C.unifiedDiff(), AccountGeneralPreferences.DiffView.UNIFIED_DIFF.name());
    Date now = new Date();
    dateFormat = new ListBox();
    for (AccountGeneralPreferences.DateFormat fmt : AccountGeneralPreferences.DateFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getShortFormat()).format(now));
        r.append(" ; ");
        r.append(DateTimeFormat.getFormat(fmt.getLongFormat()).format(now));
        dateFormat.addItem(r.toString(), fmt.name());
    }
    timeFormat = new ListBox();
    for (AccountGeneralPreferences.TimeFormat fmt : AccountGeneralPreferences.TimeFormat.values()) {
        StringBuilder r = new StringBuilder();
        r.append(DateTimeFormat.getFormat(fmt.getFormat()).format(now));
        timeFormat.addItem(r.toString(), fmt.name());
    }
    FlowPanel dateTimePanel = new FlowPanel();
    final int labelIdx;
    final int fieldIdx;
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
        dateTimePanel.add(timeFormat);
        dateTimePanel.add(dateFormat);
    } else {
        labelIdx = 0;
        fieldIdx = 1;
        dateTimePanel.add(dateFormat);
        dateTimePanel.add(timeFormat);
    }
    relativeDateInChangeTable = new CheckBox(Util.C.showRelativeDateInChangeTable());
    sizeBarInChangeTable = new CheckBox(Util.C.showSizeBarInChangeTable());
    legacycidInChangeTable = new CheckBox(Util.C.showLegacycidInChangeTable());
    muteCommonPathPrefixes = new CheckBox(Util.C.muteCommonPathPrefixes());
    boolean flashClippy = !UserAgent.hasJavaScriptClipboard() && UserAgent.Flash.isInstalled();
    final Grid formGrid = new Grid(10 + (flashClippy ? 1 : 0), 2);
    int row = 0;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, showSiteHeader);
    row++;
    if (flashClippy) {
        formGrid.setText(row, labelIdx, "");
        formGrid.setWidget(row, fieldIdx, useFlashClipboard);
        row++;
    }
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, copySelfOnEmails);
    row++;
    formGrid.setText(row, labelIdx, Util.C.reviewCategoryLabel());
    formGrid.setWidget(row, fieldIdx, reviewCategoryStrategy);
    row++;
    formGrid.setText(row, labelIdx, Util.C.maximumPageSizeFieldLabel());
    formGrid.setWidget(row, fieldIdx, maximumPageSize);
    row++;
    formGrid.setText(row, labelIdx, Util.C.dateFormatLabel());
    formGrid.setWidget(row, fieldIdx, dateTimePanel);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, relativeDateInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, sizeBarInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, legacycidInChangeTable);
    row++;
    formGrid.setText(row, labelIdx, "");
    formGrid.setWidget(row, fieldIdx, muteCommonPathPrefixes);
    row++;
    formGrid.setText(row, labelIdx, Util.C.diffViewLabel());
    formGrid.setWidget(row, fieldIdx, diffView);
    add(formGrid);
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave();
        }
    });
    myMenus = new MyMenuPanel(save);
    add(myMenus);
    add(save);
    final OnEditEnabler e = new OnEditEnabler(save);
    e.listenTo(showSiteHeader);
    e.listenTo(useFlashClipboard);
    e.listenTo(copySelfOnEmails);
    e.listenTo(maximumPageSize);
    e.listenTo(dateFormat);
    e.listenTo(timeFormat);
    e.listenTo(relativeDateInChangeTable);
    e.listenTo(sizeBarInChangeTable);
    e.listenTo(legacycidInChangeTable);
    e.listenTo(muteCommonPathPrefixes);
    e.listenTo(diffView);
    e.listenTo(reviewCategoryStrategy);
}
#end_block

#method_before
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
}
#method_after
private void enable(final boolean on) {
    showSiteHeader.setEnabled(on);
    useFlashClipboard.setEnabled(on);
    copySelfOnEmails.setEnabled(on);
    maximumPageSize.setEnabled(on);
    dateFormat.setEnabled(on);
    timeFormat.setEnabled(on);
    relativeDateInChangeTable.setEnabled(on);
    sizeBarInChangeTable.setEnabled(on);
    legacycidInChangeTable.setEnabled(on);
    muteCommonPathPrefixes.setEnabled(on);
    reviewCategoryStrategy.setEnabled(on);
    diffView.setEnabled(on);
}
#end_block

#method_before
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#method_after
private void display(Preferences p) {
    showSiteHeader.setValue(p.showSiteHeader());
    useFlashClipboard.setValue(p.useFlashClipboard());
    copySelfOnEmails.setValue(p.copySelfOnEmail());
    setListBox(maximumPageSize, DEFAULT_PAGESIZE, p.changesPerPage());
    setListBox(// 
    dateFormat, // 
    AccountGeneralPreferences.DateFormat.STD, p.dateFormat());
    setListBox(// 
    timeFormat, // 
    AccountGeneralPreferences.TimeFormat.HHMM_12, p.timeFormat());
    relativeDateInChangeTable.setValue(p.relativeDateInChangeTable());
    sizeBarInChangeTable.setValue(p.sizeBarInChangeTable());
    legacycidInChangeTable.setValue(p.legacycidInChangeTable());
    muteCommonPathPrefixes.setValue(p.muteCommonPathPrefixes());
    setListBox(reviewCategoryStrategy, AccountGeneralPreferences.ReviewCategoryStrategy.NONE, p.reviewCategoryStrategy());
    setListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, p.diffView());
    display(p.my());
}
#end_block

#method_before
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setMuteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").put(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#method_after
private void doSave() {
    final AccountGeneralPreferences p = new AccountGeneralPreferences();
    p.setShowSiteHeader(showSiteHeader.getValue());
    p.setUseFlashClipboard(useFlashClipboard.getValue());
    p.setCopySelfOnEmails(copySelfOnEmails.getValue());
    p.setMaximumPageSize(getListBox(maximumPageSize, DEFAULT_PAGESIZE));
    p.setDateFormat(getListBox(dateFormat, AccountGeneralPreferences.DateFormat.STD, AccountGeneralPreferences.DateFormat.values()));
    p.setTimeFormat(getListBox(timeFormat, AccountGeneralPreferences.TimeFormat.HHMM_12, AccountGeneralPreferences.TimeFormat.values()));
    p.setRelativeDateInChangeTable(relativeDateInChangeTable.getValue());
    p.setSizeBarInChangeTable(sizeBarInChangeTable.getValue());
    p.setLegacycidInChangeTable(legacycidInChangeTable.getValue());
    p.setMuteCommonPathPrefixes(muteCommonPathPrefixes.getValue());
    p.setReviewCategoryStrategy(getListBox(reviewCategoryStrategy, ReviewCategoryStrategy.NONE, ReviewCategoryStrategy.values()));
    p.setDiffView(getListBox(diffView, AccountGeneralPreferences.DiffView.SIDE_BY_SIDE, AccountGeneralPreferences.DiffView.values()));
    enable(false);
    save.setEnabled(false);
    List<TopMenuItem> items = new ArrayList<>();
    for (List<String> v : myMenus.getValues()) {
        items.add(TopMenuItem.create(v.get(0), v.get(1)));
    }
    AccountApi.self().view("preferences").put(Preferences.create(p, items), new GerritCallback<Preferences>() {

        @Override
        public void onSuccess(Preferences prefs) {
            Gerrit.getUserAccount().setGeneralPreferences(p);
            Gerrit.applyUserPreferences();
            enable(true);
            display(prefs);
            Gerrit.refreshMenuBar();
        }

        @Override
        public void onFailure(Throwable caught) {
            enable(true);
            save.setEnabled(true);
            super.onFailure(caught);
        }
    });
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections();
    comments.load(base, revision, path, group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.set_name(edit.commit().commit());
                info.set_edit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.current_revision();
            boolean current = currentRevision != null && revision.getId() == currentRevision;
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            diffTable.set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new CommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), changeStatus.isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    }));
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    CallbackGroup group1 = new CallbackGroup();
    final CallbackGroup group2 = new CallbackGroup();
    CodeMirror.initLibrary(group1.add(new AsyncCallback<Void>() {

        final AsyncCallback<Void> themeCallback = group2.addEmpty();

        @Override
        public void onSuccess(Void result) {
            // Load theme after CM library to ensure theme can override CSS.
            ThemeLoader.loadTheme(prefs.theme(), themeCallback);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    DiffApi.diff(revision, path).base(base).wholeFile().intraline(prefs.intralineDifference()).ignoreWhitespace(prefs.ignoreWhitespace()).get(group1.addFinal(new GerritCallback<DiffInfo>() {

        final AsyncCallback<Void> modeInjectorCb = group2.addEmpty();

        @Override
        public void onSuccess(DiffInfo diffInfo) {
            diff = diffInfo;
            fileSize = bucketFileSize(diffInfo);
            if (prefs.syntaxHighlighting()) {
                if (fileSize.compareTo(FileSize.SMALL) > 0) {
                    modeInjectorCb.onSuccess(null);
                } else {
                    injectMode(diffInfo, modeInjectorCb);
                }
            } else {
                modeInjectorCb.onSuccess(null);
            }
        }
    }));
    if (Gerrit.isSignedIn()) {
        ChangeApi.edit(changeId.get(), group2.add(new AsyncCallback<EditInfo>() {

            @Override
            public void onSuccess(EditInfo result) {
                edit = result;
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        }));
    }
    final CommentsCollections comments = new CommentsCollections();
    comments.load(base, revision, path, group2);
    RestApi call = ChangeApi.detail(changeId.get());
    ChangeList.addOptions(call, EnumSet.of(ListChangesOption.ALL_REVISIONS));
    call.get(group2.add(new AsyncCallback<ChangeInfo>() {

        @Override
        public void onSuccess(ChangeInfo info) {
            changeStatus = info.status();
            info.revisions().copyKeysIntoChildren("name");
            if (edit != null) {
                edit.set_name(edit.commit().commit());
                info.set_edit(edit);
                info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
            }
            String currentRevision = info.current_revision();
            boolean current = currentRevision != null && revision.get() == info.revision(currentRevision)._number();
            JsArray<RevisionInfo> list = info.revisions().values();
            RevisionInfo.sortRevisionInfoByNumber(list);
            diffTable.set(prefs, list, diff, edit != null, current, changeStatus.isOpen(), diff.binary());
            header.setChangeInfo(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
    ConfigInfoCache.get(changeId, group2.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(SideBySide.this) {

        @Override
        protected void preDisplay(ConfigInfoCache.Entry result) {
            commentManager = new CommentManager(SideBySide.this, base, revision, path, result.getCommentLinkProcessor(), changeStatus.isOpen());
            setTheme(result.getTheme());
            display(comments);
        }
    }));
}
#end_block

#method_before
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    if (user.isIdentifiedUser()) {
        out.submittable = submit.submittable(cd, (IdentifiedUser) user);
    } else {
        out.submittable = false;
    }
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = ((IdentifiedUser) user).getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#method_after
private ChangeInfo toChangeInfo(ChangeData cd, Optional<PatchSet.Id> limitToPsId) throws PatchListNotAvailableException, OrmException, IOException {
    ChangeInfo out = new ChangeInfo();
    if (has(CHECK)) {
        out.problems = checkerProvider.get().check(cd.change(), fix).problems();
        // If any problems were fixed, the ChangeData needs to be reloaded.
        for (ProblemInfo p : out.problems) {
            if (p.status == ProblemInfo.Status.FIXED) {
                cd = changeDataFactory.create(cd.db(), cd.getId());
                break;
            }
        }
    }
    Change in = cd.change();
    CurrentUser user = userProvider.get();
    ChangeControl ctl = cd.changeControl().forUser(user);
    out.project = in.getProject().get();
    out.branch = in.getDest().getShortName();
    out.topic = in.getTopic();
    out.hashtags = ctl.getNotes().load().getHashtags();
    out.changeId = in.getKey().get();
    // TODO(dborowitz): This gets the submit type, so we could include that in
    // the response and avoid making a request to /submit_type from the UI.
    out.mergeable = in.getStatus() == Change.Status.MERGED ? null : cd.isMergeable();
    out.submittable = submit.submittable(cd);
    ChangedLines changedLines = cd.changedLines();
    if (changedLines != null) {
        out.insertions = changedLines.insertions;
        out.deletions = changedLines.deletions;
    }
    out.subject = in.getSubject();
    out.status = in.getStatus().asChangeStatus();
    out.owner = accountLoader.get(in.getOwner());
    out.created = in.getCreatedOn();
    out.updated = in.getLastUpdatedOn();
    out._number = in.getId().get();
    out.starred = user.getStarredChanges().contains(in.getId()) ? true : null;
    if (in.getStatus().isOpen() && has(REVIEWED) && user.isIdentifiedUser()) {
        Account.Id accountId = ((IdentifiedUser) user).getAccountId();
        out.reviewed = cd.reviewedBy().contains(accountId) ? true : null;
    }
    out.labels = labelsFor(ctl, cd, has(LABELS), has(DETAILED_LABELS));
    if (out.labels != null && has(DETAILED_LABELS)) {
        // list permitted labels, since users can't vote on those patch sets.
        if (!limitToPsId.isPresent() || limitToPsId.get().equals(in.currentPatchSetId())) {
            out.permittedLabels = permittedLabels(ctl, cd);
        }
        out.removableReviewers = removableReviewers(ctl, out.labels.values());
    }
    boolean needMessages = has(MESSAGES);
    boolean needRevisions = has(ALL_REVISIONS) || has(CURRENT_REVISION) || limitToPsId.isPresent();
    Map<PatchSet.Id, PatchSet> src;
    if (needMessages || needRevisions) {
        src = loadPatchSets(cd, limitToPsId);
    } else {
        src = null;
    }
    if (needMessages) {
        out.messages = messages(ctl, cd, src);
    }
    finish(out);
    if (needRevisions) {
        out.revisions = revisions(ctl, src);
        if (out.revisions != null) {
            for (Map.Entry<String, RevisionInfo> entry : out.revisions.entrySet()) {
                if (entry.getValue().isCurrent) {
                    out.currentRevision = entry.getKey();
                    break;
                }
            }
        }
    }
    if (has(CURRENT_ACTIONS) || has(CHANGE_ACTIONS)) {
        actionJson.addChangeActions(out, ctl);
    }
    return out;
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> changes;
    if (submitWholeTopic && !Strings.isNullOrEmpty(change.getTopic())) {
        changes = new ArrayList<>();
        for (ChangeData cd : getChangesByTopic(change.getTopic())) {
            changes.add(cd.change());
        }
    } else {
        changes = Arrays.asList(change);
    }
    ChangeSet submittedChanges = ChangeSet.create(changes);
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, submittedChanges, caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    ChangeSet submittedChanges = ChangeSet.create(change);
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, submittedChanges, caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
public boolean submittable(ChangeData cd, IdentifiedUser user) {
    return problemsForSubmittingChanges(Arrays.asList(cd), user).isEmpty();
}
#method_after
public boolean submittable(ChangeData cd) {
    try {
        MergeOp.checkSubmitRule(cd);
        return true;
    } catch (ResourceConflictException | OrmException e) {
        return false;
    }
}
#end_block

#method_before
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        checkSubmitRule(cd, cd.currentPatchSet(), false);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    List<ChangeData> changesByTopic = null;
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic)) {
        changesByTopic = getChangesByTopic(topic);
    }
    if (submitWholeTopic && !Strings.isNullOrEmpty(topic) && changesByTopic.size() > 1) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(changesByTopic.size()));
        String topicProblems = problemsForSubmittingChanges(changesByTopic, resource.getUser());
        if (topicProblems != null) {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(topicProblems).setVisible(true).setEnabled(false);
        } else {
            return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
        }
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name());
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(titlePattern.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#method_after
@Override
public UiAction.Description getDescription(RevisionResource resource) {
    PatchSet.Id current = resource.getChange().currentPatchSetId();
    String topic = resource.getChange().getTopic();
    boolean visible = !resource.getPatchSet().isDraft() && resource.getChange().getStatus().isOpen() && resource.getPatchSet().getId().equals(current) && resource.getControl().canSubmit();
    ReviewDb db = dbProvider.get();
    ChangeData cd = changeDataFactory.create(db, resource.getControl());
    try {
        MergeOp.checkSubmitRule(cd);
    } catch (ResourceConflictException e) {
        visible = false;
    } catch (OrmException e) {
        log.error("Error checking if change is submittable", e);
        throw new OrmRuntimeException("Could not determine problems for the change", e);
    }
    if (!visible) {
        return new UiAction.Description().setLabel("").setTitle("").setVisible(false);
    }
    Boolean enabled;
    try {
        enabled = cd.isMergeable();
    } catch (OrmException e) {
        throw new OrmRuntimeException("Could not determine mergeability", e);
    }
    ChangeSet cs;
    try {
        cs = mergeSuperSet.completeChangeSet(db, ChangeSet.create(cd.change()));
    } catch (OrmException | IOException e) {
        throw new OrmRuntimeException("Could not determine complete set of " + "changes to be submitted", e);
    }
    int topicSize = 0;
    if (!Strings.isNullOrEmpty(topic)) {
        topicSize = getChangesByTopic(topic).size();
    }
    boolean treatWithTopic = submitWholeTopic && !Strings.isNullOrEmpty(topic) && topicSize > 1;
    String submitProblems = problemsForSubmittingChangeset(cs, resource.getUser());
    if (submitProblems != null) {
        return new UiAction.Description().setLabel(treatWithTopic ? submitTopicLabel : label).setTitle(submitProblems).setVisible(true).setEnabled(false);
    }
    if (treatWithTopic) {
        Map<String, String> params = ImmutableMap.of("topicSize", String.valueOf(topicSize), "submitSize", String.valueOf(cs.size()));
        return new UiAction.Description().setLabel(submitTopicLabel).setTitle(Strings.emptyToNull(submitTopicTooltip.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    } else {
        RevId revId = resource.getPatchSet().getRevision();
        Map<String, String> params = ImmutableMap.of("patchSet", String.valueOf(resource.getPatchSet().getPatchSetId()), "branch", resource.getChange().getDest().getShortName(), "commit", ObjectId.fromString(revId.get()).abbreviate(7).name(), "submitSize", String.valueOf(cs.size()));
        ParameterizedString tp = cs.size() > 1 ? titlePatternWithAncestors : titlePattern;
        return new UiAction.Description().setLabel(label).setTitle(Strings.emptyToNull(tp.replace(params))).setVisible(true).setEnabled(Boolean.TRUE.equals(enabled));
    }
}
#end_block

#method_before
@Test
public void patch() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeApi changeApi = gApi.changes().id(r.getChangeId());
    BinaryResult bin = changeApi.revision(r.getCommit().name()).patch();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), StandardCharsets.UTF_8);
    DateFormat dateFormat = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z");
    String date = dateFormat.format(changeApi.get().updated);
    assertThat(res).isEqualTo(String.format(PATCH, r.getCommitId().name(), date, r.getChangeId()));
}
#method_after
@Test
public void patch() throws Exception {
    PushOneCommit.Result r = createChange();
    ChangeApi changeApi = gApi.changes().id(r.getChangeId());
    BinaryResult bin = changeApi.revision(r.getCommit().name()).patch();
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    bin.writeTo(os);
    String res = new String(os.toByteArray(), StandardCharsets.UTF_8);
    DateFormat dateFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss Z");
    ChangeInfo change = changeApi.get();
    RevisionInfo rev = change.revisions.get(change.currentRevision);
    String date = dateFormat.format(rev.commit.author.date);
    assertThat(res).isEqualTo(String.format(PATCH, r.getCommitId().name(), date, r.getChangeId()));
}
#end_block

#method_before
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, List<WebLinkInfo> webLinks) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (!sideA && Gerrit.isSignedIn() && meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createEditIcon());
    }
    if (webLinks != null) {
        for (WebLinkInfo weblink : webLinks) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            linkPanel.add(a);
        }
    }
}
#method_after
void setUpPatchSetNav(JsArray<RevisionInfo> list, DiffInfo.FileMeta meta, List<WebLinkInfo> webLinks, boolean editExists, int currentPatchSet) {
    InlineHyperlink baseLink = null;
    InlineHyperlink selectedLink = null;
    if (sideA) {
        baseLink = createLink(PatchUtil.C.patchBase(), null);
        linkPanel.add(baseLink);
    }
    for (int i = 0; i < list.length(); i++) {
        RevisionInfo r = list.get(i);
        InlineHyperlink link = createLink(r.id(), new PatchSet.Id(changeId, r._number()));
        linkPanel.add(link);
        if (revision != null && r.id().equals(revision.getId())) {
            selectedLink = link;
        }
    }
    if (selectedLink != null) {
        selectedLink.setStyleName(style.selected());
    } else if (sideA) {
        baseLink.setStyleName(style.selected());
    }
    if (meta != null && !Patch.COMMIT_MSG.equals(path)) {
        linkPanel.add(createDownloadLink());
    }
    if (Gerrit.isSignedIn() && meta != null && !Patch.COMMIT_MSG.equals(path)) {
        PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
        if ((editExists && id.get() == 0) || !editExists && id.get() == currentPatchSet) {
            linkPanel.add(createEditIcon());
        }
    }
    if (webLinks != null) {
        for (WebLinkInfo weblink : webLinks) {
            Anchor a = new Anchor();
            a.setHref(weblink.url());
            if (weblink.target() != null && !weblink.target().isEmpty()) {
                a.setTarget(weblink.target());
            }
            if (weblink.imageUrl() != null && !weblink.imageUrl().isEmpty()) {
                Image img = new Image();
                img.setAltText(weblink.name());
                img.setUrl(weblink.imageUrl());
                img.setTitle(weblink.name());
                a.getElement().appendChild(img.getElement());
            } else {
                a.setText("(" + weblink.name() + ")");
            }
            linkPanel.add(a);
        }
    }
}
#end_block

#method_before
private Widget createEditIcon() {
    Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            // TODO(davido): We need to pass here the info if edit exists and
            // pass 0 ps id in this case to retrieve the content from the edit
            // and not from the patch set the edit is based on. But it's OK to
            // do that later, because normal workflow is to go to normal ps,
            // open SBS2 screen, modify file, save it: change screen is reloaded
            // and now the change edit is loaded. So the subsequent changes are
            // done on edit and not on regular patch set.
            final PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
            ChangeFileApi.getContent(id, path, new GerritCallback<String>() {

                @Override
                public void onSuccess(String result) {
                    EditFileAction edit = new EditFileAction(id, result, path, style.replyBox(), null, icon);
                    edit.onEdit();
                }
            });
        }
    });
    return anchor;
}
#method_after
private Widget createEditIcon() {
    Anchor anchor = new Anchor(new ImageResourceRenderer().render(Gerrit.RESOURCES.edit()));
    anchor.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            final PatchSet.Id id = (idActive == null) ? other.idActive : idActive;
            ChangeFileApi.getContent(id, path, new GerritCallback<String>() {

                @Override
                public void onSuccess(String result) {
                    EditFileAction edit = new EditFileAction(id, result, path, style.replyBox(), null, icon);
                    edit.onEdit();
                }
            });
        }
    });
    anchor.setTitle(PatchUtil.C.edit());
    return anchor;
}
#end_block

#method_before
public void merge(ReviewDb db, ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    this.db = db;
    logDebug("Beginning merge of {}", changes);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Checking permissions");
            checkPermissions(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#method_after
public void merge(ReviewDb db, ChangeSet changes, IdentifiedUser caller, boolean checkSubmitRules) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    this.db = db;
    logDebug("Beginning merge of {}", changes);
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkSubmitRules) {
            logDebug("Checking submit rules and state");
            checkSubmitRulesAndState(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    }
}
#end_block

#method_before
private void setMerged(Change c, ChangeMessage msg, ObjectId mergeResultRev) throws OrmException, IOException {
    logDebug("Setting change {} merged", c.getId());
    ChangeUpdate update = null;
    final PatchSetApproval submitter;
    PatchSet merged;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id mergedId = commit.change().currentPatchSetId();
        merged = db.patchSets().get(mergedId);
        c = setMergedPatchSet(c.getId(), mergedId);
        submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // did this in the past.
        if (msg != null) {
            cmUtil.addChangeMessage(db, update, msg);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    final Change change = c;
    try {
        threadScoper.scope(new Callable<Void>() {

            @Override
            public Void call() throws Exception {
                sendMergedEmail(change, submitter);
                return null;
            }
        }).call();
    } catch (Exception e) {
        logError("internal server error", e);
    }
    indexer.index(db, c);
    if (submitter != null && mergeResultRev != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#method_after
private void setMerged(Change c, ChangeMessage msg, ObjectId mergeResultRev) throws OrmException, IOException {
    logDebug("Setting change {} merged", c.getId());
    ChangeUpdate update = null;
    final PatchSetApproval submitter;
    PatchSet merged;
    try {
        db.changes().beginTransaction(c.getId());
        // We must pull the patchset out of commits, because the patchset ID is
        // modified when using the cherry-pick merge strategy.
        CodeReviewCommit commit = commits.get(c.getId());
        PatchSet.Id mergedId = commit.change().currentPatchSetId();
        merged = db.patchSets().get(mergedId);
        c = setMergedPatchSet(c.getId(), mergedId);
        submitter = approvalsUtil.getSubmitter(db, commit.notes(), mergedId);
        ChangeControl control = commit.getControl();
        update = updateFactory.create(control, c.getLastUpdatedOn());
        // did this in the past.
        if (msg != null) {
            cmUtil.addChangeMessage(db, update, msg);
        }
        db.commit();
    } finally {
        db.rollback();
    }
    update.commit();
    indexer.index(db, c);
    try {
        mergedSenderFactory.create(c.getId(), submitter != null ? submitter.getAccountId() : null).sendAsync();
    } catch (Exception e) {
        log.error("Cannot email merged notification for " + c.getId(), e);
    }
    if (submitter != null && mergeResultRev != null) {
        try {
            hooks.doChangeMergedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), merged, db, mergeResultRev.name());
        } catch (OrmException ex) {
            logError("Cannot run hook for submitted patch set " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
public static final Set<String> plugins() {
    return Natives.keys(screens());
}
#method_after
public static final Set<String> plugins() {
    return Natives.keys(settingsScreens());
}
#end_block

#method_before
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel) || matchPrefix(ProjectScreen.BRANCH, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#method_after
private static void admin(String token) {
    GWT.runAsync(new AsyncSplit(token) {

        @Override
        public void onSuccess() {
            if (matchExact(ADMIN_GROUPS, token) || matchExact("/admin/groups", token)) {
                Gerrit.display(token, new GroupListScreen());
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                } else {
                    group();
                }
            } else if (matchPrefix("/admin/groups", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new GroupListScreen(rest.substring(1)));
                }
            } else if (matchExact(ADMIN_PROJECTS, token) || matchExact("/admin/projects", token)) {
                Gerrit.display(token, new ProjectListScreen());
            } else if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                } else {
                    Gerrit.display(token, selectProject());
                }
            } else if (matchPrefix("/admin/projects", token)) {
                String rest = skip(token);
                if (rest.startsWith("?")) {
                    Gerrit.display(token, new ProjectListScreen(rest.substring(1)));
                }
            } else if (matchPrefix(ADMIN_PLUGINS, token) || matchExact("/admin/plugins", token)) {
                Gerrit.display(token, new PluginListScreen());
            } else if (matchExact(ADMIN_CREATE_PROJECT, token) || matchExact("/admin/create-project", token)) {
                Gerrit.display(token, new CreateProjectScreen());
            } else if (matchExact(ADMIN_CREATE_GROUP, token) || matchExact("/admin/create-group", token)) {
                Gerrit.display(token, new CreateGroupScreen());
            } else {
                Gerrit.display(token, new NotFoundScreen());
            }
        }

        private void group() {
            final String panel;
            final String group;
            if (matchPrefix("/admin/groups/uuid-", token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else if (matchPrefix(ADMIN_GROUPS, token)) {
                String p = skip(token);
                int c = p.indexOf(',');
                if (c < 0) {
                    group = p;
                    panel = null;
                } else {
                    group = p.substring(0, c);
                    panel = p.substring(c + 1);
                }
            } else {
                Gerrit.display(token, new NotFoundScreen());
                return;
            }
            GroupApi.getGroupDetail(group, new GerritCallback<GroupInfo>() {

                @Override
                public void onSuccess(GroupInfo group) {
                    if (panel == null || panel.isEmpty()) {
                        // 
                        if (AccountGroup.isInternalGroup(group.getGroupUUID())) {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.MEMBERS), new AccountGroupMembersScreen(group, token));
                        } else {
                            Gerrit.display(toGroup(group.getGroupId(), AccountGroupScreen.INFO), new AccountGroupInfoScreen(group, token));
                        }
                    } else if (AccountGroupScreen.INFO.equals(panel)) {
                        Gerrit.display(token, new AccountGroupInfoScreen(group, token));
                    } else if (AccountGroupScreen.MEMBERS.equals(panel)) {
                        Gerrit.display(token, new AccountGroupMembersScreen(group, token));
                    } else if (AccountGroupScreen.AUDIT_LOG.equals(panel)) {
                        Gerrit.display(token, new AccountGroupAuditLogScreen(group, token));
                    } else {
                        Gerrit.display(token, new NotFoundScreen());
                    }
                }
            });
        }

        private Screen selectProject() {
            if (matchPrefix(ADMIN_PROJECTS, token)) {
                String rest = skip(token);
                int c = rest.lastIndexOf(',');
                if (c < 0) {
                    return new ProjectInfoScreen(Project.NameKey.parse(rest));
                } else if (c == 0) {
                    return new NotFoundScreen();
                }
                int q = rest.lastIndexOf('?');
                if (q > 0 && rest.lastIndexOf(',', q) > 0) {
                    c = rest.substring(0, q - 1).lastIndexOf(',');
                }
                Project.NameKey k = Project.NameKey.parse(rest.substring(0, c));
                String panel = rest.substring(c + 1);
                if (ProjectScreen.INFO.equals(panel)) {
                    return new ProjectInfoScreen(k);
                }
                if (ProjectScreen.BRANCH.equals(panel) || matchPrefix(ProjectScreen.BRANCH, panel)) {
                    return new ProjectBranchesScreen(k);
                }
                if (ProjectScreen.ACCESS.equals(panel)) {
                    return new ProjectAccessScreen(k);
                }
                if (ProjectScreen.DASHBOARDS.equals(panel)) {
                    return new ProjectDashboardsScreen(k);
                }
            }
            return new NotFoundScreen();
        }
    });
}
#end_block

#method_before
public static void init() {
    init0();
    ActionContext.init();
    HtmlTemplate.init();
    Plugin.init();
    addHistoryHook();
}
#method_after
public static void init() {
    init0();
    ActionContext.init();
    HtmlTemplate.init();
    Plugin.init();
}
#end_block

#method_before
public AccessToken getAccessToken(String authorizationCode) throws UAAClientException {
    OAuthRequest request = new OAuthRequest(POST, accessTokenEndpoint);
    request.addHeader(AUTHORIZATION_HEADER, clientCredentials);
    request.addBodyParameter(GRANT_TYPE, BY_AUTHORIZATION_CODE);
    request.addBodyParameter(CODE, authorizationCode);
    request.addBodyParameter(REDIRECT_URI, redirectUrl);
    Response response = request.send();
    if (response.getCode() != 200) {
        throw new UAAClientException(MessageFormat.format("POST /oauth/token failed with status {0}", response.getCode()));
    }
    return parseAccessTokenResponse(response.getBody());
}
#method_after
public AccessToken getAccessToken(String authorizationCode) throws UAAClientException {
    OAuthRequest request = new OAuthRequest(POST, accessTokenEndpoint);
    request.addHeader(AUTHORIZATION_HEADER, clientCredentials);
    request.addBodyParameter(GRANT_TYPE, BY_AUTHORIZATION_CODE);
    request.addBodyParameter(CODE, authorizationCode);
    request.addBodyParameter(REDIRECT_URI, redirectUrl);
    Response response = request.send();
    if (response.getCode() != HTTP_OK) {
        throw new UAAClientException(MessageFormat.format("POST /oauth/token failed with status {0}", response.getCode()));
    }
    return parseAccessTokenResponse(response.getBody());
}
#end_block

#method_before
private SignatureVerifier createSignatureVerifier() throws UAAClientException {
    OAuthRequest request = new OAuthRequest(GET, tokenKeyEndpoint);
    request.addHeader(AUTHORIZATION_HEADER, clientCredentials);
    Response response = request.send();
    if (response.getCode() != 200) {
        throw new UAAClientException(MessageFormat.format("GET /token_key failed with status {0}", response.getCode()));
    }
    JsonObject content = getAsJsonObject(response.getBody());
    String alg = getAttribute(content, ALG_ATTRIBUTE);
    if (Strings.isNullOrEmpty(alg)) {
        throw new UAAClientException("GET /uaa/token_key failed: missing \"alg\" attribute");
    }
    if ("HMACSHA256".equals(alg)) {
        return new HMACSHA256SignatureVerifier(getAttribute(content, VALUE_ATTRIBUTE));
    } else if ("SHA256withRSA".equals(alg)) {
        return new SHA265WithRSASignatureVerifier(getAttribute(content, MODULUS_ATTRIBUTE), getAttribute(content, PUBLIC_EXPONENT_ATTRIBUTE));
    }
    throw new UAAClientException(MessageFormat.format("Unsupported signature algorithm ''{0}''", alg));
}
#method_after
private SignatureVerifier createSignatureVerifier() throws UAAClientException {
    OAuthRequest request = new OAuthRequest(GET, tokenKeyEndpoint);
    request.addHeader(AUTHORIZATION_HEADER, clientCredentials);
    Response response = request.send();
    if (response.getCode() != HTTP_OK) {
        throw new UAAClientException(MessageFormat.format("GET /token_key failed with status {0}", response.getCode()));
    }
    JsonObject content = getAsJsonObject(response.getBody());
    String alg = getAttribute(content, ALG_ATTRIBUTE);
    if (Strings.isNullOrEmpty(alg)) {
        throw new UAAClientException("GET /uaa/token_key failed: missing \"alg\" attribute");
    }
    if ("HMACSHA256".equals(alg)) {
        return new HMACSHA256SignatureVerifier(getAttribute(content, VALUE_ATTRIBUTE));
    } else if ("SHA256withRSA".equals(alg)) {
        return new SHA265WithRSASignatureVerifier(getAttribute(content, MODULUS_ATTRIBUTE), getAttribute(content, PUBLIC_EXPONENT_ATTRIBUTE));
    }
    throw new UAAClientException(MessageFormat.format("Unsupported signature algorithm ''{0}''", alg));
}
#end_block

#method_before
public String getUserName() {
    return userName;
}
#method_after
public String getUserName() {
    return username;
}
#end_block

#method_before
@Override
public String toString() {
    return "{'value':'" + value + "','externalId':'" + externalId + "','userName':'" + userName + "','emailAddress':'" + emailAddress + "','expiresAt':" + expiresAt + "}";
}
#method_after
@Override
public String toString() {
    return "{'value':'" + value + "','externalId':'" + externalId + "','userName':'" + username + "','emailAddress':'" + emailAddress + "','expiresAt':" + expiresAt + "}";
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj)
        return true;
    if (!(obj instanceof AccessToken))
        return false;
    AccessToken other = (AccessToken) obj;
    if (value == null) {
        return other.value == null;
    }
    return value.equals(other.value);
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof AccessToken)) {
        return false;
    }
    return Objects.equals(value, ((AccessToken) obj).value);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    HorizontalPanel h = new HorizontalPanel();
    add(h);
    VerticalPanel v = new VerticalPanel();
    v.addStyleName(Gerrit.RESOURCES.css().avatarInfoPanel());
    h.add(v);
    avatar = new AvatarImage();
    v.add(avatar);
    changeAvatar = new Anchor(Util.C.changeAvatar(), "", "_blank");
    changeAvatar.setVisible(false);
    v.add(changeAvatar);
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    info = new Grid((Gerrit.info().auth().siteHasUsernames() ? 1 : 0) + 4, 2);
    info.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    info.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    h.add(info);
    int row = 0;
    if (Gerrit.info().auth().siteHasUsernames()) {
        infoRow(row++, Util.C.userName());
    }
    infoRow(row++, Util.C.fullName());
    infoRow(row++, Util.C.preferredEmail());
    infoRow(row++, Util.C.registeredOn());
    infoRow(row++, Util.C.accountId());
    final CellFormatter fmt = info.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    HorizontalPanel h = new HorizontalPanel();
    add(h);
    if (Gerrit.info().plugin().hasAvatars()) {
        VerticalPanel v = new VerticalPanel();
        v.addStyleName(Gerrit.RESOURCES.css().avatarInfoPanel());
        h.add(v);
        avatar = new AvatarImage();
        v.add(avatar);
        changeAvatar = new Anchor(Util.C.changeAvatar(), "", "_blank");
        changeAvatar.setVisible(false);
        v.add(changeAvatar);
    }
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    info = new Grid((Gerrit.info().auth().siteHasUsernames() ? 1 : 0) + 4, 2);
    info.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    info.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    h.add(info);
    int row = 0;
    if (Gerrit.info().auth().siteHasUsernames()) {
        infoRow(row++, Util.C.userName());
    }
    infoRow(row++, Util.C.fullName());
    infoRow(row++, Util.C.preferredEmail());
    infoRow(row++, Util.C.registeredOn());
    infoRow(row++, Util.C.accountId());
    final CellFormatter fmt = info.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
}
#end_block

#method_before
@Override
protected void onLoad() {
    super.onLoad();
    add(new ExtensionPanel(GerritUiExtensionPoint.PROFILE_SCREEN));
    display(Gerrit.getUserAccount());
    display();
}
#method_after
@Override
protected void onLoad() {
    super.onLoad();
    add(new ExtensionPanel(GerritUiExtensionPoint.PROFILE_SCREEN_BOTTOM));
    display(Gerrit.getUserAccount());
    display();
}
#end_block

#method_before
void display(final Account account) {
    avatar.setAccount(FormatUtil.asInfo(account), 93, false);
    new RestApi("/accounts/").id("self").view("avatar.change.url").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString changeUrl) {
            changeAvatar.setHref(changeUrl.asString());
            changeAvatar.setVisible(true);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
    int row = 0;
    if (Gerrit.info().auth().siteHasUsernames()) {
        info.setWidget(row++, fieldIdx, new UsernameField());
    }
    info.setText(row++, fieldIdx, account.getFullName());
    info.setText(row++, fieldIdx, account.getPreferredEmail());
    info.setText(row++, fieldIdx, mediumFormat(account.getRegisteredOn()));
    info.setText(row, fieldIdx, account.getId().toString());
}
#method_after
void display(final Account account) {
    if (Gerrit.info().plugin().hasAvatars()) {
        avatar.setAccount(FormatUtil.asInfo(account), 93, false);
        new RestApi("/accounts/").id("self").view("avatar.change.url").get(new AsyncCallback<NativeString>() {

            @Override
            public void onSuccess(NativeString changeUrl) {
                changeAvatar.setHref(changeUrl.asString());
                changeAvatar.setVisible(true);
            }

            @Override
            public void onFailure(Throwable caught) {
            }
        });
    }
    int row = 0;
    if (Gerrit.info().auth().siteHasUsernames()) {
        info.setWidget(row++, fieldIdx, new UsernameField());
    }
    info.setText(row++, fieldIdx, account.getFullName());
    info.setText(row++, fieldIdx, account.getPreferredEmail());
    info.setText(row++, fieldIdx, mediumFormat(account.getRegisteredOn()));
    info.setText(row, fieldIdx, account.getId().toString());
}
#end_block

#method_before
public static void init() {
    init0();
    ActionContext.init();
    HtmlTemplate.init();
    Plugin.init();
    addHistoryHook();
}
#method_after
public static void init() {
    init0();
    ActionContext.init();
    HtmlTemplate.init();
    Plugin.init();
}
#end_block

#method_before
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account a) {
    if (!a.isActive()) {
        return false;
    }
    return addActive(map, a.getId());
}
#method_after
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account a) {
    if (!a.isActive()) {
        return false;
    }
    Account.Id id = a.getId();
    if (!map.containsKey(id) && accountControl.canSee(id)) {
        map.put(id, accountLoader.get(id));
        return true;
    }
    return false;
}
#end_block

#method_before
private boolean addSuggestion(Map<Id, AccountInfo> map, Id id) throws OrmException {
    Account a = db.accounts().get(id);
    return addSuggestion(map, a);
}
#method_after
private boolean addSuggestion(Map<Account.Id, AccountInfo> map, Account.Id id) {
    Account a = accountCache.get(id).getAccount();
    return addSuggestion(map, a);
}
#end_block

#method_before
@Override
public final String getCommand(DownloadScheme scheme, String project, String ref) {
    if (commandAllowed && isRecognizedScheme(scheme)) {
        String url = scheme.getUrl(project);
        if (url != null && isValidUrl(url)) {
            return getCommand(url, resolveRef(project, ref));
        }
    }
    return null;
}
#method_after
@Override
public final String getCommand(DownloadScheme scheme, String project, String ref) {
    if (commandAllowed && isRecognizedScheme(scheme)) {
        String url = scheme.getUrl(project);
        if (url != null && isValidUrl(url)) {
            if (checkForHiddenChangeRefs) {
                ref = resolveRef(project, ref);
            }
            if (ref != null) {
                return getCommand(url, ref);
            }
        }
    }
    return null;
}
#end_block

#method_before
private String resolveRef(String project, String ref) {
    try (Repository repo = repoManager.openRepository(new Project.NameKey(project))) {
        Config cfg = repo.getConfig();
        if (cfg.getBoolean(UPLOADPACK, KEY_ALLOW_TIP_SHA1_IN_WANT, false) && Arrays.asList(cfg.getStringList(UPLOADPACK, null, KEY_HIDE_REFS)).contains(RefNames.REFS_CHANGES)) {
            ObjectId id = repo.resolve(ref);
            if (id != null) {
                return id.name();
            } else {
                log.error(String.format("Cannot resolve ref %s in project %s.", ref, project));
            }
        }
    } catch (IOException e) {
        log.error(String.format("Missing project: %s", project), e);
    }
    return ref;
}
#method_after
private String resolveRef(String project, String ref) {
    if (project.startsWith("$") || ref.startsWith("$")) {
        // No real value but placeholders are being used.
        return ref;
    }
    try (Repository repo = repoManager.openRepository(new Project.NameKey(project))) {
        Config cfg = repo.getConfig();
        if (cfg.getBoolean(UPLOADPACK, KEY_ALLOW_TIP_SHA1_IN_WANT, false) && Arrays.asList(cfg.getStringList(UPLOADPACK, null, KEY_HIDE_REFS)).contains(RefNames.REFS_CHANGES)) {
            ObjectId id = repo.resolve(ref);
            if (id != null) {
                return id.name();
            } else {
                log.error(String.format("Cannot resolve ref %s in project %s.", ref, project));
                return null;
            }
        } else {
            return ref;
        }
    } catch (RepositoryNotFoundException e) {
        log.error(String.format("Missing project: %s", project), e);
        return null;
    } catch (IOException e) {
        log.error(String.format("Failed to lookup project %s from cache.", project), e);
        return null;
    }
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> changes;
    if (submitWholeTopic && !Strings.isNullOrEmpty(change.getTopic())) {
        changes = new ArrayList<>();
        for (ChangeData cd : getChangesByTopic(change.getTopic())) {
            changes.add(cd.change());
        }
    } else {
        changes = Arrays.asList(change);
    }
    ChangeSet submittedChanges = ChangeSet.create(changes);
    try (ReviewDb db = schemaFactory.open()) {
        mergeOpProvider.get().merge(db, submittedChanges, caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> changes;
    if (submitWholeTopic && !Strings.isNullOrEmpty(change.getTopic())) {
        changes = new ArrayList<>();
        for (ChangeData cd : getChangesByTopic(change.getTopic())) {
            changes.add(cd.change());
        }
    } else {
        changes = Arrays.asList(change);
    }
    ChangeSet submittedChanges = ChangeSet.create(changes);
    try {
        ReviewDb db = dbProvider.get();
        mergeOpProvider.get().merge(db, submittedChanges, caller, true);
        change = db.changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case MERGED:
            return new Output(change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball i parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball if parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#end_block

#method_before
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String cloneCommand = super.getCommand(scheme, project);
    String projectName = getBaseName(project);
    if (scheme instanceof SshScheme) {
        return new StringBuilder().append(cloneCommand).append(" && scp -p -P ").append(sshScheme.getSshdPort()).append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":" + HOOK).append(" ").append(projectName).append("/.git/hooks/").toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        return new StringBuilder().append(cloneCommand).append(" && (cd ").append(projectName).append(" && curl -kLo").append(TARGET + HOOK).append(" ").append(scheme.getUrl(project)).append("/tools/" + HOOK).append("; chmod +x").append(TARGET + HOOK).append(")").toString();
    }
    return null;
}
#method_after
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (username == null) {
        return null;
    }
    String projectName = getBaseName(project);
    if (scheme instanceof SshScheme) {
        return new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p -P ").append(sshScheme.getSshdPort()).append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":").append(HOOK).append(" ").append(projectName).append("/.git/hooks/").toString();
    }
    if (scheme instanceof HttpScheme || scheme instanceof AnonymousHttpScheme) {
        String host = getHttpHost(scheme, project);
        return new StringBuilder().append("git clone ").append(host).append(project).append(" && (cd ").append(projectName).append(" && curl -kLo").append(TARGET).append(HOOK).append(" ").append(host).append("tools/").append(HOOK).append("; chmod +x").append(TARGET).append(HOOK).append(")").toString();
    }
    return null;
}
#end_block

#method_before
@Override
public void doPut(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!isValidFile(req)) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    if (isGerritConfig(req)) {
        writeConfigFile(req, res);
    } else {
        writeFile(req, res);
    }
}
#method_after
@Override
public void doPut(HttpServletRequest req, HttpServletResponse res) throws IOException {
    if (!isValidFile(req)) {
        res.setStatus(HttpServletResponse.SC_FORBIDDEN);
        return;
    }
    if (isGerritConfig(req)) {
        writeFileAndFireAuditEvent(req, res);
    } else {
        writeFile(req, res);
    }
}
#end_block

#method_before
private void audit(String what, String path, String diff) {
    String sessionId = webSession.get().getSessionId();
    CurrentUser who = webSession.get().getCurrentUser();
    long when = TimeUtil.nowMs();
    Multimap<String, String> params = LinkedHashMultimap.create();
    params.put("plugin", pluginName);
    params.put("class", ServerConfigServlet.class.getName());
    params.put("diff", diff);
    params.put("file", path);
    auditService.dispatch(new AuditEvent(sessionId, who, what, when, params, null));
}
#method_after
private void audit(String what, String path, String diff) {
    String sessionId = webSession.get().getSessionId();
    CurrentUser who = webSession.get().getCurrentUser();
    long when = TimeUtil.nowMs();
    Multimap<String, Object> params = LinkedHashMultimap.create();
    params.put("plugin", pluginName);
    params.put("class", ServerConfigServlet.class);
    params.put("diff", diff);
    params.put("file", path);
    auditService.dispatch(new AuditEvent(sessionId, who, what, when, params, null));
}
#end_block

#method_before
private void streamFile(HttpServletRequest req, HttpServletResponse res) throws IOException {
    File f = configFile(req);
    res.setStatus(HttpServletResponse.SC_OK);
    res.setContentType("application/octet-stream");
    res.setContentLength((int) f.length());
    OutputStream out = res.getOutputStream();
    writeStreamToFile(f, out);
}
#method_after
private void streamFile(HttpServletRequest req, HttpServletResponse res) throws IOException {
    File f = configFile(req);
    res.setStatus(HttpServletResponse.SC_OK);
    res.setContentType("application/octet-stream");
    res.setContentLength((int) f.length());
    OutputStream out = res.getOutputStream();
    InputStream in = new FileInputStream(f);
    try {
        ByteStreams.copy(in, out);
    } finally {
        in.close();
    }
}
#end_block

#method_before
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(gerrit, StartIndexer.class);
    command(gerrit, ActivateIndex.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    command("git-upload-pack").to(Commands.key(git, "upload-pack"));
    command(git, "upload-pack").to(Upload.class);
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        command("git-receive-pack").to(Commands.key(git, "receive-pack"));
        command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
        command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#method_after
@Override
protected void configure() {
    final CommandName git = Commands.named("git");
    final CommandName gerrit = Commands.named("gerrit");
    CommandName index = Commands.named(gerrit, "index");
    final CommandName logging = Commands.named(gerrit, "logging");
    final CommandName plugin = Commands.named(gerrit, "plugin");
    final CommandName testSubmit = Commands.named(gerrit, "test-submit");
    command(gerrit).toProvider(new DispatchCommandProvider(gerrit));
    command(gerrit, AproposCommand.class);
    command(gerrit, BanCommitCommand.class);
    command(gerrit, CloseConnection.class);
    command(gerrit, FlushCaches.class);
    command(gerrit, ListProjectsCommand.class);
    command(gerrit, ListMembersCommand.class);
    command(gerrit, ListGroupsCommand.class);
    command(gerrit, LsUserRefs.class);
    command(gerrit, Query.class);
    command(gerrit, ShowCaches.class);
    command(gerrit, ShowConnections.class);
    command(gerrit, ShowQueue.class);
    command(gerrit, StreamEvents.class);
    command(gerrit, VersionCommand.class);
    command(gerrit, GarbageCollectionCommand.class);
    command(index).toProvider(new DispatchCommandProvider(index));
    command(index, IndexActivateCommand.class);
    command(index, IndexStartCommand.class);
    command(gerrit, "plugin").toProvider(new DispatchCommandProvider(plugin));
    command(plugin, PluginLsCommand.class);
    command(plugin, PluginEnableCommand.class);
    command(plugin, PluginInstallCommand.class);
    command(plugin, PluginReloadCommand.class);
    command(plugin, PluginRemoveCommand.class);
    alias(plugin, "add", PluginInstallCommand.class);
    alias(plugin, "rm", PluginRemoveCommand.class);
    command(git).toProvider(new DispatchCommandProvider(git));
    command("ps").to(ShowQueue.class);
    command("kill").to(KillCommand.class);
    command("scp").to(ScpCommand.class);
    // Honor the legacy hyphenated forms as aliases for the non-hyphenated forms
    if (sshEnabled()) {
        command("git-upload-pack").to(Commands.key(git, "upload-pack"));
        command(git, "upload-pack").to(Upload.class);
    }
    command("suexec").to(SuExec.class);
    listener().to(ShowCaches.StartupListener.class);
    // The following commands can only be ran on a server in Master mode
    command(gerrit, CreateAccountCommand.class);
    command(gerrit, CreateGroupCommand.class);
    command(gerrit, CreateProjectCommand.class);
    command(gerrit, AdminQueryShell.class);
    if (!slaveMode) {
        if (sshEnabled()) {
            command("git-receive-pack").to(Commands.key(git, "receive-pack"));
            command("gerrit-receive-pack").to(Commands.key(git, "receive-pack"));
            command(git, "receive-pack").to(Commands.key(gerrit, "receive-pack"));
        }
        command(gerrit, "test-submit").toProvider(new DispatchCommandProvider(testSubmit));
    }
    command(gerrit, Receive.class);
    command(gerrit, RenameGroupCommand.class);
    command(gerrit, ReviewCommand.class);
    command(gerrit, SetProjectCommand.class);
    command(gerrit, SetReviewersCommand.class);
    command(gerrit, SetMembersCommand.class);
    command(gerrit, CreateBranchCommand.class);
    command(gerrit, SetAccountCommand.class);
    command(gerrit, AdminSetParent.class);
    command(gerrit, CreateAccountCommand.class);
    command(testSubmit, TestSubmitRuleCommand.class);
    command(testSubmit, TestSubmitTypeCommand.class);
    command(logging).toProvider(new DispatchCommandProvider(logging));
    command(logging, SetLoggingLevelCommand.class);
    command(logging, ListLoggingLevelCommand.class);
    alias(logging, "ls", ListLoggingLevelCommand.class);
    alias(logging, "set", SetLoggingLevelCommand.class);
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    ui.message("Listing all changes ...");
    SetMultimap<Project.NameKey, Change.Id> openByProject = getOpenChangesByProject(db);
    ui.message("done");
    ui.message("Setting all submitted changes back to new ...");
    int i = 0;
    for (Map.Entry<Project.NameKey, Collection<Change.Id>> e : openByProject.asMap().entrySet()) {
        updateOpenChanges(db, (Set<Change.Id>) e.getValue());
        if (++i % 100 == 0) {
            ui.message("  done " + i + " projects ...");
        }
    }
    ui.message("done");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    String cmd = "UPDATE changes SET status = 'n' WHERE status = 's';";
    ui.message("Running " + cmd);
    try (StatementExecutor e = newExecutor(db)) {
        e.execute(cmd);
    }
    ui.message("done");
}
#end_block

#method_before
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    List<RevCommit> log = getRemoteLog();
    RevCommit tip = log.get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    List<RevCommit> log = getRemoteLog();
    RevCommit tip = log.get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(initialHead.getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), tip.getCommitterIdent());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#end_block

#method_before
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertNew(change2.getChangeId());
    assertNew(change3.getChangeId());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    // Change 2 stays untouched.
    approve(change2.getChangeId());
    // Change 3 is a fast-forward, no need to merge.
    submit(change3.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), tip.getCommitterIdent());
    // We need to merge change 4.
    submit(change4.getChangeId());
    tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), tip.getCommitterIdent());
    assertNew(change2.getChangeId());
}
#end_block

#method_before
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        submitWithConflict(change1b.getChangeId());
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    }
}
#method_after
@Test
public void submitChangesAcrossReposBlocked() throws Exception {
    Project.NameKey p1 = createProject("project-where-we-submit");
    Project.NameKey p2 = createProject("project-impacted-via-topic");
    Project.NameKey p3 = createProject("project-impacted-indirectly-via-topic");
    TestRepository<?> repo1 = cloneProject(p1);
    TestRepository<?> repo2 = cloneProject(p2);
    TestRepository<?> repo3 = cloneProject(p3);
    RevCommit initialHead1 = getRemoteHead(p1, "master");
    RevCommit initialHead2 = getRemoteHead(p2, "master");
    RevCommit initialHead3 = getRemoteHead(p3, "master");
    PushOneCommit.Result change1a = createChange(repo1, "master", "An ancestor of the change we want to submit", "a.txt", "1", "dependent-topic");
    PushOneCommit.Result change1b = createChange(repo1, "master", "we're interested to submit this change", "a.txt", "2", "topic-to-submit");
    PushOneCommit.Result change2a = createChange(repo2, "master", "indirection level 2a", "a.txt", "1", "topic-indirect");
    PushOneCommit.Result change2b = createChange(repo2, "master", "should go in with first change", "a.txt", "2", "dependent-topic");
    PushOneCommit.Result change3 = createChange(repo3, "master", "indirection level 2b", "a.txt", "1", "topic-indirect");
    // Create a merge conflict for change3 which is only indirectly related
    // via topics.
    repo3.reset(initialHead3);
    PushOneCommit.Result change3Conflict = createChange(repo3, "master", "conflicting change", "a.txt", "2\n2", "conflicting-topic");
    submit(change3Conflict.getChangeId());
    RevCommit tipConflict = getRemoteLog(p3, "master").get(0);
    assertThat(tipConflict.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
    approve(change1a.getChangeId());
    approve(change2a.getChangeId());
    approve(change2b.getChangeId());
    approve(change3.getChangeId());
    if (isSubmitWholeTopicEnabled()) {
        submitWithConflict(change1b.getChangeId());
    } else {
        submit(change1b.getChangeId());
    }
    RevCommit tip1 = getRemoteLog(p1, "master").get(0);
    RevCommit tip2 = getRemoteLog(p2, "master").get(0);
    RevCommit tip3 = getRemoteLog(p3, "master").get(0);
    if (isSubmitWholeTopicEnabled()) {
        assertThat(tip1.getShortMessage()).isEqualTo(initialHead1.getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change1a.getChangeId(), 1);
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    } else {
        assertThat(tip1.getShortMessage()).isEqualTo(change1b.getCommit().getShortMessage());
        assertThat(tip2.getShortMessage()).isEqualTo(initialHead2.getShortMessage());
        assertThat(tip3.getShortMessage()).isEqualTo(change3Conflict.getCommit().getShortMessage());
        assertNoSubmitter(change2a.getChangeId(), 1);
        assertNoSubmitter(change2b.getChangeId(), 1);
        assertNoSubmitter(change3.getChangeId(), 1);
    }
}
#end_block

#method_before
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, "test-topic", admin);
    change2.assertChange(Change.Status.MERGED, "test-topic", admin);
    change3.assertChange(Change.Status.MERGED, "test-topic", admin);
    assertSubmitter(change1);
    assertSubmitter(change2);
    assertSubmitter(change3);
}
#method_after
@Test
public void submitWholeTopic() throws Exception {
    assume().that(isSubmitWholeTopicEnabled()).isTrue();
    PushOneCommit.Result change1 = createChange("Change 1", "a.txt", "content", "test-topic");
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "content", "test-topic");
    PushOneCommit.Result change3 = createChange("Change 3", "c.txt", "content", "test-topic");
    approve(change1.getChangeId());
    approve(change2.getChangeId());
    approve(change3.getChangeId());
    submit(change3.getChangeId());
    change1.assertChange(Change.Status.MERGED, "test-topic", admin);
    change2.assertChange(Change.Status.MERGED, "test-topic", admin);
    change3.assertChange(Change.Status.MERGED, "test-topic", admin);
    // Check for the exact change to have the correct submitter.
    assertSubmitter(change3);
    // Also check submitters for changes submitted via the topic relationship.
    assertSubmitter(change1);
    assertSubmitter(change2);
}
#end_block

#method_before
protected void assertNew(String changeId) throws Exception {
    ChangeInfo c = get(changeId);
    assertThat(c.status).isEqualTo(ChangeStatus.NEW);
}
#method_after
protected void assertNew(String changeId) throws Exception {
    assertThat(get(changeId).status).isEqualTo(ChangeStatus.NEW);
}
#end_block

#method_before
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    ChangeSet submittedChanges = ChangeSet.create(submit(rsrc, caller, false));
    try {
        mergeOpFactory.create(submittedChanges, caller).merge(true);
        change = dbProvider.get().changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#method_after
@Override
public Output apply(RevisionResource rsrc, SubmitInput input) throws AuthException, ResourceConflictException, RepositoryNotFoundException, IOException, OrmException, UnprocessableEntityException {
    input.onBehalfOf = Strings.emptyToNull(input.onBehalfOf);
    if (input.onBehalfOf != null) {
        rsrc = onBehalfOf(rsrc, input);
    }
    ChangeControl control = rsrc.getControl();
    IdentifiedUser caller = (IdentifiedUser) control.getCurrentUser();
    Change change = rsrc.getChange();
    if (input.onBehalfOf == null && !control.canSubmit()) {
        throw new AuthException("submit not permitted");
    } else if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + status(change));
    } else if (!ProjectUtil.branchExists(repoManager, change.getDest())) {
        throw new ResourceConflictException(String.format("destination branch \"%s\" not found.", change.getDest().get()));
    } else if (!rsrc.getPatchSet().getId().equals(change.currentPatchSetId())) {
        // TODO Allow submitting non-current revision by changing the current.
        throw new ResourceConflictException(String.format("revision %s is not current revision", rsrc.getPatchSet().getRevision().get()));
    }
    List<Change> changes;
    if (submitWholeTopic && !Strings.isNullOrEmpty(change.getTopic())) {
        changes = new ArrayList<>();
        for (ChangeData cd : getChangesByTopic(change.getTopic())) {
            changes.add(cd.change());
        }
    } else {
        changes = Arrays.asList(change);
    }
    ChangeSet submittedChanges = ChangeSet.create(changes);
    try {
        mergeOpProvider.get().merge(submittedChanges, caller, true);
        change = dbProvider.get().changes().get(change.getId());
    } catch (NoSuchChangeException e) {
        throw new OrmException("Submission failed", e);
    }
    if (change == null) {
        throw new ResourceConflictException("change is deleted");
    }
    switch(change.getStatus()) {
        case SUBMITTED:
            return new Output(Status.SUBMITTED, change);
        case MERGED:
            return new Output(Status.MERGED, change);
        case NEW:
            ChangeMessage msg = getConflictMessage(rsrc);
            if (msg != null) {
                throw new ResourceConflictException(msg.getMessage());
            }
        // $FALL-THROUGH$
        default:
            throw new ResourceConflictException("change is " + status(change));
    }
}
#end_block

#method_before
private void checkPermissions(ChangeSet cs) throws ResourceConflictException, OrmException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        if (cd.change().getStatus() != Change.Status.NEW && cd.change().getStatus() != Change.Status.SUBMITTED) {
            throw new OrmException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus());
        } else {
            checkSubmitRule(cd);
        }
    }
}
#method_after
private void checkPermissions(ChangeSet cs) throws ResourceConflictException, OrmException {
    for (Change.Id id : cs.ids()) {
        ChangeData cd = changeDataFactory.create(db, id);
        if (cd.change().getStatus() != Change.Status.NEW && cd.change().getStatus() != Change.Status.SUBMITTED) {
            throw new OrmException("Change " + cd.change().getChangeId() + " is in state " + cd.change().getStatus());
        } else {
            records.put(cd.change().getId(), checkSubmitRule(cd));
        }
    }
}
#end_block

#method_before
public void merge(boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Submitting all calculated changes while " + "enforcing submit rules");
            submitAllChanges(cs, false);
            logDebug("Checking permissions");
            checkPermissions(cs);
        } else {
            logDebug("Submitting all calculated changes ignoring submit rules");
            submitAllChanges(cs, true);
        }
        try {
            integrateIntoHistory(cs);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#method_after
public void merge(ChangeSet changes, IdentifiedUser caller, boolean checkPermissions) throws NoSuchChangeException, OrmException, ResourceConflictException {
    logPrefix = String.format("[%s]: ", String.valueOf(changes.hashCode()));
    logDebug("Beginning merge of {}", changes);
    try {
        openSchema();
        ChangeSet cs = mergeSuperSet.completeChangeSet(db, changes);
        logDebug("Calculated to merge {}", cs);
        if (checkPermissions) {
            logDebug("Checking permissions");
            checkPermissions(cs);
        }
        try {
            integrateIntoHistory(cs, caller);
        } catch (MergeException e) {
            logError("Merge Conflict", e);
            throw new ResourceConflictException("Merge Conflict", e);
        }
    } catch (IOException e) {
        // Anything before the merge attempt is an error
        throw new OrmException(e);
    } finally {
        if (db != null) {
            db.close();
        }
    }
}
#end_block

#method_before
private void integrateIntoHistory(ChangeSet cs) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", changes);
    Map<Branch.NameKey, ListMultimap<SubmitType, Change>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                List<ChangeData> cds = new ArrayList<>();
                for (Change.Id id : cs.changesByBranch().get(branch)) {
                    cds.add(changeDataFactory.create(db, id));
                }
                ListMultimap<SubmitType, Change> submitting = validateChangeList(cds);
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch));
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    if (submitType != SubmitType.CHERRY_PICK) {
                        // For cherry picking we have relaxed atomic guarantees
                        // as traditionally Gerrit kept going cherry picking if one
                        // failed. We want to keep it for now.
                        updateChangeStatus(submitting.get(submitType), branch, true);
                    }
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, Change> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false);
                    updateSubscriptions(branch, submitting.get(submitType), getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#method_after
private void integrateIntoHistory(ChangeSet cs, IdentifiedUser caller) throws MergeException, NoSuchChangeException, ResourceConflictException {
    logDebug("Beginning merge attempt on {}", cs);
    Map<Branch.NameKey, ListMultimap<SubmitType, ChangeData>> toSubmit = new HashMap<>();
    try {
        openSchema();
        logDebug("Perform the merges");
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                setDestProject(branch);
                List<ChangeData> cds = new ArrayList<>();
                for (Change.Id id : cs.changesByBranch().get(branch)) {
                    cds.add(changeDataFactory.create(db, id));
                }
                ListMultimap<SubmitType, ChangeData> submitting = validateChangeList(cds);
                toSubmit.put(branch, submitting);
                Set<SubmitType> submitTypes = new HashSet<>(submitting.keySet());
                for (SubmitType submitType : submitTypes) {
                    SubmitStrategy strategy = createStrategy(branch, submitType, getBranchTip(branch), caller);
                    MergeTip mergeTip = preMerge(strategy, submitting.get(submitType), getBranchTip(branch));
                    mergeTips.put(branch, mergeTip);
                    updateChangeStatus(submitting.get(submitType), branch, true, caller);
                }
                inserter.flush();
            }
            closeRepository();
        }
        logDebug("Write out the new branch tips");
        SubmoduleOp subOp = subOpProvider.get();
        for (Project.NameKey project : cs.projects()) {
            openRepository(project);
            for (Branch.NameKey branch : cs.branchesByProject().get(project)) {
                RefUpdate update = updateBranch(branch);
                pendingRefUpdates.remove(branch);
                setDestProject(branch);
                ListMultimap<SubmitType, ChangeData> submitting = toSubmit.get(branch);
                for (SubmitType submitType : submitting.keySet()) {
                    updateChangeStatus(submitting.get(submitType), branch, false, caller);
                    updateSubmoduleSubscriptions(subOp, branch, getBranchTip(branch));
                }
                if (update != null) {
                    fireRefUpdated(branch, update);
                }
            }
            closeRepository();
        }
        updateSuperProjects(subOp, cs.branches());
        checkState(pendingRefUpdates.isEmpty(), "programmer error: " + "pending ref update list not emptied");
    } catch (NoSuchProjectException noProject) {
        logWarn("Project " + noProject.project() + " no longer exists, " + "abandoning open changes");
        abandonAllOpenChanges(noProject.project());
    } catch (OrmException e) {
        throw new MergeException("Cannot query the database", e);
    } catch (IOException e) {
        throw new MergeException("Cannot query the database", e);
    } finally {
        closeRepository();
    }
}
#end_block

#method_before
private MergeTip preMerge(SubmitStrategy strategy, List<Change> submitted, CodeReviewCommit branchTip) throws MergeException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (Change c : submitted) {
        CodeReviewCommit commit = commits.get(c.getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", c.getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#method_after
private MergeTip preMerge(SubmitStrategy strategy, List<ChangeData> submitted, CodeReviewCommit branchTip) throws MergeException, OrmException {
    logDebug("Running submit strategy {} for {} commits {}", strategy.getClass().getSimpleName(), submitted.size(), submitted);
    List<CodeReviewCommit> toMerge = new ArrayList<>(submitted.size());
    for (ChangeData cd : submitted) {
        CodeReviewCommit commit = commits.get(cd.change().getId());
        checkState(commit != null, "commit for %s not found by validateChangeList", cd.change().getId());
        toMerge.add(commit);
    }
    MergeTip mergeTip = strategy.run(branchTip, toMerge);
    refLogIdent = strategy.getRefLogIdent();
    logDebug("Produced {} new commits", strategy.getNewCommits().size());
    commits.putAll(strategy.getNewCommits());
    return mergeTip;
}
#end_block

#method_before
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch);
}
#method_after
private SubmitStrategy createStrategy(Branch.NameKey destBranch, SubmitType submitType, CodeReviewCommit branchTip, IdentifiedUser caller) throws MergeException, NoSuchProjectException {
    return submitStrategyFactory.create(submitType, db, repo, rw, inserter, canMergeFlag, getAlreadyAccepted(branchTip), destBranch, caller);
}
#end_block

#method_before
private ListMultimap<SubmitType, Change> validateChangeList(List<ChangeData> submitted) throws MergeException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, Change> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.SUBMITTED && chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new or submitted: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            toUpdate.add(chg);
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            toUpdate.add(chg);
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            toUpdate.add(chg);
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            toUpdate.add(chg);
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            toUpdate.add(chg);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, chg);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#method_after
private ListMultimap<SubmitType, ChangeData> validateChangeList(List<ChangeData> submitted) throws MergeException {
    logDebug("Validating {} changes", submitted.size());
    ListMultimap<SubmitType, ChangeData> toSubmit = ArrayListMultimap.create();
    Map<String, Ref> allRefs;
    try {
        allRefs = repo.getRefDatabase().getRefs(ALL);
    } catch (IOException e) {
        throw new MergeException(e.getMessage(), e);
    }
    Set<ObjectId> tips = new HashSet<>();
    for (Ref r : allRefs.values()) {
        tips.add(r.getObjectId());
    }
    for (ChangeData cd : submitted) {
        ChangeControl ctl;
        Change chg;
        try {
            ctl = cd.changeControl();
            // Reload change in case index was stale.
            chg = cd.reloadChange();
        } catch (OrmException e) {
            throw new MergeException("Failed to validate changes", e);
        }
        Change.Id changeId = cd.getId();
        if (chg.getStatus() != Change.Status.SUBMITTED && chg.getStatus() != Change.Status.NEW) {
            logDebug("Change {} is not new or submitted: {}", changeId, chg.getStatus());
            continue;
        }
        if (chg.currentPatchSetId() == null) {
            logError("Missing current patch set on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        PatchSet ps;
        Branch.NameKey destBranch = chg.getDest();
        try {
            ps = cd.currentPatchSet();
        } catch (OrmException e) {
            throw new MergeException("Cannot query the database", e);
        }
        if (ps == null || ps.getRevision() == null || ps.getRevision().get() == null) {
            logError("Missing patch set or revision on change " + changeId);
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        String idstr = ps.getRevision().get();
        ObjectId id;
        try {
            id = ObjectId.fromString(idstr);
        } catch (IllegalArgumentException iae) {
            logError("Invalid revision on patch set " + ps.getId());
            commits.put(changeId, CodeReviewCommit.noPatchSet(ctl));
            continue;
        }
        if (!tips.contains(id)) {
            // TODO Technically the proper way to do this test is to use a
            // RevWalk on "$id --not --all" and test for an empty set. But
            // that is way slower than looking for a ref directly pointing
            // at the desired tip. We should always have a ref available.
            // 
            // TODO this is actually an error, the branch is gone but we
            // want to merge the issue. We can't safely do that if the
            // tip is not reachable.
            // 
            logError("Revision " + idstr + " of patch set " + ps.getId() + " is not contained in any ref");
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        CodeReviewCommit commit;
        try {
            commit = (CodeReviewCommit) rw.parseCommit(id);
        } catch (IOException e) {
            logError("Invalid commit " + idstr + " on patch set " + ps.getId(), e);
            commits.put(changeId, CodeReviewCommit.revisionGone(ctl));
            continue;
        }
        // TODO(dborowitz): Consider putting ChangeData in CodeReviewCommit.
        commit.setControl(ctl);
        commit.setPatchsetId(ps.getId());
        commits.put(changeId, commit);
        MergeValidators mergeValidators = mergeValidatorsFactory.create();
        try {
            mergeValidators.validatePreMerge(repo, commit, destProject, destBranch, ps.getId());
        } catch (MergeValidationException mve) {
            logDebug("Revision {} of patch set {} failed validation: {}", idstr, ps.getId(), mve.getStatus());
            commit.setStatusCode(mve.getStatus());
            continue;
        }
        SubmitType submitType;
        submitType = getSubmitType(commit.getControl(), ps);
        if (submitType == null) {
            logError("No submit type for revision " + idstr + " of patch set " + ps.getId());
            commit.setStatusCode(CommitMergeStatus.NO_SUBMIT_TYPE);
            continue;
        }
        commit.add(canMergeFlag);
        toSubmit.put(submitType, cd);
    }
    logDebug("Submitting on this run: {}", toSubmit);
    return toSubmit;
}
#end_block

#method_before
private void updateChangeStatus(List<Change> submitted, Branch.NameKey destBranch, boolean dryRun) throws NoSuchChangeException, MergeException, ResourceConflictException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (Change c : submitted) {
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new MergeException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#method_after
private void updateChangeStatus(List<ChangeData> submitted, Branch.NameKey destBranch, boolean dryRun, IdentifiedUser caller) throws NoSuchChangeException, MergeException, ResourceConflictException, OrmException {
    if (!dryRun) {
        logDebug("Updating change status for {} changes", submitted.size());
    } else {
        logDebug("Checking change state for {} changes in a dry run", submitted.size());
    }
    MergeTip mergeTip = mergeTips.get(destBranch);
    for (ChangeData cd : submitted) {
        Change c = cd.change();
        CodeReviewCommit commit = commits.get(c.getId());
        CommitMergeStatus s = commit != null ? commit.getStatusCode() : null;
        if (s == null) {
            // Shouldn't ever happen, but leave the change alone. We'll pick
            // it up on the next pass.
            // 
            logDebug("Submitted change {} did not appear in set of new commits" + " produced by merge strategy", c.getId());
            continue;
        }
        if (!dryRun) {
            try {
                setApproval(cd, caller);
            } catch (IOException e) {
                throw new OrmException(e);
            }
        }
        String txt = s.getMessage();
        logDebug("Status of change {} ({}) on {}: {}", c.getId(), commit.name(), c.getDest(), s);
        // If mergeTip is null merge failed and mergeResultRev will not be read.
        ObjectId mergeResultRev = mergeTip != null ? mergeTip.getMergeResults().get(commit) : null;
        try {
            ChangeMessage msg;
            switch(s) {
                case CLEAN_MERGE:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case CLEAN_REBASE:
                case CLEAN_PICK:
                    if (!dryRun) {
                        setMerged(c, message(c, txt + " as " + commit.name() + getByAccountName(commit)), mergeResultRev);
                    }
                    break;
                case ALREADY_MERGED:
                    if (!dryRun) {
                        setMerged(c, null, mergeResultRev);
                    }
                    break;
                case PATH_CONFLICT:
                case MANUAL_RECURSIVE_MERGE:
                case CANNOT_CHERRY_PICK_ROOT:
                case NOT_FAST_FORWARD:
                case INVALID_PROJECT_CONFIGURATION:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_PERMITTED:
                case INVALID_PROJECT_CONFIGURATION_PLUGIN_VALUE_NOT_EDITABLE:
                case INVALID_PROJECT_CONFIGURATION_PARENT_PROJECT_NOT_FOUND:
                case INVALID_PROJECT_CONFIGURATION_ROOT_PROJECT_CANNOT_HAVE_PARENT:
                case SETTING_PARENT_PROJECT_ONLY_ALLOWED_BY_ADMIN:
                    setNew(commit.notes(), message(c, txt));
                    throw new ResourceConflictException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case MISSING_DEPENDENCY:
                    logDebug("Change {} is missing dependency", c.getId());
                    throw new MergeException("Cannot merge " + commit.name() + "\n" + s.getMessage());
                case REVISION_GONE:
                    logDebug("Commit not found for change {}", c.getId());
                    msg = new ChangeMessage(new ChangeMessage.Key(c.getId(), ChangeUtil.messageUUID(db)), null, TimeUtil.nowTs(), c.currentPatchSetId());
                    msg.setMessage("Failed to read commit for this patch set");
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
                default:
                    msg = message(c, "Unspecified merge failure: " + s.name());
                    setNew(commit.notes(), msg);
                    throw new MergeException(msg.getMessage());
            }
        } catch (OrmException | IOException err) {
            logWarn("Error updating change status for " + c.getId(), err);
        }
    }
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                ReviewDb reviewDb = schemaFactory.open();
                try {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                } finally {
                    reviewDb.close();
                }
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    });
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try (ReviewDb reviewDb = schemaFactory.open()) {
                patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    });
}
#end_block

#method_before
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : queryProvider.get().byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#method_after
private void abandonAllOpenChanges(Project.NameKey destProject) throws NoSuchChangeException {
    try {
        openSchema();
        for (ChangeData cd : internalChangeQuery.byProjectOpen(destProject)) {
            abandonOneChange(cd.change());
        }
        db.close();
        db = null;
    } catch (IOException | OrmException e) {
        logWarn("Cannot abandon changes for deleted project ", e);
    }
}
#end_block

#method_before
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
}
#method_after
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithContentMerge_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    submitWithConflict(change2.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId());
    assertSubmitter(change2.getChangeId(), 1);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithContentMerge_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "a.txt", "other content");
    submitWithConflict(change2.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 1, change2.getCommitId());
    assertNoSubmitter(change2.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitOutOfOrder_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    createChange("Change 2", "b.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content");
    submitWithConflict(change3.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId());
    assertSubmitter(change3.getChangeId(), 1);
}
#method_after
@Test
public void submitOutOfOrder_Conflict() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    createChange("Change 2", "b.txt", "other content");
    PushOneCommit.Result change3 = createChange("Change 3", "b.txt", "different content");
    submitWithConflict(change3.getChangeId());
    assertThat(getRemoteHead()).isEqualTo(oldHead);
    assertCurrentRevision(change3.getChangeId(), 1, change3.getCommitId());
    assertNoSubmitter(change3.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitDependentConflictingChangesOutOfOrder() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b1");
    PushOneCommit.Result change3 = createChange("Change 3", "b", "b2");
    assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit());
    // Submit fails; change3 contains the delta "b1" -> "b2", which cannot be
    // applied against tip.
    submitWithConflict(change3.getChangeId());
    ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info3.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict");
    // Tip has not changed.
    List<RevCommit> log = getRemoteLog();
    assertThat(log.get(0)).isEqualTo(initialHead.getId());
}
#method_after
@Test
public void submitDependentConflictingChangesOutOfOrder() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b1");
    PushOneCommit.Result change3 = createChange("Change 3", "b", "b2");
    assertThat(change3.getCommit().getParent(0)).isEqualTo(change2.getCommit());
    // Submit fails; change3 contains the delta "b1" -> "b2", which cannot be
    // applied against tip.
    submitWithConflict(change3.getChangeId());
    ChangeInfo info3 = get(change3.getChangeId(), ListChangesOption.MESSAGES);
    assertThat(info3.status).isEqualTo(ChangeStatus.NEW);
    assertThat(Iterables.getLast(info3.messages).message.toLowerCase()).contains("path conflict");
    // Tip has not changed.
    List<RevCommit> log = getRemoteLog();
    assertThat(log.get(0)).isEqualTo(initialHead.getId());
    assertNoSubmitter(change3.getChangeId(), 1);
}
#end_block

#method_before
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    approve(change.getChangeId());
    submit(change2.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change2.getCommitId());
    assertThat(head.getParent(0).getId()).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, admin.getIdent());
}
#method_after
@Test
public void submitTwoChangesWithFastForward() throws Exception {
    PushOneCommit.Result change = createChange();
    PushOneCommit.Result change2 = createChange();
    approve(change.getChangeId());
    submit(change2.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change2.getCommitId());
    assertThat(head.getParent(0).getId()).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertAuthor(newHead, admin.getIdent());
// TODO:  "Administrator" != "admin" ?
// assertCommitter(newHead, admin.getIdent());
}
#method_after
@Test
public void submitWithCherryPick() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertCherryPick(testRepo, false);
    RevCommit newHead = getRemoteHead();
    assertThat(newHead.getParentCount()).isEqualTo(1);
    assertThat(newHead.getParent(0)).isEqualTo(oldHead);
    assertCurrentRevision(change2.getChangeId(), 2, newHead);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), newHead.getAuthorIdent());
// TODO:  Check the committer, too.
// assertPersonEquals(admin.getIdent(), newHead.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, admin.getIdent());
}
#method_after
@Test
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    submitStatusOnly(change2.getChangeId());
    submitStatusOnly(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    RevCommit head = getRemoteHead();
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, serverIdent.get());
}
#method_after
@Test
public void submitMultipleChanges() throws Exception {
    RevCommit initialHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b", "b");
    testRepo.reset(initialHead);
    PushOneCommit.Result change3 = createChange("Change 3", "c", "c");
    testRepo.reset(initialHead);
    PushOneCommit.Result change4 = createChange("Change 4", "d", "d");
    submitStatusOnly(change2.getChangeId());
    submitStatusOnly(change3.getChangeId());
    submit(change4.getChangeId());
    RevCommit tip = getRemoteLog().get(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change4.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getParent(1).getShortMessage()).isEqualTo(change3.getCommit().getShortMessage());
    tip = tip.getParent(0);
    assertThat(tip.getShortMessage()).isEqualTo(change2.getCommit().getShortMessage());
    assertThat(tip.getParent(0).getId()).isEqualTo(initialHead.getId());
    assertPersonEquals(admin.getIdent(), tip.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), tip.getCommitterIdent());
}
#end_block

#method_before
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, serverIdent.get());
}
#method_after
@Test
public void submitWithMergeIfFastForwardPossible() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getParentCount()).isEqualTo(2);
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertThat(head.getParent(1)).isEqualTo(change.getCommitId());
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

#method_before
private void assertMergeCommit(String branch, String subject) throws IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        RevCommit c = rw.parseCommit(r.getRef(branch).getObjectId());
        assertThat(c.getParentCount()).isEqualTo(2);
        assertThat(c.getShortMessage()).isEqualTo("Merge \"" + subject + "\"");
        assertThat(c.getAuthorIdent().getEmailAddress()).isEqualTo(admin.email);
        assertThat(c.getCommitterIdent().getEmailAddress()).isEqualTo(serverIdent.getEmailAddress());
    }
}
#method_after
private void assertMergeCommit(String branch, String subject) throws IOException {
    try (Repository r = repoManager.openRepository(project);
        RevWalk rw = new RevWalk(r)) {
        RevCommit c = rw.parseCommit(r.getRef(branch).getObjectId());
        assertThat(c.getParentCount()).isEqualTo(2);
        assertThat(c.getShortMessage()).isEqualTo("Merge \"" + subject + "\"");
        assertThat(c.getAuthorIdent().getEmailAddress()).isEqualTo(admin.email);
        assertThat(c.getCommitterIdent().getEmailAddress()).isEqualTo(serverIdent.get().getEmailAddress());
    }
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change.getChangeId());
    assertCurrentRevision(change.getChangeId(), 1, head);
    assertSubmitter(change.getChangeId(), 1);
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithFastForward() throws Exception {
    RevCommit oldHead = getRemoteHead();
    PushOneCommit.Result change = createChange();
    submit(change.getChangeId());
    RevCommit head = getRemoteHead();
    assertThat(head.getId()).isEqualTo(change.getCommitId());
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change.getChangeId());
    assertCurrentRevision(change.getChangeId(), 1, head);
    assertSubmitter(change.getChangeId(), 1);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(admin.getIdent(), head.getCommitterIdent());
}
#end_block

#method_before
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit head = getRemoteHead();
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, head);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertAuthor(head, admin.getIdent());
    assertCommitter(head, serverIdent.get());
}
#method_after
@Test
@TestProjectInput(useContentMerge = InheritableBoolean.TRUE)
public void submitWithRebase() throws Exception {
    RevCommit initialHead = getRemoteHead();
    PushOneCommit.Result change = createChange("Change 1", "a.txt", "content");
    submit(change.getChangeId());
    RevCommit oldHead = getRemoteHead();
    testRepo.reset(initialHead);
    PushOneCommit.Result change2 = createChange("Change 2", "b.txt", "other content");
    submit(change2.getChangeId());
    assertRebase(testRepo, false);
    RevCommit head = getRemoteHead();
    assertThat(head.getParent(0)).isEqualTo(oldHead);
    assertApproved(change2.getChangeId());
    assertCurrentRevision(change2.getChangeId(), 2, head);
    assertSubmitter(change2.getChangeId(), 1);
    assertSubmitter(change2.getChangeId(), 2);
    assertPersonEquals(admin.getIdent(), head.getAuthorIdent());
    assertPersonEquals(serverIdent.get(), head.getCommitterIdent());
}
#end_block

#method_before
@Before
public void setUp() {
    Timestamp timestamp = new Timestamp(NOW);
    entry1 = new SQLEntry("name1", timestamp, "event1", Integer.MAX_VALUE);
    entry2 = new SQLEntry("name2", timestamp, "event2", Integer.MIN_VALUE);
    entry3 = new SQLEntry("name3", timestamp, "event3", 0);
}
#method_after
@Before
public void setUp() {
    Timestamp timestamp = new Timestamp(NOW);
    entry1 = new SQLEntry("name1", timestamp, "event1", Integer.MAX_VALUE);
    entry2 = new SQLEntry("name2", timestamp, "event2", Integer.MIN_VALUE);
    entry3 = new SQLEntry("name3", timestamp, "event3", 0);
    entry4 = new SQLEntry("name4", timestamp, "event4", Integer.MAX_VALUE);
}
#end_block

#method_before
@Test
public void testEquals() throws Exception {
    assertThat(entry1.equals(null)).isFalse();
    assertThat(entry1.equals("String object")).isFalse();
    assertThat(entry1.equals(entry1)).isTrue();
    assertThat(entry1.equals(entry2)).isFalse();
}
#method_after
@Test
public void testEquals() throws Exception {
    assertThat(entry1.equals(null)).isFalse();
    assertThat(entry1.equals("String object")).isFalse();
    assertThat(entry1.equals(entry1)).isTrue();
    assertThat(entry1.equals(entry2)).isFalse();
    assertThat(entry1.equals(entry4)).isTrue();
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    return prime + id;
}
#method_after
@Override
public int hashCode() {
    return 31 + id;
}
#end_block

#method_before
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (!sshScheme.isEnabled() || username == null) {
        return null;
    }
    StringBuilder b = new StringBuilder();
    b.append(super.getCommand(scheme, project)).append(" && scp -p -P ").append(sshScheme.getSshdPort()).append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":hooks/commit-msg ").append(project).append("/.git/hooks/");
    return b.toString();
}
#method_after
@Override
public String getCommand(DownloadScheme scheme, String project) {
    String username = userProvider.get().getUserName();
    if (!sshScheme.isEnabled() || username == null) {
        return null;
    }
    return new StringBuilder().append(super.getCommand(scheme, project)).append(" && scp -p -P ").append(sshScheme.getSshdPort()).append(" ").append(username).append("@").append(sshScheme.getSshdHost()).append(":hooks/commit-msg ").append(project).append("/.git/hooks/").toString();
}
#end_block

#method_before
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    String endPoint = "/changes/?S=" + start + "&n=" + limit + "&q=project:" + projectName + "&O=" + Integer.toHexString(ListChangesOption.toBits(EnumSet.of(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS)));
    List<ChangeInfo> result;
    try (RestResponse r = checkedGet(endPoint)) {
        result = newGson().fromJson(r.getReader(), new TypeToken<List<ChangeInfo>>() {
        }.getType());
    }
    for (ChangeInfo c : result) {
        for (Map.Entry<String, RevisionInfo> e : c.revisions.entrySet()) {
            e.getValue().commit.commit = e.getKey();
        }
    }
    return result;
}
#method_after
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    String endPoint = "/changes/?S=" + start + ((limit > 0) ? "&n=" + limit : "") + "&q=project:" + projectName + "&O=" + Integer.toHexString(ListChangesOption.toBits(EnumSet.of(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS)));
    List<ChangeInfo> result;
    try (RestResponse r = checkedGet(endPoint)) {
        result = newGson().fromJson(r.getReader(), new TypeToken<List<ChangeInfo>>() {
        }.getType());
    }
    for (ChangeInfo c : result) {
        for (Map.Entry<String, RevisionInfo> e : c.revisions.entrySet()) {
            e.getValue().commit.commit = e.getKey();
        }
    }
    return result;
}
#end_block

#method_before
void replay() throws IOException, OrmException, NoSuchAccountException, NoSuchChangeException, RestApiException, ValidationException {
    int start = 0, count = 1;
    final int limit = 500;
    boolean moreChanges;
    do {
        moreChanges = false;
        List<ChangeInfo> changes = api.queryChanges(srcProject.get(), start, limit);
        pm.beginTask(String.format("Replay Changes (%d)", count), changes.size());
        RevWalk rw = new RevWalk(repo);
        try {
            for (ChangeInfo c : changes) {
                try {
                    replayChange(rw, c);
                } catch (Exception e) {
                    log.error(String.format("Failed to replay change %s.", Url.decode(c.id)), e);
                    throw e;
                }
                if (!moreChanges && Boolean.TRUE.equals(c._moreChanges)) {
                    moreChanges = true;
                    start += limit;
                    count++;
                }
                pm.update(1);
            }
        } finally {
            rw.close();
        }
        pm.endTask();
    } while (moreChanges);
}
#method_after
void replay() throws IOException, OrmException, NoSuchAccountException, NoSuchChangeException, RestApiException, ValidationException {
    int start = 0;
    int limit = GlobalCapability.DEFAULT_MAX_QUERY_LIMIT;
    pm.beginTask("Replay Changes", ProgressMonitor.UNKNOWN);
    for (; ; ) {
        List<ChangeInfo> changes = api.queryChanges(srcProject.get(), start, limit);
        if (changes.isEmpty()) {
            break;
        }
        start += changes.size();
        RevWalk rw = new RevWalk(repo);
        try {
            ChangeInfo last = null;
            for (ChangeInfo c : changes) {
                try {
                    replayChange(rw, c);
                } catch (Exception e) {
                    log.error(String.format("Failed to replay change %s.", Url.decode(c.id)), e);
                    throw e;
                }
                last = c;
                pm.update(1);
            }
            if (!Boolean.TRUE.equals(last._moreChanges)) {
                break;
            }
        } finally {
            rw.close();
        }
    }
    pm.endTask();
}
#end_block

#method_before
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    try {
        return gApi.changes().query("project:" + projectName).withStart(start).withLimit(limit).withOptions(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS).get();
    } catch (RestApiException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#method_after
@Override
public List<ChangeInfo> queryChanges(String projectName, int start, int limit) throws IOException, BadRequestException {
    try {
        QueryRequest query = gApi.changes().query("project:" + projectName);
        query.withStart(start).withOptions(ListChangesOption.DETAILED_LABELS, ListChangesOption.DETAILED_ACCOUNTS, ListChangesOption.MESSAGES, ListChangesOption.CURRENT_REVISION, ListChangesOption.ALL_REVISIONS, ListChangesOption.ALL_COMMITS);
        if (limit > 0) {
            query.withLimit(limit);
        }
        return query.get();
    } catch (RestApiException e) {
        throw new BadRequestException(e.getMessage());
    }
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()));
}
#method_after
public List<ChangeInfo> format(Collection<Change.Id> ids) throws OrmException {
    List<ChangeData> changes = new ArrayList<>(ids.size());
    List<ChangeInfo> ret = new ArrayList<>(ids.size());
    ReviewDb reviewDb = db.get();
    for (Change.Id id : ids) {
        changes.add(changeDataFactory.create(reviewDb, id));
    }
    accountLoader = accountLoaderFactory.create(has(DETAILED_ACCOUNTS));
    for (ChangeData cd : changes) {
        ret.add(format(cd, Optional.<PatchSet.Id>absent(), false));
    }
    accountLoader.fill();
    return ret;
}
#end_block

#method_before
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent());
}
#method_after
public ChangeInfo format(ChangeData cd) throws OrmException {
    return format(cd, Optional.<PatchSet.Id>absent(), true);
}
#end_block

#method_before
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()));
}
#method_after
public ChangeInfo format(RevisionResource rsrc) throws OrmException {
    ChangeData cd = changeDataFactory.create(db.get(), rsrc.getControl());
    return format(cd, Optional.of(rsrc.getPatchSet().getId()), true);
}
#end_block

#method_before
@Override
public Object apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), ChangeSet.create(resource.getChange()));
        json.addOptions(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS));
        return json.format(cs.ids());
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public List<ChangeInfo> apply(ChangeResource resource) throws AuthException, BadRequestException, ResourceConflictException, Exception {
    try {
        ChangeSet cs = mergeSuperSet.completeChangeSet(dbProvider.get(), ChangeSet.create(resource.getChange()));
        json.addOptions(EnumSet.of(ListChangesOption.CURRENT_REVISION, ListChangesOption.CURRENT_COMMIT, ListChangesOption.DETAILED_LABELS, ListChangesOption.LABELS));
        return json.format(cs.ids());
    } catch (OrmException | IOException e) {
        log.error("Error on getting a ChangeSet", e);
        throw e;
    }
}
#end_block

#method_before
@Override
public void visit(HeaderNode node) {
    outputNamedAnchor = false;
    String tag = "h" + node.getLevel();
    html.open(tag);
    String id = toc.idFromHeader(node);
    if (id != null) {
        html.open("a").attribute("name", id).attribute("href", "#" + id).attribute("class", "h");
        html.open("i").close("i");
        html.close("a");
    }
    visitChildren(node);
    html.close(tag);
    outputNamedAnchor = true;
}
#method_after
@Override
public void visit(HeaderNode node) {
    outputNamedAnchor = false;
    String tag = "h" + node.getLevel();
    html.open(tag);
    String id = toc.idFromHeader(node);
    if (id != null) {
        html.open("a").attribute("class", "h").attribute("name", id).attribute("href", "#" + id).open("span").close("span").close("a");
    }
    visitChildren(node);
    html.close(tag);
    outputNamedAnchor = true;
}
#end_block

#method_before
public Project createProject(CreateProjectArgs args) throws BadRequestException, ResourceConflictException, IOException, ConfigInvalidException {
    final Project.NameKey nameKey = args.getProject();
    try {
        final String head = args.permissionsOnly ? RefNames.REFS_CONFIG : args.branch.get(0);
        try (Repository repo = repoManager.openRepository(nameKey)) {
            // Check if the repo already exists, and throw ResourceConflictException if it does.
            if (repo.getObjectDatabase().exists()) {
                throw new ResourceConflictException("project \"" + nameKey + "\" exists");
            }
        } catch (IOException e) {
        // It doesn't exist, safe to ignore.
        }
        Repository repo = repoManager.createRepository(nameKey);
        try {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                try {
                    l.onNewProjectCreated(event);
                } catch (RuntimeException e) {
                    log.warn("Failure in NewProjectCreatedListener", e);
                }
            }
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig(args);
            if (!args.permissionsOnly && args.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, args.branch);
            }
            return projectCache.get(nameKey).getProject();
        } finally {
            repo.close();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ResourceConflictException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.");
    } catch (RepositoryNotFoundException badName) {
        throw new BadRequestException("invalid project name: " + nameKey);
    } catch (ConfigInvalidException e) {
        String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw e;
    }
}
#method_after
public Project createProject(CreateProjectArgs args) throws BadRequestException, ResourceConflictException, IOException, ConfigInvalidException {
    final Project.NameKey nameKey = args.getProject();
    try {
        final String head = args.permissionsOnly ? RefNames.REFS_CONFIG : args.branch.get(0);
        try (Repository repo = repoManager.openRepository(nameKey)) {
            if (repo.getObjectDatabase().exists()) {
                throw new ResourceConflictException("project \"" + nameKey + "\" exists");
            }
        } catch (RepositoryNotFoundException e) {
        // It does not exist, safe to ignore.
        }
        try (Repository repo = repoManager.createRepository(nameKey)) {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                try {
                    l.onNewProjectCreated(event);
                } catch (RuntimeException e) {
                    log.warn("Failure in NewProjectCreatedListener", e);
                }
            }
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig(args);
            if (!args.permissionsOnly && args.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, args.branch);
            }
            return projectCache.get(nameKey).getProject();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ResourceConflictException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.");
    } catch (RepositoryNotFoundException badName) {
        throw new BadRequestException("invalid project name: " + nameKey);
    } catch (ConfigInvalidException e) {
        String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw e;
    }
}
#end_block

#method_before
@Override
public void setProjectDescription(final Project.NameKey name, final String description) {
    // 
    try {
        try (Repository e = openRepository(name)) {
            final String old = getProjectDescription(e);
            if ((old == null && description == null) || (old != null && old.equals(description))) {
                return;
            }
            final LockFile f = new LockFile(new File(e.getDirectory(), "description"), FS.DETECTED);
            if (f.lock()) {
                String d = description;
                if (d != null) {
                    d = d.trim();
                    if (d.length() > 0) {
                        d += "\n";
                    }
                } else {
                    d = "";
                }
                f.write(Constants.encode(d));
                f.commit();
            }
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Cannot update description for " + name, e);
    } catch (IOException e) {
        log.error("Cannot update description for " + name, e);
    }
}
#method_after
@Override
public void setProjectDescription(final Project.NameKey name, final String description) {
    // 
    try (Repository e = openRepository(name)) {
        final String old = getProjectDescription(e);
        if ((old == null && description == null) || (old != null && old.equals(description))) {
            return;
        }
        final LockFile f = new LockFile(new File(e.getDirectory(), "description"), FS.DETECTED);
        if (f.lock()) {
            String d = description;
            if (d != null) {
                d = d.trim();
                if (d.length() > 0) {
                    d += "\n";
                }
            } else {
                d = "";
            }
            f.write(Constants.encode(d));
            f.commit();
        }
    } catch (RepositoryNotFoundException e) {
        log.error("Cannot update description for " + name, e);
    } catch (IOException e) {
        log.error("Cannot update description for " + name, e);
    }
}
#end_block

#method_before
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    CacheHeaders.setNotCacheable(rsp);
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        rsp.setContentLength(raw.length);
        try (OutputStream out = rsp.getOutputStream()) {
            out.write(raw);
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(req.getContextPath());
        rdr.append("/");
        if (res.isNew()) {
            rdr.append('#' + PageLinks.REGISTER);
        } else {
            rdr.append(LoginUrlToken.getToken(req));
        }
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        final Writer out = rsp.getWriter();
        out.write("<html>");
        out.write("<body>");
        out.write("<h1>Account Not Found</h1>");
        out.write("</body>");
        out.write("</html>");
        out.close();
    }
}
#method_after
@Override
protected void doPost(final HttpServletRequest req, final HttpServletResponse rsp) throws IOException, ServletException {
    CacheHeaders.setNotCacheable(rsp);
    final AuthResult res;
    if ("create_account".equals(req.getParameter("action"))) {
        res = create();
    } else if (req.getParameter("user_name") != null) {
        res = byUserName(req.getParameter("user_name"));
    } else if (req.getParameter("preferred_email") != null) {
        res = byPreferredEmail(req.getParameter("preferred_email"));
    } else if (req.getParameter("account_id") != null) {
        res = byAccountId(req.getParameter("account_id"));
    } else {
        byte[] raw;
        try {
            raw = prepareHtmlOutput();
        } catch (OrmException e) {
            throw new ServletException(e);
        }
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        rsp.setContentLength(raw.length);
        try (OutputStream out = rsp.getOutputStream()) {
            out.write(raw);
        }
        return;
    }
    if (res != null) {
        webSession.get().login(res, false);
        final StringBuilder rdr = new StringBuilder();
        rdr.append(req.getContextPath());
        rdr.append("/");
        if (res.isNew()) {
            rdr.append('#' + PageLinks.REGISTER);
        } else {
            rdr.append(LoginUrlToken.getToken(req));
        }
        rsp.sendRedirect(rdr.toString());
    } else {
        rsp.setContentType("text/html");
        rsp.setCharacterEncoding(HtmlDomUtil.ENC.name());
        try (Writer out = rsp.getWriter()) {
            out.write("<html>");
            out.write("<body>");
            out.write("<h1>Account Not Found</h1>");
            out.write("</body>");
            out.write("</html>");
        }
    }
}
#end_block

#method_before
private AuthResult byUserName(final String userName) {
    try {
        try (ReviewDb db = schema.open()) {
            AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName);
            return auth(db.accountExternalIds().get(key));
        }
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#method_after
private AuthResult byUserName(final String userName) {
    try (ReviewDb db = schema.open()) {
        AccountExternalId.Key key = new AccountExternalId.Key(SCHEME_USERNAME, userName);
        return auth(db.accountExternalIds().get(key));
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
private AuthResult byPreferredEmail(final String email) {
    try {
        try (ReviewDb db = schema.open()) {
            List<Account> matches = db.accounts().byPreferredEmail(email).toList();
            return matches.size() == 1 ? auth(matches.get(0)) : null;
        }
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#method_after
private AuthResult byPreferredEmail(final String email) {
    try (ReviewDb db = schema.open()) {
        List<Account> matches = db.accounts().byPreferredEmail(email).toList();
        return matches.size() == 1 ? auth(matches.get(0)) : null;
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
private AuthResult byAccountId(final String idStr) {
    final Account.Id id;
    try {
        id = Account.Id.parse(idStr);
    } catch (NumberFormatException nfe) {
        return null;
    }
    try {
        try (ReviewDb db = schema.open()) {
            return auth(db.accounts().get(id));
        }
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#method_after
private AuthResult byAccountId(final String idStr) {
    final Account.Id id;
    try {
        id = Account.Id.parse(idStr);
    } catch (NumberFormatException nfe) {
        return null;
    }
    try (ReviewDb db = schema.open()) {
        return auth(db.accounts().get(id));
    } catch (OrmException e) {
        getServletContext().log("cannot query database", e);
        return null;
    }
}
#end_block

#method_before
private String name(final TreeLogger logger, final PublicResource r) throws UnableToCompleteException {
    final ByteArrayOutputStream tmp = new ByteArrayOutputStream();
    try {
        try (InputStream in = r.getContents(logger)) {
            final byte[] buf = new byte[2048];
            int n;
            while ((n = in.read(buf)) >= 0) {
                tmp.write(buf, 0, n);
            }
            tmp.close();
        }
    } catch (IOException e) {
        final UnableToCompleteException ute = new UnableToCompleteException();
        ute.initCause(e);
        throw ute;
    }
    String base = r.getPartialPath();
    final int s = base.lastIndexOf('/');
    if (0 < s) {
        base = base.substring(0, s + 1);
    } else {
        base = "";
    }
    return base + Util.computeStrongName(tmp.toByteArray()) + ".cache.css";
}
#method_after
private String name(final TreeLogger logger, final PublicResource r) throws UnableToCompleteException {
    final ByteArrayOutputStream tmp = new ByteArrayOutputStream();
    try (InputStream in = r.getContents(logger)) {
        final byte[] buf = new byte[2048];
        int n;
        while ((n = in.read(buf)) >= 0) {
            tmp.write(buf, 0, n);
        }
        tmp.close();
    } catch (IOException e) {
        final UnableToCompleteException ute = new UnableToCompleteException();
        ute.initCause(e);
        throw ute;
    }
    String base = r.getPartialPath();
    final int s = base.lastIndexOf('/');
    if (0 < s) {
        base = base.substring(0, s + 1);
    } else {
        base = "";
    }
    return base + Util.computeStrongName(tmp.toByteArray()) + ".cache.css";
}
#end_block

#method_before
public static boolean branchExists(final GitRepositoryManager repoManager, final Branch.NameKey branch) throws RepositoryNotFoundException, IOException {
    try (Repository repo = repoManager.openRepository(branch.getParentKey())) {
        boolean exists = repo.getRef(branch.get()) != null;
        if (!exists) {
            exists = repo.getFullBranch().equals(branch.get());
        }
        return exists;
    }
}
#method_after
public static boolean branchExists(final GitRepositoryManager repoManager, final Branch.NameKey branch) throws RepositoryNotFoundException, IOException {
    try (Repository repo = repoManager.openRepository(branch.getParentKey())) {
        boolean exists = repo.getRefDatabase().exactRef(branch.get()) != null;
        if (!exists) {
            exists = repo.getFullBranch().equals(branch.get());
        }
        return exists;
    }
}
#end_block

#method_before
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    try (Repository git = gitManager.openRepository(change.getProject())) {
        ObjectId commit = toId(ps);
        if (commit == null) {
            result.mergeable = false;
            return result;
        }
        Ref ref = git.getRef(change.getDest().get());
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        Boolean old = cache.getIfPresent(commit, ref, result.submitType, strategy);
        if (old == null) {
            result.mergeable = refresh(change, commit, ref, result.submitType, strategy, git, old);
        } else {
            result.mergeable = old;
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                for (String n : branchOrder.getMoreStable(ref.getName())) {
                    Ref other = git.getRef(n);
                    if (other == null) {
                        continue;
                    }
                    if (cache.get(commit, other, SubmitType.CHERRY_PICK, strategy, change.getDest(), git, db.get())) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    }
    return result;
}
#method_after
@Override
public MergeableInfo apply(RevisionResource resource) throws AuthException, ResourceConflictException, BadRequestException, OrmException, IOException {
    Change change = resource.getChange();
    PatchSet ps = resource.getPatchSet();
    MergeableInfo result = new MergeableInfo();
    if (!change.getStatus().isOpen()) {
        throw new ResourceConflictException("change is " + Submit.status(change));
    } else if (!ps.getId().equals(change.currentPatchSetId())) {
        // Only the current revision is mergeable. Others always fail.
        return result;
    }
    ChangeData cd = changeDataFactory.create(db.get(), resource.getControl());
    SubmitTypeRecord rec = new SubmitRuleEvaluator(cd).setPatchSet(ps).getSubmitType();
    if (rec.status != SubmitTypeRecord.Status.OK) {
        throw new OrmException("Submit type rule failed: " + rec);
    }
    result.submitType = rec.type;
    try (Repository git = gitManager.openRepository(change.getProject())) {
        ObjectId commit = toId(ps);
        if (commit == null) {
            result.mergeable = false;
            return result;
        }
        Ref ref = git.getRefDatabase().exactRef(change.getDest().get());
        ProjectState projectState = projectCache.get(change.getProject());
        String strategy = mergeUtilFactory.create(projectState).mergeStrategyName();
        Boolean old = cache.getIfPresent(commit, ref, result.submitType, strategy);
        if (old == null) {
            result.mergeable = refresh(change, commit, ref, result.submitType, strategy, git, old);
        } else {
            result.mergeable = old;
        }
        if (otherBranches) {
            result.mergeableInto = new ArrayList<>();
            BranchOrderSection branchOrder = projectState.getBranchOrderSection();
            if (branchOrder != null) {
                int prefixLen = Constants.R_HEADS.length();
                String[] names = branchOrder.getMoreStable(ref.getName());
                Map<String, Ref> refs = git.getRefDatabase().exactRef(names);
                for (String n : names) {
                    Ref other = refs.get(n);
                    if (other == null) {
                        continue;
                    }
                    if (cache.get(commit, other, SubmitType.CHERRY_PICK, strategy, change.getDest(), git, db.get())) {
                        result.mergeableInto.add(other.getName().substring(prefixLen));
                    }
                }
            }
        }
    }
    return result;
}
#end_block

#method_before
public TagInfo get(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        String tagName = id.get();
        if (!tagName.startsWith(Constants.R_TAGS)) {
            tagName = Constants.R_TAGS + tagName;
        }
        Ref ref = repo.getRefDatabase().getRef(tagName);
        if (ref != null && !visibleTags(resource.getControl(), repo, ImmutableMap.of(ref.getName(), ref)).isEmpty()) {
            return createTagInfo(ref, rw);
        }
    }
    throw new ResourceNotFoundException(id);
}
#method_after
public TagInfo get(ProjectResource resource, IdString id) throws ResourceNotFoundException, IOException {
    try (Repository repo = getRepository(resource.getNameKey());
        RevWalk rw = new RevWalk(repo)) {
        String tagName = id.get();
        if (!tagName.startsWith(Constants.R_TAGS)) {
            tagName = Constants.R_TAGS + tagName;
        }
        Ref ref = repo.getRefDatabase().exactRef(tagName);
        if (ref != null && !visibleTags(resource.getControl(), repo, ImmutableMap.of(ref.getName(), ref)).isEmpty()) {
            return createTagInfo(ref, rw);
        }
    }
    throw new ResourceNotFoundException(id);
}
#end_block

#method_before
private byte[] encrypt(final String name, final Date date, final byte[] rawText) throws PGPException, IOException {
    final byte[] zText = compress(name, date, rawText);
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final ArmoredOutputStream aout = new ArmoredOutputStream(buf);
    final OutputStream cout = cpk().open(aout, zText.length);
    cout.write(zText);
    cout.close();
    aout.close();
    return buf.toByteArray();
}
#method_after
private byte[] encrypt(final String name, final Date date, final byte[] rawText) throws PGPException, IOException {
    final byte[] zText = compress(name, date, rawText);
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    try (ArmoredOutputStream aout = new ArmoredOutputStream(buf);
        OutputStream cout = cpk().open(aout, zText.length)) {
        cout.write(zText);
    }
    return buf.toByteArray();
}
#end_block

#method_before
private static byte[] compress(final String fileName, Date fileDate, final byte[] plainText) throws IOException {
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final PGPCompressedDataGenerator comdg;
    final int len = plainText.length;
    if (fileDate == null) {
        fileDate = PGPLiteralData.NOW;
    }
    comdg = new PGPCompressedDataGenerator(PGPCompressedData.ZIP);
    final OutputStream out = new PGPLiteralDataGenerator().open(comdg.open(buf), PGPLiteralData.BINARY, fileName, len, fileDate);
    out.write(plainText);
    out.close();
    comdg.close();
    return buf.toByteArray();
}
#method_after
private static byte[] compress(final String fileName, Date fileDate, final byte[] plainText) throws IOException {
    final ByteArrayOutputStream buf = new ByteArrayOutputStream();
    final PGPCompressedDataGenerator comdg;
    final int len = plainText.length;
    if (fileDate == null) {
        fileDate = PGPLiteralData.NOW;
    }
    comdg = new PGPCompressedDataGenerator(PGPCompressedData.ZIP);
    try (OutputStream out = new PGPLiteralDataGenerator().open(comdg.open(buf), PGPLiteralData.BINARY, fileName, len, fileDate)) {
        out.write(plainText);
    } finally {
        // PGPCompressedDataGenerator doesn't implement Closable
        comdg.close();
    }
    return buf.toByteArray();
}
#end_block

#method_before
private String format(final Account account, final ContactInformation info) throws ContactInformationStoreException {
    Timestamp on = account.getContactFiledOn();
    if (on == null) {
        on = TimeUtil.nowTs();
    }
    final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
    df.setTimeZone(UTC);
    final StringBuilder b = new StringBuilder();
    field(b, "Account-Id", account.getId().toString());
    field(b, "Date", df.format(on) + " " + UTC.getID());
    field(b, "Full-Name", account.getFullName());
    field(b, "Preferred-Email", account.getPreferredEmail());
    try {
        try (ReviewDb db = schema.open()) {
            for (final AccountExternalId e : db.accountExternalIds().byAccount(account.getId())) {
                final StringBuilder oistr = new StringBuilder();
                if (e.getEmailAddress() != null && e.getEmailAddress().length() > 0) {
                    if (oistr.length() > 0) {
                        oistr.append(' ');
                    }
                    oistr.append(e.getEmailAddress());
                }
                if (e.isScheme(AccountExternalId.SCHEME_MAILTO)) {
                    if (oistr.length() > 0) {
                        oistr.append(' ');
                    }
                    oistr.append('<');
                    oistr.append(e.getExternalId());
                    oistr.append('>');
                }
                field(b, "Identity", oistr.toString());
            }
        }
    } catch (OrmException e) {
        throw new ContactInformationStoreException(e);
    }
    field(b, "Address", info.getAddress());
    field(b, "Country", info.getCountry());
    field(b, "Phone-Number", info.getPhoneNumber());
    field(b, "Fax-Number", info.getFaxNumber());
    return b.toString();
}
#method_after
private String format(final Account account, final ContactInformation info) throws ContactInformationStoreException {
    Timestamp on = account.getContactFiledOn();
    if (on == null) {
        on = TimeUtil.nowTs();
    }
    final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
    df.setTimeZone(UTC);
    final StringBuilder b = new StringBuilder();
    field(b, "Account-Id", account.getId().toString());
    field(b, "Date", df.format(on) + " " + UTC.getID());
    field(b, "Full-Name", account.getFullName());
    field(b, "Preferred-Email", account.getPreferredEmail());
    try (ReviewDb db = schema.open()) {
        for (final AccountExternalId e : db.accountExternalIds().byAccount(account.getId())) {
            final StringBuilder oistr = new StringBuilder();
            if (e.getEmailAddress() != null && e.getEmailAddress().length() > 0) {
                if (oistr.length() > 0) {
                    oistr.append(' ');
                }
                oistr.append(e.getEmailAddress());
            }
            if (e.isScheme(AccountExternalId.SCHEME_MAILTO)) {
                if (oistr.length() > 0) {
                    oistr.append(' ');
                }
                oistr.append('<');
                oistr.append(e.getExternalId());
                oistr.append('>');
            }
            field(b, "Identity", oistr.toString());
        }
    } catch (OrmException e) {
        throw new ContactInformationStoreException(e);
    }
    field(b, "Address", info.getAddress());
    field(b, "Country", info.getCountry());
    field(b, "Phone-Number", info.getPhoneNumber());
    field(b, "Fax-Number", info.getFaxNumber());
    return b.toString();
}
#end_block

#method_before
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    if (!(repoManager instanceof LocalDiskRepositoryManager)) {
        return;
    }
    ui.message("listing all repositories ...");
    SortedSet<Project.NameKey> repoList = repoManager.list();
    ui.message("done");
    ui.message(String.format("creating reflog files for %s branches ...", RefNames.REFS_CONFIG));
    for (Project.NameKey project : repoList) {
        try {
            try (Repository repo = repoManager.openRepository(project)) {
                File metaConfigLog = new File(repo.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
                if (metaConfigLog.exists()) {
                    continue;
                }
                if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
                    throw new IOException(String.format("Failed to create reflog for %s in repository %s", RefNames.REFS_CONFIG, project));
                }
                ObjectId metaConfigId = repo.resolve(RefNames.REFS_CONFIG);
                if (metaConfigId != null) {
                    try (PrintWriter writer = new PrintWriter(metaConfigLog, UTF_8.name())) {
                        writer.print(ObjectId.zeroId().name());
                        writer.print(" ");
                        writer.print(metaConfigId.name());
                        writer.print(" ");
                        writer.print(serverUser.toExternalString());
                        writer.print("\t");
                        writer.print("create reflog");
                        writer.println();
                    }
                }
            }
        } catch (IOException e) {
            ui.message(String.format("ERROR: Failed to create reflog file for the" + " %s branch in repository %s", RefNames.REFS_CONFIG, project.get()));
        }
    }
    ui.message("done");
}
#method_after
@Override
protected void migrateData(ReviewDb db, UpdateUI ui) throws OrmException {
    if (!(repoManager instanceof LocalDiskRepositoryManager)) {
        return;
    }
    ui.message("listing all repositories ...");
    SortedSet<Project.NameKey> repoList = repoManager.list();
    ui.message("done");
    ui.message(String.format("creating reflog files for %s branches ...", RefNames.REFS_CONFIG));
    for (Project.NameKey project : repoList) {
        try (Repository repo = repoManager.openRepository(project)) {
            File metaConfigLog = new File(repo.getDirectory(), "logs/" + RefNames.REFS_CONFIG);
            if (metaConfigLog.exists()) {
                continue;
            }
            if (!metaConfigLog.getParentFile().mkdirs() || !metaConfigLog.createNewFile()) {
                throw new IOException(String.format("Failed to create reflog for %s in repository %s", RefNames.REFS_CONFIG, project));
            }
            ObjectId metaConfigId = repo.resolve(RefNames.REFS_CONFIG);
            if (metaConfigId != null) {
                try (PrintWriter writer = new PrintWriter(metaConfigLog, UTF_8.name())) {
                    writer.print(ObjectId.zeroId().name());
                    writer.print(" ");
                    writer.print(metaConfigId.name());
                    writer.print(" ");
                    writer.print(serverUser.toExternalString());
                    writer.print("\t");
                    writer.print("create reflog");
                    writer.println();
                }
            }
        } catch (IOException e) {
            ui.message(String.format("ERROR: Failed to create reflog file for the" + " %s branch in repository %s", RefNames.REFS_CONFIG, project.get()));
        }
    }
    ui.message("done");
}
#end_block

#method_before
public boolean canReadCommit(ReviewDb db, RevWalk rw, RevCommit commit) {
    try {
        try (Repository repo = openRepository()) {
            return isMergedIntoVisibleRef(repo, db, rw, commit, repo.getAllRefs().values());
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
        return false;
    }
}
#method_after
public boolean canReadCommit(ReviewDb db, RevWalk rw, RevCommit commit) {
    try (Repository repo = openRepository()) {
        return isMergedIntoVisibleRef(repo, db, rw, commit, repo.getAllRefs().values());
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), getProject().getNameKey());
        log.error(msg, e);
        return false;
    }
}
#end_block

#method_before
public void addDependencies(ChangeAttribute ca, Change change) {
    ca.dependsOn = new ArrayList<>();
    ca.neededBy = new ArrayList<>();
    try {
        try (ReviewDb db = schema.open()) {
            final PatchSet.Id psId = change.currentPatchSetId();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
                for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
                    Change c = db.changes().get(p.getId().getParentKey());
                    ca.dependsOn.add(newDependsOn(c, p));
                }
            }
            final PatchSet ps = db.patchSets().get(psId);
            if (ps == null) {
                log.error("Error while generating the list of descendants for" + " PatchSet " + psId + ": Cannot find PatchSet entry in" + " database.");
            } else {
                final RevId revId = ps.getRevision();
                for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(revId)) {
                    final PatchSet p = db.patchSets().get(a.getPatchSet());
                    if (p == null) {
                        log.error("Error while generating the list of descendants for" + " revision " + revId.get() + ": Cannot find PatchSet entry in" + " database for " + a.getPatchSet());
                        continue;
                    }
                    final Change c = db.changes().get(p.getId().getParentKey());
                    ca.neededBy.add(newNeededBy(c, p));
                }
            }
        }
    } catch (OrmException e) {
    // Squash DB exceptions and leave dependency lists partially filled.
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.dependsOn.isEmpty()) {
        ca.dependsOn = null;
    }
    if (ca.neededBy.isEmpty()) {
        ca.neededBy = null;
    }
}
#method_after
public void addDependencies(ChangeAttribute ca, Change change) {
    ca.dependsOn = new ArrayList<>();
    ca.neededBy = new ArrayList<>();
    try (ReviewDb db = schema.open()) {
        final PatchSet.Id psId = change.currentPatchSetId();
        for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(psId)) {
            for (PatchSet p : db.patchSets().byRevision(a.getAncestorRevision())) {
                Change c = db.changes().get(p.getId().getParentKey());
                ca.dependsOn.add(newDependsOn(c, p));
            }
        }
        final PatchSet ps = db.patchSets().get(psId);
        if (ps == null) {
            log.error("Error while generating the list of descendants for" + " PatchSet " + psId + ": Cannot find PatchSet entry in" + " database.");
        } else {
            final RevId revId = ps.getRevision();
            for (PatchSetAncestor a : db.patchSetAncestors().descendantsOf(revId)) {
                final PatchSet p = db.patchSets().get(a.getPatchSet());
                if (p == null) {
                    log.error("Error while generating the list of descendants for" + " revision " + revId.get() + ": Cannot find PatchSet entry in" + " database for " + a.getPatchSet());
                    continue;
                }
                final Change c = db.changes().get(p.getId().getParentKey());
                ca.neededBy.add(newNeededBy(c, p));
            }
        }
    } catch (OrmException e) {
    // Squash DB exceptions and leave dependency lists partially filled.
    }
    // Remove empty lists so a confusing label won't be displayed in the output.
    if (ca.dependsOn.isEmpty()) {
        ca.dependsOn = null;
    }
    if (ca.neededBy.isEmpty()) {
        ca.neededBy = null;
    }
}
#end_block

#method_before
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    final PatchSet.Id pId = patchSet.getId();
    try {
        try (ReviewDb db = schema.open()) {
            p.parents = new ArrayList<>();
            for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
                p.parents.add(a.getAncestorRevision().get());
            }
            UserIdentity author = psInfoFactory.get(db, pId).getAuthor();
            if (author.getAccount() == null) {
                p.author = new AccountAttribute();
                p.author.email = author.getEmail();
                p.author.name = author.getName();
                p.author.username = "";
            } else {
                p.author = asAccountAttribute(author.getAccount());
            }
            Change change = db.changes().get(pId.getParentKey());
            List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
            for (Patch pe : list) {
                if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                    p.sizeDeletions -= pe.getDeletions();
                    p.sizeInsertions += pe.getInsertions();
                }
            }
            p.kind = changeKindCache.getChangeKind(db, change, patchSet);
        }
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#method_after
public PatchSetAttribute asPatchSetAttribute(final PatchSet patchSet) {
    PatchSetAttribute p = new PatchSetAttribute();
    p.revision = patchSet.getRevision().get();
    p.number = Integer.toString(patchSet.getPatchSetId());
    p.ref = patchSet.getRefName();
    p.uploader = asAccountAttribute(patchSet.getUploader());
    p.createdOn = patchSet.getCreatedOn().getTime() / 1000L;
    p.isDraft = patchSet.isDraft();
    final PatchSet.Id pId = patchSet.getId();
    try (ReviewDb db = schema.open()) {
        p.parents = new ArrayList<>();
        for (PatchSetAncestor a : db.patchSetAncestors().ancestorsOf(patchSet.getId())) {
            p.parents.add(a.getAncestorRevision().get());
        }
        UserIdentity author = psInfoFactory.get(db, pId).getAuthor();
        if (author.getAccount() == null) {
            p.author = new AccountAttribute();
            p.author.email = author.getEmail();
            p.author.name = author.getName();
            p.author.username = "";
        } else {
            p.author = asAccountAttribute(author.getAccount());
        }
        Change change = db.changes().get(pId.getParentKey());
        List<Patch> list = patchListCache.get(change, patchSet).toPatchList(pId);
        for (Patch pe : list) {
            if (!Patch.COMMIT_MSG.equals(pe.getFileName())) {
                p.sizeDeletions -= pe.getDeletions();
                p.sizeInsertions += pe.getInsertions();
            }
        }
        p.kind = changeKindCache.getChangeKind(db, change, patchSet);
    } catch (OrmException e) {
        log.error("Cannot load patch set data for " + patchSet.getId(), e);
    } catch (PatchSetInfoNotAvailableException e) {
        log.error(String.format("Cannot get authorEmail for %s.", pId), e);
    } catch (PatchListNotAvailableException e) {
        log.error(String.format("Cannot get size information for %s.", pId), e);
    }
    return p;
}
#end_block

#method_before
Funnel<K> funnel() {
    return new Funnel<K>() {

        private static final long serialVersionUID = 1L;

        @Override
        public void funnel(K from, PrimitiveSink into) {
            try {
                try (ObjectOutputStream ser = new ObjectOutputStream(new SinkOutputStream(into))) {
                    ser.writeObject(from);
                    ser.flush();
                }
            } catch (IOException err) {
                throw new RuntimeException("Cannot hash as Serializable", err);
            }
        }
    };
}
#method_after
Funnel<K> funnel() {
    return new Funnel<K>() {

        private static final long serialVersionUID = 1L;

        @Override
        public void funnel(K from, PrimitiveSink into) {
            try (ObjectOutputStream ser = new ObjectOutputStream(new SinkOutputStream(into))) {
                ser.writeObject(from);
                ser.flush();
            } catch (IOException err) {
                throw new RuntimeException("Cannot hash as Serializable", err);
            }
        }
    };
}
#end_block

#method_before
private boolean isMergedIntoBranchOrTag(ReviewDb db, RevWalk rw, RevCommit commit) {
    try {
        try (Repository repo = projectControl.openRepository()) {
            List<Ref> refs = new ArrayList<>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
            refs.addAll(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
            return projectControl.isMergedIntoVisibleRef(repo, db, rw, commit, refs);
        }
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projectControl.getProject().getNameKey());
        log.error(msg, e);
    }
    return false;
}
#method_after
private boolean isMergedIntoBranchOrTag(ReviewDb db, RevWalk rw, RevCommit commit) {
    try (Repository repo = projectControl.openRepository()) {
        List<Ref> refs = new ArrayList<>(repo.getRefDatabase().getRefs(Constants.R_HEADS).values());
        refs.addAll(repo.getRefDatabase().getRefs(Constants.R_TAGS).values());
        return projectControl.isMergedIntoVisibleRef(repo, db, rw, commit, refs);
    } catch (IOException e) {
        String msg = String.format("Cannot verify permissions to commit object %s in repository %s", commit.name(), projectControl.getProject().getNameKey());
        log.error(msg, e);
    }
    return false;
}
#end_block

#method_before
private static void unpack(File srcwar, File dstwar) throws IOException {
    try (ZipFile zf = new ZipFile(srcwar)) {
        final Enumeration<? extends ZipEntry> e = zf.entries();
        while (e.hasMoreElements()) {
            final ZipEntry ze = e.nextElement();
            final String name = ze.getName();
            if (ze.isDirectory() || name.startsWith("WEB-INF/") || name.startsWith("META-INF/") || name.startsWith("com/google/gerrit/launcher/") || name.equals("Main.class")) {
                continue;
            }
            final File rawtmp = new File(dstwar, name);
            mkdir(rawtmp.getParentFile());
            rawtmp.deleteOnExit();
            try (FileOutputStream rawout = new FileOutputStream(rawtmp)) {
                try (InputStream in = zf.getInputStream(ze)) {
                    final byte[] buf = new byte[4096];
                    int n;
                    while ((n = in.read(buf, 0, buf.length)) > 0) {
                        rawout.write(buf, 0, n);
                    }
                }
            }
        }
    }
}
#method_after
private static void unpack(File srcwar, File dstwar) throws IOException {
    try (ZipFile zf = new ZipFile(srcwar)) {
        final Enumeration<? extends ZipEntry> e = zf.entries();
        while (e.hasMoreElements()) {
            final ZipEntry ze = e.nextElement();
            final String name = ze.getName();
            if (ze.isDirectory() || name.startsWith("WEB-INF/") || name.startsWith("META-INF/") || name.startsWith("com/google/gerrit/launcher/") || name.equals("Main.class")) {
                continue;
            }
            final File rawtmp = new File(dstwar, name);
            mkdir(rawtmp.getParentFile());
            rawtmp.deleteOnExit();
            try (FileOutputStream rawout = new FileOutputStream(rawtmp);
                InputStream in = zf.getInputStream(ze)) {
                final byte[] buf = new byte[4096];
                int n;
                while ((n = in.read(buf, 0, buf.length)) > 0) {
                    rawout.write(buf, 0, n);
                }
            }
        }
    }
}
#end_block

#method_before
private Resource useDeveloperBuild(ServletContextHandler app) throws IOException {
    final File dir = GerritLauncher.getDeveloperBuckOut();
    final File gen = new File(dir, "gen");
    final File root = dir.getParentFile();
    final File dstwar = makeWarTempDir();
    File ui = new File(dstwar, "gerrit_ui");
    File p = new File(ui, "permutations");
    mkdir(ui);
    p.createNewFile();
    p.deleteOnExit();
    app.addFilter(new FilterHolder(new Filter() {

        private final boolean gwtuiRecompile = System.getProperty("gerrit.disable-gwtui-recompile") == null;

        private final UserAgentRule rule = new UserAgentRule();

        private final Set<String> uaInitialized = new HashSet<>();

        private String lastTarget;

        private long lastTime;

        @Override
        public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            String pkg = "gerrit-gwtui";
            String target = "ui_" + rule.select((HttpServletRequest) request);
            if (gwtuiRecompile || !uaInitialized.contains(target)) {
                String rule = "//" + pkg + ":" + target;
                // TODO(davido): instead of assuming specific Buck's internal
                // target directory for gwt_binary() artifacts, ask Buck for
                // the location of user agent permutation GWT zip, e. g.:
                // $ buck targets --show_output //gerrit-gwtui:ui_safari \
                // | awk '{print $2}'
                String child = String.format("%s/__gwt_binary_%s__", pkg, target);
                File zip = new File(new File(gen, child), target + ".zip");
                synchronized (this) {
                    try {
                        build(root, gen, rule);
                    } catch (BuildFailureException e) {
                        displayFailure(rule, e.why, (HttpServletResponse) res);
                        return;
                    }
                    if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                        lastTarget = target;
                        lastTime = zip.lastModified();
                        unpack(zip, dstwar);
                    }
                }
                uaInitialized.add(target);
            }
            chain.doFilter(request, res);
        }

        private void displayFailure(String rule, byte[] why, HttpServletResponse res) throws IOException {
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setContentType("text/html");
            res.setCharacterEncoding(Charsets.UTF_8.name());
            CacheHeaders.setNotCacheable(res);
            Escaper html = HtmlEscapers.htmlEscaper();
            PrintWriter w = res.getWriter();
            w.write("<html><title>BUILD FAILED</title><body>");
            w.format("<h1>%s FAILED</h1>", html.escape(rule));
            w.write("<pre>");
            w.write(html.escape(RawParseUtils.decode(why)));
            w.write("</pre>");
            w.write("</body></html>");
            w.close();
        }

        @Override
        public void init(FilterConfig config) {
        }

        @Override
        public void destroy() {
        }
    }), "/", EnumSet.of(DispatcherType.REQUEST));
    return Resource.newResource(dstwar.toURI());
}
#method_after
private Resource useDeveloperBuild(ServletContextHandler app) throws IOException {
    final File dir = GerritLauncher.getDeveloperBuckOut();
    final File gen = new File(dir, "gen");
    final File root = dir.getParentFile();
    final File dstwar = makeWarTempDir();
    File ui = new File(dstwar, "gerrit_ui");
    File p = new File(ui, "permutations");
    mkdir(ui);
    p.createNewFile();
    p.deleteOnExit();
    app.addFilter(new FilterHolder(new Filter() {

        private final boolean gwtuiRecompile = System.getProperty("gerrit.disable-gwtui-recompile") == null;

        private final UserAgentRule rule = new UserAgentRule();

        private final Set<String> uaInitialized = new HashSet<>();

        private String lastTarget;

        private long lastTime;

        @Override
        public void doFilter(ServletRequest request, ServletResponse res, FilterChain chain) throws IOException, ServletException {
            String pkg = "gerrit-gwtui";
            String target = "ui_" + rule.select((HttpServletRequest) request);
            if (gwtuiRecompile || !uaInitialized.contains(target)) {
                String rule = "//" + pkg + ":" + target;
                // TODO(davido): instead of assuming specific Buck's internal
                // target directory for gwt_binary() artifacts, ask Buck for
                // the location of user agent permutation GWT zip, e. g.:
                // $ buck targets --show_output //gerrit-gwtui:ui_safari \
                // | awk '{print $2}'
                String child = String.format("%s/__gwt_binary_%s__", pkg, target);
                File zip = new File(new File(gen, child), target + ".zip");
                synchronized (this) {
                    try {
                        build(root, gen, rule);
                    } catch (BuildFailureException e) {
                        displayFailure(rule, e.why, (HttpServletResponse) res);
                        return;
                    }
                    if (!target.equals(lastTarget) || lastTime != zip.lastModified()) {
                        lastTarget = target;
                        lastTime = zip.lastModified();
                        unpack(zip, dstwar);
                    }
                }
                uaInitialized.add(target);
            }
            chain.doFilter(request, res);
        }

        private void displayFailure(String rule, byte[] why, HttpServletResponse res) throws IOException {
            res.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            res.setContentType("text/html");
            res.setCharacterEncoding(Charsets.UTF_8.name());
            CacheHeaders.setNotCacheable(res);
            Escaper html = HtmlEscapers.htmlEscaper();
            try (PrintWriter w = res.getWriter()) {
                w.write("<html><title>BUILD FAILED</title><body>");
                w.format("<h1>%s FAILED</h1>", html.escape(rule));
                w.write("<pre>");
                w.write(html.escape(RawParseUtils.decode(why)));
                w.write("</pre>");
                w.write("</body></html>");
            }
        }

        @Override
        public void init(FilterConfig config) {
        }

        @Override
        public void destroy() {
        }
    }), "/", EnumSet.of(DispatcherType.REQUEST));
    return Resource.newResource(dstwar.toURI());
}
#end_block

#method_before
@Override
public void onAddAccountsToGroup(Account.Id me, Collection<AccountGroupMember> added) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    for (AccountGroupMember m : added) {
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
        auditInserts.add(audit);
    }
    try {
        try (ReviewDb db = schema.open()) {
            db.accountGroupMembersAudit().insert(auditInserts);
        }
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e);
    }
}
#method_after
@Override
public void onAddAccountsToGroup(Account.Id me, Collection<AccountGroupMember> added) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    for (AccountGroupMember m : added) {
        AccountGroupMemberAudit audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
        auditInserts.add(audit);
    }
    try (ReviewDb db = schema.open()) {
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log add accounts to group event performed by user", me, added, e);
    }
}
#end_block

#method_before
@Override
public void onDeleteAccountsFromGroup(Account.Id me, Collection<AccountGroupMember> removed) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    List<AccountGroupMemberAudit> auditUpdates = Lists.newLinkedList();
    try {
        try (ReviewDb db = schema.open()) {
            for (AccountGroupMember m : removed) {
                AccountGroupMemberAudit audit = null;
                for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                    if (a.isActive()) {
                        audit = a;
                        break;
                    }
                }
                if (audit != null) {
                    audit.removed(me, TimeUtil.nowTs());
                    auditUpdates.add(audit);
                } else {
                    audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
                    audit.removedLegacy();
                    auditInserts.add(audit);
                }
            }
            db.accountGroupMembersAudit().update(auditUpdates);
            db.accountGroupMembersAudit().insert(auditInserts);
        }
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e);
    }
}
#method_after
@Override
public void onDeleteAccountsFromGroup(Account.Id me, Collection<AccountGroupMember> removed) {
    List<AccountGroupMemberAudit> auditInserts = Lists.newLinkedList();
    List<AccountGroupMemberAudit> auditUpdates = Lists.newLinkedList();
    try (ReviewDb db = schema.open()) {
        for (AccountGroupMember m : removed) {
            AccountGroupMemberAudit audit = null;
            for (AccountGroupMemberAudit a : db.accountGroupMembersAudit().byGroupAccount(m.getAccountGroupId(), m.getAccountId())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            } else {
                audit = new AccountGroupMemberAudit(m, me, TimeUtil.nowTs());
                audit.removedLegacy();
                auditInserts.add(audit);
            }
        }
        db.accountGroupMembersAudit().update(auditUpdates);
        db.accountGroupMembersAudit().insert(auditInserts);
    } catch (OrmException e) {
        logOrmExceptionForAccounts("Cannot log delete accounts from group event performed by user", me, removed, e);
    }
}
#end_block

#method_before
@Override
public void onAddGroupsToGroup(Account.Id me, Collection<AccountGroupById> added) {
    List<AccountGroupByIdAud> includesAudit = new ArrayList<>();
    for (AccountGroupById groupInclude : added) {
        AccountGroupByIdAud audit = new AccountGroupByIdAud(groupInclude, me, TimeUtil.nowTs());
        includesAudit.add(audit);
    }
    try {
        try (ReviewDb db = schema.open()) {
            db.accountGroupByIdAud().insert(includesAudit);
        }
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e);
    }
}
#method_after
@Override
public void onAddGroupsToGroup(Account.Id me, Collection<AccountGroupById> added) {
    List<AccountGroupByIdAud> includesAudit = new ArrayList<>();
    for (AccountGroupById groupInclude : added) {
        AccountGroupByIdAud audit = new AccountGroupByIdAud(groupInclude, me, TimeUtil.nowTs());
        includesAudit.add(audit);
    }
    try (ReviewDb db = schema.open()) {
        db.accountGroupByIdAud().insert(includesAudit);
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log add groups to group event performed by user", me, added, e);
    }
}
#end_block

#method_before
@Override
public void onDeleteGroupsFromGroup(Account.Id me, Collection<AccountGroupById> removed) {
    final List<AccountGroupByIdAud> auditUpdates = Lists.newLinkedList();
    try {
        try (ReviewDb db = schema.open()) {
            for (final AccountGroupById g : removed) {
                AccountGroupByIdAud audit = null;
                for (AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) {
                    if (a.isActive()) {
                        audit = a;
                        break;
                    }
                }
                if (audit != null) {
                    audit.removed(me, TimeUtil.nowTs());
                    auditUpdates.add(audit);
                }
            }
            db.accountGroupByIdAud().update(auditUpdates);
        }
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e);
    }
}
#method_after
@Override
public void onDeleteGroupsFromGroup(Account.Id me, Collection<AccountGroupById> removed) {
    final List<AccountGroupByIdAud> auditUpdates = Lists.newLinkedList();
    try (ReviewDb db = schema.open()) {
        for (final AccountGroupById g : removed) {
            AccountGroupByIdAud audit = null;
            for (AccountGroupByIdAud a : db.accountGroupByIdAud().byGroupInclude(g.getGroupId(), g.getIncludeUUID())) {
                if (a.isActive()) {
                    audit = a;
                    break;
                }
            }
            if (audit != null) {
                audit.removed(me, TimeUtil.nowTs());
                auditUpdates.add(audit);
            }
        }
        db.accountGroupByIdAud().update(auditUpdates);
    } catch (OrmException e) {
        logOrmExceptionForGroups("Cannot log delete groups from group event performed by user", me, removed, e);
    }
}
#end_block

#method_before
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    byte[] compressedIndex = zip(index());
    JarOutputStream jar = new JarOutputStream(new FileOutputStream(outFile));
    JarEntry entry = new JarEntry(String.format("%s/%s", Constants.PACKAGE, Constants.INDEX_ZIP));
    entry.setSize(compressedIndex.length);
    jar.putNextEntry(entry);
    jar.write(compressedIndex);
    jar.closeEntry();
    jar.close();
}
#method_after
private void invoke(String... parameters) throws IOException {
    CmdLineParser parser = new CmdLineParser(this);
    try {
        parser.parseArgument(parameters);
        if (inputFiles.isEmpty()) {
            throw new CmdLineException(parser, "FAILED: input file missing");
        }
    } catch (CmdLineException e) {
        System.err.println(e.getMessage());
        parser.printUsage(System.err);
        System.exit(1);
        return;
    }
    try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(outFile))) {
        byte[] compressedIndex = zip(index());
        JarEntry entry = new JarEntry(String.format("%s/%s", Constants.PACKAGE, Constants.INDEX_ZIP));
        entry.setSize(compressedIndex.length);
        jar.putNextEntry(entry);
        jar.write(compressedIndex);
        jar.closeEntry();
    }
}
#end_block

#method_before
private RAMDirectory index() throws IOException, UnsupportedEncodingException, FileNotFoundException {
    RAMDirectory directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(new StandardAnalyzer(CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    config.setCommitOnClose(true);
    IndexWriter iwriter = new IndexWriter(directory, config);
    for (String inputFile : inputFiles) {
        File file = new File(inputFile);
        if (file.length() == 0) {
            continue;
        }
        BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
        String title = titleReader.readLine();
        if (title != null && title.startsWith("[[")) {
            // Generally the first line of the txt is the title. In a few cases the
            // first line is a "[[tag]]" and the second line is the title.
            title = titleReader.readLine();
        }
        titleReader.close();
        Matcher matcher = SECTION_HEADER.matcher(title);
        if (matcher.matches()) {
            title = matcher.group(1);
        }
        String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
        FileReader reader = new FileReader(file);
        Document doc = new Document();
        doc.add(new TextField(Constants.DOC_FIELD, reader));
        doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
        doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
        iwriter.addDocument(doc);
        reader.close();
    }
    iwriter.close();
    return directory;
}
#method_after
private RAMDirectory index() throws IOException, UnsupportedEncodingException, FileNotFoundException {
    RAMDirectory directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(new StandardAnalyzer(CharArraySet.EMPTY_SET));
    config.setOpenMode(OpenMode.CREATE);
    config.setCommitOnClose(true);
    try (IndexWriter iwriter = new IndexWriter(directory, config)) {
        for (String inputFile : inputFiles) {
            File file = new File(inputFile);
            if (file.length() == 0) {
                continue;
            }
            String title;
            try (BufferedReader titleReader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"))) {
                title = titleReader.readLine();
                if (title != null && title.startsWith("[[")) {
                    // Generally the first line of the txt is the title. In a few cases the
                    // first line is a "[[tag]]" and the second line is the title.
                    title = titleReader.readLine();
                }
            }
            Matcher matcher = SECTION_HEADER.matcher(title);
            if (matcher.matches()) {
                title = matcher.group(1);
            }
            String outputFile = AsciiDoctor.mapInFileToOutFile(inputFile, inExt, outExt);
            try (FileReader reader = new FileReader(file)) {
                Document doc = new Document();
                doc.add(new TextField(Constants.DOC_FIELD, reader));
                doc.add(new StringField(Constants.URL_FIELD, prefix + outputFile, Field.Store.YES));
                doc.add(new TextField(Constants.TITLE_FIELD, title, Field.Store.YES));
                iwriter.addDocument(doc);
            }
        }
    }
    return directory;
}
#end_block

#method_before
private byte[] zip(RAMDirectory dir) throws IOException {
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    ZipOutputStream zip = new ZipOutputStream(buf);
    for (String name : dir.listAll()) {
        try (IndexInput in = dir.openInput(name, null)) {
            int len = (int) in.length();
            byte[] tmp = new byte[len];
            ZipEntry entry = new ZipEntry(name);
            entry.setSize(len);
            in.readBytes(tmp, 0, len);
            zip.putNextEntry(entry);
            zip.write(tmp, 0, len);
            zip.closeEntry();
        }
    }
    zip.close();
    return buf.toByteArray();
}
#method_after
private byte[] zip(RAMDirectory dir) throws IOException {
    ByteArrayOutputStream buf = new ByteArrayOutputStream();
    try (ZipOutputStream zip = new ZipOutputStream(buf)) {
        for (String name : dir.listAll()) {
            try (IndexInput in = dir.openInput(name, null)) {
                int len = (int) in.length();
                byte[] tmp = new byte[len];
                ZipEntry entry = new ZipEntry(name);
                entry.setSize(len);
                in.readBytes(tmp, 0, len);
                zip.putNextEntry(entry);
                zip.write(tmp, 0, len);
                zip.closeEntry();
            }
        }
    }
    return buf.toByteArray();
}
#end_block

#method_before
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy, boolean save) throws IOException {
    String hash = b.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(b.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = b.getParent(0);
            RevCommit theirs = b.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024);
                try {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8");
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                } finally {
                    buf.destroy();
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        if (save) {
            RefUpdate update = repo.updateRef(refName);
            update.setNewObjectId(treeId);
            update.disableRefLog();
            update.forceUpdate();
        }
        return rw.lookupTree(treeId);
    }
}
#method_after
public static RevTree automerge(Repository repo, RevWalk rw, RevCommit b, ThreeWayMergeStrategy mergeStrategy, boolean save) throws IOException {
    String hash = b.name();
    String refName = RefNames.REFS_CACHE_AUTOMERGE + hash.substring(0, 2) + "/" + hash.substring(2);
    Ref ref = repo.getRefDatabase().exactRef(refName);
    if (ref != null && ref.getObjectId() != null) {
        return rw.parseTree(ref.getObjectId());
    }
    ResolveMerger m = (ResolveMerger) mergeStrategy.newMerger(repo, true);
    try (ObjectInserter ins = repo.newObjectInserter()) {
        DirCache dc = DirCache.newInCore();
        m.setDirCache(dc);
        m.setObjectInserter(new ObjectInserter.Filter() {

            @Override
            protected ObjectInserter delegate() {
                return ins;
            }

            @Override
            public void flush() {
            }

            @Override
            public void close() {
            }
        });
        boolean couldMerge;
        try {
            couldMerge = m.merge(b.getParents());
        } catch (IOException e) {
            // It is not safe to continue further down in this method as throwing
            // an exception most likely means that the merge tree was not created
            // and m.getMergeResults() is empty. This would mean that all paths are
            // unmerged and Gerrit UI would show all paths in the patch list.
            log.warn("Error attempting automerge " + refName, e);
            return null;
        }
        ObjectId treeId;
        if (couldMerge) {
            treeId = m.getResultTreeId();
        } else {
            RevCommit ours = b.getParent(0);
            RevCommit theirs = b.getParent(1);
            rw.parseBody(ours);
            rw.parseBody(theirs);
            String oursMsg = ours.getShortMessage();
            String theirsMsg = theirs.getShortMessage();
            String oursName = String.format("HEAD   (%s %s)", ours.abbreviate(6).name(), oursMsg.substring(0, Math.min(oursMsg.length(), 60)));
            String theirsName = String.format("BRANCH (%s %s)", theirs.abbreviate(6).name(), theirsMsg.substring(0, Math.min(theirsMsg.length(), 60)));
            MergeFormatter fmt = new MergeFormatter();
            Map<String, MergeResult<? extends Sequence>> r = m.getMergeResults();
            Map<String, ObjectId> resolved = new HashMap<>();
            for (Map.Entry<String, MergeResult<? extends Sequence>> entry : r.entrySet()) {
                MergeResult<? extends Sequence> p = entry.getValue();
                TemporaryBuffer buf = new TemporaryBuffer.LocalFile(null, 10 * 1024 * 1024);
                try {
                    fmt.formatMerge(buf, p, "BASE", oursName, theirsName, "UTF-8");
                    buf.close();
                    try (InputStream in = buf.openInputStream()) {
                        resolved.put(entry.getKey(), ins.insert(Constants.OBJ_BLOB, buf.length(), in));
                    }
                } finally {
                    buf.destroy();
                }
            }
            DirCacheBuilder builder = dc.builder();
            int cnt = dc.getEntryCount();
            for (int i = 0; i < cnt; ) {
                DirCacheEntry entry = dc.getEntry(i);
                if (entry.getStage() == 0) {
                    builder.add(entry);
                    i++;
                    continue;
                }
                int next = dc.nextEntry(i);
                String path = entry.getPathString();
                DirCacheEntry res = new DirCacheEntry(path);
                if (resolved.containsKey(path)) {
                    // For a file with content merge conflict that we produced a result
                    // above on, collapse the file down to a single stage 0 with just
                    // the blob content, and a randomly selected mode (the lowest stage,
                    // which should be the merge base, or ours).
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(resolved.get(path));
                } else if (next == i + 1) {
                    // If there is exactly one stage present, shouldn't be a conflict...
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else if (next == i + 2) {
                    // Two stages suggests a delete/modify conflict. Pick the higher
                    // stage as the automatic result.
                    entry = dc.getEntry(i + 1);
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                } else {
                    // 3 stage conflict, no resolve above
                    // Punt on the 3-stage conflict and show the base, for now.
                    res.setFileMode(entry.getFileMode());
                    res.setObjectId(entry.getObjectId());
                }
                builder.add(res);
                i = next;
            }
            builder.finish();
            treeId = dc.writeTree(ins);
        }
        ins.flush();
        if (save) {
            RefUpdate update = repo.updateRef(refName);
            update.setNewObjectId(treeId);
            update.disableRefLog();
            update.forceUpdate();
        }
        return rw.lookupTree(treeId);
    }
}
#end_block

#method_before
public Project createProject(CreateProjectArgs args) throws BadRequestException, ResourceConflictException, IOException, ConfigInvalidException {
    final Project.NameKey nameKey = args.getProject();
    try {
        final String head = args.permissionsOnly ? RefNames.REFS_CONFIG : args.branch.get(0);
        try (Repository repo = repoManager.createRepository(nameKey)) {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                try {
                    l.onNewProjectCreated(event);
                } catch (RuntimeException e) {
                    log.warn("Failure in NewProjectCreatedListener", e);
                }
            }
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig(args);
            if (!args.permissionsOnly && args.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, args.branch);
            }
            return projectCache.get(nameKey).getProject();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ResourceConflictException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.");
    } catch (RepositoryNotFoundException badName) {
        throw new BadRequestException("invalid project name: " + nameKey);
    } catch (IllegalStateException err) {
        try {
            try (Repository repo = repoManager.openRepository(nameKey)) {
                if (repo.getObjectDatabase().exists()) {
                    throw new ResourceConflictException("project \"" + nameKey + "\" exists");
                }
                throw err;
            }
        } catch (IOException ioErr) {
            String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw ioErr;
        }
    } catch (ConfigInvalidException e) {
        String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw e;
    }
}
#method_after
public Project createProject(CreateProjectArgs args) throws BadRequestException, ResourceConflictException, IOException, ConfigInvalidException {
    final Project.NameKey nameKey = args.getProject();
    try {
        final String head = args.permissionsOnly ? RefNames.REFS_CONFIG : args.branch.get(0);
        try (Repository repo = repoManager.createRepository(nameKey)) {
            NewProjectCreatedListener.Event event = new NewProjectCreatedListener.Event() {

                @Override
                public String getProjectName() {
                    return nameKey.get();
                }

                @Override
                public String getHeadName() {
                    return head;
                }
            };
            for (NewProjectCreatedListener l : createdListener) {
                try {
                    l.onNewProjectCreated(event);
                } catch (RuntimeException e) {
                    log.warn("Failure in NewProjectCreatedListener", e);
                }
            }
            RefUpdate u = repo.updateRef(Constants.HEAD);
            u.disableRefLog();
            u.link(head);
            createProjectConfig(args);
            if (!args.permissionsOnly && args.createEmptyCommit) {
                createEmptyCommits(repo, nameKey, args.branch);
            }
            return projectCache.get(nameKey).getProject();
        }
    } catch (RepositoryCaseMismatchException e) {
        throw new ResourceConflictException("Cannot create " + nameKey.get() + " because the name is already occupied by another project." + " The other project has the same name, only spelled in a" + " different case.");
    } catch (RepositoryNotFoundException badName) {
        throw new BadRequestException("invalid project name: " + nameKey);
    } catch (IllegalStateException err) {
        try (Repository repo = repoManager.openRepository(nameKey)) {
            if (repo.getObjectDatabase().exists()) {
                throw new ResourceConflictException("project \"" + nameKey + "\" exists");
            }
            throw err;
        } catch (IOException ioErr) {
            String msg = "Cannot create " + nameKey;
            log.error(msg, err);
            throw ioErr;
        }
    } catch (ConfigInvalidException e) {
        String msg = "Cannot create " + nameKey;
        log.error(msg, e);
        throw e;
    }
}
#end_block

#method_before
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                try (ReviewDb reviewDb = schemaFactory.open()) {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                }
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#method_after
private void sendMergedEmail(final Change c, final PatchSetApproval from) {
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try (ReviewDb reviewDb = schemaFactory.open()) {
                patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
                return;
            }
            try {
                MergedSender cm = mergedSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email for submitted patch set " + c.getId(), e);
            }
        }

        @Override
        public String toString() {
            return "send-email merged";
        }
    }));
}
#end_block

#method_before
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    logDebug("Possibly sending merge failure notification for {}", notes.getChangeId());
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        logError("Cannot get submitter for change " + notes.getChangeId(), e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            if (msg != null) {
                cmUtil.addChangeMessage(db, update, msg);
            }
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        logWarn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    indexer.index(db, change);
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try {
                try (ReviewDb reviewDb = schemaFactory.open()) {
                    patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
                }
            } catch (Exception e) {
                logError("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                MergeFailSender cm = mergeFailSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            logError("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#method_after
private void sendMergeFail(ChangeNotes notes, final ChangeMessage msg, boolean makeNew) throws NoSuchChangeException, IOException {
    logDebug("Possibly sending merge failure notification for {}", notes.getChangeId());
    PatchSetApproval submitter = null;
    try {
        submitter = approvalsUtil.getSubmitter(db, notes, notes.getChange().currentPatchSetId());
    } catch (Exception e) {
        logError("Cannot get submitter for change " + notes.getChangeId(), e);
    }
    if (!makeNew) {
        RetryStatus retryStatus = getRetryStatus(submitter, msg, notes);
        if (retryStatus == RetryStatus.RETRY_NO_MESSAGE) {
            return;
        } else if (retryStatus == RetryStatus.UNSUBMIT) {
            makeNew = true;
        }
    }
    final boolean setStatusNew = makeNew;
    final Change c = notes.getChange();
    Change change = null;
    ChangeUpdate update = null;
    try {
        db.changes().beginTransaction(c.getId());
        try {
            change = db.changes().atomicUpdate(c.getId(), new AtomicUpdate<Change>() {

                @Override
                public Change update(Change c) {
                    if (c.getStatus().isOpen()) {
                        if (setStatusNew) {
                            c.setStatus(Change.Status.NEW);
                        }
                        ChangeUtil.updated(c);
                    }
                    return c;
                }
            });
            ChangeControl control = changeControl(change);
            // TODO(yyonas): atomic change is not propagated.
            update = updateFactory.create(control, c.getLastUpdatedOn());
            if (msg != null) {
                cmUtil.addChangeMessage(db, update, msg);
            }
            db.commit();
        } finally {
            db.rollback();
        }
    } catch (OrmException err) {
        logWarn("Cannot record merge failure message", err);
    }
    if (update != null) {
        update.commit();
    }
    indexer.index(db, change);
    final PatchSetApproval from = submitter;
    workQueue.getDefaultQueue().submit(requestScopePropagator.wrap(new Runnable() {

        @Override
        public void run() {
            PatchSet patchSet;
            try (ReviewDb reviewDb = schemaFactory.open()) {
                patchSet = reviewDb.patchSets().get(c.currentPatchSetId());
            } catch (Exception e) {
                logError("Cannot send email notifications about merge failure", e);
                return;
            }
            try {
                MergeFailSender cm = mergeFailSenderFactory.create(c.getId());
                if (from != null) {
                    cm.setFrom(from.getAccountId());
                }
                cm.setPatchSet(patchSet);
                cm.setChangeMessage(msg);
                cm.send();
            } catch (Exception e) {
                logError("Cannot send email notifications about merge failure", e);
            }
        }

        @Override
        public String toString() {
            return "send-email merge-failed";
        }
    }));
    if (submitter != null) {
        try {
            hooks.doMergeFailedHook(c, accountCache.get(submitter.getAccountId()).getAccount(), db.patchSets().get(c.currentPatchSetId()), msg.getMessage(), db);
        } catch (OrmException ex) {
            logError("Cannot run hook for merge failed " + c.getId(), ex);
        }
    }
}
#end_block

#method_before
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (isGetOrHead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isGetOrHead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req);
                    viewData = new ViewData(null, null);
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                        status = SC_CREATED;
                    } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                        @SuppressWarnings("unchecked")
                        AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                        status = SC_NO_CONTENT;
                    } else {
                        throw e;
                    }
                }
                if (viewData.view == null) {
                    viewData = view(rsrc, c, req.getMethod(), path);
                }
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else if (viewData.view instanceof RestReadView<?>) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        replyError(req, res, status = 422, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#method_after
@Override
protected final void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    long auditStartTs = TimeUtil.nowMs();
    res.setHeader("Content-Disposition", "attachment");
    res.setHeader("X-Content-Type-Options", "nosniff");
    int status = SC_OK;
    Object result = null;
    Multimap<String, String> params = LinkedHashMultimap.create();
    Object inputRequestBody = null;
    RestResource rsrc = TopLevelResource.INSTANCE;
    ViewData viewData = null;
    try {
        checkUserSession(req);
        List<IdString> path = splitPath(req);
        RestCollection<RestResource, RestResource> rc = members.get();
        CapabilityUtils.checkRequiresCapability(globals.currentUser, null, rc.getClass());
        viewData = new ViewData(null, null);
        if (path.isEmpty()) {
            if (isGetOrHead(req)) {
                viewData = new ViewData(null, rc.list());
            } else if (rc instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                @SuppressWarnings("unchecked")
                AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) rc;
                viewData = new ViewData(null, ac.post(rsrc));
            } else {
                throw new MethodNotAllowedException();
            }
        } else {
            IdString id = path.remove(0);
            try {
                rsrc = rc.parse(rsrc, id);
                if (path.isEmpty()) {
                    checkPreconditions(req);
                }
            } catch (ResourceNotFoundException e) {
                if (rc instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                    @SuppressWarnings("unchecked")
                    AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) rc;
                    viewData = new ViewData(null, ac.create(rsrc, id));
                    status = SC_CREATED;
                } else {
                    throw e;
                }
            }
            if (viewData.view == null) {
                viewData = view(rsrc, rc, req.getMethod(), path);
            }
        }
        checkRequiresCapability(viewData);
        while (viewData.view instanceof RestCollection<?, ?>) {
            @SuppressWarnings("unchecked")
            RestCollection<RestResource, RestResource> c = (RestCollection<RestResource, RestResource>) viewData.view;
            if (path.isEmpty()) {
                if (isGetOrHead(req)) {
                    viewData = new ViewData(null, c.list());
                } else if (c instanceof AcceptsPost && "POST".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsPost<RestResource> ac = (AcceptsPost<RestResource>) c;
                    viewData = new ViewData(null, ac.post(rsrc));
                } else if (c instanceof AcceptsDelete && "DELETE".equals(req.getMethod())) {
                    @SuppressWarnings("unchecked")
                    AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                    viewData = new ViewData(null, ac.delete(rsrc, null));
                } else {
                    throw new MethodNotAllowedException();
                }
                break;
            } else {
                IdString id = path.remove(0);
                try {
                    rsrc = c.parse(rsrc, id);
                    checkPreconditions(req);
                    viewData = new ViewData(null, null);
                } catch (ResourceNotFoundException e) {
                    if (c instanceof AcceptsCreate && path.isEmpty() && ("POST".equals(req.getMethod()) || "PUT".equals(req.getMethod()))) {
                        @SuppressWarnings("unchecked")
                        AcceptsCreate<RestResource> ac = (AcceptsCreate<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.create(rsrc, id));
                        status = SC_CREATED;
                    } else if (c instanceof AcceptsDelete && path.isEmpty() && "DELETE".equals(req.getMethod())) {
                        @SuppressWarnings("unchecked")
                        AcceptsDelete<RestResource> ac = (AcceptsDelete<RestResource>) c;
                        viewData = new ViewData(viewData.pluginName, ac.delete(rsrc, id));
                        status = SC_NO_CONTENT;
                    } else {
                        throw e;
                    }
                }
                if (viewData.view == null) {
                    viewData = view(rsrc, c, req.getMethod(), path);
                }
            }
            checkRequiresCapability(viewData);
        }
        if (notModified(req, rsrc, viewData.view)) {
            res.sendError(SC_NOT_MODIFIED);
            return;
        }
        Multimap<String, String> config = LinkedHashMultimap.create();
        ParameterParser.splitQueryString(req.getQueryString(), config, params);
        if (!globals.paramParser.get().parse(viewData.view, params, req, res)) {
            return;
        }
        if (viewData.view instanceof RestReadView<?> && "GET".equals(req.getMethod())) {
            result = ((RestReadView<RestResource>) viewData.view).apply(rsrc);
        } else if (viewData.view instanceof RestModifyView<?, ?>) {
            @SuppressWarnings("unchecked")
            RestModifyView<RestResource, Object> m = (RestModifyView<RestResource, Object>) viewData.view;
            inputRequestBody = parseRequest(req, inputType(m));
            result = m.apply(rsrc, inputRequestBody);
        } else {
            throw new ResourceNotFoundException();
        }
        if (result instanceof Response) {
            @SuppressWarnings("rawtypes")
            Response<?> r = (Response) result;
            status = r.statusCode();
            configureCaching(req, res, rsrc, r.caching());
        } else if (result instanceof Response.Redirect) {
            CacheHeaders.setNotCacheable(res);
            res.sendRedirect(((Response.Redirect) result).location());
            return;
        } else {
            CacheHeaders.setNotCacheable(res);
        }
        res.setStatus(status);
        if (result != Response.none()) {
            result = Response.unwrap(result);
            if (result instanceof BinaryResult) {
                replyBinaryResult(req, res, (BinaryResult) result);
            } else {
                replyJson(req, res, config, result);
            }
        }
    } catch (MalformedJsonException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (JsonParseException e) {
        replyError(req, res, status = SC_BAD_REQUEST, "Invalid " + JSON_TYPE + " in request", e);
    } catch (BadRequestException e) {
        replyError(req, res, status = SC_BAD_REQUEST, messageOr(e, "Bad Request"), e.caching(), e);
    } catch (AuthException e) {
        replyError(req, res, status = SC_FORBIDDEN, messageOr(e, "Forbidden"), e.caching(), e);
    } catch (AmbiguousViewException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Ambiguous"), e);
    } catch (ResourceNotFoundException e) {
        replyError(req, res, status = SC_NOT_FOUND, messageOr(e, "Not Found"), e.caching(), e);
    } catch (MethodNotAllowedException e) {
        replyError(req, res, status = SC_METHOD_NOT_ALLOWED, messageOr(e, "Method Not Allowed"), e.caching(), e);
    } catch (ResourceConflictException e) {
        replyError(req, res, status = SC_CONFLICT, messageOr(e, "Conflict"), e.caching(), e);
    } catch (PreconditionFailedException e) {
        replyError(req, res, status = SC_PRECONDITION_FAILED, messageOr(e, "Precondition Failed"), e.caching(), e);
    } catch (UnprocessableEntityException e) {
        replyError(req, res, status = 422, messageOr(e, "Unprocessable Entity"), e.caching(), e);
    } catch (NotImplementedException e) {
        replyError(req, res, status = SC_NOT_IMPLEMENTED, messageOr(e, "Not Implemented"), e);
    } catch (Exception e) {
        status = SC_INTERNAL_SERVER_ERROR;
        handleException(e, req, res);
    } finally {
        globals.auditService.dispatch(new ExtendedHttpAuditEvent(globals.webSession.get().getSessionId(), globals.currentUser.get(), req, auditStartTs, params, inputRequestBody, status, result, rsrc, viewData == null ? null : viewData.view));
    }
}
#end_block

#method_before
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, 20 << 20);
    GZIPOutputStream gz = new GZIPOutputStream(buf);
    bin.writeTo(gz);
    gz.close();
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#method_after
private static BinaryResult compress(BinaryResult bin) throws IOException {
    TemporaryBuffer.Heap buf = heap(HEAP_EST_SIZE, 20 << 20);
    try (GZIPOutputStream gz = new GZIPOutputStream(buf)) {
        bin.writeTo(gz);
    }
    return asBinaryResult(buf).setContentType(bin.getContentType());
}
#end_block

#method_before
public InMemoryDatabase create() throws OrmException {
    if (!created) {
        created = true;
        try (ReviewDb c = open()) {
            try {
                schemaCreator.create(c);
            } catch (IOException e) {
                throw new OrmException("Cannot create in-memory database", e);
            } catch (ConfigInvalidException e) {
                throw new OrmException("Cannot create in-memory database", e);
            }
        }
    }
    return this;
}
#method_after
public InMemoryDatabase create() throws OrmException {
    if (!created) {
        created = true;
        try (ReviewDb c = open()) {
            schemaCreator.create(c);
        } catch (IOException | ConfigInvalidException e) {
            throw new OrmException("Cannot create in-memory database", e);
        }
    }
    return this;
}
#end_block

#method_before
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        BufferedReader reader = new BufferedReader(isr);
        StringBuilder aboutContent = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (line.isEmpty()) {
                aboutContent.append("\n");
            } else {
                aboutContent.append(line).append("\n");
            }
        }
        reader.close();
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#method_after
private void sendAutoIndex(PluginContentScanner scanner, String prefix, String pluginName, PluginResourceKey cacheKey, HttpServletResponse res, long lastModifiedTime) throws IOException {
    List<PluginEntry> cmds = Lists.newArrayList();
    List<PluginEntry> servlets = Lists.newArrayList();
    List<PluginEntry> restApis = Lists.newArrayList();
    List<PluginEntry> docs = Lists.newArrayList();
    PluginEntry about = null;
    Enumeration<PluginEntry> entries = scanner.entries();
    while (entries.hasMoreElements()) {
        PluginEntry entry = entries.nextElement();
        String name = entry.getName();
        Optional<Long> size = entry.getSize();
        if (name.startsWith(prefix) && (name.endsWith(".md") || name.endsWith(".html")) && size.isPresent() && 0 < size.get() && size.get() <= SMALL_RESOURCE) {
            name = name.substring(prefix.length());
            if (name.startsWith("cmd-")) {
                cmds.add(entry);
            } else if (name.startsWith("servlet-")) {
                servlets.add(entry);
            } else if (name.startsWith("rest-api-")) {
                restApis.add(entry);
            } else if (name.startsWith("about.")) {
                if (about == null) {
                    about = entry;
                }
            } else {
                docs.add(entry);
            }
        }
    }
    Collections.sort(cmds, PluginEntry.COMPARATOR_BY_NAME);
    Collections.sort(docs, PluginEntry.COMPARATOR_BY_NAME);
    StringBuilder md = new StringBuilder();
    md.append(String.format("# Plugin %s #\n", pluginName));
    md.append("\n");
    appendPluginInfoTable(md, scanner.getManifest().getMainAttributes());
    if (about != null) {
        InputStreamReader isr = new InputStreamReader(scanner.getInputStream(about));
        StringBuilder aboutContent = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(isr)) {
            String line;
            while ((line = reader.readLine()) != null) {
                line = line.trim();
                if (line.isEmpty()) {
                    aboutContent.append("\n");
                } else {
                    aboutContent.append(line).append("\n");
                }
            }
        }
        // Only append the About section if there was anything in it
        if (aboutContent.toString().trim().length() > 0) {
            md.append("## About ##\n");
            md.append("\n").append(aboutContent);
        }
    }
    appendEntriesSection(scanner, docs, "Documentation", md, prefix, 0);
    appendEntriesSection(scanner, servlets, "Servlets", md, prefix, "servlet-".length());
    appendEntriesSection(scanner, restApis, "REST APIs", md, prefix, "rest-api-".length());
    appendEntriesSection(scanner, cmds, "Commands", md, prefix, "cmd-".length());
    sendMarkdownAsHtml(md.toString(), pluginName, cacheKey, res, lastModifiedTime);
}
#end_block

#method_before
private static String getVersion(final File me) {
    if (me == null) {
        return "";
    }
    try {
        try (JarFile jar = new JarFile(me)) {
            Manifest mf = jar.getManifest();
            Attributes att = mf.getMainAttributes();
            String val = att.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
            return val != null ? val : "";
        }
    } catch (IOException e) {
        return "";
    }
}
#method_after
private static String getVersion(final File me) {
    if (me == null) {
        return "";
    }
    try (JarFile jar = new JarFile(me)) {
        Manifest mf = jar.getManifest();
        Attributes att = mf.getMainAttributes();
        String val = att.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
        return val != null ? val : "";
    } catch (IOException e) {
        return "";
    }
}
#end_block

#method_before
private static ClassLoader libClassLoader(boolean prologCompiler) throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED.equals(e.getMessage())) {
            return useDevClasspath();
        }
        throw e;
    }
    final SortedMap<String, URL> jars = new TreeMap<>();
    try {
        try (ZipFile zf = new ZipFile(path)) {
            final Enumeration<? extends ZipEntry> e = zf.entries();
            while (e.hasMoreElements()) {
                final ZipEntry ze = e.nextElement();
                if (ze.isDirectory()) {
                    continue;
                }
                String name = ze.getName();
                if (name.startsWith("WEB-INF/lib/")) {
                    extractJar(zf, ze, jars);
                } else if (name.startsWith("WEB-INF/pgm-lib/")) {
                    // Some Prolog tools are restricted.
                    if (prologCompiler || !name.startsWith("WEB-INF/pgm-lib/prolog-")) {
                        extractJar(zf, ze, jars);
                    }
                }
            }
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    // The extension API needs to be its own ClassLoader, along
    // with a few of its dependencies. Try to construct this first.
    List<URL> extapi = new ArrayList<>();
    move(jars, "gerrit-extension-api-", extapi);
    move(jars, "guice-", extapi);
    move(jars, "javax.inject-1.jar", extapi);
    move(jars, "aopalliance-1.0.jar", extapi);
    move(jars, "guice-servlet-", extapi);
    move(jars, "tomcat-servlet-api-", extapi);
    ClassLoader parent = ClassLoader.getSystemClassLoader();
    if (!extapi.isEmpty()) {
        parent = new URLClassLoader(extapi.toArray(new URL[extapi.size()]), parent);
    }
    return new URLClassLoader(jars.values().toArray(new URL[jars.size()]), parent);
}
#method_after
private static ClassLoader libClassLoader(boolean prologCompiler) throws IOException {
    final File path;
    try {
        path = getDistributionArchive();
    } catch (FileNotFoundException e) {
        if (NOT_ARCHIVED.equals(e.getMessage())) {
            return useDevClasspath();
        }
        throw e;
    }
    final SortedMap<String, URL> jars = new TreeMap<>();
    try (ZipFile zf = new ZipFile(path)) {
        final Enumeration<? extends ZipEntry> e = zf.entries();
        while (e.hasMoreElements()) {
            final ZipEntry ze = e.nextElement();
            if (ze.isDirectory()) {
                continue;
            }
            String name = ze.getName();
            if (name.startsWith("WEB-INF/lib/")) {
                extractJar(zf, ze, jars);
            } else if (name.startsWith("WEB-INF/pgm-lib/")) {
                // Some Prolog tools are restricted.
                if (prologCompiler || !name.startsWith("WEB-INF/pgm-lib/prolog-")) {
                    extractJar(zf, ze, jars);
                }
            }
        }
    } catch (IOException e) {
        throw new IOException("Cannot obtain libraries from " + path, e);
    }
    if (jars.isEmpty()) {
        return GerritLauncher.class.getClassLoader();
    }
    // The extension API needs to be its own ClassLoader, along
    // with a few of its dependencies. Try to construct this first.
    List<URL> extapi = new ArrayList<>();
    move(jars, "gerrit-extension-api-", extapi);
    move(jars, "guice-", extapi);
    move(jars, "javax.inject-1.jar", extapi);
    move(jars, "aopalliance-1.0.jar", extapi);
    move(jars, "guice-servlet-", extapi);
    move(jars, "tomcat-servlet-api-", extapi);
    ClassLoader parent = ClassLoader.getSystemClassLoader();
    if (!extapi.isEmpty()) {
        parent = new URLClassLoader(extapi.toArray(new URL[extapi.size()]), parent);
    }
    return new URLClassLoader(jars.values().toArray(new URL[jars.size()]), parent);
}
#end_block

#method_before
private static void extractJar(ZipFile zf, ZipEntry ze, SortedMap<String, URL> jars) throws IOException {
    File tmp = createTempFile(safeName(ze), ".jar");
    try (FileOutputStream out = new FileOutputStream(tmp)) {
        try (InputStream in = zf.getInputStream(ze)) {
            byte[] buf = new byte[4096];
            int n;
            while ((n = in.read(buf, 0, buf.length)) > 0) {
                out.write(buf, 0, n);
            }
        }
    }
    String name = ze.getName();
    jars.put(name.substring(name.lastIndexOf('/'), name.length()), tmp.toURI().toURL());
}
#method_after
private static void extractJar(ZipFile zf, ZipEntry ze, SortedMap<String, URL> jars) throws IOException {
    File tmp = createTempFile(safeName(ze), ".jar");
    try (FileOutputStream out = new FileOutputStream(tmp);
        InputStream in = zf.getInputStream(ze)) {
        byte[] buf = new byte[4096];
        int n;
        while ((n = in.read(buf, 0, buf.length)) > 0) {
            out.write(buf, 0, n);
        }
    }
    String name = ze.getName();
    jars.put(name.substring(name.lastIndexOf('/'), name.length()), tmp.toURI().toURL());
}
#end_block

#method_before
private static File locateMyArchive() throws FileNotFoundException {
    final ClassLoader myCL = GerritLauncher.class.getClassLoader();
    final String myName = GerritLauncher.class.getName().replace('.', '/') + ".class";
    final URL myClazz = myCL.getResource(myName);
    if (myClazz == null) {
        throw new FileNotFoundException("Cannot find JAR: no " + myName);
    }
    // 
    try {
        JarFile jar = ((JarURLConnection) myClazz.openConnection()).getJarFile();
        File path = new File(jar.getName());
        if (path.isFile()) {
            return path;
        }
    } catch (Exception e) {
    // Nope, that didn't work. Try a different method.
    // 
    }
    // 
    if ("file".equals(myClazz.getProtocol())) {
        final File path = new File(myClazz.getPath());
        if (path.isFile() && path.getParentFile().isDirectory()) {
            throw new FileNotFoundException(NOT_ARCHIVED);
        }
    }
    // The CodeSource might be able to give us the source as a stream.
    // If so, copy it to a local file so we have random access to it.
    // 
    final CodeSource src = GerritLauncher.class.getProtectionDomain().getCodeSource();
    if (src != null) {
        try {
            try (InputStream in = src.getLocation().openStream()) {
                final File tmp = createTempFile("gerrit_", ".zip");
                try (FileOutputStream out = new FileOutputStream(tmp)) {
                    final byte[] buf = new byte[4096];
                    int n;
                    while ((n = in.read(buf, 0, buf.length)) > 0) {
                        out.write(buf, 0, n);
                    }
                }
                return tmp;
            }
        } catch (IOException e) {
        // Nope, that didn't work.
        // 
        }
    }
    throw new FileNotFoundException("Cannot find local copy of JAR");
}
#method_after
private static File locateMyArchive() throws FileNotFoundException {
    final ClassLoader myCL = GerritLauncher.class.getClassLoader();
    final String myName = GerritLauncher.class.getName().replace('.', '/') + ".class";
    final URL myClazz = myCL.getResource(myName);
    if (myClazz == null) {
        throw new FileNotFoundException("Cannot find JAR: no " + myName);
    }
    // 
    try {
        JarFile jar = ((JarURLConnection) myClazz.openConnection()).getJarFile();
        File path = new File(jar.getName());
        if (path.isFile()) {
            return path;
        }
    } catch (Exception e) {
    // Nope, that didn't work. Try a different method.
    // 
    }
    // 
    if ("file".equals(myClazz.getProtocol())) {
        final File path = new File(myClazz.getPath());
        if (path.isFile() && path.getParentFile().isDirectory()) {
            throw new FileNotFoundException(NOT_ARCHIVED);
        }
    }
    // The CodeSource might be able to give us the source as a stream.
    // If so, copy it to a local file so we have random access to it.
    // 
    final CodeSource src = GerritLauncher.class.getProtectionDomain().getCodeSource();
    if (src != null) {
        try (InputStream in = src.getLocation().openStream()) {
            final File tmp = createTempFile("gerrit_", ".zip");
            try (FileOutputStream out = new FileOutputStream(tmp)) {
                final byte[] buf = new byte[4096];
                int n;
                while ((n = in.read(buf, 0, buf.length)) > 0) {
                    out.write(buf, 0, n);
                }
            }
            return tmp;
        } catch (IOException e) {
        // Nope, that didn't work.
        // 
        }
    }
    throw new FileNotFoundException("Cannot find local copy of JAR");
}
#end_block

#method_before
private static String readPegdownCss(AtomicBoolean file) throws IOException {
    String name = "pegdown.css";
    URL url = MarkdownFormatter.class.getResource(name);
    if (url == null) {
        throw new FileNotFoundException("Resource " + name);
    }
    file.set("file".equals(url.getProtocol()));
    try (InputStream in = url.openStream()) {
        try (TemporaryBuffer.Heap tmp = new TemporaryBuffer.Heap(128 * 1024)) {
            tmp.copy(in);
            return new String(tmp.toByteArray(), "UTF-8");
        }
    }
}
#method_after
private static String readPegdownCss(AtomicBoolean file) throws IOException {
    String name = "pegdown.css";
    URL url = MarkdownFormatter.class.getResource(name);
    if (url == null) {
        throw new FileNotFoundException("Resource " + name);
    }
    file.set("file".equals(url.getProtocol()));
    try (InputStream in = url.openStream();
        TemporaryBuffer.Heap tmp = new TemporaryBuffer.Heap(128 * 1024)) {
        tmp.copy(in);
        return new String(tmp.toByteArray(), "UTF-8");
    }
}
#end_block

#method_before
@Override
public void start() {
    try {
        try (ReviewDb db = schema.open()) {
            final CurrentSchemaVersion currentVer = getSchemaVersion(db);
            final int expectedVer = SchemaVersion.getBinaryVersion();
            if (currentVer == null) {
                throw new ProvisionException("Schema not yet initialized." + "  Run init to initialize the schema:\n" + "$ java -jar gerrit.war init -d " + site.site_path.toAbsolutePath());
            }
            if (currentVer.versionNbr < expectedVer) {
                throw new ProvisionException("Unsupported schema version " + currentVer.versionNbr + "; expected schema version " + expectedVer + ".  Run init to upgrade:\n" + "$ java -jar " + site.gerrit_war.toAbsolutePath() + " init -d " + site.site_path.toAbsolutePath());
            } else if (currentVer.versionNbr > expectedVer) {
                throw new ProvisionException("Unsupported schema version " + currentVer.versionNbr + "; expected schema version " + expectedVer + ". Downgrade is not supported.");
            }
        }
    } catch (OrmException e) {
        throw new ProvisionException("Cannot read schema_version", e);
    }
}
#method_after
@Override
public void start() {
    try (ReviewDb db = schema.open()) {
        final CurrentSchemaVersion currentVer = getSchemaVersion(db);
        final int expectedVer = SchemaVersion.getBinaryVersion();
        if (currentVer == null) {
            throw new ProvisionException("Schema not yet initialized." + "  Run init to initialize the schema:\n" + "$ java -jar gerrit.war init -d " + site.site_path.toAbsolutePath());
        }
        if (currentVer.versionNbr < expectedVer) {
            throw new ProvisionException("Unsupported schema version " + currentVer.versionNbr + "; expected schema version " + expectedVer + ".  Run init to upgrade:\n" + "$ java -jar " + site.gerrit_war.toAbsolutePath() + " init -d " + site.site_path.toAbsolutePath());
        } else if (currentVer.versionNbr > expectedVer) {
            throw new ProvisionException("Unsupported schema version " + currentVer.versionNbr + "; expected schema version " + expectedVer + ". Downgrade is not supported.");
        }
    } catch (OrmException e) {
        throw new ProvisionException("Cannot read schema_version", e);
    }
}
#end_block

#method_before
@Override
public RepositoryStatistics apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    try {
        try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
            GarbageCollectCommand gc = Git.wrap(repo).gc();
            return new RepositoryStatistics(gc.getStatistics());
        } catch (GitAPIException e) {
            throw new ResourceConflictException(e.getMessage());
        } catch (JGitInternalException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    } catch (IOException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#method_after
@Override
public RepositoryStatistics apply(ProjectResource rsrc) throws ResourceNotFoundException, ResourceConflictException {
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        GarbageCollectCommand gc = Git.wrap(repo).gc();
        return new RepositoryStatistics(gc.getStatistics());
    } catch (GitAPIException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (JGitInternalException e) {
        throw new ResourceConflictException(e.getMessage());
    } catch (IOException e) {
        throw new ResourceNotFoundException(rsrc.getName());
    }
}
#end_block

#method_before
private boolean isRevisionOutOfDate() {
    try {
        try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
            Ref ref = git.getRef(RefNames.REFS_CONFIG);
            if (ref == null || ref.getObjectId() == null) {
                return true;
            }
            return !ref.getObjectId().equals(config.getRevision());
        }
    } catch (IOException gone) {
        return true;
    }
}
#method_after
private boolean isRevisionOutOfDate() {
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        Ref ref = git.getRefDatabase().exactRef(RefNames.REFS_CONFIG);
        if (ref == null || ref.getObjectId() == null) {
            return true;
        }
        return !ref.getObjectId().equals(config.getRevision());
    } catch (IOException gone) {
        return true;
    }
}
#end_block

#method_before
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try {
        try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
            cfg.load(git);
        }
    } catch (IOException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#method_after
public ProjectLevelConfig getConfig(String fileName) {
    if (configs.containsKey(fileName)) {
        return configs.get(fileName);
    }
    ProjectLevelConfig cfg = new ProjectLevelConfig(fileName, this);
    try (Repository git = gitMgr.openRepository(getProject().getNameKey())) {
        cfg.load(git);
    } catch (IOException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    } catch (ConfigInvalidException e) {
        log.warn("Failed to load " + fileName + " for " + getProject().getName(), e);
    }
    configs.put(fileName, cfg);
    return cfg;
}
#end_block

#method_before
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = MagicBranch.getDestBranchName(cmd.getRefName());
    if (!ref.startsWith(Constants.R_REFS)) {
        ref = Constants.R_HEADS + ref;
    }
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#method_after
String parse(CmdLineParser clp, Repository repo, Set<String> refs) throws CmdLineException {
    String ref = RefNames.fullName(MagicBranch.getDestBranchName(cmd.getRefName()));
    int optionStart = ref.indexOf('%');
    if (0 < optionStart) {
        ListMultimap<String, String> options = LinkedListMultimap.create();
        for (String s : COMMAS.split(ref.substring(optionStart + 1))) {
            int e = s.indexOf('=');
            if (0 < e) {
                options.put(s.substring(0, e), s.substring(e + 1));
            } else {
                options.put(s, "");
            }
        }
        clp.parseOptionMap(options);
        ref = ref.substring(0, optionStart);
    }
    // Split the destination branch by branch and topic. The topic
    // suffix is entirely optional, so it might not even exist.
    String head = readHEAD(repo);
    int split = ref.length();
    for (; ; ) {
        String name = ref.substring(0, split);
        if (refs.contains(name) || name.equals(head)) {
            break;
        }
        split = name.lastIndexOf('/', split - 1);
        if (split <= Constants.R_REFS.length()) {
            return ref;
        }
    }
    if (split < ref.length()) {
        topic = Strings.emptyToNull(ref.substring(split + 1));
    }
    return ref.substring(0, split);
}
#end_block

#method_before
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            ObjectId baseHead = repo.getRef(destBranch).getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#method_after
private void parseMagicBranch(final ReceiveCommand cmd) {
    // Permit exactly one new change request per push.
    if (magicBranch != null) {
        reject(cmd, "duplicate request");
        return;
    }
    magicBranch = new MagicBranchInput(cmd, labelTypes, notesMigration);
    magicBranch.reviewer.addAll(reviewersFromCommandLine);
    magicBranch.cc.addAll(ccFromCommandLine);
    String ref;
    CmdLineParser clp = optionParserFactory.create(magicBranch);
    magicBranch.clp = clp;
    try {
        ref = magicBranch.parse(clp, repo, rp.getAdvertisedRefs().keySet());
    } catch (CmdLineException e) {
        if (!clp.wasHelpRequestedByOption()) {
            reject(cmd, e.getMessage());
            return;
        }
        // never happen
        ref = null;
    }
    if (clp.wasHelpRequestedByOption()) {
        StringWriter w = new StringWriter();
        w.write("\nHelp for refs/for/branch:\n\n");
        clp.printUsage(w, null);
        addMessage(w.toString());
        reject(cmd, "see help");
        return;
    }
    if (!rp.getAdvertisedRefs().containsKey(ref) && !ref.equals(readHEAD(repo))) {
        if (ref.startsWith(Constants.R_HEADS)) {
            String n = ref.substring(Constants.R_HEADS.length());
            reject(cmd, "branch " + n + " not found");
        } else {
            reject(cmd, ref + " not found");
        }
        return;
    }
    magicBranch.dest = new Branch.NameKey(project.getNameKey(), ref);
    magicBranch.ctl = projectControl.controlForRef(ref);
    if (!magicBranch.ctl.canWrite()) {
        reject(cmd, "project is read only");
        return;
    }
    if (magicBranch.draft) {
        if (!receiveConfig.allowDrafts) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "draft workflow is disabled");
            return;
        } else if (projectControl.controlForRef("refs/drafts/" + ref).isBlocked(Permission.PUSH)) {
            errors.put(Error.CODE_REVIEW, ref);
            reject(cmd, "cannot upload drafts");
            return;
        }
    }
    if (!magicBranch.ctl.canUpload()) {
        errors.put(Error.CODE_REVIEW, ref);
        reject(cmd, "cannot upload review");
        return;
    }
    if (magicBranch.draft && magicBranch.submit) {
        reject(cmd, "cannot submit draft");
        return;
    }
    if (magicBranch.submit && !projectControl.controlForRef(MagicBranch.NEW_CHANGE + ref).canSubmit()) {
        reject(cmd, "submit not allowed");
        return;
    }
    RevWalk walk = rp.getRevWalk();
    RevCommit tip;
    try {
        tip = walk.parseCommit(magicBranch.cmd.getNewId());
    } catch (IOException ex) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", ex);
        return;
    }
    // if %base was specified, ignore newChangeForAllNotInTarget
    if (tip.getParentCount() > 1 || magicBranch.base != null || tip.getParentCount() == 0) {
        newChangeForAllNotInTarget = false;
    }
    if (magicBranch.base != null) {
        magicBranch.baseCommit = Lists.newArrayListWithCapacity(magicBranch.base.size());
        for (ObjectId id : magicBranch.base) {
            try {
                magicBranch.baseCommit.add(walk.parseCommit(id));
            } catch (IncorrectObjectTypeException notCommit) {
                reject(cmd, "base must be a commit");
                return;
            } catch (MissingObjectException e) {
                reject(cmd, "base not found");
                return;
            } catch (IOException e) {
                log.warn(String.format("Project %s cannot read %s", project.getName(), id.name()), e);
                reject(cmd, "internal server error");
                return;
            }
        }
    } else if (newChangeForAllNotInTarget) {
        String destBranch = magicBranch.dest.get();
        try {
            Ref r = repo.getRefDatabase().exactRef(destBranch);
            if (r == null) {
                reject(cmd, destBranch + " not found");
                return;
            }
            ObjectId baseHead = r.getObjectId();
            magicBranch.baseCommit = Collections.singletonList(walk.parseCommit(baseHead));
        } catch (IOException ex) {
            log.warn(String.format("Project %s cannot read %s", project.getName(), destBranch), ex);
            reject(cmd, "internal server error");
            return;
        }
    }
    // 
    try {
        Ref targetRef = rp.getAdvertisedRefs().get(magicBranch.ctl.getRefName());
        if (targetRef == null || targetRef.getObjectId() == null) {
            // is "connected" to the branch.
            return;
        }
        final RevCommit h = walk.parseCommit(targetRef.getObjectId());
        final RevFilter oldRevFilter = walk.getRevFilter();
        try {
            walk.reset();
            walk.setRevFilter(RevFilter.MERGE_BASE);
            walk.markStart(tip);
            walk.markStart(h);
            if (walk.next() == null) {
                reject(magicBranch.cmd, "no common ancestry");
            }
        } finally {
            walk.reset();
            walk.setRevFilter(oldRevFilter);
        }
    } catch (IOException e) {
        magicBranch.cmd.setResult(REJECTED_MISSING_OBJECT);
        log.error("Invalid pack upload; one or more objects weren't sent", e);
    }
}
#end_block

#method_before
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try {
        try (Repository git = repoManager.openRepository(projectName)) {
            for (int i = 0; i < showBranch.size(); i++) {
                Ref ref = git.getRef(showBranch.get(i));
                if (ref != null && ref.getObjectId() != null && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible()) || (all && projectControl.isOwner())) {
                    result[i] = ref;
                }
            }
        }
    } catch (IOException ioe) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#method_after
private List<Ref> getBranchRefs(Project.NameKey projectName, ProjectControl projectControl) {
    Ref[] result = new Ref[showBranch.size()];
    try (Repository git = repoManager.openRepository(projectName)) {
        for (int i = 0; i < showBranch.size(); i++) {
            Ref ref = git.getRef(showBranch.get(i));
            if (ref != null && ref.getObjectId() != null && (projectControl.controlForRef(ref.getLeaf().getName()).isVisible()) || (all && projectControl.isOwner())) {
                result[i] = ref;
            }
        }
    } catch (IOException ioe) {
    // Fall through and return what is available.
    }
    return Arrays.asList(result);
}
#end_block

#method_before
public void publish(ChangeEdit edit) throws AuthException, NoSuchChangeException, IOException, InvalidChangeOperationException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        Change updatedChange = insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet));
        // TODO(davido): This should happen in the same BatchRefUpdate.
        deleteRef(repo, edit);
        indexer.index(db.get(), updatedChange);
    }
}
#method_after
public void publish(ChangeEdit edit) throws NoSuchChangeException, IOException, OrmException, ResourceConflictException {
    Change change = edit.getChange();
    try (Repository repo = gitManager.openRepository(change.getProject());
        RevWalk rw = new RevWalk(repo);
        ObjectInserter inserter = repo.newObjectInserter()) {
        PatchSet basePatchSet = edit.getBasePatchSet();
        if (!basePatchSet.getId().equals(change.currentPatchSetId())) {
            throw new ResourceConflictException("only edit for current patch set can be published");
        }
        try {
            Change updatedChange = insertPatchSet(edit, change, repo, rw, basePatchSet, squashEdit(rw, inserter, edit.getEditCommit(), basePatchSet));
            // TODO(davido): This should happen in the same BatchRefUpdate.
            deleteRef(repo, edit);
            indexer.index(db.get(), updatedChange);
        } catch (InvalidChangeOperationException e) {
            throw new ResourceConflictException(e.getMessage());
        }
    }
}
#end_block

#method_before
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#method_after
@Override
public BranchInfo apply(ProjectResource rsrc, Input input) throws BadRequestException, AuthException, ResourceConflictException, IOException {
    if (input == null) {
        input = new Input();
    }
    if (input.ref != null && !ref.equals(input.ref)) {
        throw new BadRequestException("ref must match URL");
    }
    if (input.revision == null) {
        input.revision = Constants.HEAD;
    }
    while (ref.startsWith("/")) {
        ref = ref.substring(1);
    }
    ref = RefNames.fullName(ref);
    if (!Repository.isValidRefName(ref)) {
        throw new BadRequestException("invalid branch name \"" + ref + "\"");
    }
    if (MagicBranch.isMagicBranch(ref)) {
        throw new BadRequestException("not allowed to create branches under \"" + MagicBranch.getMagicRefNamePrefix(ref) + "\"");
    }
    final Branch.NameKey name = new Branch.NameKey(rsrc.getNameKey(), ref);
    final RefControl refControl = rsrc.getControl().controlForRef(name);
    try (Repository repo = repoManager.openRepository(rsrc.getNameKey())) {
        final ObjectId revid = parseBaseRevision(repo, rsrc.getNameKey(), input.revision);
        final RevWalk rw = verifyConnected(repo, revid);
        RevObject object = rw.parseAny(revid);
        if (ref.startsWith(Constants.R_HEADS)) {
            // 
            try {
                object = rw.parseCommit(object);
            } catch (IncorrectObjectTypeException notCommit) {
                throw new BadRequestException("\"" + input.revision + "\" not a commit");
            }
        }
        rw.reset();
        if (!refControl.canCreate(db.get(), rw, object)) {
            throw new AuthException("Cannot create \"" + ref + "\"");
        }
        try {
            final RefUpdate u = repo.updateRef(ref);
            u.setExpectedOldObjectId(ObjectId.zeroId());
            u.setNewObjectId(object.copy());
            u.setRefLogIdent(identifiedUser.get().newRefLogIdent());
            u.setRefLogMessage("created via REST from " + input.revision, false);
            final RefUpdate.Result result = u.update(rw);
            switch(result) {
                case FAST_FORWARD:
                case NEW:
                case NO_CHANGE:
                    referenceUpdated.fire(name.getParentKey(), u, ReceiveCommand.Type.CREATE);
                    hooks.doRefUpdatedHook(name, u, identifiedUser.get().getAccount());
                    break;
                case LOCK_FAILURE:
                    if (repo.getRefDatabase().exactRef(ref) != null) {
                        throw new ResourceConflictException("branch \"" + ref + "\" already exists");
                    }
                    String refPrefix = getRefPrefix(ref);
                    while (!Constants.R_HEADS.equals(refPrefix)) {
                        if (repo.getRefDatabase().exactRef(refPrefix) != null) {
                            throw new ResourceConflictException("Cannot create branch \"" + ref + "\" since it conflicts with branch \"" + refPrefix + "\".");
                        }
                        refPrefix = getRefPrefix(refPrefix);
                    }
                // $FALL-THROUGH$
                default:
                    {
                        throw new IOException(result.name());
                    }
            }
            BranchInfo info = new BranchInfo();
            info.ref = ref;
            info.revision = revid.getName();
            info.canDelete = refControl.canDelete() ? true : null;
            return info;
        } catch (IOException err) {
            log.error("Cannot create branch \"" + name + "\"", err);
            throw err;
        }
    } catch (InvalidRevisionException e) {
        throw new BadRequestException("invalid revision \"" + input.revision + "\"");
    }
}
#end_block

#method_before
private RevWalk verifyConnected(final Repository repo, final ObjectId revid) throws InvalidRevisionException {
    try {
        final ObjectWalk rw = new ObjectWalk(repo);
        try {
            rw.markStart(rw.parseCommit(revid));
        } catch (IncorrectObjectTypeException err) {
            throw new InvalidRevisionException();
        }
        RefDatabase refDb = repo.getRefDatabase();
        Iterable<Ref> refs = Iterables.concat(refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values());
        Ref rc = refDb.getRef(RefNames.REFS_CONFIG);
        if (rc != null) {
            refs = Iterables.concat(refs, Collections.singleton(rc));
        }
        for (Ref r : refs) {
            try {
                rw.markUninteresting(rw.parseAny(r.getObjectId()));
            } catch (MissingObjectException err) {
                continue;
            }
        }
        rw.checkConnectivity();
        return rw;
    } catch (IncorrectObjectTypeException err) {
        throw new InvalidRevisionException();
    } catch (MissingObjectException err) {
        throw new InvalidRevisionException();
    } catch (IOException err) {
        log.error("Repository \"" + repo.getDirectory() + "\" may be corrupt; suggest running git fsck", err);
        throw new InvalidRevisionException();
    }
}
#method_after
private RevWalk verifyConnected(final Repository repo, final ObjectId revid) throws InvalidRevisionException {
    try {
        final ObjectWalk rw = new ObjectWalk(repo);
        try {
            rw.markStart(rw.parseCommit(revid));
        } catch (IncorrectObjectTypeException err) {
            throw new InvalidRevisionException();
        }
        RefDatabase refDb = repo.getRefDatabase();
        Iterable<Ref> refs = Iterables.concat(refDb.getRefs(Constants.R_HEADS).values(), refDb.getRefs(Constants.R_TAGS).values());
        Ref rc = refDb.exactRef(RefNames.REFS_CONFIG);
        if (rc != null) {
            refs = Iterables.concat(refs, Collections.singleton(rc));
        }
        for (Ref r : refs) {
            try {
                rw.markUninteresting(rw.parseAny(r.getObjectId()));
            } catch (MissingObjectException err) {
                continue;
            }
        }
        rw.checkConnectivity();
        return rw;
    } catch (IncorrectObjectTypeException err) {
        throw new InvalidRevisionException();
    } catch (MissingObjectException err) {
        throw new InvalidRevisionException();
    } catch (IOException err) {
        log.error("Repository \"" + repo.getDirectory() + "\" may be corrupt; suggest running git fsck", err);
        throw new InvalidRevisionException();
    }
}
#end_block

#method_before
@Override
public Iterable<AccountGroup> all() {
    try {
        try (ReviewDb db = schema.open()) {
            return Collections.unmodifiableList(db.accountGroups().all().toList());
        }
    } catch (OrmException e) {
        log.warn("Cannot list internal groups", e);
        return Collections.emptyList();
    }
}
#method_after
@Override
public Iterable<AccountGroup> all() {
    try (ReviewDb db = schema.open()) {
        return Collections.unmodifiableList(db.accountGroups().all().toList());
    } catch (OrmException e) {
        log.warn("Cannot list internal groups", e);
        return Collections.emptyList();
    }
}
#end_block

#method_before
protected Directory readIndexDirectory() throws IOException {
    Directory dir = new RAMDirectory();
    byte[] buffer = new byte[4096];
    InputStream index = getClass().getResourceAsStream(Constants.INDEX_ZIP);
    if (index == null) {
        log.warn("No index available");
        return null;
    }
    try (ZipInputStream zip = new ZipInputStream(index)) {
        ZipEntry entry;
        while ((entry = zip.getNextEntry()) != null) {
            IndexOutput out = dir.createOutput(entry.getName(), null);
            int count;
            while ((count = zip.read(buffer)) != -1) {
                out.writeBytes(buffer, count);
            }
            out.close();
        }
    }
    // We must NOT call dir.close() here, as DirectoryReader.open() expects an opened directory.
    return dir;
}
#method_after
protected Directory readIndexDirectory() throws IOException {
    Directory dir = new RAMDirectory();
    byte[] buffer = new byte[4096];
    InputStream index = getClass().getResourceAsStream(Constants.INDEX_ZIP);
    if (index == null) {
        log.warn("No index available");
        return null;
    }
    try (ZipInputStream zip = new ZipInputStream(index)) {
        ZipEntry entry;
        while ((entry = zip.getNextEntry()) != null) {
            try (IndexOutput out = dir.createOutput(entry.getName(), null)) {
                int count;
                while ((count = zip.read(buffer)) != -1) {
                    out.writeBytes(buffer, count);
                }
            }
        }
    }
    // We must NOT call dir.close() here, as DirectoryReader.open() expects an opened directory.
    return dir;
}
#end_block

#method_before
@Override
public Response<?> apply(ChangeResource rsrc, Publish.Input in) throws AuthException, ResourceConflictException, NoSuchChangeException, IOException, OrmException, BadRequestException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    try {
        editUtil.publish(edit.get());
    } catch (InvalidChangeOperationException e) {
        throw new BadRequestException(e.getMessage());
    }
    return Response.none();
}
#method_after
@Override
public Response<?> apply(ChangeResource rsrc, Publish.Input in) throws AuthException, ResourceConflictException, NoSuchChangeException, IOException, OrmException {
    Optional<ChangeEdit> edit = editUtil.byChange(rsrc.getChange());
    if (!edit.isPresent()) {
        throw new ResourceConflictException(String.format("no edit exists for change %s", rsrc.getChange().getChangeId()));
    }
    editUtil.publish(edit.get());
    return Response.none();
}
#end_block

#method_before
@Override
public Rule[] inlinePluginRules() {
    return new Rule[] { namedAnchor(), namedAnchor2() };
}
#method_after
@Override
public Rule[] inlinePluginRules() {
    return new Rule[] { namedAnchorHtmlStyle(), namedAnchorMarkdownExtensionStyle() };
}
#end_block

#method_before
private static Timestamp parseTimestamp(byte[] note, MutableInteger curr, Change.Id changeId, Charset enc) throws ConfigInvalidException {
    int endOfLine = RawParseUtils.nextLF(note, curr.value);
    Timestamp commentTime;
    String dateString = RawParseUtils.decode(enc, note, curr.value, endOfLine - 1);
    Date dateParsed;
    try {
        dateParsed = GitDateParser.parse(dateString, null, Locale.US);
    } catch (ParseException e) {
        throw new ConfigInvalidException("could not parse comment timestamp", e);
    }
    commentTime = new Timestamp(dateParsed.getTime());
    curr.value = endOfLine;
    return checkResult(commentTime, "comment timestamp", changeId);
}
#method_after
private static Timestamp parseTimestamp(byte[] note, MutableInteger curr, Change.Id changeId, Charset enc) throws ConfigInvalidException {
    int endOfLine = RawParseUtils.nextLF(note, curr.value);
    Timestamp commentTime;
    String dateString = RawParseUtils.decode(enc, note, curr.value, endOfLine - 1);
    try {
        commentTime = new Timestamp(GitDateParser.parse(dateString, null, Locale.US).getTime());
    } catch (ParseException e) {
        throw new ConfigInvalidException("could not parse comment timestamp", e);
    }
    curr.value = endOfLine;
    return checkResult(commentTime, "comment timestamp", changeId);
}
#end_block

#method_before
public void writeCommentsToNoteMap(NoteMap noteMap, Map<RevId, List<PatchLineComment>> allComments, ObjectInserter inserter) throws IOException {
    for (Map.Entry<RevId, List<PatchLineComment>> e : allComments.entrySet()) {
        List<PatchLineComment> comments = e.getValue();
        ObjectId commit = ObjectId.fromString(e.getKey().get());
        if (comments.isEmpty()) {
            noteMap.remove(commit);
            continue;
        }
        Collections.sort(comments, ChangeNotes.PLC_ORDER);
        // We allow comments for multiple commits to be written in the same
        // update, even though the rest of the metadata update is associated with
        // a single patch set.
        noteMap.set(commit, inserter.insert(OBJ_BLOB, buildNote(comments)));
    }
}
#method_after
public void writeCommentsToNoteMap(NoteMap noteMap, Map<RevId, List<PatchLineComment>> allComments, ObjectInserter inserter) throws IOException {
    for (Map.Entry<RevId, List<PatchLineComment>> e : allComments.entrySet()) {
        List<PatchLineComment> comments = e.getValue();
        ObjectId commit = ObjectId.fromString(e.getKey().get());
        if (comments.isEmpty()) {
            noteMap.remove(commit);
            continue;
        }
        Collections.sort(comments, PLC_ORDER);
        // We allow comments for multiple commits to be written in the same
        // update, even though the rest of the metadata update is associated with
        // a single patch set.
        noteMap.set(commit, inserter.insert(OBJ_BLOB, buildNote(comments)));
    }
}
#end_block

#method_before
private void makeSiteConfig(final SitePaths site, final GerritConfig gerritConfig) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // 
        if (gerritConfig.getGitDaemonUrl() != null) {
            String url = gerritConfig.getGitDaemonUrl();
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (gerritConfig.getSshdAddress() != null) {
            String sshAddr = gerritConfig.getSshdAddress();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported Gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        Path root = repoManager.getBasePath();
        p.print("$projectroot = " + quoteForPerl(root) + ";\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#method_after
private void makeSiteConfig(SitePaths site, Config cfg, SshInfo sshInfo) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // Generate URLs using anonymous git://
        // 
        String url = cfg.getString("gerrit", null, "canonicalGitUrl");
        if (url != null) {
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (sshInfo != null && !sshInfo.getHostKeys().isEmpty()) {
            String sshAddr = sshInfo.getHostKeys().get(0).getHost();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported Gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        Path root = repoManager.getBasePath();
        p.print("$projectroot = " + quoteForPerl(root) + ";\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#end_block

#method_before
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    installAuthModule();
    if (options.enableMasterFeatures()) {
        install(new UrlModule(options, authConfig));
        install(new UiRpcModule());
    }
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module(options.enableMasterFeatures()));
    if (gitWebCgiConfig.getGitwebCgi() != null) {
        install(new GitWebModule());
    }
    bind(GerritConfigProvider.class);
    bind(GerritConfig.class).toProvider(GerritConfigProvider.class);
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    bind(ProxyProperties.class).toProvider(ProxyPropertiesProvider.class);
    listener().toInstance(registerInParentInjectors());
}
#method_after
@Override
protected void configure() {
    bind(RequestScopePropagator.class).to(GuiceRequestScopePropagator.class);
    bind(HttpRequestContext.class);
    if (wantSSL) {
        install(new RequireSslFilter.Module());
    }
    install(new RunAsFilter.Module());
    installAuthModule();
    if (options.enableMasterFeatures()) {
        install(new UrlModule(options, authConfig));
        install(new UiRpcModule());
    }
    install(new GerritRequestModule());
    install(new GitOverHttpServlet.Module(options.enableMasterFeatures()));
    if (gitWebCgiConfig.getGitwebCgi() != null) {
        install(new GitWebModule());
    }
    DynamicSet.setOf(binder(), WebUiPlugin.class);
    install(new AsyncReceiveCommits.Module());
    bind(SocketAddress.class).annotatedWith(RemotePeer.class).toProvider(HttpRemotePeerProvider.class).in(RequestScoped.class);
    bind(ProxyProperties.class).toProvider(ProxyPropertiesProvider.class);
    listener().toInstance(registerInParentInjectors());
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    if (info.status() != null && info.status().equals(Change.Status.ABANDONED)) {
        sb.openSpan().setStyleName(RelatedChanges.R.css().strikedSubject());
    } else {
        sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    }
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    if (info.status() == Change.Status.ABANDONED) {
        sb.openSpan().setStyleName(RelatedChanges.R.css().strikedSubject());
    } else {
        sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    }
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebInfo gw = Gerrit.info().gitweb();
    if (gw != null && (!info.hasChangeNumber() || !info.hasRevisionNumber())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    if (info.status() == "ABANDONED" || info.status() == "MERGED") {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
        GitwebInfo gw = Gerrit.info().gitweb();
        if (gw != null) {
            sb.setAttribute("title", gw.getLinkName());
        }
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitwebInfo gw = Gerrit.info().gitweb();
    if (gw != null && (!info.hasChangeNumber() || !info.hasRevisionNumber())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (info.status() != null && !info.status().isOpen()) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", Util.toLongString(info.status()));
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
public final List<String> archives() {
    List<String> archives = new ArrayList<>();
    for (ArchiveFormatInfo f : Natives.asList(_archives())) {
        archives.add(f.get());
    }
    return archives;
}
#method_after
public final List<String> archives() {
    List<String> archives = new ArrayList<>();
    for (String f : Natives.asList(_archives())) {
        archives.add(f);
    }
    return archives;
}
#end_block

#method_before
@Override
public BinaryResult apply(RevisionResource rsrc) throws BadRequestException, IOException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    final ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    if (f == ArchiveFormat.ZIP) {
        throw new MethodNotAllowedException("zip format is disabled");
    }
    boolean close = true;
    final Repository repo = repoManager.openRepository(rsrc.getControl().getProject().getNameKey());
    try {
        final RevWalk rw = new RevWalk(repo);
        try {
            final RevCommit commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
            BinaryResult bin = new BinaryResult() {

                @Override
                public void writeTo(OutputStream out) throws IOException {
                    try {
                        new ArchiveCommand(repo).setFormat(f.name()).setTree(commit.getTree()).setOutputStream(out).call();
                    } catch (GitAPIException e) {
                        throw new IOException(e);
                    }
                }

                @Override
                public void close() throws IOException {
                    rw.close();
                    repo.close();
                }
            };
            bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName(name(f, rw, commit));
            close = false;
            return bin;
        } finally {
            if (close) {
                rw.close();
            }
        }
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#method_after
@Override
public BinaryResult apply(RevisionResource rsrc) throws BadRequestException, IOException, MethodNotAllowedException {
    if (Strings.isNullOrEmpty(format)) {
        throw new BadRequestException("format is not specified");
    }
    final ArchiveFormat f = allowedFormats.extensions.get("." + format);
    if (f == null) {
        throw new BadRequestException("unknown archive format");
    }
    if (f == ArchiveFormat.ZIP) {
        throw new MethodNotAllowedException("zip format is disabled");
    }
    boolean close = true;
    final Repository repo = repoManager.openRepository(rsrc.getControl().getProject().getNameKey());
    try {
        final RevCommit commit;
        String name;
        try (RevWalk rw = new RevWalk(repo)) {
            commit = rw.parseCommit(ObjectId.fromString(rsrc.getPatchSet().getRevision().get()));
            name = name(f, rw, commit);
        }
        BinaryResult bin = new BinaryResult() {

            @Override
            public void writeTo(OutputStream out) throws IOException {
                try {
                    new ArchiveCommand(repo).setFormat(f.name()).setTree(commit.getTree()).setOutputStream(out).call();
                } catch (GitAPIException e) {
                    throw new IOException(e);
                }
            }

            @Override
            public void close() throws IOException {
                repo.close();
            }
        };
        bin.disableGzip().setContentType(f.getMimeType()).setAttachmentName(name);
        close = false;
        return bin;
    } finally {
        if (close) {
            repo.close();
        }
    }
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    String url = Gerrit.getServerInfo().auth().httpPasswordUrl();
    if (url != null) {
        Anchor link = new Anchor();
        link.setText(Util.C.linkObtainPassword());
        link.setHref(url);
        link.setTarget("_blank");
        add(link);
        return;
    }
    password = new CopyableLabel("");
    password.addStyleName(Gerrit.RESOURCES.css().accountPassword());
    generatePassword = new Button(Util.C.buttonGeneratePassword());
    generatePassword.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doGeneratePassword();
        }
    });
    clearPassword = new Button(Util.C.buttonClearPassword());
    clearPassword.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doClearPassword();
        }
    });
    final Grid userInfo = new Grid(2, 2);
    final CellFormatter fmt = userInfo.getCellFormatter();
    userInfo.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    userInfo.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    add(userInfo);
    row(userInfo, 0, Util.C.userName(), new UsernameField());
    row(userInfo, 1, Util.C.password(), password);
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel buttons = new FlowPanel();
    buttons.add(generatePassword);
    buttons.add(clearPassword);
    add(buttons);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    String url = Gerrit.info().auth().httpPasswordUrl();
    if (url != null) {
        Anchor link = new Anchor();
        link.setText(Util.C.linkObtainPassword());
        link.setHref(url);
        link.setTarget("_blank");
        add(link);
        return;
    }
    password = new CopyableLabel("");
    password.addStyleName(Gerrit.RESOURCES.css().accountPassword());
    generatePassword = new Button(Util.C.buttonGeneratePassword());
    generatePassword.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doGeneratePassword();
        }
    });
    clearPassword = new Button(Util.C.buttonClearPassword());
    clearPassword.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            doClearPassword();
        }
    });
    final Grid userInfo = new Grid(2, 2);
    final CellFormatter fmt = userInfo.getCellFormatter();
    userInfo.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    userInfo.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    add(userInfo);
    row(userInfo, 0, Util.C.userName(), new UsernameField());
    row(userInfo, 1, Util.C.password(), password);
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(1, 0, Gerrit.RESOURCES.css().bottomheader());
    final FlowPanel buttons = new FlowPanel();
    buttons.add(generatePassword);
    buttons.add(clearPassword);
    add(buttons);
}
#end_block

#method_before
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (AccountFieldNameInfo f : Natives.asList(_editableAccountFields())) {
        fields.add(f.get());
    }
    return fields;
}
#method_after
public final List<Account.FieldName> editableAccountFields() {
    List<Account.FieldName> fields = new ArrayList<>();
    for (String f : Natives.asList(_editableAccountFields())) {
        fields.add(Account.FieldName.valueOf(f));
    }
    return fields;
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            RpcStatus.INSTANCE = new RpcStatus();
            ConfigServerApi.serverInfo(new GerritCallback<ServerInfo>() {

                @Override
                public void onSuccess(ServerInfo info) {
                    myServerInfo = info;
                    onModuleLoad2(result);
                }
            });
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = getServerInfo().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
protected void onInitUI() {
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    nameTxt = new NpTextBox();
    nameTxt.setVisibleLength(60);
    nameTxt.setReadOnly(!canEditFullName());
    emailPick = new ListBox();
    final Grid infoPlainText = new Grid(2, 2);
    infoPlainText.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoPlainText.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    body.add(infoPlainText);
    registerNewEmail = new Button(Util.C.buttonOpenRegisterNewEmail());
    registerNewEmail.setEnabled(false);
    registerNewEmail.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doRegisterNewEmail();
        }
    });
    final FlowPanel emailLine = new FlowPanel();
    emailLine.add(emailPick);
    if (canRegisterNewEmail()) {
        emailLine.add(registerNewEmail);
    }
    int row = 0;
    if (!Gerrit.getServerInfo().auth().canEdit(FieldName.USER_NAME) && Gerrit.getServerInfo().auth().siteHasUsernames()) {
        infoPlainText.resizeRows(infoPlainText.getRowCount() + 1);
        row(infoPlainText, row++, Util.C.userName(), new UsernameField());
    }
    if (!canEditFullName()) {
        FlowPanel nameLine = new FlowPanel();
        nameLine.add(nameTxt);
        if (Gerrit.getServerInfo().auth().editFullNameUrl() != null) {
            Button edit = new Button(Util.C.linkEditFullName());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    Window.open(Gerrit.getServerInfo().auth().editFullNameUrl(), "_blank", null);
                }
            });
            nameLine.add(edit);
        }
        Button reload = new Button(Util.C.linkReloadContact());
        reload.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                Window.Location.replace(Gerrit.loginRedirect(PageLinks.SETTINGS_CONTACT));
            }
        });
        nameLine.add(reload);
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameLine);
    } else {
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameTxt);
    }
    row(infoPlainText, row++, Util.C.contactFieldEmail(), emailLine);
    infoPlainText.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave(null);
        }
    });
    emailPick.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            final int idx = emailPick.getSelectedIndex();
            final String v = 0 <= idx ? emailPick.getValue(idx) : null;
            if (Util.C.buttonOpenRegisterNewEmail().equals(v)) {
                for (int i = 0; i < emailPick.getItemCount(); i++) {
                    if (currentEmail.equals(emailPick.getValue(i))) {
                        emailPick.setSelectedIndex(i);
                        break;
                    }
                }
                doRegisterNewEmail();
            } else {
                save.setEnabled(true);
            }
        }
    });
}
#method_after
protected void onInitUI() {
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    nameTxt = new NpTextBox();
    nameTxt.setVisibleLength(60);
    nameTxt.setReadOnly(!canEditFullName());
    emailPick = new ListBox();
    final Grid infoPlainText = new Grid(2, 2);
    infoPlainText.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    infoPlainText.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    body.add(infoPlainText);
    registerNewEmail = new Button(Util.C.buttonOpenRegisterNewEmail());
    registerNewEmail.setEnabled(false);
    registerNewEmail.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doRegisterNewEmail();
        }
    });
    final FlowPanel emailLine = new FlowPanel();
    emailLine.add(emailPick);
    if (canRegisterNewEmail()) {
        emailLine.add(registerNewEmail);
    }
    int row = 0;
    if (!Gerrit.info().auth().canEdit(FieldName.USER_NAME) && Gerrit.info().auth().siteHasUsernames()) {
        infoPlainText.resizeRows(infoPlainText.getRowCount() + 1);
        row(infoPlainText, row++, Util.C.userName(), new UsernameField());
    }
    if (!canEditFullName()) {
        FlowPanel nameLine = new FlowPanel();
        nameLine.add(nameTxt);
        if (Gerrit.info().auth().editFullNameUrl() != null) {
            Button edit = new Button(Util.C.linkEditFullName());
            edit.addClickHandler(new ClickHandler() {

                @Override
                public void onClick(ClickEvent event) {
                    Window.open(Gerrit.info().auth().editFullNameUrl(), "_blank", null);
                }
            });
            nameLine.add(edit);
        }
        Button reload = new Button(Util.C.linkReloadContact());
        reload.addClickHandler(new ClickHandler() {

            @Override
            public void onClick(ClickEvent event) {
                Window.Location.replace(Gerrit.loginRedirect(PageLinks.SETTINGS_CONTACT));
            }
        });
        nameLine.add(reload);
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameLine);
    } else {
        row(infoPlainText, row++, Util.C.contactFieldFullName(), nameTxt);
    }
    row(infoPlainText, row++, Util.C.contactFieldEmail(), emailLine);
    infoPlainText.getCellFormatter().addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    infoPlainText.getCellFormatter().addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
    save = new Button(Util.C.buttonSaveChanges());
    save.setEnabled(false);
    save.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            doSave(null);
        }
    });
    emailPick.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(final ChangeEvent event) {
            final int idx = emailPick.getSelectedIndex();
            final String v = 0 <= idx ? emailPick.getValue(idx) : null;
            if (Util.C.buttonOpenRegisterNewEmail().equals(v)) {
                for (int i = 0; i < emailPick.getItemCount(); i++) {
                    if (currentEmail.equals(emailPick.getValue(i))) {
                        emailPick.setSelectedIndex(i);
                        break;
                    }
                }
                doRegisterNewEmail();
            } else {
                save.setEnabled(true);
            }
        }
    });
}
#end_block

#method_before
private boolean canEditFullName() {
    return Gerrit.getServerInfo().auth().canEdit(Account.FieldName.FULL_NAME);
}
#method_after
private boolean canEditFullName() {
    return Gerrit.info().auth().canEdit(Account.FieldName.FULL_NAME);
}
#end_block

#method_before
private boolean canRegisterNewEmail() {
    return Gerrit.getServerInfo().auth().canEdit(Account.FieldName.REGISTER_NEW_EMAIL);
}
#method_after
private boolean canRegisterNewEmail() {
    return Gerrit.info().auth().canEdit(Account.FieldName.REGISTER_NEW_EMAIL);
}
#end_block

#method_before
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            AccountApi.registerEmail("self", addr, new GerritCallback<EmailInfo>() {

                @Override
                public void onSuccess(EmailInfo result) {
                    box.hide();
                    if (Gerrit.getServerInfo().auth().isDev()) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            final Account me = Gerrit.getUserAccount();
                            me.setPreferredEmail(addr);
                            onSaveSuccess(me);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    if (caught.getMessage().startsWith(EmailException.MESSAGE)) {
                        final ErrorDialog d = new ErrorDialog(caught.getMessage().substring(EmailException.MESSAGE.length()));
                        d.setText(Util.C.errorDialogTitleRegisterNewEmail());
                        d.center();
                    } else {
                        super.onFailure(caught);
                    }
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (!Gerrit.getServerInfo().auth().isDev()) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#method_after
private void doRegisterNewEmail() {
    if (!canRegisterNewEmail()) {
        return;
    }
    final AutoCenterDialogBox box = new AutoCenterDialogBox(true, true);
    final VerticalPanel body = new VerticalPanel();
    final NpTextBox inEmail = new NpTextBox();
    inEmail.setVisibleLength(60);
    final Button register = new Button(Util.C.buttonSendRegisterNewEmail());
    final Button cancel = new Button(Util.C.buttonCancel());
    final FormPanel form = new FormPanel();
    form.addSubmitHandler(new FormPanel.SubmitHandler() {

        @Override
        public void onSubmit(final SubmitEvent event) {
            event.cancel();
            final String addr = inEmail.getText().trim();
            if (!addr.contains("@")) {
                new ErrorDialog(Util.C.invalidUserEmail()).center();
                return;
            }
            inEmail.setEnabled(false);
            register.setEnabled(false);
            AccountApi.registerEmail("self", addr, new GerritCallback<EmailInfo>() {

                @Override
                public void onSuccess(EmailInfo result) {
                    box.hide();
                    if (Gerrit.info().auth().isDev()) {
                        currentEmail = addr;
                        if (emailPick.getItemCount() == 0) {
                            final Account me = Gerrit.getUserAccount();
                            me.setPreferredEmail(addr);
                            onSaveSuccess(me);
                        } else {
                            save.setEnabled(true);
                        }
                        updateEmailList();
                    }
                }

                @Override
                public void onFailure(final Throwable caught) {
                    inEmail.setEnabled(true);
                    register.setEnabled(true);
                    if (caught.getMessage().startsWith(EmailException.MESSAGE)) {
                        final ErrorDialog d = new ErrorDialog(caught.getMessage().substring(EmailException.MESSAGE.length()));
                        d.setText(Util.C.errorDialogTitleRegisterNewEmail());
                        d.center();
                    } else {
                        super.onFailure(caught);
                    }
                }
            });
        }
    });
    form.setWidget(body);
    register.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(final ClickEvent event) {
            form.submit();
        }
    });
    cancel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            box.hide();
        }
    });
    final FlowPanel buttons = new FlowPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().patchSetActions());
    buttons.add(register);
    buttons.add(cancel);
    if (!Gerrit.info().auth().isDev()) {
        body.add(new HTML(Util.C.descRegisterNewEmail()));
    }
    body.add(inEmail);
    body.add(buttons);
    box.setText(Util.C.titleRegisterNewEmail());
    box.setWidget(form);
    box.center();
    inEmail.setFocus(true);
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    HorizontalPanel h = new HorizontalPanel();
    add(h);
    VerticalPanel v = new VerticalPanel();
    v.addStyleName(Gerrit.RESOURCES.css().avatarInfoPanel());
    h.add(v);
    avatar = new AvatarImage();
    v.add(avatar);
    changeAvatar = new Anchor(Util.C.changeAvatar(), "", "_blank");
    changeAvatar.setVisible(false);
    v.add(changeAvatar);
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    info = new Grid((Gerrit.getServerInfo().auth().siteHasUsernames() ? 1 : 0) + 4, 2);
    info.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    info.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    h.add(info);
    int row = 0;
    if (Gerrit.getServerInfo().auth().siteHasUsernames()) {
        infoRow(row++, Util.C.userName());
    }
    infoRow(row++, Util.C.fullName());
    infoRow(row++, Util.C.preferredEmail());
    infoRow(row++, Util.C.registeredOn());
    infoRow(row++, Util.C.accountId());
    final CellFormatter fmt = info.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    HorizontalPanel h = new HorizontalPanel();
    add(h);
    VerticalPanel v = new VerticalPanel();
    v.addStyleName(Gerrit.RESOURCES.css().avatarInfoPanel());
    h.add(v);
    avatar = new AvatarImage();
    v.add(avatar);
    changeAvatar = new Anchor(Util.C.changeAvatar(), "", "_blank");
    changeAvatar.setVisible(false);
    v.add(changeAvatar);
    if (LocaleInfo.getCurrentLocale().isRTL()) {
        labelIdx = 1;
        fieldIdx = 0;
    } else {
        labelIdx = 0;
        fieldIdx = 1;
    }
    info = new Grid((Gerrit.info().auth().siteHasUsernames() ? 1 : 0) + 4, 2);
    info.setStyleName(Gerrit.RESOURCES.css().infoBlock());
    info.addStyleName(Gerrit.RESOURCES.css().accountInfoBlock());
    h.add(info);
    int row = 0;
    if (Gerrit.info().auth().siteHasUsernames()) {
        infoRow(row++, Util.C.userName());
    }
    infoRow(row++, Util.C.fullName());
    infoRow(row++, Util.C.preferredEmail());
    infoRow(row++, Util.C.registeredOn());
    infoRow(row++, Util.C.accountId());
    final CellFormatter fmt = info.getCellFormatter();
    fmt.addStyleName(0, 0, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(0, 1, Gerrit.RESOURCES.css().topmost());
    fmt.addStyleName(row - 1, 0, Gerrit.RESOURCES.css().bottomheader());
}
#end_block

#method_before
void display(final Account account) {
    avatar.setAccount(FormatUtil.asInfo(account), 93, false);
    new RestApi("/accounts/").id("self").view("avatar.change.url").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString changeUrl) {
            changeAvatar.setHref(changeUrl.asString());
            changeAvatar.setVisible(true);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
    int row = 0;
    if (Gerrit.getServerInfo().auth().siteHasUsernames()) {
        info.setWidget(row++, fieldIdx, new UsernameField());
    }
    info.setText(row++, fieldIdx, account.getFullName());
    info.setText(row++, fieldIdx, account.getPreferredEmail());
    info.setText(row++, fieldIdx, mediumFormat(account.getRegisteredOn()));
    info.setText(row, fieldIdx, account.getId().toString());
}
#method_after
void display(final Account account) {
    avatar.setAccount(FormatUtil.asInfo(account), 93, false);
    new RestApi("/accounts/").id("self").view("avatar.change.url").get(new AsyncCallback<NativeString>() {

        @Override
        public void onSuccess(NativeString changeUrl) {
            changeAvatar.setHref(changeUrl.asString());
            changeAvatar.setVisible(true);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    });
    int row = 0;
    if (Gerrit.info().auth().siteHasUsernames()) {
        info.setWidget(row++, fieldIdx, new UsernameField());
    }
    info.setText(row++, fieldIdx, account.getFullName());
    info.setText(row++, fieldIdx, account.getPreferredEmail());
    info.setText(row++, fieldIdx, mediumFormat(account.getRegisteredOn()));
    info.setText(row, fieldIdx, account.getId().toString());
}
#end_block

#method_before
@Override
protected Object getRowItemKey(final ChangeInfo item) {
    return item.legacy_id();
}
#method_after
@Override
protected Object getRowItemKey(final ChangeInfo item) {
    return item.legacyId();
}
#end_block

#method_before
@Override
protected void onOpenRow(final int row) {
    final ChangeInfo c = getRowItem(row);
    final Change.Id id = c.legacy_id();
    Gerrit.display(PageLinks.toChange(id));
}
#method_after
@Override
protected void onOpenRow(final int row) {
    final ChangeInfo c = getRowItem(row);
    final Change.Id id = c.legacyId();
    Gerrit.display(PageLinks.toChange(id));
}
#end_block

#method_before
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacy_id(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacy_id()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.project_name_key()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.project_name_key(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE;
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#method_after
private void populateChangeRow(final int row, final ChangeInfo c, boolean highlightUnreviewed) {
    CellFormatter fmt = table.getCellFormatter();
    if (Gerrit.isSignedIn()) {
        table.setWidget(row, C_STAR, StarredChanges.createIcon(c.legacyId(), c.starred()));
    }
    table.setWidget(row, C_ID, new TableChangeLink(String.valueOf(c.legacyId()), c));
    String subject = Util.cropSubject(c.subject());
    table.setWidget(row, C_SUBJECT, new TableChangeLink(subject, c));
    Change.Status status = c.status();
    if (status != Change.Status.NEW) {
        table.setText(row, C_STATUS, Util.toLongString(status));
    } else if (!c.mergeable()) {
        table.setText(row, C_STATUS, Util.C.changeTableNotMergeable());
    }
    if (c.owner() != null) {
        table.setWidget(row, C_OWNER, new AccountLinkPanel(c.owner(), status));
    } else {
        table.setText(row, C_OWNER, "");
    }
    table.setWidget(row, C_PROJECT, new ProjectLink(c.projectNameKey()));
    table.setWidget(row, C_BRANCH, new BranchLink(c.projectNameKey(), c.status(), c.branch(), c.topic()));
    if (Gerrit.isSignedIn() && Gerrit.getUserAccount().getGeneralPreferences().isRelativeDateInChangeTable()) {
        table.setText(row, C_LAST_UPDATE, relativeFormat(c.updated()));
    } else {
        table.setText(row, C_LAST_UPDATE, shortFormat(c.updated()));
    }
    int col = C_SIZE;
    if (Gerrit.isSignedIn() && !Gerrit.getUserAccount().getGeneralPreferences().isSizeBarInChangeTable()) {
        table.setText(row, col, Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    } else {
        table.setWidget(row, col, getSizeWidget(c));
        fmt.getElement(row, col).setTitle(Util.M.insertionsAndDeletions(c.insertions(), c.deletions()));
    }
    col++;
    for (int idx = 0; idx < labelNames.size(); idx++, col++) {
        String name = labelNames.get(idx);
        LabelInfo label = c.label(name);
        if (label == null) {
            fmt.getElement(row, col).setTitle(Gerrit.C.labelNotApplicable());
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().labelNotApplicable());
            continue;
        }
        String user;
        String info;
        ReviewCategoryStrategy reviewCategoryStrategy = Gerrit.isSignedIn() ? Gerrit.getUserAccount().getGeneralPreferences().getReviewCategoryStrategy() : ReviewCategoryStrategy.NONE;
        if (label.rejected() != null) {
            user = label.rejected().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.rejected());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.redNot()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.redNot()));
            }
        } else if (label.approved() != null) {
            user = label.approved().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.approved());
            if (info != null) {
                FlowPanel panel = new FlowPanel();
                panel.add(new Image(Gerrit.RESOURCES.greenCheck()));
                panel.add(new InlineLabel(info));
                table.setWidget(row, col, panel);
            } else {
                table.setWidget(row, col, new Image(Gerrit.RESOURCES.greenCheck()));
            }
        } else if (label.disliked() != null) {
            user = label.disliked().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.disliked());
            String vstr = String.valueOf(label._value());
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().negscore());
            table.setText(row, col, vstr);
        } else if (label.recommended() != null) {
            user = label.recommended().name();
            info = getReviewCategoryDisplayInfo(reviewCategoryStrategy, label.recommended());
            String vstr = "+" + label._value();
            if (info != null) {
                vstr = vstr + " " + info;
            }
            fmt.addStyleName(row, col, Gerrit.RESOURCES.css().posscore());
            table.setText(row, col, vstr);
        } else {
            table.clearCell(row, col);
            continue;
        }
        fmt.addStyleName(row, col, Gerrit.RESOURCES.css().singleLine());
        if (user != null) {
            // Some web browsers ignore the embedded newline; some like it;
            // so we include a space before the newline to accommodate both.
            fmt.getElement(row, col).setTitle(name + " \nby " + user);
        }
    }
    boolean needHighlight = false;
    if (highlightUnreviewed && !c.reviewed()) {
        needHighlight = true;
    }
    final Element tr = fmt.getElement(row, 0).getParentElement();
    UIObject.setStyleName(tr, Gerrit.RESOURCES.css().needsReview(), needHighlight);
    setRowItem(row, c);
}
#end_block

#method_before
private static Widget getSizeWidget(ChangeInfo c) {
    int largeChangeSize = Gerrit.getServerInfo().change().largeChange();
    int changedLines = c.insertions() + c.deletions();
    int p = 100;
    if (changedLines < largeChangeSize) {
        p = changedLines * 100 / largeChangeSize;
    }
    int width = Math.max(2, 70 * p / 100);
    int red = p >= 50 ? 255 : (int) Math.round((p) * 5.12);
    int green = p <= 50 ? 255 : (int) Math.round(256 - (p - 50) * 5.12);
    String bg = "#" + toHex(red) + toHex(green) + "00";
    SimplePanel panel = new SimplePanel();
    panel.setStyleName(Gerrit.RESOURCES.css().changeSize());
    panel.setWidth(width + "px");
    panel.getElement().getStyle().setBackgroundColor(bg);
    return panel;
}
#method_after
private static Widget getSizeWidget(ChangeInfo c) {
    int largeChangeSize = Gerrit.info().change().largeChange();
    int changedLines = c.insertions() + c.deletions();
    int p = 100;
    if (changedLines < largeChangeSize) {
        p = changedLines * 100 / largeChangeSize;
    }
    int width = Math.max(2, 70 * p / 100);
    int red = p >= 50 ? 255 : (int) Math.round((p) * 5.12);
    int green = p <= 50 ? 255 : (int) Math.round(256 - (p - 50) * 5.12);
    String bg = "#" + toHex(red) + toHex(green) + "00";
    SimplePanel panel = new SimplePanel();
    panel.setStyleName(Gerrit.RESOURCES.css().changeSize());
    panel.setWidth(width + "px");
    panel.getElement().getStyle().setBackgroundColor(bg);
    return panel;
}
#end_block

#method_before
@Override
protected void onRequestSuggestions(Request req, Callback cb) {
    if (req.getQuery().length() >= Gerrit.getServerInfo().suggest().from()) {
        _onRequestSuggestions(req, cb);
    } else {
        List<Suggestion> none = Collections.emptyList();
        cb.onSuggestionsReady(req, new Response(none));
    }
}
#method_after
@Override
protected void onRequestSuggestions(Request req, Callback cb) {
    if (req.getQuery().length() >= Gerrit.info().suggest().from()) {
        _onRequestSuggestions(req, cb);
    } else {
        List<Suggestion> none = Collections.emptyList();
        cb.onSuggestionsReady(req, new Response(none));
    }
}
#end_block

#method_before
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).is_edit()) {
        reply.setTitle(Gerrit.getServerInfo().change().replyLabel());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.getServerInfo().change().replyLabel()).closeDiv());
        if (hasDraftComments) {
            reply.setStyleName(style.highlight());
        }
        reply.setVisible(true);
    }
}
#method_after
private void initReplyButton(ChangeInfo info, String revision) {
    if (!info.revision(revision).isEdit()) {
        reply.setTitle(Gerrit.info().change().replyLabel());
        reply.setHTML(new SafeHtmlBuilder().openDiv().append(Gerrit.info().change().replyLabel()).closeDiv());
        if (hasDraftComments) {
            reply.setStyleName(style.highlight());
        }
        reply.setVisible(true);
    }
}
#end_block

#method_before
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.current_revision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacy_id(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#method_after
private void gotoSibling(final int offset) {
    if (offset > 0 && changeInfo.currentRevision().equals(revision)) {
        return;
    }
    if (offset < 0 && changeInfo.revision(revision)._number() == 1) {
        return;
    }
    JsArray<RevisionInfo> revisions = changeInfo.revisions().values();
    RevisionInfo.sortRevisionInfoByNumber(revisions);
    for (int i = 0; i < revisions.length(); i++) {
        if (revision.equals(revisions.get(i).name())) {
            if (0 <= i + offset && i + offset < revisions.length()) {
                Gerrit.display(PageLinks.toChange(new PatchSet.Id(changeInfo.legacyId(), revisions.get(i + offset)._number())));
                return;
            }
            return;
        }
    }
}
#end_block

#method_before
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacy_id(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#method_after
private void initIncludedInAction(ChangeInfo info) {
    if (info.status() == Status.MERGED) {
        includedInAction = new IncludedInAction(info.legacyId(), style, headerLine, includedIn);
        includedIn.setVisible(true);
    }
}
#end_block

#method_before
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.has_actions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initChangeAction(ChangeInfo info) {
    if (info.status() == Status.DRAFT) {
        NativeMap<ActionInfo> actions = info.hasActions() ? info.actions() : NativeMap.<ActionInfo>create();
        actions.copyKeysIntoChildren("id");
        if (actions.containsKey("/")) {
            deleteChange.setVisible(true);
            deleteChange.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.current_revision() != null && info.revisions().containsKey(info.current_revision())) {
        currentPatchSet = info.revision(info.current_revision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacy_id(), revision, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#method_after
private void initRevisionsAction(ChangeInfo info, String revision, NativeMap<ActionInfo> actions) {
    int currentPatchSet;
    if (info.currentRevision() != null && info.revisions().containsKey(info.currentRevision())) {
        currentPatchSet = info.revision(info.currentRevision())._number();
    } else {
        JsArray<RevisionInfo> revList = info.revisions().values();
        RevisionInfo.sortRevisionInfoByNumber(revList);
        currentPatchSet = revList.get(revList.length() - 1)._number();
    }
    String currentlyViewedPatchSet;
    if (info.revision(revision).id().equals("edit")) {
        currentlyViewedPatchSet = Resources.M.editPatchSet(RevisionInfo.findEditParent(info.revisions().values()));
        currentPatchSet = info.revisions().values().length() - 1;
    } else {
        currentlyViewedPatchSet = info.revision(revision).id();
    }
    patchSetsText.setInnerText(Resources.M.patchSets(currentlyViewedPatchSet, currentPatchSet));
    patchSetsAction = new PatchSetsAction(info.legacyId(), revision, edit, style, headerLine, patchSets);
    RevisionInfo revInfo = info.revision(revision);
    if (revInfo.draft()) {
        if (actions.containsKey("publish")) {
            publish.setVisible(true);
            publish.setTitle(actions.get("publish").title());
        }
        if (actions.containsKey("/")) {
            deleteRevision.setVisible(true);
            deleteRevision.setTitle(actions.get("/").title());
        }
    }
}
#end_block

#method_before
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.project_name_key()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.project_name_key()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.project_name_key()));
}
#method_after
private void initProjectLinks(final ChangeInfo info) {
    projectSettingsLink.setHref("#" + PageLinks.toProject(info.projectNameKey()));
    projectSettings.addDomHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (Hyperlink.impl.handleAsClick((Event) event.getNativeEvent())) {
                event.stopPropagation();
                event.preventDefault();
                Gerrit.display(PageLinks.toProject(info.projectNameKey()));
            }
        }
    }, ClickEvent.getType());
    projectDashboard.setText(info.project());
    projectDashboard.setTargetHistoryToken(PageLinks.toProjectDefaultDashboard(info.projectNameKey()));
}
#end_block

#method_before
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.project_name_key(), info.status(), info.branch(), null)));
}
#method_after
private void initBranchLink(ChangeInfo info) {
    branchLink.setText(info.branch());
    branchLink.setTargetHistoryToken(PageLinks.toChangeQuery(BranchLink.query(info.projectNameKey(), info.status(), info.branch(), null)));
}
#end_block

#method_before
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.is_edit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#method_after
private void initEditMode(ChangeInfo info, String revision) {
    if (Gerrit.isSignedIn() && info.status().isOpen()) {
        RevisionInfo rev = info.revision(revision);
        if (isEditModeEnabled(info, rev)) {
            editMode.setVisible(fileTableMode == FileTable.Mode.REVIEW);
            addFile.setVisible(!editMode.isVisible());
            deleteFile.setVisible(!editMode.isVisible());
            renameFile.setVisible(!editMode.isVisible());
            reviewMode.setVisible(!editMode.isVisible());
            addFileAction = new AddFileAction(changeId, info.revision(revision), style, addFile, files);
            deleteFileAction = new DeleteFileAction(changeId, info.revision(revision), style, addFile);
            renameFileAction = new RenameFileAction(changeId, info.revision(revision), style, addFile);
        } else {
            editMode.setVisible(false);
            addFile.setVisible(false);
            reviewMode.setVisible(false);
        }
        if (rev.isEdit()) {
            if (info.hasEditBasedOnCurrentPatchSet()) {
                publishEdit.setVisible(true);
            } else {
                rebaseEdit.setVisible(true);
            }
            deleteEdit.setVisible(true);
        }
    }
}
#end_block

#method_before
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.is_edit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.current_revision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#method_after
private boolean isEditModeEnabled(ChangeInfo info, RevisionInfo rev) {
    if (rev.isEdit()) {
        return true;
    }
    if (edit == null) {
        return revision.equals(info.currentRevision());
    }
    return rev._number() == RevisionInfo.findEditParent(info.revisions().values());
}
#end_block

#method_before
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.set_name(edit.commit().commit());
        info.set_edit(edit);
        if (edit.has_files()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.is_edit()) {
                info.set_current_revision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.is_edit()) {
                    info.set_current_revision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.is_edit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.project_name_key(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#method_after
private void loadConfigInfo(final ChangeInfo info, final String base) {
    info.revisions().copyKeysIntoChildren("name");
    if (edit != null) {
        edit.setName(edit.commit().commit());
        info.setEdit(edit);
        if (edit.hasFiles()) {
            edit.files().copyKeysIntoChildren("path");
        }
        info.revisions().put(edit.name(), RevisionInfo.fromEdit(edit));
        JsArray<RevisionInfo> list = info.revisions().values();
        // use the edit regardless of which patch set it is based on
        if (revision == null) {
            RevisionInfo.sortRevisionInfoByNumber(list);
            RevisionInfo rev = list.get(list.length() - 1);
            if (rev.isEdit()) {
                info.setCurrentRevision(rev.name());
            }
        } else if (revision.equals("edit") || revision.equals("0")) {
            for (int i = 0; i < list.length(); i++) {
                RevisionInfo r = list.get(i);
                if (r.isEdit()) {
                    info.setCurrentRevision(r.name());
                    break;
                }
            }
        }
    }
    final RevisionInfo rev = resolveRevisionToDisplay(info);
    final RevisionInfo b = resolveRevisionOrPatchSetId(info, base, null);
    CallbackGroup group = new CallbackGroup();
    Timestamp lastReply = myLastReply(info);
    if (rev.isEdit()) {
        loadFileList(b, rev, lastReply, group, null, null);
    } else {
        loadDiff(b, rev, lastReply, group);
    }
    loadCommit(rev, group);
    if (loaded) {
        group.done();
        return;
    }
    RevisionInfoCache.add(changeId, rev);
    ConfigInfoCache.add(info);
    ConfigInfoCache.get(info.projectNameKey(), group.addFinal(new ScreenLoadCallback<ConfigInfoCache.Entry>(this) {

        @Override
        protected void preDisplay(Entry result) {
            loaded = true;
            commentLinkProcessor = result.getCommentLinkProcessor();
            setTheme(result.getTheme());
            renderChangeInfo(info);
            loadRevisionInfo();
        }
    }));
}
#end_block

#method_before
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccountInfo()._account_id();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._account_id() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#method_after
static Timestamp myLastReply(ChangeInfo info) {
    if (Gerrit.isSignedIn() && info.messages() != null) {
        int self = Gerrit.getUserAccountInfo()._accountId();
        for (int i = info.messages().length() - 1; i >= 0; i--) {
            MessageInfo m = info.messages().get(i);
            if (m.author() != null && m.author()._accountId() == self) {
                return m.date();
            }
        }
    }
    return null;
}
#end_block

#method_before
private static NativeMap<JsArray<CommentInfo>> filterForRevision(NativeMap<JsArray<CommentInfo>> comments, int id) {
    NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
    for (String k : comments.keySet()) {
        JsArray<CommentInfo> allRevisions = comments.get(k);
        JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
        for (int i = 0; i < allRevisions.length(); i++) {
            CommentInfo c = allRevisions.get(i);
            if (c.patch_set() == id) {
                thisRevision.push(c);
            }
        }
        filtered.put(k, thisRevision);
    }
    return filtered;
}
#method_after
private static NativeMap<JsArray<CommentInfo>> filterForRevision(NativeMap<JsArray<CommentInfo>> comments, int id) {
    NativeMap<JsArray<CommentInfo>> filtered = NativeMap.create();
    for (String k : comments.keySet()) {
        JsArray<CommentInfo> allRevisions = comments.get(k);
        JsArray<CommentInfo> thisRevision = JsArray.createArray().cast();
        for (int i = 0; i < allRevisions.length(); i++) {
            CommentInfo c = allRevisions.get(i);
            if (c.patchSet() == id) {
                thisRevision.push(c);
            }
        }
        filtered.put(k, thisRevision);
    }
    return filtered;
}
#end_block

#method_before
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.is_edit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.set_commit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#method_after
private void loadCommit(final RevisionInfo rev, CallbackGroup group) {
    if (rev.isEdit()) {
        return;
    }
    ChangeApi.commitWithLinks(changeId.get(), rev.name(), group.add(new AsyncCallback<CommitInfo>() {

        @Override
        public void onSuccess(CommitInfo info) {
            rev.setCommit(info);
        }

        @Override
        public void onFailure(Throwable caught) {
        }
    }));
}
#end_block

#method_before
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.current_revision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacy_id().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#method_after
private RevisionInfo resolveRevisionToDisplay(ChangeInfo info) {
    RevisionInfo rev = resolveRevisionOrPatchSetId(info, revision, info.currentRevision());
    if (rev != null) {
        revision = rev.name();
        return rev;
    }
    // the revision is not visible to the calling user (maybe it is a draft?)
    // or the change is corrupt, take the last revision that was returned,
    // if no revision was returned display an error
    JsArray<RevisionInfo> revisions = info.revisions().values();
    if (revisions.length() > 0) {
        RevisionInfo.sortRevisionInfoByNumber(revisions);
        rev = revisions.get(revisions.length() - 1);
        revision = rev.name();
        return rev;
    } else {
        new ErrorDialog(Resources.M.changeWithNoRevisions(info.legacyId().get())).center();
        throw new IllegalStateException("no revision, cannot proceed");
    }
}
#end_block

#method_before
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacy_id()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.id_abbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.current_revision()) || info.revision(revision).is_edit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = revision.equals(info.current_revision()) && !revisionInfo.is_edit();
    if (revisionInfo.is_edit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
}
#method_after
private void renderChangeInfo(ChangeInfo info) {
    changeInfo = info;
    lastDisplayedUpdate = info.updated();
    labels.set(info);
    renderOwner(info);
    renderActionTextDate(info);
    renderDiffBaseListBox(info);
    initReplyButton(info, revision);
    initIncludedInAction(info);
    initChangeAction(info);
    initDownloadAction(info, revision);
    initProjectLinks(info);
    initBranchLink(info);
    initEditMode(info, revision);
    actions.display(info, revision);
    star.setValue(info.starred());
    permalink.setHref(ChangeLink.permalink(changeId));
    permalink.setText(String.valueOf(info.legacyId()));
    topic.set(info, revision);
    commit.set(commentLinkProcessor, info, revision);
    related.set(info, revision);
    reviewers.set(info);
    if (Gerrit.isNoteDbEnabled()) {
        hashtags.set(info);
    } else {
        setVisible(hashtagTableRow, false);
    }
    StringBuilder sb = new StringBuilder();
    sb.append(Util.M.changeScreenTitleId(info.idAbbreviated()));
    if (info.subject() != null) {
        sb.append(": ");
        sb.append(info.subject());
    }
    setWindowTitle(sb.toString());
    // render it faster.
    if (!info.status().isOpen() || !revision.equals(info.currentRevision()) || info.revision(revision).isEdit()) {
        setVisible(strategy, false);
    }
    // Properly render revision actions initially while waiting for
    // the callback to populate them correctly.
    NativeMap<ActionInfo> emptyMap = NativeMap.<ActionInfo>create();
    initRevisionsAction(info, revision, emptyMap);
    quickApprove.setVisible(false);
    actions.reloadRevisionActions(emptyMap);
    RevisionInfo revisionInfo = info.revision(revision);
    boolean current = revision.equals(info.currentRevision()) && !revisionInfo.isEdit();
    if (revisionInfo.isEdit()) {
        statusText.setInnerText(Util.C.changeEdit());
    } else if (!current) {
        statusText.setInnerText(Util.C.notCurrent());
        labels.setVisible(false);
    } else {
        statusText.setInnerText(Util.toLongString(info.status()));
    }
    if (Gerrit.isSignedIn()) {
        replyAction = new ReplyAction(info, revision, hasDraftComments, style, commentLinkProcessor, reply, quickApprove);
    }
    history.set(commentLinkProcessor, replyAction, changeId, info);
    if (current && info.status().isOpen()) {
        quickApprove.set(info, revision, replyAction);
        loadSubmitType(info.status(), isSubmittable(info));
    } else {
        quickApprove.setVisible(false);
    }
}
#end_block

#method_before
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    initRevisionsAction(info, revision, actionMap);
    actions.reloadRevisionActions(actionMap);
}
#method_after
private void renderRevisionInfo(ChangeInfo info, NativeMap<ActionInfo> actionMap) {
    initRevisionsAction(info, revision, actionMap);
    commit.setParentNotCurrent(actionMap.containsKey("rebase") && actionMap.get("rebase").enabled());
    actions.reloadRevisionActions(actionMap);
}
#end_block

#method_before
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.getServerInfo().user().anonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._account_id()), Change.Status.NEW));
}
#method_after
private void renderOwner(ChangeInfo info) {
    // TODO info card hover
    String name = info.owner().name() != null ? info.owner().name() : Gerrit.info().user().anonymousCowardName();
    if (info.owner().avatar(AvatarInfo.DEFAULT_SIZE) != null) {
        ownerPanel.insert(new AvatarImage(info.owner()), 0);
    }
    ownerLink.setText(name);
    ownerLink.setTitle(info.owner().email() != null ? info.owner().email() : name);
    ownerLink.setTargetHistoryToken(PageLinks.toAccountQuery(info.owner().name() != null ? info.owner().name() : info.owner().email() != null ? info.owner().email() : String.valueOf(info.owner()._accountId()), Change.Status.NEW));
}
#end_block

#method_before
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.getServerInfo().change().updateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#method_after
private void startPoller() {
    if (Gerrit.isSignedIn() && 0 < Gerrit.info().change().updateDelay()) {
        updateCheck = new UpdateCheckTimer(this);
        updateCheck.schedule();
        handlers.add(UserActivityMonitor.addValueChangeHandler(updateCheck));
    }
}
#end_block

#method_before
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.base_change(emptyToNull(base));
    if (Gerrit.getServerInfo().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#method_after
public static void createChange(String project, String branch, String subject, String base, AsyncCallback<ChangeInfo> cb) {
    CreateChangeInput input = CreateChangeInput.create();
    input.project(emptyToNull(project));
    input.branch(emptyToNull(branch));
    input.subject(emptyToNull(subject));
    input.baseChange(emptyToNull(base));
    if (Gerrit.info().change().allowDrafts()) {
        input.status(Change.Status.DRAFT.toString());
    }
    new RestApi("/changes/").post(input, cb);
}
#end_block

#method_before
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.wait_for_merge(true);
    call(id, commit, "submit").post(in, cb);
}
#method_after
public static void submit(int id, String commit, AsyncCallback<SubmitInfo> cb) {
    SubmitInput in = SubmitInput.create();
    in.waitForMerge(true);
    call(id, commit, "submit").post(in, cb);
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            RpcStatus.INSTANCE = new RpcStatus();
            ConfigServerApi.serverInfo(new GerritCallback<ServerInfo>() {

                @Override
                public void onSuccess(ServerInfo info) {
                    myServerInfo = info;
                    onModuleLoad2(result);
                }
            });
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#end_block

#method_before
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = getServerInfo().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = getServerInfo().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#method_after
private static void populateBottomMenu(RootPanel btmmenu, HostPageData hpd) {
    String vs = hpd.version;
    if (vs == null || vs.isEmpty()) {
        vs = "dev";
    }
    btmmenu.add(new InlineHTML(M.poweredBy(vs)));
    String reportBugUrl = info().gerrit().reportBugUrl();
    if (reportBugUrl != null) {
        String reportBugText = info().gerrit().reportBugText();
        Anchor a = new Anchor(reportBugText == null ? C.reportBug() : reportBugText, reportBugUrl);
        a.setTarget("_blank");
        a.setStyleName("");
        btmmenu.add(new InlineLabel(" | "));
        btmmenu.add(a);
    }
    btmmenu.add(new InlineLabel(" | "));
    btmmenu.add(new InlineLabel(C.keyHelp()));
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = getServerInfo().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.getServerInfo().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#method_after
private static String authorName(CommentInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.info().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#end_block

#method_before
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = new AuthInfo(authConfig, realm);
    info.change = new ChangeInfo(config);
    info.contactStore = getContactStoreInfo();
    info.download = new DownloadInfo(downloadSchemes, downloadCommands, archiveFormats);
    info.gerrit = new GerritInfo(config, allProjectsName, allUsersName);
    info.gitWeb = getGitWebInfo(gitWebConfig);
    info.suggest = new SuggestInfo(config);
    info.user = new UserInfo(anonymousCowardName);
    return info;
}
#method_after
@Override
public ServerInfo apply(ConfigResource rsrc) throws MalformedURLException {
    ServerInfo info = new ServerInfo();
    info.auth = new AuthInfo(authConfig, realm);
    info.change = getChangeInfo(config);
    info.contactStore = getContactStoreInfo();
    info.download = new DownloadInfo(downloadSchemes, downloadCommands, archiveFormats);
    info.gerrit = getGerritInfo(config, allProjectsName, allUsersName);
    info.gitWeb = getGitWebInfo(gitWebConfig);
    info.suggest = getSuggestInfo(config);
    info.user = getUserInfo(anonymousCowardName);
    return info;
}
#end_block

#method_before
private GitWebInfo getGitWebInfo(GitWebConfig cfg) {
    return cfg.getUrl() != null && cfg.getGitWebType() != null ? new GitWebInfo(cfg) : null;
}
#method_after
private GitWebInfo getGitWebInfo(GitWebConfig cfg) {
    if (cfg.getUrl() == null || cfg.getGitWebType() == null) {
        return null;
    }
    GitWebInfo info = new GitWebInfo();
    info.url = cfg.getUrl();
    info.type = cfg.getGitWebType();
    return info;
}
#end_block

#method_before
public static String nameEmail(AccountInfo info) {
    String name = info.name();
    if (name == null || name.trim().isEmpty()) {
        name = Gerrit.getServerInfo().user().anonymousCowardName();
    }
    StringBuilder b = new StringBuilder().append(name);
    if (info.email() != null) {
        b.append(" <").append(info.email()).append(">");
    } else if (info._account_id() > 0) {
        b.append(" (").append(info._account_id()).append(")");
    }
    return b.toString();
}
#method_after
public static String nameEmail(AccountInfo info) {
    String name = info.name();
    if (name == null || name.trim().isEmpty()) {
        name = Gerrit.info().user().anonymousCowardName();
    }
    StringBuilder b = new StringBuilder().append(name);
    if (info.email() != null) {
        b.append(" <").append(info.email()).append(">");
    } else if (info._accountId() > 0) {
        b.append(" (").append(info._accountId()).append(")");
    }
    return b.toString();
}
#end_block

#method_before
static String authorName(MessageInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.getServerInfo().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#method_after
static String authorName(MessageInfo info) {
    if (info.author() != null) {
        if (info.author().name() != null) {
            return info.author().name();
        }
        return Gerrit.info().user().anonymousCowardName();
    }
    return Util.C.messageNoAuthor();
}
#end_block

#method_before
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    prev = new Hyperlink(Util.C.pagedListPrev(), true, "");
    prev.setVisible(false);
    next = new Hyperlink(Util.C.pagedListNext(), true, "");
    next.setVisible(false);
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            table.setText(0, ProjectsTable.C_REPO_BROWSER, Util.C.projectRepoBrowser());
            table.getFlexCellFormatter().addStyleName(0, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataHeader());
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProject(item.name_key());
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            table.getFlexCellFormatter().addStyleName(row, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataCell());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            Image state = new Image();
            switch(k.state()) {
                case HIDDEN:
                    state.setResource(Gerrit.RESOURCES.redNot());
                    state.setTitle(Util.toLongString(k.state()));
                    table.setWidget(row, ProjectsTable.C_STATE, state);
                    break;
                case READ_ONLY:
                    state.setResource(Gerrit.RESOURCES.readOnly());
                    state.setTitle(Util.toLongString(k.state()));
                    table.setWidget(row, ProjectsTable.C_STATE, state);
                    break;
                default:
                    // Intentionally left blank, do not show an icon when active.
                    break;
            }
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new HighlightingInlineHyperlink(k.name(), link(k), match));
            table.setWidget(row, ProjectsTable.C_NAME, fp);
            table.setText(row, ProjectsTable.C_DESCRIPTION, k.description());
            addWebLinks(row, k);
            setRowItem(row, k);
        }

        private void addWebLinks(int row, ProjectInfo k) {
            GitWebInfo gitWebLink = Gerrit.getServerInfo().gitWeb();
            List<WebLinkInfo> webLinks = Natives.asList(k.web_links());
            if (gitWebLink != null || (webLinks != null && !webLinks.isEmpty())) {
                FlowPanel p = new FlowPanel();
                table.setWidget(row, ProjectsTable.C_REPO_BROWSER, p);
                if (gitWebLink != null) {
                    Anchor a = new Anchor();
                    a.setText(gitWebLink.getLinkName());
                    a.setHref(gitWebLink.toProject(k.name_key()));
                    p.add(a);
                }
                if (webLinks != null) {
                    for (WebLinkInfo weblink : webLinks) {
                        p.add(weblink.toAnchor());
                    }
                }
            }
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
    final HorizontalPanel buttons = new HorizontalPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().changeTablePrevNextLinks());
    buttons.add(prev);
    buttons.add(next);
    add(buttons);
}
#method_after
@Override
protected void onInitUI() {
    super.onInitUI();
    setPageTitle(Util.C.projectListTitle());
    initPageHeader();
    prev = new Hyperlink(Util.C.pagedListPrev(), true, "");
    prev.setVisible(false);
    next = new Hyperlink(Util.C.pagedListNext(), true, "");
    next.setVisible(false);
    projects = new ProjectsTable() {

        @Override
        protected void initColumnHeaders() {
            super.initColumnHeaders();
            table.setText(0, ProjectsTable.C_REPO_BROWSER, Util.C.projectRepoBrowser());
            table.getFlexCellFormatter().addStyleName(0, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataHeader());
        }

        @Override
        protected void onOpenRow(final int row) {
            History.newItem(link(getRowItem(row)));
        }

        private String link(final ProjectInfo item) {
            return Dispatcher.toProject(item.name_key());
        }

        @Override
        protected void insert(int row, ProjectInfo k) {
            super.insert(row, k);
            table.getFlexCellFormatter().addStyleName(row, ProjectsTable.C_REPO_BROWSER, Gerrit.RESOURCES.css().dataCell());
        }

        @Override
        protected void populate(final int row, final ProjectInfo k) {
            Image state = new Image();
            switch(k.state()) {
                case HIDDEN:
                    state.setResource(Gerrit.RESOURCES.redNot());
                    state.setTitle(Util.toLongString(k.state()));
                    table.setWidget(row, ProjectsTable.C_STATE, state);
                    break;
                case READ_ONLY:
                    state.setResource(Gerrit.RESOURCES.readOnly());
                    state.setTitle(Util.toLongString(k.state()));
                    table.setWidget(row, ProjectsTable.C_STATE, state);
                    break;
                default:
                    // Intentionally left blank, do not show an icon when active.
                    break;
            }
            FlowPanel fp = new FlowPanel();
            fp.add(new ProjectSearchLink(k.name_key()));
            fp.add(new HighlightingInlineHyperlink(k.name(), link(k), match));
            table.setWidget(row, ProjectsTable.C_NAME, fp);
            table.setText(row, ProjectsTable.C_DESCRIPTION, k.description());
            addWebLinks(row, k);
            setRowItem(row, k);
        }

        private void addWebLinks(int row, ProjectInfo k) {
            GitWebInfo gitWebLink = Gerrit.info().gitWeb();
            List<WebLinkInfo> webLinks = Natives.asList(k.webLinks());
            if (gitWebLink != null || (webLinks != null && !webLinks.isEmpty())) {
                FlowPanel p = new FlowPanel();
                table.setWidget(row, ProjectsTable.C_REPO_BROWSER, p);
                if (gitWebLink != null) {
                    Anchor a = new Anchor();
                    a.setText(gitWebLink.getLinkName());
                    a.setHref(gitWebLink.toProject(k.name_key()));
                    p.add(a);
                }
                if (webLinks != null) {
                    for (WebLinkInfo weblink : webLinks) {
                        p.add(weblink.toAnchor());
                    }
                }
            }
        }
    };
    projects.setSavePointerId(PageLinks.ADMIN_PROJECTS);
    add(projects);
    final HorizontalPanel buttons = new HorizontalPanel();
    buttons.setStyleName(Gerrit.RESOURCES.css().changeTablePrevNextLinks());
    buttons.add(prev);
    buttons.add(next);
    add(buttons);
}
#end_block

#method_before
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing);
        parentProjectBox.setProject(value.getProjectName());
        parentProjectBox.setParentProject(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    GitWebInfo c = Gerrit.getServerInfo().gitWeb();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), RefNames.REFS_CONFIG), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(editing && (!value.getOwnerOf().isEmpty() || value.canUpload()));
}
#method_after
@Override
public void setValue(ProjectAccess value) {
    // possible to add permissions to it.
    if (editing && value.isOwnerOf(AccessSection.GLOBAL_CAPABILITIES) && value.getLocal(AccessSection.GLOBAL_CAPABILITIES) == null) {
        value.getLocal().add(0, new AccessSection(AccessSection.GLOBAL_CAPABILITIES));
    }
    this.value = value;
    Project.NameKey parent = value.getInheritsFrom();
    if (parent != null) {
        inheritsFrom.getStyle().setDisplay(Display.BLOCK);
        parentProject.setText(parent.get());
        // 
        parentProject.setTargetHistoryToken(Dispatcher.toProjectAdmin(parent, ProjectScreen.ACCESS));
        parentProjectBox.setVisible(editing);
        parentProjectBox.setProject(value.getProjectName());
        parentProjectBox.setParentProject(value.getInheritsFrom());
        parentProject.setVisible(!parentProjectBox.isVisible());
    } else {
        inheritsFrom.getStyle().setDisplay(Display.NONE);
    }
    GitWebInfo c = Gerrit.info().gitWeb();
    if (value.isConfigVisible() && c != null) {
        history.getStyle().setDisplay(Display.BLOCK);
        gitweb.setText(c.getLinkName());
        gitweb.setHref(c.toFileHistory(new Branch.NameKey(value.getProjectName(), RefNames.REFS_CONFIG), "project.config"));
    } else {
        history.getStyle().setDisplay(Display.NONE);
    }
    addSection.setVisible(editing && (!value.getOwnerOf().isEmpty() || value.canUpload()));
}
#end_block

#method_before
void populate(int row, BranchInfo k) {
    GitWebInfo c = Gerrit.getServerInfo().gitWeb();
    if (k.canDelete()) {
        CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setWidget(row, 2, new InlineHTML(highlight(k.getShortName(), match)));
    if (k.revision() != null) {
        if ("HEAD".equals(k.getShortName())) {
            setHeadRevision(row, 3, k.revision());
        } else {
            table.setText(row, 3, k.revision());
        }
    } else {
        table.setText(row, 3, "");
    }
    FlowPanel actionsPanel = new FlowPanel();
    if (c != null) {
        actionsPanel.add(new Anchor(c.getLinkName(), false, c.toBranch(new Branch.NameKey(getProjectKey(), k.ref()))));
    }
    if (k.web_links() != null) {
        for (WebLinkInfo webLink : Natives.asList(k.web_links())) {
            actionsPanel.add(webLink.toAnchor());
        }
    }
    if (k.actions() != null) {
        k.actions().copyKeysIntoChildren("id");
        for (ActionInfo a : Natives.asList(k.actions().values())) {
            actionsPanel.add(new ActionButton(getProjectKey(), k, a));
        }
    }
    table.setWidget(row, 4, actionsPanel);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if (RefNames.REFS_CONFIG.equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    fmt.addStyleName(row, 4, dataCellStyle);
    setRowItem(row, k);
}
#method_after
void populate(int row, BranchInfo k) {
    GitWebInfo c = Gerrit.info().gitWeb();
    if (k.canDelete()) {
        CheckBox sel = new CheckBox();
        sel.addValueChangeHandler(updateDeleteHandler);
        table.setWidget(row, 1, sel);
        canDelete = true;
    } else {
        table.setText(row, 1, "");
    }
    table.setWidget(row, 2, new InlineHTML(highlight(k.getShortName(), match)));
    if (k.revision() != null) {
        if ("HEAD".equals(k.getShortName())) {
            setHeadRevision(row, 3, k.revision());
        } else {
            table.setText(row, 3, k.revision());
        }
    } else {
        table.setText(row, 3, "");
    }
    FlowPanel actionsPanel = new FlowPanel();
    if (c != null) {
        actionsPanel.add(new Anchor(c.getLinkName(), false, c.toBranch(new Branch.NameKey(getProjectKey(), k.ref()))));
    }
    if (k.webLinks() != null) {
        for (WebLinkInfo webLink : Natives.asList(k.webLinks())) {
            actionsPanel.add(webLink.toAnchor());
        }
    }
    if (k.actions() != null) {
        k.actions().copyKeysIntoChildren("id");
        for (ActionInfo a : Natives.asList(k.actions().values())) {
            actionsPanel.add(new ActionButton(getProjectKey(), k, a));
        }
    }
    table.setWidget(row, 4, actionsPanel);
    final FlexCellFormatter fmt = table.getFlexCellFormatter();
    String iconCellStyle = Gerrit.RESOURCES.css().iconCell();
    String dataCellStyle = Gerrit.RESOURCES.css().dataCell();
    if (RefNames.REFS_CONFIG.equals(k.getShortName()) || "HEAD".equals(k.getShortName())) {
        iconCellStyle = Gerrit.RESOURCES.css().specialBranchIconCell();
        dataCellStyle = Gerrit.RESOURCES.css().specialBranchDataCell();
        fmt.setStyleName(row, 0, iconCellStyle);
    }
    fmt.addStyleName(row, 1, iconCellStyle);
    fmt.addStyleName(row, 2, dataCellStyle);
    fmt.addStyleName(row, 3, dataCellStyle);
    fmt.addStyleName(row, 4, dataCellStyle);
    setRowItem(row, k);
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    final HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            RpcStatus.INSTANCE = new RpcStatus();
            ConfigServerApi.serverInfo(new GerritCallback<ServerInfo>() {

                @Override
                public void onSuccess(ServerInfo info) {
                    myServerInfo = info;
                    onModuleLoad2(result);
                }
            });
        }
    });
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myConfig = result.config;
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = getServerInfo().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (getConfig().isDocumentationAvailable()) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

#method_before
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.change_id());
    idText.setPreviewText(change.change_id());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
    // display the orange ball if parent has moved on (not current)
    boolean parentNotCurrent = false;
    if (revInfo.has_actions()) {
        NativeMap<ActionInfo> actions = revInfo.actions();
        if (actions.containsKey("rebase")) {
            parentNotCurrent = actions.get("rebase").enabled();
        }
    }
    UIObject.setVisible(parentNotCurrentText, parentNotCurrent);
    parentNotCurrentText.setInnerText(parentNotCurrent ? "\u25CF" : "");
}
#method_after
void set(CommentLinkProcessor commentLinkProcessor, ChangeInfo change, String revision) {
    RevisionInfo revInfo = change.revision(revision);
    CommitInfo commit = revInfo.commit();
    commitName.setText(revision);
    idText.setText("Change-Id: " + change.changeId());
    idText.setPreviewText(change.changeId());
    formatLink(commit.author(), authorPanel, authorNameEmail, authorDate, change);
    formatLink(commit.committer(), committerPanel, committerNameEmail, committerDate, change);
    text.setHTML(commentLinkProcessor.apply(new SafeHtmlBuilder().append(commit.message()).linkify()));
    setWebLinks(change, revision, revInfo);
    if (revInfo.commit().parents().length() > 1) {
        mergeCommit.setVisible(true);
    }
    setParents(change.project(), revInfo.commit().parents());
}
#end_block

#method_before
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitWebInfo gw = Gerrit.getServerInfo().gitWeb();
    if (gw != null && gw.canLink(revInfo)) {
        toAnchor(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.commit().web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            webLinkPanel.add(link.toAnchor());
        }
    }
}
#method_after
private void setWebLinks(ChangeInfo change, String revision, RevisionInfo revInfo) {
    GitWebInfo gw = Gerrit.info().gitWeb();
    if (gw != null && gw.canLink(revInfo)) {
        toAnchor(gw.toRevision(change.project(), revision), gw.getLinkName());
    }
    JsArray<WebLinkInfo> links = revInfo.commit().webLinks();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            webLinkPanel.add(link.toAnchor());
        }
    }
}
#end_block

#method_before
private void addLinks(String project, CommitInfo c, FlowPanel panel) {
    GitWebInfo gw = Gerrit.getServerInfo().gitWeb();
    if (gw != null) {
        Anchor a = new Anchor(gw.getLinkName(), gw.toRevision(project, c.commit()));
        a.setStyleName(style.parentWebLink());
        panel.add(a);
    }
    JsArray<WebLinkInfo> links = c.web_links();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            panel.add(link.toAnchor());
        }
    }
}
#method_after
private void addLinks(String project, CommitInfo c, FlowPanel panel) {
    GitWebInfo gw = Gerrit.info().gitWeb();
    if (gw != null) {
        Anchor a = new Anchor(gw.getLinkName(), gw.toRevision(project, c.commit()));
        a.setStyleName(style.parentWebLink());
        panel.add(a);
    }
    JsArray<WebLinkInfo> links = c.webLinks();
    if (links != null) {
        for (WebLinkInfo link : Natives.asList(links)) {
            panel.add(link.toAnchor());
        }
    }
}
#end_block

#method_before
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().has_avatar_info()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#method_after
private static void formatLink(GitPerson person, FlowPanel p, InlineHyperlink name, Element date, ChangeInfo change) {
    // no avatar plugin is installed
    if (change.owner().hasAvatarInfo()) {
        AvatarImage avatar;
        if (change.owner().email().equals(person.email())) {
            avatar = new AvatarImage(change.owner());
        } else {
            avatar = new AvatarImage(AccountInfo.create(0, person.name(), person.email(), null));
        }
        p.insert(avatar, 0);
    }
    name.setText(renderName(person));
    name.setTargetHistoryToken(PageLinks.toAccountQuery(owner(person), change.status()));
    date.setInnerText(FormatUtil.mediumFormat(person.date()));
}
#end_block

#method_before
private void makeSiteConfig(final SitePaths site, final GerritConfig gerritConfig) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // 
        if (gerritConfig.getGitDaemonUrl() != null) {
            String url = gerritConfig.getGitDaemonUrl();
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (gerritConfig.getSshdAddress() != null) {
            String sshAddr = gerritConfig.getSshdAddress();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported Gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        Path root = repoManager.getBasePath();
        p.print("$projectroot = " + quoteForPerl(root) + ";\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#method_after
private void makeSiteConfig(final SitePaths site, final GerritConfig gerritConfig) throws IOException {
    if (!Files.exists(site.tmp_dir)) {
        Files.createDirectories(site.tmp_dir);
    }
    Path myconf = Files.createTempFile(site.tmp_dir, "gitweb_config", ".perl");
    // To make our configuration file only readable or writable by us;
    // this reduces the chances of someone tampering with the file.
    // 
    // TODO(dborowitz): Is there a portable way to do this with NIO?
    File myconfFile = myconf.toFile();
    myconfFile.setWritable(false, false);
    myconfFile.setReadable(false, false);
    myconfFile.setExecutable(false, false);
    myconfFile.setWritable(true, true);
    myconfFile.setReadable(true, true);
    myconfFile.deleteOnExit();
    _env.set("GIT_DIR", ".");
    _env.set("GITWEB_CONFIG", myconf.toAbsolutePath().toString());
    try (PrintWriter p = new PrintWriter(Files.newBufferedWriter(myconf, UTF_8))) {
        p.print("# Autogenerated by Gerrit Code Review \n");
        p.print("# DO NOT EDIT\n");
        p.print("\n");
        // We are mounted at the same level in the context as the main
        // UI, so we can include the same header and footer scheme.
        // 
        Path hdr = site.site_header;
        if (Files.isRegularFile(hdr)) {
            p.print("$site_header = " + quoteForPerl(hdr) + ";\n");
        }
        Path ftr = site.site_footer;
        if (Files.isRegularFile(ftr)) {
            p.print("$site_footer = " + quoteForPerl(ftr) + ";\n");
        }
        // Top level should return to Gerrit's UI.
        // 
        p.print("$home_link = $ENV{'GERRIT_CONTEXT_PATH'};\n");
        p.print("$home_link_str = 'Code Review';\n");
        p.print("$favicon = 'favicon.ico';\n");
        p.print("$logo = 'gitweb-logo.png';\n");
        p.print("$javascript = 'gitweb.js';\n");
        p.print("@stylesheets = ('gitweb-default.css');\n");
        Path css = site.site_css;
        if (Files.isRegularFile(css)) {
            p.print("push @stylesheets, 'gitweb-site.css';\n");
        }
        // Try to make the title match Gerrit's normal window title
        // scheme of host followed by 'Code Review'.
        // 
        p.print("$site_name = $home_link_str;\n");
        p.print("$site_name = qq{$1 $site_name} if ");
        p.print("$ENV{'SERVER_NAME'} =~ m,^([^.]+(?:\\.[^.]+)?)(?:\\.|$),;\n");
        // Assume by default that XSS is a problem, and try to prevent it.
        // 
        p.print("$prevent_xss = 1;\n");
        // Generate URLs using smart http://
        // 
        p.print("{\n");
        p.print("  my $secure = $ENV{'HTTPS'} =~ /^ON$/i;\n");
        p.print("  my $http_url = $secure ? 'https://' : 'http://';\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_USER_NAME'}@}\n");
        p.print("    unless $ENV{'GERRIT_ANONYMOUS_READ'};\n");
        p.print("  $http_url .= $ENV{'SERVER_NAME'};\n");
        p.print("  $http_url .= qq{:$ENV{'SERVER_PORT'}}\n");
        p.print("    if (( $secure && $ENV{'SERVER_PORT'} != 443)\n");
        p.print("     || (!$secure && $ENV{'SERVER_PORT'} != 80)\n");
        p.print("    );\n");
        p.print("  $http_url .= qq{$ENV{'GERRIT_CONTEXT_PATH'}p};\n");
        p.print("  push @git_base_url_list, $http_url;\n");
        p.print("}\n");
        // 
        if (gerritConfig.getGitDaemonUrl() != null) {
            String url = gerritConfig.getGitDaemonUrl();
            if (url.endsWith("/")) {
                url = url.substring(0, url.length() - 1);
            }
            p.print("if ($ENV{'GERRIT_ANONYMOUS_READ'}) {\n");
            p.print("  push @git_base_url_list, ");
            p.print(quoteForPerl(url));
            p.print(";\n");
            p.print("}\n");
        }
        // 
        if (gerritConfig.getSshdAddress() != null) {
            String sshAddr = gerritConfig.getSshdAddress();
            p.print("if ($ENV{'GERRIT_USER_NAME'}) {\n");
            p.print("  push @git_base_url_list, join('', 'ssh://'");
            p.print(", $ENV{'GERRIT_USER_NAME'}");
            p.print(", '@'");
            if (sshAddr.startsWith("*:") || "".equals(sshAddr)) {
                p.print(", $ENV{'SERVER_NAME'}");
            }
            if (sshAddr.startsWith("*")) {
                sshAddr = sshAddr.substring(1);
            }
            p.print(", " + quoteForPerl(sshAddr));
            p.print(");\n");
            p.print("}\n");
        }
        // Link back to Gerrit (when possible, to matching review record).
        // Supported Gitweb's hash values are:
        // - (missing),
        // - HEAD,
        // - refs/heads/<branch>,
        // - refs/changes/*/<change>/*,
        // - <revision>.
        // 
        p.print("sub add_review_link {\n");
        p.print("  my $h = shift;\n");
        p.print("  my $q;\n");
        p.print("  if (!$h || $h eq 'HEAD') {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}};\n");
        p.print("  } elsif ($h =~ /^refs\\/heads\\/([-\\w]+)$/) {\n");
        p.print("    $q = qq{#q,project:$ENV{'GERRIT_PROJECT_NAME'}");
        // wrapped
        p.print("+branch:$1};\n");
        p.print("  } elsif ($h =~ /^refs\\/changes\\/\\d{2}\\/(\\d+)\\/\\d+$/) ");
        // wrapped
        p.print("{\n");
        p.print("    $q = qq{#/c/$1};\n");
        p.print("  } else {\n");
        p.print("    $q = qq{#/q/$h};\n");
        p.print("  }\n");
        p.print("  my $r = qq{$ENV{'GERRIT_CONTEXT_PATH'}$q};\n");
        p.print("  push @{$feature{'actions'}{'default'}},\n");
        p.print("      ('review',$r,'commitdiff');\n");
        p.print("}\n");
        p.print("if ($cgi->param('hb')) {\n");
        p.print("  add_review_link($cgi->param('hb'));\n");
        p.print("} elsif ($cgi->param('h')) {\n");
        p.print("  add_review_link($cgi->param('h'));\n");
        p.print("} else {\n");
        p.print("  add_review_link();\n");
        p.print("}\n");
        // If the administrator has created a site-specific gitweb_config,
        // load that before we perform any final overrides.
        // 
        Path sitecfg = site.site_gitweb;
        if (Files.isRegularFile(sitecfg)) {
            p.print("$GITWEB_CONFIG = " + quoteForPerl(sitecfg) + ";\n");
            p.print("if (-e $GITWEB_CONFIG) {\n");
            p.print("  do " + quoteForPerl(sitecfg) + ";\n");
            p.print("}\n");
        }
        Path root = repoManager.getBasePath();
        p.print("$projectroot = " + quoteForPerl(root) + ";\n");
        // Permit exporting only the project we were started for.
        // We use the name under $projectroot in case symlinks
        // were involved in the path.
        // 
        p.print("$export_auth_hook = sub {\n");
        p.print("    my $dir = shift;\n");
        p.print("    my $name = $ENV{'GERRIT_PROJECT_NAME'};\n");
        p.print("    my $allow = qq{$projectroot/$name.git};\n");
        p.print("    return $dir eq $allow;\n");
        p.print("  };\n");
        // Do not allow the administrator to enable path info, its
        // not a URL format we currently support.
        // 
        p.print("$feature{'pathinfo'}{'override'} = 0;\n");
        p.print("$feature{'pathinfo'}{'default'} = [0];\n");
        // We don't do forking, so don't allow it to be enabled.
        // 
        p.print("$feature{'forks'}{'override'} = 0;\n");
        p.print("$feature{'forks'}{'default'} = [0];\n");
    }
    myconfFile.setReadOnly();
}
#end_block

#method_before
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitWebInfo gw = Gerrit.getServerInfo().gitWeb();
    if (gw != null && (!info.has_change_number() || !info.has_revision_number())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.has_current_revision_number() && info.has_revision_number() && info._current_revision_number() != info._revision_number()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#method_after
private void renderRow(SafeHtmlBuilder sb) {
    sb.openDiv().setStyleName(RelatedChanges.R.css().row());
    sb.openSpan().setStyleName(RelatedChanges.R.css().pointer());
    sb.append(POINTER_HTML);
    sb.closeSpan();
    sb.openSpan().setStyleName(RelatedChanges.R.css().subject());
    String url = url();
    if (url != null) {
        sb.openAnchor().setAttribute("href", url);
        if (url.startsWith("#")) {
            sb.setAttribute("onclick", OPEN);
        }
        if (showProjects) {
            sb.append(info.project()).append(": ");
        }
        if (showBranches) {
            sb.append(info.branch()).append(": ");
        }
        sb.append(info.commit().subject());
        sb.closeAnchor();
    } else {
        sb.append(info.commit().subject());
    }
    sb.closeSpan();
    sb.openSpan();
    GitWebInfo gw = Gerrit.info().gitWeb();
    if (gw != null && (!info.hasChangeNumber() || !info.hasRevisionNumber())) {
        sb.setStyleName(RelatedChanges.R.css().gitweb());
        sb.setAttribute("title", gw.getLinkName());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (notConnected) {
        sb.setStyleName(RelatedChanges.R.css().indirect());
        sb.setAttribute("title", Resources.C.indirectAncestor());
        sb.append('~');
    } else if (info.hasCurrentRevisionNumber() && info.hasRevisionNumber() && info._currentRevisionNumber() != info._revisionNumber()) {
        sb.setStyleName(RelatedChanges.R.css().notCurrent());
        sb.setAttribute("title", Util.C.notCurrent());
        // Unicode 'BLACK CIRCLE'
        sb.append('\u25CF');
    } else if (showSubmittable && info.submittable()) {
        sb.setStyleName(RelatedChanges.R.css().submittable());
        sb.setAttribute("title", Util.C.submittable());
        // Unicode 'CHECK MARK'
        sb.append('\u2713');
    } else {
        sb.setStyleName(RelatedChanges.R.css().current());
    }
    sb.closeSpan();
    sb.closeDiv();
}
#end_block

#method_before
private String url() {
    if (info.has_change_number() && info.has_revision_number()) {
        PatchSet.Id id = info.patch_set_id();
        return "#" + PageLinks.toChange(id.getParentKey(), id.getId());
    }
    GitWebInfo gw = Gerrit.getServerInfo().gitWeb();
    if (gw != null && project != null) {
        return gw.toRevision(project, info.commit().commit());
    }
    return null;
}
#method_after
private String url() {
    if (info.hasChangeNumber() && info.hasRevisionNumber()) {
        PatchSet.Id id = info.patchSetId();
        return "#" + PageLinks.toChange(id.getParentKey(), id.getId());
    }
    GitWebInfo gw = Gerrit.info().gitWeb();
    if (gw != null && project != null) {
        return gw.toRevision(project, info.commit().commit());
    }
    return null;
}
#end_block

#method_before
public final boolean canLink(PatchSet ps) {
    return !ps.isDraft() || type().getLinkDrafts();
}
#method_after
public final boolean canLink(PatchSet ps) {
    return !ps.isDraft() || type().linkDrafts();
}
#end_block

#method_before
public final boolean canLink(RevisionInfo revision) {
    return revision.draft() || type().getLinkDrafts();
}
#method_after
public final boolean canLink(RevisionInfo revision) {
    return revision.draft() || type().linkDrafts();
}
#end_block

#method_before
public final String getLinkName() {
    return "(" + type().getLinkName() + ")";
}
#method_after
public final String getLinkName() {
    return "(" + type().name() + ")";
}
#end_block

#method_before
public final String toRevision(String project, String commit) {
    ParameterizedString pattern = new ParameterizedString(type().getRevision());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(project));
    p.put("commit", encode(commit));
    return url() + pattern.replace(p);
}
#method_after
public final String toRevision(String project, String commit) {
    ParameterizedString pattern = new ParameterizedString(type().revision());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(project));
    p.put("commit", encode(commit));
    return url() + pattern.replace(p);
}
#end_block

#method_before
public final String toProject(Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type().getProject());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(project.get()));
    return url() + pattern.replace(p);
}
#method_after
public final String toProject(Project.NameKey project) {
    ParameterizedString pattern = new ParameterizedString(type().project());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(project.get()));
    return url() + pattern.replace(p);
}
#end_block

#method_before
public final String toBranch(Branch.NameKey branch) {
    ParameterizedString pattern = new ParameterizedString(type().getBranch());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    return url() + pattern.replace(p);
}
#method_after
public final String toBranch(Branch.NameKey branch) {
    ParameterizedString pattern = new ParameterizedString(type().branch());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    return url() + pattern.replace(p);
}
#end_block

#method_before
public final String toFile(String project, String commit, String file) {
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(project));
    p.put("commit", encode(commit));
    p.put("file", encode(file));
    ParameterizedString pattern = (file == null || file.isEmpty()) ? new ParameterizedString(type().getRootTree()) : new ParameterizedString(type().getFile());
    return url() + pattern.replace(p);
}
#method_after
public final String toFile(String project, String commit, String file) {
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(project));
    p.put("commit", encode(commit));
    p.put("file", encode(file));
    ParameterizedString pattern = (file == null || file.isEmpty()) ? new ParameterizedString(type().rootTree()) : new ParameterizedString(type().file());
    return url() + pattern.replace(p);
}
#end_block

#method_before
public final String toFileHistory(Branch.NameKey branch, String file) {
    ParameterizedString pattern = new ParameterizedString(type().getFileHistory());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    p.put("file", encode(file));
    return url() + pattern.replace(p);
}
#method_after
public final String toFileHistory(Branch.NameKey branch, String file) {
    ParameterizedString pattern = new ParameterizedString(type().fileHistory());
    Map<String, String> p = new HashMap<>();
    p.put("project", encode(branch.getParentKey().get()));
    p.put("branch", encode(branch.get()));
    p.put("file", encode(file));
    return url() + pattern.replace(p);
}
#end_block

#method_before
private final String encode(String segment) {
    if (type().isUrlEncode()) {
        return URL.encodeQueryString(type().replacePathSeparator(segment));
    } else {
        return segment;
    }
}
#method_after
private final String encode(String segment) {
    if (type().urlEncode()) {
        return URL.encodeQueryString(type().replacePathSeparator(segment));
    } else {
        return segment;
    }
}
#end_block

#method_before
public static SafeHtml formatPath(String path, String project, String commit) {
    SafeHtmlBuilder b = new SafeHtmlBuilder();
    if (Patch.COMMIT_MSG.equals(path)) {
        return b.append(Util.C.commitMessage());
    }
    GitWebInfo gw = (project != null && commit != null) ? Gerrit.getServerInfo().gitWeb() : null;
    int s = path.lastIndexOf('/') + 1;
    if (gw != null && s > 0) {
        String base = path.substring(0, s - 1);
        b.openAnchor().setAttribute("href", gw.toFile(project, commit, base)).setAttribute("title", gw.getLinkName()).append(base).closeAnchor().append('/');
    } else {
        b.append(path.substring(0, s));
    }
    b.openElement("b");
    b.append(path.substring(s));
    b.closeElement("b");
    return b;
}
#method_after
public static SafeHtml formatPath(String path, String project, String commit) {
    SafeHtmlBuilder b = new SafeHtmlBuilder();
    if (Patch.COMMIT_MSG.equals(path)) {
        return b.append(Util.C.commitMessage());
    }
    GitWebInfo gw = (project != null && commit != null) ? Gerrit.info().gitWeb() : null;
    int s = path.lastIndexOf('/') + 1;
    if (gw != null && s > 0) {
        String base = path.substring(0, s - 1);
        b.openAnchor().setAttribute("href", gw.toFile(project, commit, base)).setAttribute("title", gw.getLinkName()).append(base).closeAnchor().append('/');
    } else {
        b.append(path.substring(0, s));
    }
    b.openElement("b");
    b.append(path.substring(s));
    b.closeElement("b");
    return b;
}
#end_block

#method_before
void setChangeInfo(ChangeInfo info) {
    GitWebInfo gw = Gerrit.getServerInfo().gitWeb();
    if (gw != null) {
        for (RevisionInfo rev : Natives.asList(info.revisions().values())) {
            if (patchSetId.getId().equals(rev.id())) {
                String c = rev.name();
                SafeHtml.setInnerHTML(filePath, formatPath(path, info.project(), c));
                SafeHtml.setInnerHTML(project, new SafeHtmlBuilder().openAnchor().setAttribute("href", gw.toFile(info.project(), c, "")).setAttribute("title", gw.getLinkName()).append(info.project()).closeAnchor());
                return;
            }
        }
    }
    project.setInnerText(info.project());
}
#method_after
void setChangeInfo(ChangeInfo info) {
    GitWebInfo gw = Gerrit.info().gitWeb();
    if (gw != null) {
        for (RevisionInfo rev : Natives.asList(info.revisions().values())) {
            if (patchSetId.getId().equals(rev.id())) {
                String c = rev.name();
                SafeHtml.setInnerHTML(filePath, formatPath(path, info.project(), c));
                SafeHtml.setInnerHTML(project, new SafeHtmlBuilder().openAnchor().setAttribute("href", gw.toFile(info.project(), c, "")).setAttribute("title", gw.getLinkName()).append(info.project()).closeAnchor());
                return;
            }
        }
    }
    project.setInnerText(info.project());
}
#end_block

#method_before
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitWebConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#method_after
@Override
protected void configure() {
    bind(EmailExpander.class).toProvider(EmailExpanderProvider.class).in(SINGLETON);
    bind(IdGenerator.class);
    bind(RulesCache.class);
    install(authModule);
    install(AccountByEmailCacheImpl.module());
    install(AccountCacheImpl.module());
    install(ChangeKindCacheImpl.module());
    install(ConflictsCacheImpl.module());
    install(GroupCacheImpl.module());
    install(GroupIncludeCacheImpl.module());
    install(MergeabilityCacheImpl.module());
    install(PatchListCacheImpl.module());
    install(ProjectCacheImpl.module());
    install(SectionSortCache.module());
    install(TagCache.module());
    install(new AccessControlModule());
    install(new CmdLineParserModule());
    install(new EmailModule());
    install(new GitModule());
    install(new GroupModule());
    install(new NoteDbModule());
    install(new PrologModule());
    install(new SshAddressesModule());
    install(ThreadLocalRequestContext.module());
    bind(AccountResolver.class);
    factory(AccountInfoCacheFactory.Factory.class);
    factory(AddReviewerSender.Factory.class);
    factory(CapabilityControl.Factory.class);
    factory(ChangeData.Factory.class);
    factory(CreateChangeSender.Factory.class);
    factory(GroupDetailFactory.Factory.class);
    factory(GroupInfoCacheFactory.Factory.class);
    factory(GroupMembers.Factory.class);
    factory(MergedSender.Factory.class);
    factory(MergeFailSender.Factory.class);
    factory(MergeUtil.Factory.class);
    factory(PatchScriptFactory.Factory.class);
    factory(PluginUser.Factory.class);
    factory(ProjectNode.Factory.class);
    factory(ProjectState.Factory.class);
    factory(RegisterNewEmailSender.Factory.class);
    factory(ReplacePatchSetSender.Factory.class);
    bind(PermissionCollection.Factory.class);
    bind(AccountVisibility.class).toProvider(AccountVisibilityProvider.class).in(SINGLETON);
    factory(ProjectOwnerGroupsProvider.Factory.class);
    bind(RepositoryConfig.class);
    bind(AuthBackend.class).to(UniversalAuthBackend.class).in(SINGLETON);
    DynamicSet.setOf(binder(), AuthBackend.class);
    bind(GroupControl.Factory.class).in(SINGLETON);
    bind(GroupControl.GenericFactory.class).in(SINGLETON);
    bind(FileTypeRegistry.class).to(MimeUtilFileTypeRegistry.class);
    bind(ToolsCatalog.class);
    bind(EventFactory.class);
    bind(TransferConfig.class);
    bind(GitWebConfig.class);
    bind(GcConfig.class);
    bind(ApprovalsUtil.class);
    bind(ChangeMergeQueue.class).in(SINGLETON);
    bind(MergeQueue.class).to(ChangeMergeQueue.class).in(SINGLETON);
    bind(RuntimeInstance.class).toProvider(VelocityRuntimeProvider.class).in(SINGLETON);
    bind(FromAddressGenerator.class).toProvider(FromAddressGeneratorProvider.class).in(SINGLETON);
    bind(Boolean.class).annotatedWith(DisableReverseDnsLookup.class).toProvider(DisableReverseDnsLookupProvider.class).in(SINGLETON);
    bind(PatchSetInfoFactory.class);
    bind(IdentifiedUser.GenericFactory.class).in(SINGLETON);
    bind(ChangeControl.GenericFactory.class);
    bind(ProjectControl.GenericFactory.class);
    bind(AccountControl.Factory.class);
    install(new AuditModule());
    install(new com.google.gerrit.server.access.Module());
    install(new com.google.gerrit.server.account.Module());
    install(new com.google.gerrit.server.api.Module());
    install(new com.google.gerrit.server.change.Module());
    install(new com.google.gerrit.server.config.Module());
    install(new com.google.gerrit.server.group.Module());
    install(new com.google.gerrit.server.project.Module());
    bind(GitReferenceUpdated.class);
    DynamicMap.mapOf(binder(), new TypeLiteral<Cache<?, ?>>() {
    });
    DynamicSet.setOf(binder(), CacheRemovalListener.class);
    DynamicMap.mapOf(binder(), CapabilityDefinition.class);
    DynamicSet.setOf(binder(), GitReferenceUpdatedListener.class);
    DynamicSet.setOf(binder(), ReceivePackInitializer.class);
    DynamicSet.setOf(binder(), PostReceiveHook.class);
    DynamicSet.setOf(binder(), PreUploadHook.class);
    DynamicSet.setOf(binder(), NewProjectCreatedListener.class);
    DynamicSet.setOf(binder(), ProjectDeletedListener.class);
    DynamicSet.setOf(binder(), GarbageCollectorListener.class);
    DynamicSet.setOf(binder(), HeadUpdatedListener.class);
    DynamicSet.setOf(binder(), UsageDataPublishedListener.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ReindexAfterUpdate.class);
    DynamicSet.bind(binder(), GitReferenceUpdatedListener.class).to(ProjectConfigEntry.UpdateChecker.class);
    DynamicSet.setOf(binder(), EventListener.class);
    DynamicSet.setOf(binder(), CommitValidationListener.class);
    DynamicSet.setOf(binder(), RefOperationValidationListener.class);
    DynamicSet.setOf(binder(), MergeValidationListener.class);
    DynamicSet.setOf(binder(), ProjectCreationValidationListener.class);
    DynamicSet.setOf(binder(), GroupCreationValidationListener.class);
    DynamicSet.setOf(binder(), HashtagValidationListener.class);
    DynamicSet.setOf(binder(), OutgoingEmailValidationListener.class);
    DynamicItem.itemOf(binder(), AvatarProvider.class);
    DynamicSet.setOf(binder(), LifecycleListener.class);
    DynamicSet.setOf(binder(), TopMenu.class);
    DynamicSet.setOf(binder(), MessageOfTheDay.class);
    DynamicMap.mapOf(binder(), DownloadScheme.class);
    DynamicMap.mapOf(binder(), DownloadCommand.class);
    DynamicMap.mapOf(binder(), ExternalIncludedIn.class);
    DynamicMap.mapOf(binder(), ProjectConfigEntry.class);
    DynamicSet.setOf(binder(), PatchSetWebLink.class);
    DynamicSet.setOf(binder(), FileWebLink.class);
    DynamicSet.setOf(binder(), DiffWebLink.class);
    DynamicSet.setOf(binder(), ProjectWebLink.class);
    DynamicSet.setOf(binder(), BranchWebLink.class);
    factory(UploadValidators.Factory.class);
    DynamicSet.setOf(binder(), UploadValidationListener.class);
    bind(AnonymousUser.class);
    factory(CommitValidators.Factory.class);
    factory(RefOperationValidators.Factory.class);
    factory(MergeValidators.Factory.class);
    factory(ProjectConfigValidator.Factory.class);
    factory(NotesBranchUtil.Factory.class);
    factory(SubmoduleSectionParser.Factory.class);
    bind(AccountManager.class);
    bind(ChangeUserName.CurrentUser.class);
    factory(ChangeUserName.Factory.class);
    bind(new TypeLiteral<List<CommentLinkInfo>>() {
    }).toProvider(CommentLinkProvider.class).in(SINGLETON);
    bind(ReloadPluginListener.class).annotatedWith(UniqueAnnotations.create()).to(PluginConfigFactory.class);
}
#end_block

#method_before
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#method_after
@Override
public void onModuleLoad() {
    UserAgent.assertNotInIFrame();
    KeyUtil.setEncoderImpl(new KeyUtil.Encoder() {

        @Override
        public String encode(String e) {
            e = URL.encodeQueryString(e);
            e = fixPathImpl(e);
            e = fixColonImpl(e);
            e = fixDoubleQuote(e);
            return e;
        }

        @Override
        public String decode(final String e) {
            return URL.decodeQueryString(e);
        }

        private native String fixPathImpl(String path);

        private native String fixColonImpl(String path);

        private native String fixDoubleQuote(String path);
    });
    initHostname();
    Window.setTitle(M.windowTitle1(myHost));
    RpcStatus.INSTANCE = new RpcStatus();
    CallbackGroup cbg = new CallbackGroup();
    getDocIndex(cbg.add(new GerritCallback<DocInfo>() {

        @Override
        public void onSuccess(DocInfo indexInfo) {
            hasDocumentation = indexInfo != null;
        }
    }));
    ConfigServerApi.serverInfo(cbg.add(new GerritCallback<ServerInfo>() {

        @Override
        public void onSuccess(ServerInfo info) {
            myServerInfo = info;
        }
    }));
    HostPageDataService hpd = GWT.create(HostPageDataService.class);
    hpd.load(cbg.addFinal(new GerritCallback<HostPageData>() {

        @Override
        public void onSuccess(final HostPageData result) {
            Document.get().getElementById("gerrit_hostpagedata").removeFromParent();
            myTheme = result.theme;
            isNoteDbEnabled = result.isNoteDbEnabled;
            if (result.account != null) {
                myAccount = result.account;
                xGerritAuth = result.xGerritAuth;
            }
            if (result.accountDiffPref != null) {
                myAccountDiffPref = result.accountDiffPref;
                applyUserPreferences();
            }
            onModuleLoad2(result);
        }
    }));
}
#end_block

#method_before
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    addDocumentationMenuBar();
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#method_after
private static void refreshMenuBar(boolean populateMyMenu) {
    menuLeft.clear();
    menuRight.clear();
    menuBars = new HashMap<>();
    boolean signedIn = isSignedIn();
    AuthInfo authInfo = info().auth();
    LinkMenuBar m;
    m = new LinkMenuBar();
    menuBars.put(GerritTopMenu.ALL.menuName, m);
    addLink(m, C.menuAllOpen(), PageLinks.toChangeQuery("status:open"));
    addLink(m, C.menuAllMerged(), PageLinks.toChangeQuery("status:merged"));
    addLink(m, C.menuAllAbandoned(), PageLinks.toChangeQuery("status:abandoned"));
    menuLeft.add(m, C.menuAll());
    if (signedIn) {
        LinkMenuBar myBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.MY.menuName, myBar);
        if (populateMyMenu) {
            AccountApi.self().view("preferences").get(createMyMenuBarCallback());
        }
        menuLeft.add(myBar, C.menuMine());
        menuLeft.selectTab(1);
    } else {
        menuLeft.selectTab(0);
    }
    patchScreen = null;
    LinkMenuBar diffBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.DIFFERENCES.menuName, diffBar);
    menuLeft.addInvisible(diffBar, C.menuDiff());
    addDiffLink(diffBar, C.menuDiffCommit(), UnifiedPatchScreen.TopView.COMMIT);
    addDiffLink(diffBar, C.menuDiffPreferences(), UnifiedPatchScreen.TopView.PREFERENCES);
    addDiffLink(diffBar, C.menuDiffPatchSets(), UnifiedPatchScreen.TopView.PATCH_SETS);
    addDiffLink(diffBar, C.menuDiffFiles(), UnifiedPatchScreen.TopView.FILES);
    final LinkMenuBar projectsBar = new LinkMenuBar();
    menuBars.put(GerritTopMenu.PROJECTS.menuName, projectsBar);
    addLink(projectsBar, C.menuProjectsList(), PageLinks.ADMIN_PROJECTS);
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsInfo(), ProjectScreen.INFO));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsBranches(), ProjectScreen.BRANCH));
    projectsBar.addItem(new ProjectLinkMenuItem(C.menuProjectsAccess(), ProjectScreen.ACCESS));
    final LinkMenuItem dashboardsMenuItem = new ProjectLinkMenuItem(C.menuProjectsDashboards(), ProjectScreen.DASHBOARDS) {

        @Override
        protected boolean match(String token) {
            return super.match(token) || (!getTargetHistoryToken().isEmpty() && ("/admin" + token).startsWith(getTargetHistoryToken()));
        }
    };
    projectsBar.addItem(dashboardsMenuItem);
    menuLeft.add(projectsBar, C.menuProjects());
    if (signedIn) {
        final LinkMenuBar peopleBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PEOPLE.menuName, peopleBar);
        final LinkMenuItem groupsListMenuItem = addLink(peopleBar, C.menuPeopleGroupsList(), PageLinks.ADMIN_GROUPS);
        menuLeft.add(peopleBar, C.menuPeople());
        final LinkMenuBar pluginsBar = new LinkMenuBar();
        menuBars.put(GerritTopMenu.PLUGINS.menuName, pluginsBar);
        AccountCapabilities.all(new GerritCallback<AccountCapabilities>() {

            @Override
            public void onSuccess(AccountCapabilities result) {
                if (result.canPerform(CREATE_PROJECT)) {
                    insertLink(projectsBar, C.menuProjectsCreate(), PageLinks.ADMIN_CREATE_PROJECT, projectsBar.getWidgetIndex(dashboardsMenuItem) + 1);
                }
                if (result.canPerform(CREATE_GROUP)) {
                    insertLink(peopleBar, C.menuPeopleGroupsCreate(), PageLinks.ADMIN_CREATE_GROUP, peopleBar.getWidgetIndex(groupsListMenuItem) + 1);
                }
                if (result.canPerform(VIEW_PLUGINS)) {
                    insertLink(pluginsBar, C.menuPluginsInstalled(), PageLinks.ADMIN_PLUGINS, 0);
                    menuLeft.insert(pluginsBar, C.menuPlugins(), menuLeft.getWidgetIndex(peopleBar) + 1);
                }
            }
        }, CREATE_PROJECT, CREATE_GROUP, VIEW_PLUGINS);
    }
    if (hasDocumentation) {
        m = new LinkMenuBar();
        menuBars.put(GerritTopMenu.DOCUMENTATION.menuName, m);
        addDocLink(m, C.menuDocumentationTOC(), "index.html");
        addDocLink(m, C.menuDocumentationSearch(), "user-search.html");
        addDocLink(m, C.menuDocumentationUpload(), "user-upload.html");
        addDocLink(m, C.menuDocumentationAccess(), "access-control.html");
        addDocLink(m, C.menuDocumentationAPI(), "rest-api.html");
        addDocLink(m, C.menuDocumentationProjectOwnerGuide(), "intro-project-owner.html");
        menuLeft.add(m, C.menuDocumentation());
    }
    if (signedIn) {
        whoAmI(!authInfo.isClientSslCertLdap());
    } else {
        switch(authInfo.authType()) {
            case CLIENT_SSL_CERT_LDAP:
                break;
            case OPENID:
                menuRight.addItem(C.menuRegister(), new Command() {

                    @Override
                    public void execute() {
                        String t = History.getToken();
                        if (t == null) {
                            t = "";
                        }
                        doSignIn(PageLinks.REGISTER + t);
                    }
                });
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OAUTH:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case OPENID_SSO:
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case HTTP:
            case HTTP_LDAP:
                if (authInfo.loginUrl() != null) {
                    String signinText = authInfo.loginText() == null ? C.menuSignIn() : authInfo.loginText();
                    menuRight.add(anchor(signinText, authInfo.loginUrl()));
                }
                break;
            case LDAP:
            case LDAP_BIND:
            case CUSTOM_EXTENSION:
                if (authInfo.registerUrl() != null) {
                    String registerText = authInfo.registerText() == null ? C.menuRegister() : authInfo.registerText();
                    menuRight.add(anchor(registerText, authInfo.registerUrl()));
                }
                menuRight.addItem(C.menuSignIn(), new Command() {

                    @Override
                    public void execute() {
                        doSignIn(History.getToken());
                    }
                });
                break;
            case DEVELOPMENT_BECOME_ANY_ACCOUNT:
                menuRight.add(anchor("Become", loginRedirect("")));
                break;
        }
    }
    ConfigServerApi.topMenus(new GerritCallback<TopMenuList>() {

        @Override
        public void onSuccess(TopMenuList result) {
            List<TopMenu> topMenuExtensions = Natives.asList(result);
            for (TopMenu menu : topMenuExtensions) {
                String name = menu.getName();
                LinkMenuBar existingBar = menuBars.get(name);
                LinkMenuBar bar = existingBar != null ? existingBar : new LinkMenuBar();
                for (TopMenuItem item : Natives.asList(menu.getItems())) {
                    addMenuLink(bar, item);
                }
                if (existingBar == null) {
                    menuBars.put(name, bar);
                    menuLeft.add(bar, name);
                }
            }
        }
    });
}
#end_block

